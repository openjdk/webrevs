{"files":[{"patch":"@@ -538,0 +538,2 @@\n+<h4 id=\"manual\">MANUAL<\/h4>\n+<p>Set to <code>true<\/code> to execute manual tests only.<\/p>\n","filename":"doc\/testing.html","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -515,0 +515,4 @@\n+#### MANUAL\n+\n+Set to `true` to execute manual tests only.\n+\n","filename":"doc\/testing.md","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-        AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n+        AOT_JDK MANUAL $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n@@ -914,1 +914,7 @@\n-  $1_JTREG_BASIC_OPTIONS += -automatic -ignore:quiet\n+  $1_JTREG_BASIC_OPTIONS += -ignore:quiet\n+\n+  ifeq ($$(JTREG_MANUAL), true)\n+    $1_JTREG_BASIC_OPTIONS += -manual\n+  else\n+    $1_JTREG_BASIC_OPTIONS += -automatic\n+  endif\n@@ -1154,0 +1160,1 @@\n+\t  $$(eval $1_PASSED := 0) \\\n","filename":"make\/RunTests.gmk","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -285,0 +285,6 @@\n+    if test \"x$TOOLCHAIN_TYPE\" = xgcc; then\n+      C_O_FLAG_LTO=\"-flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\"\n+    else\n+      C_O_FLAG_LTO=\"-flto -fno-strict-aliasing\"\n+    fi\n+\n@@ -289,0 +295,1 @@\n+      C_O_FLAG_LTO=\"${C_O_FLAG_LTO} -ffat-lto-objects\"\n@@ -320,0 +327,1 @@\n+    C_O_FLAG_LTO=\"-GL\"\n@@ -331,0 +339,1 @@\n+  CXX_O_FLAG_LTO=\"$C_O_FLAG_LTO\"\n@@ -363,0 +372,2 @@\n+  AC_SUBST(C_O_FLAG_LTO)\n+\n@@ -369,0 +380,1 @@\n+  AC_SUBST(CXX_O_FLAG_LTO)\n","filename":"make\/autoconf\/flags-cflags.m4","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    # add --icf=all (Identical Code Folding â€” merges identical functions)\n@@ -54,0 +55,6 @@\n+    if test \"x$LINKER_TYPE\" = \"xgold\"; then\n+      if test x$DEBUG_LEVEL = xrelease; then\n+        BASIC_LDFLAGS=\"$BASIC_LDFLAGS -Wl,--icf=all\"\n+      fi\n+    fi\n+\n@@ -64,0 +71,1 @@\n+    LDFLAGS_LTO=\"-flto=auto -fuse-linker-plugin -fno-strict-aliasing\"\n@@ -71,0 +79,1 @@\n+    LDFLAGS_LTO=\"-flto=auto -fuse-linker-plugin -fno-strict-aliasing\"\n@@ -90,0 +99,1 @@\n+    LDFLAGS_LTO=\"-LTCG:INCREMENTAL\"\n@@ -151,0 +161,1 @@\n+  AC_SUBST(LDFLAGS_LTO)\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -516,0 +516,1 @@\n+C_O_FLAG_LTO := @C_O_FLAG_LTO@\n@@ -522,0 +523,1 @@\n+CXX_O_FLAG_LTO  := @CXX_O_FLAG_LTO@\n@@ -590,0 +592,3 @@\n+# LDFLAGS specific to link time optimization\n+LDFLAGS_LTO := @LDFLAGS_LTO@\n+\n","filename":"make\/autoconf\/spec.gmk.template","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -519,0 +519,1 @@\n+      LINKER_TYPE=gold\n","filename":"make\/autoconf\/toolchain.m4","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+#   LINK_TIME_OPTIMIZATION if set to true, enables link time optimization\n","filename":"make\/common\/NativeCompilation.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -197,0 +197,5 @@\n+  ifeq (true, $$($1_LINK_TIME_OPTIMIZATION))\n+    $1_EXTRA_CFLAGS += $(C_O_FLAG_LTO)\n+    $1_EXTRA_CXXFLAGS += $(CXX_O_FLAG_LTO)\n+  endif\n+\n@@ -225,0 +230,4 @@\n+  ifeq ($$($1_LINK_TIME_OPTIMIZATION), true)\n+    $1_EXTRA_LDFLAGS += $(LDFLAGS_LTO)\n+  endif\n+\n","filename":"make\/common\/native\/Flags.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+    LINK_TIME_OPTIMIZATION := $(JVM_LTO), \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -177,14 +177,3 @@\n-  ifeq ($(call isCompiler, gcc), true)\n-    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing \\\n-        -fno-fat-lto-objects\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n-        -fuse-linker-plugin -fno-strict-aliasing\n-  else ifeq ($(call isCompiler, clang), true)\n-    JVM_CFLAGS_FEATURES += -flto -fno-strict-aliasing\n-    ifeq ($(call isBuildOs, aix), true)\n-      JVM_CFLAGS_FEATURES += -ffat-lto-objects\n-    endif\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto -fno-strict-aliasing\n-  else ifeq ($(call isCompiler, microsoft), true)\n-    JVM_CFLAGS_FEATURES += -GL\n-    JVM_LDFLAGS_FEATURES += -LTCG:INCREMENTAL\n+  JVM_LTO := true\n+  ifneq ($(call isCompiler, microsoft), true)\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM)\n@@ -193,0 +182,1 @@\n+  JVM_LTO := false\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+      LINK_TIME_OPTIMIZATION := true, \\\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+\/\/ Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1197,1 +1198,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1200,4 +1200,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_codestub_branch_size();\n-  }\n-\n@@ -1205,1 +1201,1 @@\n-    \/\/ count one adr and one far branch instruction\n+    \/\/ count one branch instruction and one far call instruction sequence\n@@ -2255,19 +2251,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ mov rscratch1 #exception_blob_entry_point\n-  \/\/ br rscratch1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2284,0 +2261,1 @@\n+\n@@ -2285,0 +2263,3 @@\n+  Label start;\n+  __ bind(start);\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2286,2 +2267,2 @@\n-  __ adr(lr, __ pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -2290,0 +2271,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2291,1 +2274,1 @@\n-  return offset;\n+  return entry_offset;\n@@ -3382,1 +3365,1 @@\n-  enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegLNoSp oldval, iRegLNoSp newval) %{\n+  enc_class aarch64_enc_cmpxchg_acq(memory mem, iRegL oldval, iRegL newval) %{\n@@ -3389,1 +3372,1 @@\n-  enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n+  enc_class aarch64_enc_cmpxchgw_acq(memory mem, iRegI oldval, iRegI newval) %{\n@@ -3396,1 +3379,1 @@\n-  enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n+  enc_class aarch64_enc_cmpxchgs_acq(memory mem, iRegI oldval, iRegI newval) %{\n@@ -3403,1 +3386,1 @@\n-  enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegINoSp oldval, iRegINoSp newval) %{\n+  enc_class aarch64_enc_cmpxchgb_acq(memory mem, iRegI oldval, iRegI newval) %{\n@@ -3411,1 +3394,1 @@\n-  enc_class aarch64_enc_cset_eq(iRegINoSp res) %{\n+  enc_class aarch64_enc_cset_eq(iRegI res) %{\n@@ -8458,1 +8441,1 @@\n-instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapB(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8476,1 +8459,1 @@\n-instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapS(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8494,1 +8477,1 @@\n-instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapI(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8512,1 +8495,1 @@\n-instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegLNoSp oldval, iRegLNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapL(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n@@ -8549,1 +8532,1 @@\n-instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapN(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n@@ -8570,1 +8553,1 @@\n-instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapBAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8589,1 +8572,1 @@\n-instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapSAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8608,1 +8591,1 @@\n-instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegINoSp oldval, iRegINoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapIAcq(iRegINoSp res, indirect mem, iRegI oldval, iRegI newval, rFlagsReg cr) %{\n@@ -8627,1 +8610,1 @@\n-instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegLNoSp oldval, iRegLNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapLAcq(iRegINoSp res, indirect mem, iRegL oldval, iRegL newval, rFlagsReg cr) %{\n@@ -8665,1 +8648,1 @@\n-instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegNNoSp oldval, iRegNNoSp newval, rFlagsReg cr) %{\n+instruct compareAndSwapNAcq(iRegINoSp res, indirect mem, iRegN oldval, iRegN newval, rFlagsReg cr) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":26,"deletions":43,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -455,2 +455,8 @@\n-  __ adr(lr, pc());\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ b(start);\n+\n@@ -458,0 +464,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -460,1 +468,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    _deopt_handler_size = 7 * NativeInstruction::instruction_size\n+    _deopt_handler_size = 4 * NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -397,6 +397,0 @@\n-#ifdef ASSERT\n-static bool is_movk_to_zr(uint32_t insn) {\n-  return ((insn & 0xffe0001f) == 0xf280001f);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -529,0 +529,5 @@\n+private:\n+  static bool is_movk_to_zr(uint32_t insn) {\n+    return ((insn & 0xffe0001f) == 0xf280001f);\n+  }\n+\n@@ -530,0 +535,7 @@\n+  enum AArch64_specific_constants {\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in case\n+    \/\/ the return address points to the deopt handler stub code entry point which could be\n+    \/\/ at the end of page.\n+    first_check_size = instruction_size\n+  };\n+\n@@ -531,6 +543,11 @@\n-    uint64_t insns = *(uint64_t*)addr_at(0);\n-    \/\/ Check for two instructions: nop; movk zr, xx\n-    \/\/ These instructions only ever appear together in a post-call\n-    \/\/ NOP, so it's unnecessary to check that the third instruction is\n-    \/\/ a MOVK as well.\n-    return (insns & 0xffe0001fffffffff) == 0xf280001fd503201f;\n+    \/\/ Check the first instruction is NOP.\n+    if (is_nop()) {\n+      uint32_t insn = *(uint32_t*)addr_at(first_check_size);\n+      \/\/ Check next instruction is MOVK zr, xx.\n+      \/\/ These instructions only ever appear together in a post-call\n+      \/\/ NOP, so it's unnecessary to check that the third instruction is\n+      \/\/ a MOVK as well.\n+      return is_movk_to_zr(insn);\n+    }\n+\n+    return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -263,2 +263,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in aarch64.ad file)\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -111,5 +110,0 @@\n-  static uint size_exception_handler() {\n-    return ( 3 * 4 );\n-  }\n-\n-\n@@ -879,20 +873,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-\n-  \/\/ OK to trash LR, because exception blob will kill it\n-  __ jump(OptoRuntime::exception_blob()->entry_point(), relocInfo::runtime_call_type, LR_tmp);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -909,1 +883,0 @@\n-  address deopt_pc = __ pc();\n@@ -911,5 +884,3 @@\n-  __ sub(SP, SP, wordSize); \/\/ make room for saved PC\n-  __ push(LR); \/\/ save LR that may be live when we get here\n-  __ mov_relative_address(LR, deopt_pc);\n-  __ str(LR, Address(SP, wordSize)); \/\/ save deopt PC\n-  __ pop(LR); \/\/ restore LR\n+  Label start;\n+  __ bind(start);\n+\n@@ -918,0 +889,10 @@\n+  int entry_offset = __ offset();\n+  address deopt_pc = __ pc();\n+  \/\/ Preserve R0 and reserve space for the address of the entry point\n+  __ push(RegisterSet(R0) | RegisterSet(R1));\n+  \/\/ Store the entry point address\n+  __ mov_relative_address(R0, deopt_pc);\n+  __ str(R0, Address(SP, wordSize));\n+  __ pop(R0); \/\/ restore R0\n+  __ b(start);\n+\n@@ -919,0 +900,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -921,1 +904,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":16,"deletions":33,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -65,16 +65,16 @@\n-reg_def R_R0 (SOC, SOC, Op_RegI,  0,  R(0)->as_VMReg());\n-reg_def R_R1 (SOC, SOC, Op_RegI,  1,  R(1)->as_VMReg());\n-reg_def R_R2 (SOC, SOC, Op_RegI,  2,  R(2)->as_VMReg());\n-reg_def R_R3 (SOC, SOC, Op_RegI,  3,  R(3)->as_VMReg());\n-reg_def R_R4 (SOC, SOE, Op_RegI,  4,  R(4)->as_VMReg());\n-reg_def R_R5 (SOC, SOE, Op_RegI,  5,  R(5)->as_VMReg());\n-reg_def R_R6 (SOC, SOE, Op_RegI,  6,  R(6)->as_VMReg());\n-reg_def R_R7 (SOC, SOE, Op_RegI,  7,  R(7)->as_VMReg());\n-reg_def R_R8 (SOC, SOE, Op_RegI,  8,  R(8)->as_VMReg());\n-reg_def R_R9 (SOC, SOE, Op_RegI,  9,  R(9)->as_VMReg());\n-reg_def R_R10(NS,  SOE, Op_RegI, 10, R(10)->as_VMReg());\n-reg_def R_R11(NS,  SOE, Op_RegI, 11, R(11)->as_VMReg());\n-reg_def R_R12(SOC, SOC, Op_RegI, 12, R(12)->as_VMReg());\n-reg_def R_R13(NS,  NS,  Op_RegI, 13, R(13)->as_VMReg());\n-reg_def R_R14(SOC, SOC, Op_RegI, 14, R(14)->as_VMReg());\n-reg_def R_R15(NS,  NS,  Op_RegI, 15, R(15)->as_VMReg());\n+reg_def R_R0 (SOC, SOC, Op_RegI,  0,  as_Register(0)->as_VMReg());\n+reg_def R_R1 (SOC, SOC, Op_RegI,  1,  as_Register(1)->as_VMReg());\n+reg_def R_R2 (SOC, SOC, Op_RegI,  2,  as_Register(2)->as_VMReg());\n+reg_def R_R3 (SOC, SOC, Op_RegI,  3,  as_Register(3)->as_VMReg());\n+reg_def R_R4 (SOC, SOE, Op_RegI,  4,  as_Register(4)->as_VMReg());\n+reg_def R_R5 (SOC, SOE, Op_RegI,  5,  as_Register(5)->as_VMReg());\n+reg_def R_R6 (SOC, SOE, Op_RegI,  6,  as_Register(6)->as_VMReg());\n+reg_def R_R7 (SOC, SOE, Op_RegI,  7,  as_Register(7)->as_VMReg());\n+reg_def R_R8 (SOC, SOE, Op_RegI,  8,  as_Register(8)->as_VMReg());\n+reg_def R_R9 (SOC, SOE, Op_RegI,  9,  as_Register(9)->as_VMReg());\n+reg_def R_R10(NS,  SOE, Op_RegI, 10, as_Register(10)->as_VMReg());\n+reg_def R_R11(NS,  SOE, Op_RegI, 11, as_Register(11)->as_VMReg());\n+reg_def R_R12(SOC, SOC, Op_RegI, 12, as_Register(12)->as_VMReg());\n+reg_def R_R13(NS,  NS,  Op_RegI, 13, as_Register(13)->as_VMReg());\n+reg_def R_R14(SOC, SOC, Op_RegI, 14, as_Register(14)->as_VMReg());\n+reg_def R_R15(NS,  NS,  Op_RegI, 15, as_Register(15)->as_VMReg());\n","filename":"src\/hotspot\/cpu\/arm\/arm_32.ad","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    assert(first < last, \"encoding constraint\");\n+    assert(first->encoding() < last->encoding(), \"encoding constraint\");\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,1 +184,1 @@\n-  if (obj_reg < lock_reg) {\n+  if (obj_reg->encoding() < lock_reg->encoding()) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,0 +275,6 @@\n+  Label start;\n+  __ bind(start);\n+\n+  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+\n+  int entry_offset = __ offset();\n@@ -277,1 +283,1 @@\n-  __ jump(SharedRuntime::deopt_blob()->unpack(), relocInfo::runtime_call_type, noreg);\n+  __ b(start);\n@@ -280,0 +286,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -282,1 +290,1 @@\n-  return offset;\n+  return entry_offset;\n@@ -2638,1 +2646,1 @@\n-    if (src_lo < src_hi) {\n+    if (src_lo->encoding() < src_hi->encoding()) {\n@@ -2642,1 +2650,1 @@\n-      assert(src_lo < Rtemp, \"Rtemp is higher than any allocatable register\");\n+      assert(src_lo->encoding() < Rtemp->encoding(), \"Rtemp is higher than any allocatable register\");\n@@ -2655,1 +2663,1 @@\n-    if (dest_lo < dest_hi) {\n+    if (dest_lo->encoding() < dest_hi->encoding()) {\n@@ -2658,1 +2666,1 @@\n-      assert(dest_lo < Rtemp, \"Rtemp is higher than any allocatable register\");\n+      assert(dest_lo->encoding() < Rtemp->encoding(), \"Rtemp is higher than any allocatable register\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    _deopt_handler_size = 16\n+    _deopt_handler_size = 20\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-  assert(lo < hi, \"lo must be < hi\");\n+  assert(lo->encoding() < hi->encoding(), \"lo must be < hi\");\n@@ -462,1 +462,1 @@\n-  assert(lo < hi, \"lo must be < hi\");\n+  assert(lo->encoding() < hi->encoding(), \"lo must be < hi\");\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -433,0 +433,7 @@\n+  enum arm_specific_constants {\n+    \/\/ If the check is adjusted to read beyond size of the instruction sequence at the deopt\n+    \/\/ handler stub code entry point, it has to happen in two stages - to prevent out of bounds\n+    \/\/ access in case the return address points to the entry point which could be at\n+    \/\/ the end of page.\n+    first_check_size = instruction_size\n+  };\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,3 +28,9 @@\n-const int ConcreteRegisterImpl::max_gpr = ConcreteRegisterImpl::num_gpr;\n-const int ConcreteRegisterImpl::max_fpr = ConcreteRegisterImpl::num_fpr +\n-                                          ConcreteRegisterImpl::max_gpr;\n+Register::RegisterImpl all_RegisterImpls [Register::number_of_registers + 1];\n+FloatRegister::FloatRegisterImpl all_FloatRegisterImpls [FloatRegister::number_of_registers + 1];\n+VFPSystemRegister::VFPSystemRegisterImpl all_VFPSystemRegisterImpls [VFPSystemRegister::number_of_registers + 1] {\n+  { -1 }, \/\/vfpsnoreg\n+  { VFPSystemRegister::FPSID },\n+  { VFPSystemRegister::FPSCR },\n+  { VFPSystemRegister::MVFR0 },\n+  { VFPSystemRegister::MVFR1 }\n+};\n@@ -32,2 +38,3 @@\n-const char* RegisterImpl::name() const {\n-  const char* names[number_of_registers] = {\n+const char* Register::RegisterImpl::name() const {\n+  static const char* names[number_of_registers + 1] = {\n+    \"noreg\",\n@@ -48,1 +55,1 @@\n-  return is_valid() ? names[encoding()] : \"noreg\";\n+  return names[encoding() + 1];\n@@ -51,4 +58,5 @@\n-const char* FloatRegisterImpl::name() const {\n-  const char* names[number_of_registers] = {\n-     \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",\n-     \"s8\",  \"s9\", \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\",\n+const char* FloatRegister::FloatRegisterImpl::name() const {\n+  static const char* names[number_of_registers + 1] = {\n+    \"fnoreg\",\n+    \"s0\",  \"s1\",  \"s2\",  \"s3\",  \"s4\",  \"s5\",  \"s6\",  \"s7\",\n+    \"s8\",  \"s9\", \"s10\", \"s11\", \"s12\", \"s13\", \"s14\", \"s15\",\n@@ -64,1 +72,1 @@\n-  return is_valid() ? names[encoding()] : \"fnoreg\";\n+  return names[encoding() + 1];\n","filename":"src\/hotspot\/cpu\/arm\/register_arm.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -34,20 +34,0 @@\n-\/\/ These are declared ucontext.h\n-#undef R0\n-#undef R1\n-#undef R2\n-#undef R3\n-#undef R4\n-#undef R5\n-#undef R6\n-#undef R7\n-#undef R8\n-#undef R9\n-#undef R10\n-#undef R11\n-#undef R12\n-#undef R13\n-#undef R14\n-#undef R15\n-\n-#define R(r)   ((Register)(r))\n-\n@@ -97,19 +77,80 @@\n-#define R0     ((Register)0)\n-#define R1     ((Register)1)\n-#define R2     ((Register)2)\n-#define R3     ((Register)3)\n-#define R4     ((Register)4)\n-#define R5     ((Register)5)\n-#define R6     ((Register)6)\n-#define R7     ((Register)7)\n-#define R8     ((Register)8)\n-#define R9     ((Register)9)\n-#define R10    ((Register)10)\n-#define R11    ((Register)11)\n-#define R12    ((Register)12)\n-#define R13    ((Register)13)\n-#define R14    ((Register)14)\n-#define R15    ((Register)15)\n-\n-\n-#define FP     ((Register)FP_REG_NUM)\n+class Register {\n+ private:\n+  int _encoding;\n+\n+  constexpr explicit Register(int encoding) : _encoding(encoding) {}\n+\n+ public:\n+  enum {\n+    number_of_registers = 16,\n+    max_slots_per_register = 1\n+  };\n+\n+  class RegisterImpl : public AbstractRegisterImpl {\n+    friend class Register;\n+\n+    static constexpr const RegisterImpl* first();\n+\n+   public:\n+\n+    \/\/ accessors and testers\n+    int raw_encoding() const { return this - first(); }\n+    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n+\n+    inline Register successor() const;\n+\n+    VMReg as_VMReg() const;\n+\n+    const char* name() const;\n+  };\n+\n+\n+  inline friend constexpr Register as_Register(int encoding);\n+\n+  constexpr Register() : _encoding(-1) {} \/\/noreg\n+\n+  int operator==(const Register r) const { return _encoding == r._encoding; }\n+  int operator!=(const Register r) const { return _encoding != r._encoding; }\n+\n+  const RegisterImpl* operator->() const { return RegisterImpl::first() + _encoding; }\n+};\n+\n+extern Register::RegisterImpl all_RegisterImpls[Register::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr const Register::RegisterImpl* Register::RegisterImpl::first() {\n+  return all_RegisterImpls + 1;\n+}\n+\n+constexpr Register noreg = Register();\n+\n+inline constexpr Register as_Register(int encoding) {\n+  if (0 <= encoding && encoding < Register::number_of_registers) {\n+    return Register(encoding);\n+  }\n+  return noreg;\n+}\n+\n+inline Register Register::RegisterImpl::successor() const {\n+  assert(is_valid(), \"sainty\");\n+  return as_Register(encoding() + 1);\n+}\n+\n+constexpr Register R0  = as_Register( 0);\n+constexpr Register R1  = as_Register( 1);\n+constexpr Register R2  = as_Register( 2);\n+constexpr Register R3  = as_Register( 3);\n+constexpr Register R4  = as_Register( 4);\n+constexpr Register R5  = as_Register( 5);\n+constexpr Register R6  = as_Register( 6);\n+constexpr Register R7  = as_Register( 7);\n+constexpr Register R8  = as_Register( 8);\n+constexpr Register R9  = as_Register( 9);\n+constexpr Register R10 = as_Register(10);\n+constexpr Register R11 = as_Register(11);\n+constexpr Register R12 = as_Register(12);\n+constexpr Register R13 = as_Register(13);\n+constexpr Register R14 = as_Register(14);\n+constexpr Register R15 = as_Register(15);\n+\n+constexpr Register FP = as_Register(FP_REG_NUM);\n@@ -125,1 +166,1 @@\n-#define altFP_7_11     ((Register)11)\n+constexpr Register altFP_7_11 = R11;\n@@ -127,1 +168,1 @@\n-#define altFP_7_11     ((Register)7)\n+constexpr Register altFP_7_11 = R7;\n@@ -129,3 +170,3 @@\n-#define SP     R13\n-#define LR     R14\n-#define PC     R15\n+constexpr Register SP = R13;\n+constexpr Register LR = R14;\n+constexpr Register PC = R15;\n@@ -135,2 +176,3 @@\n-class RegisterImpl;\n-typedef RegisterImpl* Register;\n+class FloatRegister {\n+ private:\n+  int _encoding;\n@@ -138,3 +180,1 @@\n-inline Register as_Register(int encoding) {\n-  return (Register)(intptr_t)encoding;\n-}\n+  constexpr explicit FloatRegister(int encoding) : _encoding(encoding) {}\n@@ -142,1 +182,0 @@\n-class RegisterImpl : public AbstractRegisterImpl {\n@@ -145,1 +184,2 @@\n-    number_of_registers = 16\n+    number_of_registers = NOT_COMPILER2(32) COMPILER2_PRESENT(64),\n+    max_slots_per_register = 1\n@@ -148,1 +188,2 @@\n-  Register successor() const      { return as_Register(encoding() + 1); }\n+  class FloatRegisterImpl : public AbstractRegisterImpl {\n+    friend class FloatRegister;\n@@ -150,1 +191,1 @@\n-  inline friend Register as_Register(int encoding);\n+    static constexpr const FloatRegisterImpl* first();\n@@ -152,1 +193,1 @@\n-  VMReg as_VMReg();\n+   public:\n@@ -154,3 +195,4 @@\n-  \/\/ accessors\n-  int   encoding() const          { assert(is_valid(), \"invalid register\"); return value(); }\n-  const char* name() const;\n+    \/\/ accessors and testers\n+    int raw_encoding() const { return this - first(); }\n+    int encoding() const     { assert(is_valid(), \"invalid register\"); return raw_encoding(); }\n+    bool is_valid() const    { return 0 <= raw_encoding() && raw_encoding() < number_of_registers; }\n@@ -158,0 +200,1 @@\n+    inline FloatRegister successor() const;\n@@ -159,4 +202,1 @@\n-  \/\/ testers\n-  bool is_valid() const           { return 0 <= value() && value() < number_of_registers; }\n-\n-};\n+    VMReg as_VMReg() const;\n@@ -164,1 +204,3 @@\n-CONSTANT_REGISTER_DECLARATION(Register, noreg, (-1));\n+    int hi_bits() const {\n+      return (encoding() >> 1) & 0xf;\n+    }\n@@ -166,0 +208,3 @@\n+    int lo_bit() const {\n+      return encoding() & 1;\n+    }\n@@ -167,3 +212,3 @@\n-\/\/ Use FloatRegister as shortcut\n-class FloatRegisterImpl;\n-typedef FloatRegisterImpl* FloatRegister;\n+    int hi_bit() const {\n+      return encoding() >> 5;\n+    }\n@@ -171,8 +216,1 @@\n-inline FloatRegister as_FloatRegister(int encoding) {\n-  return (FloatRegister)(intptr_t)encoding;\n-}\n-\n-class FloatRegisterImpl : public AbstractRegisterImpl {\n- public:\n-  enum {\n-    number_of_registers = NOT_COMPILER2(32) COMPILER2_PRESENT(64)\n+    const char* name() const;\n@@ -181,1 +219,1 @@\n-  inline friend FloatRegister as_FloatRegister(int encoding);\n+  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n@@ -183,1 +221,1 @@\n-  VMReg as_VMReg();\n+  constexpr FloatRegister() : _encoding(-1) {} \/\/ fnoreg\n@@ -185,3 +223,2 @@\n-  int   encoding() const          { assert(is_valid(), \"invalid register\"); return value(); }\n-  bool  is_valid() const          { return 0 <= (intx)this && (intx)this < number_of_registers; }\n-  FloatRegister successor() const { return as_FloatRegister(encoding() + 1); }\n+  int operator==(const FloatRegister r) const { return _encoding == r._encoding; }\n+  int operator!=(const FloatRegister r) const { return _encoding != r._encoding; }\n@@ -189,1 +226,2 @@\n-  const char* name() const;\n+  const FloatRegisterImpl* operator->() const { return FloatRegisterImpl::first() + _encoding; }\n+};\n@@ -191,3 +229,1 @@\n-  int hi_bits() const {\n-    return (encoding() >> 1) & 0xf;\n-  }\n+extern FloatRegister::FloatRegisterImpl all_FloatRegisterImpls[FloatRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n@@ -195,3 +231,5 @@\n-  int lo_bit() const {\n-    return encoding() & 1;\n-  }\n+inline constexpr const FloatRegister::FloatRegisterImpl* FloatRegister::FloatRegisterImpl::first() {\n+  return all_FloatRegisterImpls + 1;\n+}\n+\n+constexpr FloatRegister fnoreg = FloatRegister();\n@@ -199,2 +237,3 @@\n-  int hi_bit() const {\n-    return encoding() >> 5;\n+inline constexpr FloatRegister as_FloatRegister(int encoding) {\n+  if (0 <= encoding && encoding < FloatRegister::number_of_registers) {\n+    return FloatRegister(encoding);\n@@ -202,1 +241,2 @@\n-};\n+  return fnoreg;\n+}\n@@ -204,1 +244,4 @@\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, fnoreg, (-1));\n+inline FloatRegister FloatRegister::FloatRegisterImpl::successor() const {\n+  assert(is_valid(), \"sainty\");\n+  return as_FloatRegister(encoding() + 1);\n+}\n@@ -211,66 +254,66 @@\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S0,     ( 0));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S1_reg, ( 1));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S2_reg, ( 2));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S3_reg, ( 3));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S4_reg, ( 4));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S5_reg, ( 5));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S6_reg, ( 6));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S7,     ( 7));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S8,     ( 8));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S9,     ( 9));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S10,    (10));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S11,    (11));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S12,    (12));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S13,    (13));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S14,    (14));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S15,    (15));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S16,    (16));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S17,    (17));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S18,    (18));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S19,    (19));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S20,    (20));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S21,    (21));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S22,    (22));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S23,    (23));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S24,    (24));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S25,    (25));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S26,    (26));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S27,    (27));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S28,    (28));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S29,    (29));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S30,    (30));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, S31,    (31));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, Stemp,  (30));\n-\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D0,     ( 0));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D1,     ( 2));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D2,     ( 4));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D3,     ( 6));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D4,     ( 8));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D5,     ( 10));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D6,     ( 12));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D7,     ( 14));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D8,     ( 16));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D9,     ( 18));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D10,    ( 20));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D11,    ( 22));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D12,    ( 24));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D13,    ( 26));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D14,    ( 28));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D15,    (30));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D16,    (32));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D17,    (34));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D18,    (36));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D19,    (38));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D20,    (40));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D21,    (42));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D22,    (44));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D23,    (46));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D24,    (48));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D25,    (50));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D26,    (52));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D27,    (54));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D28,    (56));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D29,    (58));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D30,    (60));\n-CONSTANT_REGISTER_DECLARATION(FloatRegister, D31,    (62));\n+constexpr FloatRegister S0  = as_FloatRegister( 0);\n+constexpr FloatRegister S1_reg = as_FloatRegister(1);\n+constexpr FloatRegister S2_reg = as_FloatRegister(2);\n+constexpr FloatRegister S3_reg = as_FloatRegister(3);\n+constexpr FloatRegister S4_reg = as_FloatRegister(4);\n+constexpr FloatRegister S5_reg = as_FloatRegister(5);\n+constexpr FloatRegister S6_reg = as_FloatRegister(6);\n+constexpr FloatRegister S7  = as_FloatRegister( 7);\n+constexpr FloatRegister S8  = as_FloatRegister( 8);\n+constexpr FloatRegister S9  = as_FloatRegister( 9);\n+constexpr FloatRegister S10 = as_FloatRegister(10);\n+constexpr FloatRegister S11 = as_FloatRegister(11);\n+constexpr FloatRegister S12 = as_FloatRegister(12);\n+constexpr FloatRegister S13 = as_FloatRegister(13);\n+constexpr FloatRegister S14 = as_FloatRegister(14);\n+constexpr FloatRegister S15 = as_FloatRegister(15);\n+constexpr FloatRegister S16 = as_FloatRegister(16);\n+constexpr FloatRegister S17 = as_FloatRegister(17);\n+constexpr FloatRegister S18 = as_FloatRegister(18);\n+constexpr FloatRegister S19 = as_FloatRegister(19);\n+constexpr FloatRegister S20 = as_FloatRegister(20);\n+constexpr FloatRegister S21 = as_FloatRegister(21);\n+constexpr FloatRegister S22 = as_FloatRegister(22);\n+constexpr FloatRegister S23 = as_FloatRegister(23);\n+constexpr FloatRegister S24 = as_FloatRegister(24);\n+constexpr FloatRegister S25 = as_FloatRegister(25);\n+constexpr FloatRegister S26 = as_FloatRegister(26);\n+constexpr FloatRegister S27 = as_FloatRegister(27);\n+constexpr FloatRegister S28 = as_FloatRegister(28);\n+constexpr FloatRegister S29 = as_FloatRegister(29);\n+constexpr FloatRegister S30 = as_FloatRegister(30);\n+constexpr FloatRegister S31 = as_FloatRegister(31);\n+constexpr FloatRegister Stemp = S30;\n+\n+constexpr FloatRegister D0  = as_FloatRegister( 0);\n+constexpr FloatRegister D1  = as_FloatRegister( 2);\n+constexpr FloatRegister D2  = as_FloatRegister( 4);\n+constexpr FloatRegister D3  = as_FloatRegister( 6);\n+constexpr FloatRegister D4  = as_FloatRegister( 8);\n+constexpr FloatRegister D5  = as_FloatRegister(10);\n+constexpr FloatRegister D6  = as_FloatRegister(12);\n+constexpr FloatRegister D7  = as_FloatRegister(14);\n+constexpr FloatRegister D8  = as_FloatRegister(16);\n+constexpr FloatRegister D9  = as_FloatRegister(18);\n+constexpr FloatRegister D10 = as_FloatRegister(20);\n+constexpr FloatRegister D11 = as_FloatRegister(22);\n+constexpr FloatRegister D12 = as_FloatRegister(24);\n+constexpr FloatRegister D13 = as_FloatRegister(26);\n+constexpr FloatRegister D14 = as_FloatRegister(28);\n+constexpr FloatRegister D15 = as_FloatRegister(30);\n+constexpr FloatRegister D16 = as_FloatRegister(32);\n+constexpr FloatRegister D17 = as_FloatRegister(34);\n+constexpr FloatRegister D18 = as_FloatRegister(36);\n+constexpr FloatRegister D19 = as_FloatRegister(38);\n+constexpr FloatRegister D20 = as_FloatRegister(40);\n+constexpr FloatRegister D21 = as_FloatRegister(42);\n+constexpr FloatRegister D22 = as_FloatRegister(44);\n+constexpr FloatRegister D23 = as_FloatRegister(46);\n+constexpr FloatRegister D24 = as_FloatRegister(48);\n+constexpr FloatRegister D25 = as_FloatRegister(50);\n+constexpr FloatRegister D26 = as_FloatRegister(52);\n+constexpr FloatRegister D27 = as_FloatRegister(54);\n+constexpr FloatRegister D28 = as_FloatRegister(56);\n+constexpr FloatRegister D29 = as_FloatRegister(58);\n+constexpr FloatRegister D30 = as_FloatRegister(60);\n+constexpr FloatRegister D31 = as_FloatRegister(62);\n@@ -282,19 +325,2 @@\n-    log_vmregs_per_word = LogBytesPerWord - LogBytesPerInt, \/\/ VMRegs are of 4-byte size\n-#ifdef COMPILER2\n-    log_bytes_per_fpr  = 2, \/\/ quad vectors\n-#else\n-    log_bytes_per_fpr  = 2, \/\/ double vectors\n-#endif\n-    log_words_per_fpr  = log_bytes_per_fpr - LogBytesPerWord,\n-    words_per_fpr      = 1 << log_words_per_fpr,\n-    log_vmregs_per_fpr = log_bytes_per_fpr - LogBytesPerInt,\n-    log_vmregs_per_gpr = log_vmregs_per_word,\n-    vmregs_per_gpr = 1 << log_vmregs_per_gpr,\n-    vmregs_per_fpr = 1 << log_vmregs_per_fpr,\n-\n-    num_gpr  = RegisterImpl::number_of_registers << log_vmregs_per_gpr,\n-    max_gpr0 = num_gpr,\n-    num_fpr  = FloatRegisterImpl::number_of_registers << log_vmregs_per_fpr,\n-    max_fpr0 = max_gpr0 + num_fpr,\n-    number_of_registers = num_gpr + num_fpr + 1+1 \/\/ APSR and FPSCR so that c2's REG_COUNT <= ConcreteRegisterImpl::number_of_registers\n-  };\n+    max_gpr = Register::number_of_registers * Register::max_slots_per_register,\n+    max_fpr = max_gpr + FloatRegister::number_of_registers * FloatRegister::max_slots_per_register,\n@@ -302,2 +328,2 @@\n-  static const int max_gpr;\n-  static const int max_fpr;\n+    number_of_registers = max_fpr + 1+1 \/\/ APSR and FPSCR so that c2's REG_COUNT <= ConcreteRegisterImpl::number_of_registers\n+  };\n@@ -331,3 +357,13 @@\n-class VFPSystemRegisterImpl;\n-typedef VFPSystemRegisterImpl* VFPSystemRegister;\n-class VFPSystemRegisterImpl : public AbstractRegisterImpl {\n+class VFPSystemRegister {\n+ private:\n+  int _store_idx;\n+\n+  constexpr explicit VFPSystemRegister(int store_idx) : _store_idx(store_idx) {}\n+\n+  enum {\n+    _FPSID_store_idx = 0,\n+    _FPSCR_store_idx = 1,\n+    _MVFR0_store_idx = 2,\n+    _MVFR1_store_idx = 3\n+  };\n+\n@@ -335,1 +371,29 @@\n-  int   encoding() const          { return value(); }\n+  enum {\n+    FPSID = 0,\n+    FPSCR = 1,\n+    MVFR0 = 6,\n+    MVFR1 = 7,\n+    number_of_registers = 4\n+  };\n+\n+  class VFPSystemRegisterImpl : public AbstractRegisterImpl {\n+    friend class VFPSystemRegister;\n+\n+    int _encoding;\n+\n+    static constexpr const VFPSystemRegisterImpl* first();\n+\n+   public:\n+    constexpr VFPSystemRegisterImpl(int encoding) : _encoding(encoding) {}\n+\n+    int   encoding() const { return _encoding; }\n+  };\n+\n+  inline friend constexpr VFPSystemRegister as_VFPSystemRegister(int encoding);\n+\n+  constexpr VFPSystemRegister() : _store_idx(-1) {} \/\/ vfpsnoreg\n+\n+  int operator==(const VFPSystemRegister r) const { return _store_idx == r._store_idx; }\n+  int operator!=(const VFPSystemRegister r) const { return _store_idx != r._store_idx; }\n+\n+  const VFPSystemRegisterImpl* operator->() const { return VFPSystemRegisterImpl::first() + _store_idx; }\n@@ -338,4 +402,22 @@\n-#define FPSID     ((VFPSystemRegister)0)\n-#define FPSCR     ((VFPSystemRegister)1)\n-#define MVFR0     ((VFPSystemRegister)0x6)\n-#define MVFR1     ((VFPSystemRegister)0x7)\n+extern VFPSystemRegister::VFPSystemRegisterImpl all_VFPSystemRegisterImpls[VFPSystemRegister::number_of_registers + 1] INTERNAL_VISIBILITY;\n+\n+inline constexpr const VFPSystemRegister::VFPSystemRegisterImpl* VFPSystemRegister::VFPSystemRegisterImpl::first() {\n+  return all_VFPSystemRegisterImpls + 1;\n+}\n+\n+constexpr VFPSystemRegister vfpsnoreg = VFPSystemRegister();\n+\n+inline constexpr VFPSystemRegister as_VFPSystemRegister(int encoding) {\n+  switch (encoding) {\n+    case VFPSystemRegister::FPSID: return VFPSystemRegister(VFPSystemRegister::_FPSID_store_idx);\n+    case VFPSystemRegister::FPSCR: return VFPSystemRegister(VFPSystemRegister::_FPSCR_store_idx);\n+    case VFPSystemRegister::MVFR0: return VFPSystemRegister(VFPSystemRegister::_MVFR0_store_idx);\n+    case VFPSystemRegister::MVFR1: return VFPSystemRegister(VFPSystemRegister::_MVFR1_store_idx);\n+    default: return vfpsnoreg;\n+  }\n+}\n+\n+constexpr VFPSystemRegister FPSID = as_VFPSystemRegister(VFPSystemRegister::FPSID);\n+constexpr VFPSystemRegister FPSCR = as_VFPSystemRegister(VFPSystemRegister::FPSCR);\n+constexpr VFPSystemRegister MVFR0 = as_VFPSystemRegister(VFPSystemRegister::MVFR0);\n+constexpr VFPSystemRegister MVFR1 = as_VFPSystemRegister(VFPSystemRegister::MVFR1);\n@@ -346,2 +428,2 @@\n-#define Rexception_obj   R4\n-#define Rexception_pc    R5\n+constexpr Register Rexception_obj = R4;\n+constexpr Register Rexception_pc = R5;\n@@ -352,4 +434,4 @@\n-#define Rlocals          R8\n-#define Rmethod          R9\n-#define Rthread          R10\n-#define Rtemp            R12\n+constexpr Register Rlocals = R8;\n+constexpr Register Rmethod = R9;\n+constexpr Register Rthread = R10;\n+constexpr Register Rtemp = R12;\n@@ -359,2 +441,2 @@\n-#define Rparams          SP\n-#define Rsender_sp       R4\n+constexpr Register Rparams = SP;\n+constexpr Register Rsender_sp = R4;\n@@ -366,1 +448,1 @@\n-#define R5_mh            R5 \/\/ MethodHandle register, used during the call setup\n+constexpr Register R5_mh = R5; \/\/ MethodHandle register, used during the call setup\n@@ -371,5 +453,5 @@\n-#define Rsave0   R4\n-#define Rsave1   R5\n-#define Rsave2   R6\n-#define Rstate   altFP_7_11 \/\/ R7 or R11\n-#define Ricklass R8\n+constexpr Register Rsave0 = R4;\n+constexpr Register Rsave1 = R5;\n+constexpr Register Rsave2 = R6;\n+constexpr Register Rstate = altFP_7_11; \/\/ R7 or R11\n+constexpr Register Ricklass = R8;\n@@ -382,8 +464,8 @@\n-#define R0_tmp                 R0\n-#define R1_tmp                 R1\n-#define R2_tmp                 R2\n-#define R3_tmp                 R3\n-#define R4_tmp                 R4\n-#define R5_tmp                 R5\n-#define R12_tmp                R12\n-#define LR_tmp                 LR\n+constexpr Register R0_tmp = R0;\n+constexpr Register R1_tmp = R1;\n+constexpr Register R2_tmp = R2;\n+constexpr Register R3_tmp = R3;\n+constexpr Register R4_tmp = R4;\n+constexpr Register R5_tmp = R5;\n+constexpr Register R12_tmp = R12;\n+constexpr Register LR_tmp = LR;\n@@ -391,2 +473,2 @@\n-#define S0_tmp                 S0\n-#define S1_tmp                 S1_reg\n+constexpr FloatRegister S0_tmp = S0;\n+constexpr FloatRegister S1_tmp = S1_reg;\n@@ -394,2 +476,2 @@\n-#define D0_tmp                 D0\n-#define D1_tmp                 D1\n+constexpr FloatRegister D0_tmp = D0;\n+constexpr FloatRegister D1_tmp = D1;\n@@ -398,2 +480,2 @@\n-#define Rtmp_save0             R4\n-#define Rtmp_save1             R5\n+constexpr Register Rtmp_save0 = R4;\n+constexpr Register Rtmp_save1 = R5;\n@@ -402,1 +484,1 @@\n-#define R0_tos                 R0\n+constexpr Register R0_tos = R0;\n@@ -404,2 +486,2 @@\n-#define R0_tos_lo              R0\n-#define R1_tos_hi              R1\n+constexpr Register R0_tos_lo = R0;\n+constexpr Register R1_tos_hi = R1;\n@@ -407,2 +489,2 @@\n-#define S0_tos                 S0\n-#define D0_tos                 D0\n+constexpr FloatRegister S0_tos = S0;\n+constexpr FloatRegister D0_tos = D0;\n@@ -411,1 +493,1 @@\n-#define RdispatchTable         R6\n+constexpr Register RdispatchTable = R6;\n@@ -414,1 +496,1 @@\n-#define Rbcp                   altFP_7_11\n+constexpr Register Rbcp = altFP_7_11;\n@@ -417,1 +499,1 @@\n-#define R3_bytecode            R3\n+constexpr Register R3_bytecode = R3;\n@@ -420,2 +502,2 @@\n-#define R2_ClassCastException_obj        R2\n-#define R4_ArrayIndexOutOfBounds_index   R4\n+constexpr Register R2_ClassCastException_obj = R2;\n+constexpr Register R4_ArrayIndexOutOfBounds_index = R4;\n@@ -424,1 +506,1 @@\n-#define Rstack_top             SP\n+constexpr Register Rstack_top = SP;\n@@ -447,4 +529,5 @@\n-#define c_rarg0  R0\n-#define c_rarg1  R1\n-#define c_rarg2  R2\n-#define c_rarg3  R3\n+\n+constexpr Register c_rarg0 = R0;\n+constexpr Register c_rarg1 = R1;\n+constexpr Register c_rarg2 = R2;\n+constexpr Register c_rarg3 = R3;\n@@ -458,4 +541,4 @@\n-#define j_rarg0  c_rarg0\n-#define j_rarg1  c_rarg1\n-#define j_rarg2  c_rarg2\n-#define j_rarg3  c_rarg3\n+constexpr Register j_rarg0 = c_rarg0;\n+constexpr Register j_rarg1 = c_rarg1;\n+constexpr Register j_rarg2 = c_rarg2;\n+constexpr Register j_rarg3 = c_rarg3;\n","filename":"src\/hotspot\/cpu\/arm\/register_arm.hpp","additions":314,"deletions":231,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -185,2 +185,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in sparc.ad file)\n","filename":"src\/hotspot\/cpu\/arm\/runtime_arm.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    fpu_save_size = FloatRegisterImpl::number_of_registers,\n+    fpu_save_size = FloatRegister::number_of_registers,\n@@ -142,2 +142,2 @@\n-      if (FloatRegisterImpl::number_of_registers > 32) {\n-        assert(FloatRegisterImpl::number_of_registers == 64, \"nb fp registers should be 64\");\n+      if (FloatRegister::number_of_registers > 32) {\n+        assert(FloatRegister::number_of_registers == 64, \"nb fp registers should be 64\");\n@@ -185,2 +185,2 @@\n-      if (FloatRegisterImpl::number_of_registers > 32) {\n-        assert(FloatRegisterImpl::number_of_registers == 64, \"nb fp registers should be 64\");\n+      if (FloatRegister::number_of_registers > 32) {\n+        assert(FloatRegister::number_of_registers == 64, \"nb fp registers should be 64\");\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    for (int j = 0; j < (1 << ConcreteRegisterImpl::log_vmregs_per_gpr); j++) {\n+    for (int j = 0; j < Register::max_slots_per_register; j++) {\n@@ -40,1 +40,1 @@\n-    for (int j = 0; j < (1 << ConcreteRegisterImpl::log_vmregs_per_fpr); j++) {\n+    for (int j = 0; j < Register::max_slots_per_register; j++) {\n","filename":"src\/hotspot\/cpu\/arm\/vmreg_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    return ::as_Register(value() >> ConcreteRegisterImpl::log_vmregs_per_gpr);\n+    return ::as_Register(value() \/ Register::max_slots_per_register);\n@@ -45,1 +45,1 @@\n-    return ::as_FloatRegister((value() - ConcreteRegisterImpl::max_gpr) >> ConcreteRegisterImpl::log_vmregs_per_fpr);\n+    return ::as_FloatRegister((value() - ConcreteRegisterImpl::max_gpr) \/ FloatRegister::max_slots_per_register);\n@@ -50,1 +50,1 @@\n-      return ((value() & right_n_bits(ConcreteRegisterImpl::log_vmregs_per_gpr)) == 0);\n+      return (value() % Register::max_slots_per_register == 0);\n@@ -52,1 +52,1 @@\n-      return (((value() - ConcreteRegisterImpl::max_gpr) & right_n_bits(ConcreteRegisterImpl::log_vmregs_per_fpr)) == 0);\n+      return (value() % FloatRegister::max_slots_per_register == 0); \/\/ Single slot\n","filename":"src\/hotspot\/cpu\/arm\/vmreg_arm.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-inline VMReg RegisterImpl::as_VMReg() {\n-  return VMRegImpl::as_VMReg(encoding() << ConcreteRegisterImpl::log_vmregs_per_gpr);\n+inline VMReg Register::RegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg(encoding() * Register::max_slots_per_register);\n@@ -32,2 +32,2 @@\n-inline VMReg FloatRegisterImpl::as_VMReg() {\n-  return VMRegImpl::as_VMReg((encoding() << ConcreteRegisterImpl::log_vmregs_per_fpr) + ConcreteRegisterImpl::max_gpr);\n+inline VMReg FloatRegister::FloatRegisterImpl::as_VMReg() const {\n+  return VMRegImpl::as_VMReg((encoding() * FloatRegister::max_slots_per_register) + ConcreteRegisterImpl::max_gpr);\n","filename":"src\/hotspot\/cpu\/arm\/vmreg_arm.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -267,0 +267,3 @@\n+  Label start;\n+\n+  __ bind(start);\n@@ -268,0 +271,2 @@\n+  int entry_offset = __ offset();\n+  __ b(start);\n@@ -270,0 +275,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -272,1 +279,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  _deopt_handler_size = MacroAssembler::bl64_patchable_size\n+  _deopt_handler_size = MacroAssembler::bl64_patchable_size + BytesPerInstWord\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n-\n@@ -534,0 +532,8 @@\n+  enum ppc_specific_constants {\n+    \/\/ If the check is adjusted to read beyond size of the instruction at the deopt handler stub\n+    \/\/ code entry point, it has to happen in two stages - to prevent out of bounds access in case\n+    \/\/ the return address points to the entry point which could be at the end of page.\n+    first_check_size = BytesPerInstWord\n+  };\n+\n+  bool is_post_call_nop() const { return MacroAssembler::is_post_call_nop(long_at(0)); }\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2091,1 +2091,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2094,5 +2093,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ The exception_handler is a b64_patchable.\n-    return MacroAssembler::b64_patchable_size;\n-  }\n-\n@@ -2101,1 +2095,1 @@\n-    return MacroAssembler::bl64_patchable_size;\n+    return MacroAssembler::bl64_patchable_size + BytesPerInstWord;\n@@ -2117,16 +2111,0 @@\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  __ b64_patchable((address)OptoRuntime::exception_blob()->content_begin(),\n-                       relocInfo::runtime_call_type);\n-  assert(__ offset() - offset == (int)size_exception_handler(), \"must be fixed size\");\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -2143,0 +2121,4 @@\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -2145,0 +2127,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ b(start);\n+\n@@ -2146,0 +2133,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2148,1 +2137,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n","filename":"src\/hotspot\/cpu\/ppc\/runtime_ppc.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-                         int return_pc_adjustment,\n@@ -265,1 +264,0 @@\n-                         int return_pc_adjustment,\n@@ -274,1 +272,0 @@\n-  \/\/ If return_pc_adjustment != 0 adjust the return pc by return_pc_adjustment.\n@@ -308,1 +305,1 @@\n-    case return_pc_is_pre_saved: assert(return_pc_adjustment == 0, \"unsupported\"); break;\n+    case return_pc_is_pre_saved: break;\n@@ -313,3 +310,0 @@\n-    if (return_pc_adjustment != 0) {\n-      __ addi(R31, R31, return_pc_adjustment);\n-    }\n@@ -2910,2 +2904,0 @@\n-  \/\/ So currently SR_LR points behind the call in the deopt handler.\n-  \/\/ We adjust it such that it points to the start of the deopt handler.\n@@ -2915,4 +2907,0 @@\n-  \/\/ We can't grab a free register here, because all registers may\n-  \/\/ contain live values, so let the RegisterSaver do the adjustment\n-  \/\/ of the return pc.\n-  const int return_pc_adjustment_no_exception = -MacroAssembler::bl64_patchable_size;\n@@ -2925,1 +2913,0 @@\n-                                                                   return_pc_adjustment_no_exception,\n@@ -2960,1 +2947,0 @@\n-                                                             \/*return_pc_adjustment_exception=*\/ 0,\n@@ -2978,1 +2964,0 @@\n-                                                             \/*return_pc_adjustment_reexecute=*\/ 0,\n@@ -3269,1 +3254,0 @@\n-                                                                   \/*return_pc_adjustment=*\/0,\n@@ -3370,1 +3354,0 @@\n-                                                                   \/*return_pc_adjustment*\/ 0,\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -380,2 +380,8 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ j(start);\n+\n@@ -383,0 +389,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -385,1 +393,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    \/\/ auipc (1) + far_jump (2)\n+    \/\/ far_call (2) + j (1)\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,0 +314,7 @@\n+  enum RISCV_specific_constants {\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in\n+    \/\/ case the return address points to the deopt handler stub code entry point\n+    \/\/ which could be at the end of page.\n+    first_check_size = instruction_size\n+  };\n+\n@@ -319,1 +326,1 @@\n-    return is_nop() && MacroAssembler::is_lui_to_zr_at(addr_at(4));\n+    return is_nop() && MacroAssembler::is_lui_to_zr_at(addr_at(first_check_size));\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1052,1 +1052,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1055,4 +1054,0 @@\n-  static uint size_exception_handler() {\n-    return MacroAssembler::far_branch_size();\n-  }\n-\n@@ -1060,1 +1055,1 @@\n-    \/\/ count auipc + far branch\n+    \/\/ count far call + j\n@@ -1841,19 +1836,0 @@\n-\/\/ Emit exception handler code.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm)\n-{\n-  \/\/ auipc t1, #exception_blob_entry_point\n-  \/\/ jr (offset)t1\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ far_jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -1870,2 +1846,7 @@\n-  __ auipc(ra, 0);\n-  __ far_jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ far_call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+  __ j(start);\n@@ -1874,0 +1855,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -1875,1 +1858,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -252,2 +252,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in riscv.ad file)\n","filename":"src\/hotspot\/cpu\/riscv\/runtime_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,3 +92,0 @@\n-          stringStream ss;                                                                                  \\\n-          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n-          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n@@ -97,0 +94,4 @@\n+          stringStream ss;                                                                                  \\\n+          ss.print(\"missing dependent extension(s): \");                                                     \\\n+          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n+          log_disabled(ss.as_string(true));                                                                 \\\n@@ -104,3 +105,0 @@\n-          stringStream ss;                                                                                  \\\n-          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n-          warning(\"Cannot enable \" #flag \", it's missing dependent extension(s) %s\", ss.as_string(true));   \\\n@@ -109,0 +107,4 @@\n+          stringStream ss;                                                                                  \\\n+          ss.print(\"missing dependent extension(s): \");                                                     \\\n+          deps_string(ss, dep0, ##__VA_ARGS__);                                                             \\\n+          log_disabled(ss.as_string(true));                                                                 \\\n@@ -139,0 +141,1 @@\n+    void log_disabled(const char* reason);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -275,1 +275,7 @@\n-  }  int offset = code_offset();\n+  }\n+\n+  int offset = code_offset();\n+\n+  Label start;\n+  __ bind(start);\n+\n@@ -279,0 +285,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -280,0 +291,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -282,1 +295,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -652,0 +652,7 @@\n+  enum z_specific_constants {\n+    \/\/ Once the check is implemented, this has to specify number of bytes checked on the first\n+    \/\/ read. If the check would read beyond size of the instruction at the deopt handler stub\n+    \/\/ code entry point, then it has to happen in two stages - to prevent out of bounds access\n+    \/\/ in case the return address points to the entry point which could be at the end of page.\n+    first_check_size = 0 \/\/ check is unimplemented\n+  };\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in s390.ad file)\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1652,1 +1652,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -1655,4 +1654,0 @@\n-  static uint size_exception_handler() {\n-    return NativeJump::max_instruction_size();\n-  }\n-\n@@ -1660,1 +1655,1 @@\n-    return NativeCall::max_instruction_size();\n+    return NativeCall::max_instruction_size() + MacroAssembler::jump_pcrelative_size();\n@@ -1675,37 +1670,0 @@\n-\/\/ This exception handler code snippet is placed after the method's\n-\/\/ code. It is the return point if an exception occurred. it jumps to\n-\/\/ the exception blob.\n-\/\/\n-\/\/ If the method gets deoptimized, the method and this code snippet\n-\/\/ get patched.\n-\/\/\n-\/\/ 1) Trampoline code gets patched into the end of this exception\n-\/\/   handler. the trampoline code jumps to the deoptimization blob.\n-\/\/\n-\/\/ 2) The return address in the method's code will get patched such\n-\/\/   that it jumps to the trampoline.\n-\/\/\n-\/\/ 3) The handler will get patched such that it does not jump to the\n-\/\/   exception blob, but to an entry in the deoptimization blob being\n-\/\/   aware of the exception.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler *masm) {\n-  Register temp_reg = Z_R1;\n-\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;          \/\/ CodeBuffer::expand failed\n-  }\n-\n-  int offset = __ offset();\n-  \/\/ Use unconditional pc-relative jump with 32-bit range here.\n-  __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()->content_begin());\n-  __ z_br(temp_reg);\n-\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-\n-  __ end_a_stub();\n-\n-  return offset;\n-}\n-\n@@ -1723,0 +1681,3 @@\n+  Label start;\n+  __ bind(start);\n+\n@@ -1727,0 +1688,5 @@\n+\n+  int entry_offset = __ offset();\n+\n+  __ z_bru(start);\n+\n@@ -1728,0 +1694,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -1730,1 +1698,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":12,"deletions":44,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2547,2 +2547,1 @@\n-  \/\/ Z_R14 points behind the call in the deopt handler. We adjust\n-  \/\/ it such that it points to the start of the deopt handler.\n+  \/\/ Z_R14 points to the entry point of the deopt handler.\n@@ -2552,3 +2551,0 @@\n-  \/\/ The (int) cast is necessary, because -((unsigned int)14)\n-  \/\/ is an unsigned int.\n-  __ add2reg(Z_R14, -(int)NativeCall::max_instruction_size());\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3863,0 +3863,40 @@\n+void Assembler::vmovsldup(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovshdup(XMMRegister dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x16, (0xC0 | encode));\n+}\n+\n+void Assembler::evmovsldup(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x12, (0xC0 | encode));\n+}\n+\n+void Assembler::evmovshdup(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x16, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1667,0 +1667,5 @@\n+  void vmovsldup(XMMRegister dst, XMMRegister src, int vector_len);\n+  void vmovshdup(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evmovsldup(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evmovshdup(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -456,1 +456,0 @@\n-  InternalAddress here(__ pc());\n@@ -458,2 +457,9 @@\n-  __ pushptr(here.addr(), rscratch1);\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n+\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n+\n@@ -461,0 +467,2 @@\n+  assert(code_offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -463,1 +471,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    _deopt_handler_size = 17\n+    _deopt_handler_size = 7\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -456,1 +456,1 @@\n-    assert(sender_pc == nm->deopt_handler_begin(), \"unexpected sender pc\");\n+    assert(sender_pc == nm->deopt_handler_entry(), \"unexpected sender pc\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1425,0 +1425,1 @@\n+  using Assembler::evpcmpeqd;\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  jshort short_at(int offset) const    { return *(jshort*) addr_at(offset); }\n@@ -581,1 +582,6 @@\n-    displacement_offset = 4\n+    displacement_offset = 4,\n+\n+    \/\/ The two parts should be checked separately to prevent out of bounds access in case\n+    \/\/ the return address points to the deopt handler stub code entry point which could be\n+    \/\/ at the end of page.\n+    first_check_size = 2\n@@ -584,1 +590,1 @@\n-  bool check() const { return int_at(0) == 0x841f0f; }\n+  bool check() const { return short_at(0) == 0x1f0f && short_at(first_check_size) == 0x0084; }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -245,2 +245,0 @@\n-\/\/ Using exception blob, this code is jumped from a compiled method.\n-\/\/ (see emit_exception_handler in x86_64.ad file)\n","filename":"src\/hotspot\/cpu\/x86\/runtime_x86_64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Intel Corporation. All rights reserved.\n@@ -33,2 +34,0 @@\n-#define xmm(i) as_XMMRegister(i)\n-\n@@ -43,2 +42,0 @@\n-#define XMMBYTES 64\n-\n@@ -49,3 +46,3 @@\n-    8380417, \/\/ dilithium_q\n-    2365951, \/\/ montRSquareModQ\n-    5373807 \/\/ Barrett addend for modular reduction\n+    8380417,  \/\/ dilithium_q\n+    2365951,  \/\/ montRSquareModQ\n+    5373807   \/\/ Barrett addend for modular reduction\n@@ -63,4 +60,4 @@\n-const Register scratch = r10;\n-const XMMRegister montMulPerm = xmm28;\n-const XMMRegister montQInvModR = xmm30;\n-const XMMRegister dilithium_q = xmm31;\n+ATTRIBUTE_ALIGNED(64) static const uint32_t unshufflePerms[] = {\n+  \/\/ Shuffle for the 128-bit element swap (uint64_t)\n+  0, 0, 1,  0, 8,  0, 9, 0, 4, 0, 5, 0, 12, 0, 13, 0,\n+  10, 0, 11, 0, 2, 0, 3, 0, 14, 0, 15, 0, 6, 0, 7, 0,\n@@ -68,0 +65,3 @@\n+  \/\/ Final shuffle for AlmostNtt\n+  0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23,\n+  24, 8, 25, 9, 26, 10, 27, 11, 28, 12, 29, 13, 30, 14, 31, 15,\n@@ -69,35 +69,3 @@\n-ATTRIBUTE_ALIGNED(64) static const uint32_t dilithiumAvx512Perms[] = {\n-     \/\/ collect montmul results into the destination register\n-    17, 1, 19, 3, 21, 5, 23, 7, 25, 9, 27, 11, 29, 13, 31, 15,\n-    \/\/ ntt\n-    \/\/ level 4\n-    0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23,\n-    8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31,\n-    \/\/ level 5\n-    0, 1, 2, 3, 16, 17, 18, 19, 8, 9, 10, 11, 24, 25, 26, 27,\n-    4, 5, 6, 7, 20, 21, 22, 23, 12, 13, 14, 15, 28, 29, 30, 31,\n-    \/\/ level 6\n-    0, 1, 16, 17, 4, 5, 20, 21, 8, 9, 24, 25, 12, 13, 28, 29,\n-    2, 3, 18, 19, 6, 7, 22, 23, 10, 11, 26, 27, 14, 15, 30, 31,\n-    \/\/ level 7\n-    0, 16, 2, 18, 4, 20, 6, 22, 8, 24, 10, 26, 12, 28, 14, 30,\n-    1, 17, 3, 19, 5, 21, 7, 23, 9, 25, 11, 27, 13, 29, 15, 31,\n-    0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23,\n-    8, 24, 9, 25, 10, 26, 11, 27, 12, 28, 13, 29, 14, 30, 15, 31,\n-\n-    \/\/ ntt inverse\n-    \/\/ level 0\n-    0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,\n-    1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31,\n-    \/\/ level 1\n-    0, 16, 2, 18, 4, 20, 6, 22, 8, 24, 10, 26, 12, 28, 14, 30,\n-    1, 17, 3, 19, 5, 21, 7, 23, 9, 25, 11, 27, 13, 29, 15, 31,\n-    \/\/ level 2\n-    0, 1, 16, 17, 4, 5, 20, 21, 8, 9, 24, 25, 12, 13, 28, 29,\n-    2, 3, 18, 19, 6, 7, 22, 23, 10, 11, 26, 27, 14, 15, 30, 31,\n-    \/\/ level 3\n-    0, 1, 2, 3, 16, 17, 18, 19, 8, 9, 10, 11, 24, 25, 26, 27,\n-    4, 5, 6, 7, 20, 21, 22, 23, 12, 13, 14, 15, 28, 29, 30, 31,\n-    \/\/ level 4\n-    0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 23,\n-    8, 9, 10, 11, 12, 13, 14, 15, 24, 25, 26, 27, 28, 29, 30, 31\n+  \/\/ Initial shuffle for AlmostInverseNtt\n+  0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30,\n+  17, 19, 21, 23, 25, 27, 29, 31, 1, 3, 5, 7, 9, 11, 13, 15\n@@ -106,13 +74,2 @@\n-const int montMulPermsIdx = 0;\n-const int nttL4PermsIdx = 64;\n-const int nttL5PermsIdx = 192;\n-const int nttL6PermsIdx = 320;\n-const int nttL7PermsIdx = 448;\n-const int nttInvL0PermsIdx = 704;\n-const int nttInvL1PermsIdx = 832;\n-const int nttInvL2PermsIdx = 960;\n-const int nttInvL3PermsIdx = 1088;\n-const int nttInvL4PermsIdx = 1216;\n-\n-static address dilithiumAvx512PermsAddr() {\n-  return (address) dilithiumAvx512Perms;\n+static address unshufflePermsAddr(int offset) {\n+  return ((address) unshufflePerms) + offset*64;\n@@ -121,22 +78,13 @@\n-\/\/ We do Montgomery multiplications of two vectors of 16 ints each in 4 steps:\n-\/\/ 1. Do the multiplications of the corresponding even numbered slots into\n-\/\/    the odd numbered slots of a third register.\n-\/\/ 2. Swap the even and odd numbered slots of the original input registers.\n-\/\/ 3. Similar to step 1, but into a different output register.\n-\/\/ 4. Combine the outputs of step 1 and step 3 into the output of the Montgomery\n-\/\/    multiplication.\n-\/\/ (For levels 0-6 in the Ntt and levels 1-7 of the inverse Ntt we only swap the\n-\/\/ odd-even slots of the first multiplicand as in the second (zetas) the\n-\/\/ odd slots contain the same number as the corresponding even one.)\n-\/\/ The indexes of the registers to be multiplied\n-\/\/ are in inputRegs1[] and inputRegs[2].\n-\/\/ The results go to the registers whose indexes are in outputRegs.\n-\/\/ scratchRegs should contain 12 different register indexes.\n-\/\/ The set in outputRegs should not overlap with the set of the middle four\n-\/\/ scratch registers.\n-\/\/ The sets in inputRegs1 and inputRegs2 cannot overlap with the set of the\n-\/\/ first eight scratch registers.\n-\/\/ In most of the cases, the odd and the corresponding even slices of the\n-\/\/ registers indexed by the numbers in inputRegs2 will contain the same number,\n-\/\/ this should be indicated by calling this function with\n-\/\/ input2NeedsShuffle=false .\n+\/\/ The following function swaps elements A<->B, C<->D, and so forth.\n+\/\/ input1[] is shuffled in place; shuffle of input2[] is copied to output2[].\n+\/\/ Element size (in bits) is specified by size parameter.\n+\/\/ +-----+-----+-----+-----+-----\n+\/\/ |     |  A  |     |  C  | ...\n+\/\/ +-----+-----+-----+-----+-----\n+\/\/ +-----+-----+-----+-----+-----\n+\/\/ |  B  |     |  D  |     | ...\n+\/\/ +-----+-----+-----+-----+-----\n+\/\/\n+\/\/ NOTE: size 0 and 1 are used for initial and final shuffles respectively of\n+\/\/ dilithiumAlmostInverseNtt and dilithiumAlmostNtt. For size 0 and 1, input1[]\n+\/\/ and input2[] are modified in-place (and output2 is used as a temporary)\n@@ -144,3 +92,3 @@\n-static void montMul64(int outputRegs[], int inputRegs1[], int inputRegs2[],\n-                      int scratchRegs[], bool input2NeedsShuffle,\n-                      MacroAssembler *_masm) {\n+\/\/ Using C++ lambdas for improved readability (to hide parameters that always repeat)\n+static auto whole_shuffle(Register scratch, KRegister mergeMask1, KRegister mergeMask2,\n+  const XMMRegister unshuffle1, const XMMRegister unshuffle2, int vector_len, MacroAssembler *_masm) {\n@@ -148,15 +96,3 @@\n-  for (int i = 0; i < 4; i++) {\n-    __ vpmuldq(xmm(scratchRegs[i]), xmm(inputRegs1[i]), xmm(inputRegs2[i]),\n-               Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 4; i++) {\n-    __ vpmulld(xmm(scratchRegs[i + 4]), xmm(scratchRegs[i]), montQInvModR,\n-               Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 4; i++) {\n-    __ vpmuldq(xmm(scratchRegs[i + 4]), xmm(scratchRegs[i + 4]), dilithium_q,\n-               Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 4; i++) {\n-    __ evpsubd(xmm(scratchRegs[i + 4]), k0, xmm(scratchRegs[i]),\n-               xmm(scratchRegs[i + 4]), false, Assembler::AVX_512bit);\n+  int regCnt = 4;\n+  if (vector_len == Assembler::AVX_256bit) {\n+    regCnt = 2;\n@@ -165,6 +101,141 @@\n-  for (int i = 0; i < 4; i++) {\n-    __ vpshufd(xmm(inputRegs1[i]), xmm(inputRegs1[i]), 0xB1,\n-               Assembler::AVX_512bit);\n-    if (input2NeedsShuffle) {\n-       __ vpshufd(xmm(inputRegs2[i]), xmm(inputRegs2[i]), 0xB1,\n-                  Assembler::AVX_512bit);\n+  return [=](const XMMRegister output2[], const XMMRegister input1[],\n+    const XMMRegister input2[], int size) {\n+    if (vector_len == Assembler::AVX_256bit) {\n+      switch (size) {\n+        case 128:\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vperm2i128(output2[i], input1[i], input2[i], 0b110001);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vinserti128(input1[i], input1[i], input2[i], 1);\n+          }\n+          break;\n+        case 64:\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vshufpd(output2[i], input1[i], input2[i], 0b11111111, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vshufpd(input1[i], input1[i], input2[i], 0b00000000, vector_len);\n+          }\n+          break;\n+        case 32:\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vmovshdup(output2[i], input1[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vpblendd(output2[i], output2[i], input2[i], 0b10101010, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vmovsldup(input2[i], input2[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vpblendd(input1[i], input1[i], input2[i], 0b10101010, vector_len);\n+          }\n+          break;\n+        \/\/ Special cases\n+        case 1: \/\/ initial shuffle for dilithiumAlmostInverseNtt\n+          \/\/ shuffle all even 32bit columns to input1, and odd to input2\n+          for (int i = 0; i < regCnt; i++) {\n+            \/\/ 0b-3-1-3-1\n+            __ vshufps(output2[i], input1[i], input2[i], 0b11011101, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            \/\/ 0b-2-0-2-0\n+            __ vshufps(input1[i], input1[i], input2[i], 0b10001000, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vpermq(input2[i], output2[i], 0b11011000, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            \/\/ 0b-3-1-2-0\n+            __ vpermq(input1[i], input1[i], 0b11011000, vector_len);\n+          }\n+          break;\n+        case 0: \/\/ final unshuffle for dilithiumAlmostNtt\n+          \/\/ reverse case 1: all even are in input1 and odd in input2, put back\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vpunpckhdq(output2[i], input1[i], input2[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vpunpckldq(input1[i], input1[i], input2[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vperm2i128(input2[i], input1[i], output2[i], 0b110001);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vinserti128(input1[i], input1[i], output2[i], 1);\n+          }\n+          break;\n+        default:\n+          assert(false, \"Don't call here\");\n+      }\n+    } else {\n+      switch (size) {\n+        case 256:\n+          for (int i = 0; i < regCnt; i++) {\n+            \/\/ 0b-3-2-3-2\n+            __ evshufi64x2(output2[i], input1[i], input2[i], 0b11101110, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vinserti64x4(input1[i], input1[i], input2[i], 1);\n+          }\n+          break;\n+        case 128:\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vmovdqu(output2[i], input2[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evpermt2q(output2[i], unshuffle2, input1[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evpermt2q(input1[i], unshuffle1, input2[i], vector_len);\n+          }\n+\n+          break;\n+        case 64:\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vshufpd(output2[i], input1[i], input2[i], 0b11111111, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vshufpd(input1[i], input1[i], input2[i], 0b00000000, vector_len);\n+          }\n+          break;\n+        case 32:\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vmovdqu(output2[i], input2[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evmovshdup(output2[i], mergeMask2, input1[i], true, vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evmovsldup(input1[i], mergeMask1, input2[i], true, vector_len);\n+          }\n+          break;\n+        \/\/ Special cases\n+        case 1: \/\/ initial shuffle for dilithiumAlmostInverseNtt\n+          \/\/ shuffle all even 32bit columns to input1, and odd to input2\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vmovdqu(output2[i], input2[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evpermt2d(input2[i], unshuffle2, input1[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evpermt2d(input1[i], unshuffle1, output2[i], vector_len);\n+          }\n+          break;\n+        case 0: \/\/ final unshuffle for dilithiumAlmostNtt\n+          \/\/ reverse case 1: all even are in input1 and odd in input2, put back\n+          for (int i = 0; i < regCnt; i++) {\n+            __ vmovdqu(output2[i], input2[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evpermt2d(input2[i], unshuffle2, input1[i], vector_len);\n+          }\n+          for (int i = 0; i < regCnt; i++) {\n+            __ evpermt2d(input1[i], unshuffle1, output2[i], vector_len);\n+          }\n+          break;\n+        default:\n+          assert(false, \"Don't call here\");\n+      }\n@@ -172,1 +243,2 @@\n-  }\n+  }; \/\/ return\n+}\n@@ -174,15 +246,27 @@\n-  for (int i = 0; i < 4; i++) {\n-    __ vpmuldq(xmm(scratchRegs[i]), xmm(inputRegs1[i]), xmm(inputRegs2[i]),\n-               Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 4; i++) {\n-    __ vpmulld(xmm(scratchRegs[i + 8]), xmm(scratchRegs[i]), montQInvModR,\n-               Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 4; i++) {\n-    __ vpmuldq(xmm(scratchRegs[i + 8]), xmm(scratchRegs[i + 8]), dilithium_q,\n-               Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 4; i++) {\n-    __ evpsubd(xmm(outputRegs[i]), k0, xmm(scratchRegs[i]),\n-               xmm(scratchRegs[i + 8]), false, Assembler::AVX_512bit);\n+\/\/ We do Montgomery multiplications of two AVX registers in 4 steps:\n+\/\/ 1. Do the multiplications of the corresponding even numbered slots into\n+\/\/    the odd numbered slots of the scratch2 register.\n+\/\/ 2. Swap the even and odd numbered slots of the original input registers.(*Note)\n+\/\/ 3. Similar to step 1, but multiplication result is placed into output register.\n+\/\/ 4. Combine odd\/even slots respectively from the scratch2 and output registers\n+\/\/    into the output register for the final result of the Montgomery multiplication.\n+\/\/ (*Note: For levels 0-6 in the Ntt and levels 1-7 of the inverse Ntt, need NOT\n+\/\/         swap the second operand (zetas) since the odd slots contain the same number\n+\/\/         as the corresponding even one. This is indicated by input2NeedsShuffle=false)\n+\/\/\n+\/\/ The registers to be multiplied are in input1[] and inputs2[]. The results go\n+\/\/ into output[]. Two scratch[] register arrays are expected. input1[] can\n+\/\/ overlap with either output[] or scratch1[]\n+\/\/ - If AVX512, all register arrays are of length 4\n+\/\/ - If AVX2, first two registers of each array are in xmm0-xmm15 range\n+\/\/ Constants montQInvModR, dilithium_q and mergeMask expected to have already\n+\/\/ been loaded.\n+\/\/\n+\/\/ Using C++ lambdas for improved readability (to hide parameters that always repeat)\n+static auto whole_montMul(XMMRegister montQInvModR, XMMRegister dilithium_q,\n+    KRegister mergeMask, int vector_len, MacroAssembler *_masm) {\n+  int regCnt = 4;\n+  int regSize = 64;\n+  if (vector_len == Assembler::AVX_256bit) {\n+    regCnt = 2;\n+    regSize = 32;\n@@ -191,5 +275,40 @@\n-  for (int i = 0; i < 4; i++) {\n-    __ evpermt2d(xmm(outputRegs[i]), montMulPerm, xmm(scratchRegs[i + 4]),\n-                 Assembler::AVX_512bit);\n-  }\n-}\n+  return [=](const XMMRegister output[], const XMMRegister input1[],\n+    const XMMRegister input2[], const XMMRegister scratch1[],\n+    const XMMRegister scratch2[], bool input2NeedsShuffle = false) {\n+    \/\/ (Register overloading) Can't always use scratch1 (could override input1).\n+    \/\/ If so, use output:\n+    const XMMRegister* scratch = scratch1 == input1 ? output: scratch1;\n+\n+    \/\/ scratch = input1_even * intput2_even\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpmuldq(scratch[i], input1[i], input2[i], vector_len);\n+    }\n+\n+    \/\/ scratch2_low = scratch_low * montQInvModR\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpmuldq(scratch2[i], scratch[i], montQInvModR, vector_len);\n+    }\n+\n+    \/\/ scratch2 = scratch2_low * dilithium_q\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpmuldq(scratch2[i], scratch2[i], dilithium_q, vector_len);\n+    }\n+\n+    \/\/ scratch2_high = scratch2_high - scratch_high\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpsubd(scratch2[i], scratch[i], scratch2[i], vector_len);\n+    }\n+\n+    \/\/ input1_even = input1_odd\n+    \/\/ input2_even = input2_odd\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpshufd(input1[i], input1[i], 0xB1, vector_len);\n+      if (input2NeedsShuffle) {\n+        __ vpshufd(input2[i], input2[i], 0xB1, vector_len);\n+      }\n+    }\n+\n+    \/\/ scratch1 = input1_even*intput2_even\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpmuldq(scratch1[i], input1[i], input2[i], vector_len);\n+    }\n@@ -197,3 +316,29 @@\n-static void montMul64(int outputRegs[], int inputRegs1[], int inputRegs2[],\n-                       int scratchRegs[], MacroAssembler *_masm) {\n-   montMul64(outputRegs, inputRegs1, inputRegs2, scratchRegs, false, _masm);\n+    \/\/ output = scratch1_low * montQInvModR\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpmuldq(output[i], scratch1[i], montQInvModR, vector_len);\n+    }\n+\n+    \/\/ output = output * dilithium_q\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpmuldq(output[i], output[i], dilithium_q, vector_len);\n+    }\n+\n+    \/\/ output_high = scratch1_high - output_high\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpsubd(output[i], scratch1[i], output[i], vector_len);\n+    }\n+\n+    \/\/ output = select(output_high, scratch2_high)\n+    if (vector_len == Assembler::AVX_256bit) {\n+      for (int i = 0; i < regCnt; i++) {\n+        __ vmovshdup(scratch2[i], scratch2[i], vector_len);\n+      }\n+      for (int i = 0; i < regCnt; i++) {\n+        __ vpblendd(output[i], output[i], scratch2[i], 0b01010101, vector_len);\n+      }\n+    } else {\n+      for (int i = 0; i < regCnt; i++) {\n+        __ evmovshdup(output[i], mergeMask, scratch2[i], true, vector_len);\n+      }\n+    }\n+  }; \/\/ return\n@@ -202,2 +347,7 @@\n-static void sub_add(int subResult[], int addResult[],\n-                    int input1[], int input2[], MacroAssembler *_masm) {\n+static void sub_add(const XMMRegister subResult[], const XMMRegister addResult[],\n+                    const XMMRegister input1[], const XMMRegister input2[],\n+                    int vector_len, MacroAssembler *_masm) {\n+  int regCnt = 4;\n+  if (vector_len == Assembler::AVX_256bit) {\n+    regCnt = 2;\n+  }\n@@ -205,3 +355,2 @@\n-  for (int i = 0; i < 4; i++) {\n-    __ evpsubd(xmm(subResult[i]), k0, xmm(input1[i]), xmm(input2[i]), false,\n-               Assembler::AVX_512bit);\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(subResult[i], input1[i], input2[i], vector_len);\n@@ -210,3 +359,2 @@\n-  for (int i = 0; i < 4; i++) {\n-    __ evpaddd(xmm(addResult[i]), k0, xmm(input1[i]), xmm(input2[i]), false,\n-               Assembler::AVX_512bit);\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpaddd(addResult[i], input1[i], input2[i], vector_len);\n@@ -216,9 +364,2 @@\n-static void loadPerm(int destinationRegs[], Register perms,\n-                      int offset, MacroAssembler *_masm) {\n-  __ evmovdqul(xmm(destinationRegs[0]), Address(perms, offset),\n-                 Assembler::AVX_512bit);\n-  for (int i = 1; i < 4; i++) {\n-      __ evmovdqul(xmm(destinationRegs[i]), xmm(destinationRegs[0]),\n-                   Assembler::AVX_512bit);\n-    }\n-}\n+static void loadXmms(const XMMRegister destinationRegs[], Register source, int offset,\n+                     int vector_len, MacroAssembler *_masm, int regCnt = -1, int memStep = -1) {\n@@ -226,5 +367,6 @@\n-static void load4Xmms(int destinationRegs[], Register source, int offset,\n-                       MacroAssembler *_masm) {\n-  for (int i = 0; i < 4; i++) {\n-    __ evmovdqul(xmm(destinationRegs[i]), Address(source, offset + i * XMMBYTES),\n-                 Assembler::AVX_512bit);\n+  if (vector_len == Assembler::AVX_256bit) {\n+    regCnt = regCnt == -1 ? 2 : regCnt;\n+    memStep = memStep == -1 ? 32 : memStep;\n+  } else {\n+    regCnt = 4;\n+    memStep = 64;\n@@ -232,1 +374,0 @@\n-}\n@@ -234,2 +375,3 @@\n-static void loadXmm29(Register source, int offset, MacroAssembler *_masm) {\n-    __ evmovdqul(xmm29, Address(source, offset), Assembler::AVX_512bit);\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vmovdqu(destinationRegs[i], Address(source, offset + i * memStep), vector_len);\n+  }\n@@ -238,5 +380,8 @@\n-static void store4Xmms(Register destination, int offset, int xmmRegs[],\n-                       MacroAssembler *_masm) {\n-  for (int i = 0; i < 4; i++) {\n-    __ evmovdqul(Address(destination, offset + i * XMMBYTES), xmm(xmmRegs[i]),\n-                 Assembler::AVX_512bit);\n+static void storeXmms(Register destination, int offset, const XMMRegister xmmRegs[],\n+                      int vector_len, MacroAssembler *_masm, int regCnt = -1, int memStep = -1) {\n+  if (vector_len == Assembler::AVX_256bit) {\n+    regCnt = regCnt == -1 ? 2 : regCnt;\n+    memStep = memStep == -1 ? 32 : memStep;\n+  } else {\n+    regCnt = 4;\n+    memStep = 64;\n@@ -244,1 +389,0 @@\n-}\n@@ -246,18 +390,4 @@\n-static int xmm0_3[] = {0, 1, 2, 3};\n-static int xmm0145[] = {0, 1, 4, 5};\n-static int xmm0246[] = {0, 2, 4, 6};\n-static int xmm0426[] = {0, 4, 2, 6};\n-static int xmm1357[] = {1, 3, 5, 7};\n-static int xmm1537[] = {1, 5, 3, 7};\n-static int xmm2367[] = {2, 3, 6, 7};\n-static int xmm4_7[] = {4, 5, 6, 7};\n-static int xmm8_11[] = {8, 9, 10, 11};\n-static int xmm12_15[] = {12, 13, 14, 15};\n-static int xmm16_19[] = {16, 17, 18, 19};\n-static int xmm20_23[] = {20, 21, 22, 23};\n-static int xmm20222426[] = {20, 22, 24, 26};\n-static int xmm21232527[] = {21, 23, 25, 27};\n-static int xmm24_27[] = {24, 25, 26, 27};\n-static int xmm4_20_24[] = {4, 5, 6, 7, 20, 21, 22, 23, 24, 25, 26, 27};\n-static int xmm16_27[] = {16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27};\n-static int xmm29_29[] = {29, 29, 29, 29};\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vmovdqu(Address(destination, offset + i * memStep), xmmRegs[i], vector_len);\n+  }\n+}\n@@ -270,2 +400,1 @@\n-\/\/ zetas (int[256]) = c_rarg1\n-\/\/\n+\/\/ zetas (int[128*8]) = c_rarg1\n@@ -273,3 +402,2 @@\n-static address generate_dilithiumAlmostNtt_avx512(StubGenerator *stubgen,\n-                                                  MacroAssembler *_masm) {\n-\n+static address generate_dilithiumAlmostNtt_avx(StubGenerator *stubgen,\n+                                               int vector_len, MacroAssembler *_masm) {\n@@ -282,2 +410,0 @@\n-  Label L_loop, L_end;\n-\n@@ -286,7 +412,1 @@\n-  const Register iterations = c_rarg2;\n-\n-  const Register perms = r11;\n-\n-  __ lea(perms, ExternalAddress(dilithiumAvx512PermsAddr()));\n-\n-  __ evmovdqul(montMulPerm, Address(perms, montMulPermsIdx), Assembler::AVX_512bit);\n+  const Register scratch = r10;\n@@ -298,2 +418,1 @@\n-  \/\/ coefficients. In each level we just collect the coefficients (using\n-  \/\/ evpermi2d() instructions where necessary, i.e. in levels 4-7) that need to\n+  \/\/ coefficients. In each level we just shuffle the coefficients that need to\n@@ -304,2 +423,22 @@\n-  \/\/ that we would use for them, so we use only one, xmm29.\n-  loadXmm29(zetas, 0, _masm);\n+  \/\/ that we would use for them, so we use only one register.\n+\n+  \/\/ AVX2 version uses the first half of these arrays\n+  const XMMRegister Coeffs1[] = {xmm0, xmm1, xmm16, xmm17};\n+  const XMMRegister Coeffs2[] = {xmm2, xmm3, xmm18, xmm19};\n+  const XMMRegister Coeffs3[] = {xmm4, xmm5, xmm20, xmm21};\n+  const XMMRegister Coeffs4[] = {xmm6, xmm7, xmm22, xmm23};\n+  const XMMRegister Scratch1[] = {xmm8, xmm9, xmm24, xmm25};\n+  const XMMRegister Scratch2[] = {xmm10, xmm11, xmm26, xmm27};\n+  const XMMRegister Zetas1[] = {xmm12, xmm12, xmm12, xmm12};\n+  const XMMRegister Zetas2[] = {xmm12, xmm12, xmm13, xmm13};\n+  const XMMRegister Zetas3[] = {xmm12, xmm13, xmm28, xmm29};\n+  const XMMRegister montQInvModR = xmm14;\n+  const XMMRegister dilithium_q = xmm15;\n+  const XMMRegister unshuffle1 = xmm30;\n+  const XMMRegister unshuffle2 = xmm31;\n+  KRegister mergeMask1 = k1;\n+  KRegister mergeMask2 = k2;\n+  \/\/ lambdas to hide repeated parameters\n+  auto shuffle = whole_shuffle(scratch, mergeMask1, mergeMask2, unshuffle1, unshuffle2, vector_len, _masm);\n+  auto montMul64 = whole_montMul(montQInvModR, dilithium_q, mergeMask2, vector_len, _masm);\n+\n@@ -308,1 +447,1 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q^-1 mod 2^32\n+                  vector_len, scratch); \/\/ q^-1 mod 2^32\n@@ -311,110 +450,83 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q\n-\n-  \/\/ load all coefficients into the vector registers Zmm_0-Zmm_15,\n-  \/\/ 16 coefficients into each\n-  load4Xmms(xmm0_3, coeffs, 0, _masm);\n-  load4Xmms(xmm4_7, coeffs, 4 * XMMBYTES, _masm);\n-  load4Xmms(xmm8_11, coeffs, 8 * XMMBYTES, _masm);\n-  load4Xmms(xmm12_15, coeffs, 12 * XMMBYTES, _masm);\n-\n-  \/\/ level 0 and 1 can be done entirely in registers as the zetas on these\n-  \/\/ levels are the same for all the montmuls that we can do in parallel\n-\n-  \/\/ level 0\n-  montMul64(xmm16_19, xmm8_11, xmm29_29, xmm16_27, _masm);\n-  sub_add(xmm8_11, xmm0_3, xmm0_3, xmm16_19, _masm);\n-  montMul64(xmm16_19, xmm12_15, xmm29_29, xmm16_27, _masm);\n-  loadXmm29(zetas, 512, _masm); \/\/ for level 1\n-  sub_add(xmm12_15, xmm4_7, xmm4_7, xmm16_19, _masm);\n-\n-  \/\/ level 1\n-\n-  montMul64(xmm16_19, xmm4_7, xmm29_29, xmm16_27, _masm);\n-  loadXmm29(zetas, 768, _masm);\n-  sub_add(xmm4_7, xmm0_3, xmm0_3, xmm16_19, _masm);\n-  montMul64(xmm16_19, xmm12_15, xmm29_29, xmm16_27, _masm);\n-  sub_add(xmm12_15, xmm8_11, xmm8_11, xmm16_19, _masm);\n-\n-  \/\/ levels 2 to 7 are done in 2 batches, by first saving half of the coefficients\n-  \/\/ from level 1 into memory, doing all the level 2 to level 7 computations\n-  \/\/ on the remaining half in the vector registers, saving the result to\n-  \/\/ memory after level 7, then loading back the coefficients that we saved after\n-  \/\/ level 1 and do the same computation with those\n-\n-  store4Xmms(coeffs, 8 * XMMBYTES, xmm8_11, _masm);\n-  store4Xmms(coeffs, 12 * XMMBYTES, xmm12_15, _masm);\n-\n-  __ movl(iterations, 2);\n-\n-  __ align(OptoLoopAlignment);\n-  __ BIND(L_loop);\n-\n-  __ subl(iterations, 1);\n-\n-  \/\/ level 2\n-  load4Xmms(xmm12_15, zetas, 2 * 512, _masm);\n-  montMul64(xmm16_19, xmm2367, xmm12_15, xmm16_27, _masm);\n-  load4Xmms(xmm12_15, zetas, 3 * 512, _masm); \/\/ for level 3\n-  sub_add(xmm2367, xmm0145, xmm0145, xmm16_19, _masm);\n-\n-  \/\/ level 3\n-\n-  montMul64(xmm16_19, xmm1357, xmm12_15, xmm16_27, _masm);\n-  sub_add(xmm1357, xmm0246, xmm0246, xmm16_19, _masm);\n-\n-  \/\/ level 4\n-  loadPerm(xmm16_19, perms, nttL4PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttL4PermsIdx + 64, _masm);\n-  load4Xmms(xmm24_27, zetas, 4 * 512, _masm);\n-\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i\/2 + 16), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i \/ 2 + 12), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-\n-  montMul64(xmm12_15, xmm12_15, xmm24_27, xmm4_20_24, _masm);\n-  sub_add(xmm1357, xmm0246, xmm16_19, xmm12_15, _masm);\n-\n-  \/\/ level 5\n-  loadPerm(xmm16_19, perms, nttL5PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttL5PermsIdx + 64, _masm);\n-  load4Xmms(xmm24_27, zetas, 5 * 512, _masm);\n-\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i\/2 + 16), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i \/ 2 + 12), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-\n-  montMul64(xmm12_15, xmm12_15, xmm24_27, xmm4_20_24, _masm);\n-  sub_add(xmm1357, xmm0246, xmm16_19, xmm12_15, _masm);\n-\n-  \/\/ level 6\n-  loadPerm(xmm16_19, perms, nttL6PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttL6PermsIdx + 64, _masm);\n-  load4Xmms(xmm24_27, zetas, 6 * 512, _masm);\n-\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i\/2 + 16), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i \/ 2 + 12), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-\n-  montMul64(xmm12_15, xmm12_15, xmm24_27, xmm4_20_24, _masm);\n-  sub_add(xmm1357, xmm0246, xmm16_19, xmm12_15, _masm);\n-\n-  \/\/ level 7\n-  loadPerm(xmm16_19, perms, nttL7PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttL7PermsIdx + 64, _masm);\n-  load4Xmms(xmm24_27, zetas, 7 * 512, _masm);\n-\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i \/ 2 + 16), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i \/ 2 + 12), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n+                  vector_len, scratch); \/\/ q\n+\n+  if (vector_len == Assembler::AVX_512bit) {\n+    \/\/ levels 0-3, register shuffles:\n+    const XMMRegister Coeffs1_1[] = {xmm0, xmm1, xmm2, xmm3};\n+    const XMMRegister Coeffs2_1[] = {xmm16, xmm17, xmm18, xmm19};\n+    const XMMRegister Coeffs3_1[] = {xmm4, xmm5, xmm6, xmm7};\n+    const XMMRegister Coeffs4_1[] = {xmm20, xmm21, xmm22, xmm23};\n+    const XMMRegister Coeffs1_2[] = {xmm0, xmm16, xmm2, xmm18};\n+    const XMMRegister Coeffs2_2[] = {xmm1, xmm17, xmm3, xmm19};\n+    const XMMRegister Coeffs3_2[] = {xmm4, xmm20, xmm6, xmm22};\n+    const XMMRegister Coeffs4_2[] = {xmm5, xmm21, xmm7, xmm23};\n+\n+    \/\/ Constants for shuffle and montMul64\n+    __ mov64(scratch, 0b1010101010101010);\n+    __ kmovwl(mergeMask1, scratch);\n+    __ knotwl(mergeMask2, mergeMask1);\n+    __ vmovdqu(unshuffle1, ExternalAddress(unshufflePermsAddr(0)), vector_len, scratch);\n+    __ vmovdqu(unshuffle2, ExternalAddress(unshufflePermsAddr(1)), vector_len, scratch);\n+\n+    int memStep = 4 * 64; \/\/ 4*64-byte registers\n+    loadXmms(Coeffs1, coeffs, 0*memStep, vector_len, _masm);\n+    loadXmms(Coeffs2, coeffs, 1*memStep, vector_len, _masm);\n+    loadXmms(Coeffs3, coeffs, 2*memStep, vector_len, _masm);\n+    loadXmms(Coeffs4, coeffs, 3*memStep, vector_len, _masm);\n+\n+    \/\/ level 0-3 can be done by shuffling registers (also notice fewer zetas loads, they repeat)\n+    \/\/ level 0 - 128\n+    \/\/ scratch1 = coeffs3 * zetas1\n+    \/\/ coeffs3, coeffs1 = coeffs1 Â± scratch1\n+    \/\/ scratch1 = coeffs4 * zetas1\n+    \/\/ coeffs4, coeffs2 = coeffs2 Â± scratch1\n+    __ vmovdqu(Zetas1[0], Address(zetas, 0), vector_len);\n+    montMul64(Scratch1, Coeffs3, Zetas1, Coeffs3, Scratch2);\n+    sub_add(Coeffs3, Coeffs1, Coeffs1, Scratch1, vector_len, _masm);\n+    montMul64(Scratch1, Coeffs4, Zetas1, Coeffs4, Scratch2);\n+    sub_add(Coeffs4, Coeffs2, Coeffs2, Scratch1, vector_len, _masm);\n+\n+    \/\/ level 1 - 64\n+    __ vmovdqu(Zetas1[0], Address(zetas,        512), vector_len);\n+    montMul64(Scratch1, Coeffs2, Zetas1, Coeffs2, Scratch2);\n+    sub_add(Coeffs2, Coeffs1, Coeffs1, Scratch1, vector_len, _masm);\n+\n+    __ vmovdqu(Zetas1[0], Address(zetas, 4*64 + 512), vector_len);\n+    montMul64(Scratch1, Coeffs4, Zetas1, Coeffs4, Scratch2);\n+    sub_add(Coeffs4, Coeffs3, Coeffs3, Scratch1, vector_len, _masm);\n+\n+    \/\/ level 2 - 32\n+    __ vmovdqu(Zetas2[0], Address(zetas,        2 * 512), vector_len);\n+    __ vmovdqu(Zetas2[2], Address(zetas, 2*64 + 2 * 512), vector_len);\n+    montMul64(Scratch1, Coeffs2_1, Zetas2, Coeffs2_1, Scratch2);\n+    sub_add(Coeffs2_1, Coeffs1_1, Coeffs1_1, Scratch1, vector_len, _masm);\n+\n+    __ vmovdqu(Zetas2[0], Address(zetas, 4*64 + 2 * 512), vector_len);\n+    __ vmovdqu(Zetas2[2], Address(zetas, 6*64 + 2 * 512), vector_len);\n+    montMul64(Scratch1, Coeffs4_1, Zetas2, Coeffs4_1, Scratch2);\n+    sub_add(Coeffs4_1, Coeffs3_1, Coeffs3_1, Scratch1, vector_len, _masm);\n+\n+    \/\/ level 3 - 16\n+    loadXmms(Zetas3, zetas, 3 * 512, vector_len, _masm);\n+    montMul64(Scratch1, Coeffs2_2, Zetas3, Coeffs2_2, Scratch2);\n+    sub_add(Coeffs2_2, Coeffs1_2, Coeffs1_2, Scratch1, vector_len, _masm);\n+\n+    loadXmms(Zetas3, zetas, 4*64 + 3 * 512, vector_len, _masm);\n+    montMul64(Scratch1, Coeffs4_2, Zetas3, Coeffs4_2, Scratch2);\n+    sub_add(Coeffs4_2, Coeffs3_2, Coeffs3_2, Scratch1, vector_len, _masm);\n+\n+    for (int level = 4, distance = 8; level<8; level++, distance \/= 2) {\n+      \/\/ zetas = load(level * 512)\n+      \/\/ coeffs1_2, scratch1 = shuffle(coeffs1_2, coeffs2_2)\n+      \/\/ scratch1 = scratch1 * zetas\n+      \/\/ coeffs2_2 = coeffs1_2 - scratch1\n+      \/\/ coeffs1_2 = coeffs1_2 + scratch1\n+      loadXmms(Zetas3, zetas, level * 512, vector_len, _masm);\n+      shuffle(Scratch1, Coeffs1_2, Coeffs2_2, distance * 32); \/\/ Coeffs2_2 freed\n+      montMul64(Scratch1, Scratch1, Zetas3, Coeffs2_2, Scratch2, level==7);\n+      sub_add(Coeffs2_2, Coeffs1_2, Coeffs1_2, Scratch1, vector_len, _masm);\n+\n+      loadXmms(Zetas3, zetas, 4*64 + level * 512, vector_len, _masm);\n+      shuffle(Scratch1, Coeffs3_2, Coeffs4_2, distance * 32); \/\/ Coeffs4_2 freed\n+      montMul64(Scratch1, Scratch1, Zetas3, Coeffs4_2, Scratch2, level==7);\n+      sub_add(Coeffs4_2, Coeffs3_2, Coeffs3_2, Scratch1, vector_len, _masm);\n+    }\n@@ -422,4 +534,62 @@\n-  montMul64(xmm12_15, xmm12_15, xmm24_27, xmm4_20_24, true, _masm);\n-  loadPerm(xmm0246, perms, nttL7PermsIdx + 2 * XMMBYTES, _masm);\n-  loadPerm(xmm1357, perms, nttL7PermsIdx + 3 * XMMBYTES, _masm);\n-  sub_add(xmm21232527, xmm20222426, xmm16_19, xmm12_15, _masm);\n+    \/\/ Constants for final unshuffle\n+    __ vmovdqu(unshuffle1, ExternalAddress(unshufflePermsAddr(2)), vector_len, scratch);\n+    __ vmovdqu(unshuffle2, ExternalAddress(unshufflePermsAddr(3)), vector_len, scratch);\n+    shuffle(Scratch1, Coeffs1_2, Coeffs2_2, 0);\n+    shuffle(Scratch1, Coeffs3_2, Coeffs4_2, 0);\n+\n+    storeXmms(coeffs, 0*memStep, Coeffs1, vector_len, _masm);\n+    storeXmms(coeffs, 1*memStep, Coeffs2, vector_len, _masm);\n+    storeXmms(coeffs, 2*memStep, Coeffs3, vector_len, _masm);\n+    storeXmms(coeffs, 3*memStep, Coeffs4, vector_len, _masm);\n+  } else { \/\/ Assembler::AVX_256bit\n+    \/\/ levels 0-4, register shuffles:\n+    const XMMRegister Coeffs1_1[] = {xmm0, xmm2};\n+    const XMMRegister Coeffs2_1[] = {xmm1, xmm3};\n+    const XMMRegister Coeffs3_1[] = {xmm4, xmm6};\n+    const XMMRegister Coeffs4_1[] = {xmm5, xmm7};\n+\n+    const XMMRegister Coeffs1_2[] = {xmm0, xmm1, xmm2, xmm3};\n+    const XMMRegister Coeffs2_2[] = {xmm4, xmm5, xmm6, xmm7};\n+\n+    \/\/ Since we cannot fit the entire payload into registers, we process the\n+    \/\/ input in two stages. For the first half, load 8 registers, each 32 integers\n+    \/\/ apart. With one load, we can process level 0-2 (128-, 64- and 32-integers\n+    \/\/ apart). For the remaining levels, load 8 registers from consecutive memory\n+    \/\/ (16-, 8-, 4-, 2-, 1-integer apart)\n+    \/\/ Levels 5, 6, 7 (4-, 2-, 1-integer apart) require shuffles within registers.\n+    \/\/ On the other levels, shuffles can be done by rearranging the register order\n+\n+    \/\/ Four batches of 8 registers each, 128 bytes apart\n+    for (int i=0; i<4; i++) {\n+      loadXmms(Coeffs1_2, coeffs, i*32 + 0*128, vector_len, _masm, 4, 128);\n+      loadXmms(Coeffs2_2, coeffs, i*32 + 4*128, vector_len, _masm, 4, 128);\n+\n+      \/\/ level 0-2 can be done by shuffling registers (also notice fewer zetas loads, they repeat)\n+      \/\/ level 0 - 128\n+      __ vmovdqu(Zetas1[0], Address(zetas, 0), vector_len);\n+      montMul64(Scratch1, Coeffs3, Zetas1, Coeffs3, Scratch2);\n+      sub_add(Coeffs3, Coeffs1, Coeffs1, Scratch1, vector_len, _masm);\n+      montMul64(Scratch1, Coeffs4, Zetas1, Coeffs4, Scratch2);\n+      sub_add(Coeffs4, Coeffs2, Coeffs2, Scratch1, vector_len, _masm);\n+\n+      \/\/ level 1 - 64\n+      __ vmovdqu(Zetas1[0], Address(zetas,        512), vector_len);\n+      montMul64(Scratch1, Coeffs2, Zetas1, Coeffs2, Scratch2);\n+      sub_add(Coeffs2, Coeffs1, Coeffs1, Scratch1, vector_len, _masm);\n+\n+      __ vmovdqu(Zetas1[0], Address(zetas, 4*64 + 512), vector_len);\n+      montMul64(Scratch1, Coeffs4, Zetas1, Coeffs4, Scratch2);\n+      sub_add(Coeffs4, Coeffs3, Coeffs3, Scratch1, vector_len, _masm);\n+\n+      \/\/ level 2 - 32\n+      loadXmms(Zetas3, zetas, 2 * 512, vector_len, _masm, 2, 128);\n+      montMul64(Scratch1, Coeffs2_1, Zetas3, Coeffs2_1, Scratch2);\n+      sub_add(Coeffs2_1, Coeffs1_1, Coeffs1_1, Scratch1, vector_len, _masm);\n+\n+      loadXmms(Zetas3, zetas, 4*64 + 2 * 512, vector_len, _masm, 2, 128);\n+      montMul64(Scratch1, Coeffs4_1, Zetas3, Coeffs4_1, Scratch2);\n+      sub_add(Coeffs4_1, Coeffs3_1, Coeffs3_1, Scratch1, vector_len, _masm);\n+\n+      storeXmms(coeffs, i*32 + 0*128, Coeffs1_2, vector_len, _masm, 4, 128);\n+      storeXmms(coeffs, i*32 + 4*128, Coeffs2_2, vector_len, _masm, 4, 128);\n+    }\n@@ -427,3 +597,46 @@\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i), xmm(i + 20), xmm(i + 21), Assembler::AVX_512bit);\n-    __ evpermi2d(xmm(i + 1), xmm(i + 20), xmm(i + 21), Assembler::AVX_512bit);\n+    \/\/ Four batches of 8 registers, consecutive loads\n+    for (int i=0; i<4; i++) {\n+      loadXmms(Coeffs1_2, coeffs,       i*256, vector_len, _masm, 4);\n+      loadXmms(Coeffs2_2, coeffs, 128 + i*256, vector_len, _masm, 4);\n+\n+      \/\/ level 3 - 16\n+      __ vmovdqu(Zetas1[0], Address(zetas, i*128 + 3 * 512), vector_len);\n+      montMul64(Scratch1, Coeffs2, Zetas1, Coeffs2, Scratch2);\n+      sub_add(Coeffs2, Coeffs1, Coeffs1, Scratch1, vector_len, _masm);\n+\n+      __ vmovdqu(Zetas1[0], Address(zetas, i*128 + 64 + 3 * 512), vector_len);\n+      montMul64(Scratch1, Coeffs4, Zetas1, Coeffs4, Scratch2);\n+      sub_add(Coeffs4, Coeffs3, Coeffs3, Scratch1, vector_len, _masm);\n+\n+      \/\/ level 4 - 8\n+      loadXmms(Zetas3, zetas, i*128 + 4 * 512, vector_len, _masm);\n+      montMul64(Scratch1, Coeffs2_1, Zetas3, Coeffs2_1, Scratch2);\n+      sub_add(Coeffs2_1, Coeffs1_1, Coeffs1_1, Scratch1, vector_len, _masm);\n+\n+      loadXmms(Zetas3, zetas, i*128 + 64 + 4 * 512, vector_len, _masm);\n+      montMul64(Scratch1, Coeffs4_1, Zetas3, Coeffs4_1, Scratch2);\n+      sub_add(Coeffs4_1, Coeffs3_1, Coeffs3_1, Scratch1, vector_len, _masm);\n+\n+      for (int level = 5, distance = 4; level<8; level++, distance \/= 2) {\n+        \/\/ zetas = load(level * 512)\n+        \/\/ coeffs1_2, scratch1 = shuffle(coeffs1_2, coeffs2_2)\n+        \/\/ scratch1 = scratch1 * zetas\n+        \/\/ coeffs2_2 = coeffs1_2 - scratch1\n+        \/\/ coeffs1_2 = coeffs1_2 + scratch1\n+        loadXmms(Zetas3, zetas, i*128 + level * 512, vector_len, _masm);\n+        shuffle(Scratch1, Coeffs1_1, Coeffs2_1, distance * 32); \/\/Coeffs2_2 freed\n+        montMul64(Scratch1, Scratch1, Zetas3, Coeffs2_1, Scratch2, level==7);\n+        sub_add(Coeffs2_1, Coeffs1_1, Coeffs1_1, Scratch1, vector_len, _masm);\n+\n+        loadXmms(Zetas3, zetas, i*128 + 64 + level * 512, vector_len, _masm);\n+        shuffle(Scratch1, Coeffs3_1, Coeffs4_1, distance * 32); \/\/Coeffs4_2 freed\n+        montMul64(Scratch1, Scratch1, Zetas3, Coeffs4_1, Scratch2, level==7);\n+        sub_add(Coeffs4_1, Coeffs3_1, Coeffs3_1, Scratch1, vector_len, _masm);\n+      }\n+\n+      shuffle(Scratch1, Coeffs1_1, Coeffs2_1, 0);\n+      shuffle(Scratch1, Coeffs3_1, Coeffs4_1, 0);\n+\n+      storeXmms(coeffs,       i*256, Coeffs1_2, vector_len, _masm, 4);\n+      storeXmms(coeffs, 128 + i*256, Coeffs2_2, vector_len, _masm, 4);\n+    }\n@@ -432,18 +645,0 @@\n-  __ cmpl(iterations, 0);\n-  __ jcc(Assembler::equal, L_end);\n-\n-  store4Xmms(coeffs, 0, xmm0_3, _masm);\n-  store4Xmms(coeffs, 4 * XMMBYTES, xmm4_7, _masm);\n-\n-  load4Xmms(xmm0_3, coeffs, 8 * XMMBYTES, _masm);\n-  load4Xmms(xmm4_7, coeffs, 12 * XMMBYTES, _masm);\n-\n-  __ addptr(zetas, 4 * XMMBYTES);\n-\n-  __ jmp(L_loop);\n-\n-  __ BIND(L_end);\n-\n-  store4Xmms(coeffs, 8 * XMMBYTES, xmm0_3, _masm);\n-  store4Xmms(coeffs, 12 * XMMBYTES, xmm4_7, _masm);\n-\n@@ -462,4 +657,3 @@\n-\/\/ zetas (int[256]) = c_rarg1\n-static address generate_dilithiumAlmostInverseNtt_avx512(StubGenerator *stubgen,\n-                                                         MacroAssembler *_masm) {\n-\n+\/\/ zetas (int[128*8]) = c_rarg1\n+static address generate_dilithiumAlmostInverseNtt_avx(StubGenerator *stubgen,\n+                                        int vector_len, MacroAssembler *_masm) {\n@@ -472,2 +666,0 @@\n-  Label L_loop, L_end;\n-\n@@ -476,0 +668,21 @@\n+  const Register scratch = r10;\n+\n+  \/\/ AVX2 version uses the first half of these arrays\n+  const XMMRegister Coeffs1[] = {xmm0, xmm1, xmm16, xmm17};\n+  const XMMRegister Coeffs2[] = {xmm2, xmm3, xmm18, xmm19};\n+  const XMMRegister Coeffs3[] = {xmm4, xmm5, xmm20, xmm21};\n+  const XMMRegister Coeffs4[] = {xmm6, xmm7, xmm22, xmm23};\n+  const XMMRegister Scratch1[] = {xmm8, xmm9, xmm24, xmm25};\n+  const XMMRegister Scratch2[] = {xmm10, xmm11, xmm26, xmm27};\n+  const XMMRegister Zetas1[] = {xmm12, xmm12, xmm12, xmm12};\n+  const XMMRegister Zetas2[] = {xmm12, xmm12, xmm13, xmm13};\n+  const XMMRegister Zetas3[] = {xmm12, xmm13, xmm28, xmm29};\n+  const XMMRegister montQInvModR = xmm14;\n+  const XMMRegister dilithium_q = xmm15;\n+  const XMMRegister unshuffle1 = xmm30;\n+  const XMMRegister unshuffle2 = xmm31;\n+  KRegister mergeMask1 = k1;\n+  KRegister mergeMask2 = k2;\n+  \/\/ lambdas to hide repeated parameters\n+  auto shuffle = whole_shuffle(scratch, mergeMask1, mergeMask2, unshuffle1, unshuffle2, vector_len, _masm);\n+  auto montMul64 = whole_montMul(montQInvModR, dilithium_q, mergeMask2, vector_len, _masm);\n@@ -477,7 +690,0 @@\n-  const Register iterations = c_rarg2;\n-\n-  const Register perms = r11;\n-\n-  __ lea(perms, ExternalAddress(dilithiumAvx512PermsAddr()));\n-\n-  __ evmovdqul(montMulPerm, Address(perms, montMulPermsIdx), Assembler::AVX_512bit);\n@@ -486,1 +692,1 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q^-1 mod 2^32\n+                  vector_len, scratch); \/\/ q^-1 mod 2^32\n@@ -489,1 +695,1 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q\n+                  vector_len, scratch); \/\/ q\n@@ -495,3 +701,2 @@\n-  \/\/ the substartion is (Montgomery) multiplied by the corresponding zetas.\n-  \/\/ In each level we just collect the coefficients (using evpermi2d()\n-  \/\/ instructions where necessary, i.e. on levels 0-4) so that the results of\n+  \/\/ the subtraction is (Montgomery) multiplied by the corresponding zetas.\n+  \/\/ In each level we just shuffle the coefficients so that the results of\n@@ -501,95 +706,46 @@\n-  \/\/ We do levels 0-6 in two batches, each batch entirely in the vector registers\n-  load4Xmms(xmm0_3, coeffs, 0, _masm);\n-  load4Xmms(xmm4_7, coeffs, 4 * XMMBYTES, _masm);\n-\n-  __ movl(iterations, 2);\n-\n-  __ align(OptoLoopAlignment);\n-  __ BIND(L_loop);\n-\n-  __ subl(iterations, 1);\n-\n-  \/\/ level 0\n-  loadPerm(xmm8_11, perms, nttInvL0PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttInvL0PermsIdx + 64, _masm);\n-\n-  for (int i = 0; i < 8; i += 2) {\n-    __ evpermi2d(xmm(i \/ 2 + 8), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-    __ evpermi2d(xmm(i \/ 2 + 12), xmm(i), xmm(i + 1), Assembler::AVX_512bit);\n-  }\n-\n-  load4Xmms(xmm4_7, zetas, 0, _masm);\n-  sub_add(xmm24_27, xmm0_3, xmm8_11, xmm12_15, _masm);\n-  montMul64(xmm4_7, xmm4_7, xmm24_27, xmm16_27, true, _masm);\n-\n-  \/\/ level 1\n-  loadPerm(xmm8_11, perms, nttInvL1PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttInvL1PermsIdx + 64, _masm);\n-\n-  for (int i = 0; i < 4; i++) {\n-    __ evpermi2d(xmm(i + 8), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-    __ evpermi2d(xmm(i + 12), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-  }\n-\n-  load4Xmms(xmm4_7, zetas, 512, _masm);\n-  sub_add(xmm24_27, xmm0_3, xmm8_11, xmm12_15, _masm);\n-  montMul64(xmm4_7, xmm24_27, xmm4_7, xmm16_27, _masm);\n-\n-  \/\/ level 2\n-  loadPerm(xmm8_11, perms, nttInvL2PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttInvL2PermsIdx + 64, _masm);\n-\n-  for (int i = 0; i < 4; i++) {\n-    __ evpermi2d(xmm(i + 8), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-    __ evpermi2d(xmm(i + 12), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-  }\n-\n-  load4Xmms(xmm4_7, zetas, 2 * 512, _masm);\n-  sub_add(xmm24_27, xmm0_3, xmm8_11, xmm12_15, _masm);\n-  montMul64(xmm4_7, xmm24_27, xmm4_7, xmm16_27, _masm);\n-\n-  \/\/ level 3\n-  loadPerm(xmm8_11, perms, nttInvL3PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttInvL3PermsIdx + 64, _masm);\n-\n-  for (int i = 0; i < 4; i++) {\n-    __ evpermi2d(xmm(i + 8), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-    __ evpermi2d(xmm(i + 12), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-  }\n-\n-  load4Xmms(xmm4_7, zetas, 3 * 512, _masm);\n-  sub_add(xmm24_27, xmm0_3, xmm8_11, xmm12_15, _masm);\n-  montMul64(xmm4_7, xmm24_27, xmm4_7, xmm16_27, _masm);\n-\n-  \/\/ level 4\n-  loadPerm(xmm8_11, perms, nttInvL4PermsIdx, _masm);\n-  loadPerm(xmm12_15, perms, nttInvL4PermsIdx + 64, _masm);\n-\n-  for (int i = 0; i < 4; i++) {\n-    __ evpermi2d(xmm(i + 8), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-    __ evpermi2d(xmm(i + 12), xmm(i), xmm(i + 4), Assembler::AVX_512bit);\n-  }\n-\n-  load4Xmms(xmm4_7, zetas, 4 * 512, _masm);\n-  sub_add(xmm24_27, xmm0_3, xmm8_11, xmm12_15, _masm);\n-  montMul64(xmm4_7, xmm24_27, xmm4_7, xmm16_27, _masm);\n-\n-  \/\/ level 5\n-  load4Xmms(xmm12_15, zetas, 5 * 512, _masm);\n-  sub_add(xmm8_11, xmm0_3, xmm0426, xmm1537, _masm);\n-  montMul64(xmm4_7, xmm8_11, xmm12_15, xmm16_27, _masm);\n-\n-  \/\/ level 6\n-  load4Xmms(xmm12_15, zetas, 6 * 512, _masm);\n-  sub_add(xmm8_11, xmm0_3, xmm0145, xmm2367, _masm);\n-  montMul64(xmm4_7, xmm8_11, xmm12_15, xmm16_27, _masm);\n-\n-  __ cmpl(iterations, 0);\n-  __ jcc(Assembler::equal, L_end);\n-\n-  \/\/ save the coefficients of the first batch, adjust the zetas\n-  \/\/ and load the second batch of coefficients\n-  store4Xmms(coeffs, 0, xmm0_3, _masm);\n-  store4Xmms(coeffs, 4 * XMMBYTES, xmm4_7, _masm);\n-\n-  __ addptr(zetas, 4 * XMMBYTES);\n+  if (vector_len == Assembler::AVX_512bit) {\n+    \/\/ levels 4-7, register shuffles:\n+    const XMMRegister Coeffs1_1[] = {xmm0, xmm1, xmm2, xmm3};\n+    const XMMRegister Coeffs2_1[] = {xmm16, xmm17, xmm18, xmm19};\n+    const XMMRegister Coeffs3_1[] = {xmm4, xmm5, xmm6, xmm7};\n+    const XMMRegister Coeffs4_1[] = {xmm20, xmm21, xmm22, xmm23};\n+    const XMMRegister Coeffs1_2[] = {xmm0, xmm16, xmm2, xmm18};\n+    const XMMRegister Coeffs2_2[] = {xmm1, xmm17, xmm3, xmm19};\n+    const XMMRegister Coeffs3_2[] = {xmm4, xmm20, xmm6, xmm22};\n+    const XMMRegister Coeffs4_2[] = {xmm5, xmm21, xmm7, xmm23};\n+\n+    \/\/ Constants for shuffle and montMul64\n+    __ mov64(scratch, 0b1010101010101010);\n+    __ kmovwl(mergeMask1, scratch);\n+    __ knotwl(mergeMask2, mergeMask1);\n+    __ vmovdqu(unshuffle1, ExternalAddress(unshufflePermsAddr(4)), vector_len, scratch);\n+    __ vmovdqu(unshuffle2, ExternalAddress(unshufflePermsAddr(5)), vector_len, scratch);\n+\n+    int memStep = 4 * 64;\n+    loadXmms(Coeffs1, coeffs, 0*memStep, vector_len, _masm);\n+    loadXmms(Coeffs2, coeffs, 1*memStep, vector_len, _masm);\n+    loadXmms(Coeffs3, coeffs, 2*memStep, vector_len, _masm);\n+    loadXmms(Coeffs4, coeffs, 3*memStep, vector_len, _masm);\n+\n+    shuffle(Scratch1, Coeffs1_2, Coeffs2_2, 1);\n+    shuffle(Scratch1, Coeffs3_2, Coeffs4_2, 1);\n+\n+    \/\/ Constants for shuffle(128)\n+    __ vmovdqu(unshuffle1, ExternalAddress(unshufflePermsAddr(0)), vector_len, scratch);\n+    __ vmovdqu(unshuffle2, ExternalAddress(unshufflePermsAddr(1)), vector_len, scratch);\n+    for (int level = 0, distance = 1; level<4; level++, distance *= 2) {\n+      \/\/ zetas = load(level * 512)\n+      \/\/ coeffs1_2 = coeffs1_2 + coeffs2_2\n+      \/\/ scratch1 = coeffs1_2 - coeffs2_2\n+      \/\/ scratch1 = scratch1 * zetas\n+      \/\/ coeffs1_2, coeffs2_2 = shuffle(coeffs1_2, scratch1)\n+      loadXmms(Zetas3, zetas, level * 512, vector_len, _masm);\n+      sub_add(Scratch1, Coeffs1_2, Coeffs1_2, Coeffs2_2, vector_len, _masm); \/\/ Coeffs2_2 freed\n+      montMul64(Scratch1, Scratch1, Zetas3, Coeffs2_2, Scratch2, level==0);\n+      shuffle(Coeffs2_2, Coeffs1_2, Scratch1, distance * 32);\n+\n+      loadXmms(Zetas3, zetas, 4*64 + level * 512, vector_len, _masm);\n+      sub_add(Scratch1, Coeffs3_2, Coeffs3_2, Coeffs4_2, vector_len, _masm); \/\/ Coeffs4_2 freed\n+      montMul64(Scratch1, Scratch1, Zetas3, Coeffs4_2, Scratch2, level==0);\n+      shuffle(Coeffs4_2, Coeffs3_2, Scratch1, distance * 32);\n+    }\n@@ -597,2 +753,4 @@\n-  load4Xmms(xmm0_3, coeffs, 8 * XMMBYTES, _masm);\n-  load4Xmms(xmm4_7, coeffs, 12 * XMMBYTES, _masm);\n+    \/\/ level 4\n+    loadXmms(Zetas3, zetas, 4 * 512, vector_len, _masm);\n+    sub_add(Scratch1, Coeffs1_2, Coeffs1_2, Coeffs2_2, vector_len, _masm); \/\/ Coeffs2_2 freed\n+    montMul64(Coeffs2_2, Scratch1, Zetas3, Scratch1, Scratch2);\n@@ -600,1 +758,3 @@\n-  __ jmp(L_loop);\n+    loadXmms(Zetas3, zetas, 4*64 + 4 * 512, vector_len, _masm);\n+    sub_add(Scratch1, Coeffs3_2, Coeffs3_2, Coeffs4_2, vector_len, _masm); \/\/ Coeffs4_2 freed\n+    montMul64(Coeffs4_2, Scratch1, Zetas3, Scratch1, Scratch2);\n@@ -602,1 +762,5 @@\n-  __ BIND(L_end);\n+    \/\/ level 5\n+    __ vmovdqu(Zetas2[0], Address(zetas,        5 * 512), vector_len);\n+    __ vmovdqu(Zetas2[2], Address(zetas, 2*64 + 5 * 512), vector_len);\n+    sub_add(Scratch1, Coeffs1_1, Coeffs1_1, Coeffs2_1, vector_len, _masm); \/\/ Coeffs2_1 freed\n+    montMul64(Coeffs2_1, Scratch1, Zetas2, Scratch1, Scratch2);\n@@ -604,5 +768,4 @@\n-  \/\/ load the coeffs of the first batch of coefficients that were saved after\n-  \/\/ level 6 into Zmm_8-Zmm_15 and do the last level entirely in the vector\n-  \/\/ registers\n-  load4Xmms(xmm8_11, coeffs, 0, _masm);\n-  load4Xmms(xmm12_15, coeffs, 4 * XMMBYTES, _masm);\n+    __ vmovdqu(Zetas2[0], Address(zetas, 4*64 + 5 * 512), vector_len);\n+    __ vmovdqu(Zetas2[2], Address(zetas, 6*64 + 5 * 512), vector_len);\n+    sub_add(Scratch1, Coeffs3_1, Coeffs3_1, Coeffs4_1, vector_len, _masm); \/\/ Coeffs4_1 freed\n+    montMul64(Coeffs4_1, Scratch1, Zetas2, Scratch1, Scratch2);\n@@ -610,1 +773,4 @@\n-  \/\/ level 7\n+    \/\/ level 6\n+    __ vmovdqu(Zetas1[0], Address(zetas,        6 * 512), vector_len);\n+    sub_add(Scratch1, Coeffs1, Coeffs1, Coeffs2, vector_len, _masm); \/\/ Coeffs2 freed\n+    montMul64(Coeffs2, Scratch1, Zetas1, Scratch1, Scratch2);\n@@ -612,1 +778,3 @@\n-  loadXmm29(zetas, 7 * 512, _masm);\n+    __ vmovdqu(Zetas1[0], Address(zetas, 4*64 + 6 * 512), vector_len);\n+    sub_add(Scratch1, Coeffs3, Coeffs3, Coeffs4, vector_len, _masm); \/\/ Coeffs4 freed\n+    montMul64(Coeffs4, Scratch1, Zetas1, Scratch1, Scratch2);\n@@ -614,3 +782,67 @@\n-  for (int i = 0; i < 8; i++) {\n-    __ evpaddd(xmm(i + 16), k0, xmm(i), xmm(i + 8), false, Assembler::AVX_512bit);\n-  }\n+    \/\/ level 7\n+    __ vmovdqu(Zetas1[0], Address(zetas, 7 * 512), vector_len);\n+    sub_add(Scratch1, Coeffs1, Coeffs1, Coeffs3, vector_len, _masm); \/\/ Coeffs3 freed\n+    montMul64(Coeffs3, Scratch1, Zetas1, Scratch1, Scratch2);\n+    sub_add(Scratch1, Coeffs2, Coeffs2, Coeffs4, vector_len, _masm); \/\/ Coeffs4 freed\n+    montMul64(Coeffs4, Scratch1, Zetas1, Scratch1, Scratch2);\n+\n+    storeXmms(coeffs, 0*memStep, Coeffs1, vector_len, _masm);\n+    storeXmms(coeffs, 1*memStep, Coeffs2, vector_len, _masm);\n+    storeXmms(coeffs, 2*memStep, Coeffs3, vector_len, _masm);\n+    storeXmms(coeffs, 3*memStep, Coeffs4, vector_len, _masm);\n+  } else { \/\/ Assembler::AVX_256bit\n+    \/\/ Permutations of Coeffs1, Coeffs2, Coeffs3 and Coeffs4\n+    const XMMRegister Coeffs1_1[] = {xmm0, xmm2};\n+    const XMMRegister Coeffs2_1[] = {xmm1, xmm3};\n+    const XMMRegister Coeffs3_1[] = {xmm4, xmm6};\n+    const XMMRegister Coeffs4_1[] = {xmm5, xmm7};\n+\n+    const XMMRegister Coeffs1_2[] = {xmm0, xmm1, xmm2, xmm3};\n+    const XMMRegister Coeffs2_2[] = {xmm4, xmm5, xmm6, xmm7};\n+\n+    \/\/ Four batches of 8 registers, consecutive loads\n+    for (int i=0; i<4; i++) {\n+      loadXmms(Coeffs1_2, coeffs,       i*256, vector_len, _masm, 4);\n+      loadXmms(Coeffs2_2, coeffs, 128 + i*256, vector_len, _masm, 4);\n+\n+      shuffle(Scratch1, Coeffs1_1, Coeffs2_1, 1);\n+      shuffle(Scratch1, Coeffs3_1, Coeffs4_1, 1);\n+\n+      for (int level = 0, distance = 1; level <= 2; level++, distance *= 2) {\n+        \/\/ zetas = load(level * 512)\n+        \/\/ coeffs1_2 = coeffs1_2 + coeffs2_2\n+        \/\/ scratch1 = coeffs1_2 - coeffs2_2\n+        \/\/ scratch1 = scratch1 * zetas\n+        \/\/ coeffs1_2, coeffs2_2 = shuffle(coeffs1_2, scratch1)\n+        loadXmms(Zetas3, zetas, i*128 + level * 512, vector_len, _masm);\n+        sub_add(Scratch1, Coeffs1_1, Coeffs1_1, Coeffs2_1, vector_len, _masm); \/\/ Coeffs2_1 freed\n+        montMul64(Scratch1, Scratch1, Zetas3, Coeffs2_1, Scratch2, level==0);\n+        shuffle(Coeffs2_1, Coeffs1_1, Scratch1, distance * 32);\n+\n+        loadXmms(Zetas3, zetas, i*128 + 64 + level * 512, vector_len, _masm);\n+        sub_add(Scratch1, Coeffs3_1, Coeffs3_1, Coeffs4_1, vector_len, _masm); \/\/ Coeffs4_1 freed\n+        montMul64(Scratch1, Scratch1, Zetas3, Coeffs4_1, Scratch2, level==0);\n+        shuffle(Coeffs4_1, Coeffs3_1, Scratch1, distance * 32);\n+      }\n+\n+      \/\/ level 3\n+      loadXmms(Zetas3, zetas, i*128 + 3 * 512, vector_len, _masm);\n+      sub_add(Scratch1, Coeffs1_1, Coeffs1_1, Coeffs2_1, vector_len, _masm); \/\/ Coeffs2_1 freed\n+      montMul64(Coeffs2_1, Scratch1, Zetas3, Scratch1, Scratch2);\n+\n+      loadXmms(Zetas3, zetas, i*128 + 64 + 3 * 512, vector_len, _masm);\n+      sub_add(Scratch1, Coeffs3_1, Coeffs3_1, Coeffs4_1, vector_len, _masm); \/\/ Coeffs4_1 freed\n+      montMul64(Coeffs4_1, Scratch1, Zetas3, Scratch1, Scratch2);\n+\n+      \/\/ level 4\n+      __ vmovdqu(Zetas1[0], Address(zetas, i*128 + 4 * 512), vector_len);\n+      sub_add(Scratch1, Coeffs1, Coeffs1, Coeffs2, vector_len, _masm); \/\/ Coeffs2 freed\n+      montMul64(Coeffs2, Scratch1, Zetas1, Scratch1, Scratch2);\n+\n+      __ vmovdqu(Zetas1[0], Address(zetas, i*128 + 64 + 4 * 512), vector_len);\n+      sub_add(Scratch1, Coeffs3, Coeffs3, Coeffs4, vector_len, _masm); \/\/ Coeffs4 freed\n+      montMul64(Coeffs4, Scratch1, Zetas1, Scratch1, Scratch2);\n+\n+      storeXmms(coeffs,       i*256, Coeffs1_2, vector_len, _masm, 4);\n+      storeXmms(coeffs, 128 + i*256, Coeffs2_2, vector_len, _masm, 4);\n+    }\n@@ -618,2 +850,33 @@\n-  for (int i = 0; i < 8; i++) {\n-    __ evpsubd(xmm(i), k0, xmm(i + 8), xmm(i), false, Assembler::AVX_512bit);\n+    \/\/ Four batches of 8 registers each, 128 bytes apart\n+    for (int i=0; i<4; i++) {\n+      loadXmms(Coeffs1_2, coeffs, i*32 + 0*128, vector_len, _masm, 4, 128);\n+      loadXmms(Coeffs2_2, coeffs, i*32 + 4*128, vector_len, _masm, 4, 128);\n+\n+      \/\/ level 5\n+      loadXmms(Zetas3, zetas, 5 * 512, vector_len, _masm, 2, 128);\n+      sub_add(Scratch1, Coeffs1_1, Coeffs1_1, Coeffs2_1, vector_len, _masm); \/\/ Coeffs2_1 freed\n+      montMul64(Coeffs2_1, Scratch1, Zetas3, Scratch1, Scratch2);\n+\n+      loadXmms(Zetas3, zetas, 4*64 + 5 * 512, vector_len, _masm, 2, 128);\n+      sub_add(Scratch1, Coeffs3_1, Coeffs3_1, Coeffs4_1, vector_len, _masm); \/\/ Coeffs4_1 freed\n+      montMul64(Coeffs4_1, Scratch1, Zetas3, Scratch1, Scratch2);\n+\n+      \/\/ level 6\n+      __ vmovdqu(Zetas1[0], Address(zetas,        6 * 512), vector_len);\n+      sub_add(Scratch1, Coeffs1, Coeffs1, Coeffs2, vector_len, _masm); \/\/ Coeffs2 freed\n+      montMul64(Coeffs2, Scratch1, Zetas1, Scratch1, Scratch2);\n+\n+      __ vmovdqu(Zetas1[0], Address(zetas, 4*64 + 6 * 512), vector_len);\n+      sub_add(Scratch1, Coeffs3, Coeffs3, Coeffs4, vector_len, _masm); \/\/ Coeffs4 freed\n+      montMul64(Coeffs4, Scratch1, Zetas1, Scratch1, Scratch2);\n+\n+      \/\/ level 7\n+      __ vmovdqu(Zetas1[0], Address(zetas, 7 * 512), vector_len);\n+      sub_add(Scratch1, Coeffs1, Coeffs1, Coeffs3, vector_len, _masm); \/\/ Coeffs3 freed\n+      montMul64(Coeffs3, Scratch1, Zetas1, Scratch1, Scratch2);\n+      sub_add(Scratch1, Coeffs2, Coeffs2, Coeffs4, vector_len, _masm); \/\/ Coeffs4 freed\n+      montMul64(Coeffs4, Scratch1, Zetas1, Scratch1, Scratch2);\n+\n+      storeXmms(coeffs, i*32 + 0*128, Coeffs1_2, vector_len, _masm, 4, 128);\n+      storeXmms(coeffs, i*32 + 4*128, Coeffs2_2, vector_len, _masm, 4, 128);\n+    }\n@@ -622,7 +885,0 @@\n-  store4Xmms(coeffs, 0, xmm16_19, _masm);\n-  store4Xmms(coeffs, 4 * XMMBYTES, xmm20_23, _masm);\n-  montMul64(xmm0_3, xmm0_3, xmm29_29, xmm16_27, _masm);\n-  montMul64(xmm4_7, xmm4_7, xmm29_29, xmm16_27, _masm);\n-  store4Xmms(coeffs, 8 * XMMBYTES, xmm0_3, _masm);\n-  store4Xmms(coeffs, 12 * XMMBYTES, xmm4_7, _masm);\n-\n@@ -644,2 +900,2 @@\n-static address generate_dilithiumNttMult_avx512(StubGenerator *stubgen,\n-                                                MacroAssembler *_masm) {\n+static address generate_dilithiumNttMult_avx(StubGenerator *stubgen,\n+                                     int vector_len, MacroAssembler *_masm) {\n@@ -658,2 +914,1 @@\n-\n-  const Register perms = r10; \/\/ scratch reused after not needed any more\n+  const Register scratch = r10;\n@@ -662,1 +917,11 @@\n-  const XMMRegister montRSquareModQ = xmm29;\n+  const XMMRegister montQInvModR = xmm8;\n+  const XMMRegister dilithium_q = xmm9;\n+\n+  const XMMRegister Poly1[] = {xmm0, xmm1, xmm16, xmm17};\n+  const XMMRegister Poly2[] = {xmm2, xmm3, xmm18, xmm19};\n+  const XMMRegister Scratch1[] = {xmm4, xmm5, xmm20, xmm21};\n+  const XMMRegister Scratch2[] = {xmm6, xmm7, xmm22, xmm23};\n+  const XMMRegister MontRSquareModQ[] = {xmm10, xmm10, xmm10, xmm10};\n+  KRegister mergeMask = k1;\n+  \/\/ lambda to hide repeated parameters\n+  auto montMul64 = whole_montMul(montQInvModR, dilithium_q, mergeMask, vector_len, _masm);\n@@ -666,1 +931,1 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q^-1 mod 2^32\n+                  vector_len, scratch); \/\/ q^-1 mod 2^32\n@@ -669,2 +934,2 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q\n-  __ vpbroadcastd(montRSquareModQ,\n+                  vector_len, scratch); \/\/ q\n+  __ vpbroadcastd(MontRSquareModQ[0],\n@@ -672,1 +937,5 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ 2^64 mod q\n+                  vector_len, scratch); \/\/ 2^64 mod q\n+  if (vector_len == Assembler::AVX_512bit) {\n+    __ mov64(scratch, 0b0101010101010101);\n+    __ kmovwl(mergeMask, scratch);\n+  }\n@@ -674,2 +943,9 @@\n-  __ lea(perms, ExternalAddress(dilithiumAvx512PermsAddr()));\n-  __ evmovdqul(montMulPerm, Address(perms, montMulPermsIdx), Assembler::AVX_512bit);\n+  \/\/ Total payload is 256*int32s.\n+  \/\/ - memStep is number of bytes one iteration processes.\n+  \/\/ - loopCnt is number of iterations it will take to process entire payload.\n+  int loopCnt = 4;\n+  int memStep = 4 * 64;\n+  if (vector_len == Assembler::AVX_256bit) {\n+    loopCnt = 16;\n+    memStep = 2 * 32;\n+  }\n@@ -677,1 +953,1 @@\n-  __ movl(len, 4);\n+  __ movl(len, loopCnt);\n@@ -682,5 +958,5 @@\n-  load4Xmms(xmm4_7, poly2, 0, _masm);\n-  load4Xmms(xmm0_3, poly1, 0, _masm);\n-  montMul64(xmm4_7, xmm4_7, xmm29_29, xmm16_27, _masm);\n-  montMul64(xmm0_3, xmm0_3, xmm4_7, xmm16_27, true, _masm);\n-  store4Xmms(result, 0, xmm0_3, _masm);\n+  loadXmms(Poly2, poly2, 0, vector_len, _masm);\n+  loadXmms(Poly1, poly1, 0, vector_len, _masm);\n+  montMul64(Poly2, Poly2, MontRSquareModQ, Scratch1, Scratch2);\n+  montMul64(Poly1, Poly1, Poly2,           Scratch1, Scratch2, true);\n+  storeXmms(result, 0, Poly1, vector_len, _masm);\n@@ -689,3 +965,3 @@\n-  __ addptr(poly1, 4 * XMMBYTES);\n-  __ addptr(poly2, 4 * XMMBYTES);\n-  __ addptr(result, 4 * XMMBYTES);\n+  __ addptr(poly1, memStep);\n+  __ addptr(poly2, memStep);\n+  __ addptr(result, memStep);\n@@ -708,2 +984,2 @@\n-static address generate_dilithiumMontMulByConstant_avx512(StubGenerator *stubgen,\n-                                                          MacroAssembler *_masm) {\n+static address generate_dilithiumMontMulByConstant_avx(StubGenerator *stubgen,\n+                                        int vector_len, MacroAssembler *_masm) {\n@@ -721,2 +997,1 @@\n-\n-  const Register perms = c_rarg2; \/\/ not used for argument\n+  const Register scratch = r10;\n@@ -725,1 +1000,2 @@\n-  const XMMRegister constant = xmm29;\n+  const XMMRegister montQInvModR = xmm8;\n+  const XMMRegister dilithium_q = xmm9;\n@@ -727,1 +1003,9 @@\n-  __ lea(perms, ExternalAddress(dilithiumAvx512PermsAddr()));\n+  const XMMRegister Coeffs1[] = {xmm0, xmm1, xmm16, xmm17};\n+  const XMMRegister Coeffs2[] = {xmm2, xmm3, xmm18, xmm19};\n+  const XMMRegister Scratch1[] = {xmm4, xmm5, xmm20, xmm21};\n+  const XMMRegister Scratch2[] = {xmm6, xmm7, xmm22, xmm23};\n+  const XMMRegister Constant[] = {xmm10, xmm10, xmm10, xmm10};\n+  XMMRegister constant = Constant[0];\n+  KRegister mergeMask = k1;\n+  \/\/ lambda to hide repeated parameters\n+  auto montMul64 = whole_montMul(montQInvModR, dilithium_q, mergeMask, vector_len, _masm);\n@@ -729,1 +1013,1 @@\n-  \/\/ the following four vector registers are used in montMul64\n+  \/\/ load constants for montMul64\n@@ -732,1 +1016,1 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q^-1 mod 2^32\n+                  vector_len, scratch); \/\/ q^-1 mod 2^32\n@@ -735,3 +1019,21 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q\n-  __ evmovdqul(montMulPerm, Address(perms, montMulPermsIdx), Assembler::AVX_512bit);\n-  __ evpbroadcastd(constant, rConstant, Assembler::AVX_512bit); \/\/ constant multiplier\n+                  vector_len, scratch); \/\/ q\n+  if (vector_len == Assembler::AVX_256bit) {\n+    __ movdl(constant, rConstant);\n+    __ vpbroadcastd(constant, constant, vector_len); \/\/ constant multiplier\n+  } else {\n+    __ evpbroadcastd(constant, rConstant, Assembler::AVX_512bit); \/\/ constant multiplier\n+\n+    __ mov64(scratch, 0b0101010101010101); \/\/dw-mask\n+    __ kmovwl(mergeMask, scratch);\n+  }\n+\n+  \/\/ Total payload is 256*int32s.\n+  \/\/ - memStep is number of bytes one montMul64 processes.\n+  \/\/ - loopCnt is number of iterations it will take to process entire payload.\n+  \/\/ - (two memSteps per loop)\n+  int memStep = 4 * 64;\n+  int loopCnt = 2;\n+  if (vector_len == Assembler::AVX_256bit) {\n+    memStep = 2 * 32;\n+    loopCnt = 8;\n+  }\n@@ -739,1 +1041,1 @@\n-  __ movl(len, 2);\n+  __ movl(len, loopCnt);\n@@ -744,6 +1046,6 @@\n-  load4Xmms(xmm0_3, coeffs, 0, _masm);\n-  load4Xmms(xmm4_7, coeffs, 4 * XMMBYTES, _masm);\n-  montMul64(xmm0_3, xmm0_3, xmm29_29, xmm16_27, _masm);\n-  montMul64(xmm4_7, xmm4_7, xmm29_29, xmm16_27, _masm);\n-  store4Xmms(coeffs, 0, xmm0_3, _masm);\n-  store4Xmms(coeffs, 4 * XMMBYTES, xmm4_7, _masm);\n+  loadXmms(Coeffs1, coeffs, 0,       vector_len, _masm);\n+  loadXmms(Coeffs2, coeffs, memStep, vector_len, _masm);\n+  montMul64(Coeffs1, Coeffs1, Constant, Scratch1, Scratch2);\n+  montMul64(Coeffs2, Coeffs2, Constant, Scratch1, Scratch2);\n+  storeXmms(coeffs, 0,       Coeffs1, vector_len, _masm);\n+  storeXmms(coeffs, memStep, Coeffs2, vector_len, _masm);\n@@ -752,1 +1054,1 @@\n-  __ addptr(coeffs, 512);\n+  __ addptr(coeffs, 2 * memStep);\n@@ -772,3 +1074,2 @@\n-static address generate_dilithiumDecomposePoly_avx512(StubGenerator *stubgen,\n-                                                      MacroAssembler *_masm) {\n-\n+static address generate_dilithiumDecomposePoly_avx(StubGenerator *stubgen,\n+                                      int vector_len, MacroAssembler *_masm) {\n@@ -788,0 +1089,1 @@\n+  const Register scratch = r10;\n@@ -789,11 +1091,17 @@\n-  const XMMRegister zero = xmm24;\n-  const XMMRegister one = xmm25;\n-  const XMMRegister qMinus1 = xmm26;\n-  const XMMRegister gamma2 = xmm27;\n-  const XMMRegister twoGamma2 = xmm28;\n-  const XMMRegister barrettMultiplier = xmm29;\n-  const XMMRegister barrettAddend = xmm30;\n-\n-  __ vpxor(zero, zero, zero, Assembler::AVX_512bit); \/\/ 0\n-  __ vpternlogd(xmm0, 0xff, xmm0, xmm0, Assembler::AVX_512bit); \/\/ -1\n-  __ vpsubd(one, zero, xmm0, Assembler::AVX_512bit); \/\/ 1\n+\n+  const XMMRegister one = xmm0;\n+  const XMMRegister gamma2 = xmm1;\n+  const XMMRegister twoGamma2 = xmm2;\n+  const XMMRegister barrettMultiplier = xmm3;\n+  const XMMRegister barrettAddend = xmm4;\n+  const XMMRegister dilithium_q = xmm5;\n+  const XMMRegister zero = xmm29;     \/\/ AVX512-only\n+  const XMMRegister minusOne = xmm30; \/\/ AVX512-only\n+  const XMMRegister qMinus1 = xmm31;  \/\/ AVX512-only\n+\n+  XMMRegister RPlus[] = {xmm6, xmm7, xmm16, xmm17};\n+  XMMRegister Quotient[] = {xmm8, xmm9, xmm18, xmm19};\n+  XMMRegister R0[] = {xmm10, xmm11, xmm20, xmm21};\n+  XMMRegister Mask[] = {xmm12, xmm13, xmm22, xmm23};\n+  XMMRegister Tmp1[] = {xmm14, xmm15, xmm24, xmm25};\n+\n@@ -802,1 +1110,1 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ q\n+                  vector_len, scratch); \/\/ q\n@@ -805,1 +1113,13 @@\n-                  Assembler::AVX_512bit, scratch); \/\/ addend for Barrett reduction\n+                  vector_len, scratch); \/\/ addend for Barrett reduction\n+  if (vector_len == Assembler::AVX_512bit) {\n+    __ vpxor(zero, zero, zero, vector_len); \/\/ 0\n+    __ vpternlogd(minusOne, 0xff, minusOne, minusOne, vector_len); \/\/ -1\n+    __ vpsrld(one, minusOne, 31, vector_len);\n+    __ vpsubd(qMinus1, dilithium_q, one, vector_len); \/\/ q - 1\n+    __ evpbroadcastd(twoGamma2, rTwoGamma2, vector_len); \/\/ 2 * gamma2\n+  } else {\n+    __ vpcmpeqd(one, one, one, vector_len);\n+    __ vpsrld(one, one, 31, vector_len);\n+    __ movdl(twoGamma2, rTwoGamma2);\n+    __ vpbroadcastd(twoGamma2, twoGamma2, vector_len); \/\/ 2 * gamma2\n+  }\n@@ -807,1 +1127,1 @@\n-  __ evpbroadcastd(twoGamma2, rTwoGamma2, Assembler::AVX_512bit); \/\/ 2 * gamma2\n+  __ vpsrad(gamma2, twoGamma2, 1, vector_len); \/\/ gamma2\n@@ -816,2 +1136,7 @@\n-  __ evpbroadcastd(barrettMultiplier, rMultiplier,\n-                   Assembler::AVX_512bit); \/\/ multiplier for mod 2 * gamma2 reduce\n+  if (vector_len == Assembler::AVX_512bit) {\n+    __ evpbroadcastd(barrettMultiplier, rMultiplier,\n+                  vector_len); \/\/ multiplier for mod 2 * gamma2 reduce\n+  } else {\n+    __ movdl(barrettMultiplier, rMultiplier);\n+    __ vpbroadcastd(barrettMultiplier, barrettMultiplier, vector_len);\n+  }\n@@ -819,2 +1144,7 @@\n-  __ evpsubd(qMinus1, k0, dilithium_q, one, false, Assembler::AVX_512bit); \/\/ q - 1\n-  __ evpsrad(gamma2, k0, twoGamma2, 1, false, Assembler::AVX_512bit); \/\/ gamma2\n+  \/\/ Total payload is 1024 bytes\n+  int memStep = 4 * 64; \/\/ Number of bytes per loop iteration\n+  int regCnt = 4; \/\/ Register array length\n+  if (vector_len == Assembler::AVX_256bit) {\n+    memStep = 2 * 32;\n+    regCnt = 2;\n+  }\n@@ -827,1 +1157,1 @@\n-  load4Xmms(xmm0_3, input, 0, _masm);\n+  loadXmms(RPlus, input, 0, vector_len, _masm);\n@@ -829,1 +1159,1 @@\n-  __ addptr(input, 4 * XMMBYTES);\n+  __ addptr(input, memStep);\n@@ -831,1 +1161,0 @@\n-  \/\/ rplus in xmm0\n@@ -833,20 +1162,16 @@\n-  __ evpaddd(xmm4, k0, xmm0, barrettAddend, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm5, k0, xmm1, barrettAddend, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm6, k0, xmm2, barrettAddend, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm7, k0, xmm3, barrettAddend, false, Assembler::AVX_512bit);\n-\n-  __ evpsrad(xmm4, k0, xmm4, 23, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm5, k0, xmm5, 23, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm6, k0, xmm6, 23, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm7, k0, xmm7, 23, false, Assembler::AVX_512bit);\n-\n-  __ evpmulld(xmm4, k0, xmm4, dilithium_q, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm5, k0, xmm5, dilithium_q, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm6, k0, xmm6, dilithium_q, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm7, k0, xmm7, dilithium_q, false, Assembler::AVX_512bit);\n-\n-  __ evpsubd(xmm0, k0, xmm0, xmm4, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm1, k0, xmm1, xmm5, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm2, k0, xmm2, xmm6, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm3, k0, xmm3, xmm7, false, Assembler::AVX_512bit);\n-  \/\/ rplus in xmm0\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpaddd(Tmp1[i], RPlus[i], barrettAddend, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsrad(Tmp1[i], Tmp1[i], 23, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpmulld(Tmp1[i], Tmp1[i], dilithium_q, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(RPlus[i], RPlus[i], Tmp1[i], vector_len);\n+  }\n+\n@@ -854,15 +1179,12 @@\n-  __ evpsrad(xmm4, k0, xmm0, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm5, k0, xmm1, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm6, k0, xmm2, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm7, k0, xmm3, 31, false, Assembler::AVX_512bit);\n-\n-  __ evpandd(xmm4, k0, xmm4, dilithium_q, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm5, k0, xmm5, dilithium_q, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm6, k0, xmm6, dilithium_q, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm7, k0, xmm7, dilithium_q, false, Assembler::AVX_512bit);\n-\n-  __ evpaddd(xmm0, k0, xmm0, xmm4, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm1, k0, xmm1, xmm5, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm2, k0, xmm2, xmm6, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm3, k0, xmm3, xmm7, false, Assembler::AVX_512bit);\n-  \/\/ rplus in xmm0\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsrad(Tmp1[i], RPlus[i], 31, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpand(Tmp1[i], Tmp1[i], dilithium_q, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpaddd(RPlus[i], RPlus[i], Tmp1[i], vector_len);\n+  }\n+\n@@ -870,10 +1192,8 @@\n-  __ evpmulld(xmm4, k0, xmm0, barrettMultiplier, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm5, k0, xmm1, barrettMultiplier, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm6, k0, xmm2, barrettMultiplier, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm7, k0, xmm3, barrettMultiplier, false, Assembler::AVX_512bit);\n-\n-  __ evpsrad(xmm4, k0, xmm4, 22, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm5, k0, xmm5, 22, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm6, k0, xmm6, 22, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm7, k0, xmm7, 22, false, Assembler::AVX_512bit);\n-  \/\/ quotient in xmm4\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpmulld(Quotient[i], RPlus[i], barrettMultiplier, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsrad(Quotient[i], Quotient[i], 22, vector_len);\n+  }\n+\n@@ -881,10 +1201,8 @@\n-  __ evpmulld(xmm8, k0, xmm4, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm9, k0, xmm5, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm10, k0, xmm6, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpmulld(xmm11, k0, xmm7, twoGamma2, false, Assembler::AVX_512bit);\n-\n-  __ evpsubd(xmm8, k0, xmm0, xmm8, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm9, k0, xmm1, xmm9, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm10, k0, xmm2, xmm10, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm11, k0, xmm3, xmm11, false, Assembler::AVX_512bit);\n-  \/\/ r0 in xmm8\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpmulld(R0[i], Quotient[i], twoGamma2, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(R0[i], RPlus[i], R0[i], vector_len);\n+  }\n+\n@@ -892,10 +1210,8 @@\n-  __ evpsubd(xmm12, k0, twoGamma2, xmm8, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm13, k0, twoGamma2, xmm9, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm14, k0, twoGamma2, xmm10, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm15, k0, twoGamma2, xmm11, false, Assembler::AVX_512bit);\n-\n-  __ evpsrad(xmm12, k0, xmm12, 22, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm13, k0, xmm13, 22, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm14, k0, xmm14, 22, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm15, k0, xmm15, 22, false, Assembler::AVX_512bit);\n-  \/\/ mask in xmm12\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(Mask[i], twoGamma2, R0[i], vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsrad(Mask[i], Mask[i], 22, vector_len);\n+  }\n+\n@@ -903,10 +1219,8 @@\n-  __ evpandd(xmm16, k0, xmm12, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm17, k0, xmm13, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm18, k0, xmm14, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm19, k0, xmm15, twoGamma2, false, Assembler::AVX_512bit);\n-\n-  __ evpsubd(xmm8, k0, xmm8, xmm16, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm9, k0, xmm9, xmm17, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm10, k0, xmm10, xmm18, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm11, k0, xmm11, xmm19, false, Assembler::AVX_512bit);\n-  \/\/ r0 in xmm8\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpand(Tmp1[i], Mask[i], twoGamma2, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(R0[i], R0[i], Tmp1[i], vector_len);\n+  }\n+\n@@ -914,4 +1228,3 @@\n-  __ evpandd(xmm16, k0, xmm12, one, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm17, k0, xmm13, one, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm18, k0, xmm14, one, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm19, k0, xmm15, one, false, Assembler::AVX_512bit);\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpand(Tmp1[i], Mask[i], one, vector_len);\n+  }\n@@ -919,4 +1232,3 @@\n-  __ evpaddd(xmm4, k0, xmm4, xmm16, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm5, k0, xmm5, xmm17, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm6, k0, xmm6, xmm18, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm7, k0, xmm7, xmm19, false, Assembler::AVX_512bit);\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpaddd(Quotient[i], Quotient[i], Tmp1[i], vector_len);\n+  }\n@@ -925,4 +1237,3 @@\n-  __ evpsubd(xmm12, k0, gamma2, xmm8, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm13, k0, gamma2, xmm9, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm14, k0, gamma2, xmm10, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm15, k0, gamma2, xmm11, false, Assembler::AVX_512bit);\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(Mask[i], gamma2, R0[i], vector_len);\n+  }\n@@ -930,4 +1241,3 @@\n-  __ evpsrad(xmm12, k0, xmm12, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm13, k0, xmm13, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm14, k0, xmm14, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm15, k0, xmm15, 31, false, Assembler::AVX_512bit);\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsrad(Mask[i], Mask[i], 31, vector_len);\n+  }\n@@ -936,10 +1246,8 @@\n-  __ evpandd(xmm16, k0, xmm12, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm17, k0, xmm13, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm18, k0, xmm14, twoGamma2, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm19, k0, xmm15, twoGamma2, false, Assembler::AVX_512bit);\n-\n-  __ evpsubd(xmm8, k0, xmm8, xmm16, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm9, k0, xmm9, xmm17, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm10, k0, xmm10, xmm18, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm11, k0, xmm11, xmm19, false, Assembler::AVX_512bit);\n-  \/\/ r0 in xmm8\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpand(Tmp1[i], Mask[i], twoGamma2, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(R0[i], R0[i], Tmp1[i], vector_len);\n+  }\n+\n@@ -947,10 +1255,8 @@\n-  __ evpandd(xmm16, k0, xmm12, one, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm17, k0, xmm13, one, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm18, k0, xmm14, one, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm19, k0, xmm15, one, false, Assembler::AVX_512bit);\n-\n-  __ evpaddd(xmm4, k0, xmm4, xmm16, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm5, k0, xmm5, xmm17, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm6, k0, xmm6, xmm18, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm7, k0, xmm7, xmm19, false, Assembler::AVX_512bit);\n-  \/\/ quotient in xmm4\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpand(Tmp1[i], Mask[i], one, vector_len);\n+  }\n+\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpaddd(Quotient[i], Quotient[i], Tmp1[i], vector_len);\n+  }\n+  \/\/ r1 in RPlus\n@@ -958,10 +1264,0 @@\n-  __ evpsubd(xmm16, k0, xmm0, xmm8, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm17, k0, xmm1, xmm9, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm18, k0, xmm2, xmm10, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm19, k0, xmm3, xmm11, false, Assembler::AVX_512bit);\n-\n-  __ evpsubd(xmm16, k0, xmm16, xmm26, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm17, k0, xmm17, xmm26, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm18, k0, xmm18, xmm26, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm19, k0, xmm19, xmm26, false, Assembler::AVX_512bit);\n-  \/\/ r1 in xmm16\n@@ -969,34 +1265,42 @@\n-  __ evpsubd(xmm20, k0, zero, xmm16, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm21, k0, zero, xmm17, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm22, k0, zero, xmm18, false, Assembler::AVX_512bit);\n-  __ evpsubd(xmm23, k0, zero, xmm19, false, Assembler::AVX_512bit);\n-\n-  __ evporq(xmm16, k0, xmm16, xmm20, false, Assembler::AVX_512bit);\n-  __ evporq(xmm17, k0, xmm17, xmm21, false, Assembler::AVX_512bit);\n-  __ evporq(xmm18, k0, xmm18, xmm22, false, Assembler::AVX_512bit);\n-  __ evporq(xmm19, k0, xmm19, xmm23, false, Assembler::AVX_512bit);\n-\n-  __ evpsubd(xmm12, k0, zero, one, false, Assembler::AVX_512bit); \/\/ -1\n-\n-  __ evpsrad(xmm0, k0, xmm16, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm1, k0, xmm17, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm2, k0, xmm18, 31, false, Assembler::AVX_512bit);\n-  __ evpsrad(xmm3, k0, xmm19, 31, false, Assembler::AVX_512bit);\n-  \/\/ r1 in xmm0\n-  \/\/ r0 += ~r1;\n-  __ evpxorq(xmm20, k0, xmm0, xmm12, false, Assembler::AVX_512bit);\n-  __ evpxorq(xmm21, k0, xmm1, xmm12, false, Assembler::AVX_512bit);\n-  __ evpxorq(xmm22, k0, xmm2, xmm12, false, Assembler::AVX_512bit);\n-  __ evpxorq(xmm23, k0, xmm3, xmm12, false, Assembler::AVX_512bit);\n-\n-  __ evpaddd(xmm8, k0, xmm8, xmm20, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm9, k0, xmm9, xmm21, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm10, k0, xmm10, xmm22, false, Assembler::AVX_512bit);\n-  __ evpaddd(xmm11, k0, xmm11, xmm23, false, Assembler::AVX_512bit);\n-  \/\/ r0 in xmm8\n-  \/\/ r1 = r1 & quotient;\n-  __ evpandd(xmm0, k0, xmm4, xmm0, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm1, k0, xmm5, xmm1, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm2, k0, xmm6, xmm2, false, Assembler::AVX_512bit);\n-  __ evpandd(xmm3, k0, xmm7, xmm3, false, Assembler::AVX_512bit);\n-  \/\/ r1 in xmm0\n+  for (int i = 0; i < regCnt; i++) {\n+    __ vpsubd(RPlus[i], RPlus[i], R0[i], vector_len);\n+  }\n+\n+  if (vector_len == Assembler::AVX_512bit) {\n+    KRegister EqMsk[] = {k1, k2, k3, k4};\n+    for (int i = 0; i < regCnt; i++) {\n+      __ evpcmpeqd(EqMsk[i], k0, RPlus[i], qMinus1, vector_len);\n+    }\n+\n+    \/\/ r0 += ~r1; \/\/ add -1 or keep as is, using EqMsk as filter\n+    for (int i = 0; i < regCnt; i++) {\n+      __ evpaddd(R0[i], EqMsk[i], R0[i], minusOne, true, vector_len);\n+    }\n+\n+    \/\/ r1 in Quotient\n+    \/\/ r1 = r1 & quotient; \/\/ copy 0 or keep as is, using EqMsk as filter\n+    for (int i = 0; i < regCnt; i++) {\n+      __ evpandd(Quotient[i], EqMsk[i], Quotient[i], zero, true, vector_len);\n+    }\n+  } else {\n+    const XMMRegister qMinus1 = Tmp1[0];\n+    __ vpsubd(qMinus1, dilithium_q, one, vector_len); \/\/ q - 1\n+\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpcmpeqd(Mask[i], RPlus[i], qMinus1, vector_len);\n+    }\n+\n+    \/\/ r0 += ~r1;\n+    \/\/ Mask already negated\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpaddd(R0[i], R0[i], Mask[i], vector_len);\n+    }\n+\n+    \/\/ r1 in Quotient\n+    \/\/ r1 = r1 & quotient;\n+    for (int i = 0; i < regCnt; i++) {\n+      __ vpandn(Quotient[i], Mask[i], Quotient[i], vector_len);\n+    }\n+  }\n+\n+  \/\/ r1 in Quotient\n@@ -1005,2 +1309,2 @@\n-  store4Xmms(highPart, 0, xmm0_3, _masm);\n-  store4Xmms(lowPart, 0, xmm8_11, _masm);\n+  storeXmms(highPart, 0, Quotient, vector_len, _masm);\n+  storeXmms(lowPart, 0, R0, vector_len, _masm);\n@@ -1008,3 +1312,3 @@\n-  __ addptr(highPart, 4 * XMMBYTES);\n-  __ addptr(lowPart, 4 * XMMBYTES);\n-  __ subl(len, 4 * XMMBYTES);\n+  __ addptr(highPart, memStep);\n+  __ addptr(lowPart, memStep);\n+  __ subl(len, memStep);\n@@ -1021,0 +1325,4 @@\n+  int vector_len = Assembler::AVX_256bit;\n+  if (VM_Version::supports_evex() && VM_Version::supports_avx512bw()) {\n+    vector_len = Assembler::AVX_512bit;\n+  }\n@@ -1023,10 +1331,10 @@\n-      StubRoutines::_dilithiumAlmostNtt =\n-        generate_dilithiumAlmostNtt_avx512(this, _masm);\n-      StubRoutines::_dilithiumAlmostInverseNtt =\n-        generate_dilithiumAlmostInverseNtt_avx512(this, _masm);\n-      StubRoutines::_dilithiumNttMult =\n-        generate_dilithiumNttMult_avx512(this, _masm);\n-      StubRoutines::_dilithiumMontMulByConstant =\n-        generate_dilithiumMontMulByConstant_avx512(this, _masm);\n-      StubRoutines::_dilithiumDecomposePoly =\n-        generate_dilithiumDecomposePoly_avx512(this, _masm);\n+    StubRoutines::_dilithiumAlmostNtt =\n+        generate_dilithiumAlmostNtt_avx(this, vector_len, _masm);\n+    StubRoutines::_dilithiumAlmostInverseNtt =\n+        generate_dilithiumAlmostInverseNtt_avx(this, vector_len, _masm);\n+    StubRoutines::_dilithiumNttMult =\n+        generate_dilithiumNttMult_avx(this, vector_len, _masm);\n+    StubRoutines::_dilithiumMontMulByConstant =\n+        generate_dilithiumMontMulByConstant_avx(this, vector_len, _masm);\n+    StubRoutines::_dilithiumDecomposePoly =\n+        generate_dilithiumDecomposePoly_avx(this, vector_len, _masm);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_dilithium.cpp","additions":1009,"deletions":701,"binary":false,"changes":1710,"status":"modified"},{"patch":"@@ -1274,2 +1274,1 @@\n-  \/\/ Currently we only have them for AVX512\n-  if (supports_evex() && supports_avx512bw()) {\n+  if (UseAVX > 1) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2781,1 +2781,0 @@\n-  static int emit_exception_handler(C2_MacroAssembler *masm);\n@@ -2784,9 +2783,0 @@\n-  static uint size_exception_handler() {\n-    \/\/ NativeCall instruction size is the same as NativeJump.\n-    \/\/ exception handler starts out as jump and can be patched to\n-    \/\/ a call be deoptimization.  (4932387)\n-    \/\/ Note that this value is also credited (in output.cpp) to\n-    \/\/ the size of the code section.\n-    return NativeJump::instruction_size;\n-  }\n-\n@@ -2794,2 +2784,2 @@\n-    \/\/ three 5 byte instructions plus one move for unreachable address.\n-    return 15+3;\n+    \/\/ one call and one jmp.\n+    return 7;\n@@ -2887,18 +2877,0 @@\n-\/\/ Emit exception handler code.\n-\/\/ Stuff framesize into a register and call a VM stub routine.\n-int HandlerImpl::emit_exception_handler(C2_MacroAssembler* masm) {\n-\n-  \/\/ Note that the code buffer's insts_mark is always relative to insts.\n-  \/\/ That's why we must use the macroassembler to generate a handler.\n-  address base = __ start_a_stub(size_exception_handler());\n-  if (base == nullptr) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return 0;  \/\/ CodeBuffer::expand failed\n-  }\n-  int offset = __ offset();\n-  __ jump(RuntimeAddress(OptoRuntime::exception_blob()->entry_point()));\n-  assert(__ offset() - offset <= (int) size_exception_handler(), \"overflow\");\n-  __ end_a_stub();\n-  return offset;\n-}\n-\n@@ -2917,4 +2889,4 @@\n-  address the_pc = (address) __ pc();\n-  Label next;\n-  \/\/ push a \"the_pc\" on the stack without destroying any registers\n-  \/\/ as they all may be live.\n+  Label start;\n+  __ bind(start);\n+\n+  __ call(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2922,5 +2894,3 @@\n-  \/\/ push address of \"next\"\n-  __ call(next, relocInfo::none); \/\/ reloc none is fine since it is a disp32\n-  __ bind(next);\n-  \/\/ adjust it so it matches \"the_pc\"\n-  __ subptr(Address(rsp, 0), __ offset() - offset);\n+  int entry_offset = __ offset();\n+\n+  __ jmp(start);\n@@ -2928,1 +2898,0 @@\n-  __ jump(RuntimeAddress(SharedRuntime::deopt_blob()->unpack()));\n@@ -2930,0 +2899,2 @@\n+  assert(__ offset() - entry_offset >= NativePostCallNop::first_check_size,\n+         \"out of bounds read in post-call NOP check\");\n@@ -2931,1 +2902,1 @@\n-  return offset;\n+  return entry_offset;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":41,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1750,0 +1750,3 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) {\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1584,0 +1584,3 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) {\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-    bool is_containerized();\n+    bool is_containerized() override;\n@@ -214,1 +214,1 @@\n-    const char * container_type() {\n+    const char * container_type() override {\n@@ -217,3 +217,3 @@\n-    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n-    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n-    CgroupCpuacctController* cpuacct_controller() { return _cpuacct; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() override { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() override { return _cpu; }\n+    CgroupCpuacctController* cpuacct_controller() override { return _cpuacct; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1773,1 +1773,3 @@\n-#if    (defined AMD64)\n+#if  (defined IA32)\n+  static  Elf32_Half running_arch_code=EM_386;\n+#elif   (defined AMD64) || (defined X32)\n@@ -1807,1 +1809,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, LOONGARCH64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -1869,0 +1871,1 @@\n+#ifndef IA32\n@@ -1891,0 +1894,4 @@\n+  \/\/ This workaround is ineffective on IA32 systems because the MXCSR\n+  \/\/ register (which controls flush-to-zero mode) is not stored in the\n+  \/\/ legacy fenv.\n+\n@@ -1894,0 +1901,1 @@\n+#endif \/\/ IA32\n@@ -1913,0 +1921,1 @@\n+#ifndef IA32\n@@ -1938,0 +1947,1 @@\n+#endif \/\/ IA32\n@@ -2436,0 +2446,1 @@\n+  assert(ret == 0, \"sysinfo failed: %s\", os::strerror(errno));\n@@ -2600,1 +2611,2 @@\n-  sysinfo(&si);\n+  int ret = sysinfo(&si);\n+  assert(ret == 0, \"sysinfo failed: %s\", os::strerror(errno));\n@@ -2608,4 +2620,6 @@\n-  st->print(\", swap \" UINT64_FORMAT \"k\",\n-            ((jlong)si.totalswap * si.mem_unit) >> 10);\n-  st->print(\"(\" UINT64_FORMAT \"k free)\",\n-            ((jlong)si.freeswap * si.mem_unit) >> 10);\n+  if (ret == 0) {\n+    st->print(\", swap \" UINT64_FORMAT \"k\",\n+              ((jlong)si.totalswap * si.mem_unit) >> 10);\n+    st->print(\"(\" UINT64_FORMAT \"k free)\",\n+              ((jlong)si.freeswap * si.mem_unit) >> 10);\n+  }\n@@ -2994,0 +3008,4 @@\n+void os::numa_set_thread_affinity(Thread* thread, int node) {\n+  Linux::numa_set_thread_affinity(thread->osthread()->thread_id(), node);\n+}\n+\n@@ -3176,0 +3194,2 @@\n+      set_numa_bitmask_clearbit(CAST_TO_FN_PTR(numa_bitmask_clearbit_func_t,\n+                                               libnuma_dlsym(handle, \"numa_bitmask_clearbit\")));\n@@ -3190,0 +3210,4 @@\n+      set_numa_sched_setaffinity(CAST_TO_FN_PTR(numa_sched_setaffinity_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_sched_setaffinity\")));\n+      set_numa_allocate_cpumask(CAST_TO_FN_PTR(numa_allocate_cpumask_func_t,\n+                                               libnuma_v2_dlsym(handle, \"numa_allocate_cpumask\")));\n@@ -3195,0 +3219,1 @@\n+        set_numa_all_cpus_ptr((struct bitmask **)libnuma_dlsym(handle, \"numa_all_cpus_ptr\"));\n@@ -3198,0 +3223,1 @@\n+\n@@ -3201,0 +3227,1 @@\n+\n@@ -3204,0 +3231,5 @@\n+\n+        \/\/ Create a node -> CPUs mapping\n+        _numa_affinity_masks = new (mtInternal) GrowableArray<struct bitmask*>(0, mtInternal);\n+        build_numa_affinity_masks();\n+\n@@ -3239,0 +3271,36 @@\n+void os::Linux::build_numa_affinity_masks() {\n+  \/\/ We only build the affinity masks if running libnuma v2 (_numa_node_to_cpus_v2\n+  \/\/ is available) and we have the affinity mask of the process when it started.\n+  if (_numa_node_to_cpus_v2 == nullptr || _numa_all_cpus_ptr == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ It's important that we respect any user configuration by removing the\n+  \/\/ CPUs we're not allowed to run on from the affinity mask. For example,\n+  \/\/ if the user runs the JVM with \"numactl -C 0-1,4-5\" on a machine with\n+  \/\/ the following NUMA setup:\n+  \/\/ NUMA 0: CPUs 0-3, NUMA 1: CPUs 4-7\n+  \/\/ We expect to get the following affinity masks:\n+  \/\/ Affinity masks: idx 0 = (0, 1), idx 1 = (4, 5)\n+\n+  const int num_nodes = get_existing_num_nodes();\n+  const unsigned num_cpus = (unsigned)os::processor_count();\n+\n+  for (int i = 0; i < num_nodes; i++) {\n+    struct bitmask* affinity_mask = _numa_allocate_cpumask();\n+\n+    \/\/ Fill the affinity mask with all CPUs belonging to NUMA node i\n+    _numa_node_to_cpus_v2(i, affinity_mask);\n+\n+    \/\/ Clear the bits of all CPUs that the process is not allowed to\n+    \/\/ execute tasks on\n+    for (unsigned j = 0; j < num_cpus; j++) {\n+      if (!_numa_bitmask_isbitset(_numa_all_cpus_ptr, j)) {\n+        _numa_bitmask_clearbit(affinity_mask, j);\n+      }\n+    }\n+\n+    _numa_affinity_masks->push(affinity_mask);\n+  }\n+}\n+\n@@ -3354,0 +3422,19 @@\n+void os::Linux::numa_set_thread_affinity(pid_t tid, int node) {\n+  \/\/ We only set affinity if running libnuma v2 (_numa_sched_setaffinity\n+  \/\/ is available) and we have all affinity mask\n+  if (_numa_sched_setaffinity == nullptr ||\n+      _numa_all_cpus_ptr == nullptr ||\n+      _numa_affinity_masks->is_empty()) {\n+    return;\n+  }\n+\n+  if (node == -1) {\n+    \/\/ If the node is -1, the affinity is reverted to the original affinity\n+    \/\/ of the thread when the VM was started\n+    _numa_sched_setaffinity(tid, _numa_all_cpus_ptr);\n+  } else {\n+    \/\/ Normal case, set the affinity to the corresponding affinity mask\n+    _numa_sched_setaffinity(tid, _numa_affinity_masks->at(node));\n+  }\n+}\n+\n@@ -3363,0 +3450,1 @@\n+GrowableArray<struct bitmask*>* os::Linux::_numa_affinity_masks;\n@@ -3374,0 +3462,1 @@\n+os::Linux::numa_bitmask_clearbit_func_t os::Linux::_numa_bitmask_clearbit;\n@@ -3379,0 +3468,2 @@\n+os::Linux::numa_sched_setaffinity_func_t os::Linux::_numa_sched_setaffinity;\n+os::Linux::numa_allocate_cpumask_func_t os::Linux::_numa_allocate_cpumask;\n@@ -3385,0 +3476,1 @@\n+struct bitmask* os::Linux::_numa_all_cpus_ptr;\n@@ -5074,1 +5166,1 @@\n-                             \"\\\"%s\\\" (or dumping to %s\/core.%d)\",\n+                             \"\\\"%s\\\" (alternatively, falling back to %s\/core.%d)\",\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":100,"deletions":8,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+  static GrowableArray<struct bitmask*>* _numa_affinity_masks;\n+\n+  static void build_numa_affinity_masks();\n+\n@@ -233,0 +237,1 @@\n+  typedef int (*numa_bitmask_clearbit_func_t)(struct bitmask *bmp, unsigned int n);\n@@ -235,0 +240,2 @@\n+  typedef int (*numa_sched_setaffinity_func_t)(pid_t pid, struct bitmask* mask);\n+  typedef struct bitmask* (*numa_allocate_cpumask_func_t)(void);\n@@ -247,0 +254,1 @@\n+  static numa_bitmask_clearbit_func_t _numa_bitmask_clearbit;\n@@ -254,0 +262,2 @@\n+  static numa_sched_setaffinity_func_t _numa_sched_setaffinity;\n+  static numa_allocate_cpumask_func_t _numa_allocate_cpumask;\n@@ -257,0 +267,1 @@\n+  static struct bitmask* _numa_all_cpus_ptr;\n@@ -272,0 +283,1 @@\n+  static void set_numa_bitmask_clearbit(numa_bitmask_clearbit_func_t func) { _numa_bitmask_clearbit = func; }\n@@ -282,0 +294,1 @@\n+  static void set_numa_all_cpus_ptr(struct bitmask **ptr) { _numa_all_cpus_ptr = (ptr == nullptr ? nullptr : *ptr); }\n@@ -285,0 +298,2 @@\n+  static void set_numa_sched_setaffinity(numa_sched_setaffinity_func_t func) { _numa_sched_setaffinity = func; }\n+  static void set_numa_allocate_cpumask(numa_allocate_cpumask_func_t func) { _numa_allocate_cpumask = func; }\n@@ -295,0 +310,2 @@\n+  static void numa_set_thread_affinity(pid_t tid, int node);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+  stringStream buf(buffer, bufferSize);\n@@ -112,2 +113,2 @@\n-    jio_snprintf(buffer, bufferSize, \"CreateCoredumpOnCrash is disabled from command line\");\n-    VMError::record_coredump_status(buffer, false);\n+    buf.print(\"CreateCoredumpOnCrash is disabled from command line\");\n+    VMError::record_coredump_status(buf.freeze(), false);\n@@ -120,1 +121,5 @@\n-      jio_snprintf(buffer, bufferSize, \"core.%d (may not exist)\", current_process_id());\n+      \/\/ In the warning message, let the user know.\n+      if (check_only) {\n+        buf.print(\"the core path couldn't be determined. It commonly defaults to \");\n+      }\n+      buf.print(\"core.%d%s\", current_process_id(), check_only ? \"\" : \" (may not exist)\");\n@@ -123,1 +128,6 @@\n-      jio_snprintf(buffer, bufferSize, \"Core dumps may be processed with %s\", core_path);\n+      if (check_only) {\n+        buf.print(\"core dumps may be further processed by the following: \");\n+      } else {\n+        buf.print(\"Determined by the following: \");\n+      }\n+      buf.print(\"%s\", core_path);\n@@ -126,1 +136,4 @@\n-      jio_snprintf(buffer, bufferSize, \"%s (may not exist)\", core_path);\n+      if (check_only) {\n+        buf.print(\"the rlimit couldn't be determined. If resource limits permit, the core dump will be located at \");\n+      }\n+      buf.print(\"%s%s\", core_path, check_only ? \"\" : \" (may not exist)\");\n@@ -130,1 +143,1 @@\n-          jio_snprintf(buffer, bufferSize, \"%s\", core_path);\n+          buf.print(\"%s\", core_path);\n@@ -134,1 +147,1 @@\n-          jio_snprintf(buffer, bufferSize, \"Core dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\");\n+          buf.print(\"%s dumps have been disabled. To enable core dumping, try \\\"ulimit -c unlimited\\\" before starting Java again\", check_only ? \"core\" : \"Core\");\n@@ -138,1 +151,6 @@\n-          jio_snprintf(buffer, bufferSize, \"%s (max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", core_path, uint64_t(rlim.rlim_cur) \/ K);\n+          if (check_only) {\n+            buf.print(\"core dumps are constrained \");\n+          } else {\n+             buf.print( \"%s \", core_path);\n+          }\n+          buf.print( \"(max size \" UINT64_FORMAT \" k). To ensure a full core dump, try \\\"ulimit -c unlimited\\\" before starting Java again\", uint64_t(rlim.rlim_cur) \/ K);\n@@ -142,0 +160,1 @@\n+    const char* result = buf.freeze();\n@@ -143,1 +162,1 @@\n-      VMError::record_coredump_status(buffer, success);\n+      VMError::record_coredump_status(result, success);\n@@ -145,1 +164,1 @@\n-      warning(\"CreateCoredumpOnCrash specified, but %s\", buffer);\n+      warning(\"CreateCoredumpOnCrash specified, but %s\", result);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-        address deopt = nm->deopt_handler_begin();\n+        address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2798,1 +2798,1 @@\n-          address deopt = nm->deopt_handler_begin();\n+          address deopt = nm->deopt_handler_entry();\n@@ -3755,0 +3755,1 @@\n+void os::numa_set_thread_affinity(Thread *thread, int node) { }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -249,3 +249,3 @@\n-    assert(memval_hi == memval_lo + 1 && memval_lo < R9, \"cmpxchg_long: illegal registers\");\n-    assert(oldval_hi == oldval_lo + 1 && oldval_lo < R9, \"cmpxchg_long: illegal registers\");\n-    assert(newval_hi == newval_lo + 1 && newval_lo < R9, \"cmpxchg_long: illegal registers\");\n+    assert(memval_hi == as_Register(memval_lo->encoding() + 1) && memval_lo->encoding() < R9->encoding(), \"cmpxchg_long: illegal registers\");\n+    assert(oldval_hi == as_Register(oldval_lo->encoding() + 1) && oldval_lo->encoding() < R9->encoding(), \"cmpxchg_long: illegal registers\");\n+    assert(newval_hi == as_Register(newval_lo->encoding() + 1) && newval_lo->encoding() < R9->encoding(), \"cmpxchg_long: illegal registers\");\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/macroAssembler_linux_arm_32.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,1 +107,5 @@\n-  log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\"\", pretty());\n+  log_info(os, cpu)(\"Enabled RV64 feature \\\"%s\\\"\", pretty());\n+}\n+\n+void VM_Version::RVExtFeatureValue::log_disabled(const char* reason) {\n+  log_info(os, cpu)(\"Disabled RV64 feature \\\"%s\\\" (%s)\", pretty(), reason);\n@@ -111,1 +115,1 @@\n-  log_debug(os, cpu)(\"Enabled RV64 feature \\\"%s\\\" (%ld)\", pretty(), value());\n+  log_info(os, cpu)(\"Enabled RV64 feature \\\"%s\\\" (%ld)\", pretty(), value());\n@@ -196,1 +200,1 @@\n-      log_debug(os, cpu)(\"UseCtxFencei (PR_RISCV_CTX_SW_FENCEI_ON) enabled.\");\n+      log_info(os, cpu)(\"UseCtxFencei (PR_RISCV_CTX_SW_FENCEI_ON) enabled.\");\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -452,1 +452,1 @@\n-  int mt_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument_index(arg_i);\n+  int mt_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument(arg_i);\n@@ -468,1 +468,1 @@\n-  int mh_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument_index(arg_i);\n+  int mh_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument(arg_i);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+int volatile AOTMetaspace::_preimage_static_archive_dumped = 0;\n@@ -1061,0 +1062,5 @@\n+bool AOTMetaspace::preimage_static_archive_dumped() {\n+  assert(CDSConfig::is_dumping_preimage_static_archive(), \"Required\");\n+  return AtomicAccess::load_acquire(&_preimage_static_archive_dumped) == 1;\n+}\n+\n@@ -1062,0 +1068,9 @@\n+  if (CDSConfig::is_dumping_preimage_static_archive()) {\n+    \/\/ When dumping to the AOT configuration file ensure this function is only executed once.\n+    \/\/ Multiple invocations may happen via JCmd, during VM exit or other means (in the future)\n+    \/\/ from different threads and possibly concurrently.\n+    if (AtomicAccess::cmpxchg(&_preimage_static_archive_dumped, 0, 1) != 0) {\n+      return;\n+    }\n+  }\n+\n@@ -1360,2 +1375,5 @@\n-      aot_log_warning(aot)(\"Preload Warning: Verification failed for %s\",\n-                    ik->external_name());\n+      oop message = java_lang_Throwable::message(current->pending_exception());\n+      aot_log_warning(aot)(\"Preload Warning: Verification failed for %s because a %s was thrown: %s\",\n+                            ik->external_name(),\n+                            current->pending_exception()->klass()->external_name(),\n+                            message == nullptr ? \"(no message)\" : java_lang_String::as_utf8_string(message));\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  static int volatile _preimage_static_archive_dumped;\n@@ -118,0 +119,2 @@\n+  static bool preimage_static_archive_dumped() NOT_CDS_RETURN_(false);\n+\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1066,1 +1066,3 @@\n-    assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n+\n+    assert(compiler->type() == compiler_c2 ||\n+           offsets->value(CodeOffsets::Exceptions) != -1, \"must have exception entry\");\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -3452,0 +3453,1 @@\n+  const int cp_size = cp->length();\n@@ -3453,1 +3455,1 @@\n-  const u1* const current_start = cfs->current();\n+  const u1* const current_before_parsing = cfs->current();\n@@ -3462,1 +3464,1 @@\n-  const int attribute_array_length = cfs->get_u2_fast();\n+  const int num_bootstrap_methods = cfs->get_u2_fast();\n@@ -3464,1 +3466,1 @@\n-  guarantee_property(_max_bootstrap_specifier_index < attribute_array_length,\n+  guarantee_property(_max_bootstrap_specifier_index < num_bootstrap_methods,\n@@ -3468,0 +3470,1 @@\n+  const u4 bootstrap_methods_u2_len = (attribute_byte_length - sizeof(u2)) \/ sizeof(u2);\n@@ -3469,14 +3472,1 @@\n-  \/\/ The attribute contains a counted array of counted tuples of shorts,\n-  \/\/ represending bootstrap specifiers:\n-  \/\/    length*{bootstrap_method_index, argument_count*{argument_index}}\n-  const unsigned int operand_count = (attribute_byte_length - (unsigned)sizeof(u2)) \/ (unsigned)sizeof(u2);\n-  \/\/ operand_count = number of shorts in attr, except for leading length\n-\n-  \/\/ The attribute is copied into a short[] array.\n-  \/\/ The array begins with a series of short[2] pairs, one for each tuple.\n-  const int index_size = (attribute_array_length * 2);\n-\n-  Array<u2>* const operands =\n-    MetadataFactory::new_array<u2>(_loader_data, index_size + operand_count, CHECK);\n-\n-  \/\/ Eagerly assign operands so they will be deallocated with the constant\n+  \/\/ Eagerly assign the arrays so that they will be deallocated with the constant\n@@ -3484,8 +3474,5 @@\n-  cp->set_operands(operands);\n-\n-  int operand_fill_index = index_size;\n-  const int cp_size = cp->length();\n-\n-  for (int n = 0; n < attribute_array_length; n++) {\n-    \/\/ Store a 32-bit offset into the header of the operand array.\n-    ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);\n+  BSMAttributeEntries::InsertionIterator iter =\n+    cp->bsm_entries().start_extension(num_bootstrap_methods,\n+                                      bootstrap_methods_u2_len,\n+                                      _loader_data,\n+                                      CHECK);\n@@ -3493,1 +3480,1 @@\n-    \/\/ Read a bootstrap specifier.\n+  for (int i = 0; i < num_bootstrap_methods; i++) {\n@@ -3495,2 +3482,2 @@\n-    const u2 bootstrap_method_index = cfs->get_u2_fast();\n-    const u2 argument_count = cfs->get_u2_fast();\n+    u2 bootstrap_method_ref = cfs->get_u2_fast();\n+    u2 num_bootstrap_arguments = cfs->get_u2_fast();\n@@ -3498,15 +3485,13 @@\n-      valid_cp_range(bootstrap_method_index, cp_size) &&\n-      cp->tag_at(bootstrap_method_index).is_method_handle(),\n-      \"bootstrap_method_index %u has bad constant type in class file %s\",\n-      bootstrap_method_index,\n-      CHECK);\n-\n-    guarantee_property((operand_fill_index + 1 + argument_count) < operands->length(),\n-      \"Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s\",\n-      CHECK);\n-\n-    operands->at_put(operand_fill_index++, bootstrap_method_index);\n-    operands->at_put(operand_fill_index++, argument_count);\n-\n-    cfs->guarantee_more(sizeof(u2) * argument_count, CHECK);  \/\/ argv[argc]\n-    for (int j = 0; j < argument_count; j++) {\n+       valid_cp_range(bootstrap_method_ref, cp_size) &&\n+       cp->tag_at(bootstrap_method_ref).is_method_handle(),\n+       \"bootstrap_method_index %u has bad constant type in class file %s\",\n+       bootstrap_method_ref,\n+       CHECK);\n+    cfs->guarantee_more(sizeof(u2) * num_bootstrap_arguments, CHECK); \/\/ argv[argc]\n+\n+    BSMAttributeEntry* entry = iter.reserve_new_entry(bootstrap_method_ref, num_bootstrap_arguments);\n+    guarantee_property(entry != nullptr,\n+                       \"Invalid BootstrapMethods num_bootstrap_methods.\"\n+                       \" The total amount of space reserved for the BootstrapMethod attribute was not sufficient\", CHECK);\n+\n+    for (int argi = 0; argi < num_bootstrap_arguments; argi++) {\n@@ -3520,1 +3505,1 @@\n-      operands->at_put(operand_fill_index++, argument_index);\n+      entry->set_argument(argi, argument_index);\n@@ -3523,1 +3508,2 @@\n-  guarantee_property(current_start + attribute_byte_length == cfs->current(),\n+  cp->bsm_entries().end_extension(iter, _loader_data, CHECK);\n+  guarantee_property(current_before_parsing + attribute_byte_length == cfs->current(),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":31,"deletions":45,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -471,21 +471,19 @@\n-  JImageLocationRef location = jimage_find_resource(\"\", name, is_preview, &size);\n-\n-  if (location == 0) {\n-    TempNewSymbol class_name = SymbolTable::new_symbol(name);\n-    TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n-\n-    if (pkg_name != nullptr) {\n-      if (!Universe::is_module_initialized()) {\n-        location = jimage_find_resource(JAVA_BASE_NAME, name, is_preview, &size);\n-      } else {\n-        PackageEntry* package_entry = ClassLoader::get_package_entry(pkg_name, loader_data);\n-        if (package_entry != nullptr) {\n-          ResourceMark rm(current);\n-          \/\/ Get the module name\n-          ModuleEntry* module = package_entry->module();\n-          assert(module != nullptr, \"Boot classLoader package missing module\");\n-          assert(module->is_named(), \"Boot classLoader package is in unnamed module\");\n-          const char* module_name = module->name()->as_C_string();\n-          if (module_name != nullptr) {\n-            location = jimage_find_resource(module_name, name, is_preview, &size);\n-          }\n+  JImageLocationRef location = 0;\n+\n+  TempNewSymbol class_name = SymbolTable::new_symbol(name);\n+  TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n+\n+  if (pkg_name != nullptr) {\n+    if (!Universe::is_module_initialized()) {\n+      location = jimage_find_resource(JAVA_BASE_NAME, name, is_preview, &size);\n+    } else {\n+      PackageEntry* package_entry = ClassLoader::get_package_entry(pkg_name, loader_data);\n+      if (package_entry != nullptr) {\n+        ResourceMark rm(current);\n+        \/\/ Get the module name\n+        ModuleEntry* module = package_entry->module();\n+        assert(module != nullptr, \"Boot classLoader package missing module\");\n+        assert(module->is_named(), \"Boot classLoader package is in unnamed module\");\n+        const char* module_name = module->name()->as_C_string();\n+        if (module_name != nullptr) {\n+          location = jimage_find_resource(module_name, name, is_preview, &size);\n@@ -496,0 +494,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1320,1 +1320,1 @@\n-    _deopt_handler_offset    = 0;\n+    _deopt_handler_entry_offset    = 0;\n@@ -1460,1 +1460,1 @@\n-  _deopt_handler_offset         = nm._deopt_handler_offset;\n+  _deopt_handler_entry_offset   = nm._deopt_handler_entry_offset;\n@@ -1722,1 +1722,1 @@\n-        _deopt_handler_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n+        _deopt_handler_entry_offset    = code_offset() + offsets->value(CodeOffsets::Deopt);\n@@ -1724,1 +1724,1 @@\n-        _deopt_handler_offset    = -1;\n+        _deopt_handler_entry_offset    = -1;\n@@ -1730,1 +1730,0 @@\n-      assert(offsets->value(CodeOffsets::Exceptions) != -1, \"must be set\");\n@@ -1733,2 +1732,10 @@\n-      _exception_offset          = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n-      _deopt_handler_offset      = _stub_offset + offsets->value(CodeOffsets::Deopt);\n+      bool has_exception_handler = (offsets->value(CodeOffsets::Exceptions) != -1);\n+      assert(has_exception_handler == (compiler->type() != compiler_c2),\n+             \"C2 compiler doesn't provide exception handler stub code.\");\n+      if (has_exception_handler) {\n+        _exception_offset = _stub_offset + offsets->value(CodeOffsets::Exceptions);\n+      } else {\n+        _exception_offset = -1;\n+      }\n+\n+      _deopt_handler_entry_offset = _stub_offset + offsets->value(CodeOffsets::Deopt);\n@@ -4049,1 +4056,1 @@\n-  if (JVMCI_ONLY(_deopt_handler_offset != -1 &&) pos == deopt_handler_begin()) label = \"[Deopt Handler Code]\";\n+  if (JVMCI_ONLY(_deopt_handler_entry_offset != -1 &&) pos == deopt_handler_entry()) label = \"[Deopt Handler Entry Point]\";\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-  int _deopt_handler_offset;\n+  int _deopt_handler_entry_offset;\n@@ -625,1 +625,1 @@\n-  address deopt_handler_begin   () const { return           header_begin() + _deopt_handler_offset    ; }\n+  address deopt_handler_entry   () const { return           header_begin() + _deopt_handler_entry_offset    ; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return pc == deopt_handler_begin();\n+  return pc == deopt_handler_entry();\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1013,2 +1013,4 @@\n-  st->print_cr(\"Compiler Memory Statistic, 10 most expensive compilations:\");\n-  print_all_by_size(st, false, false, 0, 10);\n+  if (Thread::current_or_null_safe() != nullptr) {\n+    st->print_cr(\"Compiler Memory Statistic, 10 most expensive compilations:\");\n+    print_all_by_size(st, false, false, 0, 10);\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,5 +82,4 @@\n-#if __clang_major__ >= 19\n-\/\/ clang18 and earlier may accept the declaration but go wrong with uses.\n-\/\/ Different warnings and link-time failures are both possible.\n-#define CAN_DEPRECATE_HARDWARE_INTERFERENCE_SIZES 1\n-#endif \/\/ restrict clang version\n+\/\/ Some versions of clang with some stdlibs reject the declaration. Others may\n+\/\/ accept the declaration but go wrong with uses.  Different warnings and\n+\/\/ link-time failures are both possible.\n+\/\/ Known to have problems at least through clang19.\n","filename":"src\/hotspot\/share\/cppstdlib\/new.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -481,5 +481,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n@@ -741,5 +736,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n@@ -1648,0 +1638,4 @@\n+bool G1CollectedHeap::concurrent_mark_is_terminating() const {\n+  return _cm_thread->should_terminate();\n+}\n+\n@@ -1968,2 +1962,2 @@\n-    \/\/ we're terminating, then we're done.\n-    if (is_shutting_down()) {\n+    \/\/ we're shutting down, then we're done.\n+    if (op.is_shutting_down()) {\n@@ -2364,1 +2358,2 @@\n-  size_t heap_used = Heap_lock->owned_by_self() ? used() : used_unlocked();\n+  size_t heap_used = (Thread::current_or_null_safe() != nullptr &&\n+                      Heap_lock->owned_by_self()) ? used() : used_unlocked();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -920,0 +920,3 @@\n+  \/\/ Returns whether concurrent mark threads (and the VM) are about to terminate.\n+  bool concurrent_mark_is_terminating() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -270,2 +270,0 @@\n-  uint num_added_to_group = 0;\n-\n@@ -282,1 +280,1 @@\n-    if (num_added_to_group == group_limit) {\n+    if (current->length() == group_limit) {\n@@ -290,1 +288,0 @@\n-      num_added_to_group = 0;\n@@ -293,1 +290,0 @@\n-    num_added_to_group++;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1886,1 +1886,1 @@\n-  if (!cm_thread()->in_progress() && !_g1h->is_shutting_down()) {\n+  if (!cm_thread()->in_progress() && !_g1h->concurrent_mark_is_terminating()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,4 +310,0 @@\n-void G1HeapRegion::remove_code_root(nmethod* nm) {\n-  rem_set()->remove_code_root(nm);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -546,1 +546,0 @@\n-  void remove_code_root(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,15 +31,3 @@\n-G1IHOPControl::G1IHOPControl(double initial_ihop_percent,\n-                             G1OldGenAllocationTracker const* old_gen_alloc_tracker) :\n-  _initial_ihop_percent(initial_ihop_percent),\n-  _target_occupancy(0),\n-  _last_allocation_time_s(0.0),\n-  _old_gen_alloc_tracker(old_gen_alloc_tracker)\n-{\n-  assert(_initial_ihop_percent >= 0.0 && _initial_ihop_percent <= 100.0, \"Initial IHOP value must be between 0 and 100 but is %.3f\", initial_ihop_percent);\n-}\n-\n-void G1IHOPControl::update_target_occupancy(size_t new_target_occupancy) {\n-  log_debug(gc, ihop)(\"Target occupancy update: old: %zuB, new: %zuB\",\n-                      _target_occupancy, new_target_occupancy);\n-  _target_occupancy = new_target_occupancy;\n-}\n+double G1IHOPControl::predict(const TruncatedSeq* seq) const {\n+  assert(_is_adaptive, \"precondition\");\n+  assert(_predictor != nullptr, \"precondition\");\n@@ -47,3 +35,1 @@\n-void G1IHOPControl::report_statistics(G1NewTracer* new_tracer, size_t non_young_occupancy) {\n-  print_log(non_young_occupancy);\n-  send_trace_event(new_tracer, non_young_occupancy);\n+  return  _predictor->predict_zero_bounded(seq);\n@@ -52,2 +38,2 @@\n-void G1IHOPControl::update_allocation_info(double allocation_time_s, size_t additional_buffer_size) {\n-  assert(allocation_time_s >= 0.0, \"Allocation time must be positive but is %.3f\", allocation_time_s);\n+bool G1IHOPControl::have_enough_data_for_prediction() const {\n+  assert(_is_adaptive, \"precondition\");\n@@ -55,26 +41,2 @@\n-  _last_allocation_time_s = allocation_time_s;\n-}\n-\n-void G1IHOPControl::print_log(size_t non_young_occupancy) {\n-  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n-  size_t cur_conc_mark_start_threshold = get_conc_mark_start_threshold();\n-  log_debug(gc, ihop)(\"Basic information (value update), threshold: %zuB (%1.2f), target occupancy: %zuB, non-young occupancy: %zuB, \"\n-                      \"recent allocation size: %zuB, recent allocation duration: %1.2fms, recent old gen allocation rate: %1.2fB\/s, recent marking phase length: %1.2fms\",\n-                      cur_conc_mark_start_threshold,\n-                      percent_of(cur_conc_mark_start_threshold, _target_occupancy),\n-                      _target_occupancy,\n-                      non_young_occupancy,\n-                      _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n-                      _last_allocation_time_s * 1000.0,\n-                      _last_allocation_time_s > 0.0 ? _old_gen_alloc_tracker->last_period_old_gen_bytes() \/ _last_allocation_time_s : 0.0,\n-                      last_marking_length_s() * 1000.0);\n-}\n-\n-void G1IHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n-  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n-  tracer->report_basic_ihop_statistics(get_conc_mark_start_threshold(),\n-                                       _target_occupancy,\n-                                       non_young_occupancy,\n-                                       _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n-                                       _last_allocation_time_s,\n-                                       last_marking_length_s());\n+  return ((size_t)_marking_times_s.num() >= G1AdaptiveIHOPNumInitialSamples) &&\n+         ((size_t)_allocation_rate_s.num() >= G1AdaptiveIHOPNumInitialSamples);\n@@ -83,4 +45,2 @@\n-G1StaticIHOPControl::G1StaticIHOPControl(double ihop_percent,\n-                                         G1OldGenAllocationTracker const* old_gen_alloc_tracker) :\n-  G1IHOPControl(ihop_percent, old_gen_alloc_tracker),\n-  _last_marking_length_s(0.0) {\n+double G1IHOPControl::last_marking_length_s() const {\n+  return _marking_times_s.last();\n@@ -89,14 +49,2 @@\n-G1AdaptiveIHOPControl::G1AdaptiveIHOPControl(double ihop_percent,\n-                                             G1OldGenAllocationTracker const* old_gen_alloc_tracker,\n-                                             G1Predictions const* predictor,\n-                                             size_t heap_reserve_percent,\n-                                             size_t heap_waste_percent) :\n-  G1IHOPControl(ihop_percent, old_gen_alloc_tracker),\n-  _heap_reserve_percent(heap_reserve_percent),\n-  _heap_waste_percent(heap_waste_percent),\n-  _predictor(predictor),\n-  _marking_times_s(10, 0.05),\n-  _allocation_rate_s(10, 0.05),\n-  _last_unrestrained_young_size(0)\n-{\n-}\n+size_t G1IHOPControl::actual_target_threshold() const {\n+  assert(_is_adaptive, \"precondition\");\n@@ -104,2 +52,0 @@\n-size_t G1AdaptiveIHOPControl::actual_target_threshold() const {\n-  guarantee(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n@@ -113,2 +59,2 @@\n-\n-  double safe_total_heap_percentage = MIN2((double)(_heap_reserve_percent + _heap_waste_percent), 100.0);\n+  double safe_total_heap_percentage =\n+    MIN2((double)(_heap_reserve_percent + _heap_waste_percent), 100.0);\n@@ -119,1 +65,29 @@\n-    );\n+  );\n+}\n+\n+G1IHOPControl::G1IHOPControl(double ihop_percent,\n+                             const G1OldGenAllocationTracker* old_gen_alloc_tracker,\n+                             bool adaptive,\n+                             const G1Predictions* predictor,\n+                             size_t heap_reserve_percent,\n+                             size_t heap_waste_percent)\n+  : _is_adaptive(adaptive),\n+    _initial_ihop_percent(ihop_percent),\n+    _target_occupancy(0),\n+    _heap_reserve_percent(heap_reserve_percent),\n+    _heap_waste_percent(heap_waste_percent),\n+    _last_allocation_time_s(0.0),\n+    _old_gen_alloc_tracker(old_gen_alloc_tracker),\n+    _predictor(predictor),\n+    _marking_times_s(10, 0.05),\n+    _allocation_rate_s(10, 0.05),\n+    _last_unrestrained_young_size(0) {\n+  assert(_initial_ihop_percent >= 0.0 && _initial_ihop_percent <= 100.0,\n+         \"IHOP percent out of range: %.3f\", ihop_percent);\n+  assert(!_is_adaptive || _predictor != nullptr, \"precondition\");\n+}\n+\n+void G1IHOPControl::update_target_occupancy(size_t new_target_occupancy) {\n+  log_debug(gc, ihop)(\"Target occupancy update: old: %zuB, new: %zuB\",\n+                      _target_occupancy, new_target_occupancy);\n+  _target_occupancy = new_target_occupancy;\n@@ -122,2 +96,3 @@\n-double G1AdaptiveIHOPControl::predict(TruncatedSeq const* seq) const {\n-  return _predictor->predict_zero_bounded(seq);\n+void G1IHOPControl::report_statistics(G1NewTracer* new_tracer, size_t non_young_occupancy) {\n+  print_log(non_young_occupancy);\n+  send_trace_event(new_tracer, non_young_occupancy);\n@@ -126,3 +101,6 @@\n-bool G1AdaptiveIHOPControl::have_enough_data_for_prediction() const {\n-  return ((size_t)_marking_times_s.num() >= G1AdaptiveIHOPNumInitialSamples) &&\n-         ((size_t)_allocation_rate_s.num() >= G1AdaptiveIHOPNumInitialSamples);\n+void G1IHOPControl::update_allocation_info(double allocation_time_s, size_t additional_buffer_size) {\n+  assert(allocation_time_s > 0, \"Invalid allocation time: %.3f\", allocation_time_s);\n+  _last_allocation_time_s = allocation_time_s;\n+  double alloc_rate = _old_gen_alloc_tracker->last_period_old_gen_growth() \/ allocation_time_s;\n+  _allocation_rate_s.add(alloc_rate);\n+  _last_unrestrained_young_size = additional_buffer_size;\n@@ -131,21 +109,3 @@\n-size_t G1AdaptiveIHOPControl::get_conc_mark_start_threshold() {\n-  if (have_enough_data_for_prediction()) {\n-    double pred_marking_time = predict(&_marking_times_s);\n-    double pred_promotion_rate = predict(&_allocation_rate_s);\n-    size_t pred_promotion_size = (size_t)(pred_marking_time * pred_promotion_rate);\n-\n-    size_t predicted_needed_bytes_during_marking =\n-      pred_promotion_size +\n-      \/\/ In reality we would need the maximum size of the young gen during\n-      \/\/ marking. This is a conservative estimate.\n-      _last_unrestrained_young_size;\n-\n-    size_t internal_threshold = actual_target_threshold();\n-    size_t predicted_initiating_threshold = predicted_needed_bytes_during_marking < internal_threshold ?\n-                                            internal_threshold - predicted_needed_bytes_during_marking :\n-                                            0;\n-    return predicted_initiating_threshold;\n-  } else {\n-    \/\/ Use the initial value.\n-    return (size_t)(_initial_ihop_percent * _target_occupancy \/ 100.0);\n-  }\n+void G1IHOPControl::update_marking_length(double marking_length_s) {\n+  assert(marking_length_s >= 0.0, \"Invalid marking length: %.3f\", marking_length_s);\n+  _marking_times_s.add(marking_length_s);\n@@ -154,2 +114,2 @@\n-double G1AdaptiveIHOPControl::last_mutator_period_old_allocation_rate() const {\n-  assert(_last_allocation_time_s > 0, \"This should not be called when the last GC is full\");\n+size_t G1IHOPControl::get_conc_mark_start_threshold() {\n+  guarantee(_target_occupancy > 0, \"Target occupancy must be initialized\");\n@@ -157,2 +117,3 @@\n-  return _old_gen_alloc_tracker->last_period_old_gen_growth() \/ _last_allocation_time_s;\n-}\n+  if (!_is_adaptive || !have_enough_data_for_prediction()) {\n+    return (size_t)(_initial_ihop_percent * _target_occupancy \/ 100.0);\n+  }\n@@ -160,4 +121,5 @@\n-void G1AdaptiveIHOPControl::update_allocation_info(double allocation_time_s,\n-                                                   size_t additional_buffer_size) {\n-  G1IHOPControl::update_allocation_info(allocation_time_s, additional_buffer_size);\n-  _allocation_rate_s.add(last_mutator_period_old_allocation_rate());\n+  double pred_marking_time = predict(&_marking_times_s);\n+  double pred_rate = predict(&_allocation_rate_s);\n+  size_t pred_bytes = (size_t)(pred_marking_time * pred_rate);\n+  size_t predicted_needed = pred_bytes + _last_unrestrained_young_size;\n+  size_t internal_threshold = actual_target_threshold();\n@@ -165,1 +127,3 @@\n-  _last_unrestrained_young_size = additional_buffer_size;\n+  return predicted_needed < internal_threshold\n+         ? internal_threshold - predicted_needed\n+         : 0;\n@@ -168,4 +132,17 @@\n-void G1AdaptiveIHOPControl::update_marking_length(double marking_length_s) {\n-   assert(marking_length_s >= 0.0, \"Marking length must be larger than zero but is %.3f\", marking_length_s);\n-  _marking_times_s.add(marking_length_s);\n-}\n+void G1IHOPControl::print_log(size_t non_young_occupancy) {\n+  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n+  size_t cur_conc_mark_start_threshold = get_conc_mark_start_threshold();\n+  log_debug(gc, ihop)(\"Basic information (value update), threshold: %zuB (%1.2f), target occupancy: %zuB, non-young occupancy: %zuB, \"\n+                      \"recent allocation size: %zuB, recent allocation duration: %1.2fms, recent old gen allocation rate: %1.2fB\/s, recent marking phase length: %1.2fms\",\n+                      cur_conc_mark_start_threshold,\n+                      percent_of(cur_conc_mark_start_threshold, _target_occupancy),\n+                      _target_occupancy,\n+                      non_young_occupancy,\n+                      _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n+                      _last_allocation_time_s * 1000.0,\n+                      _last_allocation_time_s > 0.0 ? _old_gen_alloc_tracker->last_period_old_gen_bytes() \/ _last_allocation_time_s : 0.0,\n+                      last_marking_length_s() * 1000.0);\n+\n+  if (!_is_adaptive) {\n+    return;\n+  }\n@@ -173,2 +150,0 @@\n-void G1AdaptiveIHOPControl::print_log(size_t non_young_occupancy) {\n-  G1IHOPControl::print_log(non_young_occupancy);\n@@ -179,2 +154,2 @@\n-                      get_conc_mark_start_threshold(),\n-                      percent_of(get_conc_mark_start_threshold(), actual_threshold),\n+                      cur_conc_mark_start_threshold,\n+                      percent_of(cur_conc_mark_start_threshold, actual_threshold),\n@@ -189,9 +164,18 @@\n-void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n-  G1IHOPControl::send_trace_event(tracer, non_young_occupancy);\n-  tracer->report_adaptive_ihop_statistics(get_conc_mark_start_threshold(),\n-                                          actual_target_threshold(),\n-                                          non_young_occupancy,\n-                                          _last_unrestrained_young_size,\n-                                          predict(&_allocation_rate_s),\n-                                          predict(&_marking_times_s),\n-                                          have_enough_data_for_prediction());\n+void G1IHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n+  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n+  tracer->report_basic_ihop_statistics(get_conc_mark_start_threshold(),\n+                                       _target_occupancy,\n+                                       non_young_occupancy,\n+                                       _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n+                                       _last_allocation_time_s,\n+                                       last_marking_length_s());\n+\n+  if (_is_adaptive) {\n+    tracer->report_adaptive_ihop_statistics(get_conc_mark_start_threshold(),\n+                                            actual_target_threshold(),\n+                                            non_young_occupancy,\n+                                            _last_unrestrained_young_size,\n+                                            predict(&_allocation_rate_s),\n+                                            predict(&_marking_times_s),\n+                                            have_enough_data_for_prediction());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.cpp","additions":105,"deletions":121,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -35,3 +35,4 @@\n-\/\/ Base class for algorithms that calculate the heap occupancy at which\n-\/\/ concurrent marking should start. This heap usage threshold should be relative\n-\/\/ to old gen size.\n+\/\/ Implements two strategies for calculating the concurrent mark starting occupancy threshold:\n+\/\/ - Static mode: Uses a fixed percentage of the target heap occupancy.\n+\/\/ - Adaptive mode: Predicts a threshold based on allocation rates and marking durations\n+\/\/   to ensure the target occupancy is never exceeded during marking.\n@@ -39,1 +40,3 @@\n- protected:\n+ private:\n+  const bool _is_adaptive;\n+\n@@ -42,0 +45,1 @@\n+\n@@ -46,0 +50,6 @@\n+  \/\/ Percentage of maximum heap capacity we should avoid to touch\n+  const size_t _heap_reserve_percent;\n+\n+  \/\/ Percentage of free heap that should be considered as waste.\n+  const size_t _heap_waste_percent;\n+\n@@ -48,1 +58,0 @@\n-\n@@ -50,67 +59,0 @@\n-  \/\/ Initialize an instance with the old gen allocation tracker and the\n-  \/\/ initial IHOP value in percent. The target occupancy will be updated\n-  \/\/ at the first heap expansion.\n-  G1IHOPControl(double ihop_percent, G1OldGenAllocationTracker const* old_gen_alloc_tracker);\n-\n-  \/\/ Most recent time from the end of the concurrent start to the start of the first\n-  \/\/ mixed gc.\n-  virtual double last_marking_length_s() const = 0;\n-\n-  virtual void print_log(size_t non_young_occupancy);\n-  virtual void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n-\n-public:\n-  virtual ~G1IHOPControl() { }\n-\n-  \/\/ Get the current non-young occupancy at which concurrent marking should start.\n-  virtual size_t get_conc_mark_start_threshold() = 0;\n-\n-  \/\/ Adjust target occupancy.\n-  virtual void update_target_occupancy(size_t new_target_occupancy);\n-  \/\/ Update information about time during which allocations in the Java heap occurred,\n-  \/\/ how large these allocations were in bytes, and an additional buffer.\n-  \/\/ The allocations should contain any amount of space made unusable for further\n-  \/\/ allocation, e.g. any waste caused by TLAB allocation, space at the end of\n-  \/\/ humongous objects that can not be used for allocation, etc.\n-  \/\/ Together with the target occupancy, this additional buffer should contain the\n-  \/\/ difference between old gen size and total heap size at the start of reclamation,\n-  \/\/ and space required for that reclamation.\n-  virtual void update_allocation_info(double allocation_time_s, size_t additional_buffer_size);\n-  \/\/ Update the time spent in the mutator beginning from the end of concurrent start to\n-  \/\/ the first mixed gc.\n-  virtual void update_marking_length(double marking_length_s) = 0;\n-\n-  void report_statistics(G1NewTracer* tracer, size_t non_young_occupancy);\n-};\n-\n-\/\/ The returned concurrent mark starting occupancy threshold is a fixed value\n-\/\/ relative to the maximum heap size.\n-class G1StaticIHOPControl : public G1IHOPControl {\n-  \/\/ Most recent mutator time between the end of concurrent mark to the start of the\n-  \/\/ first mixed gc.\n-  double _last_marking_length_s;\n- protected:\n-  double last_marking_length_s() const { return _last_marking_length_s; }\n- public:\n-  G1StaticIHOPControl(double ihop_percent, G1OldGenAllocationTracker const* old_gen_alloc_tracker);\n-\n-  size_t get_conc_mark_start_threshold() {\n-    guarantee(_target_occupancy > 0, \"Target occupancy must have been initialized.\");\n-    return (size_t) (_initial_ihop_percent * _target_occupancy \/ 100.0);\n-  }\n-\n-  virtual void update_marking_length(double marking_length_s) {\n-   assert(marking_length_s > 0.0, \"Marking length must be larger than zero but is %.3f\", marking_length_s);\n-    _last_marking_length_s = marking_length_s;\n-  }\n-};\n-\n-\/\/ This algorithm tries to return a concurrent mark starting occupancy value that\n-\/\/ makes sure that during marking the given target occupancy is never exceeded,\n-\/\/ based on predictions of current allocation rate and time periods between\n-\/\/ concurrent start and the first mixed gc.\n-class G1AdaptiveIHOPControl : public G1IHOPControl {\n-  size_t _heap_reserve_percent; \/\/ Percentage of maximum heap capacity we should avoid to touch\n-  size_t _heap_waste_percent;   \/\/ Percentage of free heap that should be considered as waste.\n-\n-  const G1Predictions * _predictor;\n@@ -118,0 +60,1 @@\n+  const G1Predictions* _predictor;\n@@ -131,1 +74,1 @@\n-  double predict(TruncatedSeq const* seq) const;\n+  double predict(const TruncatedSeq* seq) const;\n@@ -134,0 +77,1 @@\n+  double last_marking_length_s() const;\n@@ -140,8 +84,2 @@\n-  \/\/ This method calculates the old gen allocation rate based on the net survived\n-  \/\/ bytes that are allocated in the old generation in the last mutator period.\n-  double last_mutator_period_old_allocation_rate() const;\n- protected:\n-  virtual double last_marking_length_s() const { return _marking_times_s.last(); }\n-\n-  virtual void print_log(size_t non_young_occupancy);\n-  virtual void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n+ void print_log(size_t non_young_occupancy);\n+ void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n@@ -150,5 +88,23 @@\n-  G1AdaptiveIHOPControl(double ihop_percent,\n-                        G1OldGenAllocationTracker const* old_gen_alloc_tracker,\n-                        G1Predictions const* predictor,\n-                        size_t heap_reserve_percent, \/\/ The percentage of total heap capacity that should not be tapped into.\n-                        size_t heap_waste_percent);  \/\/ The percentage of the free space in the heap that we think is not usable for allocation.\n+  G1IHOPControl(double ihop_percent,\n+                const G1OldGenAllocationTracker* old_gen_alloc_tracker,\n+                bool adaptive,\n+                const G1Predictions* predictor,\n+                size_t heap_reserve_percent,\n+                size_t heap_waste_percent);\n+\n+  \/\/ Adjust target occupancy.\n+  void update_target_occupancy(size_t new_target_occupancy);\n+\n+  \/\/ Update information about time during which allocations in the Java heap occurred,\n+  \/\/ how large these allocations were in bytes, and an additional buffer.\n+  \/\/ The allocations should contain any amount of space made unusable for further\n+  \/\/ allocation, e.g. any waste caused by TLAB allocation, space at the end of\n+  \/\/ humongous objects that can not be used for allocation, etc.\n+  \/\/ Together with the target occupancy, this additional buffer should contain the\n+  \/\/ difference between old gen size and total heap size at the start of reclamation,\n+  \/\/ and space required for that reclamation.\n+  void update_allocation_info(double allocation_time_s, size_t additional_buffer_size);\n+\n+  \/\/ Update the time spent in the mutator beginning from the end of concurrent start to\n+  \/\/ the first mixed gc.\n+  void update_marking_length(double marking_length_s);\n@@ -156,1 +112,2 @@\n-  virtual size_t get_conc_mark_start_threshold();\n+  \/\/ Get the current non-young occupancy at which concurrent marking should start.\n+  size_t get_conc_mark_start_threshold();\n@@ -158,2 +115,1 @@\n-  virtual void update_allocation_info(double allocation_time_s, size_t additional_buffer_size);\n-  virtual void update_marking_length(double marking_length_s);\n+  void report_statistics(G1NewTracer* tracer, size_t non_young_occupancy);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.hpp","additions":45,"deletions":89,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-class G1AdaptiveIHOPControl;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OldGenAllocationTracker.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -672,1 +672,0 @@\n-  assert(!_g1h->is_shutting_down(), \"Invariant!\");\n@@ -1029,9 +1028,6 @@\n-  if (G1UseAdaptiveIHOP) {\n-    return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,\n-                                     old_gen_alloc_tracker,\n-                                     predictor,\n-                                     G1ReservePercent,\n-                                     G1HeapWastePercent);\n-  } else {\n-    return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent, old_gen_alloc_tracker);\n-  }\n+  return new G1IHOPControl(InitiatingHeapOccupancyPercent,\n+                           old_gen_alloc_tracker,\n+                           G1UseAdaptiveIHOP,\n+                           predictor,\n+                           G1ReservePercent,\n+                           G1HeapWastePercent);\n@@ -1283,6 +1279,0 @@\n-  \/\/ We should not be starting a concurrent start pause if the concurrent mark\n-  \/\/ thread is terminating.\n-  if (_g1h->is_shutting_down()) {\n-    return;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -995,4 +995,5 @@\n-  \/\/ Closure to make sure that the marking bitmap is clear for any old region in\n-  \/\/ the collection set.\n-  \/\/ This is needed to be able to use the bitmap for evacuation failure handling.\n-  class G1ClearBitmapClosure : public G1HeapRegionClosure {\n+  \/\/ Closure to prepare the collection set regions for evacuation failure, i.e. make\n+  \/\/ sure that the mark bitmap is clear for any old region in the collection set.\n+  \/\/\n+  \/\/ These mark bitmaps record the evacuation failed objects.\n+  class G1PrepareRegionsForEvacFailClosure : public G1HeapRegionClosure {\n@@ -1021,8 +1022,2 @@\n-      \/\/\n-      \/\/ There is one exception: shutdown might have aborted the Concurrent Cleanup for Next\n-      \/\/ Mark phase midway, which might have also left stale marks in old generation regions.\n-      \/\/ There might actually have been scheduled multiple collections, but at that point we do\n-      \/\/ not care that much about performance and just do the work multiple times if needed.\n-      return (_g1h->collector_state()->clear_bitmap_in_progress() ||\n-              _g1h->is_shutting_down()) &&\n-              hr->is_old();\n+      return _g1h->collector_state()->clear_bitmap_in_progress() &&\n+             hr->is_old();\n@@ -1032,1 +1027,1 @@\n-    G1ClearBitmapClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state, bool initial_evacuation) :\n+    G1PrepareRegionsForEvacFailClosure(G1CollectedHeap* g1h, G1RemSetScanState* scan_state, bool initial_evacuation) :\n@@ -1181,2 +1176,2 @@\n-      G1ClearBitmapClosure clear(g1h, _scan_state, _initial_evacuation);\n-      g1h->collection_set_iterate_increment_from(&clear, &_hr_claimer, worker_id);\n+      G1PrepareRegionsForEvacFailClosure prepare_evac_failure(g1h, _scan_state, _initial_evacuation);\n+      g1h->collection_set_iterate_increment_from(&prepare_evac_failure, &_hr_claimer, worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -347,5 +347,0 @@\n-\n-      if (is_shutting_down()) {\n-        stall_for_vm_shutdown();\n-        return nullptr;\n-      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-  HeapWord* base() const { return _reserved.start(); }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -340,5 +340,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+bool CollectedHeap::_is_shutting_down = false;\n+\n@@ -70,1 +72,1 @@\n-class GCLogMessage : public FormatBuffer<512> {};\n+class GCLogMessage : public FormatBuffer<1024> {};\n@@ -380,2 +382,1 @@\n-                                       full_gc_count,\n-                                       GCCause::_metadata_GC_threshold);\n+                                       full_gc_count);\n@@ -389,5 +390,0 @@\n-    if (is_shutting_down()) {\n-      stall_for_vm_shutdown();\n-      return nullptr;\n-    }\n-\n@@ -608,2 +604,3 @@\n-bool CollectedHeap::is_shutting_down() const {\n-  return Universe::is_shutting_down();\n+bool CollectedHeap::is_shutting_down() {\n+  assert(Heap_lock->owned_by_self(), \"Protected by this lock\");\n+  return _is_shutting_down;\n@@ -612,14 +609,7 @@\n-void CollectedHeap::stall_for_vm_shutdown() {\n-  assert(is_shutting_down(), \"Precondition\");\n-  \/\/ Stall the thread (2 seconds) instead of an indefinite wait to avoid deadlock\n-  \/\/ if the VM shutdown triggers a GC.\n-  \/\/ The 2-seconds sleep is:\n-  \/\/   - long enough to keep daemon threads stalled, while the shutdown\n-  \/\/     sequence completes in the common case.\n-  \/\/   - short enough to avoid excessive stall time if the shutdown itself\n-  \/\/     triggers a GC.\n-  JavaThread::current()->sleep(2 * MILLIUNITS);\n-\n-  ResourceMark rm;\n-  log_warning(gc, alloc)(\"%s: Stall for VM-Shutdown timed out; allocation may fail with OOME\", Thread::current()->name());\n-}\n+void CollectedHeap::initiate_shutdown() {\n+  {\n+    \/\/ Acquire the Heap_lock to synchronize with VM_Heap_Sync_Operations,\n+    \/\/ which may depend on the value of _is_shutting_down flag.\n+    MutexLocker hl(Heap_lock);\n+    _is_shutting_down = true;\n+  }\n@@ -627,1 +617,0 @@\n-void CollectedHeap::before_exit() {\n@@ -629,3 +618,0 @@\n-\n-  \/\/ Stop any on-going concurrent work and prepare for exit.\n-  stop();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+  static bool _is_shutting_down;\n+\n@@ -212,0 +214,1 @@\n+ public:\n@@ -215,2 +218,0 @@\n- public:\n-\n@@ -248,6 +249,1 @@\n-  bool is_shutting_down() const;\n-\n-  \/\/ If the VM is shutting down, we may have skipped VM_CollectForAllocation.\n-  \/\/ In this case, stall the allocation request briefly in the hope that\n-  \/\/ the VM shutdown completes before the allocation request returns.\n-  void stall_for_vm_shutdown();\n+  static bool is_shutting_down();\n@@ -255,1 +251,1 @@\n-  void before_exit();\n+  void initiate_shutdown();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  FreeNode* old_head = AtomicAccess::xchg(&_head, node);\n+  FreeNode* old_head = _head.exchange(node);\n@@ -51,1 +51,1 @@\n-  return AtomicAccess::add(&_count, size_t(1));\n+  return _count.add_then_fetch(1u);\n@@ -55,2 +55,2 @@\n-  NodeList result{AtomicAccess::load(&_head), _tail, AtomicAccess::load(&_count)};\n-  AtomicAccess::store(&_head, (FreeNode*)nullptr);\n+  NodeList result{_head.load_relaxed(), _tail, _count.load_relaxed()};\n+  _head.store_relaxed(nullptr);\n@@ -58,1 +58,1 @@\n-  AtomicAccess::store(&_count, size_t(0));\n+  _count.store_relaxed(0u);\n@@ -63,1 +63,1 @@\n-  return  AtomicAccess::load(&_count);\n+  return _count.load_relaxed();\n@@ -88,1 +88,1 @@\n-  uint index = AtomicAccess::load(&_active_pending_list);\n+  uint index = _active_pending_list.load_relaxed();\n@@ -96,1 +96,1 @@\n-  uint index = AtomicAccess::load(&_active_pending_list);\n+  uint index = _active_pending_list.load_relaxed();\n@@ -99,1 +99,1 @@\n-  _free_count = 0;\n+  _free_count.store_relaxed(0u);\n@@ -103,1 +103,1 @@\n-  return AtomicAccess::load(&_free_count);\n+  return _free_count.load_relaxed();\n@@ -107,1 +107,1 @@\n-  uint index = AtomicAccess::load(&_active_pending_list);\n+  uint index = _active_pending_list.load_relaxed();\n@@ -127,1 +127,1 @@\n-    size_t count = AtomicAccess::sub(&_free_count, 1u);\n+    size_t count = _free_count.sub_then_fetch(1u);\n@@ -152,1 +152,1 @@\n-    uint index = AtomicAccess::load_acquire(&_active_pending_list);\n+    uint index = _active_pending_list.load_acquire();\n@@ -167,2 +167,2 @@\n-  if (AtomicAccess::load(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n-      AtomicAccess::cmpxchg(&_transfer_lock, false, true)) {\n+  if (_transfer_lock.load_relaxed() || \/\/ Skip CAS if likely to fail.\n+      _transfer_lock.compare_exchange(false, true)) {\n@@ -175,1 +175,1 @@\n-  uint index = AtomicAccess::load(&_active_pending_list);\n+  uint index = _active_pending_list.load_relaxed();\n@@ -177,1 +177,1 @@\n-  AtomicAccess::release_store(&_active_pending_list, new_active);\n+  _active_pending_list.release_store(new_active);\n@@ -189,1 +189,1 @@\n-    AtomicAccess::add(&_free_count, count);\n+    _free_count.add_then_fetch(count);\n@@ -194,1 +194,1 @@\n-  AtomicAccess::release_store(&_transfer_lock, false);\n+  _transfer_lock.release_store(false);\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -65,1 +65,1 @@\n-    FreeNode* volatile _next;\n+    Atomic<FreeNode*> _next;\n@@ -69,1 +69,1 @@\n-    FreeNode* next() { return AtomicAccess::load(&_next); }\n+    FreeNode* next() { return _next.load_relaxed(); }\n@@ -71,1 +71,1 @@\n-    FreeNode* volatile* next_addr() { return &_next; }\n+    Atomic<FreeNode*>* next_addr() { return &_next; }\n@@ -73,1 +73,1 @@\n-    void set_next(FreeNode* next) { AtomicAccess::store(&_next, next); }\n+    void set_next(FreeNode* next) { _next.store_relaxed(next); }\n@@ -88,2 +88,2 @@\n-    FreeNode* volatile _head;\n-    volatile size_t _count;\n+    Atomic<FreeNode*> _head;\n+    Atomic<size_t> _count;\n@@ -108,2 +108,2 @@\n-  static FreeNode* volatile* next_ptr(FreeNode& node) { return node.next_addr(); }\n-  typedef LockFreeStack<FreeNode, &next_ptr> Stack;\n+  static Atomic<FreeNode*>* next_ptr(FreeNode& node) { return node.next_addr(); }\n+  using Stack = LockFreeStack<FreeNode, &next_ptr>;\n@@ -116,1 +116,1 @@\n-  DECLARE_PADDED_MEMBER(1, volatile size_t, _free_count);\n+  DECLARE_PADDED_MEMBER(1, Atomic<size_t>, _free_count);\n@@ -118,1 +118,1 @@\n-  DECLARE_PADDED_MEMBER(3, volatile bool, _transfer_lock);\n+  DECLARE_PADDED_MEMBER(3, Atomic<bool>, _transfer_lock);\n@@ -121,1 +121,1 @@\n-  volatile uint _active_pending_list;\n+  Atomic<uint> _active_pending_list;\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.hpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/thread.hpp\"\n@@ -86,1 +87,2 @@\n-  if (!_lock->try_lock_without_rank_check()) {\n+  if (Thread::current_or_null_safe() == nullptr ||\n+      !_lock->try_lock_without_rank_check()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,0 +95,16 @@\n+static void block_if_java_thread() {\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    \/\/ Block here and allow the shutdown to complete\n+    while (true) {\n+      \/\/ The call to wait has a few important effects:\n+      \/\/ 1) Block forever (minus spurious wake-ups, hence the loop)\n+      \/\/ 2) Release the Heap_lock, which is taken by the shutdown code\n+      \/\/ 3) Transition to blocked state so that the final VM_Exit operation can be scheduled\n+      Heap_lock->wait();\n+    }\n+  } else {\n+    assert(thread->is_ConcurrentGC_thread(), \"Unexpected thread type\");\n+  }\n+}\n+\n@@ -113,0 +129,7 @@\n+  _is_shutting_down = CollectedHeap::is_shutting_down();\n+  if (_is_shutting_down) {\n+    \/\/ Block forever if a Java thread is triggering a GC after\n+    \/\/ the GC has started to shut down.\n+    block_if_java_thread();\n+  }\n+\n@@ -114,1 +137,1 @@\n-  if (skip_operation() || Universe::is_shutting_down()) {\n+  if (skip_operation() || _is_shutting_down) {\n@@ -200,3 +223,2 @@\n-                                                                 uint full_gc_count_before,\n-                                                                 GCCause::Cause gc_cause)\n-    : VM_GC_Collect_Operation(gc_count_before, gc_cause, full_gc_count_before, true),\n+                                                                 uint full_gc_count_before)\n+    : VM_GC_Collect_Operation(gc_count_before, GCCause::_metadata_GC_threshold, full_gc_count_before, true),\n@@ -211,2 +233,5 @@\n-  CollectedHeap* heap = Universe::heap();\n-  GCCauseSetter gccs(heap, _gc_cause);\n+  \/\/ Note: GCCauseSetter is intentionally not used here.\n+  \/\/ The specific GC cause is set directly in downstream calls that initiate\n+  \/\/ collections, allowing us to accurately reflect different situations:\n+  \/\/ - A typical metadata allocation failure triggers a collection.\n+  \/\/ - As a last resort, a collection clears soft references if prior attempts fail.\n@@ -235,0 +260,2 @@\n+  CollectedHeap* heap = Universe::heap();\n+\n@@ -236,1 +263,1 @@\n-  heap->collect_as_vm_thread(GCCause::_metadata_GC_threshold);\n+  heap->collect_as_vm_thread(_gc_cause);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":34,"deletions":7,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+  bool           _is_shutting_down;        \/\/ whether the operation found that the GC is shutting down\n@@ -119,1 +120,1 @@\n-                  GCCause::Cause _cause,\n+                  GCCause::Cause cause,\n@@ -121,9 +122,8 @@\n-                  bool full) : VM_Heap_Sync_Operation() {\n-    _full = full;\n-    _prologue_succeeded = false;\n-    _gc_count_before    = gc_count_before;\n-\n-    _gc_cause           = _cause;\n-\n-    _full_gc_count_before = full_gc_count_before;\n-  }\n+                  bool full)\n+    : VM_Heap_Sync_Operation(),\n+      _gc_count_before(gc_count_before),\n+      _full_gc_count_before(full_gc_count_before),\n+      _full(full),\n+      _prologue_succeeded(false),\n+      _is_shutting_down(false),\n+      _gc_cause(cause) {}\n@@ -142,0 +142,8 @@\n+  \/\/ This function returns the value of CollectedHeap::is_shutting_down() that\n+  \/\/ was recorded in the prologue. Unlike CollectedHeap::is_shutting_down(),\n+  \/\/ this function can be called without acquiring the Heap_lock.\n+  \/\/\n+  \/\/ This function exists so that code that tries to schedule a GC operation\n+  \/\/ can check if it was refused because the JVM is about to shut down.\n+  bool is_shutting_down() const { return _is_shutting_down; }\n+\n@@ -217,2 +225,1 @@\n-                                  uint full_gc_count_before,\n-                                  GCCause::Cause gc_cause);\n+                                  uint full_gc_count_before);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  size_t new_count = AtomicAccess::add(&_refcount, count, memory_order_relaxed);\n+  size_t new_count = _refcount.add_then_fetch(count, memory_order_relaxed);\n@@ -95,1 +95,1 @@\n-  size_t refcount = AtomicAccess::sub(&state->_refcount, size_t(1), memory_order_release);\n+  size_t refcount = state->_refcount.sub_then_fetch(1u, memory_order_release);\n@@ -119,1 +119,1 @@\n-  uint idx = AtomicAccess::fetch_then_add(&_registered_allocators, 1u, memory_order_relaxed);\n+  uint idx = _registered_allocators.fetch_then_add(1u, memory_order_relaxed);\n@@ -126,2 +126,2 @@\n-  uint old = AtomicAccess::fetch_then_add(&_released_allocators, 1u, memory_order_relaxed);\n-  assert(old < AtomicAccess::load(&_registered_allocators), \"too many releases\");\n+  uint old = _released_allocators.fetch_then_add(1u, memory_order_relaxed);\n+  assert(old < _registered_allocators.load_relaxed(), \"too many releases\");\n@@ -132,2 +132,2 @@\n-  uint count = AtomicAccess::load(&_registered_allocators);\n-  assert(count == AtomicAccess::load(&_released_allocators),\n+  uint count = _registered_allocators.load_relaxed();\n+  assert(count == _released_allocators.load_relaxed(),\n@@ -138,2 +138,2 @@\n-  AtomicAccess::store(&_registered_allocators, 0u);\n-  DEBUG_ONLY(AtomicAccess::store(&_released_allocators, 0u);)\n+  _registered_allocators.store_relaxed(0u);\n+  DEBUG_ONLY(_released_allocators.store_relaxed(0u);)\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -63,2 +64,2 @@\n-  volatile size_t _index;\n-  volatile size_t _refcount;\n+  Atomic<size_t> _index;\n+  Atomic<size_t> _refcount;\n@@ -93,1 +94,1 @@\n-  volatile size_t* index_addr() { return &_index; }\n+  Atomic<size_t>* index_addr() { return &_index; }\n@@ -181,2 +182,2 @@\n-  volatile uint _registered_allocators;\n-  DEBUG_ONLY(volatile uint _released_allocators;)\n+  Atomic<uint> _registered_allocators;\n+  DEBUG_ONLY(Atomic<uint> _released_allocators;)\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -76,1 +77,1 @@\n-  inline Step next_impl(size_t length, volatile size_t* index_addr) const;\n+  inline Step next_impl(size_t length, Atomic<size_t>* index_addr) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-PartialArrayTaskStepper::next_impl(size_t length, volatile size_t* index_addr) const {\n+PartialArrayTaskStepper::next_impl(size_t length, Atomic<size_t>* index_addr) const {\n@@ -55,3 +55,1 @@\n-  size_t start = AtomicAccess::fetch_then_add(index_addr,\n-                                              _chunk_size,\n-                                              memory_order_relaxed);\n+  size_t start = index_addr->fetch_then_add(_chunk_size, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cppstdlib\/type_traits.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -31,1 +33,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -103,0 +106,41 @@\n+\/\/ Helper for TaskQueueSuper, encoding {queue index, tag} pair in a form that\n+\/\/ supports atomic access to the pair.\n+class TaskQueueAge {\n+  friend struct PrimitiveConversions::Translate<TaskQueueAge>;\n+\n+public:\n+  \/\/ Internal type used for indexing the queue, and for the tag.\n+  using idx_t = NOT_LP64(uint16_t) LP64_ONLY(uint32_t);\n+\n+  explicit TaskQueueAge(size_t data = 0) : _data{data} {}\n+  TaskQueueAge(idx_t top, idx_t tag) : _fields{top, tag} {}\n+\n+  idx_t top() const { return _fields._top; }\n+  idx_t tag() const { return _fields._tag; }\n+\n+  bool operator==(const TaskQueueAge& other) const { return _data == other._data; }\n+\n+private:\n+  struct Fields {\n+    idx_t _top;\n+    idx_t _tag;\n+  };\n+  union {\n+    size_t _data;    \/\/ Provides access to _fields as a single integral value.\n+    Fields _fields;\n+  };\n+  \/\/ _data must be able to hold combined _fields. Must be equal to ensure\n+  \/\/ there isn't any padding that could be uninitialized by 2-arg ctor.\n+  static_assert(sizeof(_data) == sizeof(_fields));\n+};\n+\n+\/\/ Support for Atomic<TaskQueueAge>.\n+template<>\n+struct PrimitiveConversions::Translate<TaskQueueAge> : public std::true_type {\n+  using Value = TaskQueueAge;\n+  using Decayed = decltype(TaskQueueAge::_data);\n+\n+  static Decayed decay(Value x) { return x._data; }\n+  static Value recover(Decayed x) { return Value(x); }\n+};\n+\n@@ -108,3 +152,3 @@\n-  \/\/ Internal type for indexing the queue; also used for the tag.\n-  typedef NOT_LP64(uint16_t) LP64_ONLY(uint32_t) idx_t;\n-  STATIC_ASSERT(N == idx_t(N)); \/\/ Ensure N fits in an idx_t.\n+  using Age = TaskQueueAge;\n+  using idx_t = Age::idx_t;\n+  static_assert(N == idx_t(N)); \/\/ Ensure N fits in an idx_t.\n@@ -114,2 +158,2 @@\n-  STATIC_ASSERT(N >= 2);\n-  STATIC_ASSERT(is_power_of_2(N));\n+  static_assert(N >= 2);\n+  static_assert(is_power_of_2(N));\n@@ -118,24 +162,0 @@\n-  class Age {\n-    friend class TaskQueueSuper;\n-\n-  public:\n-    explicit Age(size_t data = 0) : _data(data) {}\n-    Age(idx_t top, idx_t tag) { _fields._top = top; _fields._tag = tag; }\n-\n-    idx_t top() const { return _fields._top; }\n-    idx_t tag() const { return _fields._tag; }\n-\n-    bool operator ==(const Age& other) const { return _data == other._data; }\n-\n-  private:\n-    struct fields {\n-      idx_t _top;\n-      idx_t _tag;\n-    };\n-    union {\n-      size_t _data;\n-      fields _fields;\n-    };\n-    STATIC_ASSERT(sizeof(size_t) >= sizeof(fields));\n-  };\n-\n@@ -143,1 +163,1 @@\n-    return AtomicAccess::load(&_bottom);\n+    return _bottom.load_relaxed();\n@@ -147,1 +167,1 @@\n-    return AtomicAccess::load_acquire(&_bottom);\n+    return _bottom.load_acquire();\n@@ -151,1 +171,1 @@\n-    AtomicAccess::store(&_bottom, new_bottom);\n+    _bottom.store_relaxed(new_bottom);\n@@ -155,1 +175,1 @@\n-    AtomicAccess::release_store(&_bottom, new_bottom);\n+    _bottom.release_store(new_bottom);\n@@ -159,1 +179,1 @@\n-    return Age(AtomicAccess::load(&_age._data));\n+    return _age.load_relaxed();\n@@ -163,1 +183,1 @@\n-    AtomicAccess::store(&_age._data, new_age._data);\n+    _age.store_relaxed(new_age);\n@@ -167,1 +187,1 @@\n-    return Age(AtomicAccess::cmpxchg(&_age._data, old_age._data, new_age._data));\n+    return _age.compare_exchange(old_age, new_age);\n@@ -171,2 +191,1 @@\n-    \/\/ Atomically accessing a subfield of an \"atomic\" member.\n-    return AtomicAccess::load(&_age._fields._top);\n+    return _age.load_relaxed().top();\n@@ -225,2 +244,2 @@\n-  volatile uint _bottom;\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(uint));\n+  Atomic<uint> _bottom;\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(_bottom));\n@@ -233,2 +252,2 @@\n-  volatile Age _age;\n-  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(Age));\n+  Atomic<Age> _age;\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(_age));\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":62,"deletions":43,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -34,9 +34,31 @@\n-  enum Type {\n-    _alloc_shared,      \/\/ Allocate common, outside of TLAB\n-    _alloc_shared_gc,   \/\/ Allocate common, outside of GCLAB\/PLAB\n-    _alloc_cds,         \/\/ Allocate for CDS\n-    _alloc_tlab,        \/\/ Allocate TLAB\n-    _alloc_gclab,       \/\/ Allocate GCLAB\n-    _alloc_plab,        \/\/ Allocate PLAB\n-    _ALLOC_LIMIT\n-  };\n+  \/\/ Alloc type is an int value with encoded bits in scheme as:\n+  \/\/ [x|xx|xx|xx]\n+  \/\/          ^---- Requester:\n+  \/\/                  00 -- mutator\n+  \/\/                  10 -- mutator (CDS)\n+  \/\/                  01 -- GC\n+  \/\/       ^------- Purpose:\n+  \/\/                  00 -- shared\n+  \/\/                  01 -- TLAB\/GCLAB\n+  \/\/                  11 -- PLAB\n+  \/\/    ^---------- Affiliation:\n+  \/\/                  00 -- YOUNG\n+  \/\/                  01 -- OLD\n+  \/\/                  11 -- OLD, promotion\n+  typedef int Type;\n+\n+  static constexpr int bit_gc_alloc         = 1 << 0;\n+  static constexpr int bit_cds_alloc        = 1 << 1;\n+  static constexpr int bit_lab_alloc        = 1 << 2;\n+  static constexpr int bit_plab_alloc       = 1 << 3;\n+  static constexpr int bit_old_alloc        = 1 << 4;\n+  static constexpr int bit_promotion_alloc  = 1 << 5;\n+\n+  static constexpr Type _alloc_shared              = 0;\n+  static constexpr Type _alloc_tlab                = bit_lab_alloc;\n+  static constexpr Type _alloc_cds                 = bit_cds_alloc;\n+  static constexpr Type _alloc_shared_gc           = bit_gc_alloc;\n+  static constexpr Type _alloc_shared_gc_old       = bit_gc_alloc | bit_old_alloc;\n+  static constexpr Type _alloc_shared_gc_promotion = bit_gc_alloc | bit_old_alloc | bit_promotion_alloc;\n+  static constexpr Type _alloc_gclab               = bit_gc_alloc | bit_lab_alloc;\n+  static constexpr Type _alloc_plab                = bit_gc_alloc | bit_lab_alloc | bit_plab_alloc | bit_old_alloc;\n@@ -50,0 +72,4 @@\n+      case _alloc_shared_gc_old:\n+        return \"Shared GC Old\";\n+      case _alloc_shared_gc_promotion:\n+        return \"Shared GC Promotion\";\n@@ -83,6 +109,0 @@\n-  \/\/ This is the generation which the request is targeting.\n-  ShenandoahAffiliation const _affiliation;\n-\n-  \/\/ True if this request is trying to copy any object from young to old (promote).\n-  bool _is_promotion;\n-\n@@ -94,1 +114,1 @@\n-  ShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type, ShenandoahAffiliation affiliation, bool is_promotion = false) :\n+  ShenandoahAllocRequest(size_t _min_size, size_t _requested_size, Type _alloc_type) :\n@@ -96,1 +116,1 @@\n-          _actual_size(0), _waste(0), _alloc_type(_alloc_type), _affiliation(affiliation), _is_promotion(is_promotion)\n+          _actual_size(0), _waste(0), _alloc_type(_alloc_type)\n@@ -104,1 +124,1 @@\n-    return ShenandoahAllocRequest(min_size, requested_size, _alloc_tlab, ShenandoahAffiliation::YOUNG_GENERATION);\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_tlab);\n@@ -108,1 +128,1 @@\n-    return ShenandoahAllocRequest(min_size, requested_size, _alloc_gclab, ShenandoahAffiliation::YOUNG_GENERATION);\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_gclab);\n@@ -112,1 +132,1 @@\n-    return ShenandoahAllocRequest(min_size, requested_size, _alloc_plab, ShenandoahAffiliation::OLD_GENERATION);\n+    return ShenandoahAllocRequest(min_size, requested_size, _alloc_plab);\n@@ -117,2 +137,2 @@\n-      assert(affiliation == ShenandoahAffiliation::OLD_GENERATION, \"Should only promote to old generation\");\n-      return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc, affiliation, true);\n+      assert(affiliation == OLD_GENERATION, \"Should only promote to old generation\");\n+      return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc_promotion);\n@@ -120,1 +140,4 @@\n-    return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc, affiliation);\n+    if (affiliation == OLD_GENERATION) {\n+      return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc_old);\n+    }\n+    return ShenandoahAllocRequest(0, requested_size, _alloc_shared_gc);\n@@ -124,1 +147,1 @@\n-    return ShenandoahAllocRequest(0, requested_size, _alloc_shared, ShenandoahAffiliation::YOUNG_GENERATION);\n+    return ShenandoahAllocRequest(0, requested_size, _alloc_shared);\n@@ -128,1 +151,1 @@\n-    return ShenandoahAllocRequest(0, requested_size, _alloc_cds, ShenandoahAffiliation::YOUNG_GENERATION);\n+    return ShenandoahAllocRequest(0, requested_size, _alloc_cds);\n@@ -170,13 +193,1 @@\n-    switch (_alloc_type) {\n-      case _alloc_tlab:\n-      case _alloc_shared:\n-      case _alloc_cds:\n-        return true;\n-      case _alloc_gclab:\n-      case _alloc_plab:\n-      case _alloc_shared_gc:\n-        return false;\n-      default:\n-        ShouldNotReachHere();\n-        return false;\n-    }\n+    return (_alloc_type & bit_gc_alloc) == 0;\n@@ -186,13 +197,1 @@\n-    switch (_alloc_type) {\n-      case _alloc_tlab:\n-      case _alloc_shared:\n-      case _alloc_cds:\n-        return false;\n-      case _alloc_gclab:\n-      case _alloc_plab:\n-      case _alloc_shared_gc:\n-        return true;\n-      default:\n-        ShouldNotReachHere();\n-        return false;\n-    }\n+    return (_alloc_type & bit_gc_alloc) != 0;\n@@ -202,13 +201,1 @@\n-    switch (_alloc_type) {\n-      case _alloc_tlab:\n-      case _alloc_gclab:\n-      case _alloc_plab:\n-        return true;\n-      case _alloc_shared:\n-      case _alloc_shared_gc:\n-      case _alloc_cds:\n-        return false;\n-      default:\n-        ShouldNotReachHere();\n-        return false;\n-    }\n+    return (_alloc_type & bit_lab_alloc) != 0;\n@@ -217,2 +204,2 @@\n-  bool is_old() const {\n-    return _affiliation == OLD_GENERATION;\n+  inline bool is_old() const {\n+    return (_alloc_type & bit_old_alloc) != 0;\n@@ -221,2 +208,2 @@\n-  bool is_young() const {\n-    return _affiliation == YOUNG_GENERATION;\n+  inline bool is_young() const {\n+    return (_alloc_type & bit_old_alloc) == 0;\n@@ -225,2 +212,2 @@\n-  ShenandoahAffiliation affiliation() const {\n-    return _affiliation;\n+  inline ShenandoahAffiliation affiliation() const {\n+    return (_alloc_type & bit_old_alloc) == 0 ? YOUNG_GENERATION : OLD_GENERATION ;\n@@ -230,1 +217,1 @@\n-    return shenandoah_affiliation_name(_affiliation);\n+    return shenandoah_affiliation_name(affiliation());\n@@ -233,2 +220,2 @@\n-  bool is_promotion() const {\n-    return _is_promotion;\n+  inline bool is_promotion() const {\n+    return (_alloc_type & bit_promotion_alloc) != 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAllocRequest.hpp","additions":60,"deletions":73,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -208,1 +209,1 @@\n-  size_t align = ShenandoahMaxRegionSize;\n+  size_t align = next_power_of_2(ShenandoahMaxRegionSize);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-  inline void arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking);\n+  inline void arraycopy_marking(T* dst, size_t count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,4 +391,2 @@\n-  \/\/ may have forwarded objects. In this case, the `arraycopy_work` is first called with HAS_FWD=true and\n-  \/\/ ENQUEUE=false.\n-  assert(HAS_FWD == _heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(),\n-         \"Forwarded object status is sane\");\n+  \/\/ may have forwarded objects.\n+  assert(HAS_FWD == _heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded object status is sane\");\n@@ -397,1 +395,1 @@\n-  assert((HAS_FWD || EVAC) != ENQUEUE, \"Cannot evacuate and mark both sides of copy.\");\n+  static_assert((HAS_FWD || EVAC) != ENQUEUE, \"Cannot evacuate and mark both sides of copy.\");\n@@ -416,1 +414,1 @@\n-      if (ENQUEUE && !ctx->is_marked_strong_or_old(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n@@ -430,1 +428,8 @@\n-  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n+  const char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n+  if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n+    \/\/ If marking old or young, we must evaluate the SATB barrier. This will be the only\n+    \/\/ action if we are not marking old. If we are marking old, we must still evaluate the\n+    \/\/ load reference barrier for a young collection.\n+    arraycopy_marking(dst, count);\n+  }\n+\n@@ -432,0 +437,1 @@\n+    assert((gc_state & ShenandoahHeap::YOUNG_MARKING) == 0, \"Cannot be marking young during evacuation\");\n@@ -434,0 +440,1 @@\n+    assert((gc_state & ShenandoahHeap::YOUNG_MARKING) == 0, \"Cannot be marking young during update-refs\");\n@@ -436,12 +443,0 @@\n-\n-  if (_heap->mode()->is_generational()) {\n-    assert(ShenandoahSATBBarrier, \"Generational mode assumes SATB mode\");\n-    if ((gc_state & ShenandoahHeap::YOUNG_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, false);\n-    }\n-    if ((gc_state & ShenandoahHeap::OLD_MARKING) != 0) {\n-      arraycopy_marking(src, dst, count, true);\n-    }\n-  } else if ((gc_state & ShenandoahHeap::MARKING) != 0) {\n-    arraycopy_marking(src, dst, count, false);\n-  }\n@@ -451,1 +446,1 @@\n-void ShenandoahBarrierSet::arraycopy_marking(T* src, T* dst, size_t count, bool is_old_marking) {\n+void ShenandoahBarrierSet::arraycopy_marking(T* dst, size_t count) {\n@@ -453,21 +448,0 @@\n-  \/*\n-   * Note that an old-gen object is considered live if it is live at the start of OLD marking or if it is promoted\n-   * following the start of OLD marking.\n-   *\n-   * 1. Every object promoted following the start of OLD marking will be above TAMS within its old-gen region\n-   * 2. Every object live at the start of OLD marking will be referenced from a \"root\" or it will be referenced from\n-   *    another live OLD-gen object.  With regards to old-gen, roots include stack locations and all of live young-gen.\n-   *    All root references to old-gen are identified during a bootstrap young collection.  All references from other\n-   *    old-gen objects will be marked during the traversal of all old objects, or will be marked by the SATB barrier.\n-   *\n-   * During old-gen marking (which is interleaved with young-gen collections), call arraycopy_work() if:\n-   *\n-   * 1. The overwritten array resides in old-gen and it is below TAMS within its old-gen region\n-   * 2. Do not call arraycopy_work for any array residing in young-gen because young-gen collection is idle at this time\n-   *\n-   * During young-gen marking, call arraycopy_work() if:\n-   *\n-   * 1. The overwritten array resides in young-gen and is below TAMS within its young-gen region\n-   * 2. Additionally, if array resides in old-gen, regardless of its relationship to TAMS because this old-gen array\n-   *    may hold references to young-gen\n-   *\/\n@@ -475,17 +449,2 @@\n-    T* array = dst;\n-    HeapWord* array_addr = reinterpret_cast<HeapWord*>(array);\n-    ShenandoahHeapRegion* r = _heap->heap_region_containing(array_addr);\n-    if (is_old_marking) {\n-      \/\/ Generational, old marking\n-      assert(_heap->mode()->is_generational(), \"Invariant\");\n-      if (r->is_old() && (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (_heap->mode()->is_generational()) {\n-      \/\/ Generational, young marking\n-      if (r->is_old() || (array_addr < _heap->marking_context()->top_at_mark_start(r))) {\n-        arraycopy_work<T, false, false, true>(array, count);\n-      }\n-    } else if (array_addr < _heap->marking_context()->top_at_mark_start(r)) {\n-      \/\/ Non-generational, marking\n-      arraycopy_work<T, false, false, true>(array, count);\n+    if (!_heap->marking_context()->allocated_after_mark_start(reinterpret_cast<HeapWord*>(dst))) {\n+      arraycopy_work<T, false, false, true>(dst, count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":17,"deletions":58,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -1314,11 +1314,4 @@\n-  switch (req.type()) {\n-    case ShenandoahAllocRequest::_alloc_tlab:\n-    case ShenandoahAllocRequest::_alloc_shared:\n-    case ShenandoahAllocRequest::_alloc_cds:\n-      return allocate_for_mutator(req, in_new_region);\n-    case ShenandoahAllocRequest::_alloc_gclab:\n-    case ShenandoahAllocRequest::_alloc_plab:\n-    case ShenandoahAllocRequest::_alloc_shared_gc:\n-      return allocate_for_collector(req, in_new_region);\n-    default:\n-      ShouldNotReachHere();\n+  if (req.is_mutator_alloc()) {\n+    return allocate_for_mutator(req, in_new_region);\n+  } else {\n+    return allocate_for_collector(req, in_new_region);\n@@ -1326,1 +1319,0 @@\n-  return nullptr;\n@@ -1622,4 +1614,1 @@\n-  } else if (req.type() == ShenandoahAllocRequest::_alloc_gclab) {\n-    request_generation = _heap->mode()->is_generational()? _heap->young_generation(): _heap->global_generation();\n-    orig_partition = ShenandoahFreeSetPartitionId::Collector;\n-  } else if (req.type() == ShenandoahAllocRequest::_alloc_plab) {\n+  } else if (req.is_old()) {\n@@ -1629,8 +1618,3 @@\n-    assert(req.type() == ShenandoahAllocRequest::_alloc_shared_gc, \"Unexpected allocation type\");\n-    if (req.is_old()) {\n-      request_generation = _heap->old_generation();\n-      orig_partition = ShenandoahFreeSetPartitionId::OldCollector;\n-    } else {\n-      request_generation = _heap->mode()->is_generational()? _heap->young_generation(): _heap->global_generation();\n-      orig_partition = ShenandoahFreeSetPartitionId::Collector;\n-    }\n+    \/\/ Not old collector alloc, so this is a young collector gclab or shared allocation\n+    request_generation = _heap->mode()->is_generational()? _heap->young_generation(): _heap->global_generation();\n+    orig_partition = ShenandoahFreeSetPartitionId::Collector;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -132,0 +132,2 @@\n+    case ShenandoahAllocRequest::_alloc_shared_gc_old:\n+    case ShenandoahAllocRequest::_alloc_shared_gc_promotion:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,0 +253,2 @@\n+  \/\/ Since end_range_of_interest may not align on a card boundary, last_relevant_card_index is conservative.  Not all of the\n+  \/\/ memory within the last relevant card's span is < right.\n@@ -355,3 +357,2 @@\n-        assert(_rs->addr_for_card_index(following_card_index) + get_first_start(following_card_index),\n-               \"Result must precede right\");\n-        return _rs->addr_for_card_index(following_card_index) + get_first_start(following_card_index);\n+        HeapWord* result_candidate = _rs->addr_for_card_index(following_card_index) + get_first_start(following_card_index);\n+        return (result_candidate >= right)? nullptr: result_candidate;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -89,4 +89,0 @@\n-    if (ptr == zpointer::null) {\n-      assert(!ZVerifyOops || !ZHeap::heap()->is_in(uintptr_t(p)) || !ZHeap::heap()->is_old(p), \"No raw null in old\");\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-    return;\n@@ -228,19 +227,0 @@\n-\n-  if (!ZGeneration::young()->is_phase_mark_complete()) {\n-    return;\n-  }\n-\n-  if (!page->is_relocatable()) {\n-    return;\n-  }\n-\n-  if (ZRelocate::compute_to_age(age) != ZPageAge::old) {\n-    return;\n-  }\n-\n-  \/\/ If the object is young, we have to still be careful that it isn't racingly\n-  \/\/ about to get promoted to the old generation. That causes issues when null\n-  \/\/ pointers are supposed to be coloured, but the JIT is a bit sloppy and\n-  \/\/ reinitializes memory with raw nulls. We detect this situation and detune\n-  \/\/ rather than relying on the JIT to never be sloppy with redundant initialization.\n-  deoptimize_allocation(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -114,0 +114,10 @@\n+class ZRendezvousHandshakeClosure : public HandshakeClosure {\n+public:\n+  ZRendezvousHandshakeClosure()\n+    : HandshakeClosure(\"ZRendezvous\") {}\n+\n+  void do_thread(Thread* thread) {\n+    \/\/ Does nothing\n+  }\n+};\n+\n@@ -171,5 +181,13 @@\n-  if (is_young()) {\n-    _relocate.flip_age_pages(selector->not_selected_small());\n-    _relocate.flip_age_pages(selector->not_selected_medium());\n-    _relocate.flip_age_pages(selector->not_selected_large());\n-  }\n+  _relocate.flip_age_pages(selector->not_selected_small());\n+  _relocate.flip_age_pages(selector->not_selected_medium());\n+  _relocate.flip_age_pages(selector->not_selected_large());\n+\n+  \/\/ Perform a handshake between flip promotion and running the promotion barrier. This ensures\n+  \/\/ that ZBarrierSet::on_slowpath_allocation_exit() observing a young page that was then racingly\n+  \/\/ flip promoted, will run any stores without barriers to completion before responding to the\n+  \/\/ handshake at the subsequent safepoint poll. This ensures that the flip promotion barriers always\n+  \/\/ run after compiled code missing barriers, but before relocate start.\n+  ZRendezvousHandshakeClosure cl;\n+  Handshake::execute(&cl);\n+\n+  _relocate.barrier_flip_promoted_pages(_relocation_set.flip_promoted_pages());\n@@ -238,1 +256,3 @@\n-  flip_age_pages(&selector);\n+  if (is_young()) {\n+    flip_age_pages(&selector);\n+  }\n@@ -1283,10 +1303,0 @@\n-class ZRendezvousHandshakeClosure : public HandshakeClosure {\n-public:\n-  ZRendezvousHandshakeClosure()\n-    : HandshakeClosure(\"ZRendezvous\") {}\n-\n-  void do_thread(Thread* thread) {\n-    \/\/ Does nothing\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1325,1 +1325,1 @@\n-    : ZTask(\"ZPromotePagesTask\"),\n+    : ZTask(\"ZFlipAgePagesTask\"),\n@@ -1340,10 +1340,0 @@\n-      if (promotion) {\n-        \/\/ Before promoting an object (and before relocate start), we must ensure that all\n-        \/\/ contained zpointers are store good. The marking code ensures that for non-null\n-        \/\/ pointers, but null pointers are ignored. This code ensures that even null pointers\n-        \/\/ are made store good, for the promoted objects.\n-        prev_page->object_iterate([&](oop obj) {\n-          ZIterator::basic_oop_iterate_safe(obj, ZBarrier::promote_barrier_on_young_oop_field);\n-        });\n-      }\n-\n@@ -1363,1 +1353,1 @@\n-        \/\/ Defer promoted page registration times the lock is taken\n+        \/\/ Defer promoted page registration\n@@ -1374,0 +1364,26 @@\n+class ZPromoteBarrierTask : public ZTask {\n+private:\n+  ZArrayParallelIterator<ZPage*> _iter;\n+\n+public:\n+  ZPromoteBarrierTask(const ZArray<ZPage*>* pages)\n+    : ZTask(\"ZPromoteBarrierTask\"),\n+      _iter(pages) {}\n+\n+  virtual void work() {\n+    SuspendibleThreadSetJoiner sts_joiner;\n+\n+    for (ZPage* page; _iter.next(&page);) {\n+      \/\/ When promoting an object (and before relocate start), we must ensure that all\n+      \/\/ contained zpointers are store good. The marking code ensures that for non-null\n+      \/\/ pointers, but null pointers are ignored. This code ensures that even null pointers\n+      \/\/ are made store good, for the promoted objects.\n+      page->object_iterate([&](oop obj) {\n+        ZIterator::basic_oop_iterate_safe(obj, ZBarrier::promote_barrier_on_young_oop_field);\n+      });\n+\n+      SuspendibleThreadSet::yield();\n+    }\n+  }\n+};\n+\n@@ -1379,0 +1395,5 @@\n+void ZRelocate::barrier_flip_promoted_pages(const ZArray<ZPage*>* pages) {\n+  ZPromoteBarrierTask promote_barrier_task(pages);\n+  workers()->run(&promote_barrier_task);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  void barrier_flip_promoted_pages(const ZArray<ZPage*>* pages);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-            top_frame = frame(synthetic_sp, synthetic_sp, sender_sp, pc_desc->real_pc(sampled_nm), sampled_nm);\n+            top_frame = frame(synthetic_sp, synthetic_sp, sender_sp - 2, pc_desc->real_pc(sampled_nm), sampled_nm);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,0 @@\n-volatile bool   Universe::_is_shutting_down = false;\n@@ -1405,7 +1404,5 @@\n-  {\n-    \/\/ Acquire the Heap_lock to synchronize with VM_Heap_Sync_Operations,\n-    \/\/ which may depend on the value of _is_shutting_down flag.\n-    MutexLocker hl(Heap_lock);\n-    log_cpu_time();\n-    AtomicAccess::release_store(&_is_shutting_down, true);\n-  }\n+  \/\/ Tell the GC that it is time to shutdown and to block requests for new GC pauses.\n+  heap()->initiate_shutdown();\n+\n+  \/\/ Log CPU time statistics before stopping the GC threads.\n+  log_cpu_time();\n@@ -1413,1 +1410,2 @@\n-  heap()->before_exit();\n+  \/\/ Stop the GC threads.\n+  heap()->stop();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -131,3 +131,0 @@\n-  \/\/ Shutdown\n-  static volatile bool _is_shutting_down;\n-\n@@ -336,2 +333,0 @@\n-  static bool is_shutting_down()                  { return  AtomicAccess::load_acquire(&_is_shutting_down); }\n-\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_BSMATTRIBUTE_HPP\n+#define SHARE_OOPS_BSMATTRIBUTE_HPP\n+\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ClassLoaderData;\n+\n+class BSMAttributeEntry {\n+  friend class ConstantPool;\n+  friend class BSMAttributeEntries;\n+\n+  u2 _bootstrap_method_index;\n+  u2 _argument_count;\n+\n+  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n+  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n+  \/\/ So in order to find the argument array, jump over ourselves.\n+  const u2* argument_indexes() const {\n+    return reinterpret_cast<const u2*>(this + 1);\n+  }\n+  u2* argument_indexes() {\n+    return reinterpret_cast<u2*>(this + 1);\n+  }\n+  \/\/ These are overlays on top of the BSMAttributeEntries data array, do not construct.\n+  BSMAttributeEntry() = delete;\n+  NONCOPYABLE(BSMAttributeEntry);\n+\n+  void copy_args_into(BSMAttributeEntry* entry) const;\n+\n+public:\n+  \/\/ Offsets for SA\n+  enum {\n+    _bsmi_offset = 0,\n+    _argc_offset = 1,\n+    _argv_offset = 2\n+  };\n+\n+  int bootstrap_method_index() const {\n+    return _bootstrap_method_index;\n+  }\n+  int argument_count() const {\n+    return _argument_count;\n+  }\n+  int argument(int n) const {\n+    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n+    return argument_indexes()[n];\n+  }\n+\n+  void set_argument(int index, u2 value) {\n+    assert(index >= 0 && index < argument_count(), \"invariant\");\n+    argument_indexes()[index] = value;\n+  }\n+\n+  \/\/ How many u2s are required to store a BSM entry with argc arguments?\n+  static int u2s_required (u2 argc) {\n+    return 1 \/* index *\/ + 1  \/* argc *\/ + argc \/* argv *\/;\n+  }\n+};\n+\n+\/\/ The BSMAttributeEntries stores the state of the BootstrapMethods attribute.\n+class BSMAttributeEntries {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+public:\n+  class InsertionIterator {\n+    friend BSMAttributeEntries;\n+    BSMAttributeEntries* _insert_into;\n+    \/\/ Current unused offset into BSMAEs offset array.\n+    int _cur_offset;\n+    \/\/ Current unused offset into BSMAEs bsm-data array.\n+    int _cur_array;\n+  public:\n+    InsertionIterator() : _insert_into(nullptr), _cur_offset(-1), _cur_array(-1) {}\n+    InsertionIterator(BSMAttributeEntries* insert_into, int cur_offset, int cur_array)\n+    : _insert_into(insert_into),\n+      _cur_offset(cur_offset),\n+      _cur_array(cur_array) {}\n+    InsertionIterator(const InsertionIterator&) = default;\n+    InsertionIterator& operator=(const InsertionIterator&) = default;\n+\n+    int current_offset() const { return _cur_offset; }\n+    \/\/ Add a new BSMAE, reserving the necessary memory for filling the argument vector.\n+    \/\/ Returns null if there isn't enough space.\n+    inline BSMAttributeEntry* reserve_new_entry(u2 bsmi, u2 argc);\n+  };\n+\n+private:\n+  \/\/ Each bootstrap method has a variable-sized array associated with it.\n+  \/\/ We want constant-time lookup of the Nth BSM. Therefore, we use an offset table,\n+  \/\/ such that the Nth BSM is located at _bootstrap_methods[_offsets[N]].\n+  Array<u4>* _offsets;\n+  Array<u2>* _bootstrap_methods;\n+\n+  \/\/ Copy the first num_entries into iter.\n+  void copy_into(InsertionIterator& iter, int num_entries) const;\n+\n+public:\n+  BSMAttributeEntries() : _offsets(nullptr), _bootstrap_methods(nullptr) {}\n+  BSMAttributeEntries(Array<u4>* offsets, Array<u2>* bootstrap_methods)\n+    : _offsets(offsets),\n+      _bootstrap_methods(bootstrap_methods) {}\n+\n+  bool is_empty() const {\n+    return _offsets == nullptr && _bootstrap_methods == nullptr;\n+  }\n+\n+  Array<u4>*& offsets() { return _offsets; }\n+  const Array<u4>* const& offsets() const { return _offsets; }\n+  Array<u2>*& bootstrap_methods() { return _bootstrap_methods; }\n+  const Array<u2>* const& bootstrap_methods() const { return _bootstrap_methods; }\n+\n+  BSMAttributeEntry* entry(int bsms_attribute_index) {\n+    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n+  }\n+  const BSMAttributeEntry* entry(int bsms_attribute_index) const {\n+    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n+  }\n+\n+  int number_of_entries() const {\n+    return _offsets == nullptr ? 0 : _offsets->length();\n+  }\n+\n+  \/\/ The number of U2s the BSM data consists of.\n+  int array_length() const {\n+    return _bootstrap_methods == nullptr ? 0 :  _bootstrap_methods->length();\n+  }\n+\n+  void deallocate_contents(ClassLoaderData* loader_data);\n+\n+  \/\/ Extend to have the space for both this BSMAEntries and other's.\n+  \/\/ Does not copy in the other's BSMAEntrys, that must be done via the InsertionIterator.\n+  \/\/ This starts an insertion iterator. Any call to start_extension must have a matching end_extension call.\n+  InsertionIterator start_extension(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Extend the BSMAEntries with an additional number_of_entries with a total data_size.\n+  InsertionIterator start_extension(int number_of_entries, int data_size, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Reallocates the underlying memory to fit the limits of the InsertionIterator precisely.\n+  \/\/ This ends an insertion iteration. The memory is truncated to fit exactly the data used.\n+  void end_extension(InsertionIterator& iter, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Append all of the BSMAEs in other into this.\n+  void append(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n+};\n+\n+#endif \/\/ SHARE_OOPS_BSMATTRIBUTE_HPP\n","filename":"src\/hotspot\/share\/oops\/bsmAttribute.hpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n+#define SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n+\n+#include \"oops\/bsmAttribute.hpp\"\n+\n+inline BSMAttributeEntry* BSMAttributeEntries::InsertionIterator::reserve_new_entry(u2 bsmi, u2 argc) {\n+  assert(_insert_into->offsets() != nullptr, \"must\");\n+  assert(_insert_into->bootstrap_methods() != nullptr, \"must\");\n+\n+  if (_cur_offset + 1 > _insert_into->offsets()->length() ||\n+      _cur_array + BSMAttributeEntry::u2s_required(argc) > _insert_into->bootstrap_methods()->length()) {\n+    return nullptr;\n+  }\n+  _insert_into->offsets()->at_put(_cur_offset, _cur_array);\n+  BSMAttributeEntry* e = _insert_into->entry(_cur_offset);\n+  e->_bootstrap_method_index = bsmi;\n+  e->_argument_count = argc;\n+\n+  _cur_array += 1 + 1 + argc;\n+  _cur_offset += 1;\n+  return e;\n+}\n+\n+inline void BSMAttributeEntry::copy_args_into(BSMAttributeEntry* entry) const {\n+  assert(entry->argument_count() == this->argument_count(), \"must be same\");\n+  for (int i = 0; i < argument_count(); i++) {\n+    entry->set_argument(i, this->argument(i));\n+  }\n+}\n+\n+#endif \/\/ SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/bsmAttribute.inline.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -136,2 +136,1 @@\n-  MetadataFactory::free_array<jushort>(loader_data, operands());\n-  set_operands(nullptr);\n+  bsm_entries().deallocate_contents(loader_data);\n@@ -157,1 +156,2 @@\n-  it->push(&_operands);\n+  it->push(&bsm_entries().offsets());\n+  it->push(&bsm_entries().bootstrap_methods());\n@@ -793,1 +793,1 @@\n-    log_debug(class, resolve)(\"bad operand %d in:\", which); cpool->print();\n+    log_debug(class, resolve)(\"bad BSM %d in:\", which); cpool->print();\n@@ -1594,2 +1594,2 @@\n-    bool match_operand = compare_operand_to(i1, cp2, i2);\n-    return (match_entry && match_operand);\n+    bool match_bsm = compare_bootstrap_entry_to(i1, cp2, i2);\n+    return (match_entry && match_bsm);\n@@ -1605,2 +1605,2 @@\n-    bool match_operand = compare_operand_to(i1, cp2, i2);\n-    return (match_entry && match_operand);\n+    bool match_bsm = compare_bootstrap_entry_to(i1, cp2, i2);\n+    return (match_entry && match_bsm);\n@@ -1640,34 +1640,1 @@\n-\n-\/\/ Resize the operands array with delta_len and delta_size.\n-\/\/ Used in RedefineClasses for CP merge.\n-void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {\n-  int old_len  = operand_array_length(operands());\n-  int new_len  = old_len + delta_len;\n-  int min_len  = (delta_len > 0) ? old_len : new_len;\n-\n-  int old_size = operands()->length();\n-  int new_size = old_size + delta_size;\n-  int min_size = (delta_size > 0) ? old_size : new_size;\n-\n-  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-  Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, new_size, CHECK);\n-\n-  \/\/ Set index in the resized array for existing elements only\n-  for (int idx = 0; idx < min_len; idx++) {\n-    int offset = operand_offset_at(idx);                       \/\/ offset in original array\n-    operand_offset_at_put(new_ops, idx, offset + 2*delta_len); \/\/ offset in resized array\n-  }\n-  \/\/ Copy the bootstrap specifiers only\n-  Copy::conjoint_memory_atomic(operands()->adr_at(2*old_len),\n-                               new_ops->adr_at(2*new_len),\n-                               (min_size - 2*min_len) * sizeof(u2));\n-  \/\/ Explicitly deallocate old operands array.\n-  \/\/ Note, it is not needed for 7u backport.\n-  if ( operands() != nullptr) { \/\/ the safety check\n-    MetadataFactory::free_array<u2>(loader_data, operands());\n-  }\n-  set_operands(new_ops);\n-} \/\/ end resize_operands()\n-\n-\n-\/\/ Extend the operands array with the length and size of the ext_cp operands.\n+\/\/ Extend the BSMAttributeEntries with the length and size of the ext_cp BSMAttributeEntries.\n@@ -1675,18 +1642,7 @@\n-void ConstantPool::extend_operands(const constantPoolHandle& ext_cp, TRAPS) {\n-  int delta_len = operand_array_length(ext_cp->operands());\n-  if (delta_len == 0) {\n-    return; \/\/ nothing to do\n-  }\n-  int delta_size = ext_cp->operands()->length();\n-\n-  assert(delta_len  > 0 && delta_size > 0, \"extended operands array must be bigger\");\n-\n-  if (operand_array_length(operands()) == 0) {\n-    ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-    Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, delta_size, CHECK);\n-    \/\/ The first element index defines the offset of second part\n-    operand_offset_at_put(new_ops, 0, 2*delta_len); \/\/ offset in new array\n-    set_operands(new_ops);\n-  } else {\n-    resize_operands(delta_len, delta_size, CHECK);\n-  }\n+BSMAttributeEntries::InsertionIterator\n+ConstantPool::start_extension(const constantPoolHandle& ext_cp, TRAPS) {\n+  BSMAttributeEntries::InsertionIterator iter =\n+    bsm_entries().start_extension(ext_cp->bsm_entries(), pool_holder()->class_loader_data(),\n+                                  CHECK_(BSMAttributeEntries::InsertionIterator()));\n+  return iter;\n+}\n@@ -1694,1 +1650,0 @@\n-} \/\/ end extend_operands()\n@@ -1696,0 +1651,3 @@\n+void ConstantPool::end_extension(BSMAttributeEntries::InsertionIterator iter, TRAPS) {\n+  bsm_entries().end_extension(iter, pool_holder()->class_loader_data(), THREAD);\n+}\n@@ -1697,71 +1655,0 @@\n-\/\/ Shrink the operands array to a smaller array with new_len length.\n-\/\/ Used in RedefineClasses for CP merge.\n-void ConstantPool::shrink_operands(int new_len, TRAPS) {\n-  int old_len = operand_array_length(operands());\n-  if (new_len == old_len) {\n-    return; \/\/ nothing to do\n-  }\n-  assert(new_len < old_len, \"shrunken operands array must be smaller\");\n-\n-  int free_base  = operand_next_offset_at(new_len - 1);\n-  int delta_len  = new_len - old_len;\n-  int delta_size = 2*delta_len + free_base - operands()->length();\n-\n-  resize_operands(delta_len, delta_size, CHECK);\n-\n-} \/\/ end shrink_operands()\n-\n-\n-void ConstantPool::copy_operands(const constantPoolHandle& from_cp,\n-                                 const constantPoolHandle& to_cp,\n-                                 TRAPS) {\n-\n-  int from_oplen = operand_array_length(from_cp->operands());\n-  int old_oplen  = operand_array_length(to_cp->operands());\n-  if (from_oplen != 0) {\n-    ClassLoaderData* loader_data = to_cp->pool_holder()->class_loader_data();\n-    \/\/ append my operands to the target's operands array\n-    if (old_oplen == 0) {\n-      \/\/ Can't just reuse from_cp's operand list because of deallocation issues\n-      int len = from_cp->operands()->length();\n-      Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, len, CHECK);\n-      Copy::conjoint_memory_atomic(\n-          from_cp->operands()->adr_at(0), new_ops->adr_at(0), len * sizeof(u2));\n-      to_cp->set_operands(new_ops);\n-    } else {\n-      int old_len  = to_cp->operands()->length();\n-      int from_len = from_cp->operands()->length();\n-      int old_off  = old_oplen * sizeof(u2);\n-      int from_off = from_oplen * sizeof(u2);\n-      \/\/ Use the metaspace for the destination constant pool\n-      Array<u2>* new_operands = MetadataFactory::new_array<u2>(loader_data, old_len + from_len, CHECK);\n-      int fillp = 0, len = 0;\n-      \/\/ first part of dest\n-      Copy::conjoint_memory_atomic(to_cp->operands()->adr_at(0),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = old_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ first part of src\n-      Copy::conjoint_memory_atomic(from_cp->operands()->adr_at(0),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = from_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ second part of dest\n-      Copy::conjoint_memory_atomic(to_cp->operands()->adr_at(old_off),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = old_len - old_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ second part of src\n-      Copy::conjoint_memory_atomic(from_cp->operands()->adr_at(from_off),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = from_len - from_off) * sizeof(u2));\n-      fillp += len;\n-      assert(fillp == new_operands->length(), \"\");\n-\n-      \/\/ Adjust indexes in the first part of the copied operands array.\n-      for (int j = 0; j < from_oplen; j++) {\n-        int offset = operand_offset_at(new_operands, old_oplen + j);\n-        assert(offset == operand_offset_at(from_cp->operands(), j), \"correct copy\");\n-        offset += old_len;  \/\/ every new tuple is preceded by old_len extra u2's\n-        operand_offset_at_put(new_operands, old_oplen + j, offset);\n-      }\n@@ -1769,5 +1656,7 @@\n-      \/\/ replace target operands array with combined array\n-      to_cp->set_operands(new_operands);\n-    }\n-  }\n-} \/\/ end copy_operands()\n+void ConstantPool::copy_bsm_entries(const constantPoolHandle& from_cp,\n+                                    const constantPoolHandle& to_cp,\n+                                    TRAPS) {\n+  to_cp->bsm_entries().append(from_cp->bsm_entries(),\n+                              to_cp->pool_holder()->class_loader_data(),\n+                              THREAD);\n+}\n@@ -1803,1 +1692,1 @@\n-  copy_operands(from_cp, to_cp, CHECK);\n+  copy_bsm_entries(from_cp, to_cp, THREAD);\n@@ -1927,1 +1816,1 @@\n-    k1 += operand_array_length(to_cp->operands());  \/\/ to_cp might already have operands\n+    k1 += to_cp->bsm_entries().array_length();  \/\/ to_cp might already have a BSM attribute\n@@ -1935,1 +1824,1 @@\n-    k1 += operand_array_length(to_cp->operands());  \/\/ to_cp might already have operands\n+    k1 += to_cp->bsm_entries().array_length();  \/\/ to_cp might already have a BSM attribute\n@@ -1971,3 +1860,3 @@\n-bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle& cp2, int idx2) {\n-  BSMAttributeEntry* e1 = bsm_attribute_entry(idx1);\n-  BSMAttributeEntry* e2 = cp2->bsm_attribute_entry(idx2);\n+bool ConstantPool::compare_bootstrap_entry_to(int idx1, const constantPoolHandle& cp2, int idx2) {\n+  const BSMAttributeEntry* const e1 = bsm_attribute_entry(idx1);\n+  const BSMAttributeEntry* const e2 = cp2->bsm_attribute_entry(idx2);\n@@ -1981,9 +1870,12 @@\n-  int argc = e1->argument_count();\n-  if (argc == e2->argument_count()) {\n-    for (int j = 0; j < argc; j++) {\n-      k1 = e1->argument_index(j);\n-      k2 = e2->argument_index(j);\n-      match = compare_entry_to(k1, cp2, k2);\n-      if (!match) {\n-        return false;\n-      }\n+\n+  const int argc = e1->argument_count();\n+  if (argc != e2->argument_count()) {\n+    return false;\n+  }\n+\n+  for (int j = 0; j < argc; j++) {\n+    k1 = e1->argument(j);\n+    k2 = e2->argument(j);\n+    match = compare_entry_to(k1, cp2, k2);\n+    if (!match) {\n+      return false;\n@@ -1991,1 +1883,0 @@\n-    return true;           \/\/ got through loop; all elements equal\n@@ -1993,2 +1884,3 @@\n-  return false;\n-} \/\/ end compare_operand_to()\n+\n+  return true; \/\/ got through loop; all elements equal\n+} \/\/ end compare_bootstrap_entry_to()\n@@ -1999,4 +1891,4 @@\n-int ConstantPool::find_matching_operand(int pattern_i,\n-                    const constantPoolHandle& search_cp, int search_len) {\n-  for (int i = 0; i < search_len; i++) {\n-    bool found = compare_operand_to(pattern_i, search_cp, i);\n+int ConstantPool::find_matching_bsm_entry(int pattern_i,\n+                                          const constantPoolHandle& search_cp, int offset_limit) {\n+  for (int i = 0; i < offset_limit; i++) {\n+    bool found = compare_bootstrap_entry_to(pattern_i, search_cp, i);\n@@ -2008,1 +1900,1 @@\n-} \/\/ end find_matching_operand()\n+} \/\/ end find_matching_bsm_entry()\n@@ -2443,1 +2335,1 @@\n-  if (operands() != nullptr)  st->print(\"\/operands[%d]\", operands()->length());\n+  if (!bsm_entries().is_empty())  st->print(\"\/BSMs[%d]\", bsm_entries().bootstrap_methods()->length());\n@@ -2478,0 +2370,84 @@\n+\n+void BSMAttributeEntries::deallocate_contents(ClassLoaderData* loader_data) {\n+  MetadataFactory::free_array<u4>(loader_data, this->_offsets);\n+  MetadataFactory::free_array<u2>(loader_data, this->_bootstrap_methods);\n+  this->_offsets = nullptr;\n+  this->_bootstrap_methods = nullptr;\n+}\n+\n+void BSMAttributeEntries::copy_into(InsertionIterator& iter, int num_entries) const {\n+  assert(num_entries + iter._cur_offset <= iter._insert_into->_offsets->length(), \"must\");\n+  for (int i = 0; i < num_entries; i++) {\n+    const BSMAttributeEntry* e = entry(i);\n+    BSMAttributeEntry* e_new = iter.reserve_new_entry(e->bootstrap_method_index(), e->argument_count());\n+    assert(e_new != nullptr, \"must be\");\n+    e->copy_args_into(e_new);\n+  }\n+}\n+\n+BSMAttributeEntries::InsertionIterator\n+BSMAttributeEntries::start_extension(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS) {\n+  InsertionIterator iter = start_extension(other.number_of_entries(), other.array_length(),\n+                                           loader_data, CHECK_(BSMAttributeEntries::InsertionIterator()));\n+  return iter;\n+}\n+\n+BSMAttributeEntries::InsertionIterator\n+BSMAttributeEntries::start_extension(int number_of_entries, int array_length,\n+                                     ClassLoaderData* loader_data, TRAPS) {\n+  InsertionIterator extension_iterator(this, this->number_of_entries(), this->array_length());\n+  int new_number_of_entries = this->number_of_entries() + number_of_entries;\n+  int new_array_length = this->array_length() + array_length;\n+  int invalid_index = new_array_length;\n+\n+  Array<u4>* new_offsets =\n+    MetadataFactory::new_array<u4>(loader_data, new_number_of_entries, invalid_index, CHECK_(InsertionIterator()));\n+  Array<u2>* new_array = MetadataFactory::new_array<u2>(loader_data, new_array_length, CHECK_(InsertionIterator()));\n+  { \/\/ Copy over all the old BSMAEntry's and their respective offsets\n+    BSMAttributeEntries carrier(new_offsets, new_array);\n+    InsertionIterator copy_iter(&carrier, 0, 0);\n+    copy_into(copy_iter, this->number_of_entries());\n+  }\n+  \/\/ Replace content\n+  deallocate_contents(loader_data);\n+  _offsets = new_offsets;\n+  _bootstrap_methods = new_array;\n+  return extension_iterator;\n+}\n+\n+\n+void BSMAttributeEntries::append(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS) {\n+  if (other.number_of_entries() == 0) {\n+    return; \/\/ Done!\n+  }\n+  InsertionIterator iter = start_extension(other, loader_data, CHECK);\n+  other.copy_into(iter, other.number_of_entries());\n+  end_extension(iter, loader_data, THREAD);\n+}\n+\n+void BSMAttributeEntries::end_extension(InsertionIterator& iter, ClassLoaderData* loader_data, TRAPS) {\n+  assert(iter._insert_into == this, \"must be\");\n+  assert(iter._cur_offset <= this->_offsets->length(), \"must be\");\n+  assert(iter._cur_array <= this->_bootstrap_methods->length(), \"must be\");\n+\n+  \/\/ Did we fill up all of the available space? If so, do nothing.\n+  if (iter._cur_offset == this->_offsets->length() &&\n+      iter._cur_array == this->_bootstrap_methods->length()) {\n+    return;\n+  }\n+\n+  \/\/ We used less, truncate by allocating new arrays\n+  Array<u4>* new_offsets =\n+      MetadataFactory::new_array<u4>(loader_data, iter._cur_offset, 0, CHECK);\n+  Array<u2>* new_array =\n+    MetadataFactory::new_array<u2>(loader_data, iter._cur_array, CHECK);\n+  { \/\/ Copy over the constructed BSMAEntry's\n+    BSMAttributeEntries carrier(new_offsets, new_array);\n+    InsertionIterator copy_iter(&carrier, 0, 0);\n+    copy_into(copy_iter, iter._cur_offset);\n+  }\n+\n+  deallocate_contents(loader_data);\n+  _offsets = new_offsets;\n+  _bootstrap_methods = new_array;\n+}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":137,"deletions":161,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -80,37 +81,0 @@\n-class BSMAttributeEntry {\n-  friend class ConstantPool;\n-  u2 _bootstrap_method_index;\n-  u2 _argument_count;\n-\n-  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n-  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n-  \/\/ So in order to find the argument array, jump over ourselves.\n-  const u2* argument_indexes() const {\n-    return reinterpret_cast<const u2*>(this + 1);\n-  }\n-  u2* argument_indexes() {\n-    return reinterpret_cast<u2*>(this + 1);\n-  }\n-  \/\/ These are overlays on top of the operands array. Do not construct.\n-  BSMAttributeEntry() = delete;\n-\n-public:\n-  \/\/ Offsets for SA\n-  enum {\n-    _bsmi_offset = 0,\n-    _argc_offset = 1,\n-    _argv_offset = 2\n-  };\n-\n-  int bootstrap_method_index() const {\n-    return _bootstrap_method_index;\n-  }\n-  int argument_count() const {\n-    return _argument_count;\n-  }\n-  int argument_index(int n) const {\n-    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n-    return argument_indexes()[n];\n-  }\n-};\n-\n@@ -129,1 +93,2 @@\n-  Array<u2>*           _operands;    \/\/ for variable-sized (InvokeDynamic) nodes, usually empty\n+\n+  BSMAttributeEntries _bsm_entries;\n@@ -170,2 +135,0 @@\n-  void set_operands(Array<u2>* operands)       { _operands = operands; }\n-\n@@ -211,1 +174,7 @@\n-  Array<u2>* operands() const               { return _operands; }\n+\n+  BSMAttributeEntries& bsm_entries() {\n+    return _bsm_entries;\n+  }\n+  const BSMAttributeEntries& bsm_entries() const {\n+    return _bsm_entries;\n+  }\n@@ -559,46 +528,0 @@\n-  \/\/ The first part of the operands array consists of an index into the second part.\n-  \/\/ Extract a 32-bit index value from the first part.\n-  static int operand_offset_at(Array<u2>* operands, int bsms_attribute_index) {\n-    int n = (bsms_attribute_index * 2);\n-    assert(n >= 0 && n+2 <= operands->length(), \"oob\");\n-    \/\/ The first 32-bit index points to the beginning of the second part\n-    \/\/ of the operands array.  Make sure this index is in the first part.\n-    DEBUG_ONLY(int second_part = build_int_from_shorts(operands->at(0),\n-                                                       operands->at(1)));\n-    assert(second_part == 0 || n+2 <= second_part, \"oob (2)\");\n-    int offset = build_int_from_shorts(operands->at(n+0),\n-                                       operands->at(n+1));\n-    \/\/ The offset itself must point into the second part of the array.\n-    assert(offset == 0 || (offset >= second_part && offset <= operands->length()), \"oob (3)\");\n-    return offset;\n-  }\n-  static void operand_offset_at_put(Array<u2>* operands, int bsms_attribute_index, int offset) {\n-    int n = bsms_attribute_index * 2;\n-    assert(n >= 0 && n+2 <= operands->length(), \"oob\");\n-    operands->at_put(n+0, extract_low_short_from_int(offset));\n-    operands->at_put(n+1, extract_high_short_from_int(offset));\n-  }\n-  static int operand_array_length(Array<u2>* operands) {\n-    if (operands == nullptr || operands->length() == 0)  return 0;\n-    int second_part = operand_offset_at(operands, 0);\n-    return (second_part \/ 2);\n-  }\n-\n-#ifdef ASSERT\n-  \/\/ operand tuples fit together exactly, end to end\n-  static int operand_limit_at(Array<u2>* operands, int bsms_attribute_index) {\n-    int nextidx = bsms_attribute_index + 1;\n-    if (nextidx == operand_array_length(operands))\n-      return operands->length();\n-    else\n-      return operand_offset_at(operands, nextidx);\n-  }\n-#endif \/\/ASSERT\n-\n-  \/\/ These functions are used in RedefineClasses for CP merge\n-  int operand_offset_at(int bsms_attribute_index) {\n-    assert(0 <= bsms_attribute_index &&\n-           bsms_attribute_index < operand_array_length(operands()),\n-           \"Corrupted CP operands\");\n-    return operand_offset_at(operands(), bsms_attribute_index);\n-  }\n@@ -607,22 +530,13 @@\n-    int offset = operand_offset_at(bsms_attribute_index);\n-    return reinterpret_cast<BSMAttributeEntry*>(operands()->adr_at(offset));\n-  }\n-\n-  int operand_next_offset_at(int bsms_attribute_index) {\n-    BSMAttributeEntry* bsme = bsm_attribute_entry(bsms_attribute_index);\n-    u2* argv_start = bsme->argument_indexes();\n-    int offset = argv_start - operands()->data();\n-    return offset + bsme->argument_count();\n-  }\n-  \/\/ Compare a bootstrap specifier data in the operands arrays\n-  bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle& cp2,\n-                          int bsms_attribute_index2);\n-  \/\/ Find a bootstrap specifier data in the operands array\n-  int find_matching_operand(int bsms_attribute_index, const constantPoolHandle& search_cp,\n-                            int operands_cur_len);\n-  \/\/ Resize the operands array with delta_len and delta_size\n-  void resize_operands(int delta_len, int delta_size, TRAPS);\n-  \/\/ Extend the operands array with the length and size of the ext_cp operands\n-  void extend_operands(const constantPoolHandle& ext_cp, TRAPS);\n-  \/\/ Shrink the operands array to a smaller array with new_len length\n-  void shrink_operands(int new_len, TRAPS);\n+    return _bsm_entries.entry(bsms_attribute_index);\n+  }\n+\n+  bool compare_bootstrap_entry_to(int bsms_attribute_index1, const constantPoolHandle& cp2,\n+                                  int bsms_attribute_index2);\n+  \/\/ Find a BSM entry in search_cp that matches the BSM at bsm_attribute_index.\n+  \/\/ Return -1 if not found.\n+  int find_matching_bsm_entry(int bsms_attribute_index, const constantPoolHandle& search_cp,\n+                              int offset_limit);\n+  \/\/ Extend the BSM attribute storage to fit both the current data and the BSM data in ext_cp.\n+  \/\/ Use the returned InsertionIterator to fill out the newly allocated space.\n+  BSMAttributeEntries::InsertionIterator start_extension(const constantPoolHandle& ext_cp, TRAPS);\n+  void end_extension(BSMAttributeEntries::InsertionIterator iter, TRAPS);\n@@ -644,1 +558,1 @@\n-    return bsm_attribute_entry(bsmai)->argument_index(j);\n+    return bsm_attribute_entry(bsmai)->argument(j);\n@@ -851,1 +765,1 @@\n-  static void copy_operands(const constantPoolHandle& from_cp, const constantPoolHandle& to_cp, TRAPS);\n+  static void copy_bsm_entries(const constantPoolHandle& from_cp, const constantPoolHandle& to_cp, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":25,"deletions":111,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-          \"as well by using CompileCommand=PrintPhaseLevel.\")                        \\\n+          \"as well by using CompileCommand=PhasePrintLevel.\")               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5823,1 +5823,1 @@\n-  return PrintPhaseLevel > 0 && directive()->PhasePrintLevelOption >= level &&\n+  return PrintPhaseLevel >= 0 && directive()->PhasePrintLevelOption >= level &&\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,90 @@\n+\/\/ Support for printing properties\n+class PrintProperties\n+{\n+private:\n+  IdealGraphPrinter* _printer;\n+\n+public:\n+  PrintProperties(IdealGraphPrinter* printer) : _printer(printer) {}\n+  void print_node_properties(Node* node);\n+  void print_lrg_properties(const LRG& lrg, const char* buffer);\n+  void print_property(int flag, const char* name);\n+  void print_property(int flag, const char* name, const char* val);\n+  void print_property(int flag, const char* name, int val);\n+};\n+\n+void PrintProperties::print_node_properties(Node* node) {\n+  const jushort flags = node->flags();\n+  print_property((flags & Node::Flag_is_Copy), \"is_copy\");\n+  print_property((flags & Node::Flag_rematerialize), \"rematerialize\");\n+  print_property((flags & Node::Flag_needs_anti_dependence_check), \"needs_anti_dependence_check\");\n+  print_property((flags & Node::Flag_is_macro), \"is_macro\");\n+  print_property((flags & Node::Flag_is_Con), \"is_con\");\n+  print_property((flags & Node::Flag_is_cisc_alternate), \"is_cisc_alternate\");\n+  print_property((flags & Node::Flag_is_dead_loop_safe), \"is_dead_loop_safe\");\n+  print_property((flags & Node::Flag_may_be_short_branch), \"may_be_short_branch\");\n+  print_property((flags & Node::Flag_has_call), \"has_call\");\n+  print_property((flags & Node::Flag_has_swapped_edges), \"has_swapped_edges\");\n+  Matcher* matcher = _printer->C->matcher();\n+  if (matcher != nullptr) {\n+    print_property(matcher->is_shared(node),\"is_shared\");\n+    print_property(!(matcher->is_shared(node)), \"is_shared\", IdealGraphPrinter::FALSE_VALUE);\n+    print_property(matcher->is_dontcare(node), \"is_dontcare\");\n+    print_property(!(matcher->is_dontcare(node)),\"is_dontcare\", IdealGraphPrinter::FALSE_VALUE);\n+    Node* old = matcher->find_old_node(node);\n+    if (old != nullptr) {\n+      print_property(true, \"old_node_idx\", old->_idx);\n+    }\n+  }\n+}\n+\n+void PrintProperties::print_lrg_properties(const LRG &lrg, const char *buffer) {\n+  print_property(true, \"mask\", buffer);\n+  print_property(true, \"mask_size\", lrg.mask_size());\n+  if (lrg._degree_valid) {\n+    print_property(true, \"degree\", lrg.degree());\n+  }\n+  print_property(true, \"num_regs\", lrg.num_regs());\n+  print_property(true, \"reg_pressure\", lrg.reg_pressure());\n+  print_property(true, \"cost\", lrg._cost);\n+  print_property(true, \"area\", lrg._area);\n+  print_property(true, \"score\", lrg.score());\n+  print_property((lrg._risk_bias != 0), \"risk_bias\", lrg._risk_bias);\n+  print_property((lrg._copy_bias != 0), \"copy_bias\", lrg._copy_bias);\n+  print_property(lrg.is_singledef(), \"is_singledef\");\n+  print_property(lrg.is_multidef(), \"is_multidef\");\n+  print_property(lrg._is_oop, \"is_oop\");\n+  print_property(lrg._is_float, \"is_float\");\n+  print_property(lrg._is_vector, \"is_vector\");\n+  print_property(lrg._is_predicate, \"is_predicate\");\n+  print_property(lrg._is_scalable, \"is_scalable\");\n+  print_property(lrg._was_spilled1, \"was_spilled1\");\n+  print_property(lrg._was_spilled2, \"was_spilled2\");\n+  print_property(lrg._direct_conflict, \"direct_conflict\");\n+  print_property(lrg._fat_proj, \"fat_proj\");\n+  print_property(lrg._was_lo, \"_was_lo\");\n+  print_property(lrg._has_copy, \"has_copy\");\n+  print_property(lrg._at_risk, \"at_risk\");\n+  print_property(lrg._must_spill, \"must_spill\");\n+  print_property(lrg._is_bound, \"is_bound\");\n+  print_property((lrg._msize_valid && lrg._degree_valid && lrg.lo_degree()), \"trivial\");\n+}\n+\n+void PrintProperties::print_property(int flag, const char* name) {\n+  if (flag != 0) {\n+    _printer->print_prop(name, IdealGraphPrinter::TRUE_VALUE);\n+  }\n+}\n+\n+void PrintProperties::print_property(int flag, const char* name, const char* val) {\n+  if (flag != 0) {\n+    _printer->print_prop(name, val);\n+  }\n+}\n+\n+void PrintProperties::print_property(int flag, const char* name, int val) {\n+  if (flag != 0) {\n+    _printer->print_prop(name, val);\n+  }\n+}\n+\n@@ -525,48 +615,2 @@\n-    const jushort flags = node->flags();\n-    if (flags & Node::Flag_is_Copy) {\n-      print_prop(\"is_copy\", \"true\");\n-    }\n-    if (flags & Node::Flag_rematerialize) {\n-      print_prop(\"rematerialize\", \"true\");\n-    }\n-    if (flags & Node::Flag_needs_anti_dependence_check) {\n-      print_prop(\"needs_anti_dependence_check\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_macro) {\n-      print_prop(\"is_macro\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_Con) {\n-      print_prop(\"is_con\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_cisc_alternate) {\n-      print_prop(\"is_cisc_alternate\", \"true\");\n-    }\n-    if (flags & Node::Flag_is_dead_loop_safe) {\n-      print_prop(\"is_dead_loop_safe\", \"true\");\n-    }\n-    if (flags & Node::Flag_may_be_short_branch) {\n-      print_prop(\"may_be_short_branch\", \"true\");\n-    }\n-    if (flags & Node::Flag_has_call) {\n-      print_prop(\"has_call\", \"true\");\n-    }\n-    if (flags & Node::Flag_has_swapped_edges) {\n-      print_prop(\"has_swapped_edges\", \"true\");\n-    }\n-\n-    if (C->matcher() != nullptr) {\n-      if (C->matcher()->is_shared(node)) {\n-        print_prop(\"is_shared\", \"true\");\n-      } else {\n-        print_prop(\"is_shared\", \"false\");\n-      }\n-      if (C->matcher()->is_dontcare(node)) {\n-        print_prop(\"is_dontcare\", \"true\");\n-      } else {\n-        print_prop(\"is_dontcare\", \"false\");\n-      }\n-      Node* old = C->matcher()->find_old_node(node);\n-      if (old != nullptr) {\n-        print_prop(\"old_node_idx\", old->_idx);\n-      }\n-    }\n+    PrintProperties print_node(this);\n+    print_node.print_node_properties(node);\n@@ -1148,67 +1192,4 @@\n-      print_prop(\"mask\", buffer);\n-      print_prop(\"mask_size\", lrg.mask_size());\n-      if (lrg._degree_valid) {\n-        print_prop(\"degree\", lrg.degree());\n-      }\n-      print_prop(\"num_regs\", lrg.num_regs());\n-      print_prop(\"reg_pressure\", lrg.reg_pressure());\n-      print_prop(\"cost\", lrg._cost);\n-      print_prop(\"area\", lrg._area);\n-      print_prop(\"score\", lrg.score());\n-      if (lrg._risk_bias != 0) {\n-        print_prop(\"risk_bias\", lrg._risk_bias);\n-      }\n-      if (lrg._copy_bias != 0) {\n-        print_prop(\"copy_bias\", lrg._copy_bias);\n-      }\n-      if (lrg.is_singledef()) {\n-        print_prop(\"is_singledef\", TRUE_VALUE);\n-      }\n-      if (lrg.is_multidef()) {\n-        print_prop(\"is_multidef\", TRUE_VALUE);\n-      }\n-      if (lrg._is_oop) {\n-        print_prop(\"is_oop\", TRUE_VALUE);\n-      }\n-      if (lrg._is_float) {\n-        print_prop(\"is_float\", TRUE_VALUE);\n-      }\n-      if (lrg._is_vector) {\n-        print_prop(\"is_vector\", TRUE_VALUE);\n-      }\n-      if (lrg._is_predicate) {\n-        print_prop(\"is_predicate\", TRUE_VALUE);\n-      }\n-      if (lrg._is_scalable) {\n-        print_prop(\"is_scalable\", TRUE_VALUE);\n-      }\n-      if (lrg._was_spilled1) {\n-        print_prop(\"was_spilled1\", TRUE_VALUE);\n-      }\n-      if (lrg._was_spilled2) {\n-        print_prop(\"was_spilled2\", TRUE_VALUE);\n-      }\n-      if (lrg._direct_conflict) {\n-        print_prop(\"direct_conflict\", TRUE_VALUE);\n-      }\n-      if (lrg._fat_proj) {\n-        print_prop(\"fat_proj\", TRUE_VALUE);\n-      }\n-      if (lrg._was_lo) {\n-        print_prop(\"_was_lo\", TRUE_VALUE);\n-      }\n-      if (lrg._has_copy) {\n-        print_prop(\"has_copy\", TRUE_VALUE);\n-      }\n-      if (lrg._at_risk) {\n-        print_prop(\"at_risk\", TRUE_VALUE);\n-      }\n-      if (lrg._must_spill) {\n-        print_prop(\"must_spill\", TRUE_VALUE);\n-      }\n-      if (lrg._is_bound) {\n-        print_prop(\"is_bound\", TRUE_VALUE);\n-      }\n-      if (lrg._msize_valid && lrg._degree_valid && lrg.lo_degree()) {\n-        print_prop(\"trivial\", TRUE_VALUE);\n-      }\n+\n+      PrintProperties print_node(this);\n+      print_node.print_lrg_properties(lrg, buffer);\n+\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":96,"deletions":115,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- private:\n+  friend class PrintProperties;\n@@ -51,0 +51,1 @@\n+private:\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1414,1 +1414,0 @@\n-  Node *pre_header= main_head->in(LoopNode::EntryControl);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1165,0 +1165,1 @@\n+  Node* const _new_init;\n@@ -1168,0 +1169,1 @@\n+                                 Node* new_init,\n@@ -1171,1 +1173,2 @@\n-      _phase(phase) {\n+      _phase(phase),\n+      _new_init(new_init) {\n@@ -1183,1 +1186,1 @@\n-    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    _clone_predicate_to_loop.clone_template_assertion_predicate_and_replace_init(template_assertion_predicate, _new_init);\n@@ -1188,0 +1191,21 @@\n+\/\/ For an int counted loop, try_make_short_running_loop() transforms the loop from:\n+\/\/     for (int = start; i < stop; i+= stride) { ... }\n+\/\/ to\n+\/\/     for (int = 0; i < stop - start; i+= stride) { ... }\n+\/\/ Template Assertion Predicates added so far were with an init value of start. They need to be updated with the new\n+\/\/ init value of 0 (otherwise when a template assertion predicate is turned into an initialized assertion predicate, it\n+\/\/ performs an incorrect check):\n+\/\/                                zero\n+\/\/        init                     |\n+\/\/         |           ===>   OpaqueLoopInit   init\n+\/\/  OpaqueLoopInit                         \\   \/\n+\/\/                                          AddI\n+\/\/\n+Node* PhaseIdealLoop::new_assertion_predicate_opaque_init(Node* entry_control, Node* init, Node* int_zero) {\n+  OpaqueLoopInitNode* new_opaque_init = new OpaqueLoopInitNode(C, int_zero);\n+  register_new_node(new_opaque_init, entry_control);\n+  Node* new_init = new AddINode(new_opaque_init, init);\n+  register_new_node(new_init, entry_control);\n+  return new_init;\n+}\n+\n@@ -1239,0 +1263,1 @@\n+  Node* int_zero = intcon(0);\n@@ -1264,0 +1289,2 @@\n+    Node* new_init = new_assertion_predicate_opaque_init(entry_control, init, int_zero);\n+\n@@ -1266,1 +1293,1 @@\n-    CloneShortLoopPredicateVisitor clone_short_loop_predicates_visitor(head, node_in_short_loop_body, this);\n+    CloneShortLoopPredicateVisitor clone_short_loop_predicates_visitor(head, new_init, node_in_short_loop_body, this);\n@@ -1314,0 +1341,4 @@\n+    PredicateIterator predicate_iterator(entry_control);\n+    Node* new_init = new_assertion_predicate_opaque_init(entry_control, init, int_zero);\n+    UpdateInitForTemplateAssertionPredicates update_init_for_template_assertion_predicates(new_init, this);\n+    predicate_iterator.for_each(update_init_for_template_assertion_predicates);\n@@ -1323,1 +1354,0 @@\n-  Node* int_zero = intcon(0);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1982,0 +1982,2 @@\n+  Node* new_assertion_predicate_opaque_init(Node* entry_control, Node* init, Node* int_zero);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4363,0 +4363,27 @@\n+#ifdef ASSERT\n+\n+\/\/ Moves Template Assertion Predicates to a target loop by cloning and killing the old ones. The target loop is the\n+\/\/ original, not-cloned loop. This is currently only used with StressLoopBackedge which is a develop flag only and\n+\/\/ false with product builds. We can therefore guard it with an ifdef. More details can be found at the use-site.\n+class MoveAssertionPredicatesVisitor : public PredicateVisitor {\n+  ClonePredicateToTargetLoop _clone_predicate_to_loop;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  MoveAssertionPredicatesVisitor(LoopNode* target_loop_head,\n+                                 const NodeInSingleLoopBody &node_in_loop_body,\n+                                 PhaseIdealLoop* phase)\n+    : _clone_predicate_to_loop(target_loop_head, node_in_loop_body, phase),\n+      _phase(phase) {\n+  }\n+  NONCOPYABLE(MoveAssertionPredicatesVisitor);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    template_assertion_predicate.kill(_phase->igvn());\n+  }\n+};\n+#endif \/\/ ASSERT\n+\n@@ -4431,0 +4458,1 @@\n+#ifdef ASSERT\n@@ -4449,1 +4477,3 @@\n-  } else {\n+  } else\n+#endif \/\/ASSERT\n+  {\n@@ -4640,0 +4670,13 @@\n+#ifdef ASSERT\n+  if (StressDuplicateBackedge && head->is_CountedLoop()) {\n+    \/\/ The Template Assertion Predicates from the old counted loop are now at the new outer loop - clone them to\n+    \/\/ the inner counted loop and kill the old ones. We only need to do this with debug builds because\n+    \/\/ StressDuplicateBackedge is a devlop flag and false by default. Without StressDuplicateBackedge 'head' will be a\n+    \/\/ non-counted loop, and thus we have no Template Assertion Predicates above the old loop to move down.\n+    PredicateIterator predicate_iterator(outer_head->in(LoopNode::EntryControl));\n+    NodeInSingleLoopBody node_in_body(this, loop);\n+    MoveAssertionPredicatesVisitor move_assertion_predicates_visitor(head, node_in_body, this);\n+    predicate_iterator.for_each(move_assertion_predicates_visitor);\n+  }\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2199,1 +2199,4 @@\n-  virtual void target_node_action(Node* target_node) = 0;\n+  \/\/ To give more freedom, we pass the direct child node to the target node such that\n+  \/\/ child->in(i) == target node. This allows to also directly replace the target node instead\n+  \/\/ of only updating its inputs.\n+  virtual void target_node_action(Node* child, uint i) = 0;\n@@ -2221,1 +2224,1 @@\n-          _bfs_actions.target_node_action(input);\n+          _bfs_actions.target_node_action(next, j);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1443,1 +1443,0 @@\n-  int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; \/\/ add marginal slop for handler\n@@ -1449,1 +1448,1 @@\n-    code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  \/\/ force expansion\n+    code_req = const_req = stub_req = deopt_handler_req = 0x10;  \/\/ force expansion\n@@ -1456,1 +1455,0 @@\n-          exception_handler_req +\n@@ -1886,2 +1884,0 @@\n-    \/\/ Emit the exception handler code.\n-    _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(masm));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1135,1 +1135,1 @@\n-bool PhaseIterGVN::verify_Value_for(Node* n) {\n+bool PhaseIterGVN::verify_Value_for(Node* n, bool strict) {\n@@ -1155,1 +1155,1 @@\n-  if (n->is_Load() && !told->singleton()) {\n+  if (!strict && n->is_Load() && !told->singleton()) {\n@@ -1163,1 +1163,1 @@\n-  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+  if (!strict && n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n@@ -2852,0 +2852,1 @@\n+  Unique_Node_List worklist_revisit(&local_arena);\n@@ -2860,2 +2861,3 @@\n-  \/\/ Pull from worklist; compute new value; push changes out.\n-  \/\/ This loop is the meat of CCP.\n+  \/\/ This is the meat of CCP: pull from worklist; compute new value; push changes out.\n+\n+  \/\/ Do the first round. Since all initial types are TOP, this will visit all alive nodes.\n@@ -2865,0 +2867,3 @@\n+    if (needs_revisit(n)) {\n+      worklist_revisit.push(n);\n+    }\n@@ -2870,6 +2875,10 @@\n-    const Type* new_type = n->Value(this);\n-    if (new_type != type(n)) {\n-      DEBUG_ONLY(verify_type(n, new_type, type(n));)\n-      dump_type_and_node(n, new_type);\n-      set_type(n, new_type);\n-      push_child_nodes_to_worklist(worklist, n);\n+    analyze_step(worklist, n);\n+  }\n+\n+  \/\/ More rounds to catch updates far in the graph.\n+  \/\/ Revisit nodes that might be able to refine their types at the end of the round.\n+  \/\/ If so, process these nodes. If there is remaining work, start another round.\n+  do {\n+    while (worklist.size() != 0) {\n+      Node* n = fetch_next_node(worklist);\n+      analyze_step(worklist, n);\n@@ -2877,4 +2886,3 @@\n-    if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n-      \/\/ Keep track of Type nodes to kill CFG paths that use Type\n-      \/\/ nodes that become dead.\n-      _maybe_top_type_nodes.push(n);\n+    for (uint t = 0; t < worklist_revisit.size(); t++) {\n+      Node* n = worklist_revisit.at(t);\n+      analyze_step(worklist, n);\n@@ -2882,1 +2890,2 @@\n-  }\n+  } while (worklist.size() != 0);\n+\n@@ -2886,0 +2895,31 @@\n+void PhaseCCP::analyze_step(Unique_Node_List& worklist, Node* n) {\n+  const Type* new_type = n->Value(this);\n+  if (new_type != type(n)) {\n+    DEBUG_ONLY(verify_type(n, new_type, type(n));)\n+    dump_type_and_node(n, new_type);\n+    set_type(n, new_type);\n+    push_child_nodes_to_worklist(worklist, n);\n+  }\n+  if (KillPathsReachableByDeadTypeNode && n->is_Type() && new_type == Type::TOP) {\n+    \/\/ Keep track of Type nodes to kill CFG paths that use Type\n+    \/\/ nodes that become dead.\n+    _maybe_top_type_nodes.push(n);\n+  }\n+}\n+\n+\/\/ Some nodes can refine their types due to type change somewhere deep\n+\/\/ in the graph. We will need to revisit them before claiming convergence.\n+\/\/ Add nodes here if particular *Node::Value is doing deep graph traversals\n+\/\/ not handled by PhaseCCP::push_more_uses().\n+bool PhaseCCP::needs_revisit(Node* n) const {\n+  \/\/ LoadNode performs deep traversals. Load is not notified for changes far away.\n+  if (n->is_Load()) {\n+    return true;\n+  }\n+  \/\/ CmpPNode performs deep traversals if it compares oopptr. CmpP is not notified for changes far away.\n+  if (n->Opcode() == Op_CmpP && type(n->in(1))->isa_oopptr() && type(n->in(2))->isa_oopptr()) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2888,1 +2928,2 @@\n-\/\/ We have a list of exceptions, see comments in verify_Value_for.\n+\/\/ Note for CCP the non-convergence can lead to unsound analysis and mis-compilation.\n+\/\/ Therefore, we are verifying Value convergence strictly.\n@@ -2893,1 +2934,1 @@\n-    failure |= verify_Value_for(n);\n+    failure |= verify_Value_for(n, \/* strict = *\/ true);\n@@ -2897,2 +2938,3 @@\n-  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type or add an exception\n-  \/\/ in the verification code above if that is not possible for some reason (like Load nodes).\n+  \/\/ in PhaseCCP::push_child_nodes_to_worklist() to update their type in the same round,\n+  \/\/ or that they are added in PhaseCCP::needs_revisit() so that analysis revisits\n+  \/\/ them at the end of the round.\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":62,"deletions":20,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -493,1 +493,1 @@\n-  bool verify_Value_for(Node* n);\n+  bool verify_Value_for(Node* n, bool strict = false);\n@@ -665,0 +665,2 @@\n+  void analyze_step(Unique_Node_List& worklist, Node* n);\n+  bool needs_revisit(Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -201,1 +201,0 @@\n-  DEBUG_ONLY(verify();)\n@@ -204,0 +203,10 @@\n+  return clone_and_replace_init(new_control, new_opaque_init, new_loop_node, phase);\n+}\n+\n+\/\/ Clone this Template Assertion Predicate and replace the old OpaqueLoopInit node with 'new_init'.\n+\/\/ Note: 'new_init' could also have the 'OpaqueLoopInit` as parent node further up.\n+TemplateAssertionPredicate TemplateAssertionPredicate::clone_and_replace_init(Node* new_control,\n+                                                                              Node* new_init,\n+                                                                              CountedLoopNode* new_loop_node,\n+                                                                              PhaseIdealLoop* phase) const {\n+  DEBUG_ONLY(verify();)\n@@ -206,1 +215,1 @@\n-      template_assertion_expression.clone_and_replace_init(new_control, new_opaque_init, new_loop_node);\n+      template_assertion_expression.clone_and_replace_init(new_control, new_init, new_loop_node);\n@@ -241,2 +250,34 @@\n-  void target_node_action(Node* target_node) override {\n-    _igvn.replace_input_of(target_node, 1, _new_opaque_stride_input);\n+  void target_node_action(Node* child, uint i) override {\n+    assert(child->in(i)->is_OpaqueLoopStride(), \"must be OpaqueLoopStride\");\n+    _igvn.replace_input_of(child->in(i), 1, _new_opaque_stride_input);\n+  }\n+};\n+\n+\/\/ This class is used to replace the OpaqueLoopInitNode with a new node while leaving the other nodes\n+\/\/ unchanged.\n+class ReplaceOpaqueInitNode : public BFSActions {\n+  Node* _new_opaque_init_node;\n+  PhaseIterGVN& _igvn;\n+\n+  public:\n+  ReplaceOpaqueInitNode(Node* new_opaque_init_node, PhaseIterGVN& igvn)\n+      : _new_opaque_init_node(new_opaque_init_node),\n+        _igvn(igvn) {}\n+  NONCOPYABLE(ReplaceOpaqueInitNode);\n+\n+  void replace_for(OpaqueTemplateAssertionPredicateNode* opaque_node) {\n+    DataNodeBFS bfs(*this);\n+    bfs.run(opaque_node);\n+  }\n+\n+  bool should_visit(Node* node) const override {\n+    return TemplateAssertionExpressionNode::is_maybe_in_expression(node);\n+  }\n+\n+  bool is_target_node(Node* node) const override {\n+    return node->is_OpaqueLoopInit();\n+  }\n+\n+  void target_node_action(Node* child, uint i) override {\n+    assert(child->in(i)->is_OpaqueLoopInit(), \"must be old OpaqueLoopInit\");\n+    _igvn.replace_input_of(child, i, _new_opaque_init_node);\n@@ -253,0 +294,7 @@\n+\/\/ Replace the OpaqueLoopInitNode with 'new_init' and leave the other nodes unchanged.\n+void TemplateAssertionPredicate::replace_opaque_init_node(Node* new_init, PhaseIterGVN& igvn) const {\n+  DEBUG_ONLY(verify();)\n+  ReplaceOpaqueInitNode replace_opaque_init_node(new_init, igvn);\n+  replace_opaque_init_node.replace_for(opaque_node());\n+}\n+\n@@ -311,1 +359,2 @@\n-  void target_node_action(Node* target_node) override {\n+  void target_node_action(Node* child, uint i) override {\n+    Node* target_node = child->in(i);\n@@ -1097,0 +1146,12 @@\n+\/\/ Clones the provided Template Assertion Predicate to the head of the current predicate chain at the target loop and\n+\/\/ replaces the current OpaqueLoopInit with 'new_init'.\n+\/\/  Note: 'new_init' could also have the 'OpaqueLoopInit` as parent node further up.\n+void ClonePredicateToTargetLoop::clone_template_assertion_predicate_and_replace_init(\n+    const TemplateAssertionPredicate& template_assertion_predicate, Node* new_init) {\n+  TemplateAssertionPredicate cloned_template_assertion_predicate =\n+      template_assertion_predicate.clone_and_replace_init(_old_target_loop_entry, new_init, _target_loop_head->as_CountedLoop(), _phase);\n+  template_assertion_predicate.rewire_loop_data_dependencies(cloned_template_assertion_predicate.tail(),\n+                                                             _node_in_loop_body, _phase);\n+  _target_loop_predicate_chain.insert_predicate(cloned_template_assertion_predicate);\n+}\n+\n@@ -1185,0 +1246,4 @@\n+void UpdateInitForTemplateAssertionPredicates::visit(const TemplateAssertionPredicate& template_assertion_predicate) {\n+  template_assertion_predicate.replace_opaque_init_node(_new_init, _phase->igvn());\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":70,"deletions":5,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -441,0 +441,2 @@\n+  TemplateAssertionPredicate clone_and_replace_init(Node* new_control, Node* new_input,\n+                                                    CountedLoopNode* new_loop_node, PhaseIdealLoop* phase) const;\n@@ -442,0 +444,1 @@\n+  void replace_opaque_init_node(Node* new_init, PhaseIterGVN& igvn) const;\n@@ -1231,0 +1234,1 @@\n+  void clone_template_assertion_predicate_and_replace_init(const TemplateAssertionPredicate& template_assertion_predicate, Node* new_init);\n@@ -1303,0 +1307,16 @@\n+\/\/ This visitor replaces the OpaqueLoopInitNode for an Assertion Predicate with the expression passed as input.\n+class UpdateInitForTemplateAssertionPredicates : public PredicateVisitor {\n+  Node* const _new_init;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  UpdateInitForTemplateAssertionPredicates(Node* const new_init, PhaseIdealLoop* phase)\n+      : _new_init(new_init),\n+        _phase(phase) {}\n+  NONCOPYABLE(UpdateInitForTemplateAssertionPredicates);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -3175,3 +3177,2 @@\n-  if( _ptr == Null ) st->print(\"null\");\n-  else st->print(\"%s *\", ptr_msg[_ptr]);\n-  _offset.dump2(st);\n+  st->print(\"ptr:%s\", ptr_msg[_ptr]);\n+  dump_offset(st);\n@@ -3182,0 +3183,4 @@\n+void TypePtr::dump_offset(outputStream* st) const {\n+  _offset.dump2(st);\n+}\n+\n@@ -3369,4 +3374,4 @@\n-void TypeRawPtr::dump2( Dict &d, uint depth, outputStream *st ) const {\n-  if( _ptr == Constant )\n-    st->print(INTPTR_FORMAT, p2i(_bits));\n-  else\n+void TypeRawPtr::dump2(Dict& d, uint depth, outputStream* st) const {\n+  if (_ptr == Constant) {\n+    st->print(\"rawptr:Constant:\" INTPTR_FORMAT, p2i(_bits));\n+  } else {\n@@ -3374,0 +3379,1 @@\n+  }\n@@ -4081,1 +4087,1 @@\n-void TypeOopPtr::dump2( Dict &d, uint depth, outputStream *st ) const {\n+void TypeOopPtr::dump2(Dict& d, uint depth, outputStream* st) const {\n@@ -4083,8 +4089,8 @@\n-  if( _klass_is_exact ) st->print(\":exact\");\n-  if( const_oop() ) st->print(INTPTR_FORMAT, p2i(const_oop()));\n-  _offset.dump2(st);\n-  if (_instance_id == InstanceTop)\n-    st->print(\",iid=top\");\n-  else if (_instance_id != InstanceBot)\n-    st->print(\",iid=%d\",_instance_id);\n-\n+  if (_klass_is_exact) {\n+    st->print(\":exact\");\n+  }\n+  if (const_oop() != nullptr) {\n+    st->print(\":\" INTPTR_FORMAT, p2i(const_oop()));\n+  }\n+  dump_offset(st);\n+  dump_instance_id(st);\n@@ -4094,0 +4100,10 @@\n+\n+void TypeOopPtr::dump_instance_id(outputStream* st) const {\n+  if (_instance_id == InstanceTop) {\n+    st->print(\",iid=top\");\n+  } else if (_instance_id == InstanceBot) {\n+    st->print(\",iid=bot\");\n+  } else {\n+    st->print(\",iid=%d\", _instance_id);\n+  }\n+}\n@@ -4782,0 +4798,1 @@\n+  st->print(\"instptr:\");\n@@ -4785,27 +4802,11 @@\n-  switch( _ptr ) {\n-  case Constant:\n-    if (WizardMode || Verbose) {\n-      ResourceMark rm;\n-      stringStream ss;\n-\n-      st->print(\" \");\n-      const_oop()->print_oop(&ss);\n-      \/\/ 'const_oop->print_oop()' may emit newlines('\\n') into ss.\n-      \/\/ suppress newlines from it so -XX:+Verbose -XX:+PrintIdeal dumps one-liner for each node.\n-      char* buf = ss.as_string(\/* c_heap= *\/false);\n-      StringUtils::replace_no_expand(buf, \"\\n\", \"\");\n-      st->print_raw(buf);\n-    }\n-  case BotPTR:\n-    if (!WizardMode && !Verbose) {\n-      if( _klass_is_exact ) st->print(\":exact\");\n-      break;\n-    }\n-  case TopPTR:\n-  case AnyNull:\n-  case NotNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if( _klass_is_exact ) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n+  if (_ptr == Constant && (WizardMode || Verbose)) {\n+    ResourceMark rm;\n+    stringStream ss;\n+\n+    st->print(\" \");\n+    const_oop()->print_oop(&ss);\n+    \/\/ 'const_oop->print_oop()' may emit newlines('\\n') into ss.\n+    \/\/ suppress newlines from it so -XX:+Verbose -XX:+PrintIdeal dumps one-liner for each node.\n+    char* buf = ss.as_string(\/* c_heap= *\/false);\n+    StringUtils::replace_no_expand(buf, \"\\n\", \"\");\n+    st->print_raw(buf);\n@@ -4814,1 +4815,4 @@\n-  _offset.dump2(st);\n+  st->print(\":%s\", ptr_msg[_ptr]);\n+  if (_klass_is_exact) {\n+    st->print(\":exact\");\n+  }\n@@ -4818,7 +4822,2 @@\n-  dump_flat_in_array(_flat_in_array, st);\n-\n-  if (_instance_id == InstanceTop)\n-    st->print(\",iid=top\");\n-  else if (_instance_id != InstanceBot)\n-    st->print(\",iid=%d\",_instance_id);\n-\n+  dump_offset(st);\n+  dump_instance_id(st);\n@@ -4827,0 +4826,1 @@\n+  dump_flat_in_array(_flat_in_array, st);\n@@ -5581,1 +5581,2 @@\n-  _ary->dump2(d,depth,st);\n+  st->print(\"aryptr:\");\n+  _ary->dump2(d, depth, st);\n@@ -5584,2 +5585,1 @@\n-  switch( _ptr ) {\n-  case Constant:\n+  if (_ptr == Constant) {\n@@ -5587,14 +5587,5 @@\n-    break;\n-  case BotPTR:\n-    if (!WizardMode && !Verbose) {\n-      if( _klass_is_exact ) st->print(\":exact\");\n-      break;\n-    }\n-  case TopPTR:\n-  case AnyNull:\n-  case NotNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if( _klass_is_exact ) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n+  }\n+\n+  st->print(\":%s\", ptr_msg[_ptr]);\n+  if (_klass_is_exact) {\n+    st->print(\":exact\");\n@@ -5640,5 +5631,0 @@\n-  st->print(\" *\");\n-  if (_instance_id == InstanceTop)\n-    st->print(\",iid=top\");\n-  else if (_instance_id != InstanceBot)\n-    st->print(\",iid=%d\",_instance_id);\n@@ -5646,0 +5632,1 @@\n+  dump_instance_id(st);\n@@ -6064,6 +6051,2 @@\n-  if( metadata() ) st->print(INTPTR_FORMAT, p2i(metadata()));\n-  switch (offset()) {\n-  case OffsetTop: st->print(\"+top\"); break;\n-  case OffsetBot: st->print(\"+any\"); break;\n-  case         0: break;\n-  default:        st->print(\"+%d\",offset()); break;\n+  if (metadata() != nullptr) {\n+    st->print(\":\" INTPTR_FORMAT, p2i(metadata()));\n@@ -6071,0 +6054,1 @@\n+  dump_offset(st);\n@@ -6221,33 +6205,0 @@\n-\/\/------------------------------dump2------------------------------------------\n-\/\/ Dump Klass Type\n-#ifndef PRODUCT\n-void TypeKlassPtr::dump2(Dict & d, uint depth, outputStream *st) const {\n-  switch(_ptr) {\n-  case Constant:\n-    st->print(\"precise \");\n-  case NotNull:\n-    {\n-      const char *name = klass()->name()->as_utf8();\n-      if (name) {\n-        st->print(\"%s: \" INTPTR_FORMAT, name, p2i(klass()));\n-      } else {\n-        ShouldNotReachHere();\n-      }\n-      _interfaces->dump(st);\n-    }\n-  case BotPTR:\n-    if (!WizardMode && !Verbose && _ptr != Constant) break;\n-  case TopPTR:\n-  case AnyNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if (_ptr == Constant) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n-  }\n-\n-  _offset.dump2(st);\n-  st->print(\" *\");\n-}\n-#endif\n-\n@@ -6635,0 +6586,11 @@\n+#ifndef PRODUCT\n+void TypeInstKlassPtr::dump2(Dict& d, uint depth, outputStream* st) const {\n+  st->print(\"instklassptr:\");\n+  klass()->print_name_on(st);\n+  _interfaces->dump(st);\n+  st->print(\":%s\", ptr_msg[_ptr]);\n+  dump_offset(st);\n+  dump_flat_in_array(_flat_in_array, st);\n+}\n+#endif \/\/ PRODUCT\n+\n@@ -7232,2 +7194,3 @@\n-void TypeInstKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n-  klass()->print_name_on(st);\n+void TypeAryKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n+  st->print(\"aryklassptr:[\");\n+  _elem->dump2(d, depth, st);\n@@ -7236,24 +7199,0 @@\n-  dump_flat_in_array(_flat_in_array, st);\n-}\n-\n-void TypeAryKlassPtr::dump2( Dict & d, uint depth, outputStream *st ) const {\n-  switch( _ptr ) {\n-  case Constant:\n-    st->print(\"precise \");\n-  case NotNull:\n-    {\n-      st->print(\"[\");\n-      _elem->dump2(d, depth, st);\n-      _interfaces->dump(st);\n-      st->print(\": \");\n-    }\n-  case BotPTR:\n-    if( !WizardMode && !Verbose && _ptr != Constant ) break;\n-  case TopPTR:\n-  case AnyNull:\n-    st->print(\":%s\", ptr_msg[_ptr]);\n-    if( _ptr == Constant ) st->print(\":exact\");\n-    break;\n-  default:\n-    break;\n-  }\n@@ -7268,4 +7207,1 @@\n-\n-  _offset.dump2(st);\n-\n-  st->print(\" *\");\n+  dump_offset(st);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":78,"deletions":142,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -1236,3 +1236,0 @@\n-#ifndef PRODUCT\n-  void dump_speculative(outputStream *st) const;\n-#endif\n@@ -1243,0 +1240,1 @@\n+\n@@ -1244,1 +1242,3 @@\n-  void dump_inline_depth(outputStream *st) const;\n+  void dump_speculative(outputStream* st) const;\n+  void dump_inline_depth(outputStream* st) const;\n+  void dump_offset(outputStream* st) const;\n@@ -1444,0 +1444,4 @@\n+#ifndef PRODUCT\n+  void dump_instance_id(outputStream* st) const;\n+#endif \/\/ PRODUCT\n+\n@@ -1972,3 +1976,0 @@\n-#ifndef PRODUCT\n-  virtual void dump2( Dict &d, uint depth, outputStream *st ) const; \/\/ Specialized per-Type dumping\n-#endif\n@@ -2071,0 +2072,5 @@\n+\n+#ifndef PRODUCT\n+  virtual void dump2(Dict& d, uint depth, outputStream* st) const;\n+#endif \/\/ PRODUCT\n+\n@@ -2073,2 +2079,0 @@\n-\n-  NOT_PRODUCT(virtual void dump2(Dict& d, uint depth, outputStream* st) const;) \/\/ Specialized per-Type dumping\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1025,4 +1025,9 @@\n-  \/\/ For the computation of main_init, we also need the pre_limit, and so we need\n-  \/\/ to check that this value is pre-loop invariant. In the case of non-equal iv_scales,\n-  \/\/ we also need the main_limit in the aliasing check, and so this value must then\n-  \/\/ also be pre-loop invariant.\n+  \/\/ In VPointer::make_speculative_aliasing_check_with we compute main_init in all\n+  \/\/ cases. For this, we require pre_init and pre_limit. These values must be available\n+  \/\/ for the speculative check, i.e. their control must dominate the speculative check.\n+  \/\/ Further, \"if vp1.iv_scale() != vp2.iv_scale()\" we additionally need to have\n+  \/\/ main_limit available for the speculative check.\n+  \/\/ Note: no matter if the speculative check is inserted as a predicate or at the\n+  \/\/       multiversion if, the speculative check happens before (dominates) the\n+  \/\/       pre-loop.\n+  Node* pre_init = _vloop.pre_loop_end()->init_trip();\n@@ -1032,2 +1037,9 @@\n-\n-  if (!_vloop.is_pre_loop_invariant(pre_limit)) {\n+  if (!_vloop.is_available_for_speculative_check(pre_init)) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis()) {\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: pre_limit is not available at speculative check!\");\n+    }\n+#endif\n+    return false;\n+  }\n+  if (!_vloop.is_available_for_speculative_check(pre_limit)) {\n@@ -1036,1 +1048,1 @@\n-      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: pre_limit is not pre-loop independent!\");\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: pre_limit is not available at speculative check!\");\n@@ -1042,1 +1054,1 @@\n-  if (vp1.iv_scale() != vp2.iv_scale() && !_vloop.is_pre_loop_invariant(main_limit)) {\n+  if (vp1.iv_scale() != vp2.iv_scale() && !_vloop.is_available_for_speculative_check(main_limit)) {\n@@ -1045,1 +1057,1 @@\n-      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: main_limit is not pre-loop independent!\");\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: main_limit is not available at speculative check!\");\n@@ -1122,0 +1134,2 @@\n+  assert(_vloop.is_available_for_speculative_check(pre_init),  \"ctrl must be early enough to avoid cycles\");\n+  assert(_vloop.is_available_for_speculative_check(pre_limit), \"ctrl must be early enough to avoid cycles\");\n@@ -1183,0 +1197,1 @@\n+    assert(_vloop.is_available_for_speculative_check(main_limit), \"ctrl must be early enough to avoid cycles\");\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -239,0 +239,2 @@\n+  \/\/ Note: this condition is NOT strong enough for speculative checks, those happen\n+  \/\/       before the pre-loop. See is_available_for_speculative_check\n@@ -260,0 +262,22 @@\n+  \/\/ Nodes that are to be used in speculative checks must be available early enough.\n+  \/\/ Note: the speculative check happens before the pre-loop, either at the auto\n+  \/\/       vectorization predicate or the multiversion if. This is before the\n+  \/\/       pre-loop, and thus the condition here is stronger then the one from\n+  \/\/       is_pre_loop_invariant.\n+  bool is_available_for_speculative_check(Node* n) const {\n+    assert(are_speculative_checks_possible(), \"meaningless without speculative check\");\n+    ParsePredicateSuccessProj* parse_predicate_proj = auto_vectorization_parse_predicate_proj();\n+    \/\/ Find the control of the predicate:\n+    ProjNode* proj = (parse_predicate_proj != nullptr) ? parse_predicate_proj : multiversioning_fast_proj();\n+    Node* check_ctrl = proj->in(0)->as_If()->in(0);\n+\n+    \/\/ Often, the control of n already dominates that of the predicate.\n+    Node* n_ctrl = phase()->get_ctrl(n);\n+    if (phase()->is_dominator(n_ctrl, check_ctrl)) { return true; }\n+\n+    \/\/ But in some cases, the ctrl of n is after that of the predicate,\n+    \/\/ but the early ctrl is before the predicate.\n+    Node* n_early = phase()->compute_early_ctrl(n, n_ctrl);\n+    return phase()->is_dominator(n_early, check_ctrl);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -393,1 +394,0 @@\n-  Array<u2>* operands = cpool()->operands();\n@@ -395,10 +395,3 @@\n-  int num_bootstrap_methods = ConstantPool::operand_array_length(operands);\n-\n-  \/\/ calculate length of attribute\n-  u4 length = sizeof(u2); \/\/ num_bootstrap_methods\n-  for (int n = 0; n < num_bootstrap_methods; n++) {\n-    u2 num_bootstrap_arguments = cpool()->bsm_attribute_entry(n)->argument_count();\n-    length += sizeof(u2); \/\/ bootstrap_method_ref\n-    length += sizeof(u2); \/\/ num_bootstrap_arguments\n-    length += (u4)sizeof(u2) * num_bootstrap_arguments; \/\/ bootstrap_arguments[num_bootstrap_arguments]\n-  }\n+  u4 length = sizeof(u2) + \/\/ Size of num_bootstrap_methods\n+              \/\/ The rest of the data for the attribute is exactly the u2s in the data array.\n+              sizeof(u2) * cpool()->bsm_entries().array_length();\n@@ -407,0 +400,1 @@\n+  int num_bootstrap_methods = cpool()->bsm_entries().number_of_entries();\n@@ -415,1 +409,1 @@\n-      u2 bootstrap_argument = bsme->argument_index(arg);\n+      u2 bootstrap_argument = bsme->argument(arg);\n@@ -827,1 +821,1 @@\n-  if (cpool()->operands() != nullptr) {\n+  if (!cpool()->bsm_entries().is_empty()) {\n@@ -878,1 +872,1 @@\n-  if (cpool()->operands() != nullptr) {\n+  if (!cpool()->bsm_entries().is_empty()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-#include \"oops\/constantPool.hpp\"\n+#include \"oops\/bsmAttribute.inline.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -576,1 +577,1 @@\n-      \/\/ Index of the bootstrap specifier in the operands array\n+      \/\/ Index of the bootstrap specifier in the BSM array\n@@ -578,1 +579,1 @@\n-      int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,\n+      int new_bs_i = find_or_append_bsm_entry(scratch_cp, old_bs_i, merge_cp_p,\n@@ -594,1 +595,1 @@\n-      if (scratch_cp->tag_at(scratch_i).is_dynamic_constant())\n+      if (scratch_cp->tag_at(scratch_i).is_dynamic_constant()) {\n@@ -596,1 +597,1 @@\n-      else\n+      } else {\n@@ -598,0 +599,1 @@\n+      }\n@@ -662,2 +664,2 @@\n-\/\/ Append a bootstrap specifier into the merge_cp operands that is semantically equal\n-\/\/ to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.\n+\/\/ Append a bootstrap specifier into the merge_cp BSM entries that is semantically equal\n+\/\/ to the scratch_cp BSM entries' bootstrap specifier passed by the old_bs_i index.\n@@ -665,1 +667,1 @@\n-void VM_RedefineClasses::append_operand(const constantPoolHandle& scratch_cp, const int old_bs_i,\n+int VM_RedefineClasses::append_bsm_entry(const constantPoolHandle& scratch_cp, const int old_bs_i,\n@@ -674,1 +676,1 @@\n-      (\"operands entry@%d bootstrap method ref_index change: %d to %d\", _operands_cur_length, old_ref_i, new_ref_i);\n+      (\"BSM attribute entry@%d bootstrap method ref_index change: %d to %d\", _bsmae_iter.current_offset() - 1, old_ref_i, new_ref_i);\n@@ -677,14 +679,6 @@\n-  Array<u2>* merge_ops = (*merge_cp_p)->operands();\n-  int new_bs_i = _operands_cur_length;\n-  \/\/ We have _operands_cur_length == 0 when the merge_cp operands is empty yet.\n-  \/\/ However, the operand_offset_at(0) was set in the extend_operands() call.\n-  int new_base = (new_bs_i == 0) ? (*merge_cp_p)->operand_offset_at(0)\n-                                 : (*merge_cp_p)->operand_next_offset_at(new_bs_i - 1);\n-  u2 argc      = old_bsme->argument_count();\n-\n-  ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);\n-  merge_ops->at_put(new_base++, new_ref_i);\n-  merge_ops->at_put(new_base++, argc);\n-\n-  for (int i = 0; i < argc; i++) {\n-    u2 old_arg_ref_i = old_bsme->argument_index(i);\n+  const int new_bs_i = _bsmae_iter.current_offset();\n+  BSMAttributeEntry* new_bsme =\n+    _bsmae_iter.reserve_new_entry(new_ref_i, old_bsme->argument_count());\n+  assert(new_bsme != nullptr, \"must be\");\n+  for (int i = 0; i < new_bsme->argument_count(); i++) {\n+    u2 old_arg_ref_i = old_bsme->argument(i);\n@@ -693,1 +687,2 @@\n-    merge_ops->at_put(new_base++, new_arg_ref_i);\n+    new_bsme->set_argument(i, new_arg_ref_i);\n+\n@@ -696,2 +691,2 @@\n-        (\"operands entry@%d bootstrap method argument ref_index change: %d to %d\",\n-         _operands_cur_length, old_arg_ref_i, new_arg_ref_i);\n+        (\"BSM attribute entry@%d bootstrap method argument ref_index change: %d to %d\",\n+         _bsmae_iter.current_offset() - 1, old_arg_ref_i, new_arg_ref_i);\n@@ -700,7 +695,4 @@\n-  if (old_bs_i != _operands_cur_length) {\n-    \/\/ The bootstrap specifier in *merge_cp_p is at a different index than\n-    \/\/ that in scratch_cp so we need to map the index values.\n-    map_operand_index(old_bs_i, new_bs_i);\n-  }\n-  _operands_cur_length++;\n-} \/\/ end append_operand()\n+  \/\/ This is only for the logging\n+  map_bsm_index(old_bs_i, new_bs_i);\n+  return new_bs_i;\n+} \/\/ end append_bsm_entry()\n@@ -709,1 +701,1 @@\n-int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle& scratch_cp,\n+int VM_RedefineClasses::find_or_append_bsm_entry(const constantPoolHandle& scratch_cp,\n@@ -712,0 +704,1 @@\n+  const int max_offset_in_merge = _bsmae_iter.current_offset();\n@@ -713,2 +706,4 @@\n-  bool match = (old_bs_i < _operands_cur_length) &&\n-               scratch_cp->compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i);\n+  \/\/ Has the old_bs_i index been used already? Check if it's the same so we know\n+  \/\/ whether or not a remapping is required.\n+  bool match = (old_bs_i < max_offset_in_merge) &&\n+               scratch_cp->compare_bootstrap_entry_to(old_bs_i, *merge_cp_p, old_bs_i);\n@@ -718,2 +713,2 @@\n-    int found_i = scratch_cp->find_matching_operand(old_bs_i, *merge_cp_p,\n-                                                    _operands_cur_length);\n+    int found_i = scratch_cp->find_matching_bsm_entry(old_bs_i, *merge_cp_p,\n+                                                      max_offset_in_merge);\n@@ -721,2 +716,2 @@\n-      guarantee(found_i != old_bs_i, \"compare_operand_to() and find_matching_operand() disagree\");\n-      \/\/ found a matching operand somewhere else in *merge_cp_p so just need a mapping\n+      guarantee(found_i != old_bs_i, \"compare_bootstrap_entry_to() and find_matching_bsm_entry() disagree\");\n+      \/\/ found a matching BSM entry somewhere else in *merge_cp_p so just need a mapping\n@@ -724,1 +719,1 @@\n-      map_operand_index(old_bs_i, found_i);\n+      map_bsm_index(old_bs_i, found_i);\n@@ -727,2 +722,1 @@\n-      append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p);\n-      new_bs_i = _operands_cur_length - 1;\n+      new_bs_i = append_bsm_entry(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p);\n@@ -732,1 +726,1 @@\n-} \/\/ end find_or_append_operand()\n+} \/\/ end find_or_append_bsm_entry()\n@@ -735,2 +729,2 @@\n-void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle& merge_cp, TRAPS) {\n-  if (merge_cp->operands() == nullptr) {\n+void VM_RedefineClasses::finalize_bsm_entries_merge(const constantPoolHandle& merge_cp, TRAPS) {\n+  if (merge_cp->bsm_entries().number_of_entries() == 0) {\n@@ -739,2 +733,2 @@\n-  \/\/ Shrink the merge_cp operands\n-  merge_cp->shrink_operands(_operands_cur_length, CHECK);\n+  \/\/ Finished extending the BSMAEs\n+  merge_cp->end_extension(_bsmae_iter, CHECK);\n@@ -745,2 +739,2 @@\n-    for (int i = 1; i < _operands_index_map_p->length(); i++) {\n-      int value = _operands_index_map_p->at(i);\n+    for (int i = 1; i < _bsm_index_map_p->length(); i++) {\n+      int value = _bsm_index_map_p->at(i);\n@@ -748,1 +742,1 @@\n-        log_trace(redefine, class, constantpool)(\"operands_index_map[%d]: old=%d new=%d\", count, i, value);\n+        log_trace(redefine, class, constantpool)(\"bsm_index_map[%d]: old=%d new=%d\", count, i, value);\n@@ -754,4 +748,4 @@\n-  _operands_index_map_p = nullptr;\n-  _operands_cur_length = 0;\n-  _operands_index_map_count = 0;\n-} \/\/ end finalize_operands_merge()\n+  _bsm_index_map_p = nullptr;\n+  _bsm_index_map_count = 0;\n+  _bsmae_iter = BSMAttributeEntries::InsertionIterator();\n+} \/\/ end finalize_bsmentries_merge()\n@@ -1274,2 +1268,2 @@\n-int VM_RedefineClasses::find_new_operand_index(int old_index) {\n-  if (_operands_index_map_count == 0) {\n+int VM_RedefineClasses::find_new_bsm_index(int old_index) {\n+  if (_bsm_index_map_count == 0) {\n@@ -1280,1 +1274,1 @@\n-  if (old_index == -1 || old_index >= _operands_index_map_p->length()) {\n+  if (old_index == -1 || old_index >= _bsm_index_map_p->length()) {\n@@ -1286,1 +1280,1 @@\n-  int value = _operands_index_map_p->at(old_index);\n+  int value = _bsm_index_map_p->at(old_index);\n@@ -1293,1 +1287,1 @@\n-} \/\/ end find_new_operand_index()\n+} \/\/ end find_new_bsm_index()\n@@ -1562,6 +1556,1 @@\n-void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {\n-  if (find_new_operand_index(old_index) != -1) {\n-    \/\/ old_index is already mapped\n-    return;\n-  }\n-\n+void VM_RedefineClasses::map_bsm_index(int old_index, int new_index) {\n@@ -1572,4 +1561,2 @@\n-\n-  _operands_index_map_p->at_put(old_index, new_index);\n-  _operands_index_map_count++;\n-\n+  _bsm_index_map_p->at_put(old_index, new_index);\n+  _bsm_index_map_count++;\n@@ -1577,1 +1564,1 @@\n-} \/\/ end map_index()\n+} \/\/ end map_bsm_index()\n@@ -1641,2 +1628,2 @@\n-    ConstantPool::copy_operands(old_cp, merge_cp_p, CHECK_false);\n-    merge_cp_p->extend_operands(scratch_cp, CHECK_false);\n+    ConstantPool::copy_bsm_entries(old_cp, merge_cp_p, CHECK_false);\n+    _bsmae_iter = merge_cp_p->start_extension(scratch_cp, CHECK_false);\n@@ -1739,1 +1726,1 @@\n-  finalize_operands_merge(merge_cp_p, CHECK_false);\n+  finalize_bsm_entries_merge(merge_cp_p, CHECK_false);\n@@ -1809,4 +1796,3 @@\n-  _operands_cur_length = ConstantPool::operand_array_length(old_cp->operands());\n-  _operands_index_map_count = 0;\n-  int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp->operands());\n-  _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);\n+  _bsm_index_map_count = 0;\n+  int bsm_data_len = scratch_cp->bsm_entries().array_length();\n+  _bsm_index_map_p = new intArray(bsm_data_len, bsm_data_len, -1);\n@@ -1814,1 +1800,1 @@\n-  \/\/ reference to the cp holder is needed for copy_operands()\n+  \/\/ reference to the cp holder is needed for reallocating the BSM attribute\n@@ -3552,1 +3538,1 @@\n-  \/\/ reference to the cp holder is needed for copy_operands()\n+  \/\/ reference to the cp holder is needed for reallocating the BSM attribute\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":66,"deletions":80,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -366,5 +366,10 @@\n-  \/\/ _operands_index_map_count is just an optimization for knowing if\n-  \/\/ _operands_index_map_p contains any entries.\n-  int                         _operands_cur_length;\n-  int                         _operands_index_map_count;\n-  intArray *                  _operands_index_map_p;\n+  \/\/ _bsm_index_map_count is just an optimization for knowing if\n+  \/\/ _bsm_index_map_p contains any entries.\n+  int                         _bsm_index_map_count;\n+  intArray *                  _bsm_index_map_p;\n+\n+  \/\/ After merge_constant_pools \"Pass 0\", the BSMAttribute entries of merge_cp_p will have been expanded to fit\n+  \/\/ scratch_cp's BSMAttribute entries as well.\n+  \/\/ However, the newly acquired space will not have been filled in yet.\n+  \/\/ To append to this new space, the iterator is used.\n+  BSMAttributeEntries::InsertionIterator _bsmae_iter;\n@@ -432,1 +437,2 @@\n-  void append_operand(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n+  \/\/ Returns the index of the appended BSM\n+  int append_bsm_entry(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n@@ -434,1 +440,1 @@\n-  void finalize_operands_merge(const constantPoolHandle& merge_cp, TRAPS);\n+  void finalize_bsm_entries_merge(const constantPoolHandle& merge_cp, TRAPS);\n@@ -437,1 +443,1 @@\n-  int find_or_append_operand(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n+  int find_or_append_bsm_entry(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n@@ -440,1 +446,1 @@\n-  int find_new_operand_index(int old_bootstrap_spec_index);\n+  int find_new_bsm_index(int old_bootstrap_spec_index);\n@@ -442,1 +448,1 @@\n-  void map_operand_index(int old_bootstrap_spec_index, int new_bootstrap_spec_index);\n+  void map_bsm_index(int old_bootstrap_spec_index, int new_bootstrap_spec_index);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1499,0 +1499,1 @@\n+  assert(is_power_of_2(_conservative_max_heap_alignment), \"Expected to be a power-of-2\");\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -548,0 +548,3 @@\n+  if (exec_mode == Unpack_deopt) {\n+    assert(deoptee.is_deoptimized_frame(), \"frame is not marked for deoptimization\");\n+  }\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    return nm->deopt_handler_begin() - pc_return_offset;\n+    return nm->deopt_handler_entry() - pc_return_offset;\n@@ -362,1 +362,1 @@\n-  address deopt = nm->deopt_handler_begin();\n+  address deopt = nm->deopt_handler_entry();\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+  static void   numa_set_thread_affinity(Thread* thread, int node);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,0 +96,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n@@ -610,0 +613,5 @@\n+#ifdef COMPILER2\n+      if (nm->compiler_type() == compiler_c2) {\n+        return OptoRuntime::exception_blob()->entry_point();\n+      }\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"oops\/bsmAttribute.hpp\"\n@@ -171,0 +172,3 @@\n+  nonstatic_field(BSMAttributeEntries,         _offsets,                                      Array<u4>*)                            \\\n+  nonstatic_field(BSMAttributeEntries,         _bootstrap_methods,                            Array<u2>*)                            \\\n+  nonstatic_field(ConstantPool,                _bsm_entries,                                  BSMAttributeEntries)                   \\\n@@ -174,1 +178,0 @@\n-  nonstatic_field(ConstantPool,                _operands,                                     Array<u2>*)                            \\\n@@ -539,1 +542,1 @@\n-  nonstatic_field(nmethod,                     _deopt_handler_offset,                         int)                                   \\\n+  nonstatic_field(nmethod,                     _deopt_handler_entry_offset,                   int)                                   \\\n@@ -738,0 +741,1 @@\n+  unchecked_nonstatic_field(Array<u4>,                 _data,                                 sizeof(u4))                            \\\n@@ -972,0 +976,1 @@\n+  declare_toplevel_type(BSMAttributeEntries)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  assert(!Universe::is_shutting_down(), \"Should not query during shutdown\");\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -169,0 +170,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<AOTEndRecordingDCmd>(full_export, true, false));\n@@ -1014,0 +1016,22 @@\n+#if INCLUDE_CDS\n+void AOTEndRecordingDCmd::execute(DCmdSource source, TRAPS) {\n+  if (!CDSConfig::is_dumping_preimage_static_archive()) {\n+    output()->print_cr(\"AOT.end_recording is unsupported when VM flags -XX:AOTMode=record or -XX:AOTCacheOutput=<file> are missing.\");\n+    return;\n+  }\n+\n+  if (AOTMetaspace::preimage_static_archive_dumped()) {\n+    output()->print_cr(\"Recording has already ended.\");\n+    return;\n+  }\n+\n+  AOTMetaspace::dump_static_archive(THREAD);\n+  if (!AOTMetaspace::preimage_static_archive_dumped()) {\n+    output()->print_cr(\"Error: Failed to end recording.\");\n+    return;\n+  }\n+\n+  output()->print_cr(\"Recording ended successfully.\");\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -348,0 +348,15 @@\n+#if INCLUDE_CDS\n+class AOTEndRecordingDCmd : public DCmd {\n+public:\n+  AOTEndRecordingDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"AOT.end_recording\"; }\n+    static const char* description() {\n+      return \"End AOT recording.\";\n+    }\n+    static const char* impact() {\n+      return \"Medium: Pause time depends on number of loaded classes\";\n+    }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -667,0 +667,1 @@\n+      _thread != nullptr &&\n@@ -1308,1 +1309,1 @@\n-  STEP_IF(\"Native Memory Tracking\", _verbose)\n+  STEP_IF(\"Native Memory Tracking\", _verbose && _thread != nullptr)\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.Serial;\n@@ -30,2 +31,11 @@\n-import java.security.*;\n-import java.security.interfaces.ECKey;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n@@ -33,1 +43,0 @@\n-import java.security.interfaces.XECKey;\n@@ -35,1 +44,10 @@\n-import java.security.spec.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.ECPoint;\n+import java.security.spec.ECPrivateKeySpec;\n+import java.security.spec.ECPublicKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.XECPrivateKeySpec;\n+import java.security.spec.XECPublicKeySpec;\n@@ -38,2 +56,6 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.SecretKey;\n@@ -41,0 +63,1 @@\n+import javax.crypto.spec.SecretKeySpec;\n@@ -43,3 +66,6 @@\n-import sun.security.util.*;\n-\n-import jdk.internal.access.SharedSecrets;\n+import sun.security.util.ArrayUtil;\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+import sun.security.util.InternalPrivateKey;\n+import sun.security.util.NamedCurve;\n+import sun.security.util.SliceableSecretKey;\n@@ -48,1 +74,0 @@\n-\/\/ without the AuthEncap and AuthDecap functions\n@@ -68,1 +93,2 @@\n-                           PrivateKey skR, PublicKey pkR)\n+                           PrivateKey skS, PublicKey pkS, \/\/ sender keys\n+                           PrivateKey skR, PublicKey pkR) \/\/ receiver keys\n@@ -73,1 +99,1 @@\n-            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.checkFromToIndex(from, to, params.nsecret);\n@@ -78,4 +104,2 @@\n-            byte[] pkEm = params.SerializePublicKey(pkE);\n-            byte[] pkRm = params.SerializePublicKey(pkR);\n-            byte[] kem_context = concat(pkEm, pkRm);\n-            byte[] key = null;\n+            byte[] pkEm = params.serializePublicKey(pkE);\n+            byte[] pkRm = params.serializePublicKey(pkR);\n@@ -83,5 +107,14 @@\n-                byte[] dh = params.DH(skE, pkR);\n-                key = params.ExtractAndExpand(dh, kem_context);\n-                return new KEM.Encapsulated(\n-                        new SecretKeySpec(key, from, to - from, algorithm),\n-                        pkEm, null);\n+                SecretKey key;\n+                if (skS == null) {\n+                    byte[] kem_context = concat(pkEm, pkRm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.dh(skE, pkR));\n+                } else {\n+                    byte[] pkSm = params.serializePublicKey(pkS);\n+                    byte[] kem_context = concat(pkEm, pkRm, pkSm);\n+                    key = params.deriveKey(algorithm, from, to, kem_context,\n+                            params.dh(skE, pkR), params.dh(skS, pkR));\n+                }\n+                return new KEM.Encapsulated(key, pkEm, null);\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -90,6 +123,0 @@\n-            } finally {\n-                \/\/ `key` has been cloned into the `SecretKeySpec` within the\n-                \/\/ returned `KEM.Encapsulated`, so it can now be cleared.\n-                if (key != null) {\n-                    Arrays.fill(key, (byte)0);\n-                }\n@@ -102,1 +129,1 @@\n-            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.checkFromToIndex(from, to, params.nsecret);\n@@ -105,1 +132,1 @@\n-            if (encapsulation.length != params.Npk) {\n+            if (encapsulation.length != params.npk) {\n@@ -108,1 +135,0 @@\n-            byte[] key = null;\n@@ -110,6 +136,14 @@\n-                PublicKey pkE = params.DeserializePublicKey(encapsulation);\n-                byte[] dh = params.DH(skR, pkE);\n-                byte[] pkRm = params.SerializePublicKey(pkR);\n-                byte[] kem_context = concat(encapsulation, pkRm);\n-                key = params.ExtractAndExpand(dh, kem_context);\n-                return new SecretKeySpec(key, from, to - from, algorithm);\n+                PublicKey pkE = params.deserializePublicKey(encapsulation);\n+                byte[] pkRm = params.serializePublicKey(pkR);\n+                if (pkS == null) {\n+                    byte[] kem_context = concat(encapsulation, pkRm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.dh(skR, pkE));\n+                } else {\n+                    byte[] pkSm = params.serializePublicKey(pkS);\n+                    byte[] kem_context = concat(encapsulation, pkRm, pkSm);\n+                    return params.deriveKey(algorithm, from, to, kem_context,\n+                            params.dh(skR, pkE), params.dh(skR, pkS));\n+                }\n+            } catch (UnsupportedOperationException e) {\n+                throw e;\n@@ -120,4 +154,0 @@\n-            } finally {\n-                if (key != null) {\n-                    Arrays.fill(key, (byte)0);\n-                }\n@@ -129,1 +159,1 @@\n-            return params.Nsecret;\n+            return params.nsecret;\n@@ -134,1 +164,1 @@\n-            return params.Npk;\n+            return params.npk;\n@@ -141,1 +171,2 @@\n-        static final long serialVersionUID = 0L;\n+        @Serial\n+        private static final long serialVersionUID = 0L;\n@@ -150,1 +181,1 @@\n-        public KeyPair derive(Params params) {\n+        private KeyPair derive(Params params) {\n@@ -186,3 +217,3 @@\n-        private final int Nsecret;\n-        private final int Nsk;\n-        private final int Npk;\n+        private final int nsecret;\n+        private final int nsk;\n+        private final int npk;\n@@ -196,1 +227,1 @@\n-        Params(int kem_id, int Nsecret, int Nsk, int Npk,\n+        Params(int kem_id, int nsecret, int nsk, int npk,\n@@ -201,3 +232,3 @@\n-            this.Nsecret = Nsecret;\n-            this.Nsk = Nsk;\n-            this.Npk = Npk;\n+            this.nsecret = nsecret;\n+            this.nsk = nsk;\n+            this.npk = npk;\n@@ -207,1 +238,1 @@\n-            suiteId = concat(KEM, I2OSP(kem_id, 2));\n+            suiteId = concat(KEM, i2OSP(kem_id, 2));\n@@ -227,1 +258,1 @@\n-        private byte[] SerializePublicKey(PublicKey k) {\n+        private byte[] serializePublicKey(PublicKey k) {\n@@ -234,1 +265,1 @@\n-                return Arrays.copyOf(uArray, Npk);\n+                return Arrays.copyOf(uArray, npk);\n@@ -238,1 +269,1 @@\n-        private PublicKey DeserializePublicKey(byte[] data)\n+        private PublicKey deserializePublicKey(byte[] data)\n@@ -254,1 +285,1 @@\n-        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+        private SecretKey dh(PrivateKey skE, PublicKey pkR)\n@@ -259,1 +290,1 @@\n-            return ka.generateSecret();\n+            return ka.generateSecret(\"Generic\");\n@@ -262,11 +293,28 @@\n-        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n-                throws NoSuchAlgorithmException, InvalidKeyException {\n-            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n-            SecretKey eae_prk = LabeledExtract(hkdf, suiteId, EAE_PRK, dh);\n-            try {\n-                return LabeledExpand(hkdf, suiteId, eae_prk, SHARED_SECRET,\n-                        kem_context, Nsecret);\n-            } finally {\n-                if (eae_prk instanceof SecretKeySpec s) {\n-                    SharedSecrets.getJavaxCryptoSpecAccess()\n-                            .clearSecretKeySpec(s);\n+        \/\/ The final shared secret derivation of either the encapsulator\n+        \/\/ or the decapsulator. The key slicing is implemented inside.\n+        \/\/ Throws UOE if a slice of the key cannot be found.\n+        private SecretKey deriveKey(String alg, int from, int to,\n+                byte[] kem_context, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            if (from == 0 && to == nsecret) {\n+                return extractAndExpand(kem_context, alg, dhs);\n+            } else {\n+                \/\/ First get shared secrets in \"Generic\" and then get a slice\n+                \/\/ of it in the requested algorithm.\n+                var fullKey = extractAndExpand(kem_context, \"Generic\", dhs);\n+                if (\"RAW\".equalsIgnoreCase(fullKey.getFormat())) {\n+                    byte[] km = fullKey.getEncoded();\n+                    if (km == null) {\n+                        \/\/ Should not happen if format is \"RAW\"\n+                        throw new UnsupportedOperationException(\"Key extract failed\");\n+                    } else {\n+                        try {\n+                            return new SecretKeySpec(km, from, to - from, alg);\n+                        } finally {\n+                            Arrays.fill(km, (byte)0);\n+                        }\n+                    }\n+                } else if (fullKey instanceof SliceableSecretKey ssk) {\n+                    return ssk.slice(alg, from, to);\n+                } else {\n+                    throw new UnsupportedOperationException(\"Cannot extract key\");\n@@ -277,0 +325,13 @@\n+        private SecretKey extractAndExpand(byte[] kem_context, String alg, SecretKey... dhs)\n+                throws NoSuchAlgorithmException {\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, EAE_PRK);\n+            for (var dh : dhs) builder.addIKM(dh);\n+            try {\n+                return kdf.deriveKey(alg,\n+                        labeledExpand(builder, suiteId, SHARED_SECRET, kem_context, nsecret));\n+            } catch (InvalidAlgorithmParameterException e) {\n+                throw new ProviderException(e);\n+            }\n+        }\n+\n@@ -301,21 +362,10 @@\n-            KDF hkdf = KDF.getInstance(hkdfAlgorithm);\n-            SecretKey dkp_prk = LabeledExtract(hkdf, suiteId, DKP_PRK, ikm);\n-            try {\n-                if (isEC()) {\n-                    NamedCurve curve = (NamedCurve) spec;\n-                    BigInteger sk = BigInteger.ZERO;\n-                    int counter = 0;\n-                    while (sk.signum() == 0 ||\n-                            sk.compareTo(curve.getOrder()) >= 0) {\n-                        if (counter > 255) {\n-                            throw new RuntimeException();\n-                        }\n-                        byte[] bytes = LabeledExpand(hkdf, suiteId, dkp_prk,\n-                                CANDIDATE, I2OSP(counter, 1), Nsk);\n-                        \/\/ bitmask is defined to be 0xFF for P-256 and P-384,\n-                        \/\/ and 0x01 for P-521\n-                        if (this == Params.P521) {\n-                            bytes[0] = (byte) (bytes[0] & 0x01);\n-                        }\n-                        sk = new BigInteger(1, (bytes));\n-                        counter = counter + 1;\n+            var kdf = KDF.getInstance(hkdfAlgorithm);\n+            var builder = labeledExtract(suiteId, DKP_PRK).addIKM(ikm);\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) spec;\n+                BigInteger sk = BigInteger.ZERO;\n+                int counter = 0;\n+                while (sk.signum() == 0 || sk.compareTo(curve.getOrder()) >= 0) {\n+                    if (counter > 255) {\n+                        \/\/ So unlucky and should not happen\n+                        throw new ProviderException(\"DeriveKeyPairError\");\n@@ -323,12 +373,8 @@\n-                    PrivateKey k = DeserializePrivateKey(sk.toByteArray());\n-                    return new KeyPair(getPublicKey(k), k);\n-                } else {\n-                    byte[] sk = LabeledExpand(hkdf, suiteId, dkp_prk, SK, EMPTY,\n-                            Nsk);\n-                    PrivateKey k = DeserializePrivateKey(sk);\n-                    return new KeyPair(getPublicKey(k), k);\n-                }\n-            } finally {\n-                if (dkp_prk instanceof SecretKeySpec s) {\n-                    SharedSecrets.getJavaxCryptoSpecAccess()\n-                            .clearSecretKeySpec(s);\n+                    byte[] bytes = kdf.deriveData(labeledExpand(builder,\n+                            suiteId, CANDIDATE, i2OSP(counter, 1), nsk));\n+                    \/\/ bitmask is defined to be 0xFF for P-256 and P-384, and 0x01 for P-521\n+                    if (this == Params.P521) {\n+                        bytes[0] = (byte) (bytes[0] & 0x01);\n+                    }\n+                    sk = new BigInteger(1, (bytes));\n+                    counter = counter + 1;\n@@ -336,0 +382,7 @@\n+                PrivateKey k = deserializePrivateKey(sk.toByteArray());\n+                return new KeyPair(getPublicKey(k), k);\n+            } else {\n+                byte[] sk = kdf.deriveData(labeledExpand(builder,\n+                        suiteId, SK, EMPTY, nsk));\n+                PrivateKey k = deserializePrivateKey(sk);\n+                return new KeyPair(getPublicKey(k), k);\n@@ -339,1 +392,1 @@\n-        private PrivateKey DeserializePrivateKey(byte[] data) throws Exception {\n+        private PrivateKey deserializePrivateKey(byte[] data) throws Exception {\n@@ -362,1 +415,16 @@\n-        return new Handler(params, getSecureRandom(secureRandom), null, pk);\n+        return new Handler(params, getSecureRandom(secureRandom), null, null, null, pk);\n+    }\n+\n+    \/\/ AuthEncap is not public KEM API\n+    public EncapsulatorSpi engineNewAuthEncapsulator(PublicKey pkR, PrivateKey skS,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (pkR == null || skS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(pkR);\n+        return new Handler(params, getSecureRandom(secureRandom),\n+                skS, params.getPublicKey(skS), null, pkR);\n@@ -375,1 +443,15 @@\n-        return new Handler(params, null, sk, params.getPublicKey(sk));\n+        return new Handler(params, null, null, null, sk, params.getPublicKey(sk));\n+    }\n+\n+    \/\/ AuthDecap is not public KEM API\n+    public DecapsulatorSpi engineNewAuthDecapsulator(\n+            PrivateKey skR, PublicKey pkS, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (skR == null || pkS == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(skR);\n+        return new Handler(params, null, null, pkS, skR, params.getPublicKey(skR));\n@@ -378,3 +460,4 @@\n-    private Params paramsFromKey(Key k) throws InvalidKeyException {\n-        if (k instanceof ECKey eckey) {\n-            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+    private Params paramsFromKey(AsymmetricKey k) throws InvalidKeyException {\n+        var p = k.getParams();\n+        if (p instanceof ECParameterSpec ecp) {\n+            if (ECUtil.equals(ecp, CurveDB.P_256)) {\n@@ -382,1 +465,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_384)) {\n@@ -384,1 +467,1 @@\n-            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+            } else if (ECUtil.equals(ecp, CurveDB.P_521)) {\n@@ -387,2 +470,1 @@\n-        } else if (k instanceof XECKey xkey\n-                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+        } else if (p instanceof NamedParameterSpec ns) {\n@@ -404,2 +486,5 @@\n-    private static byte[] I2OSP(int n, int w) {\n-        assert n < 256;\n+    \/\/ I2OSP(n, w) as defined in RFC 9180 Section 3.\n+    \/\/ In DHKEM and HPKE, number is always <65536\n+    \/\/ and converted to at most 2 bytes.\n+    public static byte[] i2OSP(int n, int w) {\n+        assert n < 65536;\n@@ -414,14 +499,6 @@\n-    private static SecretKey LabeledExtract(KDF hkdf, byte[] suite_id,\n-            byte[] label, byte[] ikm) throws InvalidKeyException {\n-        SecretKeySpec s = new SecretKeySpec(concat(HPKE_V1, suite_id, label,\n-                ikm), \"IKM\");\n-        try {\n-            HKDFParameterSpec spec =\n-                    HKDFParameterSpec.ofExtract().addIKM(s).extractOnly();\n-            return hkdf.deriveKey(\"Generic\", spec);\n-        } catch (InvalidAlgorithmParameterException |\n-                 NoSuchAlgorithmException e) {\n-            throw new InvalidKeyException(e.getMessage(), e);\n-        } finally {\n-            SharedSecrets.getJavaxCryptoSpecAccess().clearSecretKeySpec(s);\n-        }\n+    \/\/ Create a LabeledExtract builder with labels.\n+    \/\/ You can add more IKM and salt into the result.\n+    public static HKDFParameterSpec.Builder labeledExtract(\n+            byte[] suiteId, byte[] label) {\n+        return HKDFParameterSpec.ofExtract()\n+                .addIKM(HPKE_V1).addIKM(suiteId).addIKM(label);\n@@ -430,11 +507,19 @@\n-    private static byte[] LabeledExpand(KDF hkdf, byte[] suite_id,\n-            SecretKey prk, byte[] label, byte[] info, int L)\n-            throws InvalidKeyException {\n-        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1, suite_id, label,\n-                info);\n-        try {\n-            return hkdf.deriveData(HKDFParameterSpec.expandOnly(\n-                    prk, labeled_info, L));\n-        } catch (InvalidAlgorithmParameterException iape) {\n-            throw new InvalidKeyException(iape.getMessage(), iape);\n-        }\n+    \/\/ Create a labeled info from info and labels\n+    private static byte[] labeledInfo(\n+            byte[] suiteId, byte[] label, byte[] info, int length) {\n+        return concat(i2OSP(length, 2), HPKE_V1, suiteId, label, info);\n+    }\n+\n+    \/\/ LabeledExpand from a builder\n+    public static HKDFParameterSpec labeledExpand(\n+            HKDFParameterSpec.Builder builder,\n+            byte[] suiteId, byte[] label, byte[] info, int length) {\n+        return builder.thenExpand(\n+                labeledInfo(suiteId, label, info, length), length);\n+    }\n+\n+    \/\/ LabeledExpand from a prk\n+    public static HKDFParameterSpec labeledExpand(\n+            SecretKey prk, byte[] suiteId, byte[] label, byte[] info, int length) {\n+        return HKDFParameterSpec.expandOnly(\n+                prk, labeledInfo(suiteId, label, info, length), length);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":223,"deletions":138,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -0,0 +1,588 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.crypto.provider;\n+\n+import sun.security.util.CurveDB;\n+import sun.security.util.ECUtil;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherSpi;\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.KDF;\n+import javax.crypto.KEM;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.ShortBufferException;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.security.AlgorithmParameters;\n+import java.security.AsymmetricKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.ECParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+\n+public class HPKE extends CipherSpi {\n+\n+    private static final byte[] HPKE = new byte[]\n+            {'H', 'P', 'K', 'E'};\n+    private static final byte[] SEC = new byte[]\n+            {'s', 'e', 'c'};\n+    private static final byte[] PSK_ID_HASH = new byte[]\n+            {'p', 's', 'k', '_', 'i', 'd', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] INFO_HASH = new byte[]\n+            {'i', 'n', 'f', 'o', '_', 'h', 'a', 's', 'h'};\n+    private static final byte[] SECRET = new byte[]\n+            {'s', 'e', 'c', 'r', 'e', 't'};\n+    private static final byte[] EXP = new byte[]\n+            {'e', 'x', 'p'};\n+    private static final byte[] KEY = new byte[]\n+            {'k', 'e', 'y'};\n+    private static final byte[] BASE_NONCE = new byte[]\n+            {'b', 'a', 's', 'e', '_', 'n', 'o', 'n', 'c', 'e'};\n+\n+    private static final int BEGIN = 1;\n+    private static final int EXPORT_ONLY = 2; \/\/ init done with aead_id == 65535\n+    private static final int ENCRYPT_AND_EXPORT = 3; \/\/ int done with AEAD\n+    private static final int AFTER_FINAL = 4; \/\/ after doFinal, need reinit internal cipher\n+\n+    private int state = BEGIN;\n+    private Impl impl;\n+\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        throw new NoSuchAlgorithmException(mode);\n+    }\n+\n+    @Override\n+    protected void engineSetPadding(String padding) throws NoSuchPaddingException {\n+        throw new NoSuchPaddingException(padding);\n+    }\n+\n+    @Override\n+    protected int engineGetBlockSize() {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getBlockSize();\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        if (state == ENCRYPT_AND_EXPORT || state == AFTER_FINAL) {\n+            return impl.aead.cipher.getOutputSize(inputLen);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return (state == BEGIN || impl.kemEncaps == null)\n+                ? null : impl.kemEncaps.clone();\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+            throws InvalidKeyException {\n+        throw new InvalidKeyException(\"HPKEParameterSpec must be provided\");\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        impl = new Impl(opmode);\n+        if (!(key instanceof AsymmetricKey ak)) {\n+            throw new InvalidKeyException(\"Not an asymmetric key\");\n+        }\n+        if (params == null) {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"HPKEParameterSpec must be provided\");\n+        } else if (params instanceof HPKEParameterSpec hps) {\n+            impl.init(ak, hps, random);\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unsupported params type: \" + params.getClass());\n+        }\n+        if (impl.hasEncrypt()) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.computeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        } else {\n+            state = EXPORT_ONLY;\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameters params, SecureRandom random)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        throw new InvalidKeyException(\"HPKEParameterSpec must be provided\");\n+    }\n+\n+    \/\/ state is ENCRYPT_AND_EXPORT after this call succeeds\n+    private void maybeReinitInternalCipher() {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"Illegal state: \" + state);\n+        }\n+        if (state == EXPORT_ONLY) {\n+            throw new UnsupportedOperationException();\n+        }\n+        if (state == AFTER_FINAL) {\n+            impl.aead.start(impl.opmode, impl.context.k, impl.context.computeNonce());\n+            state = ENCRYPT_AND_EXPORT;\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(input, inputOffset, inputLen);\n+    }\n+\n+    @Override\n+    protected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException {\n+        maybeReinitInternalCipher();\n+        return impl.aead.cipher.update(\n+                input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(byte[] src, int offset, int len) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src, offset, len);\n+    }\n+\n+    @Override\n+    protected void engineUpdateAAD(ByteBuffer src) {\n+        maybeReinitInternalCipher();\n+        impl.aead.cipher.updateAAD(src);\n+    }\n+\n+    @Override\n+    protected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)\n+            throws IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        if (input == null) { \/\/ a bug in doFinal(null, ?, ?)\n+            return impl.aead.cipher.doFinal();\n+        } else {\n+            return impl.aead.cipher.doFinal(input, inputOffset, inputLen);\n+        }\n+    }\n+\n+    @Override\n+    protected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n+            byte[] output, int outputOffset) throws ShortBufferException,\n+            IllegalBlockSizeException, BadPaddingException {\n+        maybeReinitInternalCipher();\n+        impl.context.IncrementSeq();\n+        state = AFTER_FINAL;\n+        return impl.aead.cipher.doFinal(\n+                input, inputOffset, inputLen, output, outputOffset);\n+    }\n+\n+    \/\/@Override\n+    protected SecretKey engineExportKey(String algorithm, byte[] context, int length) {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"State: \" + state);\n+        } else {\n+            return impl.context.exportKey(algorithm, context, length);\n+        }\n+    }\n+\n+    \/\/@Override\n+    protected byte[] engineExportData(byte[] context, int length) {\n+        if (state == BEGIN) {\n+            throw new IllegalStateException(\"State: \" + state);\n+        } else {\n+            return impl.context.exportData(context, length);\n+        }\n+    }\n+\n+    private static class AEAD {\n+        final Cipher cipher;\n+        final int nk, nn, nt;\n+        final int id;\n+        public AEAD(int id) throws InvalidAlgorithmParameterException {\n+            this.id = id;\n+            try {\n+                switch (id) {\n+                    case HPKEParameterSpec.AEAD_AES_128_GCM -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        nk = 16;\n+                    }\n+                    case HPKEParameterSpec.AEAD_AES_256_GCM -> {\n+                        cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+                        nk = 32;\n+                    }\n+                    case HPKEParameterSpec.AEAD_CHACHA20_POLY1305 -> {\n+                        cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+                        nk = 32;\n+                    }\n+                    case HPKEParameterSpec.EXPORT_ONLY -> {\n+                        cipher = null;\n+                        nk = -1;\n+                    }\n+                    default -> throw new InvalidAlgorithmParameterException(\n+                            \"Unknown aead_id: \" + id);\n+                }\n+            } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+            nn = 12; nt = 16;\n+        }\n+\n+        void start(int opmode, SecretKey key, byte[] nonce) {\n+            try {\n+                if (id == HPKEParameterSpec.AEAD_CHACHA20_POLY1305) {\n+                    cipher.init(opmode, key, new IvParameterSpec(nonce));\n+                } else {\n+                    cipher.init(opmode, key, new GCMParameterSpec(nt * 8, nonce));\n+                }\n+            } catch (InvalidAlgorithmParameterException | InvalidKeyException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+    }\n+\n+    private static class Impl {\n+\n+        final int opmode;\n+\n+        HPKEParameterSpec params;\n+        Context context;\n+        AEAD aead;\n+\n+        byte[] suite_id;\n+        String kdfAlg;\n+        int kdfNh;\n+\n+        \/\/ only used on sender side\n+        byte[] kemEncaps;\n+\n+        class Context {\n+            final SecretKey k; \/\/ null if only export\n+            final byte[] base_nonce;\n+            final SecretKey exporter_secret;\n+\n+            byte[] seq = new byte[aead.nn];\n+\n+            public Context(SecretKey sk, byte[] base_nonce,\n+                    SecretKey exporter_secret) {\n+                this.k = sk;\n+                this.base_nonce = base_nonce;\n+                this.exporter_secret = exporter_secret;\n+            }\n+\n+            SecretKey exportKey(String algorithm, byte[] exporter_context, int length) {\n+                if (exporter_context == null) {\n+                    throw new IllegalArgumentException(\"Null exporter_context\");\n+                }\n+                try {\n+                    var kdf = KDF.getInstance(kdfAlg);\n+                    return kdf.deriveKey(algorithm, DHKEM.labeledExpand(\n+                            exporter_secret, suite_id, SEC, exporter_context, length));\n+                } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+                    \/\/ algorithm not accepted by HKDF, length too big or too small\n+                    throw new IllegalArgumentException(\"Invalid input\", e);\n+                }\n+            }\n+\n+            byte[] exportData(byte[] exporter_context, int length) {\n+                if (exporter_context == null) {\n+                    throw new IllegalArgumentException(\"Null exporter_context\");\n+                }\n+                try {\n+                    var kdf = KDF.getInstance(kdfAlg);\n+                    return kdf.deriveData(DHKEM.labeledExpand(\n+                            exporter_secret, suite_id, SEC, exporter_context, length));\n+                } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException e) {\n+                    \/\/ algorithm not accepted by HKDF, length too big or too small\n+                    throw new IllegalArgumentException(\"Invalid input\", e);\n+                }\n+            }\n+\n+            private byte[] computeNonce() {\n+                var result = new byte[aead.nn];\n+                for (var i = 0; i < result.length; i++) {\n+                    result[i] = (byte)(seq[i] ^ base_nonce[i]);\n+                }\n+                return result;\n+            }\n+\n+            private void IncrementSeq() {\n+                for (var i = seq.length - 1; i >= 0; i--) {\n+                    if ((seq[i] & 0xff) == 0xff) {\n+                        seq[i] = 0;\n+                    } else {\n+                        seq[i]++;\n+                        return;\n+                    }\n+                }\n+                \/\/ seq >= (1 << (8*aead.Nn)) - 1 when this method is called\n+                throw new ProviderException(\"MessageLimitReachedError\");\n+            }\n+        }\n+\n+        public Impl(int opmode) {\n+            this.opmode = opmode;\n+        }\n+\n+        public boolean hasEncrypt() {\n+            return params.aead_id() != 65535;\n+        }\n+\n+        \/\/ Section 7.2.1 of RFC 9180 has restrictions on size of psk, psk_id,\n+        \/\/ info, and exporter_context (~2^61 for HMAC-SHA256 and ~2^125 for\n+        \/\/ HMAC-SHA384 and HMAC-SHA512). This method does not pose any\n+        \/\/ restrictions.\n+        public void init(AsymmetricKey key, HPKEParameterSpec p, SecureRandom rand)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            if (opmode != Cipher.ENCRYPT_MODE && opmode != Cipher.DECRYPT_MODE) {\n+                throw new UnsupportedOperationException(\n+                        \"Can only be used for encryption and decryption\");\n+            }\n+            setParams(p);\n+            SecretKey shared_secret;\n+            if (opmode == Cipher.ENCRYPT_MODE) {\n+                if (!(key instanceof PublicKey pk)) {\n+                    throw new InvalidKeyException(\n+                            \"Cannot encrypt with private key\");\n+                }\n+                if (p.encapsulation() != null) {\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Must not provide key encapsulation message on sender side\");\n+                }\n+                checkMatch(false, pk, params.kem_id());\n+                KEM.Encapsulated enc;\n+                switch (p.authKey()) {\n+                    case null -> {\n+                        var e = kem().newEncapsulator(pk, rand);\n+                        enc = e.encapsulate();\n+                    }\n+                    case PrivateKey skS -> {\n+                        checkMatch(true, skS, params.kem_id());\n+                        \/\/ AuthEncap not public KEM API but it's internally supported\n+                        var e = new DHKEM().engineNewAuthEncapsulator(pk, skS, null, rand);\n+                        enc = e.engineEncapsulate(0, e.engineSecretSize(), \"Generic\");\n+                    }\n+                    default -> throw new InvalidAlgorithmParameterException(\n+                            \"Cannot auth with public key\");\n+                }\n+                kemEncaps = enc.encapsulation();\n+                shared_secret = enc.key();\n+            } else {\n+                if (!(key instanceof PrivateKey sk)) {\n+                    throw new InvalidKeyException(\"Cannot decrypt with public key\");\n+                }\n+                checkMatch(false, sk, params.kem_id());\n+                try {\n+                    var encap = p.encapsulation();\n+                    if (encap == null) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"Must provide key encapsulation message on recipient side\");\n+                    }\n+                    switch (p.authKey()) {\n+                        case null -> {\n+                            var d = kem().newDecapsulator(sk);\n+                            shared_secret = d.decapsulate(encap);\n+                        }\n+                        case PublicKey pkS -> {\n+                            checkMatch(true, pkS, params.kem_id());\n+                            \/\/ AuthDecap not public KEM API but it's internally supported\n+                            var d = new DHKEM().engineNewAuthDecapsulator(sk, pkS, null);\n+                            shared_secret = d.engineDecapsulate(\n+                                    encap, 0, d.engineSecretSize(), \"Generic\");\n+                        }\n+                        default -> throw new InvalidAlgorithmParameterException(\n+                                \"Cannot auth with private key\");\n+                    }\n+                } catch (DecapsulateException e) {\n+                    throw new InvalidAlgorithmParameterException(e);\n+                }\n+            }\n+\n+            var usePSK = usePSK(params.psk());\n+            int mode = params.authKey() == null ? (usePSK ? 1 : 0) : (usePSK ? 3 : 2);\n+            context = keySchedule(mode, shared_secret,\n+                    params.info(),\n+                    params.psk(),\n+                    params.psk_id());\n+        }\n+\n+        private static void checkMatch(boolean inSpec, AsymmetricKey k, int kem_id)\n+                throws InvalidKeyException, InvalidAlgorithmParameterException {\n+            var p = k.getParams();\n+            switch (p) {\n+                case ECParameterSpec ecp -> {\n+                    if ((!ECUtil.equals(ecp, CurveDB.P_256)\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256)\n+                            && (!ECUtil.equals(ecp, CurveDB.P_384)\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384)\n+                            && (!ECUtil.equals(ecp, CurveDB.P_521)\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512)) {\n+                        var name = ECUtil.getCurveName(ecp);\n+                        throw new InvalidAlgorithmParameterException(\n+                                name + \" does not match \" + kem_id);\n+                    }\n+                }\n+                case NamedParameterSpec ns -> {\n+                    var name = ns.getName();\n+                    if ((!name.equalsIgnoreCase(\"x25519\")\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256)\n+                            && (!name.equalsIgnoreCase(\"x448\")\n+                            || kem_id != HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512)) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                name + \" does not match \" + kem_id);\n+                    }\n+                }\n+                case null, default -> {\n+                    var msg = k.getClass() + \" does not match \" + kem_id;\n+                    if (inSpec) {\n+                        throw new InvalidAlgorithmParameterException(msg);\n+                    } else {\n+                        throw new InvalidKeyException(msg);\n+                    }\n+                }\n+            }\n+        }\n+\n+        private KEM kem() {\n+            try {\n+                return KEM.getInstance(\"DHKEM\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+\n+        private void setParams(HPKEParameterSpec p)\n+                throws InvalidAlgorithmParameterException {\n+            params = p;\n+            suite_id = concat(\n+                    HPKE,\n+                    DHKEM.i2OSP(params.kem_id(), 2),\n+                    DHKEM.i2OSP(params.kdf_id(), 2),\n+                    DHKEM.i2OSP(params.aead_id(), 2));\n+            switch (params.kdf_id()) {\n+                case HPKEParameterSpec.KDF_HKDF_SHA256 -> {\n+                    kdfAlg = \"HKDF-SHA256\";\n+                    kdfNh = 32;\n+                }\n+                case HPKEParameterSpec.KDF_HKDF_SHA384 -> {\n+                    kdfAlg = \"HKDF-SHA384\";\n+                    kdfNh = 48;\n+                }\n+                case HPKEParameterSpec.KDF_HKDF_SHA512 -> {\n+                    kdfAlg = \"HKDF-SHA512\";\n+                    kdfNh = 64;\n+                }\n+                default -> throw new InvalidAlgorithmParameterException(\n+                        \"Unsupported kdf_id: \" + params.kdf_id());\n+            }\n+            aead = new AEAD(params.aead_id());\n+        }\n+\n+        private Context keySchedule(int mode,\n+                SecretKey shared_secret,\n+                byte[] info,\n+                SecretKey psk,\n+                byte[] psk_id) {\n+            try {\n+                var psk_id_hash_x = DHKEM.labeledExtract(suite_id, PSK_ID_HASH)\n+                        .addIKM(psk_id).extractOnly();\n+                var info_hash_x = DHKEM.labeledExtract(suite_id, INFO_HASH)\n+                        .addIKM(info).extractOnly();\n+\n+                \/\/ deriveData must and can be called because all info to\n+                \/\/ thw builder are just byte arrays. Any KDF impl can handle this.\n+                var kdf = KDF.getInstance(kdfAlg);\n+                var key_schedule_context = concat(new byte[]{(byte) mode},\n+                        kdf.deriveData(psk_id_hash_x),\n+                        kdf.deriveData(info_hash_x));\n+\n+                var secret_x_builder = DHKEM.labeledExtract(suite_id, SECRET);\n+                if (psk != null) {\n+                    secret_x_builder.addIKM(psk);\n+                }\n+                secret_x_builder.addSalt(shared_secret);\n+                var secret_x = kdf.deriveKey(\"Generic\", secret_x_builder.extractOnly());\n+\n+                \/\/ A new KDF object must be created because secret_x_builder\n+                \/\/ might contain provider-specific keys which the previous\n+                \/\/ KDF (provider already chosen) cannot handle.\n+                kdf = KDF.getInstance(kdfAlg);\n+                var exporter_secret = kdf.deriveKey(\"Generic\", DHKEM.labeledExpand(\n+                        secret_x, suite_id, EXP, key_schedule_context, kdfNh));\n+\n+                if (hasEncrypt()) {\n+                    \/\/ ChaCha20-Poly1305 does not care about algorithm name\n+                    var key = kdf.deriveKey(\"AES\", DHKEM.labeledExpand(secret_x,\n+                            suite_id, KEY, key_schedule_context, aead.nk));\n+                    \/\/ deriveData must be called because we need to increment nonce\n+                    var base_nonce = kdf.deriveData(DHKEM.labeledExpand(secret_x,\n+                            suite_id, BASE_NONCE, key_schedule_context, aead.nn));\n+                    return new Context(key, base_nonce, exporter_secret);\n+                } else {\n+                    return new Context(null, null, exporter_secret);\n+                }\n+            } catch (InvalidAlgorithmParameterException\n+                     | NoSuchAlgorithmException | UnsupportedOperationException e) {\n+                throw new ProviderException(\"Internal error\", e);\n+            }\n+        }\n+    }\n+\n+    private static boolean usePSK(SecretKey psk) {\n+        return psk != null;\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        var o = new ByteArrayOutputStream();\n+        Arrays.stream(inputs).forEach(o::writeBytes);\n+        return o.toByteArray();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/HPKE.java","additions":588,"deletions":0,"binary":false,"changes":588,"status":"added"},{"patch":"@@ -664,0 +664,4 @@\n+\n+            if (debug != null) {\n+                emitWeakKeyStoreWarning();\n+            }\n@@ -865,0 +869,4 @@\n+                if (debug != null) {\n+                    emitWeakKeyStoreWarning();\n+                }\n+\n@@ -981,0 +989,8 @@\n+\n+    private void emitWeakKeyStoreWarning() {\n+        debug.println(\"WARNING: JCEKS uses outdated cryptographic \"\n+                + \"algorithms and will be removed in a future \"\n+                + \"release. Migrate to PKCS12 using:\");\n+        debug.println(\"keytool -importkeystore -srckeystore <keystore> \"\n+                + \"-destkeystore <keystore> -deststoretype pkcs12\");\n+    }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/JceKeyStore.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -374,0 +374,2 @@\n+        ps(\"Cipher\", \"HPKE\", \"com.sun.crypto.provider.HPKE\");\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -756,1 +756,2 @@\n-         * NUM_ENTITIES should match the total number of UnicodeBlocks.\n+         * NUM_ENTITIES should match the total number of UnicodeBlock identifier\n+         * names plus their aliases.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.reflect.GenericSignatureFormatError;\n@@ -166,0 +167,4 @@\n+ * <p> Unless otherwise specified, methods in this class throw a\n+ * {@link NullPointerException} when they are called with {@code null}\n+ * or an array that contains {@code null} as an argument.\n+ *\n@@ -544,1 +549,2 @@\n-     * @param loader     class loader from which the class must be loaded\n+     * @param loader     class loader from which the class must be loaded,\n+     *                   may be {@code null}\n@@ -603,2 +609,0 @@\n-     * @throws NullPointerException if the given module or name is {@code null}\n-     *\n@@ -682,2 +686,0 @@\n-     * @throws NullPointerException if the argument is {@code null}\n-     *\n@@ -819,1 +821,1 @@\n-     * @param   obj the object to check\n+     * @param   obj the object to check, may be {@code null}\n@@ -849,2 +851,0 @@\n-     * @throws    NullPointerException if the specified Class parameter is\n-     *            null.\n@@ -1522,1 +1522,0 @@\n-            \/\/ Descriptor already validated by VM\n@@ -1610,2 +1609,9 @@\n-        String getDescriptor() { return descriptor; }\n-\n+        String getDescriptor() {\n+            \/\/ hotspot validates this descriptor to be either a field or method\n+            \/\/ descriptor as the \"type\" in a NameAndType in verification.\n+            \/\/ So this can still be a field descriptor\n+            if (descriptor.isEmpty() || descriptor.charAt(0) != '(') {\n+                throw new GenericSignatureFormatError(\"Bad method signature: \" + descriptor);\n+            }\n+            return descriptor;\n+        }\n@@ -1644,1 +1650,0 @@\n-            \/\/ Descriptor already validated by VM\n@@ -2128,1 +2133,0 @@\n-     * @throws NullPointerException if {@code name} is {@code null}\n@@ -2219,1 +2223,1 @@\n-     * @param parameterTypes the list of parameters\n+     * @param parameterTypes the list of parameters, may be {@code null}\n@@ -2222,1 +2226,2 @@\n-     * @throws NoSuchMethodException if a matching method is not found\n+     * @throws NoSuchMethodException if a matching method is not found,\n+     *         if {@code parameterTypes} contains {@code null},\n@@ -2224,2 +2229,1 @@\n-     *         {@value ConstantDescs#CLASS_INIT_NAME}.\n-     * @throws NullPointerException if {@code name} is {@code null}\n+     *         {@value ConstantDescs#CLASS_INIT_NAME}\n@@ -2256,1 +2260,1 @@\n-     * @param parameterTypes the parameter array\n+     * @param parameterTypes the parameter array, may be {@code null}\n@@ -2260,2 +2264,3 @@\n-     *         including when this {@code Class} object represents\n-     *         an interface, a primitive type, an array class, or void.\n+     *         if this {@code Class} object represents an interface, a primitive\n+     *         type, an array class, or void, or if {@code parameterTypes}\n+     *         contains {@code null}\n@@ -2442,1 +2447,0 @@\n-     * @throws  NullPointerException if {@code name} is {@code null}\n@@ -2477,5 +2481,7 @@\n-     * @param parameterTypes the parameter array\n-     * @return  the {@code Method} object for the method of this class\n-     *          matching the specified name and parameters\n-     * @throws  NoSuchMethodException if a matching method is not found.\n-     * @throws  NullPointerException if {@code name} is {@code null}\n+     * @param parameterTypes the parameter array, may be {@code null}\n+     * @return the {@code Method} object for the method of this class\n+     *         matching the specified name and parameters\n+     * @throws NoSuchMethodException if a matching method is not found,\n+     *         if {@code parameterTypes} contains {@code null},\n+     *         or if the name is {@value ConstantDescs#INIT_NAME} or\n+     *         {@value ConstantDescs#CLASS_INIT_NAME}\n@@ -2548,1 +2554,1 @@\n-     * @param parameterTypes the parameter array\n+     * @param parameterTypes the parameter array, may be {@code null}\n@@ -2552,2 +2558,3 @@\n-     *          including when this {@code Class} object represents\n-     *          an interface, a primitive type, an array class, or void.\n+     *          if this {@code Class} object represents an interface, a\n+     *          primitive type, an array class, or void, or if\n+     *          {@code parameterTypes} contains {@code null}\n@@ -2612,1 +2619,0 @@\n-     * @throws  NullPointerException If {@code name} is {@code null}\n@@ -2708,1 +2714,0 @@\n-     * @throws NullPointerException If {@code name} is {@code null}\n@@ -3550,1 +3555,1 @@\n-     * @param obj the object to be cast\n+     * @param obj the object to be cast, may be {@code null}\n@@ -3605,1 +3610,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3618,1 +3622,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3631,1 +3634,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3661,1 +3663,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3677,1 +3678,0 @@\n-     * @throws NullPointerException {@inheritDoc}\n@@ -3908,0 +3908,1 @@\n+        Objects.requireNonNull(c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":38,"deletions":37,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+ * <p>\n@@ -43,0 +44,1 @@\n+ * <p>\n@@ -47,1 +49,3 @@\n- * the constant. Once a lazy constant is initialized, its contents can <em>never change<\/em>\n+ * the constant.\n+ * <p>\n+ * Once a lazy constant is initialized, its contents can <em>never change<\/em>\n@@ -67,1 +71,1 @@\n- *}\n+ * }\n@@ -124,1 +128,1 @@\n- *}\n+ * }\n@@ -241,1 +245,2 @@\n-     * {@return if this lazy constant is the same as the provided {@code obj}}\n+     * {@return {@code true} if this lazy constant is the same instance as\n+     *          the provided {@code obj}, otherwise {@code false}}\n@@ -244,1 +249,1 @@\n-     * to determine equality. Hence, two lazy constants with the same contents are\n+     * to determine equality. Hence, two distinct lazy constants with the same contents are\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LazyConstant.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                return name + (long) COUNT.getAndAdd(this, 1);\n+                return name + (long) COUNT.getAndAdd(this, 1L);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadBuilders.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,3 +35,2 @@\n- * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n- * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n- * to be thrown.\n+ * APIs in this package perform {@linkplain java.lang.classfile##checks null and unrepresentable argument checks},\n+ * unless otherwise noted.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/package-info.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,3 +33,2 @@\n- * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n- * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n- * to be thrown.\n+ * APIs in this package perform {@linkplain java.lang.classfile##checks null and unrepresentable argument checks},\n+ * unless otherwise noted.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/package-info.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,2 @@\n- * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n- * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n- * to be thrown.\n+ * APIs in this package perform {@linkplain java.lang.classfile##checks null and unrepresentable argument checks},\n+ * unless otherwise noted.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/package-info.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -253,6 +253,0 @@\n- * <p>\n- * Unless otherwise noted, passing a {@code null} argument to a constructor\n- * or method of any Class-File API class or interface will cause a {@link\n- * NullPointerException} to be thrown. Additionally,\n- * invoking a method with an array or collection containing a {@code null} element\n- * will cause a {@code NullPointerException}, unless otherwise specified.\n@@ -275,8 +269,16 @@\n- * <h3>Consistency checks, syntax checks and verification<\/h3>\n- * The Class-File API performs checks to ensure arguments are representable in\n- * the {@code class} file format.  A value that is lost when it is built to a\n- * {@code class} file and re-parsed to a model is rejected with an {@link\n- * IllegalArgumentException}.  For example, a negative value or a value over\n- * {@code 65535} is lost when built to a {@link ##u2 u2} item, with\n- * the range {@code [0, 65535]}.  In particular, any variable-sized table\n- * exceeding its maximum representable size is rejected.\n+ * <h3 id=\"checks\">Consistency checks, syntax checks and verification<\/h3>\n+ * The Class-File API performs checks to ensure arguments to construct {@code\n+ * class} file structures are representable in the {@code class} file format.\n+ * An argument value that cannot be representable by its data type is rejected\n+ * with an {@link IllegalArgumentException}.  For example, an {@code int} value\n+ * cannot be out of the range of its {@linkplain java.lang.classfile##data-types\n+ * data type}; a {@code List} cannot exceed the maximum representable size of\n+ * its table data type, or contain an unrepresentable element.  Restrictions\n+ * based on underlying data type, such as the {@code int} and {@code List} ones\n+ * before, are specified on the corresponding APIs.  Unless otherwise noted, in\n+ * all structures, a {@code String} cannot exceed {@code 65535} bytes when\n+ * represented in modified UTF-8 format.\n+ * <p>\n+ * Unless otherwise noted, passing null or an array or collection that contains\n+ * null as an element to a constructor or method of any Class-File API class or\n+ * interface will cause a {@link NullPointerException} to be thrown.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1197,4 +1197,0 @@\n-        if (!descriptor.startsWith(\"(\") ||  \/\/ also generates NPE if needed\n-            descriptor.indexOf(')') < 0 ||\n-            descriptor.indexOf('.') >= 0)\n-            throw newIllegalArgumentException(\"not a method descriptor: \"+descriptor);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+     * @throws NullPointerException if {@code array} or any of its elements is\n+     *         {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,2 +101,2 @@\n-     * @throws    NullPointerException if the specified\n-     * {@code componentType} argument is null\n+     * @throws    NullPointerException if any of the specified\n+     * {@code componentType} or {@code dimensions} arguments is null\n@@ -120,2 +120,2 @@\n-     * @throws    IllegalArgumentException if the object argument is not\n-     * an array\n+     * @throws NullPointerException if {@code array} is {@code null}\n+     * @throws IllegalArgumentException if {@code array} is not an array\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -443,0 +443,1 @@\n+     * @throws NullPointerException if {@code rv} is {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-     *        The detail message\n+     *        The detail message, may be {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InaccessibleObjectException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-     * @param target the target exception\n+     * @param target the target exception, may be {@code null}\n@@ -76,2 +76,2 @@\n-     * @param target the target exception\n-     * @param s      the detail message\n+     * @param target the target exception, may be {@code null}\n+     * @param s      the detail message, may be {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationTargetException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-     * @param reason The reason for the exception.\n+     * @param reason The reason for the exception, may be {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/MalformedParametersException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -900,1 +900,2 @@\n-     * @param   loader the class loader to define the proxy class\n+     * @param   loader the class loader to define the proxy class, may be\n+     *          {@code null} to represent the bootstrap class loader\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-     *          that was thrown\n+     *          that was thrown, may be {@code null}\n@@ -75,2 +75,2 @@\n-     *          that was thrown\n-     * @param   s the detail message\n+     *          that was thrown, may be {@code null}\n+     * @param   s the detail message, may be {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/UndeclaredThrowableException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,5 @@\n+        \/\/ Defensive validation first\n+        if (host == null || host.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid URL authority\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/HostPortrange.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -530,0 +530,3 @@\n+            if (authority == null || authority.isEmpty()) {\n+                throw new IllegalArgumentException(\"Invalid URL: authority is empty\");\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLPermission.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -775,4 +777,6 @@\n-        return new StringBuilder(10).append(\"--\")\n-            .append(month < 10 ? \"0\" : \"\").append(month)\n-            .append(day < 10 ? \"-0\" : \"-\").append(day)\n-            .toString();\n+        StringBuilder buf = new StringBuilder(10);\n+        buf.append(\"--\");\n+        DecimalDigits.appendPair(buf, month);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, day);\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/MonthDay.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,0 +104,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -1224,1 +1226,1 @@\n-        if (absYear < 1000) {\n+        if (absYear < 10000) {\n@@ -1226,3 +1228,1 @@\n-                buf.append(year - 10000).deleteCharAt(1);\n-            } else {\n-                buf.append(year + 10000).deleteCharAt(0);\n+                buf.append('-');\n@@ -1230,0 +1230,1 @@\n+            DecimalDigits.appendQuad(buf, absYear);\n@@ -1233,3 +1234,3 @@\n-        return buf.append(month < 10 ? \"-0\" : \"-\")\n-            .append(month)\n-            .toString();\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, month);\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/YearMonth.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -468,3 +469,4 @@\n-            buf.append(totalSeconds < 0 ? \"-\" : \"+\")\n-                .append(absHours < 10 ? \"0\" : \"\").append(absHours)\n-                .append(absMinutes < 10 ? \":0\" : \":\").append(absMinutes);\n+            buf.append(totalSeconds < 0 ? '-' : '+');\n+            DecimalDigits.appendPair(buf, absHours);\n+            buf.append(':');\n+            DecimalDigits.appendPair(buf, absMinutes);\n@@ -473,1 +475,2 @@\n-                buf.append(absSeconds < 10 ? \":0\" : \":\").append(absSeconds);\n+                buf.append(':');\n+                DecimalDigits.appendPair(buf, absSeconds);\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+import jdk.internal.util.DecimalDigits;\n+\n@@ -430,4 +432,6 @@\n-        \/\/ getLong() reduces chances of exceptions in toString()\n-        long yoe = getLong(YEAR_OF_ERA);\n-        long moy = getLong(MONTH_OF_YEAR);\n-        long dom = getLong(DAY_OF_MONTH);\n+        \/\/ Using get() instead of getLong() for performance reasons,\n+        \/\/ as the values of YEAR_OF_ERA, MONTH_OF_YEAR, and DAY_OF_MONTH\n+        \/\/ are guaranteed to be within the int range for all chronologies.\n+        int yoe = get(YEAR_OF_ERA);\n+        int moy = get(MONTH_OF_YEAR);\n+        int dom = get(DAY_OF_MONTH);\n@@ -440,2 +444,4 @@\n-                .append(moy < 10 ? \"-0\" : \"-\").append(moy)\n-                .append(dom < 10 ? \"-0\" : \"-\").append(dom);\n+                .append('-');\n+        DecimalDigits.appendPair(buf, moy);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, dom);\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateImpl.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1210,1 +1210,1 @@\n-     * an element is computed or the computing function completes abnormally\n+     * an element is computed or the computing function completes abnormally.\n@@ -1238,1 +1238,1 @@\n-     * function used to compute elements at least so long as there are uninitialized\n+     * function used to compute elements at least as long as there are uninitialized\n","filename":"src\/java.base\/share\/classes\/java\/util\/List.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1791,1 +1791,1 @@\n-     * computing function used to compute values at least so long as there are\n+     * computing function used to compute values at least as long as there are\n","filename":"src\/java.base\/share\/classes\/java\/util\/Map.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1374,5 +1374,12 @@\n-            for (Node<K,V> p; (p = it.advance()) != null; ) {\n-                V val = p.val;\n-                Object v = m.get(p.key);\n-                if (!Objects.equals(val, v))\n-                    return false;\n+\n+            try {\n+                for (Node<K,V> p; (p = it.advance()) != null; ) {\n+                    V val = p.val;\n+                    Object v = m.get(p.key);\n+                    if (!Objects.equals(val, v))\n+                        return false;\n+                }\n+            } catch (ClassCastException | NullPointerException _) {\n+                \/\/ m.get(p.key) is contractually allowed to throw CCE or NPE\n+                \/\/ but CHM doesn't allow null keys, so NPE shouldn't occur in practice\n+                return false;\n@@ -1380,0 +1387,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -363,3 +363,12 @@\n-                if (t != null) {       \/\/ sift down\n-                    for (int cs; (cs = (k << 2) + 1) < n; ) {\n-                        ScheduledForkJoinTask<?> leastChild = null, c;\n+                if (t != null) {\n+                    while (k > 0) {    \/\/ sift up if replaced with smaller value\n+                        ScheduledForkJoinTask<?> parent; int pk;\n+                        if ((parent = h[pk = (k - 1) >>> 2]) == null ||\n+                            parent.when <= d)\n+                            break;\n+                        parent.heapIndex = k;\n+                        h[k] = parent;\n+                        k = pk;\n+                    }\n+                    for (int cs; (cs = (k << 2) + 1) < n; ) { \/\/ sift down\n+                        ScheduledForkJoinTask<?> leastChild = null;\n@@ -367,10 +376,4 @@\n-                        long leastValue = Long.MAX_VALUE;\n-                        for (int ck = cs, j = 4;;) { \/\/ at most 4 children\n-                            if ((c = h[ck]) == null)\n-                                break;\n-                            long cd = c.when;\n-                            if (c.status < 0 && alsoReplace < 0) {\n-                                alsoReplace = ck;    \/\/ at most once per pass\n-                                c.heapIndex = -1;\n-                            }\n-                            else if (leastChild == null || cd < leastValue) {\n+                        long leastValue = d;    \/\/ at most 4 children\n+                        for (int ck, j = 0; j < 4 && (ck = j + cs) < n; ++j) {\n+                            ScheduledForkJoinTask<?> c; long cd;\n+                            if ((c = h[ck]) != null && (cd = c.when) < leastValue) {\n@@ -381,2 +384,0 @@\n-                            if (--j == 0 || ++ck >= n)\n-                                break;\n@@ -384,1 +385,1 @@\n-                        if (leastChild == null || d <= leastValue)\n+                        if (leastChild == null) \/\/ already ordered\n@@ -386,2 +387,6 @@\n-                        leastChild.heapIndex = k;\n-                        h[k] = leastChild;\n+                        if ((h[k] = leastChild).status >= 0 || alsoReplace >= 0)\n+                            leastChild.heapIndex = k;\n+                        else {\n+                            leastChild.heapIndex = -1;\n+                            alsoReplace = k;\n+                        }\n@@ -396,0 +401,1 @@\n+        assert checkHeap(h, n);\n@@ -454,0 +460,27 @@\n+    \/**\n+     * Invariant checks\n+     *\/\n+    private static boolean checkHeap(ScheduledForkJoinTask<?>[] h, int n) {\n+        for (int i = 0; i < h.length; ++i) {\n+            ScheduledForkJoinTask<?> t = h[i];\n+            if (t == null) {         \/\/ unused slots all null\n+                if (i < n)\n+                    return false;\n+            }\n+            else {\n+                long v = t.when;\n+                int x = t.heapIndex;\n+                if (x != i && x >= 0) \/\/ valid index unless removing\n+                    return false;\n+                if (i > 0 && h[(i - 1) >>> 2].when > v) \/\/ ordered wrt parent\n+                    return false;\n+                int cs = (i << 2) + 1; \/\/ ordered wrt children\n+                for (int ck, j = 0; j < 4 && (ck = cs + j) < n; ++j) {\n+                    if (h[ck].when < v)\n+                        return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayScheduler.java","additions":51,"deletions":18,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,3 +111,0 @@\n-            super(upstream, StreamShape.REFERENCE,\n-                  StreamOpFlag.IS_ORDERED | StreamOpFlag.IS_SORTED);\n-            this.isNaturalSort = true;\n@@ -117,1 +114,1 @@\n-            this.comparator = comp;\n+            this(upstream, comp);\n@@ -126,0 +123,4 @@\n+            Objects.requireNonNull(comparator);\n+            boolean isNaturalSort = Comparator.naturalOrder().equals(comparator);\n+            this.comparator = comparator;\n+            this.isNaturalSort = isNaturalSort;\n@@ -127,3 +128,2 @@\n-                  StreamOpFlag.IS_ORDERED | StreamOpFlag.NOT_SORTED);\n-            this.isNaturalSort = false;\n-            this.comparator = Objects.requireNonNull(comparator);\n+                  StreamOpFlag.IS_ORDERED |\n+                          (isNaturalSort ? StreamOpFlag.IS_SORTED : StreamOpFlag.NOT_SORTED));\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/SortedOps.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.util.Comparator;\n@@ -741,3 +742,3 @@\n-     * {@code Comparator} is {@code null}) then the characteristic is converted\n-     * to the {@link #SORTED} flag, otherwise the characteristic is not\n-     * converted.\n+     * {@code Comparator} is {@code null} or {@code Comparator.naturalOrder()}) then\n+     * the characteristic is converted to the {@link #SORTED} flag, otherwise\n+     * the characteristic is not converted.\n@@ -751,7 +752,7 @@\n-        if ((characteristics & Spliterator.SORTED) != 0 && spliterator.getComparator() != null) {\n-            \/\/ Do not propagate the SORTED characteristic if it does not correspond\n-            \/\/ to a natural sort order\n-            return characteristics & SPLITERATOR_CHARACTERISTICS_MASK & ~Spliterator.SORTED;\n-        }\n-        else {\n-            return characteristics & SPLITERATOR_CHARACTERISTICS_MASK;\n+        if ((characteristics & Spliterator.SORTED) != 0) {\n+            Comparator<?> comparator = spliterator.getComparator();\n+            if (comparator != null && !Comparator.naturalOrder().equals(comparator)) {\n+                \/\/ Do not propagate the SORTED characteristic if it does not correspond\n+                \/\/ to a natural sort order\n+                return characteristics & SPLITERATOR_CHARACTERISTICS_MASK & ~Spliterator.SORTED;\n+            }\n@@ -759,0 +760,1 @@\n+        return characteristics & SPLITERATOR_CHARACTERISTICS_MASK;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamOpFlag.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,443 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto.spec;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import java.nio.charset.StandardCharsets;\n+import java.security.AsymmetricKey;\n+import java.security.Key;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.Objects;\n+\n+\/**\n+ * This immutable class specifies the set of parameters used with a {@code Cipher} for the\n+ * <a href=\"https:\/\/www.rfc-editor.org\/info\/rfc9180\">Hybrid Public Key Encryption<\/a>\n+ * (HPKE) algorithm. HPKE is a public key encryption scheme for encrypting\n+ * arbitrary-sized plaintexts with a recipient's public key. It combines a key\n+ * encapsulation mechanism (KEM), a key derivation function (KDF), and an\n+ * authenticated encryption with additional data (AEAD) cipher.\n+ * <p>\n+ * The <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+ * standard algorithm name<\/a> for the cipher is \"HPKE\". Unlike most other\n+ * ciphers, HPKE is not expressed as a transformation string of the form\n+ * \"algorithm\/mode\/padding\". Therefore, the argument to {@code Cipher.getInstance}\n+ * must be the single algorithm name \"HPKE\".\n+ * <p>\n+ * In HPKE, the sender's {@code Cipher} is always initialized with the\n+ * recipient's public key in {@linkplain Cipher#ENCRYPT_MODE encrypt mode},\n+ * while the recipient's {@code Cipher} object is initialized with its own\n+ * private key in {@linkplain Cipher#DECRYPT_MODE decrypt mode}.\n+ * <p>\n+ * An {@code HPKEParameterSpec} object must be provided at HPKE\n+ * {@linkplain Cipher#init(int, Key, AlgorithmParameterSpec) cipher initialization}.\n+ * <p>\n+ * The {@link #of(int, int, int)} static method returns an {@code HPKEParameterSpec}\n+ * object with the specified KEM, KDF, and AEAD algorithm identifiers.\n+ * The terms \"KEM algorithm identifiers\", \"KDF algorithm identifiers\", and\n+ * \"AEAD algorithm identifiers\" refer to their respective numeric values\n+ * (specifically, {@code kem_id}, {@code kdf_id}, and {@code aead_id}) as\n+ * defined in <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-7\">Section 7<\/a>\n+ * of RFC 9180 and maintained on the\n+ * <a href=\"https:\/\/www.iana.org\/assignments\/hpke\/hpke.xhtml\">IANA HPKE page<\/a>.\n+ * <p>\n+ * Once an {@code HPKEParameterSpec} object is created, additional methods\n+ * are available to generate new {@code HPKEParameterSpec} objects with\n+ * different features:\n+ * <ul>\n+ * <li>\n+ * Application-supplied information can be provided using the\n+ * {@link #withInfo(byte[])} method by both sides.\n+ * <li>\n+ * To authenticate using a pre-shared key ({@code mode_psk}), the\n+ * pre-shared key and its identifier must be provided using the\n+ * {@link #withPsk(SecretKey, byte[])} method by both sides.\n+ * <li>\n+ * To authenticate using an asymmetric key ({@code mode_auth}),\n+ * the asymmetric keys must be provided using the {@link #withAuthKey(AsymmetricKey)}\n+ * method. Precisely, the sender must call this method with its own private key\n+ * and the recipient must call it with the sender's public key.\n+ * <li>\n+ * To authenticate using both a PSK and an asymmetric key\n+ * ({@code mode_auth_psk}), both {@link #withAuthKey(AsymmetricKey)} and\n+ * {@link #withPsk(SecretKey, byte[])} methods must be called as described above.\n+ * <li>\n+ * In HPKE, a shared secret is negotiated during the KEM step and a key\n+ * encapsulation message must be transmitted from the sender to the recipient\n+ * so that the recipient can recover the shared secret. On the sender side,\n+ * after the cipher is initialized, the key encapsulation message can be\n+ * retrieved using the {@link Cipher#getIV()} method. On the recipient side,\n+ * this message must be supplied as part of an {@code HPKEParameterSpec}\n+ * object obtained from the {@link #withEncapsulation(byte[])} method.\n+ * <\/ul>\n+ * For successful interoperability, both sides need to have identical algorithm\n+ * identifiers, and supply identical\n+ * {@code info}, {@code psk}, and {@code psk_id} or matching authentication\n+ * keys if provided. For details about HPKE modes, refer to\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-5\">Section 5<\/a>\n+ * of RFC 9180.\n+ * <p>\n+ * If an HPKE cipher is {@linkplain Cipher#init(int, Key) initialized without\n+ * parameters}, an {@code InvalidKeyException} is thrown.\n+ * <p>\n+ * At HPKE cipher initialization, if no HPKE implementation supports the\n+ * provided key type, an {@code InvalidKeyException} is thrown. If the provided\n+ * {@code HPKEParameterSpec} is not accepted by any HPKE implementation,\n+ * an {@code InvalidAlgorithmParameterException} is thrown. For example:\n+ * <ul>\n+ * <li> An algorithm identifier is unsupported or does not match the provided key type.\n+ * <li> A key encapsulation message is provided on the sender side.\n+ * <li> A key encapsulation message is not provided on the recipient side.\n+ * <li> An attempt to use {@code withAuthKey(key)} is made with an incompatible key.\n+ * <li> An attempt to use {@code withAuthKey(key)} is made but {@code mode_auth}\n+ *      or {@code mode_auth_psk} is not supported by the KEM algorithm used.\n+ * <\/ul>\n+ * After initialization, both the sender and recipient can process multiple\n+ * messages in sequence with repeated {@code doFinal} calls, optionally preceded\n+ * by one or more {@code updateAAD} and {@code update}. Each {@code doFinal}\n+ * performs a complete HPKE encryption or decryption operation using a distinct\n+ * IV derived from an internal sequence counter, as specified in\n+ * <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html#section-5.2\">Section 5.2<\/a>\n+ * of RFC 9180. On the recipient side, each {@code doFinal} call must correspond\n+ * to exactly one complete ciphertext, and the number and order of calls must\n+ * match those on the sender side. This differs from the direct use of an AEAD\n+ * cipher, where the caller must provide a fresh IV and reinitialize the cipher\n+ * for each message. By managing IVs internally, HPKE allows a single\n+ * initialization to support multiple messages while still ensuring IV\n+ * uniqueness and preserving AEAD security guarantees.\n+ * <p>\n+ * This example shows a sender and a recipient using HPKE to securely exchange\n+ * messages with an X25519 key pair.\n+ * {@snippet lang=java class=\"PackageSnippets\" region=\"hpke-spec-example\"}\n+ *\n+ * @implNote This class defines constants for some of the standard algorithm\n+ * identifiers such as {@link #KEM_DHKEM_P_256_HKDF_SHA256},\n+ * {@link #KDF_HKDF_SHA256}, and {@link #AEAD_AES_128_GCM}. An HPKE {@code Cipher}\n+ * implementation may support all, some, or none of the algorithm identifiers\n+ * defined here. An implementation may also support additional identifiers not\n+ * listed here, including private or experimental values.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc9180\n+ *      RFC 9180: Hybrid Public Key Encryption\n+ * @spec security\/standard-names.html\n+ *      Java Security Standard Algorithm Names\n+ * @since 26\n+ *\/\n+public final class HPKEParameterSpec implements AlgorithmParameterSpec {\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-256, HKDF-SHA256) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_P_256_HKDF_SHA256 = 0x10;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-384, HKDF-SHA384) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_P_384_HKDF_SHA384 = 0x11;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(P-521, HKDF-SHA512) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_P_521_HKDF_SHA512 = 0x12;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(X25519, HKDF-SHA256) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_X25519_HKDF_SHA256 = 0x20;\n+\n+    \/**\n+     * KEM algorithm identifier for DHKEM(X448, HKDF-SHA512) as defined in RFC 9180.\n+     *\/\n+    public static final int KEM_DHKEM_X448_HKDF_SHA512 = 0x21;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA256 as defined in RFC 9180.\n+     *\/\n+    public static final int KDF_HKDF_SHA256 = 0x1;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA384 as defined in RFC 9180.\n+     *\/\n+    public static final int KDF_HKDF_SHA384 = 0x2;\n+\n+    \/**\n+     * KDF algorithm identifier for HKDF-SHA512 as defined in RFC 9180.\n+     *\/\n+    public static final int KDF_HKDF_SHA512 = 0x3;\n+\n+    \/**\n+     * AEAD algorithm identifier for AES-128-GCM as defined in RFC 9180.\n+     *\/\n+    public static final int AEAD_AES_128_GCM = 0x1;\n+\n+    \/**\n+     * AEAD algorithm identifier for AES-256-GCM as defined in RFC 9180.\n+     *\/\n+    public static final int AEAD_AES_256_GCM = 0x2;\n+\n+    \/**\n+     * AEAD algorithm identifier for ChaCha20Poly1305 as defined in RFC 9180.\n+     *\/\n+    public static final int AEAD_CHACHA20_POLY1305 = 0x3;\n+\n+    \/**\n+     * AEAD algorithm identifier for Export-only as defined in RFC 9180.\n+     *\/\n+    public static final int EXPORT_ONLY = 0xffff;\n+\n+    private final int kem_id;\n+    private final int kdf_id;\n+    private final int aead_id;\n+    private final byte[] info; \/\/ never null, can be empty\n+    private final SecretKey psk; \/\/ null if not used\n+    private final byte[] psk_id; \/\/ never null, can be empty\n+    private final AsymmetricKey kS; \/\/ null if not used\n+    private final byte[] encapsulation; \/\/ null if none\n+\n+    \/\/ Note: this constructor does not clone array arguments.\n+    private HPKEParameterSpec(int kem_id, int kdf_id, int aead_id, byte[] info,\n+            SecretKey psk, byte[] psk_id, AsymmetricKey kS, byte[] encapsulation) {\n+        this.kem_id = kem_id;\n+        this.kdf_id = kdf_id;\n+        this.aead_id = aead_id;\n+        this.info = info;\n+        this.psk = psk;\n+        this.psk_id = psk_id;\n+        this.kS = kS;\n+        this.encapsulation = encapsulation;\n+    }\n+\n+    \/**\n+     * A factory method to create a new {@code HPKEParameterSpec} object with\n+     * specified KEM, KDF, and AEAD algorithm identifiers in {@code mode_base}\n+     * mode with an empty {@code info}.\n+     *\n+     * @param kem_id algorithm identifier for KEM, must be between 0 and 65535 (inclusive)\n+     * @param kdf_id algorithm identifier for KDF, must be between 0 and 65535 (inclusive)\n+     * @param aead_id algorithm identifier for AEAD, must be between 0 and 65535 (inclusive)\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws IllegalArgumentException if any input value\n+     *      is out of range (must be between 0 and 65535, inclusive).\n+     *\/\n+    public static HPKEParameterSpec of(int kem_id, int kdf_id, int aead_id) {\n+        if (kem_id < 0 || kem_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid kem_id: \" + kem_id);\n+        }\n+        if (kdf_id < 0 || kdf_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid kdf_id: \" + kdf_id);\n+        }\n+        if (aead_id < 0 || aead_id > 65535) {\n+            throw new IllegalArgumentException(\"Invalid aead_id: \" + aead_id);\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                new byte[0], null, new byte[0], null, null);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * {@code info} value.\n+     * <p>\n+     * For interoperability, RFC 9180 Section 7.2.1 recommends limiting\n+     * this value to a maximum of 64 bytes.\n+     *\n+     * @param info application-supplied information.\n+     *      The contents of the array are copied to protect\n+     *      against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code info} is {@code null}\n+     * @throws IllegalArgumentException if {@code info} is empty.\n+     *\/\n+    public HPKEParameterSpec withInfo(byte[] info) {\n+        Objects.requireNonNull(info);\n+        if (info.length == 0) {\n+            throw new IllegalArgumentException(\"info is empty\");\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info.clone(), psk, psk_id, kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * {@code psk} and {@code psk_id} values.\n+     * <p>\n+     * RFC 9180 Section 5.1.2 requires the PSK MUST have at least 32 bytes\n+     * of entropy. For interoperability, RFC 9180 Section 7.2.1 recommends\n+     * limiting the key size and identifier length to a maximum of 64 bytes.\n+     *\n+     * @param psk pre-shared key\n+     * @param psk_id identifier for PSK. The contents of the array are copied\n+     *               to protect against subsequent modification.\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code psk} or {@code psk_id} is {@code null}\n+     * @throws IllegalArgumentException if {@code psk} is shorter than 32 bytes\n+     *                                  or {@code psk_id} is empty\n+     *\/\n+    public HPKEParameterSpec withPsk(SecretKey psk, byte[] psk_id) {\n+        Objects.requireNonNull(psk);\n+        Objects.requireNonNull(psk_id);\n+        if (psk_id.length == 0) {\n+            throw new IllegalArgumentException(\"psk_id is empty\");\n+        }\n+        if (\"RAW\".equalsIgnoreCase(psk.getFormat())) {\n+            \/\/ We can only check when psk is extractable. We can only\n+            \/\/ check the length and not the real entropy size\n+            var keyBytes = psk.getEncoded();\n+            assert keyBytes != null;\n+            Arrays.fill(keyBytes, (byte)0);\n+            if (keyBytes.length < 32) {\n+                throw new IllegalArgumentException(\"psk is too short\");\n+            }\n+        }\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id.clone(), kS, encapsulation);\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * key encapsulation message value that will be used by the recipient.\n+     *\n+     * @param encapsulation the key encapsulation message.\n+     *      The contents of the array are copied to protect against\n+     *      subsequent modification.\n+     *\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code encapsulation} is {@code null}\n+     *\/\n+    public HPKEParameterSpec withEncapsulation(byte[] encapsulation) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id, kS,\n+                Objects.requireNonNull(encapsulation).clone());\n+    }\n+\n+    \/**\n+     * Creates a new {@code HPKEParameterSpec} object with the specified\n+     * authentication key value.\n+     * <p>\n+     * Note: this method does not check whether the KEM algorithm supports\n+     * {@code mode_auth} or {@code mode_auth_psk}. If the resulting object is\n+     * used to initialize an HPKE cipher with an unsupported mode, an\n+     * {@code InvalidAlgorithmParameterException} will be thrown at that time.\n+     *\n+     * @param kS the authentication key\n+     * @return a new {@code HPKEParameterSpec} object\n+     * @throws NullPointerException if {@code kS} is {@code null}\n+     *\/\n+    public HPKEParameterSpec withAuthKey(AsymmetricKey kS) {\n+        return new HPKEParameterSpec(kem_id, kdf_id, aead_id,\n+                info, psk, psk_id,\n+                Objects.requireNonNull(kS),\n+                encapsulation);\n+    }\n+\n+    \/**\n+     * {@return the algorithm identifier for KEM }\n+     *\/\n+    public int kem_id() {\n+        return kem_id;\n+    }\n+\n+    \/**\n+     * {@return the algorithm identifier for KDF }\n+     *\/\n+    public int kdf_id() {\n+        return kdf_id;\n+    }\n+\n+    \/**\n+     * {@return the algorithm identifier for AEAD }\n+     *\/\n+    public int aead_id() {\n+        return aead_id;\n+    }\n+\n+    \/**\n+     * {@return a copy of the application-supplied information, empty if none}\n+     *\/\n+    public byte[] info() {\n+        return info.clone();\n+    }\n+\n+    \/**\n+     * {@return pre-shared key, {@code null} if none}\n+     *\/\n+    public SecretKey psk() {\n+        return psk;\n+    }\n+\n+    \/**\n+     * {@return a copy of the identifier for PSK, empty if none}\n+     *\/\n+    public byte[] psk_id() {\n+        return psk_id.clone();\n+    }\n+\n+    \/**\n+     * {@return the key for authentication, {@code null} if none}\n+     *\/\n+    public AsymmetricKey authKey() {\n+        return kS;\n+    }\n+\n+    \/**\n+     * {@return a copy of the key encapsulation message, {@code null} if none}\n+     *\/\n+    public byte[] encapsulation() {\n+        return encapsulation == null ? null : encapsulation.clone();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"HPKEParameterSpec{\" +\n+                \"kem_id=\" + kem_id +\n+                \", kdf_id=\" + kdf_id +\n+                \", aead_id=\" + aead_id +\n+                \", info=\" + bytesToString(info) +\n+                \", \" + (psk == null\n+                        ? (kS == null ? \"mode_base\" : \"mode_auth\")\n+                        : (kS == null ? \"mode_psk\" : \"mode_auth_psk\")) + \"}\";\n+    }\n+\n+    \/\/ Returns a human-readable representation of a byte array.\n+    private static String bytesToString(byte[] input) {\n+        if (input.length == 0) {\n+            return \"(empty)\";\n+        } else {\n+            for (byte b : input) {\n+                if (b < 0x20 || b > 0x7E || b == '\"') {\n+                    \/\/ Non-ASCII or control characters are hard to read, and\n+                    \/\/ `\"` requires character escaping. If any of these are\n+                    \/\/ present, return only the HEX representation.\n+                    return HexFormat.of().formatHex(input);\n+                }\n+            }\n+            \/\/ Otherwise, all characters are printable and safe.\n+            \/\/ Return both HEX and ASCII representations.\n+            return HexFormat.of().formatHex(input)\n+                    + \" (\\\"\" + new String(input, StandardCharsets.US_ASCII) + \"\\\")\";\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/HPKEParameterSpec.java","additions":443,"deletions":0,"binary":false,"changes":443,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+\n+class PackageSnippets {\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ @start region=\"hpke-spec-example\"\n+        \/\/ Recipient key pair generation\n+        KeyPairGenerator g = KeyPairGenerator.getInstance(\"X25519\");\n+        KeyPair kp = g.generateKeyPair();\n+\n+        \/\/ The HPKE sender cipher is initialized with the recipient's public\n+        \/\/ key and an HPKEParameterSpec using specified algorithm identifiers\n+        \/\/ and application-supplied info.\n+        Cipher senderCipher = Cipher.getInstance(\"HPKE\");\n+        HPKEParameterSpec ps = HPKEParameterSpec.of(\n+                        HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256,\n+                        HPKEParameterSpec.KDF_HKDF_SHA256,\n+                        HPKEParameterSpec.AEAD_AES_128_GCM)\n+                .withInfo(HexFormat.of().parseHex(\"010203040506\"));\n+        senderCipher.init(Cipher.ENCRYPT_MODE, kp.getPublic(), ps);\n+\n+        \/\/ Retrieve the key encapsulation message (from the KEM step) from\n+        \/\/ the sender.\n+        byte[] kemEncap = senderCipher.getIV();\n+\n+        \/\/ The HPKE recipient cipher is initialized with its own private key,\n+        \/\/ an HPKEParameterSpec using the same algorithm identifiers as used by\n+        \/\/ the sender, and the key encapsulation message from the sender.\n+        Cipher recipientCipher = Cipher.getInstance(\"HPKE\");\n+        HPKEParameterSpec pr = HPKEParameterSpec.of(\n+                        HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256,\n+                        HPKEParameterSpec.KDF_HKDF_SHA256,\n+                        HPKEParameterSpec.AEAD_AES_128_GCM)\n+                .withInfo(HexFormat.of().parseHex(\"010203040506\"))\n+                .withEncapsulation(kemEncap);\n+        recipientCipher.init(Cipher.DECRYPT_MODE, kp.getPrivate(), pr);\n+\n+        \/\/ Encryption and decryption\n+        byte[] msg = \"Hello World\".getBytes(StandardCharsets.UTF_8);\n+        byte[] ct = senderCipher.doFinal(msg);\n+        byte[] pt = recipientCipher.doFinal(ct);\n+\n+        assert Arrays.equals(msg, pt);\n+        \/\/ @end\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/spec\/snippet-files\/PackageSnippets.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.ModifiedUtf;\n@@ -144,1 +145,1 @@\n-                          byte[] rawBytes, int offset, int rawLen) {\n+                      byte[] rawBytes, int offset, int rawLen) {\n@@ -157,0 +158,4 @@\n+            \/\/ Prevent creation of unwritable entries\n+            if (!ModifiedUtf.isValidLengthInConstantPool(s)) {\n+                throw new IllegalArgumentException(\"utf8 length out of range of u2: \" + ModifiedUtf.utfLen(s));\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -323,4 +323,3 @@\n-        if (!ExactConversionsSupport.isLongToCharExact(utflenLong)) {\n-            throw new IllegalArgumentException(\"utf8 length out of range of u2: \" + utflenLong);\n-        }\n-        int utflen = (int)utflenLong;\n+        \/\/ Utf8Entry should always be writable\n+        assert ExactConversionsSupport.isLongToCharExact(utflenLong) : utflenLong;\n+        int utflen = (int) utflenLong;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.io.BufferedInputStream;\n-import java.io.DataInputStream;\n@@ -34,0 +32,1 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n@@ -41,1 +40,0 @@\n-import static java.lang.classfile.constantpool.PoolEntry.*;\n@@ -167,25 +165,6 @@\n-            try (var in = new DataInputStream(new BufferedInputStream(ci))) {\n-                in.skipBytes(8);\n-                int cpLength = in.readUnsignedShort();\n-                String[] cpStrings = new String[cpLength];\n-                int[] cpClasses = new int[cpLength];\n-                for (int i = 1; i < cpLength; i++) {\n-                    int tag;\n-                    switch (tag = in.readUnsignedByte()) {\n-                        case TAG_UTF8 -> cpStrings[i] = in.readUTF();\n-                        case TAG_CLASS -> cpClasses[i] = in.readUnsignedShort();\n-                        case TAG_STRING, TAG_METHOD_TYPE, TAG_MODULE, TAG_PACKAGE -> in.skipBytes(2);\n-                        case TAG_METHOD_HANDLE -> in.skipBytes(3);\n-                        case TAG_INTEGER, TAG_FLOAT, TAG_FIELDREF, TAG_METHODREF, TAG_INTERFACE_METHODREF,\n-                             TAG_NAME_AND_TYPE, TAG_DYNAMIC, TAG_INVOKE_DYNAMIC -> in.skipBytes(4);\n-                        case TAG_LONG, TAG_DOUBLE -> {\n-                            in.skipBytes(8);\n-                            i++;\n-                        }\n-                        default -> throw new IllegalStateException(\"Bad tag (\" + tag + \") at index (\" + i + \")\");\n-                    }\n-                }\n-                boolean isInterface = (in.readUnsignedShort() & ACC_INTERFACE) != 0;\n-                in.skipBytes(2);\n-                int superIndex = in.readUnsignedShort();\n-                var superClass = superIndex > 0 ? ClassDesc.ofInternalName(cpStrings[cpClasses[superIndex]]) : null;\n+            try (ci) {\n+                var reader = new ClassReaderImpl(ci.readAllBytes(), ClassFileImpl.DEFAULT_CONTEXT);\n+                boolean isInterface = (reader.flags() & ACC_INTERFACE) != 0;\n+                ClassDesc superClass = reader.superclassEntry()\n+                        .map(ClassEntry::asSymbol)\n+                        .orElse(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":8,"deletions":29,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,3 +123,3 @@\n-            if (next instanceof ClassMethodTransform cmt)\n-                return new ClassMethodTransform(transform.andThen(cmt.transform),\n-                                                mm -> filter.test(mm) && cmt.filter.test(mm));\n+            \/\/ Optimized for shared _ -> true filter in ClassTransform.transformingMethods(MethodTransform)\n+            if (next instanceof ClassMethodTransform(var nextTransform, var nextFilter) && filter == nextFilter)\n+                return new ClassMethodTransform(transform.andThen(nextTransform), filter);\n@@ -146,3 +146,3 @@\n-            if (next instanceof ClassFieldTransform cft)\n-                return new ClassFieldTransform(transform.andThen(cft.transform),\n-                                               mm -> filter.test(mm) && cft.filter.test(mm));\n+            \/\/ Optimized for shared _ -> true filter in ClassTransform.transformingFields(FieldTransform)\n+            if (next instanceof ClassFieldTransform(var nextTransform, var nextFilter) && filter == nextFilter)\n+                return new ClassFieldTransform(transform.andThen(nextTransform), filter);\n@@ -211,2 +211,2 @@\n-            return (next instanceof TransformImpl.MethodCodeTransform mct)\n-                   ? new TransformImpl.MethodCodeTransform(xform.andThen(mct.xform))\n+            return (next instanceof MethodCodeTransform(var nextXform))\n+                   ? new TransformImpl.MethodCodeTransform(xform.andThen(nextXform))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -215,1 +215,3 @@\n-            allocationSize = alignedSize;\n+            \/\/ always allocate at least 'byteAlignment' bytes, so that malloc is guaranteed to\n+            \/\/ return a pointer aligned to that alignment, for cases where byteAlignment > alignedSize\n+            allocationSize = Math.max(alignedSize, byteAlignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,5 +52,3 @@\n-        int year  = date.getYear(),\n-            month = date.getMonthValue(),\n-            day   = date.getDayOfMonth();\n-        int absYear = Math.abs(year);\n-        if (absYear < 1000) {\n+        int year    = date.getYear(),\n+            absYear = Math.abs(year);\n+        if (absYear < 10000) {\n@@ -60,2 +58,1 @@\n-            buf.repeat('0', absYear < 10 ? 3 : absYear < 100 ? 2 : 1);\n-            buf.append(absYear);\n+            DecimalDigits.appendQuad(buf, absYear);\n@@ -68,2 +65,4 @@\n-        buf.append(month < 10 ? \"-0\" : \"-\").append(month)\n-           .append(day < 10 ? \"-0\" : \"-\").append(day);\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, date.getMonthValue());\n+        buf.append('-');\n+        DecimalDigits.appendPair(buf, date.getDayOfMonth());\n@@ -77,3 +76,4 @@\n-        int hour   = time.getHour(),\n-            minute = time.getMinute(),\n-            second = time.getSecond(),\n+        DecimalDigits.appendPair(buf, time.getHour());\n+        buf.append(':');\n+        DecimalDigits.appendPair(buf, time.getMinute());\n+        int second = time.getSecond(),\n@@ -81,2 +81,0 @@\n-        buf.append(hour < 10 ? \"0\" : \"\").append(hour)\n-           .append(minute < 10 ? \":0\" : \":\").append(minute);\n@@ -84,1 +82,2 @@\n-            buf.append(second < 10 ? \":0\" : \":\").append(second);\n+            buf.append(':');\n+            DecimalDigits.appendPair(buf, second);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DateTimeHelper.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -39,0 +41,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -446,0 +449,52 @@\n+\n+    \/**\n+     * Appends the two-digit string representation of the {@code int}\n+     * argument to the given {@code StringBuilder}.\n+     * <p>\n+     * The integer {@code v} is formatted as two decimal digits.\n+     * Values from 0 to 9 are formatted with a leading zero (e.g., 5 becomes \"05\"),\n+     * and values from 10 to 99 are formatted as regular two-digit numbers.\n+     * If the value is outside the range 0-99, the behavior is unspecified.\n+     *\n+     * @param buf the {@code StringBuilder} to append to.\n+     * @param v the {@code int} value (should be between 0 and 99 inclusive).\n+     *\/\n+    public static void appendPair(StringBuilder buf, int v) {\n+        \/\/ The & 0x7f operation keeps the index within the safe range [0, 127] for the DIGITS array,\n+        \/\/ which allows the JIT compiler to eliminate array bounds checks for performance.\n+        int packed = DIGITS[v & 0x7f];\n+        \/\/ The temporary String and byte[] objects created here are typically eliminated\n+        \/\/ by the JVM's escape analysis and scalar replacement optimizations during\n+        \/\/ runtime compilation, avoiding actual heap allocations in optimized code.\n+        buf.append(\n+                JLA.uncheckedNewStringWithLatin1Bytes(\n+                        new byte[] {(byte) packed, (byte) (packed >> 8)}));\n+    }\n+\n+    \/**\n+     * Appends the four-digit string representation of the {@code int}\n+     * argument to the given {@code StringBuilder}.\n+     * <p>\n+     * The integer {@code v} is formatted as four decimal digits.\n+     * Values from 0 to 9 are formatted with leading zeros (e.g., 5 becomes \"0005\"),\n+     * values from 10 to 99 add two leading zeros (e.g., 25 becomes \"0025\"),\n+     * values from 100 to 999 add one leading zero (e.g., 123 becomes \"0123\"),\n+     * and values from 1000 to 9999 have no leading zeros.\n+     * If the value is outside the range 0-9999, the behavior is unspecified.\n+     *\n+     * @param buf the {@code StringBuilder} to append to.\n+     * @param v the {@code int} value (should be between 0 and 9999 inclusive).\n+     *\/\n+    public static void appendQuad(StringBuilder buf, int v) {\n+        \/\/ The & 0x7f operation keeps the index within the safe range [0, 127] for the DIGITS array,\n+        \/\/ which allows the JIT compiler to eliminate array bounds checks for performance.\n+        int packedHigh = DIGITS[(v \/ 100) & 0x7f];\n+        int packedLow  = DIGITS[(v % 100) & 0x7f];\n+        \/\/ The temporary String and byte[] objects created here are typically eliminated\n+        \/\/ by the JVM's escape analysis and scalar replacement optimizations during\n+        \/\/ runtime compilation, avoiding actual heap allocations in optimized code.\n+        buf.append(\n+                JLA.uncheckedNewStringWithLatin1Bytes(\n+                        new byte[] {(byte) packedHigh, (byte) (packedHigh >> 8),\n+                                    (byte) packedLow,  (byte) (packedLow  >> 8)}));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -31,8 +31,5 @@\n-\/**\n- * Helper to JDK UTF putChar and Calculate length\n- *\n- * @since 24\n- *\/\n-public abstract class ModifiedUtf {\n-    \/\/ Maximum number of bytes allowed for a Modified UTF-8 encoded string\n-    \/\/ in a ClassFile constant pool entry (CONSTANT_Utf8_info).\n+\/\/\/ Utilities for string encoding and decoding with the\n+\/\/\/ [Modified UTF-8][java.io.DataInput##modified-utf-8] format.\n+public final class ModifiedUtf {\n+    \/\/\/ Maximum number of bytes allowed for a Modified UTF-8 encoded string\n+    \/\/\/ in a [java.lang.classfile.constantpool.Utf8Entry] or a hotspot `Symbol`.\n@@ -44,0 +41,1 @@\n+    \/\/\/ Writes a char to the pre-sized modified UTF buffer.\n@@ -61,5 +59,17 @@\n-    \/**\n-     * Calculate the utf length of a string\n-     * @param str input string\n-     * @param countNonZeroAscii the number of non-zero ascii characters in the prefix calculated by JLA.countNonZeroAscii(str)\n-     *\/\n+    \/\/\/ Calculate the encoded length of an input String.\n+    \/\/\/ For many workloads that have fast paths for ASCII-only prefixes,\n+    \/\/\/ [#utfLen(String, int)] skips scanning that prefix.\n+    \/\/\/\n+    \/\/\/ @param str input string\n+    public static long utfLen(String str) {\n+        return utfLen(str, 0);\n+    }\n+\n+    \/\/\/ Calculate the encoded length of trailing parts of an input String,\n+    \/\/\/ after [jdk.internal.access.JavaLangAccess#countNonZeroAscii(String)]\n+    \/\/\/ calculates the number of contiguous single-byte characters in the\n+    \/\/\/ beginning of the string.\n+    \/\/\/\n+    \/\/\/ @param str input string\n+    \/\/\/ @param countNonZeroAscii the number of non-zero ascii characters in the\n+    \/\/\/        prefix calculated by JLA.countNonZeroAscii(str)\n@@ -77,5 +87,5 @@\n-    \/**\n-     * Checks whether the Modified UTF-8 encoded length of the given string\n-     * fits within the ClassFile constant pool limit (u2 length = 65535 bytes).\n-     * @param str the string to check\n-     *\/\n+    \/\/\/ Checks whether an input String can be encoded in a\n+    \/\/\/ [java.lang.classfile.constantpool.Utf8Entry], or represented as a\n+    \/\/\/ hotspot `Symbol` (which has the same length limit).\n+    \/\/\/\n+    \/\/\/ @param str input string\n@@ -94,1 +104,1 @@\n-        long utfLen = utfLen(str, 0);\n+        long utfLen = utfLen(str);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ModifiedUtf.java","additions":29,"deletions":19,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -66,11 +66,2 @@\n-        return parseMethod(descriptor, 0, descriptor.length(), loader);\n-    }\n-\n-    \/**\n-     * @param loader the class loader in which to look up the types (null means\n-     *               bootstrap class loader)\n-     *\/\n-    static List<Class<?>> parseMethod(String bytecodeSignature,\n-            int start, int end, ClassLoader loader) {\n-        String str = bytecodeSignature;\n-        int[] i = {start};\n+        int end = descriptor.length(); \/\/ implicit null check\n+        int[] i = {0};\n@@ -78,1 +69,1 @@\n-        if (i[0] < end && str.charAt(i[0]) == '(') {\n+        if (i[0] < end && descriptor.charAt(i[0]) == '(') {\n@@ -80,2 +71,2 @@\n-            while (i[0] < end && str.charAt(i[0]) != ')') {\n-                Class<?> pt = parseSig(str, i, end, loader);\n+            while (i[0] < end && descriptor.charAt(i[0]) != ')') {\n+                Class<?> pt = parseSig(descriptor, i, end, loader);\n@@ -83,1 +74,1 @@\n-                    parseError(str, \"bad argument type\");\n+                    parseError(descriptor, \"bad argument type\");\n@@ -88,1 +79,1 @@\n-            parseError(str, \"not a method type\");\n+            parseError(descriptor, \"not a method type\");\n@@ -90,1 +81,1 @@\n-        Class<?> rtype = parseSig(str, i, end, loader);\n+        Class<?> rtype = parseSig(descriptor, i, end, loader);\n@@ -92,1 +83,1 @@\n-            parseError(str, \"bad return type\");\n+            parseError(descriptor, \"bad return type\");\n@@ -118,2 +109,16 @@\n-            int begc = i[0], endc = str.indexOf(';', begc);\n-            if (endc < 0)  return null;\n+            int begc = i[0];\n+            int identifierStart = begc;\n+            int endc;\n+            while (true) {\n+                int next = nextNonIdentifier(str, identifierStart, end);\n+                if (identifierStart == next || next >= end) return null;  \/\/ Empty name segment, or the end\n+                char ch = str.charAt(next);\n+                if (ch == ';') {\n+                    endc = next;\n+                    break;\n+                } else if (ch == '\/') {\n+                    identifierStart = next + 1;  \/\/ Next name segment\n+                } else {\n+                    return null;  \/\/ Bad char [ or .\n+                }\n+            }\n@@ -151,0 +156,17 @@\n+    private static final int CHECK_OFFSET = 32;\n+    private static final long NON_IDENTIFIER_MASK = (1L << ('.' - CHECK_OFFSET))\n+            | (1L << ('\/' - CHECK_OFFSET))\n+            | (1L << (';' - CHECK_OFFSET))\n+            | (1L << ('[' - CHECK_OFFSET));\n+\n+    private static int nextNonIdentifier(String str, int index, int end) {\n+        while (index < end) {\n+            int check = str.charAt(index) - CHECK_OFFSET;\n+            if ((check & -Long.SIZE) == 0 && (NON_IDENTIFIER_MASK & (1L << check)) != 0) {\n+                break;\n+            }\n+            index++;\n+        }\n+        return index;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":42,"deletions":20,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -630,0 +630,4 @@\n+\n+            if (debug != null) {\n+                emitWeakKeyStoreWarning();\n+            }\n@@ -793,0 +797,4 @@\n+            if (debug != null) {\n+                emitWeakKeyStoreWarning();\n+            }\n+\n@@ -841,0 +849,12 @@\n+\n+    private void emitWeakKeyStoreWarning() {\n+        String type = this.getClass().getSimpleName().\n+                toUpperCase(Locale.ROOT);\n+        if (type.equals(\"JKS\")){\n+            debug.println(\"WARNING: JKS uses outdated cryptographic \"\n+                    + \"algorithms and will be removed in a future \"\n+                    + \"release. Migrate to PKCS12 using:\");\n+            debug.println(\"keytool -importkeystore -srckeystore <keystore> \"\n+                    + \"-destkeystore <keystore> -deststoretype pkcs12\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/JavaKeyStore.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Alert.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -173,1 +173,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -186,1 +186,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -200,1 +200,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -215,1 +215,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -269,1 +269,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -291,1 +291,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -381,1 +381,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -426,1 +426,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/AlpnExtension.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -147,1 +147,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -238,1 +238,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -286,1 +286,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertSignAlgsExtension.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -199,1 +199,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -560,1 +560,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -601,1 +601,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -659,1 +659,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -669,1 +669,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -842,1 +842,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -918,1 +918,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -960,1 +960,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1020,1 +1020,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1030,1 +1030,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1115,1 +1115,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1124,1 +1124,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1142,1 +1142,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -1152,1 +1152,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n@@ -1211,1 +1211,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertStatusExtension.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -208,1 +208,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -219,1 +219,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -273,1 +273,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -322,1 +322,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -335,1 +335,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -346,1 +346,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -400,1 +400,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateAuthoritiesExtension.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -296,1 +296,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -305,1 +305,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -327,1 +327,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -363,1 +363,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -369,1 +369,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -504,1 +504,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"handshake\")) {\n@@ -514,1 +514,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"handshake\")) {\n@@ -983,1 +983,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1000,1 +1000,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1024,1 +1024,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1037,1 +1037,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1044,1 +1044,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1070,1 +1070,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1111,1 +1111,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1117,1 +1117,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateMessage.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -363,1 +363,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -403,1 +403,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -411,1 +411,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -419,1 +419,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -658,1 +658,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -720,1 +720,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -787,1 +787,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -826,1 +826,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -936,1 +936,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -988,1 +988,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -328,1 +328,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -361,1 +361,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateStatus.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -251,1 +251,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -261,1 +261,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -303,1 +303,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -506,1 +506,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -516,1 +516,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -558,1 +558,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -757,1 +757,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -767,1 +767,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -809,1 +809,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1095,1 +1095,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1116,1 +1116,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1133,1 +1133,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1176,1 +1176,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateVerify.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -145,1 +145,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -240,1 +240,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ChangeCipherSpec.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -446,1 +446,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -459,1 +459,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -516,1 +516,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -527,1 +527,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n@@ -550,1 +550,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -637,1 +637,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -703,1 +703,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -737,1 +737,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -793,1 +793,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -823,1 +823,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -983,1 +983,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -996,1 +996,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n@@ -1011,1 +1011,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n@@ -1026,1 +1026,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n@@ -1042,1 +1042,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n@@ -1057,1 +1057,1 @@\n-                if (!resumingSession && SSLLogger.isOn &&\n+                if (!resumingSession && SSLLogger.isOn() &&\n@@ -1324,1 +1324,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -1337,1 +1337,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n@@ -1353,1 +1353,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n@@ -1368,1 +1368,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -157,1 +157,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -221,1 +221,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -256,1 +256,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -283,1 +283,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CookieExtension.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -271,1 +271,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHClientKeyExchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -515,1 +515,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DHServerKeyExchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -153,1 +153,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -165,1 +165,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -184,1 +184,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -226,1 +226,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -244,1 +244,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -276,1 +276,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -299,1 +299,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -359,1 +359,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -371,1 +371,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -407,1 +407,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -751,1 +751,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -772,1 +772,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -840,1 +840,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -864,1 +864,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -900,1 +900,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1032,1 +1032,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1078,1 +1078,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1091,1 +1091,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1129,1 +1129,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1150,1 +1150,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1162,1 +1162,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1247,1 +1247,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1259,1 +1259,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1276,1 +1276,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1298,1 +1298,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1449,1 +1449,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1457,1 +1457,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1470,1 +1470,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1484,1 +1484,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1496,1 +1496,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1510,1 +1510,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1522,1 +1522,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1545,1 +1545,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1559,1 +1559,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1570,1 +1570,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1583,1 +1583,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -1597,1 +1597,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSInputRecord.java","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -123,1 +123,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -140,1 +140,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -157,1 +157,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -182,1 +182,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -189,1 +189,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -204,1 +204,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -272,1 +272,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -285,1 +285,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -500,1 +500,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -514,1 +514,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSOutputRecord.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -311,1 +311,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -400,1 +400,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -493,1 +493,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHClientKeyExchange.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -492,1 +492,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -525,1 +525,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECDHServerKeyExchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -196,1 +196,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -224,1 +224,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ECPointFormatsExtension.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -171,1 +171,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/EncryptedExtensions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -165,1 +165,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -185,1 +185,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -216,1 +216,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -255,1 +255,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ExtendedMasterSecretExtension.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -456,1 +456,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -545,1 +545,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -605,1 +605,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -684,1 +684,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -781,1 +781,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -933,1 +933,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1076,1 +1076,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-                } else if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                } else if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -294,1 +294,1 @@\n-            if (!found && (SSLLogger.isOn) && SSLLogger.isOn(\"handshake\")) {\n+            if (!found && (SSLLogger.isOn()) && SSLLogger.isOn(\"handshake\")) {\n@@ -338,1 +338,1 @@\n-                        SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                        SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -559,1 +559,1 @@\n-                                SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+                                SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -573,1 +573,1 @@\n-            if (!retval && SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+            if (!retval && SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n@@ -579,1 +579,1 @@\n-        } else if (SSLLogger.isOn && SSLLogger.isOn(\"verbose\")) {\n+        } else if (SSLLogger.isOn() && SSLLogger.isOn(\"verbose\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeContext.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HandshakeOutStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -140,1 +140,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -180,1 +180,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -193,1 +193,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -209,1 +209,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HelloRequest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -200,1 +200,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HelloVerifyRequest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -225,1 +225,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -240,1 +240,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -290,1 +290,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -326,1 +326,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -335,1 +335,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -349,1 +349,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -367,1 +367,1 @@\n-                            if (SSLLogger.isOn &&\n+                            if (SSLLogger.isOn() &&\n@@ -382,1 +382,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -525,1 +525,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -534,1 +534,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -545,1 +545,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -565,1 +565,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -600,1 +600,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -711,1 +711,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"handshake\")) {\n@@ -804,1 +804,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyShareExtension.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -238,1 +238,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -279,1 +279,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -331,1 +331,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyUpdate.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -216,1 +216,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -246,1 +246,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -291,1 +291,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -308,1 +308,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -416,1 +416,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -458,1 +458,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -475,1 +475,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -581,1 +581,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/MaxFragExtension.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -297,1 +297,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -385,1 +385,1 @@\n-                if (SSLLogger.isOn &&\n+                if (SSLLogger.isOn() &&\n@@ -814,1 +814,1 @@\n-                        SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NamedGroup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -332,1 +332,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -350,1 +350,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -361,1 +361,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -375,1 +375,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -462,1 +462,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -477,1 +477,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -491,1 +491,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -529,1 +529,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -543,1 +543,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -582,1 +582,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -593,1 +593,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -602,1 +602,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -614,1 +614,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -640,1 +640,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -668,1 +668,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -677,1 +677,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -689,1 +689,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -698,1 +698,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -225,1 +225,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/OutputRecord.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -396,1 +396,1 @@\n-                            if (SSLLogger.isOn &&\n+                            if (SSLLogger.isOn() &&\n@@ -405,1 +405,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -438,1 +438,1 @@\n-            if (SSLLogger.isOn &&\n+            if (SSLLogger.isOn() &&\n@@ -452,1 +452,1 @@\n-                if (SSLLogger.isOn &&\n+                if (SSLLogger.isOn() &&\n@@ -469,1 +469,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -483,1 +483,1 @@\n-                if (SSLLogger.isOn &&\n+                if (SSLLogger.isOn() &&\n@@ -497,1 +497,1 @@\n-            if (SSLLogger.isOn &&\n+            if (SSLLogger.isOn() &&\n@@ -656,1 +656,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -666,1 +666,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -676,1 +676,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -690,1 +690,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -702,1 +702,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -839,1 +839,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -904,1 +904,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -914,1 +914,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -928,1 +928,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"sslctx\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"sslctx\")) {\n@@ -265,1 +265,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"sslctx\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"sslctx\")) {\n@@ -282,1 +282,1 @@\n-            } else if (SSLLogger.isOn && SSLLogger.isOn(\"sslctx\")) {\n+            } else if (SSLLogger.isOn() && SSLLogger.isOn(\"sslctx\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PredefinedDHParameterSpecs.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -219,1 +219,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -250,1 +250,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -290,1 +290,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PskKeyExchangeModesExtension.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -85,1 +85,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -93,1 +93,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -112,1 +112,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/QuicEngineOutputRecord.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -392,1 +392,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -573,1 +573,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -614,1 +614,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -636,1 +636,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -649,1 +649,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -720,1 +720,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -735,1 +735,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -758,1 +758,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -806,1 +806,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -818,1 +818,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1028,1 +1028,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1035,1 +1035,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/QuicKeyManager.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-                if (SSLLogger.isOn) {\n+                if (SSLLogger.isOn()) {\n@@ -838,1 +838,1 @@\n-            if (SSLLogger.isOn) {\n+            if (SSLLogger.isOn()) {\n@@ -856,1 +856,1 @@\n-            if (SSLLogger.isOn) {\n+            if (SSLLogger.isOn()) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/QuicTLSEngineImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -273,1 +273,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/RSAClientKeyExchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -153,1 +152,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -200,1 +199,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -208,1 +207,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -223,1 +222,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -238,1 +237,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/RSAKeyExchange.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -299,1 +299,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/RSAServerKeyExchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -185,1 +185,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -219,1 +219,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -283,1 +283,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -297,1 +297,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -309,1 +309,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -315,1 +315,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -348,1 +348,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -357,1 +357,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -518,1 +518,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -530,1 +530,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -536,1 +536,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/RenegoInfoExtension.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLAlgorithmConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -416,1 +416,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -422,1 +422,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -471,1 +471,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -863,1 +863,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -933,1 +933,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1053,1 +1053,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1185,1 +1185,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1329,1 +1329,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1481,1 +1481,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1653,1 +1653,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1740,1 +1740,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1826,1 +1826,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1935,1 +1935,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -1987,1 +1987,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -2029,1 +2029,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -2185,1 +2185,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -2234,1 +2234,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -2276,1 +2276,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -2453,1 +2453,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n@@ -2502,1 +2502,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -2544,1 +2544,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"plaintext\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-            if (nstServerCount != null && SSLLogger.isOn &&\n+            if (nstServerCount != null && SSLLogger.isOn() &&\n@@ -216,1 +216,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -589,1 +589,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")\n@@ -618,1 +618,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")) {\n@@ -111,1 +111,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")) {\n@@ -146,1 +146,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")) {\n@@ -249,1 +249,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")) {\n@@ -386,1 +386,1 @@\n-                    } else if (SSLLogger.isOn &&\n+                    } else if (SSLLogger.isOn() &&\n@@ -395,1 +395,1 @@\n-                if (!isSupported && SSLLogger.isOn &&\n+                if (!isSupported && SSLLogger.isOn() &&\n@@ -413,1 +413,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")) {\n@@ -440,1 +440,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")) {\n@@ -452,1 +452,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")) {\n@@ -910,1 +910,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,defaultctx\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,defaultctx\")) {\n@@ -922,1 +922,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,defaultctx\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,defaultctx\")) {\n@@ -980,1 +980,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,defaultctx\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,defaultctx\")) {\n@@ -1010,1 +1010,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,defaultctx\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,defaultctx\")) {\n@@ -1033,1 +1033,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,defaultctx\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,defaultctx\")) {\n@@ -1071,1 +1071,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,defaultctx\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,defaultctx\")) {\n@@ -1100,1 +1100,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,defaultctx\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,defaultctx\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLContextImpl.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -333,1 +333,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,verbose\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,verbose\")) {\n@@ -400,1 +400,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -422,1 +422,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -615,1 +615,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,verbose\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,verbose\")) {\n@@ -783,1 +783,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -822,1 +822,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -212,1 +212,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -391,1 +391,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -413,1 +413,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineInputRecord.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -94,1 +94,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -141,1 +141,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -174,1 +174,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -181,1 +181,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -196,1 +196,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -278,1 +278,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -291,1 +291,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -320,1 +320,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -334,1 +334,1 @@\n-            if (SSLLogger.isOn) {\n+            if (SSLLogger.isOn()) {\n@@ -528,1 +528,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -546,1 +546,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineOutputRecord.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -847,1 +847,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,sslctx\")\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,sslctx\")\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtension.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-            SSLLogger.isOn ? new LinkedHashMap<>() : null;\n+            SSLLogger.isOn() ? new LinkedHashMap<>() : null;\n@@ -96,1 +96,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -146,1 +146,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -174,1 +174,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -184,1 +184,1 @@\n-                } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                } else if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -193,1 +193,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -203,1 +203,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -218,1 +218,1 @@\n-                } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                } else if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -226,1 +226,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -235,1 +235,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -248,1 +248,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -257,1 +257,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -270,1 +270,1 @@\n-            } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            } else if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -287,1 +287,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -308,1 +308,1 @@\n-            } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            } else if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtensions.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.lang.System.Logger;\n-import java.lang.System.Logger.Level;\n@@ -44,0 +42,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -61,1 +60,1 @@\n-public final class SSLLogger {\n+public final class SSLLogger implements System.Logger {\n@@ -64,1 +63,4 @@\n-    public static final boolean isOn;\n+    private static final boolean isOn;\n+\n+    private final String loggerName;\n+    private final boolean useCompactFormat;\n@@ -79,1 +81,1 @@\n-                logger = new SSLConsoleLogger(\"javax.net.ssl\", p);\n+                logger = new SSLLogger(\"javax.net.ssl\", p);\n@@ -89,29 +91,4 @@\n-    private static void help() {\n-        System.err.println();\n-        System.err.println(\"help           print the help messages\");\n-        System.err.println(\"expand         expand debugging information\");\n-        System.err.println();\n-        System.err.println(\"all            turn on all debugging\");\n-        System.err.println(\"ssl            turn on ssl debugging\");\n-        System.err.println();\n-        System.err.println(\"The following can be used with ssl:\");\n-        System.err.println(\"\\trecord       enable per-record tracing\");\n-        System.err.println(\"\\thandshake    print each handshake message\");\n-        System.err.println(\"\\tkeygen       print key generation data\");\n-        System.err.println(\"\\tsession      print session activity\");\n-        System.err.println(\"\\tdefaultctx   print default SSL initialization\");\n-        System.err.println(\"\\tsslctx       print SSLContext tracing\");\n-        System.err.println(\"\\tsessioncache print session cache tracing\");\n-        System.err.println(\"\\tkeymanager   print key manager tracing\");\n-        System.err.println(\"\\ttrustmanager print trust manager tracing\");\n-        System.err.println(\"\\tpluggability print pluggability tracing\");\n-        System.err.println();\n-        System.err.println(\"\\thandshake debugging can be widened with:\");\n-        System.err.println(\"\\tdata         hex dump of each handshake message\");\n-        System.err.println(\"\\tverbose      verbose handshake message printing\");\n-        System.err.println();\n-        System.err.println(\"\\trecord debugging can be widened with:\");\n-        System.err.println(\"\\tplaintext    hex dump of record plaintext\");\n-        System.err.println(\"\\tpacket       print raw SSL\/TLS packets\");\n-        System.err.println();\n-        System.exit(0);\n+    private SSLLogger(String loggerName, String options) {\n+        this.loggerName = loggerName;\n+        options = options.toLowerCase(Locale.ENGLISH);\n+        this.useCompactFormat = !options.contains(\"expand\");\n@@ -142,0 +119,5 @@\n+    @ForceInline\n+    public static boolean isOn() {\n+        return isOn;\n+    }\n+\n@@ -164,1 +146,1 @@\n-        SSLLogger.log(Level.ERROR, msg, params);\n+        SSLLogger.log0(Level.ERROR, msg, params);\n@@ -168,1 +150,1 @@\n-        SSLLogger.log(Level.WARNING, msg, params);\n+        SSLLogger.log0(Level.WARNING, msg, params);\n@@ -172,1 +154,1 @@\n-        SSLLogger.log(Level.INFO, msg, params);\n+        SSLLogger.log0(Level.INFO, msg, params);\n@@ -176,1 +158,1 @@\n-        SSLLogger.log(Level.DEBUG, msg, params);\n+        SSLLogger.log0(Level.DEBUG, msg, params);\n@@ -180,1 +162,1 @@\n-        SSLLogger.log(Level.TRACE, msg, params);\n+        SSLLogger.log0(Level.TRACE, msg, params);\n@@ -184,1 +166,1 @@\n-        SSLLogger.log(Level.TRACE, msg, params);\n+        SSLLogger.log0(Level.TRACE, msg, params);\n@@ -187,1 +169,1 @@\n-    private static void log(Level level, String msg, Object... params) {\n+    private static void log0(Level level, String msg, Object... params) {\n@@ -195,2 +177,2 @@\n-                    \/\/ use the customized log method for SSLConsoleLogger\n-                    if (logger instanceof SSLConsoleLogger) {\n+                    \/\/ use the customized log method for SSLLogger\n+                    if (logger instanceof SSLLogger) {\n@@ -208,0 +190,31 @@\n+    private static void help() {\n+        System.err.println();\n+        System.err.println(\"help           print the help messages\");\n+        System.err.println(\"expand         expand debugging information\");\n+        System.err.println();\n+        System.err.println(\"all            turn on all debugging\");\n+        System.err.println(\"ssl            turn on ssl debugging\");\n+        System.err.println();\n+        System.err.println(\"The following can be used with ssl:\");\n+        System.err.println(\"\\trecord       enable per-record tracing\");\n+        System.err.println(\"\\thandshake    print each handshake message\");\n+        System.err.println(\"\\tkeygen       print key generation data\");\n+        System.err.println(\"\\tsession      print session activity\");\n+        System.err.println(\"\\tdefaultctx   print default SSL initialization\");\n+        System.err.println(\"\\tsslctx       print SSLContext tracing\");\n+        System.err.println(\"\\tsessioncache print session cache tracing\");\n+        System.err.println(\"\\tkeymanager   print key manager tracing\");\n+        System.err.println(\"\\ttrustmanager print trust manager tracing\");\n+        System.err.println(\"\\tpluggability print pluggability tracing\");\n+        System.err.println();\n+        System.err.println(\"\\thandshake debugging can be widened with:\");\n+        System.err.println(\"\\tdata         hex dump of each handshake message\");\n+        System.err.println(\"\\tverbose      verbose handshake message printing\");\n+        System.err.println();\n+        System.err.println(\"\\trecord debugging can be widened with:\");\n+        System.err.println(\"\\tplaintext    hex dump of record plaintext\");\n+        System.err.println(\"\\tpacket       print raw SSL\/TLS packets\");\n+        System.err.println();\n+        System.exit(0);\n+    }\n+\n@@ -219,1 +232,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(option)) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(option)) {\n@@ -225,14 +238,4 @@\n-    private static class SSLConsoleLogger implements Logger {\n-        private final String loggerName;\n-        private final boolean useCompactFormat;\n-\n-        SSLConsoleLogger(String loggerName, String options) {\n-            this.loggerName = loggerName;\n-            options = options.toLowerCase(Locale.ENGLISH);\n-            this.useCompactFormat = !options.contains(\"expand\");\n-        }\n-\n-        @Override\n-        public String getName() {\n-            return loggerName;\n-        }\n+    @Override\n+    public String getName() {\n+        return loggerName;\n+    }\n@@ -240,4 +243,4 @@\n-        @Override\n-        public boolean isLoggable(Level level) {\n-            return level != Level.OFF;\n-        }\n+    @Override\n+    public boolean isLoggable(Level level) {\n+        return level != Level.OFF;\n+    }\n@@ -245,6 +248,6 @@\n-        @Override\n-        public void log(Level level,\n-                ResourceBundle rb, String message, Throwable thrwbl) {\n-            if (isLoggable(level)) {\n-                try {\n-                    String formatted =\n+    @Override\n+    public void log(Level level,\n+                    ResourceBundle rb, String message, Throwable thrwbl) {\n+        if (isLoggable(level)) {\n+            try {\n+                String formatted =\n@@ -252,4 +255,3 @@\n-                    System.err.write(formatted.getBytes(UTF_8));\n-                } catch (Exception exp) {\n-                    \/\/ ignore it, just for debugging.\n-                }\n+                System.err.write(formatted.getBytes(UTF_8));\n+            } catch (Exception exp) {\n+                \/\/ ignore it, just for debugging.\n@@ -258,0 +260,1 @@\n+    }\n@@ -259,6 +262,6 @@\n-        @Override\n-        public void log(Level level,\n-                ResourceBundle rb, String message, Object... params) {\n-            if (isLoggable(level)) {\n-                try {\n-                    String formatted =\n+    @Override\n+    public void log(Level level,\n+                    ResourceBundle rb, String message, Object... params) {\n+        if (isLoggable(level)) {\n+            try {\n+                String formatted =\n@@ -266,4 +269,3 @@\n-                    System.err.write(formatted.getBytes(UTF_8));\n-                } catch (Exception exp) {\n-                    \/\/ ignore it, just for debugging.\n-                }\n+                System.err.write(formatted.getBytes(UTF_8));\n+            } catch (Exception exp) {\n+                \/\/ ignore it, just for debugging.\n@@ -276,2 +278,3 @@\n-        private static final DateTimeFormatter dateTimeFormat = DateTimeFormatter.ofPattern(PATTERN, Locale.ENGLISH)\n-                                                                                 .withZone(ZoneId.systemDefault());\n+        private static final DateTimeFormatter dateTimeFormat =\n+                DateTimeFormatter.ofPattern(PATTERN, Locale.ENGLISH)\n+                .withZone(ZoneId.systemDefault());\n@@ -293,15 +296,15 @@\n-            new MessageFormat(\n-                    \"\"\"\n-                            \"version\"            : \"v{0}\",\n-                            \"serial number\"      : \"{1}\",\n-                            \"signature algorithm\": \"{2}\",\n-                            \"issuer\"             : \"{3}\",\n-                            \"not before\"         : \"{4}\",\n-                            \"not  after\"         : \"{5}\",\n-                            \"subject\"            : \"{6}\",\n-                            \"subject public key\" : \"{7}\",\n-                            \"extensions\"         : [\n-                            {8}\n-                            ]\n-                            \"\"\",\n-                Locale.ENGLISH);\n+                new MessageFormat(\n+                        \"\"\"\n+                                \"version\"            : \"v{0}\",\n+                                \"serial number\"      : \"{1}\",\n+                                \"signature algorithm\": \"{2}\",\n+                                \"issuer\"             : \"{3}\",\n+                                \"not before\"         : \"{4}\",\n+                                \"not  after\"         : \"{5}\",\n+                                \"subject\"            : \"{6}\",\n+                                \"subject public key\" : \"{7}\",\n+                                \"extensions\"         : [\n+                                {8}\n+                                ]\n+                                \"\"\",\n+                        Locale.ENGLISH);\n@@ -310,13 +313,13 @@\n-            new MessageFormat(\n-                    \"\"\"\n-                            '{'\n-                              \"logger\"      : \"{0}\",\n-                              \"level\"       : \"{1}\",\n-                              \"thread id\"   : \"{2}\",\n-                              \"thread name\" : \"{3}\",\n-                              \"time\"        : \"{4}\",\n-                              \"caller\"      : \"{5}\",\n-                              \"message\"     : \"{6}\"\n-                            '}'\n-                            \"\"\",\n-                Locale.ENGLISH);\n+                new MessageFormat(\n+                        \"\"\"\n+                                '{'\n+                                  \"logger\"      : \"{0}\",\n+                                  \"level\"       : \"{1}\",\n+                                  \"thread id\"   : \"{2}\",\n+                                  \"thread name\" : \"{3}\",\n+                                  \"time\"        : \"{4}\",\n+                                  \"caller\"      : \"{5}\",\n+                                  \"message\"     : \"{6}\"\n+                                '}'\n+                                \"\"\",\n+                        Locale.ENGLISH);\n@@ -325,3 +328,3 @@\n-            new MessageFormat(\n-                \"{0}|{1}|{2}|{3}|{4}|{5}|{6}\" + LINE_SEP,\n-                Locale.ENGLISH);\n+                new MessageFormat(\n+                        \"{0}|{1}|{2}|{3}|{4}|{5}|{6}\" + LINE_SEP,\n+                        Locale.ENGLISH);\n@@ -330,16 +333,16 @@\n-            new MessageFormat(\n-                    \"\"\"\n-                            '{'\n-                              \"logger\"      : \"{0}\",\n-                              \"level\"       : \"{1}\",\n-                              \"thread id\"   : \"{2}\",\n-                              \"thread name\" : \"{3}\",\n-                              \"time\"        : \"{4}\",\n-                              \"caller\"      : \"{5}\",\n-                              \"message\"     : \"{6}\",\n-                              \"specifics\"   : [\n-                            {7}\n-                              ]\n-                            '}'\n-                            \"\"\",\n-                Locale.ENGLISH);\n+                new MessageFormat(\n+                        \"\"\"\n+                                '{'\n+                                  \"logger\"      : \"{0}\",\n+                                  \"level\"       : \"{1}\",\n+                                  \"thread id\"   : \"{2}\",\n+                                  \"thread name\" : \"{3}\",\n+                                  \"time\"        : \"{4}\",\n+                                  \"caller\"      : \"{5}\",\n+                                  \"message\"     : \"{6}\",\n+                                  \"specifics\"   : [\n+                                {7}\n+                                  ]\n+                                '}'\n+                                \"\"\",\n+                        Locale.ENGLISH);\n@@ -348,7 +351,7 @@\n-            new MessageFormat(\n-                    \"\"\"\n-                            {0}|{1}|{2}|{3}|{4}|{5}|{6} (\n-                            {7}\n-                            )\n-                            \"\"\",\n-                Locale.ENGLISH);\n+                new MessageFormat(\n+                        \"\"\"\n+                                {0}|{1}|{2}|{3}|{4}|{5}|{6} (\n+                                {7}\n+                                )\n+                                \"\"\",\n+                        Locale.ENGLISH);\n@@ -367,2 +370,2 @@\n-        private static String format(SSLConsoleLogger logger, Level level,\n-                    String message, Object ... parameters) {\n+        private static String format(SSLLogger logger, Level level,\n+                                     String message, Object... parameters) {\n@@ -397,3 +400,3 @@\n-                        formatParameters(parameters) :\n-                        Utilities.indent(formatParameters(parameters)))\n-                };\n+                            formatParameters(parameters) :\n+                            Utilities.indent(formatParameters(parameters)))\n+            };\n@@ -417,1 +420,1 @@\n-        private static String formatParameters(Object ... parameters) {\n+        private static String formatParameters(Object... parameters) {\n@@ -428,1 +431,1 @@\n-                    builder.append(formatThrowable((Throwable)parameter));\n+                    builder.append(formatThrowable((Throwable) parameter));\n@@ -430,1 +433,1 @@\n-                    builder.append(formatCertificate((Certificate)parameter));\n+                    builder.append(formatCertificate((Certificate) parameter));\n@@ -433,1 +436,1 @@\n-                        (ByteArrayInputStream)parameter));\n+                            (ByteArrayInputStream) parameter));\n@@ -435,1 +438,1 @@\n-                    builder.append(formatByteBuffer((ByteBuffer)parameter));\n+                    builder.append(formatByteBuffer((ByteBuffer) parameter));\n@@ -438,1 +441,1 @@\n-                        new ByteArrayInputStream((byte[])parameter)));\n+                            new ByteArrayInputStream((byte[]) parameter)));\n@@ -442,1 +445,1 @@\n-                        (Map.Entry<String, ?>)parameter;\n+                            (Map.Entry<String, ?>) parameter;\n@@ -465,1 +468,1 @@\n-                };\n+            };\n@@ -482,1 +485,1 @@\n-                    X509CertImpl.toImpl((X509Certificate)certificate);\n+                        X509CertImpl.toImpl((X509Certificate) certificate);\n@@ -531,1 +534,1 @@\n-                };\n+            };\n@@ -594,1 +597,1 @@\n-                    Utilities.toHexString((byte[])value) + \"\\\"\";\n+                        Utilities.toHexString((byte[]) value) + \"\\\"\";\n@@ -597,1 +600,1 @@\n-                        HexFormat.of().toHexDigits((byte)value) + \"\\\"\";\n+                        HexFormat.of().toHexDigits((byte) value) + \"\\\"\";\n@@ -600,1 +603,1 @@\n-                    \"\\\"\" + value.toString() + \"\\\"\";\n+                        \"\\\"\" + value.toString() + \"\\\"\";\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLLogger.java","additions":159,"deletions":156,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -155,1 +154,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLMasterKeyDerivation.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -352,1 +352,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -366,1 +366,1 @@\n-            } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            } else if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -374,1 +374,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"session\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"session\")) {\n@@ -259,1 +259,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"session\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"session\")) {\n@@ -458,1 +458,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,session\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,session\")) {\n@@ -466,1 +466,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,session\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,session\")) {\n@@ -485,1 +485,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -493,1 +493,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -865,1 +865,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"session\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"session\")) {\n@@ -1135,1 +1135,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"session\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"session\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -373,1 +373,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"handshake\")) {\n@@ -576,1 +576,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -594,1 +594,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -604,1 +604,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -699,1 +699,1 @@\n-                            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -720,1 +720,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -835,1 +835,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -871,1 +871,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1030,1 +1030,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1051,1 +1051,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1137,1 +1137,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1145,1 +1145,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1221,1 +1221,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1330,1 +1330,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1338,1 +1338,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1546,1 +1546,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1565,1 +1565,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1673,1 +1673,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1750,1 +1750,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1776,1 +1776,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1831,1 +1831,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -1841,1 +1841,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -246,1 +246,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -409,1 +409,1 @@\n-                if (SSLLogger.isOn) {\n+                if (SSLLogger.isOn()) {\n@@ -448,1 +448,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -491,1 +491,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -497,1 +497,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -70,1 +70,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -84,1 +84,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -102,1 +102,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -130,1 +130,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -144,1 +144,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -180,1 +180,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -194,1 +194,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -215,1 +215,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -234,1 +234,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -260,1 +260,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -274,1 +274,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n@@ -296,1 +296,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -333,1 +333,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"record\")) {\n@@ -348,1 +348,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"packet\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketOutputRecord.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -164,1 +164,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,verbose\")) {\n@@ -184,1 +184,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,verbose\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,verbose\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLTransport.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -443,1 +443,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -456,1 +456,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -573,1 +573,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -726,1 +726,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -733,1 +733,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -786,1 +786,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -848,1 +848,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -889,1 +889,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -934,1 +934,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -989,1 +989,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1135,1 +1135,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -1207,1 +1207,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -150,1 +150,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHelloDone.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -264,1 +264,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -290,1 +290,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -308,1 +308,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -325,1 +325,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -350,1 +350,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -444,1 +444,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -454,1 +454,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -531,1 +531,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -541,1 +541,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerNameExtension.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -106,1 +106,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -255,1 +255,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -297,1 +297,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -312,1 +312,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -331,1 +331,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -397,1 +397,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -409,1 +409,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -453,1 +453,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -465,1 +465,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -469,1 +469,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -549,1 +549,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -221,1 +221,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -300,1 +300,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -435,1 +435,1 @@\n-                if (SSLLogger.isOn &&\n+                if (SSLLogger.isOn() &&\n@@ -454,1 +454,1 @@\n-                } else if (SSLLogger.isOn &&\n+                } else if (SSLLogger.isOn() &&\n@@ -459,1 +459,1 @@\n-            } else if (SSLLogger.isOn &&\n+            } else if (SSLLogger.isOn() &&\n@@ -479,1 +479,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -489,1 +489,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -548,1 +548,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -577,1 +577,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -663,1 +663,1 @@\n-            if (SSLLogger.isOn &&\n+            if (SSLLogger.isOn() &&\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -128,1 +128,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -168,1 +168,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -195,1 +195,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -222,1 +222,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -229,1 +229,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -260,1 +260,1 @@\n-                            if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                            if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -269,1 +269,1 @@\n-                        } else if (SSLLogger.isOn &&\n+                        } else if (SSLLogger.isOn() &&\n@@ -275,1 +275,1 @@\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                        if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -283,1 +283,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -311,1 +311,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -326,1 +326,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -333,1 +333,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -496,1 +496,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -508,1 +508,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -514,1 +514,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -544,1 +544,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -557,1 +557,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -576,1 +576,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -581,1 +581,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"respmgr\")) {\n@@ -603,1 +603,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -626,1 +626,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n@@ -663,1 +663,1 @@\n-                if (SSLLogger.isOn &&\n+                if (SSLLogger.isOn() &&\n@@ -681,1 +681,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n@@ -695,1 +695,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -707,1 +707,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -724,1 +724,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -746,1 +746,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -755,1 +755,1 @@\n-                        if (SSLLogger.isOn &&\n+                        if (SSLLogger.isOn() &&\n@@ -766,1 +766,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -774,1 +774,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/StatusResponseManager.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"keymanager\")) {\n@@ -318,1 +318,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"keymanager\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SunX509KeyManagerImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -180,1 +180,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -196,1 +196,1 @@\n-                } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                } else if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -203,1 +203,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -247,1 +247,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -322,1 +322,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -338,1 +338,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -355,1 +355,1 @@\n-                } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                } else if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -362,1 +362,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -402,1 +402,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SupportedGroupsExtension.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -219,1 +219,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -311,1 +311,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -320,1 +320,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -359,1 +359,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -402,1 +402,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -444,1 +444,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n@@ -486,1 +486,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,handshake\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SupportedVersionsExtension.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -333,1 +333,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -344,1 +344,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -367,1 +367,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -383,1 +383,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -414,1 +414,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -427,1 +427,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -443,1 +443,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -529,1 +529,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -586,1 +586,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -56,1 +56,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -62,1 +62,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -68,1 +68,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TrustManagerFactoryImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -154,1 +154,1 @@\n-                    if (SSLLogger.isOn &&\n+                    if (SSLLogger.isOn() &&\n@@ -270,1 +270,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -324,1 +324,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -332,1 +332,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -337,1 +337,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -358,1 +358,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n@@ -385,1 +385,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"trustmanager\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"trustmanager\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TrustStoreManager.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -119,1 +119,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Utilities.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -246,1 +246,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -255,1 +255,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -264,1 +264,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -273,1 +273,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -283,1 +283,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -299,1 +299,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -340,1 +340,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -348,1 +348,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -357,1 +357,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -367,1 +367,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -382,1 +382,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -401,1 +401,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509Authentication.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"keymanager\")) {\n@@ -137,1 +137,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"keymanager\")) {\n@@ -153,1 +153,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"keymanager\")) {\n@@ -222,1 +222,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"keymanager\")) {\n@@ -238,1 +238,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"keymanager\")) {\n@@ -395,1 +395,1 @@\n-                                if (SSLLogger.isOn &&\n+                                if (SSLLogger.isOn() &&\n@@ -411,1 +411,1 @@\n-                            if (SSLLogger.isOn &&\n+                            if (SSLLogger.isOn() &&\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerCertChecking.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,keymanager\")) {\n@@ -258,1 +258,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,keymanager\")) {\n@@ -298,1 +298,1 @@\n-                            if (SSLLogger.isOn\n+                            if (SSLLogger.isOn()\n@@ -315,1 +315,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,keymanager\")) {\n@@ -321,1 +321,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,keymanager\")) {\n@@ -361,1 +361,1 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+            if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,keymanager\")) {\n@@ -367,1 +367,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,keymanager\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,trustmanager\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,trustmanager\")) {\n@@ -101,1 +101,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,trustmanager\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,trustmanager\")) {\n@@ -245,1 +245,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,trustmanager\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,trustmanager\")) {\n@@ -291,1 +291,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,trustmanager\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,trustmanager\")) {\n@@ -334,1 +334,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,trustmanager\")) {\n+        if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,trustmanager\")) {\n@@ -368,1 +368,1 @@\n-                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,trustmanager\")) {\n+                    if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl,trustmanager\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509TrustManagerImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -324,1 +324,2 @@\n-jks.storetype.warning=The %1$s keystore uses a proprietary format. It is recommended to migrate to PKCS12 which is an industry standard format using \"keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\".\n+jks.storetype.warning=%1$s uses outdated cryptographic algorithms and will be removed in a future release. Migrate to PKCS12 using:\\n\\\n+keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/resources\/keytool.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import jdk.internal.util.StaticProperty;\n@@ -196,1 +195,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n@@ -213,1 +212,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\") &&\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\") &&\n@@ -234,1 +233,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                if (SSLLogger.isOn() && SSLLogger.isOn(\"ssl\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DomainName.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-            if (SSLLogger.isOn) {\n+            if (SSLLogger.isOn()) {\n@@ -311,1 +311,1 @@\n-            if (SSLLogger.isOn) {\n+            if (SSLLogger.isOn()) {\n@@ -331,1 +331,1 @@\n-            if (SSLLogger.isOn) {\n+            if (SSLLogger.isOn()) {\n@@ -356,1 +356,1 @@\n-            if (SSLLogger.isOn) {\n+            if (SSLLogger.isOn()) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/HostnameChecker.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.util;\n+\n+import javax.crypto.SecretKey;\n+\n+\/**\n+ * An interface for <code>SecretKey<\/code>s that support using its slice as a new\n+ * <code>SecretKey<\/code>.\n+ * <p>\n+ * This is mainly used by PKCS #11 implementations that support the\n+ * EXTRACT_KEY_FROM_KEY mechanism even if the key itself is sensitive\n+ * and non-extractable.\n+ *\/\n+public interface SliceableSecretKey {\n+\n+    \/**\n+     * Returns a slice as a new <code>SecretKey<\/code>.\n+     *\n+     * @param alg the new algorithm name\n+     * @param from the byte offset of the new key in the full key\n+     * @param to the to offset (exclusive) of the new key in the full key\n+     * @return the new key\n+     * @throws ArrayIndexOutOfBoundsException for improper <code>from<\/code>\n+     *      and <code>to<\/code> values\n+     * @throws UnsupportedOperationException if slicing is not supported\n+     *\/\n+    SecretKey slice(String alg, int from, int to);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SliceableSecretKey.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -113,3 +113,2 @@\n-\n-    \/\/ TBD:   assert(module_name_len > 0, \"module name must be non-empty\");\n-    assert(name_len > 0 && \"resource name must be non-empty\");\n+    assert(module_name_len > 0 && \"module name must be non-empty\");\n+    assert(name_len > 0 && \"name must non-empty\");\n","filename":"src\/java.base\/share\/native\/libjimage\/jimage.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -391,2 +391,6 @@\n-        sysinfo(SI_ISALIST, list, sizeof(list));\n-        sprops.cpu_isalist = strdup(list);\n+        int ret = sysinfo(SI_ISALIST, list, sizeof(list));\n+        if (ret == 0) {\n+            sprops.cpu_isalist = strdup(list);\n+        } else {\n+            sprops.cpu_isalist = NULL;\n+        }\n@@ -441,1 +445,1 @@\n-     * file.encoding system properties. *\/\n+     * native.encoding system properties. *\/\n","filename":"src\/java.base\/unix\/native\/libjava\/java_props_md.c","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -572,1 +572,1 @@\n-     *  file.encoding\n+     *  native.encoding\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,2 +268,6 @@\n-     *         is less than 0\n-     * @throws IllegalArgumentException if {@code pixelStride} is less than 0\n+     *         is less than or equal to 0\n+     * @throws IllegalArgumentException if {@code pixelStride} is less than or equal to 0\n+     * @throws IllegalArgumentException if {@code w * pixelStride} is greater\n+     *         than {@code scanlineStride}\n+     * @throws IllegalArgumentException if the data size need to store all\n+     *          lines of the image is greater than {@code Integer.MAX_VALUE}\n@@ -271,0 +275,2 @@\n+     * @throws IllegalArgumentException if any element of {@code bandOffsets} is greater\n+     *         than {@code pixelStride} or the {@code scanlineStride}\n@@ -288,2 +294,2 @@\n-        if (pixelStride < 0) {\n-            throw new IllegalArgumentException(\"pixelStride is < 0\");\n+        if (pixelStride <= 0) {\n+            throw new IllegalArgumentException(\"pixelStride is <= 0\");\n@@ -291,2 +297,5 @@\n-        if (scanlineStride < 0) {\n-            throw new IllegalArgumentException(\"scanlineStride is < 0\");\n+        if (scanlineStride <= 0) {\n+            throw new IllegalArgumentException(\"scanlineStride is <= 0\");\n+        }\n+        if (bandOffsets == null) {\n+            throw new NullPointerException(\"bandOffsets is null\");\n@@ -294,2 +303,10 @@\n-        int size = scanlineStride * (h - 1) + \/\/ first (h - 1) scans\n-            pixelStride * w; \/\/ last scan\n+        lsz = (long)w * pixelStride;\n+        if (lsz > scanlineStride) {\n+            throw new IllegalArgumentException(\"w * pixelStride is too large\");\n+        }\n+        lsz = (long)scanlineStride * (long)(h - 1) + \/\/ first (h - 1) scans\n+            (long)pixelStride * (long)w; \/\/ last scan\n+        if (lsz > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"size too large to store image\");\n+        }\n+        int size = (int)lsz;\n@@ -418,0 +435,4 @@\n+     * @throws IllegalArgumentException if the lengths of {@code bankIndices}\n+     *         and {@code bandOffsets} are different.\n+     * @throws IllegalArgumentException if the data size need to store all\n+     *          lines of a bank of the image is greater than {@code Integer.MAX_VALUE}\n@@ -426,3 +447,0 @@\n-        DataBuffer d;\n-        int bands = bandOffsets.length;\n-\n@@ -443,1 +461,5 @@\n-                ArrayIndexOutOfBoundsException(\"Band offsets array is null\");\n+                NullPointerException(\"Band offsets array is null\");\n+        }\n+        if (bandOffsets.length != bankIndices.length) {\n+            throw new IllegalArgumentException(\n+                                   \"bankIndices.length != bandOffsets.length\");\n@@ -454,0 +476,3 @@\n+        DataBuffer d;\n+        int bands = bandOffsets.length;\n+\n@@ -466,3 +491,9 @@\n-        int size = maxBandOff +\n-            scanlineStride * (h - 1) + \/\/ first (h - 1) scans\n-            w; \/\/ last scan\n+\n+        lsz = (long) maxBandOff +\n+              (long)scanlineStride * (h - 1) + \/\/ first (h - 1) scans\n+               w; \/\/ last scan\n+        if (lsz > Integer.MAX_VALUE) {\n+             throw new IllegalArgumentException(\"storage size is too large\");\n+        }\n+\n+        int size = (int)lsz;\n@@ -511,2 +542,6 @@\n-     * @throws RasterFormatException if {@code w} or {@code h}\n-     *         is less than or equal to zero, or computing either\n+     * @throws NullPointerException if {@code bandMasks} is null\n+     * @throws IllegalArgumentException if {@code w} and {@code h}\n+     *         are not both greater than 0\n+     * @throws IllegalArgumentException if the product of {@code w}\n+     *         and {@code h} is greater than {@code Integer.MAX_VALUE}\n+     * @throws RasterFormatException if computing either\n@@ -514,2 +549,1 @@\n-     *         {@code location.y + h} results in integer\n-     *         overflow\n+     *         {@code location.y + h} results in integer overflow\n@@ -528,0 +562,18 @@\n+        if (w <= 0 || h <= 0) {\n+             throw new IllegalArgumentException(\"w and h must be positive\");\n+        }\n+        long lsz = (long)w * h;\n+        if (lsz > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Dimensions (width=\"+w+\n+                                               \" height=\"+h+\") are too large\");\n+        }\n+\n+        if (location != null) {\n+            if ((w + location.getX() > Integer.MAX_VALUE) ||\n+                (h + location.getY() > Integer.MAX_VALUE)) {\n+              throw new RasterFormatException(\n+                 \"location.x + w and location.y + h \" +\n+                 \" cannot exceed Integer.MAX_VALUE\");\n+            }\n+        }\n+\n@@ -576,5 +628,2 @@\n-     * @throws RasterFormatException if {@code w} or {@code h}\n-     *         is less than or equal to zero, or computing either\n-     *         {@code location.x + w} or\n-     *         {@code location.y + h} results in integer\n-     *         overflow\n+     * @throws IllegalArgumentException if {@code bitsPerBand} or\n+     *         {@code bands} is not greater than zero\n@@ -585,2 +634,7 @@\n-     * @throws IllegalArgumentException if {@code bitsPerBand} or\n-     *         {@code bands} is not greater than zero\n+     * @throws IllegalArgumentException if {@code w} and {@code h}\n+     *         are not both greater than 0\n+     * @throws IllegalArgumentException if the product of {@code w}\n+     *         and {@code h} is greater than {@code Integer.MAX_VALUE}\n+     * @throws RasterFormatException if computing either\n+     *         {@code location.x + w} or\n+     *         {@code location.y + h} results in integer overflow\n@@ -610,0 +664,27 @@\n+        if (w <= 0 || h <= 0) {\n+             throw new IllegalArgumentException(\"w and h must be positive\");\n+        }\n+        long lsz = (long)w * h;\n+        if (lsz > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Dimensions (width=\"+w+\n+                                               \" height=\"+h+\") are too large\");\n+        }\n+\n+        if (location != null) {\n+            if ((w + location.getX() > Integer.MAX_VALUE) ||\n+                (h + location.getY() > Integer.MAX_VALUE)) {\n+              throw new RasterFormatException(\n+                 \"location.x + w and location.y + h \" +\n+                 \" cannot exceed Integer.MAX_VALUE\");\n+            }\n+        }\n+\n+        int shift = (bands-1)*bitsPerBand;\n+\n+        \/* Make sure the total mask size will fit in the data type *\/\n+        if (shift+bitsPerBand > DataBuffer.getDataTypeSize(dataType)) {\n+            throw new IllegalArgumentException(\"bitsPerBand(\"+\n+                                               bitsPerBand+\") * bands is \"+\n+                                               \" greater than data type \"+\n+                                               \"size.\");\n+        }\n@@ -613,9 +694,1 @@\n-            int shift = (bands-1)*bitsPerBand;\n-\n-            \/* Make sure the total mask size will fit in the data type *\/\n-            if (shift+bitsPerBand > DataBuffer.getDataTypeSize(dataType)) {\n-                throw new IllegalArgumentException(\"bitsPerBand(\"+\n-                                                   bitsPerBand+\") * bands is \"+\n-                                                   \" greater than data type \"+\n-                                                   \"size.\");\n-            }\n+\n@@ -696,0 +769,1 @@\n+     * @throws RasterFormatException if {@code dataBuffer} is too small.\n@@ -707,0 +781,2 @@\n+     * @throws IllegalArgumentException if any element of {@code bandOffsets} is greater\n+     *         than {@code pixelStride} or the {@code scanlineStride}\n@@ -782,0 +858,4 @@\n+     * @throws IllegalArgumentException if the lengths of {@code bankIndices}\n+     *         and {@code bandOffsets} are different.\n+     * @throws ArrayIndexOutOfBoundsException if any element of {@code bankIndices}\n+     *         is greater or equal to the number of bands in {@code dataBuffer}\n@@ -886,2 +966,6 @@\n-     * @throws RasterFormatException if {@code w} or {@code h}\n-     *         is less than or equal to zero, or computing either\n+     * @throws NullPointerException if {@code bandMasks} is null\n+     * @throws IllegalArgumentException if {@code w} and {@code h}\n+     *         are not both greater than 0\n+     * @throws IllegalArgumentException if the product of {@code w}\n+     *         and {@code h} is greater than {@code Integer.MAX_VALUE}\n+     * @throws RasterFormatException if computing either\n@@ -889,2 +973,1 @@\n-     *         {@code location.y + h} results in integer\n-     *         overflow\n+     *         {@code location.y + h} results in integer overflow\n@@ -909,0 +992,19 @@\n+\n+        if (w <= 0 || h <= 0) {\n+             throw new IllegalArgumentException(\"w and h must be positive\");\n+        }\n+        long lsz = (long)w * h;\n+        if (lsz > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Dimensions (width=\"+w+\n+                                               \" height=\"+h+\") are too large\");\n+        }\n+\n+        if (location != null) {\n+            if ((w + location.getX() > Integer.MAX_VALUE) ||\n+                (h + location.getY() > Integer.MAX_VALUE)) {\n+              throw new RasterFormatException(\n+                 \"location.x + w and location.y + h \" +\n+                 \" cannot exceed Integer.MAX_VALUE\");\n+            }\n+        }\n+\n@@ -963,2 +1065,5 @@\n-     * @throws RasterFormatException if {@code w} or {@code h}\n-     *         is less than or equal to zero, or computing either\n+     * @throws IllegalArgumentException if {@code w} and {@code h}\n+     *         are not both greater than 0\n+     * @throws IllegalArgumentException if the product of {@code w}\n+     *         and {@code h} is greater than {@code Integer.MAX_VALUE}\n+     * @throws RasterFormatException if computing either\n@@ -966,2 +1071,1 @@\n-     *         {@code location.y + h} results in integer\n-     *         overflow\n+     *         {@code location.y + h} results in integer overflow\n@@ -975,0 +1079,2 @@\n+     * @throws RasterFormatException if {@code bitsPixel} is less than 1 or\n+     *         not a power of 2 or exceeds the {@code dataBuffer} element size.\n@@ -985,0 +1091,19 @@\n+        if (w <= 0 || h <= 0) {\n+             throw new IllegalArgumentException(\"w and h must be positive\");\n+        }\n+        long lsz = (long)w * h;\n+\n+        if (lsz > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Dimensions (width=\"+w+\n+                                               \" height=\"+h+\") are too large\");\n+        }\n+\n+        if (location != null) {\n+            if ((w + location.getX() > Integer.MAX_VALUE) ||\n+                (h + location.getY() > Integer.MAX_VALUE)) {\n+              throw new RasterFormatException(\n+                 \"location.x + w and location.y + h \" +\n+                 \" cannot exceed Integer.MAX_VALUE\");\n+            }\n+        }\n+\n@@ -1003,0 +1128,6 @@\n+        if ((bitsPerPixel < 1) || (bitsPerPixel > DataBuffer.getDataTypeSize(dataType))) {\n+            \/\/ NB MPPSM checks power of 2 condition\n+            throw new\n+                RasterFormatException(\"bitsPerPixel must be > 0 and a power of 2 that \" +\n+                                      \"does not exceed data buffer element size\");\n+        }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/Raster.java","additions":175,"deletions":44,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,0 +220,7 @@\n+        } else {\n+            Rectangle emptyRect = new Rectangle();\n+            emptyRect.x = 5;\n+            emptyRect.y = 5;\n+            emptyRect.width = b.getWidth() - emptyRect.x * 2;\n+            emptyRect.height = b.getHeight() - emptyRect.y * 2;\n+            focusRect.setBounds(emptyRect);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalButtonUI.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,2 +139,1 @@\n-                                    Object srcData, Object dstData,\n-                                    int srcType, int dstType);\n+                                    Object srcData, Object dstData);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.annotation.Native;\n@@ -72,6 +71,0 @@\n-    @Native\n-    private static final int DT_BYTE = 0;\n-    @Native\n-    private static final int DT_SHORT = 1;\n-    @Native\n-    private static final int DT_INT = 2;\n@@ -79,1 +72,0 @@\n-    int dataType;\n@@ -96,1 +88,0 @@\n-     * @param  dt the type of data array: DT_BYTE, DT_SHORT or DT_INT\n@@ -99,1 +90,1 @@\n-    private LCMSImageLayout(Object data, int length, int nc, int dt, int size) {\n+    private LCMSImageLayout(Object data, int length, int nc, int size) {\n@@ -101,1 +92,0 @@\n-        dataType = dt;\n@@ -112,1 +102,1 @@\n-        this(data, data.length, nc, DT_BYTE, Byte.BYTES);\n+        this(data, data.length, nc, Byte.BYTES);\n@@ -116,1 +106,1 @@\n-        this(data, data.length, nc, DT_SHORT, Short.BYTES);\n+        this(data, data.length, nc, Short.BYTES);\n@@ -189,1 +179,0 @@\n-                l.dataType = DT_INT;\n@@ -204,1 +193,0 @@\n-                l.dataType = DT_BYTE;\n@@ -215,1 +203,0 @@\n-                l.dataType = DT_SHORT;\n@@ -322,1 +309,0 @@\n-            l.dataType = DT_BYTE;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -124,2 +124,1 @@\n-                          in.dataArray, out.dataArray,\n-                          in.dataType, out.dataType);\n+                          in.dataArray, out.dataArray);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"sun_java2d_cmm_lcms_LCMSImageLayout.h\"\n@@ -49,4 +48,0 @@\n-#define DT_BYTE     sun_java2d_cmm_lcms_LCMSImageLayout_DT_BYTE\n-#define DT_SHORT    sun_java2d_cmm_lcms_LCMSImageLayout_DT_SHORT\n-#define DT_INT      sun_java2d_cmm_lcms_LCMSImageLayout_DT_INT\n-\n@@ -467,28 +462,0 @@\n-static void *getILData(JNIEnv *env, jobject data, jint type) {\n-    switch (type) {\n-        case DT_BYTE:\n-            return (*env)->GetByteArrayElements(env, data, 0);\n-        case DT_SHORT:\n-            return (*env)->GetShortArrayElements(env, data, 0);\n-        case DT_INT:\n-            return (*env)->GetIntArrayElements(env, data, 0);\n-        default:\n-            return NULL;\n-    }\n-}\n-\n-static void releaseILData(JNIEnv *env, void *pData, jint type, jobject data,\n-                          jint mode) {\n-    switch (type) {\n-        case DT_BYTE:\n-            (*env)->ReleaseByteArrayElements(env, data, (jbyte *) pData, mode);\n-            break;\n-        case DT_SHORT:\n-            (*env)->ReleaseShortArrayElements(env, data, (jshort *) pData, mode);\n-            break;\n-        case DT_INT:\n-            (*env)->ReleaseIntArrayElements(env, data, (jint *) pData, mode);\n-            break;\n-    }\n-}\n-\n@@ -498,1 +465,1 @@\n- * Signature: (JIIIIIIZZLjava\/lang\/Object;Ljava\/lang\/Object;)V\n+ * Signature: (JIIIIIILjava\/lang\/Object;Ljava\/lang\/Object;)V\n@@ -503,1 +470,1 @@\n-   jobject srcData, jobject dstData, jint srcDType, jint dstDType)\n+   jobject srcData, jobject dstData)\n@@ -506,1 +473,0 @@\n-\n@@ -514,1 +480,1 @@\n-    void *inputBuffer = getILData(env, srcData, srcDType);\n+    void *inputBuffer = (*env)->GetPrimitiveArrayCritical(env, srcData, NULL);\n@@ -516,1 +482,0 @@\n-        J2dRlsTraceLn(J2D_TRACE_ERROR, \"\");\n@@ -520,0 +485,4 @@\n+    void *outputBuffer = (*env)->GetPrimitiveArrayCritical(env, dstData, NULL);\n+    if (outputBuffer != NULL) {\n+        char *input = (char *) inputBuffer + srcOffset;\n+        char *output = (char *) outputBuffer + dstOffset;\n@@ -521,6 +490,2 @@\n-    void *outputBuffer = getILData(env, dstData, dstDType);\n-    if (outputBuffer == NULL) {\n-        releaseILData(env, inputBuffer, srcDType, srcData, JNI_ABORT);\n-        \/\/ An exception should have already been thrown.\n-        return;\n-    }\n+        cmsDoTransformLineStride(sTrans, input, output, width, height,\n+                                 srcNextRowOffset, dstNextRowOffset, 0, 0);\n@@ -528,8 +493,3 @@\n-    char *input = (char *) inputBuffer + srcOffset;\n-    char *output = (char *) outputBuffer + dstOffset;\n-\n-    cmsDoTransformLineStride(sTrans, input, output, width, height,\n-                             srcNextRowOffset, dstNextRowOffset, 0, 0);\n-\n-    releaseILData(env, inputBuffer, srcDType, srcData, JNI_ABORT);\n-    releaseILData(env, outputBuffer, dstDType, dstData, 0);\n+        (*env)->ReleasePrimitiveArrayCritical(env, dstData, outputBuffer, 0);\n+    }\n+    (*env)->ReleasePrimitiveArrayCritical(env, srcData, inputBuffer, JNI_ABORT);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":13,"deletions":53,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.net.http.HttpClient.Version;\n@@ -34,1 +33,0 @@\n-import java.util.concurrent.Executor;\n@@ -711,1 +709,1 @@\n-                                Throwable t = c.getRecordedCause();\n+                                final Http2TerminationCause tc = c.getTerminationCause();\n@@ -713,4 +711,2 @@\n-                                if (t != null) {\n-                                    if (!cached)\n-                                        c.close();\n-                                    ioe = new IOException(\"Can't get stream 1: \" + t, t);\n+                                if (tc != null) {\n+                                    ioe = new IOException(\"Can't get stream 1\", tc.getCloseCause());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.EOFException;\n@@ -237,1 +236,0 @@\n-    private EOFException STOPPED;\n@@ -240,2 +238,0 @@\n-        STOPPED = new EOFException(\"HTTP\/2 client stopped\");\n-        STOPPED.setStackTrace(new StackTraceElement[0]);\n@@ -256,1 +252,0 @@\n-        \/\/ send GOAWAY\n@@ -258,2 +253,0 @@\n-        \/\/ attempt graceful shutdown\n-        try { h2c.shutdown(STOPPED); } catch (Throwable t) {}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.Closeable;\n@@ -31,2 +32,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -39,0 +38,1 @@\n+import java.nio.channels.ClosedChannelException;\n@@ -40,2 +40,0 @@\n-import java.util.ArrayList;\n-import java.net.http.HttpConnectTimeoutException;\n@@ -43,0 +41,1 @@\n+import java.util.ArrayList;\n@@ -52,0 +51,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -59,0 +59,1 @@\n+\n@@ -133,1 +134,1 @@\n-class Http2Connection  {\n+class Http2Connection implements Closeable {\n@@ -146,0 +147,2 @@\n+    private final AtomicBoolean goAwaySent = new AtomicBoolean();\n+    private final AtomicBoolean goAwayRecvd = new AtomicBoolean();\n@@ -218,1 +221,1 @@\n-         * {@link #shutdown(Throwable) Shuts down} the connection, unless this event is\n+         * {@link #close(Http2TerminationCause) Closes} the connection, unless this event is\n@@ -231,8 +234,1 @@\n-                        debug.log(\"Not initiating idle connection shutdown\");\n-                    }\n-                    return;\n-                }\n-                if (!markIdleShutdownInitiated()) {\n-                    if (debug.on()) {\n-                        debug.log(\"Unexpected state %s, skipping idle connection shutdown\",\n-                                describeClosedState(closedState));\n+                        debug.log(\"Idle timeout event already cancelled, not initiating idle connection close\");\n@@ -242,0 +238,5 @@\n+                \/\/ the connection has been idle long enough, we now\n+                \/\/ mark a state indicating that the connection is chosen\n+                \/\/ for idle termination and should not be handed out (from the pool)\n+                \/\/ for newer requests.\n+                connTerminator.markForIdleTermination();\n@@ -245,6 +246,2 @@\n-            if (debug.on()) {\n-                debug.log(\"Initiating shutdown of HTTP connection which is idle for too long\");\n-            }\n-            HttpConnectTimeoutException hte = new HttpConnectTimeoutException(\n-                    \"HTTP connection idle, no active streams. Shutting down.\");\n-            shutdown(hte);\n+            \/\/ terminate the connection due to being idle long enough\n+            connTerminator.idleTimedOut();\n@@ -259,1 +256,1 @@\n-            \/\/ doing the shutdown\n+            \/\/ doing the close\n@@ -379,6 +376,0 @@\n-    private static final int HALF_CLOSED_LOCAL  = 1;\n-    private static final int HALF_CLOSED_REMOTE = 2;\n-    private static final int SHUTDOWN_REQUESTED = 4;\n-    \/\/ state when idle connection management initiates a shutdown of the connection, after\n-    \/\/ which the connection will go into SHUTDOWN_REQUESTED state\n-    private static final int IDLE_SHUTDOWN_INITIATED = 8;\n@@ -386,3 +377,0 @@\n-    private volatile int closedState;\n-\n-    \/\/-------------------------------------\n@@ -406,0 +394,1 @@\n+\n@@ -407,0 +396,1 @@\n+\n@@ -421,1 +411,1 @@\n-    private final AtomicReference<Throwable> cause = new AtomicReference<>();\n+    private final Terminator connTerminator = new Terminator();\n@@ -643,1 +633,0 @@\n-        boolean shouldClose = false;\n@@ -648,3 +637,0 @@\n-            if (finalStream && reserved == 0 && streams.isEmpty()) {\n-                shouldClose = true;\n-            }\n@@ -652,1 +638,1 @@\n-            shutdown(t); \/\/ in case the assert fires...\n+            close(Http2TerminationCause.forException(t)); \/\/ in case the assert fires...\n@@ -657,7 +643,3 @@\n-        \/\/ We should close the connection here if\n-        \/\/ it's not pooled. If it's not pooled it will\n-        \/\/ be marked final stream, reserved will be 0\n-        \/\/ after decrementing it by one, and there should\n-        \/\/ be no active request-response streams.\n-        if (shouldClose) {\n-            shutdown(new IOException(\"HTTP\/2 connection abandoned\"));\n+        \/\/ if the connection is eligible to be closed, we close it here\n+        if (shouldClose()) {\n+            close(Http2TerminationCause.noErrorTermination());\n@@ -665,1 +647,0 @@\n-\n@@ -668,1 +649,6 @@\n-    boolean shouldClose() {\n+    \/*\n+     * return true if the connection is marked as \"final stream\" and there\n+     * are no active streams on that connection and the connection isn't\n+     * reserved for a new stream.\n+     *\/\n+    final boolean shouldClose() {\n@@ -671,1 +657,1 @@\n-            return finalStream() && streams.isEmpty();\n+            return finalStream() && streams.isEmpty() && numReservedClientStreams == 0;\n@@ -843,15 +829,0 @@\n-    void close() {\n-        if (markHalfClosedLocal()) {\n-            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n-            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n-            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n-                Log.logTrace(\"Closing HTTP\/2 connection: to {0}\", connection.address());\n-                GoAwayFrame f = new GoAwayFrame(0,\n-                        ErrorFrame.NO_ERROR,\n-                        \"Requested by user\".getBytes(UTF_8));\n-                \/\/ TODO: set last stream. For now zero ok.\n-                sendFrame(f);\n-            }\n-        }\n-    }\n-\n@@ -859,0 +830,1 @@\n+\n@@ -907,1 +879,1 @@\n-            shutdown(e);\n+            close(Http2TerminationCause.forException(e));\n@@ -911,2 +883,6 @@\n-    Throwable getRecordedCause() {\n-        return cause.get();\n+    \/**\n+     * Closes the connection normally (with a NO_ERROR termination cause), if not already closed.\n+     *\/\n+    @Override\n+    public final void close() {\n+        close(Http2TerminationCause.noErrorTermination());\n@@ -915,30 +891,8 @@\n-    void shutdown(Throwable t) {\n-        int state = closedState;\n-        if (debug.on()) debug.log(() -> \"Shutting down h2c (state=\"+describeClosedState(state)+\"): \" + t);\n-        stateLock.lock();\n-        try {\n-            if (!markShutdownRequested()) return;\n-            cause.compareAndSet(null, t);\n-        } finally {\n-            stateLock.unlock();\n-        }\n-\n-        if (Log.errors()) {\n-            if (t!= null && (!(t instanceof EOFException) || isActive())) {\n-                Log.logError(t);\n-            } else if (t != null) {\n-                Log.logError(\"Shutting down connection: {0}\", t.getMessage());\n-            } else {\n-                Log.logError(\"Shutting down connection\");\n-            }\n-        }\n-        client2.removeFromPool(this);\n-        subscriber.stop(cause.get());\n-        for (Stream<?> s : streams.values()) {\n-            try {\n-                s.connectionClosing(t);\n-            } catch (Throwable e) {\n-                Log.logError(\"Failed to close stream {0}: {1}\", s.streamid, e);\n-            }\n-        }\n-        connection.close(cause.get());\n+    \/**\n+     * Closes the connection with the given termination cause, if not already closed.\n+     *\n+     * @param tc the termination cause. cannot be null.\n+     *\/\n+    final void close(final Http2TerminationCause tc) {\n+        Objects.requireNonNull(tc, \"termination cause cannot be null\");\n+        this.connTerminator.terminate(tc);\n@@ -984,1 +938,1 @@\n-                framesDecoder.close(\n+                protocolError(ErrorFrame.PROTOCOL_ERROR,\n@@ -986,1 +940,0 @@\n-                protocolError(GoAwayFrame.PROTOCOL_ERROR);\n@@ -992,1 +945,1 @@\n-                protocolError(ResetFrame.PROTOCOL_ERROR, protocolError);\n+                protocolError(ErrorFrame.PROTOCOL_ERROR, protocolError);\n@@ -1147,1 +1100,3 @@\n-        if (isMarked(closedState, SHUTDOWN_REQUESTED)) return;\n+        if (!isOpen()) {\n+            return;\n+        }\n@@ -1157,1 +1112,3 @@\n-            if (isMarked(closedState, SHUTDOWN_REQUESTED)) return;\n+            if (!isOpen()) {\n+                return;\n+            }\n@@ -1254,1 +1211,1 @@\n-            default -> protocolError(ErrorFrame.PROTOCOL_ERROR);\n+            default -> protocolError(ErrorFrame.PROTOCOL_ERROR, \"unknown frame: \" + frame);\n@@ -1258,2 +1215,6 @@\n-    boolean isOpen() {\n-        return !isMarkedForShutdown() && connection.channel().isOpen();\n+    \/**\n+     * Returns true if this connection hasn't been terminated and the underlying\n+     * {@linkplain NetworkChannel#isOpen() channel is open}. false otherwise.\n+     *\/\n+    final boolean isOpen() {\n+        return this.connTerminator.terminationCause.get() == null && connection.channel().isOpen();\n@@ -1298,0 +1259,1 @@\n+\n@@ -1349,2 +1311,1 @@\n-        if (finalStream() && streams.isEmpty()) {\n-            \/\/ should be only 1 stream, but there might be more if server push\n+        if (shouldClose()) {\n@@ -1375,3 +1336,1 @@\n-    private void handleWindowUpdate(WindowUpdateFrame f)\n-        throws IOException\n-    {\n+    private void handleWindowUpdate(WindowUpdateFrame f) {\n@@ -1386,1 +1345,1 @@\n-                protocolError(ErrorFrame.FLOW_CONTROL_ERROR);  \/\/ overflow\n+                protocolError(ErrorFrame.FLOW_CONTROL_ERROR, null);  \/\/ overflow\n@@ -1391,21 +1350,5 @@\n-    private void protocolError(int errorCode)\n-        throws IOException\n-    {\n-        protocolError(errorCode, null);\n-    }\n-\n-    private void protocolError(int errorCode, String msg)\n-        throws IOException\n-    {\n-        String protocolError = \"protocol error\" + (msg == null?\"\":(\": \" + msg));\n-        ProtocolException protocolException =\n-                new ProtocolException(protocolError);\n-        this.cause.compareAndSet(null, protocolException);\n-        if (markHalfClosedLocal()) {\n-            framesDecoder.close(protocolError);\n-            subscriber.stop(protocolException);\n-            if (debug.on()) debug.log(\"Sending GOAWAY due to \" + protocolException);\n-            GoAwayFrame frame = new GoAwayFrame(0, errorCode);\n-            sendFrame(frame);\n-        }\n-        shutdown(protocolException);\n+    private void protocolError(final int errorCode, final String msg) {\n+        final Http2TerminationCause terminationCause =\n+                Http2TerminationCause.forH2Error(errorCode, msg);\n+        framesDecoder.close(terminationCause.getLogMsg());\n+        close(terminationCause);\n@@ -1414,3 +1357,1 @@\n-    private void handleSettings(SettingsFrame frame)\n-        throws IOException\n-    {\n+    private void handleSettings(SettingsFrame frame) {\n@@ -1433,3 +1374,1 @@\n-    private void handlePing(PingFrame frame)\n-        throws IOException\n-    {\n+    private void handlePing(PingFrame frame) {\n@@ -1445,1 +1384,1 @@\n-        markHalfClosedRemote();\n+        goAwayRecvd.set(true);\n@@ -1602,4 +1541,4 @@\n-            cancelIdleShutdownEvent();\n-            \/\/ consider the reservation successful only if the connection's state hasn't moved\n-            \/\/ to \"being closed\"\n-            return isOpen();\n+            cancelIdleCloseEvent();\n+            \/\/ consider the reservation successful only if the connection is open and\n+            \/\/ hasn't been chosen for idle termination\n+            return !this.connTerminator.isMarkedForIdleTermination() && isOpen();\n@@ -1612,1 +1551,1 @@\n-     * Cancels any event that might have been scheduled to shutdown this connection. Must be called\n+     * Cancels any event that might have been scheduled to close this connection. Must be called\n@@ -1615,1 +1554,1 @@\n-    private void cancelIdleShutdownEvent() {\n+    private void cancelIdleCloseEvent() {\n@@ -1630,1 +1569,1 @@\n-            if (!isMarkedForShutdown()) {\n+            if (isOpen() && !this.connTerminator.isMarkedForIdleTermination()) {\n@@ -1636,1 +1575,2 @@\n-                cancelIdleShutdownEvent();\n+                \/\/ don't consider the connection idle anymore\n+                cancelIdleCloseEvent();\n@@ -1643,1 +1583,3 @@\n-        stream.cancel(new IOException(\"Stream \" + streamid + \" cancelled\", cause.get()));\n+        final Http2TerminationCause terminationCause = getTerminationCause();\n+        assert terminationCause != null : \"termination cause is null\";\n+        stream.cancel(new IOException(\"Stream \" + streamid + \" cancelled\", terminationCause.getCloseCause()));\n@@ -1746,5 +1688,4 @@\n-            if (isMarked(closedState, SHUTDOWN_REQUESTED)) {\n-                cause = this.cause.get();\n-                if (cause == null) {\n-                    cause = new IOException(\"Connection closed\");\n-                }\n+            if (!isOpen()) {\n+                final Http2TerminationCause terminationCause = getTerminationCause();\n+                assert terminationCause != null : \"termination cause is null\";\n+                cause = terminationCause.getCloseCause();\n@@ -1765,1 +1706,1 @@\n-            if (finalStream() && streams.isEmpty()) {\n+            if (shouldClose()) {\n@@ -1798,7 +1739,4 @@\n-            if (!isMarked(closedState, SHUTDOWN_REQUESTED)) {\n-                if (!client2.stopping()) {\n-                    Log.logError(e);\n-                    shutdown(e);\n-                } else if (debug.on()) {\n-                    debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n-                }\n+            if (!client2.stopping()) {\n+                Log.logError(e);\n+            } else if (debug.on()) {\n+                debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n@@ -1806,0 +1744,1 @@\n+            close(Http2TerminationCause.forException(e));\n@@ -1820,7 +1759,4 @@\n-            if (!isMarked(closedState, SHUTDOWN_REQUESTED)) {\n-                if (!client2.stopping()) {\n-                    Log.logError(e);\n-                    shutdown(e);\n-                } else if (debug.on()) {\n-                    debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n-                }\n+            if (!client2.stopping()) {\n+                Log.logError(e);\n+            } else if (debug.on()) {\n+                debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n@@ -1828,0 +1764,1 @@\n+            close(Http2TerminationCause.forException(e));\n@@ -1842,1 +1779,1 @@\n-            if (!isMarked(closedState, SHUTDOWN_REQUESTED)) {\n+            if (!client2.stopping()) {\n@@ -1844,1 +1781,2 @@\n-                shutdown(e);\n+            } else if (debug.on()) {\n+                debug.log(\"Failed to send %s while stopping: %s\", frame, e);\n@@ -1846,0 +1784,1 @@\n+            close(Http2TerminationCause.forException(e));\n@@ -1871,0 +1810,1 @@\n+                    assert buffer != null : \"null buffer obtained from non-empty queue\";\n@@ -1880,1 +1820,6 @@\n-                if (x != null) {\n+                \/\/ if there was any error or if the TubeSubscriber completed normally,\n+                \/\/ then close the connection\n+                if (x != null || completed) {\n+                    \/\/ although the connection terminator stops the scheduler too,\n+                    \/\/ we don't want to wait that \"long\" and instead we should immediately\n+                    \/\/ stop the scheduler so that we don't enter \"processQueue\" anymore.\n@@ -1891,1 +1836,5 @@\n-                    Http2Connection.this.shutdown(x);\n+                    \/\/ terminate the connection\n+                    final Http2TerminationCause tc = (x != null)\n+                            ? Http2TerminationCause.forException(x)\n+                            : Http2TerminationCause.noErrorTermination();\n+                    Http2Connection.this.close(tc);\n@@ -1941,5 +1890,11 @@\n-            String msg = isActive()\n-                    ? \"EOF reached while reading\"\n-                    : \"Idle connection closed by HTTP\/2 peer\";\n-            if (debug.on()) debug.log(msg);\n-            errorRef.compareAndSet(null, new EOFException(msg));\n+            if (isActive()) {\n+                final String msg = \"EOF reached while reading\";\n+                errorRef.compareAndSet(null, new EOFException(msg));\n+                if (debug.on()) {\n+                    debug.log(msg);\n+                }\n+            } else {\n+                if (debug.on()) {\n+                    debug.log(\"HTTP\/2 connection (with no active streams) closed by peer\");\n+                }\n+            }\n@@ -1958,9 +1913,5 @@\n-        void stop(Throwable error) {\n-            if (errorRef.compareAndSet(null, error)) {\n-                completed = true;\n-                scheduler.stop();\n-                queue.clear();\n-                if (subscription != null) {\n-                    subscription.cancel();\n-                }\n-                queue.clear();\n+        private void close() {\n+            scheduler.stop();\n+            queue.clear();\n+            if (subscription != null) {\n+                subscription.cancel();\n@@ -1968,0 +1919,1 @@\n+            queue.clear();\n@@ -1993,0 +1945,1 @@\n+\n@@ -2007,7 +1960,3 @@\n-                try {\n-                    connection.protocolError(ErrorFrame.FLOW_CONTROL_ERROR,\n-                            \"connection window exceeded (%s > %s)\"\n-                                    .formatted(received, windowSize));\n-                } catch (IOException io) {\n-                    connection.shutdown(io);\n-                }\n+                connection.protocolError(ErrorFrame.FLOW_CONTROL_ERROR,\n+                        \"connection window exceeded (%s > %s)\"\n+                                .formatted(received, windowSize));\n@@ -2036,34 +1985,14 @@\n-    private boolean isMarked(int state, int mask) {\n-        return (state & mask) == mask;\n-    }\n-\n-    private boolean isMarkedForShutdown() {\n-        final int closedSt = closedState;\n-        return isMarked(closedSt, IDLE_SHUTDOWN_INITIATED)\n-                || isMarked(closedSt, SHUTDOWN_REQUESTED);\n-    }\n-\n-    private boolean markShutdownRequested() {\n-        return markClosedState(SHUTDOWN_REQUESTED);\n-    }\n-\n-    private boolean markHalfClosedLocal() {\n-        return markClosedState(HALF_CLOSED_LOCAL);\n-    }\n-\n-    private boolean markHalfClosedRemote() {\n-        return markClosedState(HALF_CLOSED_REMOTE);\n-    }\n-\n-    private boolean markIdleShutdownInitiated() {\n-        return markClosedState(IDLE_SHUTDOWN_INITIATED);\n-    }\n-\n-    private boolean markClosedState(int flag) {\n-        int state, desired;\n-        do {\n-            state = desired = closedState;\n-            if ((state & flag) == flag) return false;\n-            desired = state | flag;\n-        } while (!CLOSED_STATE.compareAndSet(this, state, desired));\n-        return true;\n+    private void sendGoAway(final GoAwayFrame goAway) {\n+        \/\/ currently we send a GOAWAY just once irrespective of what value the\n+        \/\/ last stream id was in the GOAWAY frame\n+        if (!goAwaySent.compareAndSet(false, true)) {\n+            \/\/ already sent\n+            return;\n+        }\n+        if (Log.trace()) {\n+            Log.logTrace(\"{0} sending GOAWAY {1}\", connection, goAway);\n+        } else if (debug.on()) {\n+            debug.log(\"sending GOAWAY \" + goAway);\n+        }\n+        \/\/ this merely enqueues the frame\n+        sendFrame(goAway);\n@@ -2072,5 +2001,34 @@\n-    String describeClosedState(int state) {\n-        if (state == 0) return \"active\";\n-        String desc = null;\n-        if (isMarked(state, IDLE_SHUTDOWN_INITIATED)) {\n-            desc = \"idle-shutdown-initiated\";\n+    \/**\n+     * Returns the termination cause if the connection is closed, else returns null.\n+     *\/\n+    final Http2TerminationCause getTerminationCause() {\n+        return this.connTerminator.determineTerminationCause();\n+    }\n+\n+    \/\/ Responsible for doing all the necessary work for closing a Http2Connection\n+    private final class Terminator {\n+        \/\/ the cause for closing the connection. Must only be set in the\n+        \/\/ Terminator.terminate(Http2TerminationCause) method.\n+        private final AtomicReference<Http2TerminationCause> terminationCause = new AtomicReference<>();\n+        \/\/ true if it has been decided to terminate the connection due to being idle,\n+        \/\/ false otherwise. should be accessed only when holding the stateLock\n+        private boolean chosenForIdleTermination;\n+\n+        private void terminate(final Http2TerminationCause terminationCause) {\n+            Objects.requireNonNull(terminationCause, \"termination cause cannot be null\");\n+            \/\/ allow to be terminated only once\n+            stateLock.lock();\n+            try {\n+                final boolean success = this.terminationCause.compareAndSet(null, terminationCause);\n+                if (!success) {\n+                    \/\/ already terminated or is being terminated by some other thread\n+                    return;\n+                }\n+                \/\/ disable the idle timeout event, since we are now going to terminate the\n+                \/\/ connection\n+                Http2Connection.this.cancelIdleCloseEvent();\n+            } finally {\n+                stateLock.unlock();\n+            }\n+            \/\/ do the actual termination\n+            doTerminate();\n@@ -2078,2 +2036,45 @@\n-        if (isMarked(state, SHUTDOWN_REQUESTED)) {\n-            desc = desc == null ? \"shutdown\" : desc + \"+shutdown\";\n+\n+        private void doTerminate() {\n+            final Http2TerminationCause tc = terminationCause.get();\n+            assert tc != null : \"missing termination cause\";\n+            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n+            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n+            if (!Http2Connection.this.goAwayRecvd.get()) {\n+                final int lastStream = 0; \/\/ TODO: set last stream. For now zero is ok.\n+                final String peerVisibleReason = tc.getPeerVisibleReason();\n+                final GoAwayFrame goAway;\n+                if (peerVisibleReason == null) {\n+                    goAway = new GoAwayFrame(lastStream, tc.getCloseCode());\n+                } else {\n+                    goAway = new GoAwayFrame(lastStream, tc.getCloseCode(),\n+                            peerVisibleReason.getBytes(UTF_8));\n+                }\n+                sendGoAway(goAway);\n+            }\n+            \/\/ now close the connection\n+\n+            if (Log.errors() || debug.on()) {\n+                final String stateStr = \"Abnormal close=\" + tc.isAbnormalClose() +\n+                        \", has active streams=\" + isActive() +\n+                        \", GOAWAY received=\" + goAwayRecvd.get() +\n+                        \", GOAWAY sent=\" + goAwaySent.get();\n+                if (Log.errors()) {\n+                    Log.logError(\"Closing connection {0} ({1}) due to: {2}\",\n+                            connection, stateStr, tc);\n+                } else {\n+                    debug.log(\"Closing connection (\" + stateStr + \") due to: \" + tc);\n+                }\n+            }\n+            \/\/ close the TubeSubscriber\n+            subscriber.close();\n+            client2.removeFromPool(Http2Connection.this);\n+            \/\/ notify the HTTP\/2 streams of the connection closure\n+            for (final Stream<?> s : streams.values()) {\n+                try {\n+                    s.connectionClosing(tc.getCloseCause());\n+                } catch (Throwable e) {\n+                    Log.logError(\"Failed to close stream {0}: {1}\", s.streamid, e);\n+                }\n+            }\n+            \/\/ close the underlying connection\n+            connection.close(tc.getCloseCause());\n@@ -2081,3 +2082,5 @@\n-        if (isMarked(state, HALF_CLOSED_LOCAL | HALF_CLOSED_REMOTE)) {\n-            if (desc == null) return \"closed\";\n-            else return desc + \"+closed\";\n+\n+        private void markForIdleTermination() {\n+            assert stateLock.isHeldByCurrentThread() : Thread.currentThread()\n+                    + \" not holding stateLock\";\n+            this.chosenForIdleTermination = true;\n@@ -2085,3 +2088,5 @@\n-        if (isMarked(state, HALF_CLOSED_LOCAL)) {\n-            if (desc == null) return \"half-closed-local\";\n-            else return desc + \"+half-closed-local\";\n+\n+        private boolean isMarkedForIdleTermination() {\n+            assert stateLock.isHeldByCurrentThread() : Thread.currentThread()\n+                    + \" not holding stateLock\";\n+            return this.chosenForIdleTermination;\n@@ -2089,3 +2094,6 @@\n-        if (isMarked(state, HALF_CLOSED_REMOTE)) {\n-            if (desc == null) return \"half-closed-remote\";\n-            else return desc + \"+half-closed-remote\";\n+\n+        private void idleTimedOut() {\n+            if (debug.on()) {\n+                debug.log(\"closing connection due to being idle\");\n+            }\n+            this.terminate(Http2TerminationCause.idleTimedOut());\n@@ -2093,2 +2101,0 @@\n-        return \"0x\" + Integer.toString(state, 16);\n-    }\n@@ -2096,6 +2102,21 @@\n-    private static final VarHandle CLOSED_STATE;\n-    static {\n-        try {\n-            CLOSED_STATE = MethodHandles.lookup().findVarHandle(Http2Connection.class, \"closedState\", int.class);\n-        } catch (Exception x) {\n-            throw new ExceptionInInitializerError(x);\n+        \/**\n+         * Returns the termination cause for the connection. This method guarantees that if the\n+         * {@linkplain Http2Connection#isOpen() connection is not open}, when this method is called,\n+         * then it returns a non-null termination cause. Returns null if the connection is open.\n+         *\/\n+        private Http2TerminationCause determineTerminationCause() {\n+            final Http2TerminationCause tc = this.terminationCause.get();\n+            if (tc != null) {\n+                \/\/ already terminated, return the cause\n+                return tc;\n+            }\n+            if (!connection.channel().isOpen()) {\n+                \/\/ if the underlying SocketChannel isn't open, then terminate the connection.\n+                \/\/ that way when Http2Connection.isOpen() returns false in that situation, then this\n+                \/\/ getTerminationCause() will return a termination cause.\n+                terminate(Http2TerminationCause.forException(new ClosedChannelException()));\n+                final Http2TerminationCause terminated = this.terminationCause.get();\n+                assert terminated != null : \"missing termination cause\";\n+                return terminated;\n+            }\n+            return null; \/\/ connection still open\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":269,"deletions":248,"binary":false,"changes":517,"status":"modified"},{"patch":"@@ -0,0 +1,281 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http;\n+\n+\n+import java.io.IOException;\n+import java.net.ProtocolException;\n+import java.util.Objects;\n+\n+import jdk.internal.net.http.common.Utils;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+\n+\/**\n+ * Termination cause for an {@linkplain Http2Connection HTTP\/2 connection}\n+ *\/\n+public abstract sealed class Http2TerminationCause {\n+    private String logMsg;\n+    private String peerVisibleReason;\n+    private final int closeCode;\n+    private final Throwable originalCause;\n+    private final IOException reportedCause;\n+\n+    private Http2TerminationCause(final int closeCode, final Throwable closeCause) {\n+        this.closeCode = closeCode;\n+        this.originalCause = closeCause;\n+        if (closeCause != null) {\n+            this.logMsg = closeCause.toString();\n+        }\n+        this.reportedCause = toReportedCause(this.originalCause, this.logMsg);\n+    }\n+\n+    private Http2TerminationCause(final int closeCode, final String loggedAs) {\n+        this.closeCode = closeCode;\n+        this.originalCause = null;\n+        this.logMsg = loggedAs;\n+        this.reportedCause = toReportedCause(null, this.logMsg);\n+    }\n+\n+    \/**\n+     * Returns the error code (specified for HTTP\/2 ErrorFrame) that caused the\n+     * connection termination.\n+     *\/\n+    public final int getCloseCode() {\n+        return this.closeCode;\n+    }\n+\n+    \/**\n+     * Returns the {@link IOException} that is considered the cause of the connection termination.\n+     * Even a {@linkplain #isAbnormalClose() normal} termination will have\n+     * an {@code IOException} associated with it, so this method will always return a non-null instance.\n+     *\/\n+    public final IOException getCloseCause() {\n+        return this.reportedCause;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the connection was terminated due to some exception. {@code false}\n+     * otherwise.\n+     * A normal connection termination (for example, the connection idle timing out locally)\n+     * is not considered as an abnormal termination and this method returns {@code false} for\n+     * such cases.\n+     *\/\n+    public abstract boolean isAbnormalClose();\n+\n+    \/**\n+     * Returns the connection termination cause, represented as a string. Unlike the\n+     * {@linkplain #getPeerVisibleReason() peer-visible reason}, this log message will not be\n+     * sent across to the peer and it is thus allowed to include additional details that might\n+     * help debugging a connection termination.\n+     *\/\n+    public final String getLogMsg() {\n+        return logMsg;\n+    }\n+\n+    \/**\n+     * Returns the connection termination cause, represented as a string. This represents the\n+     * \"debugData\" that is sent to the peer in a\n+     * {@linkplain  jdk.internal.net.http.frame.GoAwayFrame GOAWAY frame}.\n+     *\/\n+    public final String getPeerVisibleReason() {\n+        return this.peerVisibleReason;\n+    }\n+\n+    \/**\n+     * Sets the connection termination cause, represented as a string, which will be sent\n+     * to the peer in a {@linkplain  jdk.internal.net.http.frame.GoAwayFrame GOAWAY frame}.\n+     * Unlike the {@link #getLogMsg() log message},\n+     * it is expected that this peer-visible reason will not contain anything that is not meant\n+     * to be viewed by the peer.\n+     *\/\n+    protected final void setPeerVisibleReason(final String reasonPhrase) {\n+        this.peerVisibleReason = reasonPhrase;\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents an\n+     * {@linkplain #isAbnormalClose() abnormal} termination due to the given {@code cause}.\n+     *\n+     * @param cause the termination cause, cannot be null.\n+     *\/\n+    public static Http2TerminationCause forException(final Throwable cause) {\n+        Objects.requireNonNull(cause);\n+        if (cause instanceof ProtocolException pe) {\n+            return new ProtocolError(pe);\n+        }\n+        return new InternalError(cause);\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents a\n+     * {@linkplain #isAbnormalClose() normal} termination.\n+     *\/\n+    public static Http2TerminationCause noErrorTermination() {\n+        return NoError.INSTANCE;\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents a\n+     * {@linkplain #isAbnormalClose() normal} termination due to the connection\n+     * being idle.\n+     *\/\n+    public static Http2TerminationCause idleTimedOut() {\n+        return NoError.IDLE_TIMED_OUT;\n+    }\n+\n+    \/**\n+     * Returns a connection termination cause that represents an\n+     * {@linkplain #isAbnormalClose() abnormal} termination due to the given {@code errorCode}.\n+     * Although this method does no checks for the {@code errorCode}, it is expected to be one\n+     * of the error codes specified by the HTTP\/2 RFC for the ErrorFrame.\n+     *\n+     * @param errorCode the error code\n+     * @param loggedAs  optional log message to be associated with this termination cause\n+     *\/\n+    public static Http2TerminationCause forH2Error(final int errorCode, final String loggedAs) {\n+        if (errorCode == ErrorFrame.PROTOCOL_ERROR) {\n+            return new ProtocolError(loggedAs);\n+        } else if (errorCode == ErrorFrame.FLOW_CONTROL_ERROR) {\n+            \/\/ we treat flow control error as a protocol error currently\n+            return new ProtocolError(loggedAs, true);\n+        }\n+        return new H2StandardError(errorCode, loggedAs);\n+    }\n+\n+    private static IOException toReportedCause(final Throwable original,\n+                                               final String fallbackExceptionMsg) {\n+        if (original == null) {\n+            return fallbackExceptionMsg == null\n+                    ? new IOException(\"connection terminated\")\n+                    : new IOException(fallbackExceptionMsg);\n+        } else if (original instanceof IOException ioe) {\n+            return ioe;\n+        } else {\n+            return Utils.toIOException(original);\n+        }\n+    }\n+\n+    private static final class NoError extends Http2TerminationCause {\n+        private static final IOException NO_ERROR_MARKER =\n+                new IOException(\"HTTP\/2 connection closed normally - no error\");\n+        private static final IOException NO_ERROR_IDLE_TIMED_OUT_MARKER =\n+                new IOException(\"HTTP\/2 connection idle timed out - no error\");\n+\n+        static {\n+            \/\/ remove the stacktrace from the marker exception instances\n+            NO_ERROR_MARKER.setStackTrace(new StackTraceElement[0]);\n+            NO_ERROR_IDLE_TIMED_OUT_MARKER.setStackTrace(new StackTraceElement[0]);\n+        }\n+\n+        private static final NoError INSTANCE = new NoError(false);\n+        private static final NoError IDLE_TIMED_OUT = new NoError(true);\n+\n+        private final boolean idleTimedOut;\n+\n+        private NoError(final boolean idleTimedOut) {\n+            super(ErrorFrame.NO_ERROR,\n+                    idleTimedOut ? NO_ERROR_IDLE_TIMED_OUT_MARKER : NO_ERROR_MARKER);\n+            this.idleTimedOut = idleTimedOut;\n+            setPeerVisibleReason(idleTimedOut ? \"idle timed out\" : \"no error\");\n+        }\n+\n+        @Override\n+        public boolean isAbnormalClose() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.idleTimedOut\n+                    ? \"No error - idle timed out\"\n+                    : \"No error - normal termination\";\n+        }\n+    }\n+\n+    private static sealed class H2StandardError extends Http2TerminationCause {\n+        private H2StandardError(final int errCode, final String msg) {\n+            super(errCode, msg);\n+            setPeerVisibleReason(ErrorFrame.stringForCode(errCode));\n+        }\n+\n+        private H2StandardError(final int errCode, final Throwable cause) {\n+            super(errCode, cause);\n+            setPeerVisibleReason(ErrorFrame.stringForCode(errCode));\n+        }\n+\n+        @Override\n+        public boolean isAbnormalClose() {\n+            return getCloseCode() != ErrorFrame.NO_ERROR;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return ErrorFrame.stringForCode(this.getCloseCode());\n+        }\n+    }\n+\n+    private static final class ProtocolError extends H2StandardError {\n+        private ProtocolError(final String msg) {\n+            this(msg, false);\n+        }\n+\n+        private ProtocolError(final String msg, final boolean flowControlError) {\n+            super(flowControlError\n+                            ? ErrorFrame.FLOW_CONTROL_ERROR\n+                            : ErrorFrame.PROTOCOL_ERROR,\n+                    new ProtocolException(msg));\n+        }\n+\n+        private ProtocolError(final ProtocolException pe) {\n+            super(ErrorFrame.PROTOCOL_ERROR, pe);\n+        }\n+\n+        @Override\n+        public boolean isAbnormalClose() {\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Protocol error - \" + this.getLogMsg();\n+        }\n+    }\n+\n+    private static final class InternalError extends Http2TerminationCause {\n+        private InternalError(final Throwable cause) {\n+            super(ErrorFrame.INTERNAL_ERROR, cause);\n+        }\n+\n+        @Override\n+        public boolean isAbnormalClose() {\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Internal error - \" + this.getLogMsg();\n+        }\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2TerminationCause.java","additions":281,"deletions":0,"binary":false,"changes":281,"status":"added"},{"patch":"@@ -101,0 +101,1 @@\n+import jdk.internal.net.http.common.Utils.UseVTForSelector;\n@@ -129,0 +130,10 @@\n+    static final UseVTForSelector USE_VT_FOR_SELECTOR =\n+        Utils.useVTForSelector(\"jdk.internal.httpclient.tcp.selector.useVirtualThreads\", \"default\");\n+    private static boolean useVtForSelector() {\n+        return switch (USE_VT_FOR_SELECTOR) {\n+            case ALWAYS -> true;\n+            case NEVER -> false;\n+            default -> true;\n+        };\n+    }\n+\n@@ -296,1 +307,0 @@\n-        var cf = pending.cf;\n@@ -345,0 +355,1 @@\n+    private final Thread selmgrThread;\n@@ -512,1 +523,5 @@\n-        selmgr.setDaemon(true);\n+        selmgrThread = useVtForSelector()\n+                ? Thread.ofVirtual().name(\"HttpClient-\" + id + \"-SelectorManager\")\n+                .inheritInheritableThreadLocals(false).unstarted(selmgr)\n+                : Thread.ofPlatform().name(\"HttpClient-\" + id + \"-SelectorManager\")\n+                .inheritInheritableThreadLocals(false).daemon().unstarted(selmgr);\n@@ -531,1 +546,1 @@\n-            selmgr.start();\n+            selmgrThread.start();\n@@ -638,1 +653,1 @@\n-        return selmgr.join(duration);\n+        return selmgrThread.join(duration);\n@@ -930,1 +945,1 @@\n-        return Thread.currentThread() == selmgr;\n+        return Thread.currentThread() == selmgrThread;\n@@ -1160,1 +1175,1 @@\n-    private static final class SelectorManager extends Thread {\n+    private static final class SelectorManager implements Runnable {\n@@ -1199,3 +1214,0 @@\n-            super(null, null,\n-                  \"HttpClient-\" + ref.id + \"-SelectorManager\",\n-                  0, false);\n@@ -1224,1 +1236,1 @@\n-            if (Thread.currentThread() == this) {\n+            if (owner.isSelectorThread()) {\n@@ -1318,0 +1330,4 @@\n+        String getName() {\n+            return owner.selmgrThread.getName();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -543,3 +543,1 @@\n-    void close(Throwable cause) {\n-        close();\n-    }\n+    abstract void close(Throwable cause);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpConnection.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,0 +245,9 @@\n+    public enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n+\n+    public static UseVTForSelector useVTForSelector(String property, String defval) {\n+        String useVtForSelector = System.getProperty(property, defval);\n+        return Stream.of(UseVTForSelector.values())\n+                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n+                .findFirst().orElse(UseVTForSelector.DEFAULT);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+        var label = \"quic:\" + connection.uniqueId();\n@@ -147,1 +148,1 @@\n-                + (peerIsServer ? \"server\" : \"client\") + \")\");\n+                + (peerIsServer ? \"server\" : \"client\") + \") on \" + label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/ConnectionTerminatorImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -349,2 +349,4 @@\n-        final TerminationCause cause = forSilentTermination(\"connection idle timed out (\"\n-                + timeoutMillis + \" milli seconds)\");\n+        var type = connection.isClientConnection() ? \"client\" : \"server\";\n+        var label = \"quic:\" + connection.uniqueId();\n+        final TerminationCause cause = forSilentTermination(type + \" connection idle timed out (\"\n+                + timeoutMillis + \" milli seconds) on \" + label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/IdleTimeoutManager.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-            var nextDeadline = this.nextDeadline;\n+            Deadline newDeadline;\n@@ -390,1 +390,0 @@\n-            congestionController.updatePacer(now);\n@@ -392,0 +391,1 @@\n+                congestionController.updatePacer(now);\n@@ -537,1 +537,1 @@\n-                \/\/ if nextDeadline is not Deadline.MAX the task will be\n+                \/\/ if newDeadline is not Deadline.MAX the task will be\n@@ -540,2 +540,3 @@\n-                nextDeadline = computeNextDeadline();\n-            } while(!nextDeadline.isAfter(now));\n+                newDeadline = computeNextDeadline();\n+                now = now();\n+            } while(!newDeadline.isAfter(now));\n@@ -543,2 +544,2 @@\n-            logNoDeadline(nextDeadline, true);\n-            if (Deadline.MAX.equals(nextDeadline)) return;\n+            logNoDeadline(newDeadline, true);\n+            if (Deadline.MAX.equals(newDeadline)) return;\n@@ -546,1 +547,1 @@\n-            packetEmitter.reschedule(this, nextDeadline);\n+            packetEmitter.reschedule(this, newDeadline);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/PacketSpaceManager.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.quic;\n+\n+import jdk.internal.net.http.common.Deadline;\n+import jdk.internal.net.http.common.Log;\n+import jdk.internal.net.http.common.TimeLine;\n+import jdk.internal.net.http.common.TimeSource;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.internal.net.http.quic.frames.AckFrame;\n+import jdk.internal.net.http.quic.packets.QuicPacket;\n+\n+import java.util.Collection;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\/**\n+ * Implementation of the common parts of a QUIC congestion controller based on RFC 9002.\n+ *\n+ * This class implements the common parts of a congestion controller:\n+ * - slow start\n+ * - loss recovery\n+ * - cooperation with pacer\n+ *\n+ * Subclasses implement congestion window growth in congestion avoidance phase.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc9002\n+ *      RFC 9002: QUIC Loss Detection and Congestion Control\n+ *\/\n+abstract class QuicBaseCongestionController implements QuicCongestionController {\n+    \/\/ higher of 14720 and 2*maxDatagramSize; we use fixed maxDatagramSize\n+    private static final int INITIAL_WINDOW = Math.max(14720, 2 * QuicConnectionImpl.DEFAULT_DATAGRAM_SIZE);\n+    private static final int MAX_BYTES_IN_FLIGHT = Math.clamp(\n+            Utils.getLongProperty(\"jdk.httpclient.quic.maxBytesInFlight\", 1 << 24),\n+            1 << 14, 1 << 24);\n+    final TimeLine timeSource;\n+    final String dbgTag;\n+    final Lock lock = new ReentrantLock();\n+    long congestionWindow = INITIAL_WINDOW;\n+    int maxDatagramSize = QuicConnectionImpl.DEFAULT_DATAGRAM_SIZE;\n+    int minimumWindow = 2 * maxDatagramSize;\n+    long bytesInFlight;\n+    \/\/ maximum bytes in flight seen since the last congestion event\n+    long maxBytesInFlight;\n+    Deadline congestionRecoveryStartTime;\n+    long ssThresh = Long.MAX_VALUE;\n+\n+    private final QuicPacer pacer;\n+\n+    QuicBaseCongestionController(String dbgTag, QuicRttEstimator rttEstimator) {\n+        this(dbgTag, TimeSource.source(), rttEstimator);\n+    }\n+\n+    \/\/ Allows to pass a custom timeline for testing\n+    QuicBaseCongestionController(String dbgTag, TimeLine source, QuicRttEstimator rttEstimator) {\n+        this.dbgTag = dbgTag;\n+        this.timeSource = source;\n+        this.pacer = new QuicPacer(rttEstimator, this);\n+    }\n+\n+    boolean inCongestionRecovery(Deadline sentTime) {\n+        return (congestionRecoveryStartTime != null &&\n+                !sentTime.isAfter(congestionRecoveryStartTime));\n+    }\n+\n+    abstract void onCongestionEvent(Deadline sentTime);\n+\n+    private static boolean inFlight(QuicPacket packet) {\n+        \/\/ packet is in flight if it contains anything other than a single ACK frame\n+        \/\/ specifically, a packet containing padding is considered to be in flight.\n+        return packet.frames().size() != 1 ||\n+                !(packet.frames().get(0) instanceof AckFrame);\n+    }\n+\n+    @Override\n+    public boolean canSendPacket() {\n+        lock.lock();\n+        try {\n+            if (bytesInFlight >= MAX_BYTES_IN_FLIGHT) {\n+                return false;\n+            }\n+            if (isCwndLimited() || isPacerLimited()) {\n+                return false;\n+            }\n+            return true;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void updateMaxDatagramSize(int newSize) {\n+        lock.lock();\n+        try {\n+            if (minimumWindow != newSize * 2) {\n+                minimumWindow = newSize * 2;\n+                maxDatagramSize = newSize;\n+                congestionWindow = Math.max(congestionWindow, minimumWindow);\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void packetSent(int packetBytes) {\n+        lock.lock();\n+        try {\n+            bytesInFlight += packetBytes;\n+            if (bytesInFlight > maxBytesInFlight) {\n+                maxBytesInFlight = bytesInFlight;\n+            }\n+            pacer.packetSent(packetBytes);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void packetAcked(int packetBytes, Deadline sentTime) {\n+        lock.lock();\n+        try {\n+            long oldWindow = congestionWindow;\n+            assert oldWindow >= minimumWindow :\n+                    \"Congestion window lower than minimum: %s < %s\".formatted(oldWindow, minimumWindow);\n+            bytesInFlight -= packetBytes;\n+            \/\/ RFC 9002 says we should not increase cwnd when application limited.\n+            \/\/ The concept itself is poorly defined.\n+            \/\/ Here we limit cwnd growth based on the maximum bytes in flight\n+            \/\/ observed since the last congestion event\n+            if (inCongestionRecovery(sentTime)) {\n+                if (Log.quicCC() && Log.trace()) {\n+                    Log.logQuic(dbgTag + \" Acked, in recovery: bytes: \" + packetBytes +\n+                            \", in flight: \" + bytesInFlight);\n+                }\n+                return;\n+            }\n+            boolean isAppLimited;\n+            if (congestionWindow < ssThresh) {\n+                isAppLimited = congestionWindow >= 2 * maxBytesInFlight;\n+                if (!isAppLimited) {\n+                    congestionWindow += packetBytes;\n+                }\n+            } else {\n+                isAppLimited = congestionAvoidanceAcked(packetBytes, sentTime);\n+            }\n+            if (Log.quicCC() && Log.trace()) {\n+                if (isAppLimited) {\n+                    Log.logQuic(dbgTag + \" Acked, not blocked: bytes: \" + packetBytes +\n+                            \", in flight: \" + bytesInFlight);\n+                } else {\n+                    Log.logQuic(dbgTag + \" Acked, increased: bytes: \" + packetBytes +\n+                            \", in flight: \" + bytesInFlight +\n+                            \", new cwnd:\" + congestionWindow);\n+                }\n+            }\n+            assert congestionWindow >= oldWindow :\n+                    \"Window size decreased on ACK: %s to %s\".formatted(oldWindow, congestionWindow);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    abstract boolean congestionAvoidanceAcked(int packetBytes, Deadline sentTime);\n+\n+    @Override\n+    public void packetLost(Collection<QuicPacket> lostPackets, Deadline sentTime, boolean persistent) {\n+        lock.lock();\n+        try {\n+            for (QuicPacket packet : lostPackets) {\n+                if (inFlight(packet)) {\n+                    bytesInFlight -= packet.size();\n+                }\n+            }\n+            onCongestionEvent(sentTime);\n+            if (persistent) {\n+                congestionWindow = minimumWindow;\n+                congestionRecoveryStartTime = null;\n+                if (Log.quicCC()) {\n+                    Log.logQuic(dbgTag + \" Persistent congestion: ssThresh: \" + ssThresh +\n+                            \", in flight: \" + bytesInFlight +\n+                            \", cwnd:\" + congestionWindow);\n+                }\n+            }\n+            assert congestionWindow >= minimumWindow :\n+                    \"Congestion window lower than minimum: %s < %s\".formatted(congestionWindow, minimumWindow);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void packetDiscarded(Collection<QuicPacket> discardedPackets) {\n+        lock.lock();\n+        try {\n+            for (QuicPacket packet : discardedPackets) {\n+                if (inFlight(packet)) {\n+                    bytesInFlight -= packet.size();\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public long congestionWindow() {\n+        lock.lock();\n+        try {\n+            return congestionWindow;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public long initialWindow() {\n+        lock.lock();\n+        try {\n+            return Math.max(14720, 2 * maxDatagramSize);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public long maxDatagramSize() {\n+        lock.lock();\n+        try {\n+            return maxDatagramSize;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isSlowStart() {\n+        lock.lock();\n+        try {\n+            return congestionWindow < ssThresh;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void updatePacer(Deadline now) {\n+        lock.lock();\n+        try {\n+            pacer.updateQuota(now);\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isPacerLimited() {\n+        lock.lock();\n+        try {\n+            return !pacer.canSend();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public boolean isCwndLimited() {\n+        lock.lock();\n+        try {\n+            return congestionWindow - bytesInFlight < maxDatagramSize;\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public Deadline pacerDeadline() {\n+        lock.lock();\n+        try {\n+            return pacer.twoPacketDeadline();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void appLimited() {\n+        lock.lock();\n+        try {\n+            pacer.appLimited();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicBaseCongestionController.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -337,1 +337,1 @@\n-        this.congestionController = new QuicRenoCongestionController(dbgTag, rttEstimator);\n+        this.congestionController = createCongestionController(dbgTag, rttEstimator);\n@@ -369,0 +369,10 @@\n+    private static QuicCongestionController createCongestionController\n+            (String dbgTag, QuicRttEstimator rttEstimator) {\n+        String algo = System.getProperty(\"jdk.internal.httpclient.quic.congestionController\", \"cubic\");\n+        if (algo.equalsIgnoreCase(\"reno\")) {\n+            return new QuicRenoCongestionController(dbgTag, rttEstimator);\n+        } else {\n+            return new QuicCubicCongestionController(dbgTag, rttEstimator);\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicConnectionImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.quic;\n+\n+import jdk.internal.net.http.common.Deadline;\n+import jdk.internal.net.http.common.Log;\n+import jdk.internal.net.http.common.TimeLine;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Implementation of the CUBIC congestion controller\n+ * based on RFC 9438.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/rfc\/rfc9438.html\n+ *       RFC 9438: CUBIC for Fast and Long-Distance Networks\n+ *\/\n+public final class QuicCubicCongestionController extends QuicBaseCongestionController {\n+\n+    public static final double BETA = 0.7;\n+    public static final double ALPHA = 3 * (1 - BETA) \/ (1 + BETA);\n+    private static final double C = 0.4;\n+    private final QuicRttEstimator rttEstimator;\n+    \/\/ Cubic curve inflection point, in bytes\n+    private long wMaxBytes;\n+    \/\/ cwnd before the most recent congestion event\n+    private long cwndPriorBytes;\n+    \/\/ \"t\" from RFC 9438\n+    private long timeNanos;\n+    \/\/ \"K\" from RFC 9438\n+    private long kNanos;\n+    \/\/ estimate for the Reno-friendly congestion window\n+    private long wEstBytes;\n+    \/\/ the most recent time when the congestion window was filled\n+    private Deadline lastFullWindow;\n+\n+    public QuicCubicCongestionController(String dbgTag, QuicRttEstimator rttEstimator) {\n+        super(dbgTag, rttEstimator);\n+        this.rttEstimator = rttEstimator;\n+    }\n+\n+    \/\/ for testing\n+    public QuicCubicCongestionController(TimeLine source, QuicRttEstimator rttEstimator) {\n+        super(\"TEST\", source, rttEstimator);\n+        this.rttEstimator = rttEstimator;\n+    }\n+\n+    @Override\n+    public void packetSent(int packetBytes) {\n+        lock.lock();\n+        try {\n+            super.packetSent(packetBytes);\n+            if (isCwndLimited()) {\n+                Deadline now = timeSource.instant();\n+                if (lastFullWindow == null) {\n+                    lastFullWindow = now;\n+                } else {\n+                    long timePassedNanos = Deadline.between(lastFullWindow, now).toNanos();\n+                    if (timePassedNanos > 0) {\n+                        \/* \"The elapsed time MUST NOT include periods during which cwnd\n+                           has not been updated due to application-limited behavior\"\n+                           \"A flow is application limited if it is currently sending less\n+                            than what is allowed by the congestion window.\"\n+\n+                           We are sending asynchronously; one thread is sending data,\n+                           a separate thread is processing the acknowledgements.\n+                           We can't rely on cwnd being fully utilized when we process an ack, because\n+                           most of the time it won't be.\n+\n+                           Instead, we assume that if we filled the cwnd, we were not application-limited\n+                           in the last RTT (which is a pretty good approximation because of pacing),\n+                           and acknowledgements for all packets sent prior to filling the cwnd\n+                           count towards cwnd increase.\n+                         *\/\n+                        long rttNanos = TimeUnit.MICROSECONDS.toNanos(rttEstimator.state().smoothedRttMicros());\n+                        timeNanos += Math.min(timePassedNanos, rttNanos);\n+                        lastFullWindow = now;\n+                    }\n+                }\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+\n+    boolean congestionAvoidanceAcked(int packetBytes, Deadline sentTime) {\n+        boolean isAppLimited = sentTime.isAfter(lastFullWindow);\n+        if (!isAppLimited) {\n+            if (wEstBytes < cwndPriorBytes) {\n+                wEstBytes += Math.max((long) (ALPHA * maxDatagramSize * packetBytes \/ congestionWindow), 1);\n+            } else {\n+                wEstBytes += Math.max((long)maxDatagramSize * packetBytes \/ congestionWindow, 1);\n+            }\n+            \/\/ target = Wcubic(t + RTT)\n+            long rttNanos = TimeUnit.MICROSECONDS.toNanos(rttEstimator.state().smoothedRttMicros());\n+            double dblTargetBytes = wCubicBytes(timeNanos + rttNanos);\n+            assert dblTargetBytes > 0 : \"Unexpected negative target bytes\";\n+            long targetBytes = (long) Math.min(dblTargetBytes, 1.5 * congestionWindow);\n+            if (targetBytes > congestionWindow) {\n+                long oldWindow = congestionWindow;\n+                congestionWindow += Math.max((targetBytes - congestionWindow) * packetBytes \/ congestionWindow, 1L);\n+                assert congestionWindow > oldWindow :\n+                        \"Window size decreased: %s to %s\".formatted(oldWindow, congestionWindow);\n+            }\n+            if (wEstBytes > congestionWindow) {\n+                congestionWindow = wEstBytes;\n+            }\n+        }\n+        return isAppLimited;\n+    }\n+\n+    \/\/ Wcubic(t) = C * (t-K [seconds])^3 + Wmax (segments)\n+    private double wCubicBytes(long timeNanos) {\n+        return (C * maxDatagramSize * Math.pow((timeNanos - kNanos) \/ 1e9, 3)) + wMaxBytes;\n+    }\n+\n+    void onCongestionEvent(Deadline sentTime) {\n+        if (inCongestionRecovery(sentTime)) {\n+            return;\n+        }\n+        if (congestionWindow < wMaxBytes) {\n+            \/\/ fast convergence\n+            wMaxBytes = (long) ((1 + BETA) * congestionWindow \/ 2);\n+        } else {\n+            wMaxBytes = congestionWindow;\n+        }\n+        cwndPriorBytes = congestionWindow;\n+        congestionRecoveryStartTime = timeSource.instant();\n+        ssThresh = (long)(congestionWindow * BETA);\n+        wEstBytes = congestionWindow = Math.max(minimumWindow, ssThresh);\n+        maxBytesInFlight = 0;\n+        timeNanos = 0;\n+        \/\/ set lastFullWindow to prevent rapid timeNanos growth\n+        lastFullWindow = congestionRecoveryStartTime;\n+        \/\/ ((wmax_segments - cwnd_segments) \/ C) ^ (1\/3) seconds\n+        kNanos = (long)(Math.cbrt((wMaxBytes - congestionWindow) \/ C \/ maxDatagramSize) * 1_000_000_000);\n+        \/\/ kNanos may be negative if we reduced the window below minimum,\n+        \/\/ and fast convergence was used. This is acceptable.\n+        if (Log.quicCC()) {\n+            Log.logQuic(dbgTag + \" Congestion: ssThresh: \" + ssThresh +\n+                    \", in flight: \" + bytesInFlight +\n+                    \", cwnd:\" + congestionWindow +\n+                    \", K: \" + TimeUnit.NANOSECONDS.toMillis(kNanos) + \" ms\");\n+        }\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicCubicCongestionController.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.internal.net.http.common.Utils.UseVTForSelector;\n@@ -119,1 +120,0 @@\n-    enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n@@ -147,5 +147,2 @@\n-        String useVtForSelector =\n-                System.getProperty(\"jdk.internal.httpclient.quic.selector.useVirtualThreads\", \"default\");\n-        USE_VT_FOR_SELECTOR = Stream.of(UseVTForSelector.values())\n-                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n-                .findFirst().orElse(UseVTForSelector.DEFAULT);\n+        var property = \"jdk.internal.httpclient.quic.selector.useVirtualThreads\";\n+        USE_VT_FOR_SELECTOR = Utils.useVTForSelector(property, \"default\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicEndpoint.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.time.Duration;\n@@ -36,1 +35,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicPacer.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,9 +30,0 @@\n-import jdk.internal.net.http.common.TimeLine;\n-import jdk.internal.net.http.common.TimeSource;\n-import jdk.internal.net.http.common.Utils;\n-import jdk.internal.net.http.quic.frames.AckFrame;\n-import jdk.internal.net.http.quic.packets.QuicPacket;\n-\n-import java.util.Collection;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -49,20 +40,1 @@\n-class QuicRenoCongestionController implements QuicCongestionController {\n-    \/\/ higher of 14720 and 2*maxDatagramSize; we use fixed maxDatagramSize\n-    private static final int INITIAL_WINDOW = Math.max(14720, 2 * QuicConnectionImpl.DEFAULT_DATAGRAM_SIZE);\n-    private static final int MAX_BYTES_IN_FLIGHT = Math.clamp(\n-            Utils.getLongProperty(\"jdk.httpclient.quic.maxBytesInFlight\", 1 << 24),\n-            1 << 14, 1 << 24);\n-    private final TimeLine timeSource;\n-    private final String dbgTag;\n-    private final Lock lock = new ReentrantLock();\n-    private long congestionWindow = INITIAL_WINDOW;\n-    private int maxDatagramSize = QuicConnectionImpl.DEFAULT_DATAGRAM_SIZE;\n-    private int minimumWindow = 2 * maxDatagramSize;\n-    private long bytesInFlight;\n-    \/\/ maximum bytes in flight seen since the last congestion event\n-    private long maxBytesInFlight;\n-    private Deadline congestionRecoveryStartTime;\n-    private long ssThresh = Long.MAX_VALUE;\n-\n-    private final QuicPacer pacer;\n-\n+final class QuicRenoCongestionController extends QuicBaseCongestionController {\n@@ -70,3 +42,1 @@\n-        this.dbgTag = dbgTag;\n-        this.timeSource = TimeSource.source();\n-        this.pacer = new QuicPacer(rttEstimator, this);\n+        super(dbgTag, rttEstimator);\n@@ -75,3 +45,6 @@\n-    private boolean inCongestionRecovery(Deadline sentTime) {\n-        return (congestionRecoveryStartTime != null &&\n-                !sentTime.isAfter(congestionRecoveryStartTime));\n+    boolean congestionAvoidanceAcked(int packetBytes, Deadline sentTime) {\n+        boolean isAppLimited = congestionWindow > maxBytesInFlight + 2L * maxDatagramSize;\n+        if (!isAppLimited) {\n+            congestionWindow += Math.max((long) maxDatagramSize * packetBytes \/ congestionWindow, 1L);\n+        }\n+        return isAppLimited;\n@@ -80,1 +53,1 @@\n-    private void onCongestionEvent(Deadline sentTime) {\n+    void onCongestionEvent(Deadline sentTime) {\n@@ -94,222 +67,0 @@\n-\n-    private static boolean inFlight(QuicPacket packet) {\n-        \/\/ packet is in flight if it contains anything other than a single ACK frame\n-        \/\/ specifically, a packet containing padding is considered to be in flight.\n-        return packet.frames().size() != 1 ||\n-                !(packet.frames().get(0) instanceof AckFrame);\n-    }\n-\n-    @Override\n-    public boolean canSendPacket() {\n-        lock.lock();\n-        try {\n-            if (bytesInFlight >= MAX_BYTES_IN_FLIGHT) {\n-                return false;\n-            }\n-            if (isCwndLimited() || isPacerLimited()) {\n-                return false;\n-            }\n-            return true;\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public void updateMaxDatagramSize(int newSize) {\n-        lock.lock();\n-        try {\n-            if (minimumWindow != newSize * 2) {\n-                minimumWindow = newSize * 2;\n-                maxDatagramSize = newSize;\n-                congestionWindow = Math.max(congestionWindow, minimumWindow);\n-            }\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public void packetSent(int packetBytes) {\n-        lock.lock();\n-        try {\n-            bytesInFlight += packetBytes;\n-            if (bytesInFlight > maxBytesInFlight) {\n-                maxBytesInFlight = bytesInFlight;\n-            }\n-            pacer.packetSent(packetBytes);\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public void packetAcked(int packetBytes, Deadline sentTime) {\n-        lock.lock();\n-        try {\n-            bytesInFlight -= packetBytes;\n-            \/\/ RFC 9002 says we should not increase cwnd when application limited.\n-            \/\/ The concept itself is poorly defined.\n-            \/\/ Here we limit cwnd growth based on the maximum bytes in flight\n-            \/\/ observed since the last congestion event\n-            if (inCongestionRecovery(sentTime)) {\n-                if (Log.quicCC() && Log.trace()) {\n-                    Log.logQuic(dbgTag + \" Acked, in recovery: bytes: \" + packetBytes +\n-                            \", in flight: \" + bytesInFlight);\n-                }\n-                return;\n-            }\n-            boolean isAppLimited;\n-            if (congestionWindow < ssThresh) {\n-                isAppLimited = congestionWindow >= 2 * maxBytesInFlight;\n-                if (!isAppLimited) {\n-                    congestionWindow += packetBytes;\n-                }\n-            } else {\n-                isAppLimited = congestionWindow > maxBytesInFlight + 2L * maxDatagramSize;\n-                if (!isAppLimited) {\n-                    congestionWindow += Math.max((long) maxDatagramSize * packetBytes \/ congestionWindow, 1L);\n-                }\n-            }\n-            if (Log.quicCC() && Log.trace()) {\n-                if (isAppLimited) {\n-                    Log.logQuic(dbgTag + \" Acked, not blocked: bytes: \" + packetBytes +\n-                            \", in flight: \" + bytesInFlight);\n-                } else {\n-                    Log.logQuic(dbgTag + \" Acked, increased: bytes: \" + packetBytes +\n-                            \", in flight: \" + bytesInFlight +\n-                            \", new cwnd:\" + congestionWindow);\n-                }\n-            }\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public void packetLost(Collection<QuicPacket> lostPackets, Deadline sentTime, boolean persistent) {\n-        lock.lock();\n-        try {\n-            for (QuicPacket packet : lostPackets) {\n-                if (inFlight(packet)) {\n-                    bytesInFlight -= packet.size();\n-                }\n-            }\n-            onCongestionEvent(sentTime);\n-            if (persistent) {\n-                congestionWindow = minimumWindow;\n-                congestionRecoveryStartTime = null;\n-                if (Log.quicCC()) {\n-                    Log.logQuic(dbgTag + \" Persistent congestion: ssThresh: \" + ssThresh +\n-                            \", in flight: \" + bytesInFlight +\n-                            \", cwnd:\" + congestionWindow);\n-                }\n-            }\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public void packetDiscarded(Collection<QuicPacket> discardedPackets) {\n-        lock.lock();\n-        try {\n-            for (QuicPacket packet : discardedPackets) {\n-                if (inFlight(packet)) {\n-                    bytesInFlight -= packet.size();\n-                }\n-            }\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public long congestionWindow() {\n-        lock.lock();\n-        try {\n-            return congestionWindow;\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public long initialWindow() {\n-        lock.lock();\n-        try {\n-            return Math.max(14720, 2 * maxDatagramSize);\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public long maxDatagramSize() {\n-        lock.lock();\n-        try {\n-            return maxDatagramSize;\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public boolean isSlowStart() {\n-        lock.lock();\n-        try {\n-            return congestionWindow < ssThresh;\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public void updatePacer(Deadline now) {\n-        lock.lock();\n-        try {\n-            pacer.updateQuota(now);\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public boolean isPacerLimited() {\n-        lock.lock();\n-        try {\n-            return !pacer.canSend();\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public boolean isCwndLimited() {\n-        lock.lock();\n-        try {\n-            return congestionWindow - bytesInFlight < maxDatagramSize;\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public Deadline pacerDeadline() {\n-        lock.lock();\n-        try {\n-            return pacer.twoPacketDeadline();\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    @Override\n-    public void appLimited() {\n-        lock.lock();\n-        try {\n-            pacer.appLimited();\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicRenoCongestionController.java","additions":9,"deletions":258,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.net.http.common.Utils.UseVTForSelector;\n@@ -50,1 +51,0 @@\n-import jdk.internal.net.http.quic.QuicEndpoint.UseVTForSelector;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicSelector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -416,1 +416,12 @@\n-                tsym = env.enclClass.sym;\n+                \/\/ Resolve target for unqualified reference based on declaring element\n+                tsym = switch (path.getLeaf().getKind()) {\n+                    case PACKAGE -> env.toplevel.packge;\n+                    case MODULE -> env.toplevel.modle;\n+                    case COMPILATION_UNIT ->\n+                        \/\/ Treat unqualified reference in legacy package.html as package reference.\n+                        \/\/ Unqualified references in doc-files only need to work locally, so null is fine.\n+                        path.getCompilationUnit().getSourceFile().isNameCompatible(\"package\", JavaFileObject.Kind.HTML)\n+                                ? env.toplevel.packge\n+                                : null;\n+                    default -> env.enclClass.sym;  \/\/ Class or class member reference\n+                };\n@@ -473,1 +484,1 @@\n-            if (memberName == null)\n+            if (memberName == null) {\n@@ -475,0 +486,7 @@\n+            } else if (tsym == null || tsym.getKind() == ElementKind.PACKAGE || tsym.getKind() == ElementKind.MODULE) {\n+                return null;  \/\/ Non-null member name in non-class context\n+            }\n+\n+            if (tsym.type.isPrimitive()) {\n+                return null;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        captureMRefReturnType = Source.Feature.ERASE_POLY_SIG_RETURN_TYPE.allowedInSource(source);\n+        captureMRefReturnType = Source.Feature.CAPTURE_MREF_RETURN_TYPE.allowedInSource(source);\n@@ -369,1 +369,1 @@\n-                if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)\n+                if (site == null || site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2816,1 +2816,6 @@\n-        return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);\n+        try {\n+            return resolveQualifiedMethod(new MethodResolutionContext(), pos, env, location, site, name, argtypes, typeargtypes);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(pos, cf);\n+            return methodNotFound.access(name, site.tsym);\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -508,1 +508,1 @@\n-        return TreeInfo.getStartPos(this);\n+        return noNoPos(TreeInfo.getStartPos(this));\n@@ -518,1 +518,8 @@\n-        return TreeInfo.getEndPos(this, endPosTable);\n+        return noNoPos(TreeInfo.getEndPos(this, endPosTable));\n+    }\n+\n+    private int noNoPos(int position) {\n+        if (position == JCDiagnostic.NOPOS) {\n+            return pos;\n+        }\n+        return position;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -669,0 +669,5 @@\n+        if (endPosTable == null) {\n+            \/\/ fall back on limited info in the tree\n+            return endPos(tree);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  private static CIntegerField deoptHandlerOffsetField;\n+  private static CIntegerField deoptHandlerEntryOffsetField;\n@@ -89,1 +89,1 @@\n-    deoptHandlerOffsetField            = type.getCIntegerField(\"_deopt_handler_offset\");\n+    deoptHandlerEntryOffsetField       = type.getCIntegerField(\"_deopt_handler_entry_offset\");\n@@ -124,10 +124,10 @@\n-  public Address constantsBegin()             { return contentBegin();                                     }\n-  public Address constantsEnd()               { return codeBegin();                                        }\n-  public Address instsBegin()                 { return codeBegin();                                        }\n-  public Address instsEnd()                   { return headerBegin().addOffsetTo(getStubOffset());         }\n-  public Address exceptionBegin()             { return headerBegin().addOffsetTo(getExceptionOffset());    }\n-  public Address deoptHandlerBegin()          { return headerBegin().addOffsetTo(getDeoptHandlerOffset()); }\n-  public Address stubBegin()                  { return headerBegin().addOffsetTo(getStubOffset());         }\n-  public Address stubEnd()                    { return dataBegin();                                        }\n-  public Address oopsBegin()                  { return dataBegin();                                        }\n-  public Address oopsEnd()                    { return dataEnd();                                          }\n+  public Address constantsBegin()             { return contentBegin();                                          }\n+  public Address constantsEnd()               { return codeBegin();                                             }\n+  public Address instsBegin()                 { return codeBegin();                                             }\n+  public Address instsEnd()                   { return headerBegin().addOffsetTo(getStubOffset());              }\n+  public Address exceptionBegin()             { return headerBegin().addOffsetTo(getExceptionOffset());         }\n+  public Address deoptHandlerEntry()          { return headerBegin().addOffsetTo(getDeoptHandlerEntryOffset()); }\n+  public Address stubBegin()                  { return headerBegin().addOffsetTo(getStubOffset());              }\n+  public Address stubEnd()                    { return dataBegin();                                             }\n+  public Address oopsBegin()                  { return dataBegin();                                             }\n+  public Address oopsEnd()                    { return dataEnd();                                               }\n@@ -265,1 +265,1 @@\n-  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerBegin(); }\n+  public boolean isDeoptEntry   (Address pc) { return pc == deoptHandlerEntry(); }\n@@ -493,1 +493,1 @@\n-  private int getDeoptHandlerOffset()           { return (int) deoptHandlerOffsetField          .getValue(addr); }\n+  private int getDeoptHandlerEntryOffset()      { return (int) deoptHandlerEntryOffsetField     .getValue(addr); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-    operands    = type.getAddressField(\"_operands\");\n@@ -93,0 +92,4 @@\n+    bsm_entries = type.getField(\"_bsm_entries\").getOffset();\n+    Type bsmae_type = db.lookupType(\"BSMAttributeEntries\");\n+    bsm_entries_offsets = bsmae_type.getAddressField(\"_offsets\");\n+    bsm_entries_bootstrap_methods = bsmae_type.getAddressField(\"_bootstrap_methods\");\n@@ -115,1 +118,0 @@\n-  private static AddressField operands;\n@@ -118,0 +120,3 @@\n+  private static long bsm_entries; \/\/ Offset in the constantpool where the Bsm_Entries are found\n+  private static AddressField bsm_entries_offsets;\n+  private static AddressField bsm_entries_bootstrap_methods;\n@@ -133,4 +138,0 @@\n-  public U2Array           getOperands()   {\n-    Address addr = operands.getValue(getAddress());\n-    return VMObjectFactory.newObject(U2Array.class, addr);\n-  }\n@@ -438,0 +439,12 @@\n+  private U4Array getOffsets() {\n+     Address a =  getAddress().addOffsetTo(bsm_entries);\n+     if (a == null) return null;\n+     a = bsm_entries_offsets.getValue(a);\n+     return VMObjectFactory.newObject(U4Array.class, a);\n+  }\n+  private U2Array getBootstrapMethods() {\n+    Address a =  getAddress().addOffsetTo(bsm_entries);\n+    if (a == null) return null;\n+    return VMObjectFactory.newObject(U2Array.class, bsm_entries_bootstrap_methods.getValue(a));\n+  }\n+\n@@ -439,1 +452,1 @@\n-    U2Array operands = getOperands();\n+    U4Array offsets = getOffsets();\n@@ -441,17 +454,2 @@\n-    if (operands != null) {\n-      \/\/ Operands array consists of two parts. First part is an array of 32-bit values which denote\n-      \/\/ index of the bootstrap method data in the operands array. Note that elements of operands array are of type short.\n-      \/\/ So each element of first part occupies two slots in the array.\n-      \/\/ Second part is the bootstrap methods data.\n-      \/\/ This layout allows us to get BSM count by getting the index of first BSM and dividing it by 2.\n-      \/\/\n-      \/\/ The example below shows layout of operands array with 3 bootstrap methods.\n-      \/\/ First part has 3 32-bit values indicating the index of the respective bootstrap methods in\n-      \/\/ the operands array.\n-      \/\/ The first BSM is at index 6. So the count in this case is 6\/2=3.\n-      \/\/\n-      \/\/            <-----first part----><-------second part------->\n-      \/\/ index:     0     2      4      6        i2       i3\n-      \/\/ operands:  |  6  |  i2  |  i3  |  bsm1  |  bsm2  |  bsm3  |\n-      \/\/\n-      count = getOperandOffsetAt(operands, 0) \/ 2;\n+    if (offsets != null) {\n+      count = offsets.length();\n@@ -466,1 +464,2 @@\n-    U2Array operands = getOperands();\n+    U4Array offs = getOffsets();\n+    U2Array bsms = getBootstrapMethods();\n@@ -468,1 +467,1 @@\n-      Assert.that(operands != null, \"Operands is not present\");\n+      Assert.that(offs != null && bsms != null, \"BSM attribute is not present\");\n@@ -470,2 +469,1 @@\n-    int bsmOffset = getOperandOffsetAt(operands, bsmIndex);\n-    int argc = operands.at(bsmOffset + INDY_ARGC_OFFSET);\n+    int argc = bsms.at(offs.at(bsmIndex) + INDY_ARGC_OFFSET);\n@@ -479,3 +477,4 @@\n-    U2Array operands = getOperands();\n-    if (operands == null)  return null;  \/\/ safety first\n-    int basePos = getOperandOffsetAt(operands, bsmIndex);\n+    U4Array offs = getOffsets();\n+    U2Array bsms = getBootstrapMethods();\n+    if (offs == null || bsms == null) return null; \/\/ safety first\n+    int basePos = offs.at(bsmIndex);\n@@ -483,1 +482,1 @@\n-    int argc = operands.at(basePos + INDY_ARGC_OFFSET);\n+    int argc = getBootstrapMethodArgsCount(bsmIndex);\n@@ -487,1 +486,1 @@\n-        values[j] = operands.at(basePos+j);\n+      values[j] = bsms.at(basePos+j);\n@@ -776,2 +775,1 @@\n-    return VM.getVM().buildIntFromShorts(operands.at(bsmIndex * 2),\n-                                         operands.at(bsmIndex * 2 + 1));\n+      return 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":33,"deletions":35,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        if (pc.equals(nm.deoptHandlerBegin())) {\n+        if (pc.equals(nm.deoptHandlerEntry())) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Frame.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.utilities;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+import sun.jvm.hotspot.types.WrongTypeException;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class U4Array extends GenericArray {\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+      public void update(Observable o, Object data) {\n+        initialize(VM.getVM().getTypeDataBase());\n+      }\n+    });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+    elemType = db.lookupType(\"u4\");\n+    Type type = db.lookupType(\"Array<u4>\");\n+    dataFieldOffset = type.getAddressField(\"_data\").getOffset();\n+  }\n+\n+  private static long dataFieldOffset;\n+  protected static Type elemType;\n+\n+  public U4Array(Address addr) {\n+    super(addr, dataFieldOffset);\n+  }\n+\n+  public int at(int i) {\n+    return (int)getIntegerAt(i);\n+  }\n+\n+  public Type getElemType() {\n+    return elemType;\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/U4Array.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,3 +112,10 @@\n-     * Normalize the key by converting to following form.\n-     * First {@code char} upper case, rest lower case.\n-     * key is presumed to be {@code ASCII}.\n+     * {@return the normalized header name of the following form: the first\n+     * character in upper-case, the rest in lower-case}\n+     * The input header name is assumed to be encoded in ASCII.\n+     *\n+     * @implSpec\n+     * This method is performance-sensitive; update with care.\n+     *\n+     * @param key an ASCII-encoded header name\n+     * @throws NullPointerException on null {@code key}\n+     * @throws IllegalArgumentException if {@code key} contains {@code \\r} or {@code \\n}\n@@ -116,1 +123,3 @@\n-    private String normalize(String key) {\n+    private static String normalize(String key) {\n+\n+        \/\/ Fast path for the empty key\n@@ -118,2 +127,2 @@\n-        int len = key.length();\n-        if (len == 0) {\n+        int l = key.length();\n+        if (l == 0) {\n@@ -122,11 +131,17 @@\n-        char[] b = key.toCharArray();\n-        if (b[0] >= 'a' && b[0] <= 'z') {\n-            b[0] = (char)(b[0] - ('a' - 'A'));\n-        } else if (b[0] == '\\r' || b[0] == '\\n')\n-            throw new IllegalArgumentException(\"illegal character in key\");\n-\n-        for (int i=1; i<len; i++) {\n-            if (b[i] >= 'A' && b[i] <= 'Z') {\n-                b[i] = (char) (b[i] + ('a' - 'A'));\n-            } else if (b[i] == '\\r' || b[i] == '\\n')\n-                throw new IllegalArgumentException(\"illegal character in key\");\n+\n+        \/\/ Find the first non-normalized `char`\n+        int i = 0;\n+        char c = key.charAt(i);\n+        if (!(c == '\\r' || c == '\\n' || (c >= 'a' && c <= 'z'))) {\n+            i++;\n+            for (; i < l; i++) {\n+                c = key.charAt(i);\n+                if (c == '\\r' || c == '\\n' || (c >= 'A' && c <= 'Z')) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        \/\/ Fast path for the already normalized key\n+        if (i == l) {\n+            return key;\n@@ -134,1 +149,26 @@\n-        return new String(b);\n+\n+        \/\/ Upper-case the first `char`\n+        char[] cs = key.toCharArray();\n+        int o = 'a' - 'A';\n+        if (i == 0) {\n+            if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+            if (c >= 'a' && c <= 'z') {\n+                cs[0] = (char) (c - o);\n+            }\n+            i++;\n+        }\n+\n+        \/\/ Lower-case the secondary `char`s\n+        for (; i < l; i++) {\n+            c = cs[i];\n+            if (c >= 'A' && c <= 'Z') {\n+                cs[i] = (char) (c + o);\n+            } else if (c == '\\r' || c == '\\n') {\n+                throw new IllegalArgumentException(\"illegal character in key at index \" + i);\n+            }\n+        }\n+\n+        return new String(cs);\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":59,"deletions":19,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+        jdk.jpackage,\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+    String realStoreType;\n@@ -243,0 +244,1 @@\n+    private boolean weakKeyStore = false;\n@@ -1485,0 +1487,6 @@\n+        if (weakKeyStore) {\n+            warnings.add(String.format(rb.getString(\n+                    \"jks.storetype.warning\"),\n+                    realStoreType, keystore));\n+        }\n+\n@@ -2425,0 +2433,17 @@\n+\n+                    File storeFile = new File(keyStoreName);\n+                    if (storeFile.exists()) {\n+                        \/\/ Probe for real type. A JKS can be loaded as PKCS12 because\n+                        \/\/ DualFormat support, vice versa.\n+                        try {\n+                            KeyStore keyStore = KeyStore.getInstance(storeFile, storepass);\n+                            realStoreType = keyStore.getType();\n+                            if (realStoreType.equalsIgnoreCase(\"JKS\")\n+                                    || realStoreType.equalsIgnoreCase(\"JCEKS\")) {\n+                                weakKeyStore = true;\n+                            }\n+                        } catch (KeyStoreException e) {\n+                            \/\/ Probing not supported, therefore cannot be JKS or JCEKS.\n+                            \/\/ Skip the legacy type warning at all.\n+                        }\n+                    }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -225,0 +225,2 @@\n+jks.storetype.warning=%1$s uses outdated cryptographic algorithms and will be removed in a future release. Migrate to PKCS12 using:\\n\\\n+keytool -importkeystore -srckeystore %2$s -destkeystore %2$s -deststoretype pkcs12\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/resources\/jarsigner.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -911,0 +911,1 @@\n+     * @param title the title for the link\n@@ -916,1 +917,1 @@\n-                                     Content label, HtmlStyle style, boolean code) {\n+                                     Content label, String title, HtmlStyle style, boolean code) {\n@@ -934,3 +935,1 @@\n-                    (label == null) || label.isEmpty() ? defaultLabel : label, style,\n-                    resources.getText(\"doclet.Href_Class_Or_Interface_Title\",\n-                        getLocalizedPackageName(packageElement)), true);\n+                    (label == null) || label.isEmpty() ? defaultLabel : label, style, title, true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-                label, linkInfo.getStyle(), true);\n+                label, linkInfo.getTitle(), linkInfo.getStyle(), true);\n@@ -364,1 +364,1 @@\n-            return (m_writer.getCrossClassLink(typeElement, id.name(), label, null, false));\n+            return (m_writer.getCrossClassLink(typeElement, id.name(), label, null, null, false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-        if (title != null && title.length() != 0) {\n+        if (title != null && !title.isEmpty()) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Links.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-doclet.Href_Class_Or_Interface_Title=class or interface in {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-doclet.Href_Class_Or_Interface_Title=Klasse oder Schnittstelle in {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_de.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-doclet.Href_Class_Or_Interface_Title={0}å†…ã®ã‚¯ãƒ©ã‚¹ã¾ãŸã¯ã‚¤ãƒ³ã‚¿ãƒ•ã‚§ãƒ¼ã‚¹\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_ja.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-doclet.Href_Class_Or_Interface_Title={0}ä¸­çš„ç±»æˆ–æŽ¥å£\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard_zh_CN.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -162,0 +163,4 @@\n+            if (ref == null && refSignature.startsWith(\"##\")) {\n+                \/\/ Unqualified local anchor link in doc-file\n+                return htmlWriter.links.createLink(HtmlId.of(refFragment), labelContent);\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1007,6 +1007,9 @@\n-        Element e = env.trees.getElement(getCurrentPath());\n-        if (e == null) {\n-            reportBadReference(tree);\n-        } else if ((inLink || inSee)\n-                && e.getKind() == ElementKind.CLASS && e.asType().getKind() != TypeKind.DECLARED) {\n-            reportBadReference(tree);\n+        \/\/ Exclude same-file anchor links from reference checks\n+        if (!tree.getSignature().startsWith(\"##\")) {\n+            Element e = env.trees.getElement(getCurrentPath());\n+            if (e == null) {\n+                reportBadReference(tree);\n+            } else if ((inLink || inSee)\n+                    && e.getKind() == ElementKind.CLASS && e.asType().getKind() != TypeKind.DECLARED) {\n+                reportBadReference(tree);\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/Checker.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,3 @@\n+static ThreadNode *\n+insertThread(JNIEnv *env, ThreadList *list, jthread thread);\n+\n@@ -280,0 +283,29 @@\n+\/* Creates a new ThreadNode for a vthread if one is needed. *\/\n+static ThreadNode *\n+createVThreadNodeIfNeeded(jthread thread) {\n+    ThreadNode *node = findThread(&otherThreads, thread);\n+    if (node != NULL) {\n+        \/\/tty_message(\"createVThreadNodeIfNeeded: thread is on otherThreads\");\n+        \/\/ Don't create a new node if it is on otherThreads list. Also don't return\n+        \/\/ the existing node because if it is on otherThreads, it is not running.\n+        return NULL;\n+    }\n+\n+    \/\/ See if we have a vthread that is alive. If we do, create a ThreadNode\n+    \/\/ for it. Otherwise just return NULL.\n+    jint vthread_state = 0;\n+    jvmtiError error = threadState(thread, &vthread_state);\n+    if (error != JVMTI_ERROR_NONE) {\n+        EXIT_ERROR(error, \"getting vthread state\");\n+    }\n+    if ((vthread_state & JVMTI_THREAD_STATE_ALIVE) == 0) {\n+        return NULL; \/\/ Don't create a new ThreadNode if thread is not alive\n+    }\n+    node = insertThread(getEnv(), &runningVThreads, thread);\n+    if (node->suspendCount > 0 && !node->suspendOnStart) {\n+        node->toBeResumed = JNI_TRUE;\n+    }\n+\n+    return node;\n+}\n+\n@@ -287,0 +319,10 @@\n+        if (node == NULL && !gdata->includeVThreads) {\n+            \/\/ Unlike platform threads, we don't always have a ThreadNode for all vthreads.\n+            \/\/ They can be freed if not holding on to any relevant state info. It's also\n+            \/\/ possible that the vthread was created before the debugger attached. Also\n+            \/\/ in the future we won't be enabling VIRTUAL_THREAD_START events in some\n+            \/\/ cases, which means we won't be creating a ThreadNode when the vthread is\n+            \/\/ created. If for any of the above reasons the ThreadNode lookup failed,\n+            \/\/ we'll create one for the vthread now, but only if really needed.\n+            node = createVThreadNodeIfNeeded(thread);\n+        }\n@@ -373,0 +415,17 @@\n+\n+#ifdef DEBUG_THREADNAME\n+        {\n+            \/* Set the thread name *\/\n+            jvmtiThreadInfo info;\n+            jvmtiError error;\n+\n+            memset(&info, 0, sizeof(info));\n+            error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+                    (gdata->jvmti, node->thread, &info);\n+            if (info.name != NULL) {\n+                strncpy(node->name, info.name, sizeof(node->name) - 1);\n+                jvmtiDeallocate(info.name);\n+            }\n+        }\n+#endif\n+\n@@ -421,16 +480,0 @@\n-#ifdef DEBUG_THREADNAME\n-        {\n-            \/* Set the thread name *\/\n-            jvmtiThreadInfo info;\n-            jvmtiError error;\n-\n-            memset(&info, 0, sizeof(info));\n-            error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n-                    (gdata->jvmti, node->thread, &info);\n-            if (info.name != NULL) {\n-                strncpy(node->name, info.name, sizeof(node->name) - 1);\n-                jvmtiDeallocate(info.name);\n-            }\n-        }\n-#endif\n-\n@@ -494,2 +537,1 @@\n-    ThreadList *list = &runningVThreads;\n-    ThreadNode *node = list->first;\n+    ThreadNode *node = runningVThreads.first;\n@@ -504,0 +546,88 @@\n+\/*\n+ * Free (garbage collect) a vthread node if it is unused. This can only be called when\n+ * locks are held so we don't need to worry about other threads changing the state\n+ * of the ThreadNode while we are looking at it. We also need to make sure the\n+ * ThreadNode is not in use for operations like single stepping or invoking.\n+ *\/\n+static void\n+freeUnusedVThreadNode(JNIEnv *env, ThreadNode* node)\n+{\n+    if (gdata->includeVThreads) {\n+        return;\n+    }\n+\n+    \/*\n+     * node->suspendCount requires special handling to see if it triggers having\n+     * to keep the node around. It's possible for it to be 0 yet we still need to\n+     * keep the node around. Also, it's possbile for it to be non-zero yet we\n+     * don't need to keep the node around. More details in the comments below.\n+     *\/\n+    if (node->suspendCount == 0) {\n+        \/*\n+         * Normally a suspendCount of 0 does not result in having to keep the\n+         * node. However, if the suspendAllCount is not 0, then we do. Otherwise\n+         * when the node is recreated later it will end up assuming suspendAllCount\n+         * as its suspendCount rather than 0, which would be incorrect. This\n+         * mismatch in suspend counts happens when there is a suspendAll in place,\n+         * and ThreadReference.resume() is used to decrement the thread's\n+         * suspendCount to 0.\n+         *\/\n+        if (suspendAllCount > 0) {\n+            return;\n+        }\n+    } else {\n+        \/*\n+         * Although at first it might seem that a non-zero suspendCount would require\n+         * keeping the node, we don't have to if node->suspendCount == suspendAllCount,\n+         * because when the node is recreated it will get suspendAllCount assigned to it.\n+         * So we only worry about keeping the node around if the two counts are not equal.\n+         *\/\n+        if (node->suspendCount != suspendAllCount) {\n+            return;\n+        }\n+\n+    }\n+\n+    \/\/ All of the following conditions must be met to free this node. Note\n+    \/\/ suspendCount checks were already made above, so are not included below. If\n+    \/\/ we got here, then suspendCount checks passed w.r.t. being able to free the node.\n+    \/\/ Also note we don't need to check node->toBeResumed. If it is set, that implies\n+    \/\/ node->suspendCount > 0, and that will trigger toBeResumed getting set when\n+    \/\/ the ThreadNode is recreated. See createVThreadNodeIfNeeded().\n+    if (!node->suspendOnStart &&\n+        node->current_ei == 0 &&\n+        node->cleInfo.ei == 0 &&\n+        !node->currentInvoke.pending &&\n+        !node->currentInvoke.started &&\n+        !node->currentInvoke.available &&\n+        !node->currentStep.pending &&\n+        node->instructionStepMode != JVMTI_ENABLE &&\n+        !node->pendingInterrupt &&\n+        !node->popFrameEvent &&\n+        !node->popFrameProceed &&\n+        !node->popFrameThread &&\n+        node->pendingStop == NULL)\n+    {\n+        removeNode(node);\n+        clearThread(env, node);\n+    }\n+}\n+\n+\/*\n+ * Free (garbage collect) vthread nodes if unused. See freeUnusedVThreadNode() above.\n+ *\/\n+static void\n+freeUnusedVThreadNodes(JNIEnv *env)\n+{\n+    if (gdata->includeVThreads) {\n+        return;\n+    }\n+\n+    ThreadNode *node = runningVThreads.first;\n+    while (node != NULL) {\n+        ThreadNode *temp = node->next;\n+        freeUnusedVThreadNode(env, node);\n+        node = temp;\n+    }\n+}\n+\n@@ -1142,0 +1272,1 @@\n+ * Only called for platform threads.\n@@ -1163,0 +1294,2 @@\n+        jthread thread = initList[i];\n+        JDI_ASSERT(!isVThread(thread));\n@@ -1169,1 +1302,1 @@\n-        node = findThread(&runningThreads, initList[i]);\n+        node = findThread(&runningThreads, thread);\n@@ -1171,1 +1304,1 @@\n-            node = insertThread(env, &otherThreads, initList[i]);\n+            node = insertThread(env, &otherThreads, thread);\n@@ -1190,1 +1323,1 @@\n-            reqList[reqCnt++] = initList[i];\n+            reqList[reqCnt++] = thread;\n@@ -1258,2 +1391,3 @@\n-     * The thread is normally between its start and end events, but if\n-     * not, check the auxiliary list used by threadControl_suspendThread.\n+     * We need to call findRunningThread(thread) here instead of just calling\n+     * findThread(NULL, thread) because it's possible that there is not currently a\n+     * ThreadNode for the thread, and findRunningThread() will create one in that case.\n@@ -1261,1 +1395,6 @@\n-    node = findThread(NULL, thread);\n+    node = findRunningThread(thread);\n+    if (node == NULL) {\n+        \/\/ The thread is normally between its start and end events, but if not,\n+        \/\/ check the auxiliary list used by commonSuspend() and commonSuspendList().\n+        node = findThread(&otherThreads, thread);\n+    }\n@@ -1339,1 +1478,1 @@\n-         * this thread, so the suspend count is 0, unless it is a vthread.\n+         * this thread, so the suspend count is 0.\n@@ -1341,16 +1480,1 @@\n-        if (isVThread(thread)) {\n-            jint vthread_state = 0;\n-            jvmtiError error = threadState(thread, &vthread_state);\n-            if (error != JVMTI_ERROR_NONE) {\n-                EXIT_ERROR(error, \"getting vthread state\");\n-            }\n-            if (vthread_state == 0) {\n-                \/\/ If state == 0, then this is a new vthread that has not been started yet.\n-                *count = 0;\n-            } else {\n-                \/\/ This is a started vthread that we are not tracking. Use suspendAllCount.\n-                *count = suspendAllCount;\n-            }\n-        } else {\n-            *count = 0;\n-        }\n+        *count = 0;\n@@ -1409,3 +1533,0 @@\n-#if 0\n-    tty_message(\"threadControl_suspendAll: suspendAllCount(%d)\", suspendAllCount);\n-#endif\n@@ -1419,0 +1540,2 @@\n+    \/\/tty_message(\"threadControl_suspendAll: suspendAllCount(%d)\", suspendAllCount);\n+\n@@ -1428,0 +1551,5 @@\n+            \/\/ Now is a good time to garbage collect vthread nodes. We want to do it before\n+            \/\/ any suspendAll because it will prevent the suspended nodes from being freed.\n+            if (!gdata->includeVThreads) {\n+                freeUnusedVThreadNodes(env);\n+            }\n@@ -1531,3 +1659,0 @@\n-#if 0\n-    tty_message(\"threadControl_resumeAll: suspendAllCount(%d)\", suspendAllCount);\n-#endif\n@@ -1542,0 +1667,2 @@\n+    \/\/tty_message(\"threadControl_resumeAll: suspendAllCount(%d)\", suspendAllCount);\n+\n@@ -2095,1 +2222,1 @@\n-        \/\/ If the node was previously freed, then it was just recreated and we need\n+        \/\/ If the node was previously freed and was just now recreated, we need\n@@ -2151,1 +2278,1 @@\n-    if (ei == EI_THREAD_END) {\n+    if (ei == EI_THREAD_END || ei == EI_THREAD_START) {\n@@ -2158,4 +2285,17 @@\n-        removeThread(env, node); \/\/ Grabs handlerLock, thus the reason for first grabbing it above.\n-        node = NULL; \/\/ We exiting the threadLock. No longer safe to access.\n-        debugMonitorExit(threadLock);\n-        eventHandler_unlock();\n+        \/\/ Remove nodes for exiting threads, but also remove nodes for vthreads\n+        \/\/ that are just starting to help prevent their accumulation. There can't\n+        \/\/ possibly be any state related information in the node at this point. A new\n+        \/\/ one will be created later if necessary, such as when a new event arrives.\n+        if (ei == EI_THREAD_END || (node->is_vthread && !gdata->includeVThreads)) {\n+            removeThread(env, node); \/\/ Grabs handlerLock, thus the reason for first grabbing it above.\n+            node = NULL; \/\/ Node has been freed. No longer safe to access.\n+       } else {\n+            \/\/ EI_THREAD_START for a platform thread, or we are tracking vthreads.\n+            \/\/ In either case we are not removing the thread node.\n+            \/\/ Just clear these two fields. Others are not set yet. Also no need to\n+            \/\/ worry about pending tasks like we do below for other event types.\n+            node->eventBag = eventBag;\n+            node->current_ei = 0;\n+       }\n+       debugMonitorExit(threadLock);\n+       eventHandler_unlock();\n@@ -2176,1 +2316,1 @@\n-        node = NULL; \/\/ We exiting the threadLock. No longer safe to access.\n+        node = NULL; \/\/ We're exiting the threadLock. No longer safe to access.\n@@ -2192,0 +2332,2 @@\n+        \/\/ Note: Threads that were just created or are about to die don't have pending\n+        \/\/ tasks, which is why this is the only code path where we call doPendingTasks().\n@@ -2210,0 +2352,1 @@\n+    eventHandler_lock(); \/\/ Needed to safely access HANDLING_EVENT(node)\n@@ -2232,0 +2375,1 @@\n+    eventHandler_unlock();\n@@ -2337,0 +2481,1 @@\n+    eventHandler_lock(); \/\/ Needed to safely access HANDLING_EVENT(node)\n@@ -2354,0 +2499,1 @@\n+    eventHandler_unlock();\n@@ -2582,1 +2728,1 @@\n-    tty_message(\"\\nDumping runningVThreads:\");\n+    tty_message(\"\\nDumping runningVThreads(numRunningVThreads=%d):\", numRunningVThreads);\n@@ -2653,0 +2799,3 @@\n+    tty_message(\"\\ttoBeResumed: %d\", node->toBeResumed);\n+    tty_message(\"\\tisStarted: %d\", node->isStarted);\n+    tty_message(\"\\tsuspendOnStart: %d\", node->suspendOnStart);\n@@ -2655,1 +2804,0 @@\n-    tty_message(\"\\ttoBeResumed: %d\", node->toBeResumed);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":205,"deletions":57,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.FileInputStream;\n@@ -31,0 +30,1 @@\n+import java.io.Reader;\n@@ -33,0 +33,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -110,2 +112,2 @@\n-                try (FileInputStream fis = new FileInputStream(operation)) {\n-                    props.load(fis);\n+                try (Reader reader = Files.newBufferedReader(Path.of(operation))) {\n+                    props.load(reader); \/\/ Use reader API so as to read in as UTF-8\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/ReleaseInfoPlugin.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+\\       The specified file is expected to be encoded in UTF-8.\\n\\\n@@ -49,1 +50,2 @@\n-\\                            the supplied file.\\n\\\n+\\                            the supplied file. The specified file is expected\\n\\\n+\\                            to be encoded in UTF-8.\\n\\\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/plugins.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.Optional;\n-\n-public class LinuxAppBundler extends AppImageBundler {\n-    public LinuxAppBundler() {\n-        setAppImageSupplier((params, output) -> {\n-            \/\/ Order is important!\n-            var app = LinuxFromParams.APPLICATION.fetchFrom(params);\n-            var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-            LinuxPackagingPipeline.build(Optional.empty())\n-                    .excludeDirFromCopying(output.getParent())\n-                    .create().execute(BuildEnv.withAppImageDir(env, output), app);\n-        });\n-    }\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppBundler.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.LinuxFromOptions.createLinuxApplication;\n+import static jdk.jpackage.internal.LinuxPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_LINUX_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_LINUX_DEB;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_LINUX_RPM;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.util.Result;\n+\n+public class LinuxBundlingEnvironment extends DefaultBundlingEnvironment {\n+\n+    public LinuxBundlingEnvironment() {\n+        super(build()\n+                .defaultOperation(() -> {\n+                    return LazyLoad.SYS_ENV.value().map(LinuxSystemEnvironment::nativePackageType).map(DESCRIPTORS::get);\n+                })\n+                .bundler(CREATE_LINUX_APP_IMAGE, LinuxBundlingEnvironment::createAppImage)\n+                .bundler(CREATE_LINUX_DEB, LazyLoad::debSysEnv, LinuxBundlingEnvironment::createDebPackage)\n+                .bundler(CREATE_LINUX_RPM, LazyLoad::rpmSysEnv, LinuxBundlingEnvironment::createRpmPackage));\n+    }\n+\n+    private static void createDebPackage(Options options, LinuxDebSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                LinuxFromOptions::createLinuxDebPackage,\n+                buildEnv()::create,\n+                LinuxBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    return new LinuxDebPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createRpmPackage(Options options, LinuxRpmSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                LinuxFromOptions::createLinuxRpmPackage,\n+                buildEnv()::create,\n+                LinuxBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    return new LinuxRpmPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createAppImage(Options options) {\n+\n+        final var app = createLinuxApplication(options);\n+\n+        createApplicationImage(options, app, LinuxPackagingPipeline.build(Optional.empty()));\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline(LinuxPackage pkg) {\n+        return LinuxPackagingPipeline.build(Optional.of(pkg));\n+    }\n+\n+    private static BuildEnvFromOptions buildEnv() {\n+        return new BuildEnvFromOptions().predefinedAppImageLayout(APPLICATION_LAYOUT);\n+    }\n+\n+    private static final class LazyLoad {\n+\n+        static Result<LinuxDebSystemEnvironment> debSysEnv() {\n+            return DEB_SYS_ENV;\n+        }\n+\n+        static Result<LinuxRpmSystemEnvironment> rpmSysEnv() {\n+            return RPM_SYS_ENV;\n+        }\n+\n+        private static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n+\n+        private static final Result<LinuxDebSystemEnvironment> DEB_SYS_ENV = LinuxDebSystemEnvironment.create(SYS_ENV);\n+\n+        private static final Result<LinuxRpmSystemEnvironment> RPM_SYS_ENV = LinuxRpmSystemEnvironment.create(SYS_ENV);\n+    }\n+\n+    private static final Map<PackageType, BundlingOperationDescriptor> DESCRIPTORS = Stream.of(\n+            CREATE_LINUX_DEB,\n+            CREATE_LINUX_RPM\n+    ).collect(toMap(StandardBundlingOperation::packageType, StandardBundlingOperation::descriptor));\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxBundlingEnvironment.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.StandardPackageType;\n-import jdk.jpackage.internal.util.Result;\n-\n-public class LinuxDebBundler extends LinuxPackageBundler {\n-\n-    public LinuxDebBundler() {\n-        super(LinuxFromParams.DEB_PACKAGE);\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"deb.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"deb\";\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n-\n-        var pkg = LinuxFromParams.DEB_PACKAGE.fetchFrom(params);\n-\n-        return Packager.<LinuxDebPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new LinuxDebPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    protected Result<LinuxDebSystemEnvironment> sysEnv() {\n-        return sysEnv;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return sysEnv.value()\n-                .map(LinuxSystemEnvironment::nativePackageType)\n-                .map(StandardPackageType.LINUX_DEB::equals)\n-                .orElse(false);\n-    }\n-\n-    private final Result<LinuxDebSystemEnvironment> sysEnv = LinuxDebSystemEnvironment.create(SYS_ENV);\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -39,1 +38,1 @@\n-    LinuxDebPackage create() throws ConfigException {\n+    LinuxDebPackage create() {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebPackageBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.FromOptions.buildApplicationBuilder;\n+import static jdk.jpackage.internal.FromOptions.createPackageBuilder;\n+import static jdk.jpackage.internal.LinuxPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_APP_CATEGORY;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_DEB_MAINTAINER_EMAIL;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_MENU_GROUP;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_PACKAGE_DEPENDENCIES;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_PACKAGE_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_RELEASE;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_RPM_LICENSE_TYPE;\n+import static jdk.jpackage.internal.cli.StandardOption.LINUX_SHORTCUT_HINT;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_RPM;\n+\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LinuxApplication;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxLauncherMixin;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+\n+final class LinuxFromOptions {\n+\n+    static LinuxApplication createLinuxApplication(Options options) {\n+\n+        final var launcherFromOptions = new LauncherFromOptions().faWithDefaultDescription();\n+\n+        final var appBuilder = buildApplicationBuilder().create(options, launcherOptions -> {\n+\n+            final var launcher = launcherFromOptions.create(launcherOptions);\n+\n+            final var shortcut = LINUX_SHORTCUT_HINT.findIn(launcherOptions);\n+\n+            return LinuxLauncher.create(launcher, new LinuxLauncherMixin.Stub(shortcut));\n+\n+        }, (LinuxLauncher linuxLauncher, Launcher launcher) -> {\n+            return LinuxLauncher.create(launcher, linuxLauncher);\n+        }, APPLICATION_LAYOUT);\n+\n+        appBuilder.launchers().map(LinuxPackagingPipeline::normalizeShortcuts).ifPresent(appBuilder::launchers);\n+\n+        return LinuxApplication.create(appBuilder.create());\n+    }\n+\n+    static LinuxRpmPackage createLinuxRpmPackage(Options options) {\n+\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_RPM);\n+\n+        final var pkgBuilder = new LinuxRpmPackageBuilder(superPkgBuilder);\n+\n+        LINUX_RPM_LICENSE_TYPE.ifPresentIn(options, pkgBuilder::licenseType);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static LinuxDebPackage createLinuxDebPackage(Options options) {\n+\n+        final var superPkgBuilder = createLinuxPackageBuilder(options, LINUX_DEB);\n+\n+        final var pkgBuilder = new LinuxDebPackageBuilder(superPkgBuilder);\n+\n+        LINUX_DEB_MAINTAINER_EMAIL.ifPresentIn(options, pkgBuilder::maintainerEmail);\n+\n+        final var pkg = pkgBuilder.create();\n+\n+        \/\/ Show warning if license file is missing\n+        if (pkg.licenseFile().isEmpty()) {\n+            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n+        }\n+\n+        return pkg;\n+    }\n+\n+    private static LinuxPackageBuilder createLinuxPackageBuilder(Options options, StandardPackageType type) {\n+\n+        final var app = createLinuxApplication(options);\n+\n+        final var superPkgBuilder = createPackageBuilder(options, app, type);\n+\n+        final var pkgBuilder = new LinuxPackageBuilder(superPkgBuilder);\n+\n+        LINUX_PACKAGE_DEPENDENCIES.ifPresentIn(options, pkgBuilder::additionalDependencies);\n+        LINUX_APP_CATEGORY.ifPresentIn(options, pkgBuilder::category);\n+        LINUX_MENU_GROUP.ifPresentIn(options, pkgBuilder::menuGroupName);\n+        LINUX_RELEASE.ifPresentIn(options, pkgBuilder::release);\n+        LINUX_PACKAGE_NAME.ifPresentIn(options, pkgBuilder::literalName);\n+\n+        return pkgBuilder;\n+    }\n+\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromOptions.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n-import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n-import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n-import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n-import static jdk.jpackage.internal.LinuxPackagingPipeline.APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n-import static jdk.jpackage.internal.model.StandardPackageType.LINUX_RPM;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.LinuxApplication;\n-import jdk.jpackage.internal.model.LinuxDebPackage;\n-import jdk.jpackage.internal.model.LinuxLauncher;\n-import jdk.jpackage.internal.model.LinuxLauncherMixin;\n-import jdk.jpackage.internal.model.LinuxRpmPackage;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.StandardPackageType;\n-\n-final class LinuxFromParams {\n-\n-    private static LinuxApplication createLinuxApplication(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-        final var launcherFromParams = new LauncherFromParams();\n-\n-        final var app = createApplicationBuilder(params, toFunction(launcherParams -> {\n-            final var launcher = launcherFromParams.create(launcherParams);\n-            final var shortcut = findLauncherShortcut(LINUX_SHORTCUT_HINT, params, launcherParams);\n-            return LinuxLauncher.create(launcher, new LinuxLauncherMixin.Stub(shortcut));\n-        }), (LinuxLauncher linuxLauncher, Launcher launcher) -> {\n-            return LinuxLauncher.create(launcher, linuxLauncher);\n-        }, APPLICATION_LAYOUT).create();\n-        return LinuxApplication.create(app);\n-    }\n-\n-    private static LinuxPackageBuilder createLinuxPackageBuilder(\n-            Map<String, ? super Object> params, StandardPackageType type) throws ConfigException, IOException {\n-\n-        final var app = APPLICATION.fetchFrom(params);\n-\n-        final var superPkgBuilder = createPackageBuilder(params, app, type);\n-\n-        final var pkgBuilder = new LinuxPackageBuilder(superPkgBuilder);\n-\n-        LINUX_PACKAGE_DEPENDENCIES.copyInto(params, pkgBuilder::additionalDependencies);\n-        LINUX_CATEGORY.copyInto(params, pkgBuilder::category);\n-        LINUX_MENU_GROUP.copyInto(params, pkgBuilder::menuGroupName);\n-        RELEASE.copyInto(params, pkgBuilder::release);\n-        LINUX_PACKAGE_NAME.copyInto(params, pkgBuilder::literalName);\n-\n-        return pkgBuilder;\n-    }\n-\n-    private static LinuxRpmPackage createLinuxRpmPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var superPkgBuilder = createLinuxPackageBuilder(params, LINUX_RPM);\n-\n-        final var pkgBuilder = new LinuxRpmPackageBuilder(superPkgBuilder);\n-\n-        LICENSE_TYPE.copyInto(params, pkgBuilder::licenseType);\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    private static LinuxDebPackage createLinuxDebPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var superPkgBuilder = createLinuxPackageBuilder(params, LINUX_DEB);\n-\n-        final var pkgBuilder = new LinuxDebPackageBuilder(superPkgBuilder);\n-\n-        MAINTAINER_EMAIL.copyInto(params, pkgBuilder::maintainerEmail);\n-\n-        final var pkg = pkgBuilder.create();\n-\n-        \/\/ Show warning if license file is missing\n-        if (pkg.licenseFile().isEmpty()) {\n-            Log.verbose(I18N.getString(\"message.debs-like-licenses\"));\n-        }\n-\n-        return pkg;\n-    }\n-\n-    static final BundlerParamInfo<LinuxApplication> APPLICATION = createApplicationBundlerParam(\n-            LinuxFromParams::createLinuxApplication);\n-\n-    static final BundlerParamInfo<LinuxRpmPackage> RPM_PACKAGE = createPackageBundlerParam(\n-            LinuxFromParams::createLinuxRpmPackage);\n-\n-    static final BundlerParamInfo<LinuxDebPackage> DEB_PACKAGE = createPackageBundlerParam(\n-            LinuxFromParams::createLinuxDebPackage);\n-\n-    private static final BundlerParamInfo<String> LINUX_SHORTCUT_HINT = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_CATEGORY = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_CATEGORY.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_PACKAGE_DEPENDENCIES = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_PACKAGE_DEPENDENCIES.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_MENU_GROUP = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_MENU_GROUP.getId());\n-\n-    private static final BundlerParamInfo<String> RELEASE = createStringBundlerParam(\n-            Arguments.CLIOptions.RELEASE.getId());\n-\n-    private static final BundlerParamInfo<String> LINUX_PACKAGE_NAME = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_BUNDLE_NAME.getId());\n-\n-    private static final BundlerParamInfo<String> LICENSE_TYPE = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_RPM_LICENSE_TYPE.getId());\n-\n-    private static final BundlerParamInfo<String> MAINTAINER_EMAIL = createStringBundlerParam(\n-            Arguments.CLIOptions.LINUX_DEB_MAINTAINER.getId());\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -38,1 +37,0 @@\n-import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -41,0 +39,1 @@\n+import jdk.jpackage.internal.model.RuntimeLayout;\n@@ -49,4 +48,2 @@\n-    LinuxPackage create() throws ConfigException {\n-        if (literalName != null) {\n-            pkgBuilder.name(literalName);\n-        } else {\n+    LinuxPackage create() {\n+        pkgBuilder.name(Optional.ofNullable(literalName).orElseGet(() -> {\n@@ -54,2 +51,2 @@\n-            pkgBuilder.name(pkgBuilder.create().packageName().toLowerCase().replaceAll(\"[ _]\", \"-\"));\n-        }\n+            return pkgBuilder.create().packageName().toLowerCase().replaceAll(\"[ _]\", \"-\");\n+        }));\n@@ -59,4 +56,3 @@\n-        final var stdPkgType = tmpPkg.asStandardPackageType();\n-        if (stdPkgType.isPresent()) {\n-            validatePackageName(tmpPkg.packageName(), stdPkgType.orElseThrow());\n-        }\n+        tmpPkg.asStandardPackageType().ifPresent(stdPkgType -> {\n+            validatePackageName(tmpPkg.packageName(), stdPkgType);\n+        });\n@@ -84,1 +80,1 @@\n-    private LinuxPackage create(Package pkg) throws ConfigException {\n+    private LinuxPackage create(Package pkg) {\n@@ -140,2 +136,1 @@\n-    private static void validatePackageName(String packageName,\n-            StandardPackageType pkgType) throws ConfigException {\n+    private static void validatePackageName(String packageName, StandardPackageType pkgType) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.util.Map;\n-import java.util.Objects;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.LinuxPackage;\n-import jdk.jpackage.internal.util.Result;\n-\n-abstract class LinuxPackageBundler extends AbstractBundler {\n-\n-    LinuxPackageBundler(BundlerParamInfo<? extends LinuxPackage> pkgParam) {\n-        this.pkgParam = Objects.requireNonNull(pkgParam);\n-    }\n-\n-    @Override\n-    public final boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-\n-        \/\/ Order is important!\n-        pkgParam.fetchFrom(params);\n-        BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        LinuxSystemEnvironment sysEnv;\n-        try {\n-            sysEnv = sysEnv().orElseThrow();\n-        } catch (RuntimeException ex) {\n-            throw ConfigException.rethrowConfigException(ex);\n-        }\n-\n-        if (!isDefault()) {\n-            Log.verbose(I18N.format(\n-                    \"message.not-default-bundler-no-dependencies-lookup\",\n-                    getName()));\n-        } else if (!sysEnv.soLookupAvailable()) {\n-            final String advice;\n-            if (\"deb\".equals(getID())) {\n-                advice = \"message.deb-ldd-not-available.advice\";\n-            } else {\n-                advice = \"message.rpm-ldd-not-available.advice\";\n-            }\n-            \/\/ Let user know package dependencies will not be generated.\n-            Log.error(String.format(\"%s\\n%s\", I18N.getString(\n-                    \"message.ldd-not-available\"), I18N.getString(advice)));\n-        }\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public final String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return sysEnv().hasValue();\n-    }\n-\n-    protected abstract Result<? extends LinuxSystemEnvironment> sysEnv();\n-\n-    private final BundlerParamInfo<? extends LinuxPackage> pkgParam;\n-\n-    static final Result<LinuxSystemEnvironment> SYS_ENV = LinuxSystemEnvironment.create();\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -43,1 +43,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -98,1 +97,1 @@\n-    private void buildConfigFiles() throws PackagerException, IOException {\n+    private void buildConfigFiles() throws IOException {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackager.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static jdk.jpackage.internal.ApplicationBuilder.normalizeLauncherProperty;\n@@ -39,0 +40,1 @@\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n@@ -41,0 +43,3 @@\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxLauncherMixin;\n@@ -67,0 +72,11 @@\n+    static ApplicationLaunchers normalizeShortcuts(ApplicationLaunchers appLaunchers) {\n+        return normalizeLauncherProperty(appLaunchers, launcher -> {\n+            \/\/ Return \"true\" if shortcut is not configured for the launcher.\n+            return launcher.shortcut().isEmpty();\n+        }, (LinuxLauncher launcher) -> {\n+            return launcher.shortcut().flatMap(LauncherShortcut::startupDirectory);\n+        }, (launcher, shortcut) -> {\n+            return LinuxLauncher.create(launcher, new LinuxLauncherMixin.Stub(Optional.of(new LauncherShortcut(shortcut))));\n+        });\n+    }\n+\n@@ -93,0 +109,9 @@\n+    private static final ApplicationLayout LINUX_APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .launchersDirectory(\"bin\")\n+            .appDirectory(\"lib\/app\")\n+            .runtimeDirectory(\"lib\/runtime\")\n+            .desktopIntegrationDirectory(\"lib\")\n+            .appModsDirectory(\"lib\/app\/mods\")\n+            .contentDirectory(\"lib\")\n+            .create();\n+\n@@ -94,1 +119,1 @@\n-            ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT, Path.of(\"lib\/libapplauncher.so\"));\n+            LINUX_APPLICATION_LAYOUT, Path.of(\"lib\/libapplauncher.so\"));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackagingPipeline.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.LinuxRpmPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.StandardPackageType;\n-import jdk.jpackage.internal.util.Result;\n-\n-\n-public class LinuxRpmBundler extends LinuxPackageBundler {\n-\n-    public LinuxRpmBundler() {\n-        super(LinuxFromParams.RPM_PACKAGE);\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"rpm.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"rpm\";\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params, Path outputParentDir) throws PackagerException {\n-\n-        var pkg = LinuxFromParams.RPM_PACKAGE.fetchFrom(params);\n-\n-        return Packager.<LinuxRpmPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new LinuxRpmPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    protected Result<LinuxRpmSystemEnvironment> sysEnv() {\n-        return sysEnv;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return sysEnv.value()\n-                .map(LinuxSystemEnvironment::nativePackageType)\n-                .map(StandardPackageType.LINUX_RPM::equals)\n-                .orElse(false);\n-    }\n-\n-    private final Result<LinuxRpmSystemEnvironment> sysEnv = LinuxRpmSystemEnvironment.create(SYS_ENV);\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -39,1 +38,1 @@\n-    LinuxRpmPackage create() throws ConfigException {\n+    LinuxRpmPackage create() {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmPackageBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LINUX_LAUNCHER_SHORTCUT;\n+\n@@ -42,1 +44,1 @@\n-            shortcut.store(SHORTCUT_ID, map::put);\n+            shortcut.store(LINUX_LAUNCHER_SHORTCUT.getName(), map::put);\n@@ -58,2 +60,0 @@\n-\n-    public static final String SHORTCUT_ID = \"linux-shortcut\";\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,4 +26,0 @@\n-app.bundler.name=Linux Application Image\n-deb.bundler.name=DEB Bundle\n-rpm.bundler.name=RPM Bundle\n-\n@@ -61,1 +57,0 @@\n-message.creating-association-with-null-extension=Creating association with null extension.\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/LinuxResources.properties","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,2 @@\n-provides jdk.jpackage.internal.Bundler with\n-    jdk.jpackage.internal.LinuxAppBundler,\n-    jdk.jpackage.internal.LinuxDebBundler,\n-    jdk.jpackage.internal.LinuxRpmBundler;\n-\n+provides jdk.jpackage.internal.cli.CliBundlingEnvironment with\n+    jdk.jpackage.internal.LinuxBundlingEnvironment;\n","filename":"src\/jdk.jpackage\/linux\/classes\/module-info.java.extra","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -65,5 +64,2 @@\n-    Optional<AppImageSigningConfig> create() throws ConfigException {\n-        final var identityCfg = signingIdentityBuilder.create();\n-        if (identityCfg.isEmpty()) {\n-            return Optional.empty();\n-        } else {\n+    Optional<AppImageSigningConfig> create() {\n+        return signingIdentityBuilder.create().map(cfg -> {\n@@ -71,6 +67,8 @@\n-            return identityCfg.map(cfg -> {\n-                return new AppImageSigningConfig.Stub(cfg.identity(), signingIdentifierPrefix,\n-                        validatedEntitlements, cfg.keychain().map(Keychain::name),\n-                        Optional.ofNullable(entitlementsResourceName).orElse(\"entitlements.plist\"));\n-            });\n-        }\n+            return new AppImageSigningConfig.Stub(\n+                    Objects.requireNonNull(cfg.identity()),\n+                    Objects.requireNonNull(signingIdentifierPrefix),\n+                    validatedEntitlements,\n+                    cfg.keychain().map(Keychain::name),\n+                    Optional.ofNullable(entitlementsResourceName).orElse(\"entitlements.plist\")\n+            );\n+        });\n@@ -79,1 +77,1 @@\n-    private Optional<Path> validatedEntitlements() throws ConfigException {\n+    private Optional<Path> validatedEntitlements() {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigningConfigBuilder.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.OUTPUT_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-\n-import java.util.Map;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.util.function.ExceptionBox;\n-\n-public class MacAppBundler extends AppImageBundler {\n-     public MacAppBundler() {\n-         setAppImageSupplier((params, output) -> {\n-\n-             \/\/ Order is important!\n-             final var app = MacFromParams.APPLICATION.fetchFrom(params);\n-             final BuildEnv env;\n-\n-             if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n-                 env = MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-                 final var pkg = MacPackagingPipeline.createSignAppImagePackage(app, env);\n-                 MacPackagingPipeline.build(Optional.of(pkg)).create().execute(env, pkg, output);\n-             } else {\n-                 env = BuildEnv.withAppImageDir(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n-                 MacPackagingPipeline.build(Optional.empty())\n-                         .excludeDirFromCopying(output.getParent())\n-                         .excludeDirFromCopying(OUTPUT_DIR.fetchFrom(params)).create().execute(env, app);\n-             }\n-\n-         });\n-         setParamsValidator(MacAppBundler::doValidate);\n-    }\n-\n-    private static void doValidate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-\n-        try {\n-            MacFromParams.APPLICATION.fetchFrom(params);\n-        } catch (ExceptionBox ex) {\n-            if (ex.getCause() instanceof ConfigException cfgEx) {\n-                throw cfgEx;\n-            } else {\n-                throw ex;\n-            }\n-        }\n-\n-        if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n-            if (!Optional.ofNullable(\n-                    SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n-                throw new ConfigException(\n-                        I18N.getString(\"error.app-image.mac-sign.required\"),\n-                        null);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.AppImageFile.getBooleanExtraFieldValue;\n-\n-import jdk.jpackage.internal.model.ExternalApplication;\n-import jdk.jpackage.internal.model.MacApplication.ExtraAppImageFileField;\n-\n-record MacAppImageFileExtras(boolean signed, boolean appStore) {\n-\n-    MacAppImageFileExtras(ExternalApplication app) {\n-        this(getBooleanExtraFieldValue(ExtraAppImageFileField.SIGNED.fieldName(), app),\n-                getBooleanExtraFieldValue(ExtraAppImageFileField.APP_STORE.fieldName(), app));\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageFileExtras.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -31,2 +31,0 @@\n-import java.util.List;\n-import java.util.Set;\n@@ -35,0 +33,3 @@\n+import java.util.Set;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.AppImageSigningConfig;\n@@ -36,1 +37,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -40,2 +40,0 @@\n-import jdk.jpackage.internal.model.AppImageLayout;\n-import jdk.jpackage.internal.model.AppImageSigningConfig;\n@@ -95,1 +93,1 @@\n-    MacApplication create() throws ConfigException {\n+    MacApplication create() {\n@@ -139,1 +137,1 @@\n-    private static void validateAppVersion(Application app) throws ConfigException {\n+    private static void validateAppVersion(Application app) {\n@@ -159,1 +157,1 @@\n-    private MacApplicationBuilder createCopyForExternalInfoPlistFile() throws ConfigException {\n+    private MacApplicationBuilder createCopyForExternalInfoPlistFile() {\n@@ -190,6 +188,2 @@\n-    private Optional<AppImageSigningConfig> createSigningConfig() throws ConfigException {\n-        if (signingBuilder != null) {\n-            return signingBuilder.create();\n-        } else {\n-            return Optional.empty();\n-        }\n+    private Optional<AppImageSigningConfig> createSigningConfig() {\n+        return Optional.ofNullable(signingBuilder).flatMap(AppImageSigningConfigBuilder::create);\n@@ -198,1 +192,1 @@\n-    private String validatedBundleName() throws ConfigException {\n+    private String validatedBundleName() {\n@@ -217,1 +211,1 @@\n-    private String validatedBundleIdentifier() throws ConfigException {\n+    private String validatedBundleIdentifier() {\n@@ -241,1 +235,1 @@\n-    private String validatedCategory() throws ConfigException {\n+    private String validatedCategory() {\n@@ -245,6 +239,2 @@\n-    private Optional<Path> validatedIcon() throws ConfigException {\n-        if (icon != null) {\n-            LauncherBuilder.validateIcon(icon);\n-        }\n-\n-        return Optional.ofNullable(icon);\n+    private Optional<Path> validatedIcon() {\n+        return Optional.ofNullable(icon).map(LauncherBuilder::validateIcon);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-\n-public abstract class MacBaseInstallerBundler extends AbstractBundler {\n-\n-    public MacBaseInstallerBundler() {\n-        appImageBundler = new MacAppBundler();\n-    }\n-\n-    protected void validateAppImageAndBundeler(\n-            Map<String, ? super Object> params) throws ConfigException {\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {\n-            appImageBundler.validate(params);\n-        }\n-    }\n-\n-    @Override\n-    public String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    private final Bundler appImageBundler;\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import jdk.jpackage.internal.model.MacPackage;\n-\n-final class MacBuildEnvFromParams {\n-\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n-        return BuildEnvFromParams.create(params, MacPackagingPipeline.APPLICATION_LAYOUT::resolveAt, MacPackage::guessRuntimeLayout);\n-    });\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBuildEnvFromParams.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.MacFromOptions.createMacApplication;\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.MacPackagingPipeline.createSignAppImagePackage;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_DMG;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_PKG;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+\n+import java.util.Optional;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.MacPackage;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.util.Result;\n+\n+public class MacBundlingEnvironment extends DefaultBundlingEnvironment {\n+\n+    public MacBundlingEnvironment() {\n+        super(build()\n+                .defaultOperation(CREATE_MAC_DMG)\n+                .bundler(SIGN_MAC_APP_IMAGE, MacBundlingEnvironment::signAppImage)\n+                .bundler(CREATE_MAC_APP_IMAGE, MacBundlingEnvironment::createAppImage)\n+                .bundler(CREATE_MAC_DMG, LazyLoad::dmgSysEnv, MacBundlingEnvironment::createDmdPackage)\n+                .bundler(CREATE_MAC_PKG, MacBundlingEnvironment::createPkgPackage));\n+    }\n+\n+    private static void createDmdPackage(Options options, MacDmgSystemEnvironment sysEnv) {\n+        createNativePackage(options,\n+                MacFromOptions::createMacDmgPackage,\n+                buildEnv()::create,\n+                MacBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n+                    return new MacDmgPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createPkgPackage(Options options) {\n+        createNativePackage(options,\n+                MacFromOptions::createMacPkgPackage,\n+                buildEnv()::create,\n+                MacBundlingEnvironment::buildPipeline,\n+                (env, pkg, outputDir) -> {\n+                    Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n+                    return new MacPkgPackager(env, pkg, outputDir);\n+                });\n+    }\n+\n+    private static void signAppImage(Options options) {\n+\n+        final var app = createMacApplication(options);\n+\n+        final var env = buildEnv().create(options, app);\n+\n+        final var pkg = createSignAppImagePackage(app, env);\n+\n+        buildPipeline(pkg).create().execute(env, pkg, env.appImageDir());\n+    }\n+\n+    private static void createAppImage(Options options) {\n+\n+        final var app = createMacApplication(options);\n+\n+        createApplicationImage(options, app, MacPackagingPipeline.build(Optional.empty()));\n+    }\n+\n+    private static PackagingPipeline.Builder buildPipeline(Package pkg) {\n+        return MacPackagingPipeline.build(Optional.of(pkg));\n+    }\n+\n+    private static BuildEnvFromOptions buildEnv() {\n+        return new BuildEnvFromOptions()\n+                .predefinedAppImageLayout(APPLICATION_LAYOUT)\n+                .predefinedRuntimeImageLayout(MacPackage::guessRuntimeLayout);\n+    }\n+\n+    private static final class LazyLoad {\n+\n+        static Result<MacDmgSystemEnvironment> dmgSysEnv() {\n+            return DMG_SYS_ENV;\n+        }\n+\n+        private static final Result<MacDmgSystemEnvironment> DMG_SYS_ENV = MacDmgSystemEnvironment.create();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundlingEnvironment.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.MacDmgPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.util.Result;\n-\n-public class MacDmgBundler extends MacBaseInstallerBundler {\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"dmg.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"dmg\";\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        try {\n-            Objects.requireNonNull(params);\n-\n-            MacFromParams.DMG_PACKAGE.fetchFrom(params);\n-\n-            \/\/run basic validation to ensure requirements are met\n-            \/\/we are not interested in return code, only possible exception\n-            validateAppImageAndBundeler(params);\n-\n-            return true;\n-        } catch (RuntimeException re) {\n-            if (re.getCause() instanceof ConfigException) {\n-                throw (ConfigException) re.getCause();\n-            } else {\n-                throw new ConfigException(re);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n-\n-        Log.verbose(I18N.format(\"message.building-dmg\", pkg.app().name()));\n-\n-        return Packager.<MacDmgPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new MacDmgPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return sysEnv.hasValue();\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return true;\n-    }\n-\n-    private final Result<MacDmgSystemEnvironment> sysEnv = MacDmgSystemEnvironment.create();\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -55,1 +54,1 @@\n-    MacDmgPackage create() throws ConfigException {\n+    MacDmgPackage create() {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -38,1 +36,1 @@\n-    MacFileAssociation create(FileAssociation fa) throws ConfigException {\n+    MacFileAssociation create(FileAssociation fa) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFileAssociationBuilder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.FromOptions.buildApplicationBuilder;\n+import static jdk.jpackage.internal.FromOptions.createPackageBuilder;\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasJliLib;\n+import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasNoBinDir;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.APPCLASS;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_CATEGORY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_IMAGE_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_BUNDLE_IDENTIFIER;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_BUNDLE_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_BUNDLE_SIGNING_PREFIX;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_DMG_CONTENT;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_ENTITLEMENTS;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_INSTALLER_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGN;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGNING_KEYCHAIN;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGNING_KEY_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_DMG;\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_PKG;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.ApplicationBuilder.MainLauncherStartupInfo;\n+import jdk.jpackage.internal.SigningIdentityBuilder.ExpiredCertificateException;\n+import jdk.jpackage.internal.SigningIdentityBuilder.StandardCertificateSelector;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardFaOption;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ExternalApplication;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.MacApplication;\n+import jdk.jpackage.internal.model.MacDmgPackage;\n+import jdk.jpackage.internal.model.MacFileAssociation;\n+import jdk.jpackage.internal.model.MacLauncher;\n+import jdk.jpackage.internal.model.MacPackage;\n+import jdk.jpackage.internal.model.MacPkgPackage;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\n+final class MacFromOptions {\n+\n+    static MacApplication createMacApplication(Options options) {\n+        return createMacApplicationInternal(options).app();\n+    }\n+\n+    static MacDmgPackage createMacDmgPackage(Options options) {\n+\n+        final var app = createMacApplicationInternal(options);\n+\n+        final var superPkgBuilder = createMacPackageBuilder(options, app, MAC_DMG);\n+\n+        final var pkgBuilder = new MacDmgPackageBuilder(superPkgBuilder);\n+\n+        MAC_DMG_CONTENT.ifPresentIn(options, pkgBuilder::dmgContent);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static MacPkgPackage createMacPkgPackage(Options options) {\n+\n+        \/\/\n+        \/\/ One of \"MacSignTest.testExpiredCertificate\" test cases expects\n+        \/\/ two error messages about expired certificates in the output: one for\n+        \/\/ certificate for signing an app image, another certificate for signing a PKG.\n+        \/\/ So creation of a PKG package is a bit messy.\n+        \/\/\n+\n+        final boolean sign = MAC_SIGN.findIn(options).orElse(false);\n+        final boolean appStore = MAC_APP_STORE.findIn(options).orElse(false);\n+\n+        final var appResult = Result.create(() -> createMacApplicationInternal(options));\n+\n+        final Optional<MacPkgPackageBuilder> pkgBuilder;\n+        if (appResult.hasValue()) {\n+            final var superPkgBuilder = createMacPackageBuilder(options, appResult.orElseThrow(), MAC_PKG);\n+            pkgBuilder = Optional.of(new MacPkgPackageBuilder(superPkgBuilder));\n+        } else {\n+            \/\/ Failed to create an app. Is it because of the expired certificate?\n+            rethrowIfNotExpiredCertificateException(appResult);\n+            \/\/ Yes, the certificate for signing the app image has expired.\n+            \/\/ Keep going, try to create a signing config for the package.\n+            pkgBuilder = Optional.empty();\n+        }\n+\n+        if (sign) {\n+            final var signingIdentityBuilder = createSigningIdentityBuilder(options);\n+            MAC_INSTALLER_SIGN_IDENTITY.ifPresentIn(options, signingIdentityBuilder::signingIdentity);\n+            MAC_SIGNING_KEY_NAME.findIn(options).ifPresent(userName -> {\n+                final StandardCertificateSelector domain;\n+                if (appStore) {\n+                    domain = StandardCertificateSelector.APP_STORE_PKG_INSTALLER;\n+                } else {\n+                    domain = StandardCertificateSelector.PKG_INSTALLER;\n+                }\n+\n+                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n+            });\n+\n+            if (pkgBuilder.isPresent()) {\n+                pkgBuilder.orElseThrow().signingBuilder(signingIdentityBuilder);\n+            } else {\n+                \/\/\n+                \/\/ The certificate for signing the app image has expired. Can not create a\n+                \/\/ package because there is no app.\n+                \/\/ Try to create a signing config for the package and see if the certificate for\n+                \/\/ signing the package is also expired.\n+                \/\/\n+\n+                final var expiredAppCertException = appResult.firstError().orElseThrow();\n+\n+                final var pkgSignConfigResult = Result.create(signingIdentityBuilder::create);\n+                try {\n+                    rethrowIfNotExpiredCertificateException(pkgSignConfigResult);\n+                    \/\/ The certificate for the package signing config is also expired!\n+                } catch (RuntimeException ex) {\n+                    \/\/ Some error occurred trying to configure the signing config for the package.\n+                    \/\/ Ignore it, bail out with the first error.\n+                    rethrowUnchecked(expiredAppCertException);\n+                }\n+\n+                Log.error(pkgSignConfigResult.firstError().orElseThrow().getMessage());\n+                rethrowUnchecked(expiredAppCertException);\n+            }\n+        }\n+\n+        return pkgBuilder.orElseThrow().create();\n+    }\n+\n+    private record ApplicationWithDetails(MacApplication app, Optional<ExternalApplication> externalApp) {\n+        ApplicationWithDetails {\n+            Objects.requireNonNull(app);\n+            Objects.requireNonNull(externalApp);\n+        }\n+    }\n+\n+    private static ApplicationWithDetails createMacApplicationInternal(Options options) {\n+\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(options)\n+                .map(MacPackage::guessRuntimeLayout);\n+\n+        predefinedRuntimeLayout.ifPresent(layout -> {\n+            validateRuntimeHasJliLib(layout);\n+            if (MAC_APP_STORE.containsIn(options)) {\n+                validateRuntimeHasNoBinDir(layout);\n+            }\n+        });\n+\n+        final var launcherFromOptions = new LauncherFromOptions().faMapper(MacFromOptions::createMacFa);\n+\n+        final var superAppBuilder = buildApplicationBuilder()\n+                .runtimeLayout(RUNTIME_BUNDLE_LAYOUT)\n+                .predefinedRuntimeLayout(predefinedRuntimeLayout.map(RuntimeLayout::unresolve).orElse(null))\n+                .create(options, launcherOptions -> {\n+                    var launcher = launcherFromOptions.create(launcherOptions);\n+                    return MacLauncher.create(launcher);\n+                }, (MacLauncher _, Launcher launcher) -> {\n+                    return MacLauncher.create(launcher);\n+                }, APPLICATION_LAYOUT);\n+\n+        if (PREDEFINED_APP_IMAGE.containsIn(options)) {\n+            \/\/ Set the main launcher start up info.\n+            \/\/ AppImageFile assumes the main launcher start up info is available when\n+            \/\/ it is constructed from Application instance.\n+            \/\/ This happens when jpackage signs predefined app image.\n+            final var appImageFileOptions = superAppBuilder.externalApplication().orElseThrow().extra();\n+            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(APPCLASS.getFrom(appImageFileOptions));\n+            final var launchers = superAppBuilder.launchers().orElseThrow();\n+            final var mainLauncher = ApplicationBuilder.overrideLauncherStartupInfo(launchers.mainLauncher(), mainLauncherStartupInfo);\n+            superAppBuilder.launchers(new ApplicationLaunchers(MacLauncher.create(mainLauncher), launchers.additionalLaunchers()));\n+        }\n+\n+        final var app = superAppBuilder.create();\n+\n+        final var appBuilder = new MacApplicationBuilder(app);\n+\n+        PREDEFINED_APP_IMAGE.findIn(options)\n+                .map(MacBundle::new)\n+                .map(MacBundle::infoPlistFile)\n+                .ifPresent(appBuilder::externalInfoPlistFile);\n+\n+        ICON.ifPresentIn(options, appBuilder::icon);\n+        MAC_BUNDLE_NAME.ifPresentIn(options, appBuilder::bundleName);\n+        MAC_BUNDLE_IDENTIFIER.ifPresentIn(options, appBuilder::bundleIdentifier);\n+        MAC_APP_CATEGORY.ifPresentIn(options, appBuilder::category);\n+\n+        final boolean sign;\n+        final boolean appStore;\n+\n+        if (PREDEFINED_APP_IMAGE.containsIn(options) && OptionUtils.bundlingOperation(options) != SIGN_MAC_APP_IMAGE) {\n+            final var appImageFileOptions = superAppBuilder.externalApplication().orElseThrow().extra();\n+            sign = MAC_SIGN.getFrom(appImageFileOptions);\n+            appStore = MAC_APP_STORE.getFrom(appImageFileOptions);\n+        } else {\n+            sign = MAC_SIGN.getFrom(options);\n+            appStore = MAC_APP_STORE.getFrom(options);\n+        }\n+\n+        appBuilder.appStore(appStore);\n+\n+        if (sign) {\n+            final var signingIdentityBuilder = createSigningIdentityBuilder(options);\n+            MAC_APP_IMAGE_SIGN_IDENTITY.ifPresentIn(options, signingIdentityBuilder::signingIdentity);\n+            MAC_SIGNING_KEY_NAME.findIn(options).ifPresent(userName -> {\n+                final StandardCertificateSelector domain;\n+                if (appStore) {\n+                    domain = StandardCertificateSelector.APP_STORE_APP_IMAGE;\n+                } else {\n+                    domain = StandardCertificateSelector.APP_IMAGE;\n+                }\n+\n+                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n+            });\n+\n+            final var signingBuilder = new AppImageSigningConfigBuilder(signingIdentityBuilder);\n+            if (appStore) {\n+                signingBuilder.entitlementsResourceName(\"sandbox.plist\");\n+            }\n+\n+            app.mainLauncher().flatMap(Launcher::startupInfo).ifPresentOrElse(\n+                signingBuilder::signingIdentifierPrefix,\n+                () -> {\n+                    \/\/ Runtime installer does not have the main launcher, use\n+                    \/\/ 'bundleIdentifier' as the prefix by default.\n+                    var bundleIdentifier = appBuilder.create().bundleIdentifier();\n+                    signingBuilder.signingIdentifierPrefix(bundleIdentifier + \".\");\n+                });\n+            MAC_BUNDLE_SIGNING_PREFIX.ifPresentIn(options, signingBuilder::signingIdentifierPrefix);\n+\n+            MAC_ENTITLEMENTS.ifPresentIn(options, signingBuilder::entitlements);\n+\n+            appBuilder.signingBuilder(signingBuilder);\n+        }\n+\n+        return new ApplicationWithDetails(appBuilder.create(), superAppBuilder.externalApplication());\n+    }\n+\n+    private static MacPackageBuilder createMacPackageBuilder(Options options, ApplicationWithDetails app, PackageType type) {\n+\n+        final var builder = new MacPackageBuilder(createPackageBuilder(options, app.app(), type));\n+\n+        app.externalApp()\n+                .map(ExternalApplication::extra)\n+                .flatMap(MAC_SIGN::findIn)\n+                .ifPresent(builder::predefinedAppImageSigned);\n+\n+        PREDEFINED_RUNTIME_IMAGE.findIn(options)\n+                .map(MacBundle::new)\n+                .filter(MacBundle::isValid)\n+                .map(MacBundle::isSigned)\n+                .ifPresent(builder::predefinedAppImageSigned);\n+\n+        return builder;\n+    }\n+\n+    private static void rethrowIfNotExpiredCertificateException(Result<?> result) {\n+        final var ex = result.firstError().orElseThrow();\n+\n+        if (ex instanceof ExpiredCertificateException) {\n+            return;\n+        }\n+\n+        if (ex instanceof ExceptionBox box) {\n+            if (box.getCause() instanceof Exception cause) {\n+                rethrowIfNotExpiredCertificateException(Result.ofError(cause));\n+            }\n+        }\n+\n+        rethrowUnchecked(ex);\n+    }\n+\n+    private static SigningIdentityBuilder createSigningIdentityBuilder(Options options) {\n+        final var builder = new SigningIdentityBuilder();\n+        MAC_SIGNING_KEYCHAIN.findIn(options).map(Path::toString).ifPresent(builder::keychain);\n+        return builder;\n+    }\n+\n+    private static MacFileAssociation createMacFa(Options options, FileAssociation fa) {\n+\n+        final var builder = new MacFileAssociationBuilder();\n+\n+        StandardFaOption.MAC_CFBUNDLETYPEROLE.ifPresentIn(options, builder::cfBundleTypeRole);\n+        StandardFaOption.MAC_LSHANDLERRANK.ifPresentIn(options, builder::lsHandlerRank);\n+        StandardFaOption.MAC_NSSTORETYPEKEY.ifPresentIn(options, builder::nsPersistentStoreTypeKey);\n+        StandardFaOption.MAC_NSDOCUMENTCLASS.ifPresentIn(options, builder::nsDocumentClass);\n+        StandardFaOption.MAC_LSTYPEISPACKAGE.ifPresentIn(options, builder::lsTypeIsPackage);\n+        StandardFaOption.MAC_LSDOCINPLACE.ifPresentIn(options, builder::lsSupportsOpeningDocumentsInPlace);\n+        StandardFaOption.MAC_UIDOCBROWSER.ifPresentIn(options, builder::uiSupportsDocumentBrowser);\n+        StandardFaOption.MAC_NSEXPORTABLETYPES.ifPresentIn(options, builder::nsExportableTypes);\n+        StandardFaOption.MAC_UTTYPECONFORMSTO.ifPresentIn(options, builder::utTypeConformsTo);\n+\n+        return builder.create(fa);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromOptions.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -1,384 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.BundlerParamInfo.createBooleanBundlerParam;\n-import static jdk.jpackage.internal.BundlerParamInfo.createPathBundlerParam;\n-import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n-import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n-import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n-import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasJliLib;\n-import static jdk.jpackage.internal.MacRuntimeValidator.validateRuntimeHasNoBinDir;\n-import static jdk.jpackage.internal.StandardBundlerParam.DMG_CONTENT;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-import static jdk.jpackage.internal.StandardBundlerParam.hasPredefinedAppImage;\n-import static jdk.jpackage.internal.model.MacPackage.RUNTIME_BUNDLE_LAYOUT;\n-import static jdk.jpackage.internal.model.StandardPackageType.MAC_DMG;\n-import static jdk.jpackage.internal.model.StandardPackageType.MAC_PKG;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.Callable;\n-import java.util.function.Predicate;\n-import jdk.jpackage.internal.ApplicationBuilder.MainLauncherStartupInfo;\n-import jdk.jpackage.internal.SigningIdentityBuilder.ExpiredCertificateException;\n-import jdk.jpackage.internal.SigningIdentityBuilder.StandardCertificateSelector;\n-import jdk.jpackage.internal.model.ApplicationLaunchers;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.FileAssociation;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.MacApplication;\n-import jdk.jpackage.internal.model.MacDmgPackage;\n-import jdk.jpackage.internal.model.MacFileAssociation;\n-import jdk.jpackage.internal.model.MacLauncher;\n-import jdk.jpackage.internal.model.MacPackage;\n-import jdk.jpackage.internal.model.MacPkgPackage;\n-import jdk.jpackage.internal.model.PackageType;\n-import jdk.jpackage.internal.model.RuntimeLayout;\n-import jdk.jpackage.internal.util.function.ExceptionBox;\n-\n-\n-final class MacFromParams {\n-\n-    private static MacApplication createMacApplication(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params)\n-                .map(MacPackage::guessRuntimeLayout);\n-\n-        if (predefinedRuntimeLayout.isPresent()) {\n-            validateRuntimeHasJliLib(predefinedRuntimeLayout.orElseThrow());\n-            if (APP_STORE.findIn(params).orElse(false)) {\n-                validateRuntimeHasNoBinDir(predefinedRuntimeLayout.orElseThrow());\n-            }\n-        }\n-\n-        final var launcherFromParams = new LauncherFromParams(Optional.of(MacFromParams::createMacFa));\n-\n-        final var superAppBuilder = createApplicationBuilder(params, toFunction(launcherParams -> {\n-            var launcher = launcherFromParams.create(launcherParams);\n-            return MacLauncher.create(launcher);\n-        }), (MacLauncher _, Launcher launcher) -> {\n-            return MacLauncher.create(launcher);\n-        }, APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout.map(RuntimeLayout::unresolve));\n-\n-        if (hasPredefinedAppImage(params)) {\n-            \/\/ Set the main launcher start up info.\n-            \/\/ AppImageFile assumes the main launcher start up info is available when\n-            \/\/ it is constructed from Application instance.\n-            \/\/ This happens when jpackage signs predefined app image.\n-            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(superAppBuilder.mainLauncherClassName().orElseThrow());\n-            final var launchers = superAppBuilder.launchers().orElseThrow();\n-            final var mainLauncher = ApplicationBuilder.overrideLauncherStartupInfo(launchers.mainLauncher(), mainLauncherStartupInfo);\n-            superAppBuilder.launchers(new ApplicationLaunchers(MacLauncher.create(mainLauncher), launchers.additionalLaunchers()));\n-        }\n-\n-        final var app = superAppBuilder.create();\n-\n-        final var appBuilder = new MacApplicationBuilder(app);\n-\n-        if (hasPredefinedAppImage(params)) {\n-            appBuilder.externalInfoPlistFile(PREDEFINED_APP_IMAGE.findIn(params).map(MacBundle::new).orElseThrow().infoPlistFile());\n-        }\n-\n-        ICON.copyInto(params, appBuilder::icon);\n-        MAC_CF_BUNDLE_NAME.copyInto(params, appBuilder::bundleName);\n-        MAC_CF_BUNDLE_IDENTIFIER.copyInto(params, appBuilder::bundleIdentifier);\n-        APP_CATEGORY.copyInto(params, appBuilder::category);\n-\n-        final boolean sign;\n-        final boolean appStore;\n-\n-        if (hasPredefinedAppImage(params) && PACKAGE_TYPE.findIn(params).filter(Predicate.isEqual(\"app-image\")).isEmpty()) {\n-            final var appImageFileExtras = new MacAppImageFileExtras(superAppBuilder.externalApplication().orElseThrow());\n-            sign = appImageFileExtras.signed();\n-            appStore = appImageFileExtras.appStore();\n-        } else {\n-            sign = SIGN_BUNDLE.findIn(params).orElse(false);\n-            appStore = APP_STORE.findIn(params).orElse(false);\n-        }\n-\n-        appBuilder.appStore(appStore);\n-\n-        if (sign) {\n-            final var signingIdentityBuilder = createSigningIdentityBuilder(params);\n-            APP_IMAGE_SIGN_IDENTITY.copyInto(params, signingIdentityBuilder::signingIdentity);\n-            SIGNING_KEY_USER.findIn(params).ifPresent(userName -> {\n-                final StandardCertificateSelector domain;\n-                if (appStore) {\n-                    domain = StandardCertificateSelector.APP_STORE_APP_IMAGE;\n-                } else {\n-                    domain = StandardCertificateSelector.APP_IMAGE;\n-                }\n-\n-                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n-            });\n-\n-            final var signingBuilder = new AppImageSigningConfigBuilder(signingIdentityBuilder);\n-            if (appStore) {\n-                signingBuilder.entitlementsResourceName(\"sandbox.plist\");\n-            }\n-\n-            final var bundleIdentifier = appBuilder.create().bundleIdentifier();\n-            app.mainLauncher().flatMap(Launcher::startupInfo).ifPresentOrElse(\n-                signingBuilder::signingIdentifierPrefix,\n-                () -> {\n-                    \/\/ Runtime installer does not have main launcher, so use\n-                    \/\/ 'bundleIdentifier' as prefix by default.\n-                    signingBuilder.signingIdentifierPrefix(\n-                        bundleIdentifier + \".\");\n-                });\n-            SIGN_IDENTIFIER_PREFIX.copyInto(params, signingBuilder::signingIdentifierPrefix);\n-\n-            ENTITLEMENTS.copyInto(params, signingBuilder::entitlements);\n-\n-            appBuilder.signingBuilder(signingBuilder);\n-        }\n-\n-        return appBuilder.create();\n-    }\n-\n-    private static MacPackageBuilder createMacPackageBuilder(\n-            Map<String, ? super Object> params, MacApplication app,\n-            PackageType type) throws ConfigException {\n-        final var builder = new MacPackageBuilder(createPackageBuilder(params, app, type));\n-\n-        PREDEFINED_APP_IMAGE_FILE.findIn(params)\n-                .map(MacAppImageFileExtras::new)\n-                .map(MacAppImageFileExtras::signed)\n-                .ifPresent(builder::predefinedAppImageSigned);\n-\n-        PREDEFINED_RUNTIME_IMAGE.findIn(params)\n-                .map(MacBundle::new)\n-                .filter(MacBundle::isValid)\n-                .map(MacBundle::isSigned)\n-                .ifPresent(builder::predefinedAppImageSigned);\n-\n-        return builder;\n-    }\n-\n-    private static MacDmgPackage createMacDmgPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var app = APPLICATION.fetchFrom(params);\n-\n-        final var superPkgBuilder = createMacPackageBuilder(params, app, MAC_DMG);\n-\n-        final var pkgBuilder = new MacDmgPackageBuilder(superPkgBuilder);\n-\n-        DMG_CONTENT.copyInto(params, pkgBuilder::dmgContent);\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    private record WithExpiredCertificateException<T>(Optional<T> obj, Optional<ExpiredCertificateException> certEx) {\n-        WithExpiredCertificateException {\n-            if (obj.isEmpty() == certEx.isEmpty()) {\n-                throw new IllegalArgumentException();\n-            }\n-        }\n-\n-        static <U> WithExpiredCertificateException<U> of(Callable<U> callable) {\n-            try {\n-                return new WithExpiredCertificateException<>(Optional.of(callable.call()), Optional.empty());\n-            } catch (ExpiredCertificateException ex) {\n-                return new WithExpiredCertificateException<>(Optional.empty(), Optional.of(ex));\n-            } catch (ExceptionBox ex) {\n-                if (ex.getCause() instanceof ExpiredCertificateException certEx) {\n-                    return new WithExpiredCertificateException<>(Optional.empty(), Optional.of(certEx));\n-                }\n-                throw ex;\n-            } catch (RuntimeException ex) {\n-                throw ex;\n-            } catch (Throwable t) {\n-                throw ExceptionBox.rethrowUnchecked(t);\n-            }\n-        }\n-    }\n-\n-    private static MacPkgPackage createMacPkgPackage(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        \/\/ This is over complicated to make \"MacSignTest.testExpiredCertificate\" test pass.\n-\n-        final boolean sign = SIGN_BUNDLE.findIn(params).orElse(false);\n-        final boolean appStore = APP_STORE.findIn(params).orElse(false);\n-\n-        final var appOrExpiredCertEx = WithExpiredCertificateException.of(() -> {\n-            return APPLICATION.fetchFrom(params);\n-        });\n-\n-        final Optional<MacPkgPackageBuilder> pkgBuilder;\n-        if (appOrExpiredCertEx.obj().isPresent()) {\n-            final var superPkgBuilder = createMacPackageBuilder(params, appOrExpiredCertEx.obj().orElseThrow(), MAC_PKG);\n-            pkgBuilder = Optional.of(new MacPkgPackageBuilder(superPkgBuilder));\n-        } else {\n-            pkgBuilder = Optional.empty();\n-        }\n-\n-        if (sign) {\n-            final var signingIdentityBuilder = createSigningIdentityBuilder(params);\n-            INSTALLER_SIGN_IDENTITY.copyInto(params, signingIdentityBuilder::signingIdentity);\n-            SIGNING_KEY_USER.findIn(params).ifPresent(userName -> {\n-                final StandardCertificateSelector domain;\n-                if (appStore) {\n-                    domain = StandardCertificateSelector.APP_STORE_PKG_INSTALLER;\n-                } else {\n-                    domain = StandardCertificateSelector.PKG_INSTALLER;\n-                }\n-\n-                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n-            });\n-\n-            if (pkgBuilder.isPresent()) {\n-                pkgBuilder.orElseThrow().signingBuilder(signingIdentityBuilder);\n-            } else {\n-                final var expiredPkgCert = WithExpiredCertificateException.of(() -> {\n-                    return signingIdentityBuilder.create();\n-                }).certEx();\n-                expiredPkgCert.map(ConfigException::getMessage).ifPresent(Log::error);\n-                throw appOrExpiredCertEx.certEx().orElseThrow();\n-            }\n-        }\n-\n-        return pkgBuilder.orElseThrow().create();\n-    }\n-\n-    private static SigningIdentityBuilder createSigningIdentityBuilder(Map<String, ? super Object> params) {\n-        final var builder = new SigningIdentityBuilder();\n-        SIGNING_KEYCHAIN.copyInto(params, builder::keychain);\n-        return builder;\n-    }\n-\n-    private static MacFileAssociation createMacFa(FileAssociation fa, Map<String, ? super Object> params) {\n-\n-        final var builder = new MacFileAssociationBuilder();\n-\n-        FA_MAC_CFBUNDLETYPEROLE.copyInto(params, builder::cfBundleTypeRole);\n-        FA_MAC_LSHANDLERRANK.copyInto(params, builder::lsHandlerRank);\n-        FA_MAC_NSSTORETYPEKEY.copyInto(params, builder::nsPersistentStoreTypeKey);\n-        FA_MAC_NSDOCUMENTCLASS.copyInto(params, builder::nsDocumentClass);\n-        FA_MAC_LSTYPEISPACKAGE.copyInto(params, builder::lsTypeIsPackage);\n-        FA_MAC_LSDOCINPLACE.copyInto(params, builder::lsSupportsOpeningDocumentsInPlace);\n-        FA_MAC_UIDOCBROWSER.copyInto(params, builder::uiSupportsDocumentBrowser);\n-        FA_MAC_NSEXPORTABLETYPES.copyInto(params, builder::nsExportableTypes);\n-        FA_MAC_UTTYPECONFORMSTO.copyInto(params, builder::utTypeConformsTo);\n-\n-        return toFunction(builder::create).apply(fa);\n-    }\n-\n-    static final BundlerParamInfo<MacApplication> APPLICATION = createApplicationBundlerParam(\n-            MacFromParams::createMacApplication);\n-\n-    static final BundlerParamInfo<MacDmgPackage> DMG_PACKAGE = createPackageBundlerParam(\n-            MacFromParams::createMacDmgPackage);\n-\n-    static final BundlerParamInfo<MacPkgPackage> PKG_PACKAGE = createPackageBundlerParam(\n-            MacFromParams::createMacPkgPackage);\n-\n-    private static final BundlerParamInfo<String> MAC_CF_BUNDLE_NAME = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_BUNDLE_NAME.getId());\n-\n-    private static final BundlerParamInfo<String> APP_CATEGORY = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_CATEGORY.getId());\n-\n-    private static final BundlerParamInfo<Path> ENTITLEMENTS = createPathBundlerParam(\n-            Arguments.CLIOptions.MAC_ENTITLEMENTS.getId());\n-\n-    private static final BundlerParamInfo<String> MAC_CF_BUNDLE_IDENTIFIER = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId());\n-\n-    private static final BundlerParamInfo<String> SIGN_IDENTIFIER_PREFIX = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_BUNDLE_SIGNING_PREFIX.getId());\n-\n-    private static final BundlerParamInfo<String> APP_IMAGE_SIGN_IDENTITY = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId());\n-\n-    private static final BundlerParamInfo<String> INSTALLER_SIGN_IDENTITY = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId());\n-\n-    private static final BundlerParamInfo<String> SIGNING_KEY_USER = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_SIGNING_KEY_NAME.getId());\n-\n-    private static final BundlerParamInfo<String> SIGNING_KEYCHAIN = createStringBundlerParam(\n-            Arguments.CLIOptions.MAC_SIGNING_KEYCHAIN.getId());\n-\n-    private static final BundlerParamInfo<String> PACKAGE_TYPE = createStringBundlerParam(\n-            Arguments.CLIOptions.PACKAGE_TYPE.getId());\n-\n-    private static final BundlerParamInfo<Boolean> APP_STORE = createBooleanBundlerParam(\n-            Arguments.CLIOptions.MAC_APP_STORE.getId());\n-\n-    private static final BundlerParamInfo<String> FA_MAC_CFBUNDLETYPEROLE = createStringBundlerParam(\n-            Arguments.MAC_CFBUNDLETYPEROLE);\n-\n-    private static final BundlerParamInfo<String> FA_MAC_LSHANDLERRANK = createStringBundlerParam(\n-            Arguments.MAC_LSHANDLERRANK);\n-\n-    private static final BundlerParamInfo<String> FA_MAC_NSSTORETYPEKEY = createStringBundlerParam(\n-            Arguments.MAC_NSSTORETYPEKEY);\n-\n-    private static final BundlerParamInfo<String> FA_MAC_NSDOCUMENTCLASS = createStringBundlerParam(\n-            Arguments.MAC_NSDOCUMENTCLASS);\n-\n-    private static final BundlerParamInfo<Boolean> FA_MAC_LSTYPEISPACKAGE = createBooleanBundlerParam(\n-            Arguments.MAC_LSTYPEISPACKAGE);\n-\n-    private static final BundlerParamInfo<Boolean> FA_MAC_LSDOCINPLACE = createBooleanBundlerParam(\n-            Arguments.MAC_LSDOCINPLACE);\n-\n-    private static final BundlerParamInfo<Boolean> FA_MAC_UIDOCBROWSER = createBooleanBundlerParam(\n-            Arguments.MAC_UIDOCBROWSER);\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static final BundlerParamInfo<List<String>> FA_MAC_NSEXPORTABLETYPES =\n-            new BundlerParamInfo<>(\n-                    Arguments.MAC_NSEXPORTABLETYPES,\n-                    (Class<List<String>>) (Object) List.class,\n-                    null,\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static final BundlerParamInfo<List<String>> FA_MAC_UTTYPECONFORMSTO =\n-            new BundlerParamInfo<>(\n-                    Arguments.MAC_UTTYPECONFORMSTO,\n-                    (Class<List<String>>) (Object) List.class,\n-                    null,\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":0,"deletions":384,"binary":false,"changes":384,"status":"deleted"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -52,1 +51,1 @@\n-    MacPackage create() throws ConfigException {\n+    MacPackage create() {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -228,4 +227,6 @@\n-        return toSupplier(() -> {\n-            return new PackageBuilder(app, SignAppImagePackageType.VALUE).predefinedAppImage(\n-                    Objects.requireNonNull(env.appImageDir())).installDir(Path.of(\"\/foo\")).create();\n-        }).get();\n+        return new PackageBuilder(\n+                app,\n+                SignAppImagePackageType.VALUE\n+        ).predefinedAppImage(\n+                Objects.requireNonNull(env.appImageDir())\n+        ).installDir(Path.of(\"\/foo\")).create();\n@@ -271,1 +272,1 @@\n-                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException, PackagerException {\n+                public void execute(AppImageBuildEnv<MacApplication, T> env) throws IOException {\n@@ -613,1 +614,1 @@\n-        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+        public void execute(TaskAction taskAction) throws IOException {\n@@ -618,0 +619,9 @@\n+    private static final ApplicationLayout MAC_APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .launchersDirectory(\"Contents\/MacOS\")\n+            .appDirectory(\"Contents\/app\")\n+            .runtimeDirectory(\"Contents\/runtime\/Contents\/Home\")\n+            .desktopIntegrationDirectory(\"Contents\/Resources\")\n+            .appModsDirectory(\"Contents\/app\/mods\")\n+            .contentDirectory(\"Contents\")\n+            .create();\n+\n@@ -619,1 +629,1 @@\n-            ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT, Path.of(\"Contents\/runtime\"));\n+            MAC_APPLICATION_LAYOUT, Path.of(\"Contents\/runtime\"));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.MacPkgPackage;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-public class MacPkgBundler extends MacBaseInstallerBundler {\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"pkg.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"pkg\";\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        try {\n-            Objects.requireNonNull(params);\n-\n-            final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n-\n-            \/\/ run basic validation to ensure requirements are met\n-            \/\/ we are not interested in return code, only possible exception\n-            validateAppImageAndBundeler(params);\n-\n-            \/\/ hdiutil is always available so there's no need\n-            \/\/ to test for availability.\n-\n-            return true;\n-        } catch (RuntimeException re) {\n-            if (re.getCause() instanceof ConfigException) {\n-                throw (ConfigException) re.getCause();\n-            } else {\n-                throw new ConfigException(re);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n-\n-        Log.verbose(I18N.format(\"message.building-pkg\", pkg.app().name()));\n-\n-        return Packager.<MacPkgPackage>build().outputDir(outputParentDir)\n-                .pkg(pkg)\n-                .env(MacBuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n-                    return new MacPkgPackager(env, pkg, outputDir);\n-                }).execute(MacPackagingPipeline.build(Optional.of(pkg)));\n-    }\n-\n-    @Override\n-    public boolean supported(boolean runtimeInstaller) {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return false;\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -45,1 +44,1 @@\n-    MacPkgPackage create() throws ConfigException {\n+    MacPkgPackage create() {\n@@ -51,8 +50,4 @@\n-    private Optional<PkgSigningConfig> createSigningConfig() throws ConfigException {\n-        if (signingBuilder != null) {\n-            return signingBuilder.create().map(cfg -> {\n-                return new PkgSigningConfig.Stub(cfg.identity(), cfg.keychain().map(Keychain::name));\n-            });\n-        } else {\n-            return Optional.empty();\n-        }\n+    private Optional<PkgSigningConfig> createSigningConfig() {\n+        return Optional.ofNullable(signingBuilder).flatMap(SigningIdentityBuilder::create).map(cfg -> {\n+            return new PkgSigningConfig.Stub(cfg.identity(), cfg.keychain().map(Keychain::name));\n+        });\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackageBuilder.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -38,1 +37,1 @@\n-    static void validateRuntimeHasJliLib(RuntimeLayout runtimeLayout) throws ConfigException {\n+    static void validateRuntimeHasJliLib(RuntimeLayout runtimeLayout) {\n@@ -54,1 +53,1 @@\n-    static void validateRuntimeHasNoBinDir(RuntimeLayout runtimeLayout) throws ConfigException {\n+    static void validateRuntimeHasNoBinDir(RuntimeLayout runtimeLayout) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacRuntimeValidator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    Optional<SigningConfig> create() throws ConfigException {\n+    Optional<SigningConfig> create() {\n@@ -93,1 +93,1 @@\n-    private Optional<Keychain> validatedKeychain() throws ConfigException {\n+    private Optional<Keychain> validatedKeychain() {\n@@ -97,1 +97,1 @@\n-    private SigningIdentity validatedSigningIdentity() throws ConfigException {\n+    private SigningIdentity validatedSigningIdentity() {\n@@ -145,1 +145,1 @@\n-            CertificateSelector certificateSelector, Optional<Keychain> keychain) throws ConfigException {\n+            CertificateSelector certificateSelector, Optional<Keychain> keychain) {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/SigningIdentityBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_MAIN_CLASS;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n@@ -32,0 +35,1 @@\n+import java.util.Optional;\n@@ -35,0 +39,1 @@\n+import jdk.jpackage.internal.cli.OptionValue;\n@@ -79,1 +84,8 @@\n-        return Stream.of(ExtraAppImageFileField.values()).collect(toMap(ExtraAppImageFileField::fieldName, x -> x.asString(this)));\n+        return Stream.of(ExtraAppImageFileField.values()).map(field -> {\n+            return field.findStringValue(this).map(value -> {\n+                return Map.entry(field.fieldName(), value);\n+            });\n+        })\n+        .filter(Optional::isPresent)\n+        .map(Optional::get)\n+        .collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -87,2 +99,10 @@\n-        SIGNED(\"signed\", app -> Boolean.toString(app.sign())),\n-        APP_STORE(\"app-store\", app -> Boolean.toString(app.appStore()));\n+        SIGNED(MAC_SIGNED, app -> {\n+            return Optional.of(Boolean.toString(app.sign()));\n+        }),\n+        APP_STORE(MAC_APP_STORE, app -> {\n+            return Optional.of(Boolean.toString(app.appStore()));\n+        }),\n+        APP_CLASS(MAC_MAIN_CLASS, app -> {\n+            return app.mainLauncher().flatMap(Launcher::startupInfo).map(LauncherStartupInfo::qualifiedClassName);\n+        }),\n+        ;\n@@ -90,2 +110,2 @@\n-        ExtraAppImageFileField(String fieldName, Function<MacApplication, String> getter) {\n-            this.fieldName = fieldName;\n+        ExtraAppImageFileField(OptionValue<?> option, Function<MacApplication, Optional<String>> getter) {\n+            this.fieldName = option.getName();\n@@ -95,1 +115,1 @@\n-        public String fieldName() {\n+        String fieldName() {\n@@ -99,1 +119,1 @@\n-        String asString(MacApplication app) {\n+        Optional<String> findStringValue(MacApplication app) {\n@@ -104,1 +124,1 @@\n-        private final Function<MacApplication, String> getter;\n+        private final Function<MacApplication, Optional<String>> getter;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacApplication.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,6 +26,0 @@\n-\n-app.bundler.name=Mac Application Image\n-store.bundler.name=Mac App Store Ready Bundler\n-dmg.bundler.name=Mac DMG Package\n-pkg.bundler.name=Mac PKG Package\n-\n@@ -35,3 +29,1 @@\n-error.must-sign-app-store=Mac App Store apps must be signed, and signing has been disabled by bundler configuration\n-error.must-sign-app-store.advice=Use --mac-sign option with appropriate user-name and keychain\n-error.certificate.expired=Error: Certificate expired {0}\n+error.certificate.expired=Certificate expired {0}\n@@ -40,2 +32,2 @@\n-error.app-image.mac-sign.required=Error: --mac-sign option is required with predefined application image and with type [app-image]\n-error.tool.failed.with.output=Error: \"{0}\" failed with following output:\n+error.app-image.mac-sign.required=--mac-sign option is required with predefined application image and with type [app-image]\n+error.tool.failed.with.output=\"{0}\" failed with following output:\n@@ -45,1 +37,0 @@\n-resource.bundle-config-file=Bundle config file\n@@ -63,1 +54,0 @@\n-\n@@ -69,6 +59,2 @@\n-message.creating-association-with-null-extension=Creating association with null extension.\n-message.ignoring.symlink=Warning: codesign is skipping the symlink {0}.\n-message.already.signed=File already signed: {0}.\n-message.keychain.error=Error: unable to get keychain list.\n-message.building-bundle=Building Mac App Store Package for {0}.\n-message.invalid-identifier=invalid mac bundle identifier [{0}].\n+message.keychain.error=Unable to get keychain list.\n+message.invalid-identifier=Invalid mac bundle identifier [{0}].\n@@ -77,1 +63,0 @@\n-message.running-script=Running shell script on application image [{0}].\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/MacResources.properties","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,2 @@\n-provides jdk.jpackage.internal.Bundler with\n-    jdk.jpackage.internal.MacAppBundler,\n-    jdk.jpackage.internal.MacDmgBundler,\n-    jdk.jpackage.internal.MacPkgBundler;\n-\n+provides jdk.jpackage.internal.cli.CliBundlingEnvironment with\n+    jdk.jpackage.internal.MacBundlingEnvironment;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/module-info.java.extra","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.util.FileUtils;\n-\n-\n-\/**\n- * AbstractBundler\n- *\n- * This is the base class all bundlers extend from.\n- * It contains methods and parameters common to all bundlers.\n- * The concrete implementations are in the platform specific bundlers.\n- *\/\n-abstract class AbstractBundler implements Bundler {\n-\n-    @Override\n-    public String toString() {\n-        return getName();\n-    }\n-\n-    @Override\n-    public void cleanup(Map<String, ? super Object> params) {\n-        try {\n-            FileUtils.deleteRecursive(\n-                    StandardBundlerParam.TEMP_ROOT.fetchFrom(params));\n-        } catch (IOException e) {\n-            Log.verbose(e.getMessage());\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractBundler.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import jdk.internal.util.OperatingSystem;\n-\n-import jdk.jpackage.internal.Arguments.CLIOptions;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-\n-\/*\n- * AddLauncherArguments\n- *\n- * Processes a add-launcher properties file to create the Map of\n- * bundle params applicable to the add-launcher:\n- *\n- * BundlerParams p = (new AddLauncherArguments(file)).getLauncherMap();\n- *\n- * A add-launcher is another executable program generated by either the\n- * create-app-image mode or the create-installer mode.\n- * The add-launcher may be the same program with different configuration,\n- * or a completely different program created from the same files.\n- *\n- * There may be multiple add-launchers, each created by using the\n- * command line arg \"--add-launcher <file path>\n- *\n- * The add-launcher properties file may have any of:\n- *\n- * appVersion\n- * description\n- * module\n- * main-jar\n- * main-class\n- * icon\n- * arguments\n- * java-options\n- * launcher-as-service\n- * win-console\n- * win-shortcut\n- * win-menu\n- * linux-app-category\n- * linux-shortcut\n- *\n- *\/\n-class AddLauncherArguments {\n-\n-    private final String name;\n-    private final String filename;\n-    private Map<String, String> allArgs;\n-    private Map<String, ? super Object> bundleParams;\n-\n-    AddLauncherArguments(String name, String filename) {\n-        this.name = name;\n-        this.filename = filename;\n-    }\n-\n-    private void initLauncherMap() {\n-        if (bundleParams != null) {\n-            return;\n-        }\n-\n-        allArgs = Arguments.getPropertiesFromFile(filename);\n-        allArgs.put(CLIOptions.NAME.getId(), name);\n-\n-        bundleParams = new HashMap<>();\n-        String mainJar = getOptionValue(CLIOptions.MAIN_JAR);\n-        String mainClass = getOptionValue(CLIOptions.APPCLASS);\n-        String module = getOptionValue(CLIOptions.MODULE);\n-\n-        if (module != null && mainClass != null) {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.MODULE.getId(),\n-                    module + \"\/\" + mainClass);\n-        } else if (module != null) {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.MODULE.getId(),\n-                    module);\n-        } else {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.MAIN_JAR.getId(),\n-                    mainJar);\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.APPCLASS.getId(),\n-                    mainClass);\n-        }\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.NAME.getId(),\n-                getOptionValue(CLIOptions.NAME));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.VERSION.getId(),\n-                getOptionValue(CLIOptions.VERSION));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.DESCRIPTION.getId(),\n-                getOptionValue(CLIOptions.DESCRIPTION));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.RELEASE.getId(),\n-                getOptionValue(CLIOptions.RELEASE));\n-\n-        Arguments.putUnlessNull(bundleParams, CLIOptions.ICON.getId(),\n-                Optional.ofNullable(getOptionValue(CLIOptions.ICON)).map(\n-                        Path::of).orElse(null));\n-\n-        Arguments.putUnlessNull(bundleParams,\n-                CLIOptions.LAUNCHER_AS_SERVICE.getId(), getOptionValue(\n-                CLIOptions.LAUNCHER_AS_SERVICE));\n-\n-        if (OperatingSystem.isWindows()) {\n-            Arguments.putUnlessNull(bundleParams,\n-                    CLIOptions.WIN_CONSOLE_HINT.getId(),\n-                    getOptionValue(CLIOptions.WIN_CONSOLE_HINT));\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_SHORTCUT_HINT.getId(),\n-                    getOptionValue(CLIOptions.WIN_SHORTCUT_HINT));\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.WIN_MENU_HINT.getId(),\n-                    getOptionValue(CLIOptions.WIN_MENU_HINT));\n-        }\n-\n-        if (OperatingSystem.isLinux()) {\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_CATEGORY.getId(),\n-                    getOptionValue(CLIOptions.LINUX_CATEGORY));\n-            Arguments.putUnlessNull(bundleParams, CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n-                    getOptionValue(CLIOptions.LINUX_SHORTCUT_HINT));\n-        }\n-\n-        \/\/ \"arguments\" and \"java-options\" even if value is null:\n-        if (allArgs.containsKey(CLIOptions.ARGUMENTS.getId())) {\n-            String argumentStr = getOptionValue(CLIOptions.ARGUMENTS);\n-            bundleParams.put(CLIOptions.ARGUMENTS.getId(),\n-                    Arguments.getArgumentList(argumentStr));\n-        }\n-\n-        if (allArgs.containsKey(CLIOptions.JAVA_OPTIONS.getId())) {\n-            String jvmargsStr = getOptionValue(CLIOptions.JAVA_OPTIONS);\n-            bundleParams.put(CLIOptions.JAVA_OPTIONS.getId(),\n-                    Arguments.getArgumentList(jvmargsStr));\n-        }\n-    }\n-\n-    private String getOptionValue(CLIOptions option) {\n-        if (option == null || allArgs == null) {\n-            return null;\n-        }\n-\n-        String id = option.getId();\n-\n-        if (allArgs.containsKey(id)) {\n-            return allArgs.get(id);\n-        }\n-\n-        return null;\n-    }\n-\n-    Map<String, ? super Object> getLauncherMap() {\n-        initLauncherMap();\n-        return bundleParams;\n-    }\n-\n-    static Map<String, ? super Object> merge(\n-            Map<String, ? super Object> original,\n-            Map<String, ? super Object> additional, String... exclude) {\n-        Map<String, ? super Object> tmp = new HashMap<>(original);\n-        List.of(exclude).forEach(tmp::remove);\n-\n-        \/\/ remove LauncherData from map so it will be re-computed\n-        tmp.remove(LAUNCHER_DATA.getID());\n-        \/\/ remove \"application-name\" so it will be re-computed\n-        tmp.remove(APP_NAME.getID());\n-\n-        if (additional.containsKey(CLIOptions.MODULE.getId())) {\n-            tmp.remove(CLIOptions.MAIN_JAR.getId());\n-            tmp.remove(CLIOptions.APPCLASS.getId());\n-        } else if (additional.containsKey(CLIOptions.MAIN_JAR.getId())) {\n-            tmp.remove(CLIOptions.MODULE.getId());\n-        }\n-        if (additional.containsKey(CLIOptions.ARGUMENTS.getId())) {\n-            \/\/ if add launcher properties file contains \"arguments\", even with\n-            \/\/ null value, disregard the \"arguments\" from command line\n-            tmp.remove(CLIOptions.ARGUMENTS.getId());\n-        }\n-        if (additional.containsKey(CLIOptions.JAVA_OPTIONS.getId())) {\n-            \/\/ same thing for java-options\n-            tmp.remove(CLIOptions.JAVA_OPTIONS.getId());\n-        }\n-        tmp.putAll(additional);\n-        return tmp;\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AddLauncherArguments.java","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -1,168 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Map;\n-import java.util.Objects;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-\n-class AppImageBundler extends AbstractBundler {\n-\n-    @Override\n-    public final String getName() {\n-        return I18N.getString(\"app.bundler.name\");\n-    }\n-\n-    @Override\n-    public final String getID() {\n-        return \"app\";\n-    }\n-\n-    @Override\n-    public final String getBundleType() {\n-        return \"IMAGE\";\n-    }\n-\n-    @Override\n-    public final boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        try {\n-            Objects.requireNonNull(params);\n-\n-            if (!params.containsKey(PREDEFINED_APP_IMAGE.getID())\n-                    && !StandardBundlerParam.isRuntimeInstaller(params)) {\n-                LAUNCHER_DATA.fetchFrom(params);\n-            }\n-\n-            if (paramsValidator != null) {\n-                paramsValidator.validate(params);\n-            }\n-        } catch (RuntimeException re) {\n-            if (re.getCause() instanceof ConfigException) {\n-                throw (ConfigException) re.getCause();\n-            } else {\n-                throw new ConfigException(re);\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    @Override\n-    public final Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        final var predefinedAppImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-\n-        try {\n-            if (predefinedAppImage == null) {\n-                Path rootDirectory = createRoot(params, outputParentDir);\n-                appImageSupplier.prepareApplicationFiles(params, rootDirectory);\n-                return rootDirectory;\n-            } else {\n-                appImageSupplier.prepareApplicationFiles(params, predefinedAppImage);\n-                return predefinedAppImage;\n-            }\n-        } catch (PackagerException pe) {\n-            throw pe;\n-        } catch (RuntimeException|IOException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n-    }\n-\n-    @Override\n-    public final boolean supported(boolean runtimeInstaller) {\n-        return true;\n-    }\n-\n-    @Override\n-    public final boolean isDefault() {\n-        return false;\n-    }\n-\n-    @FunctionalInterface\n-    static interface AppImageSupplier {\n-\n-        void prepareApplicationFiles(Map<String, ? super Object> params,\n-                Path root) throws PackagerException, IOException;\n-    }\n-\n-    final AppImageBundler setAppImageSupplier(AppImageSupplier v) {\n-        appImageSupplier = v;\n-        return this;\n-    }\n-\n-    final AppImageBundler setParamsValidator(ParamsValidator v) {\n-        paramsValidator = v;\n-        return this;\n-    }\n-\n-    @FunctionalInterface\n-    interface ParamsValidator {\n-        void validate(Map<String, ? super Object> params) throws ConfigException;\n-    }\n-\n-    private Path createRoot(Map<String, ? super Object> params,\n-            Path outputDirectory) throws PackagerException, IOException {\n-\n-        IOUtils.writableOutputDir(outputDirectory);\n-\n-        String imageName = APP_NAME.fetchFrom(params);\n-        if (OperatingSystem.isMacOS()) {\n-            imageName = imageName + \".app\";\n-        }\n-\n-        Log.verbose(MessageFormat.format(\n-                I18N.getString(\"message.creating-app-bundle\"),\n-                imageName, outputDirectory.toAbsolutePath()));\n-\n-        \/\/ Create directory structure\n-        Path rootDirectory = outputDirectory.resolve(imageName);\n-        if (Files.exists(rootDirectory)) {\n-            throw new PackagerException(\"error.root-exists\",\n-                    rootDirectory.toAbsolutePath().toString());\n-        }\n-\n-        Files.createDirectories(rootDirectory);\n-\n-        return rootDirectory;\n-    }\n-\n-    private ParamsValidator paramsValidator;\n-    private AppImageSupplier appImageSupplier;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageBundler.java","additions":0,"deletions":168,"binary":false,"changes":168,"status":"deleted"},{"patch":"@@ -28,2 +28,6 @@\n-import static java.util.stream.Collectors.toMap;\n-import static java.util.stream.Collectors.toSet;\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.DESCRIPTION;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_NAME;\n@@ -36,0 +40,1 @@\n+import java.util.ArrayList;\n@@ -39,0 +44,1 @@\n+import java.util.NoSuchElementException;\n@@ -40,1 +46,0 @@\n-import java.util.Optional;\n@@ -43,0 +48,2 @@\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n@@ -47,0 +54,5 @@\n+import jdk.jpackage.internal.cli.OptionValue;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.AppImageFileOptionScope;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.InvalidOptionValueException;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.MissingMandatoryOptionException;\n@@ -49,1 +61,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -51,0 +62,1 @@\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -53,0 +65,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -59,1 +72,1 @@\n-final class AppImageFile implements ExternalApplication {\n+final class AppImageFile {\n@@ -62,1 +75,3 @@\n-        this(new ApplicationData(app));\n+        appVersion = Objects.requireNonNull(app.version());\n+        extra = Objects.requireNonNull(app.extraAppImageFileData());\n+        launcherInfos = app.launchers().stream().map(LauncherInfo::new).toList();\n@@ -65,39 +80,13 @@\n-    private AppImageFile(ApplicationData app) {\n-\n-        appVersion = app.version();\n-        launcherName = app.mainLauncherName();\n-        mainClass = app.mainLauncherMainClassName();\n-        extra = app.extra;\n-        creatorVersion = getVersion();\n-        creatorPlatform = getPlatform();\n-        addLauncherInfos = app.additionalLaunchers;\n-    }\n-\n-    @Override\n-    public List<LauncherInfo> getAddLaunchers() {\n-        return addLauncherInfos;\n-    }\n-\n-    @Override\n-    public String getAppVersion() {\n-        return appVersion;\n-    }\n-\n-    @Override\n-    public String getAppName() {\n-        return launcherName;\n-    }\n-\n-    @Override\n-    public String getLauncherName() {\n-        return launcherName;\n-    }\n-\n-    @Override\n-    public String getMainClass() {\n-        return mainClass;\n-    }\n-\n-    @Override\n-    public Map<String, String> getExtra() {\n-        return extra;\n+    \/**\n+     * Writes the values captured in this instance into the application image info\n+     * file in the given application layout.\n+     * <p>\n+     * It is an equivalent to calling\n+     * {@link #save(ApplicationLayout, OperatingSystem)} method with\n+     * {@code OperatingSystem.current()} for the second parameter.\n+     *\n+     * @param appLayout the application layout\n+     * @throws IOException if an I\/O error occurs when writing\n+     *\/\n+    void save(ApplicationLayout appLayout) throws IOException {\n+        save(appLayout, OperatingSystem.current());\n@@ -107,2 +96,6 @@\n-     * Saves file with application image info in application image using values\n-     * from this instance.\n+     * Writes the values captured in this instance into the application image info\n+     * file in the given application layout.\n+     *\n+     * @param appLayout the application layout\n+     * @param os the target OS\n+     * @throws IOException if an I\/O error occurs when writing\n@@ -110,1 +103,1 @@\n-    void save(ApplicationLayout appLayout) throws IOException {\n+    void save(ApplicationLayout appLayout, OperatingSystem os) throws IOException {\n@@ -113,2 +106,2 @@\n-            xml.writeAttribute(\"version\", creatorVersion);\n-            xml.writeAttribute(\"platform\", creatorPlatform);\n+            xml.writeAttribute(\"version\", getVersion());\n+            xml.writeAttribute(\"platform\", getPlatform(os));\n@@ -120,8 +113,0 @@\n-            xml.writeStartElement(\"main-launcher\");\n-            xml.writeCharacters(launcherName);\n-            xml.writeEndElement();\n-\n-            xml.writeStartElement(\"main-class\");\n-            xml.writeCharacters(mainClass);\n-            xml.writeEndElement();\n-\n@@ -134,10 +119,4 @@\n-            for (var li : addLauncherInfos) {\n-                xml.writeStartElement(\"add-launcher\");\n-                xml.writeAttribute(\"name\", li.name());\n-                xml.writeAttribute(\"service\", Boolean.toString(li.service()));\n-                for (var extraKey : li.extra().keySet().stream().sorted().toList()) {\n-                    xml.writeStartElement(extraKey);\n-                    xml.writeCharacters(li.extra().get(extraKey));\n-                    xml.writeEndElement();\n-                }\n-                xml.writeEndElement();\n+            launcherInfos.getFirst().save(xml, \"main-launcher\");\n+\n+            for (var li : launcherInfos.subList(1, launcherInfos.size())) {\n+                li.save(xml, \"add-launcher\");\n@@ -149,2 +128,3 @@\n-     * Returns path to application image info file.\n-     * @param appLayout - application layout\n+     * Returns the path to the application image info file in the given application layout.\n+     *\n+     * @param appLayout the application layout\n@@ -157,3 +137,18 @@\n-     * Loads application image info from application image.\n-     * @param appImageDir - path at which to resolve the given application layout\n-     * @param appLayout - application layout\n+     * Loads application image info from the specified application layout.\n+     * <p>\n+     * It is an equivalent to calling\n+     * {@link #load(ApplicationLayout, OperatingSystem)} method with\n+     * {@code OperatingSystem.current()} for the second parameter.\n+     *\n+     * @param appLayout the application layout\n+     *\/\n+    static ExternalApplication load(ApplicationLayout appLayout) {\n+        return load(appLayout, OperatingSystem.current());\n+    }\n+\n+    \/**\n+     * Loads application image info from the specified application layout and OS.\n+     *\n+     * @param appLayout the application layout\n+     * @param os        the OS defining extra properties of the application and\n+     *                  additional launchers\n@@ -161,2 +156,8 @@\n-    static AppImageFile load(Path appImageDir, ApplicationLayout appLayout) throws ConfigException, IOException {\n-        var srcFilePath = getPathInAppImage(appLayout.resolveAt(appImageDir));\n+    static ExternalApplication load(ApplicationLayout appLayout, OperatingSystem os) {\n+        Objects.requireNonNull(appLayout);\n+        Objects.requireNonNull(os);\n+\n+        final var appImageDir = appLayout.rootDirectory();\n+        final var appImageFilePath = getPathInAppImage(appLayout);\n+        final var relativeAppImageFilePath = appImageDir.relativize(appImageFilePath);\n+\n@@ -164,1 +165,1 @@\n-            final Document doc = XmlUtils.initDocumentBuilder().parse(Files.newInputStream(srcFilePath));\n+            final Document doc = XmlUtils.initDocumentBuilder().parse(Files.newInputStream(appImageFilePath));\n@@ -169,1 +170,1 @@\n-                    Node::getNodeValue).map(getPlatform()::equals).orElse(false);\n+                    Node::getNodeValue).map(getPlatform(os)::equals).orElse(false);\n@@ -180,6 +181,7 @@\n-            final AppImageProperties props;\n-            try {\n-                props = AppImageProperties.main(doc, xPath);\n-            } catch (IllegalArgumentException ex) {\n-                throw new InvalidAppImageFileException(ex);\n-            }\n+            final var appOptions = AppImageFileOptionScope.APP.parse(appImageFilePath, AppImageProperties.main(doc, xPath), os);\n+\n+            final var mainLauncherOptions = LauncherElement.MAIN.readAll(doc, xPath).stream().reduce((_, second) -> {\n+                return second;\n+            }).map(launcherProps -> {\n+                return AppImageFileOptionScope.LAUNCHER.parse(appImageFilePath, launcherProps, os);\n+            }).orElseThrow(InvalidAppImageFileException::new);\n@@ -187,7 +189,2 @@\n-            final var additionalLaunchers = AppImageProperties.launchers(doc, xPath).stream().map(launcherProps -> {\n-                try {\n-                    return new LauncherInfo(launcherProps.get(\"name\"),\n-                            launcherProps.find(\"service\").map(Boolean::parseBoolean).orElse(false), launcherProps.getExtra());\n-                } catch (IllegalArgumentException ex) {\n-                    throw new InvalidAppImageFileException(ex);\n-                }\n+            final var addLauncherOptions = LauncherElement.ADDITIONAL.readAll(doc, xPath).stream().map(launcherProps -> {\n+                return AppImageFileOptionScope.LAUNCHER.parse(appImageFilePath, launcherProps, os);\n@@ -196,2 +193,5 @@\n-            return new AppImageFile(new ApplicationData(props.get(\"app-version\"), props.get(\"main-launcher\"),\n-                    props.get(\"main-class\"), props.getExtra(), additionalLaunchers));\n+            try {\n+                return ExternalApplication.create(Options.concat(appOptions, mainLauncherOptions), addLauncherOptions, os);\n+            } catch (NoSuchElementException ex) {\n+                throw new InvalidAppImageFileException(ex);\n+            }\n@@ -201,1 +201,1 @@\n-            throw new RuntimeException(ex);\n+            throw ExceptionBox.rethrowUnchecked(ex);\n@@ -203,2 +203,2 @@\n-            \/\/ Exception reading input XML (probably malformed XML)\n-            throw new IOException(ex);\n+            \/\/ Malformed input XML\n+            throw new JPackageException(I18N.format(\"error.malformed-app-image-file\", relativeAppImageFilePath, appImageDir), ex);\n@@ -206,2 +206,3 @@\n-            throw I18N.buildConfigException(\"error.foreign-app-image\", appImageDir).create();\n-        } catch (InvalidAppImageFileException ex) {\n+            \/\/ Don't save the original exception as its error message is redundant.\n+            throw new JPackageException(I18N.format(\"error.missing-app-image-file\", relativeAppImageFilePath, appImageDir));\n+        } catch (InvalidAppImageFileException|InvalidOptionValueException|MissingMandatoryOptionException ex) {\n@@ -209,1 +210,3 @@\n-            throw I18N.buildConfigException(\"error.invalid-app-image\", appImageDir, srcFilePath).create();\n+            throw new JPackageException(I18N.format(\"error.invalid-app-image-file\", relativeAppImageFilePath, appImageDir), ex);\n+        } catch (IOException ex) {\n+            throw new JPackageException(I18N.format(\"error.reading-app-image-file\", relativeAppImageFilePath, appImageDir), ex);\n@@ -213,6 +216,0 @@\n-    static boolean getBooleanExtraFieldValue(String fieldId, ExternalApplication appImageFile) {\n-        Objects.requireNonNull(fieldId);\n-        Objects.requireNonNull(appImageFile);\n-        return Optional.ofNullable(appImageFile.getExtra().get(fieldId)).map(Boolean::parseBoolean).orElse(false);\n-    }\n-\n@@ -223,2 +220,2 @@\n-    static String getPlatform() {\n-        return PLATFORM_LABELS.get(OperatingSystem.current());\n+    static String getPlatform(OperatingSystem os) {\n+        return Objects.requireNonNull(PLATFORM_LABELS.get(Objects.requireNonNull(os)));\n@@ -227,0 +224,1 @@\n+\n@@ -228,4 +226,0 @@\n-        private AppImageProperties(Map<String, String> data, Set<String> stdKeys) {\n-            this.data = data;\n-            this.stdKeys = stdKeys;\n-        }\n@@ -233,3 +227,2 @@\n-        static AppImageProperties main(Document xml, XPath xPath) throws XPathExpressionException {\n-            final var data = queryProperties(xml.getDocumentElement(), xPath, MAIN_PROPERTIES_XPATH_QUERY);\n-            return new AppImageProperties(data, MAIN_ELEMENT_NAMES);\n+        static Map<String, String> main(Document xml, XPath xPath) throws XPathExpressionException {\n+            return queryProperties(xml.getDocumentElement(), xPath, MAIN_PROPERTIES_XPATH_QUERY);\n@@ -238,3 +231,3 @@\n-        static AppImageProperties launcher(Element addLauncherNode, XPath xPath) throws XPathExpressionException {\n-            final var attrData = XmlUtils.toStream(addLauncherNode.getAttributes())\n-                    .collect(toMap(Node::getNodeName, Node::getNodeValue));\n+        static Map<String, String> launcher(Element launcherNode, XPath xPath) throws XPathExpressionException {\n+            final var attrData = XmlUtils.toStream(launcherNode.getAttributes())\n+                    .collect(toUnmodifiableMap(Node::getNodeName, Node::getNodeValue));\n@@ -242,1 +235,1 @@\n-            final var extraData = queryProperties(addLauncherNode, xPath, LAUNCHER_PROPERTIES_XPATH_QUERY);\n+            final var extraData = queryProperties(launcherNode, xPath, LAUNCHER_PROPERTIES_XPATH_QUERY);\n@@ -247,22 +240,1 @@\n-            return new AppImageProperties(data, LAUNCHER_ATTR_NAMES);\n-        }\n-\n-        static List<AppImageProperties> launchers(Document xml, XPath xPath) throws XPathExpressionException {\n-            return XmlUtils.queryNodes(xml, xPath, \"\/jpackage-state\/add-launcher\")\n-                    .map(Element.class::cast).map(toFunction(e -> {\n-                        return launcher(e, xPath);\n-                    })).toList();\n-        }\n-\n-        String get(String name) {\n-            return find(name).orElseThrow(InvalidAppImageFileException::new);\n-        }\n-\n-        Optional<String> find(String name) {\n-            return Optional.ofNullable(data.get(name));\n-        }\n-\n-        Map<String, String> getExtra() {\n-            Map<String, String> extra = new HashMap<>(data);\n-            stdKeys.forEach(extra::remove);\n-            return extra;\n+            return data;\n@@ -275,1 +247,1 @@\n-                    .collect(toMap(Node::getNodeName, selectedElement -> {\n+                    .collect(toUnmodifiableMap(Node::getNodeName, selectedElement -> {\n@@ -288,4 +260,3 @@\n-        private final Map<String, String> data;\n-        private final Set<String> stdKeys;\n-\n-        private static final Set<String> LAUNCHER_ATTR_NAMES = Set.of(\"name\", \"service\");\n+        private static final Set<String> LAUNCHER_ATTR_NAMES = Stream.of(\n+                LAUNCHER_NAME\n+        ).map(OptionValue::getName).collect(toUnmodifiableSet());\n@@ -294,1 +265,3 @@\n-        private static final Set<String> MAIN_ELEMENT_NAMES = Set.of(\"app-version\", \"main-launcher\", \"main-class\");\n+        private static final Set<String> MAIN_ELEMENT_NAMES = Stream.of(\n+                APP_VERSION\n+        ).map(OptionValue::getName).collect(toUnmodifiableSet());\n@@ -304,1 +277,1 @@\n-                            Stream.of(\"add-launcher\")).collect(toSet())));\n+                            Stream.of(\"main-launcher\", \"add-launcher\")).collect(toUnmodifiableSet())));\n@@ -308,2 +281,0 @@\n-    private record ApplicationData(String version, String mainLauncherName, String mainLauncherMainClassName,\n-            Map<String, String> extra, List<LauncherInfo> additionalLaunchers) {\n@@ -311,6 +282,3 @@\n-        ApplicationData {\n-            Objects.requireNonNull(version);\n-            Objects.requireNonNull(mainLauncherName);\n-            Objects.requireNonNull(mainLauncherMainClassName);\n-            Objects.requireNonNull(extra);\n-            Objects.requireNonNull(additionalLaunchers);\n+    private enum LauncherElement {\n+        MAIN(\"main-launcher\"),\n+        ADDITIONAL(\"add-launcher\");\n@@ -318,5 +286,2 @@\n-            for (final var property : List.of(version, mainLauncherName, mainLauncherMainClassName)) {\n-                if (property.isBlank()) {\n-                    throw new IllegalArgumentException();\n-                }\n-            }\n+        LauncherElement(String elementName) {\n+            this.elementName = Objects.requireNonNull(elementName);\n@@ -325,2 +290,5 @@\n-        ApplicationData(Application app) {\n-            this(app, app.mainLauncher().orElseThrow());\n+        List<Map<String, String>> readAll(Document xml, XPath xPath) throws XPathExpressionException {\n+            return XmlUtils.queryNodes(xml, xPath, \"\/jpackage-state\/\" + elementName + \"[@name]\")\n+                    .map(Element.class::cast).map(toFunction(e -> {\n+                        return AppImageProperties.launcher(e, xPath);\n+                    })).toList();\n@@ -329,6 +297,35 @@\n-        private ApplicationData(Application app, Launcher mainLauncher) {\n-            this(app.version(), mainLauncher.name(), mainLauncher.startupInfo().orElseThrow().qualifiedClassName(),\n-                    app.extraAppImageFileData(), app.additionalLaunchers().stream().map(launcher -> {\n-                        return new LauncherInfo(launcher.name(), launcher.isService(),\n-                                launcher.extraAppImageFileData());\n-                    }).toList());\n+        private final String elementName;\n+    }\n+\n+    private record LauncherInfo(String name, Map<String, String> properties) {\n+        LauncherInfo {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(properties);\n+        }\n+\n+        LauncherInfo(Launcher launcher) {\n+            this(launcher.name(), properties(launcher));\n+        }\n+\n+        void save(XMLStreamWriter xml, String elementName) throws IOException, XMLStreamException {\n+            xml.writeStartElement(elementName);\n+            xml.writeAttribute(\"name\", name());\n+            for (var key : properties().keySet().stream().sorted().toList()) {\n+                xml.writeStartElement(key);\n+                xml.writeCharacters(properties().get(key));\n+                xml.writeEndElement();\n+            }\n+            xml.writeEndElement();\n+        }\n+\n+        private static Map<String, String> properties(Launcher launcher) {\n+            List<Map.Entry<String, String>> standardProps = new ArrayList<>();\n+            if (launcher.isService()) {\n+                standardProps.add(Map.entry(LAUNCHER_AS_SERVICE.getName(), Boolean.TRUE.toString()));\n+            }\n+            standardProps.add(Map.entry(DESCRIPTION.getName(), launcher.description()));\n+\n+            return Stream.concat(\n+                    standardProps.stream(),\n+                    launcher.extraAppImageFileData().entrySet().stream()\n+            ).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n@@ -338,0 +335,1 @@\n+\n@@ -350,0 +348,1 @@\n+\n@@ -351,2 +350,0 @@\n-    private final String launcherName;\n-    private final String mainClass;\n@@ -354,3 +351,1 @@\n-    private final List<LauncherInfo> addLauncherInfos;\n-    private final String creatorVersion;\n-    private final String creatorPlatform;\n+    private final List<LauncherInfo> launcherInfos;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":167,"deletions":172,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -43,1 +42,0 @@\n-import jdk.jpackage.internal.model.ExternalApplication.LauncherInfo;\n@@ -52,1 +50,1 @@\n-    Application create() throws ConfigException {\n+    Application create() {\n@@ -58,16 +56,5 @@\n-        final var launcherCount = launchersAsList.size();\n-\n-        if (launcherCount != launchersAsList.stream().map(Launcher::name).distinct().count()) {\n-            throw buildConfigException(\"ERR_NoUniqueName\").create();\n-        }\n-\n-        final String effectiveName;\n-        if (name != null) {\n-            effectiveName = name;\n-        } else if (!launchersAsList.isEmpty()) {\n-            effectiveName = launchers.mainLauncher().name();\n-        } else {\n-            throw buildConfigException(\"error.no.name\").advice(\"error.no.name.advice\").create();\n-        }\n-\n-        Objects.requireNonNull(launchersAsList);\n+        final String effectiveName = Optional.ofNullable(name).or(() -> {\n+            return Optional.ofNullable(launchers).map(ApplicationLaunchers::mainLauncher).map(Launcher::name);\n+        }).orElseThrow(() -> {\n+            return buildConfigException(\"error.no.name\").advice(\"error.no.name.advice\").create();\n+        });\n@@ -83,1 +70,4 @@\n-                appImageLayout, Optional.ofNullable(runtimeBuilder), launchersAsList, Map.of());\n+                appImageLayout,\n+                Optional.ofNullable(runtimeBuilder),\n+                launchersAsList,\n+                Map.of());\n@@ -91,19 +81,2 @@\n-    ApplicationBuilder initFromExternalApplication(ExternalApplication app,\n-            Function<LauncherInfo, Launcher> mapper) {\n-\n-        externalApp = Objects.requireNonNull(app);\n-\n-        if (version == null) {\n-            version = app.getAppVersion();\n-        }\n-        if (name == null) {\n-            name = app.getAppName();\n-        }\n-        runtimeBuilder = null;\n-\n-        var mainLauncherInfo = new LauncherInfo(app.getLauncherName(), false, Map.of());\n-\n-        launchers = new ApplicationLaunchers(\n-                mapper.apply(mainLauncherInfo),\n-                app.getAddLaunchers().stream().map(mapper).toList());\n-\n+    ApplicationBuilder externalApplication(ExternalApplication v) {\n+        externalApp = v;\n@@ -126,9 +99,0 @@\n-    Optional<String> mainLauncherClassName() {\n-        return launchers()\n-                .map(ApplicationLaunchers::mainLauncher)\n-                .flatMap(Launcher::startupInfo)\n-                .map(LauncherStartupInfo::qualifiedClassName).or(() -> {\n-                    return externalApplication().map(ExternalApplication::getMainClass);\n-                });\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":12,"deletions":48,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-\n-\n-final class ApplicationLayoutUtils {\n-\n-    public static final ApplicationLayout PLATFORM_APPLICATION_LAYOUT;\n-\n-    private static final ApplicationLayout WIN_APPLICATION_LAYOUT = ApplicationLayout.build()\n-            .setAll(\"\")\n-            .appDirectory(\"app\")\n-            .runtimeDirectory(\"runtime\")\n-            .appModsDirectory(Path.of(\"app\", \"mods\"))\n-            .create();\n-\n-    private static final ApplicationLayout MAC_APPLICATION_LAYOUT = ApplicationLayout.build()\n-            .launchersDirectory(\"Contents\/MacOS\")\n-            .appDirectory(\"Contents\/app\")\n-            .runtimeDirectory(\"Contents\/runtime\/Contents\/Home\")\n-            .desktopIntegrationDirectory(\"Contents\/Resources\")\n-            .appModsDirectory(\"Contents\/app\/mods\")\n-            .contentDirectory(\"Contents\")\n-            .create();\n-\n-    private static final ApplicationLayout LINUX_APPLICATION_LAYOUT = ApplicationLayout.build()\n-            .launchersDirectory(\"bin\")\n-            .appDirectory(\"lib\/app\")\n-            .runtimeDirectory(\"lib\/runtime\")\n-            .desktopIntegrationDirectory(\"lib\")\n-            .appModsDirectory(\"lib\/app\/mods\")\n-            .contentDirectory(\"lib\")\n-            .create();\n-\n-    static {\n-        switch (OperatingSystem.current()) {\n-            case WINDOWS -> PLATFORM_APPLICATION_LAYOUT = WIN_APPLICATION_LAYOUT;\n-            case MACOS -> PLATFORM_APPLICATION_LAYOUT = MAC_APPLICATION_LAYOUT;\n-            case LINUX -> PLATFORM_APPLICATION_LAYOUT = LINUX_APPLICATION_LAYOUT;\n-            default -> {\n-                throw new UnsupportedOperationException();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayoutUtils.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,867 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Properties;\n-import java.util.ResourceBundle;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Arguments\n- *\n- * This class encapsulates and processes the command line arguments,\n- * in effect, implementing all the work of jpackage tool.\n- *\n- * The primary entry point, processArguments():\n- * Processes and validates command line arguments, constructing DeployParams.\n- * Validates the DeployParams, and generate the BundleParams.\n- * Generates List of Bundlers from BundleParams valid for this platform.\n- * Executes each Bundler in the list.\n- *\/\n-public class Arguments {\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MainResources\");\n-\n-    private static final String FA_EXTENSIONS = \"extension\";\n-    private static final String FA_CONTENT_TYPE = \"mime-type\";\n-    private static final String FA_DESCRIPTION = \"description\";\n-    private static final String FA_ICON = \"icon\";\n-\n-    \/\/ Mac specific file association keys\n-    \/\/ String\n-    public static final String MAC_CFBUNDLETYPEROLE = \"mac.CFBundleTypeRole\";\n-    public static final String MAC_LSHANDLERRANK = \"mac.LSHandlerRank\";\n-    public static final String MAC_NSSTORETYPEKEY = \"mac.NSPersistentStoreTypeKey\";\n-    public static final String MAC_NSDOCUMENTCLASS = \"mac.NSDocumentClass\";\n-    \/\/ Boolean\n-    public static final String MAC_LSTYPEISPACKAGE = \"mac.LSTypeIsPackage\";\n-    public static final String MAC_LSDOCINPLACE = \"mac.LSSupportsOpeningDocumentsInPlace\";\n-    public static final String MAC_UIDOCBROWSER = \"mac.UISupportsDocumentBrowser\";\n-     \/\/ Array of strings\n-    public static final String MAC_NSEXPORTABLETYPES = \"mac.NSExportableTypes\";\n-    public static final String MAC_UTTYPECONFORMSTO = \"mac.UTTypeConformsTo\";\n-\n-    \/\/ regexp for parsing args (for example, for additional launchers)\n-    private static Pattern pattern = Pattern.compile(\n-          \"(?:(?:([\\\"'])(?:\\\\\\\\\\\\1|.)*?(?:\\\\1|$))|(?:\\\\\\\\[\\\"'\\\\s]|[^\\\\s]))++\");\n-\n-    private DeployParams deployParams = null;\n-\n-    private int pos = 0;\n-    private List<String> argList = null;\n-\n-    private List<CLIOptions> allOptions = null;\n-\n-    private boolean hasMainJar = false;\n-    private boolean hasMainClass = false;\n-    private boolean hasMainModule = false;\n-    public boolean userProvidedBuildRoot = false;\n-\n-    private String buildRoot = null;\n-    private String mainJarPath = null;\n-\n-    private boolean runtimeInstaller = false;\n-\n-    private List<AddLauncherArguments> addLaunchers = null;\n-\n-    private static final Map<String, CLIOptions> argIds = new HashMap<>();\n-    private static final Map<String, CLIOptions> argShortIds = new HashMap<>();\n-\n-    static {\n-        \/\/ init maps for parsing arguments\n-        (EnumSet.allOf(CLIOptions.class)).forEach(option -> {\n-            argIds.put(option.getIdWithPrefix(), option);\n-            if (option.getShortIdWithPrefix() != null) {\n-                argShortIds.put(option.getShortIdWithPrefix(), option);\n-            }\n-        });\n-    }\n-\n-    private static final InheritableThreadLocal<Arguments> instance =\n-            new InheritableThreadLocal<Arguments>();\n-\n-    public Arguments(String[] args) {\n-        instance.set(this);\n-\n-        argList = new ArrayList<String>(args.length);\n-        for (String arg : args) {\n-            argList.add(arg);\n-        }\n-\n-        pos = 0;\n-\n-        deployParams = new DeployParams();\n-\n-        allOptions = new ArrayList<>();\n-\n-        addLaunchers = new ArrayList<>();\n-    }\n-\n-    \/\/ CLIOptions is public for DeployParamsTest\n-    public enum CLIOptions {\n-        PACKAGE_TYPE(\"type\", \"t\", OptionCategories.PROPERTY, () -> {\n-            var type = popArg();\n-            context().deployParams.setTargetFormat(type);\n-            setOptionValue(\"type\", type);\n-        }),\n-\n-        INPUT (\"input\", \"i\", OptionCategories.PROPERTY, () -> {\n-            setOptionValue(\"input\", popArg());\n-        }),\n-\n-        OUTPUT (\"dest\", \"d\", OptionCategories.PROPERTY, () -> {\n-            var path = Path.of(popArg());\n-            setOptionValue(\"dest\", path);\n-        }),\n-\n-        DESCRIPTION (\"description\", OptionCategories.PROPERTY),\n-\n-        VENDOR (\"vendor\", OptionCategories.PROPERTY),\n-\n-        APPCLASS (\"main-class\", OptionCategories.PROPERTY, () -> {\n-            context().hasMainClass = true;\n-            setOptionValue(\"main-class\", popArg());\n-        }),\n-\n-        NAME (\"name\", \"n\", OptionCategories.PROPERTY),\n-\n-        VERBOSE (\"verbose\", OptionCategories.PROPERTY, () -> {\n-            setOptionValue(\"verbose\", true);\n-            Log.setVerbose();\n-        }),\n-\n-        RESOURCE_DIR(\"resource-dir\",\n-                OptionCategories.PROPERTY, () -> {\n-            String resourceDir = popArg();\n-            setOptionValue(\"resource-dir\", resourceDir);\n-        }),\n-\n-        DMG_CONTENT (\"mac-dmg-content\", OptionCategories.PROPERTY, () -> {\n-            List<String> content = getArgumentList(popArg());\n-            content.forEach(a -> setOptionValue(\"mac-dmg-content\", a));\n-        }),\n-\n-        ARGUMENTS (\"arguments\", OptionCategories.PROPERTY, () -> {\n-            List<String> arguments = getArgumentList(popArg());\n-            setOptionValue(\"arguments\", arguments);\n-        }),\n-\n-        JLINK_OPTIONS (\"jlink-options\", OptionCategories.PROPERTY, () -> {\n-            List<String> options = getArgumentList(popArg());\n-            setOptionValue(\"jlink-options\", options);\n-        }),\n-\n-        ICON (\"icon\", OptionCategories.PROPERTY),\n-\n-        COPYRIGHT (\"copyright\", OptionCategories.PROPERTY),\n-\n-        LICENSE_FILE (\"license-file\", OptionCategories.PROPERTY),\n-\n-        VERSION (\"app-version\", OptionCategories.PROPERTY),\n-\n-        RELEASE (\"linux-app-release\", OptionCategories.PROPERTY),\n-\n-        ABOUT_URL (\"about-url\", OptionCategories.PROPERTY),\n-\n-        JAVA_OPTIONS (\"java-options\", OptionCategories.PROPERTY, () -> {\n-            List<String> args = getArgumentList(popArg());\n-            args.forEach(a -> setOptionValue(\"java-options\", a));\n-        }),\n-\n-        APP_CONTENT (\"app-content\", OptionCategories.PROPERTY, () -> {\n-            getArgumentList(popArg()).forEach(\n-                    a -> setOptionValue(\"app-content\", a));\n-        }),\n-\n-        FILE_ASSOCIATIONS (\"file-associations\",\n-                OptionCategories.PROPERTY, () -> {\n-            Map<String, ? super Object> args = new HashMap<>();\n-\n-            \/\/ load .properties file\n-            Map<String, String> initialMap = getPropertiesFromFile(popArg());\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_EXTENSIONS.getID(),\n-                    initialMap.get(FA_EXTENSIONS));\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_CONTENT_TYPE.getID(),\n-                    initialMap.get(FA_CONTENT_TYPE));\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_DESCRIPTION.getID(),\n-                    initialMap.get(FA_DESCRIPTION));\n-\n-            putUnlessNull(args, StandardBundlerParam.FA_ICON.getID(),\n-                    initialMap.get(FA_ICON));\n-\n-            \/\/ Mac extended file association arguments\n-            putUnlessNull(args, MAC_CFBUNDLETYPEROLE,\n-                    initialMap.get(MAC_CFBUNDLETYPEROLE));\n-\n-            putUnlessNull(args, MAC_LSHANDLERRANK,\n-                    initialMap.get(MAC_LSHANDLERRANK));\n-\n-            putUnlessNull(args, MAC_NSSTORETYPEKEY,\n-                    initialMap.get(MAC_NSSTORETYPEKEY));\n-\n-            putUnlessNull(args, MAC_NSDOCUMENTCLASS,\n-                    initialMap.get(MAC_NSDOCUMENTCLASS));\n-\n-            putUnlessNull(args, MAC_LSTYPEISPACKAGE,\n-                    initialMap.get(MAC_LSTYPEISPACKAGE));\n-\n-            putUnlessNull(args, MAC_LSDOCINPLACE,\n-                    initialMap.get(MAC_LSDOCINPLACE));\n-\n-            putUnlessNull(args, MAC_UIDOCBROWSER,\n-                    initialMap.get(MAC_UIDOCBROWSER));\n-\n-            putUnlessNull(args, MAC_NSEXPORTABLETYPES,\n-                    initialMap.get(MAC_NSEXPORTABLETYPES));\n-\n-            putUnlessNull(args, MAC_UTTYPECONFORMSTO,\n-                    initialMap.get(MAC_UTTYPECONFORMSTO));\n-\n-            ArrayList<Map<String, ? super Object>> associationList =\n-                new ArrayList<Map<String, ? super Object>>();\n-\n-            associationList.add(args);\n-\n-            \/\/ check that we really add _another_ value to the list\n-            setOptionValue(\"file-associations\", associationList);\n-\n-        }),\n-\n-        ADD_LAUNCHER (\"add-launcher\",\n-                    OptionCategories.PROPERTY, () -> {\n-            String spec = popArg();\n-            String name = null;\n-            String filename = spec;\n-            if (spec.contains(\"=\")) {\n-                String[] values = spec.split(\"=\", 2);\n-                name = values[0];\n-                filename = values[1];\n-            }\n-            context().addLaunchers.add(\n-                new AddLauncherArguments(name, filename));\n-        }),\n-\n-        TEMP_ROOT (\"temp\", OptionCategories.PROPERTY, () -> {\n-            context().buildRoot = popArg();\n-            context().userProvidedBuildRoot = true;\n-            setOptionValue(\"temp\", context().buildRoot);\n-        }),\n-\n-        INSTALL_DIR (\"install-dir\", OptionCategories.PROPERTY),\n-\n-        PREDEFINED_APP_IMAGE (\"app-image\", OptionCategories.PROPERTY),\n-\n-        PREDEFINED_RUNTIME_IMAGE (\"runtime-image\", OptionCategories.PROPERTY),\n-\n-        MAIN_JAR (\"main-jar\",  OptionCategories.PROPERTY, () -> {\n-            context().mainJarPath = popArg();\n-            context().hasMainJar = true;\n-            setOptionValue(\"main-jar\", context().mainJarPath);\n-        }),\n-\n-        MODULE (\"module\", \"m\", OptionCategories.MODULAR, () -> {\n-            context().hasMainModule = true;\n-            setOptionValue(\"module\", popArg());\n-        }),\n-\n-        ADD_MODULES (\"add-modules\", OptionCategories.MODULAR),\n-\n-        MODULE_PATH (\"module-path\", \"p\", OptionCategories.MODULAR),\n-\n-        LAUNCHER_AS_SERVICE (\"launcher-as-service\", OptionCategories.PROPERTY, () -> {\n-            setOptionValue(\"launcher-as-service\", true);\n-        }),\n-\n-        MAC_SIGN (\"mac-sign\", \"s\", OptionCategories.PLATFORM_MAC, () -> {\n-            setOptionValue(\"mac-sign\", true);\n-        }),\n-\n-        MAC_APP_STORE (\"mac-app-store\", OptionCategories.PLATFORM_MAC, () -> {\n-            setOptionValue(\"mac-app-store\", true);\n-        }),\n-\n-        MAC_CATEGORY (\"mac-app-category\", OptionCategories.PLATFORM_MAC),\n-\n-        MAC_BUNDLE_NAME (\"mac-package-name\", OptionCategories.PLATFORM_MAC),\n-\n-        MAC_BUNDLE_IDENTIFIER(\"mac-package-identifier\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_BUNDLE_SIGNING_PREFIX (\"mac-package-signing-prefix\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_SIGNING_KEY_NAME (\"mac-signing-key-user-name\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_APP_IMAGE_SIGN_IDENTITY (\"mac-app-image-sign-identity\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_INSTALLER_SIGN_IDENTITY (\"mac-installer-sign-identity\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_SIGNING_KEYCHAIN (\"mac-signing-keychain\",\n-                    OptionCategories.PLATFORM_MAC),\n-\n-        MAC_ENTITLEMENTS (\"mac-entitlements\", OptionCategories.PLATFORM_MAC),\n-\n-        WIN_HELP_URL (\"win-help-url\", OptionCategories.PLATFORM_WIN),\n-\n-        WIN_UPDATE_URL (\"win-update-url\", OptionCategories.PLATFORM_WIN),\n-\n-        WIN_MENU_HINT (\"win-menu\", OptionCategories.PLATFORM_WIN,\n-                createArgumentWithOptionalValueAction(\"win-menu\")),\n-\n-        WIN_MENU_GROUP (\"win-menu-group\", OptionCategories.PLATFORM_WIN),\n-\n-        WIN_SHORTCUT_HINT (\"win-shortcut\", OptionCategories.PLATFORM_WIN,\n-                createArgumentWithOptionalValueAction(\"win-shortcut\")),\n-\n-        WIN_SHORTCUT_PROMPT (\"win-shortcut-prompt\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-shortcut-prompt\", true);\n-        }),\n-\n-        WIN_PER_USER_INSTALLATION (\"win-per-user-install\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-per-user-install\", false);\n-        }),\n-\n-        WIN_DIR_CHOOSER (\"win-dir-chooser\",\n-                OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-dir-chooser\", true);\n-        }),\n-\n-        WIN_UPGRADE_UUID (\"win-upgrade-uuid\",\n-                OptionCategories.PLATFORM_WIN),\n-\n-        WIN_CONSOLE_HINT (\"win-console\", OptionCategories.PLATFORM_WIN, () -> {\n-            setOptionValue(\"win-console\", true);\n-        }),\n-\n-        LINUX_BUNDLE_NAME (\"linux-package-name\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_DEB_MAINTAINER (\"linux-deb-maintainer\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_CATEGORY (\"linux-app-category\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_RPM_LICENSE_TYPE (\"linux-rpm-license-type\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_PACKAGE_DEPENDENCIES (\"linux-package-deps\",\n-                OptionCategories.PLATFORM_LINUX),\n-\n-        LINUX_SHORTCUT_HINT (\"linux-shortcut\", OptionCategories.PLATFORM_LINUX,\n-                createArgumentWithOptionalValueAction(\"linux-shortcut\")),\n-\n-        LINUX_MENU_GROUP (\"linux-menu-group\", OptionCategories.PLATFORM_LINUX);\n-\n-        private final String id;\n-        private final String shortId;\n-        private final OptionCategories category;\n-        private final Runnable action;\n-        private static Arguments argContext;\n-\n-        private CLIOptions(String id, OptionCategories category) {\n-            this(id, null, category, null);\n-        }\n-\n-        private CLIOptions(String id, String shortId,\n-                           OptionCategories category) {\n-            this(id, shortId, category, null);\n-        }\n-\n-        private CLIOptions(String id,\n-                OptionCategories category, Runnable action) {\n-            this(id, null, category, action);\n-        }\n-\n-        private CLIOptions(String id, String shortId,\n-                           OptionCategories category, Runnable action) {\n-            this.id = id;\n-            this.shortId = shortId;\n-            this.action = action;\n-            this.category = category;\n-        }\n-\n-        public static Arguments context() {\n-            return instance.get();\n-        }\n-\n-        public String getId() {\n-            return this.id;\n-        }\n-\n-        String getIdWithPrefix() {\n-            return \"--\" + this.id;\n-        }\n-\n-        String getShortIdWithPrefix() {\n-            return this.shortId == null ? null : \"-\" + this.shortId;\n-        }\n-\n-        void execute() {\n-            if (action != null) {\n-                action.run();\n-            } else {\n-                defaultAction();\n-            }\n-        }\n-\n-        private void defaultAction() {\n-            context().deployParams.addBundleArgument(id, popArg());\n-        }\n-\n-        private static void setOptionValue(String option, Object value) {\n-            context().deployParams.addBundleArgument(option, value);\n-        }\n-\n-        private static String popArg() {\n-            nextArg();\n-            return (context().pos >= context().argList.size()) ?\n-                            \"\" : context().argList.get(context().pos);\n-        }\n-\n-        private static String getArg() {\n-            return (context().pos >= context().argList.size()) ?\n-                        \"\" : context().argList.get(context().pos);\n-        }\n-\n-        private static void nextArg() {\n-            context().pos++;\n-        }\n-\n-        private static void prevArg() {\n-            Objects.checkIndex(context().pos, context().argList.size());\n-            context().pos--;\n-        }\n-\n-        private static boolean hasNextArg() {\n-            return context().pos < context().argList.size();\n-        }\n-\n-        private static Runnable createArgumentWithOptionalValueAction(String option) {\n-            Objects.requireNonNull(option);\n-            return () -> {\n-                nextArg();\n-                if (hasNextArg()) {\n-                    var value = getArg();\n-                    if (value.startsWith(\"-\")) {\n-                        prevArg();\n-                        setOptionValue(option, true);\n-                    } else {\n-                        setOptionValue(option, value);\n-                    }\n-                } else {\n-                    setOptionValue(option, true);\n-                }\n-            };\n-        }\n-    }\n-\n-    enum OptionCategories {\n-        MODULAR,\n-        PROPERTY,\n-        PLATFORM_MAC,\n-        PLATFORM_WIN,\n-        PLATFORM_LINUX;\n-    }\n-\n-    public boolean processArguments() {\n-        try {\n-            \/\/ parse cmd line\n-            String arg;\n-            CLIOptions option;\n-            for (; CLIOptions.hasNextArg(); CLIOptions.nextArg()) {\n-                arg = CLIOptions.getArg();\n-                if ((option = toCLIOption(arg)) != null) {\n-                    \/\/ found a CLI option\n-                    allOptions.add(option);\n-                    option.execute();\n-                } else {\n-                    throw new PackagerException(\"ERR_InvalidOption\", arg);\n-                }\n-            }\n-\n-            \/\/ display error for arguments that are not supported\n-            \/\/ for current configuration.\n-\n-            validateArguments();\n-\n-            List<Map<String, ? super Object>> launchersAsMap =\n-                    new ArrayList<>();\n-\n-            for (AddLauncherArguments sl : addLaunchers) {\n-                launchersAsMap.add(sl.getLauncherMap());\n-            }\n-\n-            deployParams.addBundleArgument(\n-                    StandardBundlerParam.ADD_LAUNCHERS.getID(),\n-                    launchersAsMap);\n-\n-            \/\/ at this point deployParams should be already configured\n-\n-            deployParams.validate();\n-\n-            BundleParams bp = deployParams.getBundleParams();\n-\n-            \/\/ validate name(s)\n-            ArrayList<String> usedNames = new ArrayList<String>();\n-            usedNames.add(bp.getName()); \/\/ add main app name\n-\n-            for (AddLauncherArguments sl : addLaunchers) {\n-                Map<String, ? super Object> slMap = sl.getLauncherMap();\n-                String slName =\n-                        (String) slMap.get(Arguments.CLIOptions.NAME.getId());\n-                if (slName == null) {\n-                    throw new PackagerException(\"ERR_NoAddLauncherName\");\n-                }\n-                \/\/ same rules apply to additional launcher names as app name\n-                DeployParams.validateName(slName, false);\n-                for (String usedName : usedNames) {\n-                    if (slName.equals(usedName)) {\n-                        throw new PackagerException(\"ERR_NoUniqueName\");\n-                    }\n-                }\n-                usedNames.add(slName);\n-            }\n-\n-            generateBundle(bp.getBundleParamsAsMap());\n-            return true;\n-        } catch (Exception e) {\n-            Log.verbose(e);\n-            String msg1 = e.getMessage();\n-            Log.fatalError(msg1);\n-            if (e.getCause() != null && e.getCause() != e) {\n-                String msg2 = e.getCause().getMessage();\n-                if (msg2 != null && !msg1.contains(msg2)) {\n-                    Log.fatalError(msg2);\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private void validateArguments() throws PackagerException {\n-        String type = deployParams.getTargetFormat();\n-        String ptype = (type != null) ? type : \"default\";\n-        boolean imageOnly = deployParams.isTargetAppImage();\n-        boolean hasAppImage = allOptions.contains(\n-                CLIOptions.PREDEFINED_APP_IMAGE);\n-        boolean hasRuntime = allOptions.contains(\n-                CLIOptions.PREDEFINED_RUNTIME_IMAGE);\n-        boolean installerOnly = !imageOnly && hasAppImage;\n-        boolean isMac = OperatingSystem.isMacOS();\n-        runtimeInstaller = !imageOnly && hasRuntime && !hasAppImage &&\n-                !hasMainModule && !hasMainJar;\n-\n-        for (CLIOptions option : allOptions) {\n-            if (!ValidOptions.checkIfSupported(option)) {\n-                \/\/ includes option valid only on different platform\n-                throw new PackagerException(\"ERR_UnsupportedOption\",\n-                        option.getIdWithPrefix());\n-            }\n-            if ((imageOnly && !isMac) || (imageOnly && !hasAppImage && isMac)) {\n-                if (!ValidOptions.checkIfImageSupported(option)) {\n-                    throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                        option.getIdWithPrefix(), type);\n-                }\n-            } else if (imageOnly && hasAppImage && isMac) { \/\/ Signing app image\n-                if (!ValidOptions.checkIfSigningSupported(option)) {\n-                    throw new PackagerException(\n-                            \"ERR_InvalidOptionWithAppImageSigning\",\n-                            option.getIdWithPrefix());\n-                }\n-            } else if (installerOnly || runtimeInstaller) {\n-                if (!ValidOptions.checkIfInstallerSupported(option)) {\n-                    if (runtimeInstaller) {\n-                        throw new PackagerException(\"ERR_NoInstallerEntryPoint\",\n-                            option.getIdWithPrefix());\n-                    } else {\n-                        throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                            option.getIdWithPrefix(), ptype);\n-                   }\n-                }\n-            }\n-        }\n-        if (hasRuntime) {\n-            if (hasAppImage) {\n-                \/\/ note --runtime-image is only for image or runtime installer.\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),\n-                        CLIOptions.PREDEFINED_APP_IMAGE.getIdWithPrefix());\n-            }\n-            if (allOptions.contains(CLIOptions.ADD_MODULES)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),\n-                        CLIOptions.ADD_MODULES.getIdWithPrefix());\n-            }\n-            if (allOptions.contains(CLIOptions.JLINK_OPTIONS)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.PREDEFINED_RUNTIME_IMAGE.getIdWithPrefix(),\n-                        CLIOptions.JLINK_OPTIONS.getIdWithPrefix());\n-            }\n-        }\n-        if (allOptions.contains(CLIOptions.MAC_SIGNING_KEY_NAME) &&\n-            allOptions.contains(CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.MAC_SIGNING_KEY_NAME.getIdWithPrefix(),\n-                        CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getIdWithPrefix());\n-        }\n-        if (allOptions.contains(CLIOptions.MAC_SIGNING_KEY_NAME) &&\n-            allOptions.contains(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY)) {\n-                throw new PackagerException(\"ERR_MutuallyExclusiveOptions\",\n-                        CLIOptions.MAC_SIGNING_KEY_NAME.getIdWithPrefix(),\n-                        CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getIdWithPrefix());\n-        }\n-        if (isMac && (imageOnly || \"dmg\".equals(type)) &&\n-            allOptions.contains(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY)) {\n-                throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                        CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getIdWithPrefix(),\n-                        type);\n-        }\n-        if (allOptions.contains(CLIOptions.DMG_CONTENT)\n-                && !(\"dmg\".equals(type))) {\n-            throw new PackagerException(\"ERR_InvalidTypeOption\",\n-                    CLIOptions.DMG_CONTENT.getIdWithPrefix(), ptype);\n-        }\n-        if (hasMainJar && hasMainModule) {\n-            throw new PackagerException(\"ERR_BothMainJarAndModule\");\n-        }\n-        if (imageOnly && !hasAppImage && !hasMainJar && !hasMainModule) {\n-                throw new PackagerException(\"ERR_NoEntryPoint\");\n-        }\n-    }\n-\n-    private jdk.jpackage.internal.Bundler getPlatformBundler() {\n-        boolean appImage = deployParams.isTargetAppImage();\n-        String type = deployParams.getTargetFormat();\n-        String bundleType = (appImage ?  \"IMAGE\" : \"INSTALLER\");\n-\n-        for (jdk.jpackage.internal.Bundler bundler :\n-                Bundlers.createBundlersInstance().getBundlers(bundleType)) {\n-            if (type == null) {\n-                if (bundler.isDefault()) {\n-                    return bundler;\n-                }\n-            } else {\n-                if (appImage || type.equalsIgnoreCase(bundler.getID())) {\n-                    return bundler;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private void generateBundle(Map<String,? super Object> params)\n-            throws PackagerException {\n-\n-        \/\/ the temp dir needs to be fetched from the params early,\n-        \/\/ to prevent each copy of the params (such as may be used for\n-        \/\/ additional launchers) from generating a separate temp dir when\n-        \/\/ the default is used (the default is a new temp directory)\n-        \/\/ The bundler.cleanup() below would not otherwise be able to\n-        \/\/ clean these extra (and unneeded) temp directories.\n-        StandardBundlerParam.TEMP_ROOT.fetchFrom(params);\n-\n-        \/\/ determine what bundler to run\n-        jdk.jpackage.internal.Bundler bundler = getPlatformBundler();\n-\n-        if (bundler == null || !bundler.supported(runtimeInstaller)) {\n-            String type = Optional.ofNullable(bundler).map(Bundler::getID).orElseGet(\n-                    () -> deployParams.getTargetFormat());\n-            throw new PackagerException(\"ERR_InvalidInstallerType\", type);\n-        }\n-\n-        Map<String, ? super Object> localParams = new HashMap<>(params);\n-        try {\n-            Path result = executeBundler(bundler, params, localParams);\n-            if (result == null) {\n-                throw new PackagerException(\"MSG_BundlerFailed\",\n-                        bundler.getID(), bundler.getName());\n-            }\n-            Log.verbose(MessageFormat.format(\n-                    I18N.getString(\"message.bundle-created\"),\n-                    bundler.getName()));\n-        } catch (ConfigException e) {\n-            Log.verbose(e);\n-            if (e.getAdvice() != null)  {\n-                throw new PackagerException(e, \"MSG_BundlerConfigException\",\n-                        bundler.getName(), e.getMessage(), e.getAdvice());\n-            } else {\n-                throw new PackagerException(e,\n-                       \"MSG_BundlerConfigExceptionNoAdvice\",\n-                        bundler.getName(), e.getMessage());\n-            }\n-        } catch (RuntimeException re) {\n-            Log.verbose(re);\n-            throw new PackagerException(re, \"MSG_BundlerRuntimeException\",\n-                    bundler.getName(), re.toString());\n-        } finally {\n-            if (userProvidedBuildRoot) {\n-                Log.verbose(MessageFormat.format(\n-                        I18N.getString(\"message.debug-working-directory\"),\n-                        (Path.of(buildRoot)).toAbsolutePath().toString()));\n-            } else {\n-                \/\/ always clean up the temporary directory created\n-                \/\/ when --temp option not used.\n-                bundler.cleanup(localParams);\n-            }\n-        }\n-    }\n-\n-    private static Path executeBundler(Bundler bundler, Map<String, ? super Object> params,\n-            Map<String, ? super Object> localParams) throws ConfigException, PackagerException {\n-        try {\n-            bundler.validate(localParams);\n-            return bundler.execute(localParams, StandardBundlerParam.OUTPUT_DIR.fetchFrom(params));\n-        } catch (ConfigException|PackagerException ex) {\n-            throw ex;\n-        } catch (RuntimeException ex) {\n-            if (ex.getCause() instanceof ConfigException cfgEx) {\n-                throw cfgEx;\n-            } else if (ex.getCause() instanceof PackagerException pkgEx) {\n-                throw pkgEx;\n-            } else {\n-                throw ex;\n-            }\n-        }\n-    }\n-\n-    static CLIOptions toCLIOption(String arg) {\n-        CLIOptions option;\n-        if ((option = argIds.get(arg)) == null) {\n-            option = argShortIds.get(arg);\n-        }\n-        return option;\n-    }\n-\n-    static Map<String, String> getPropertiesFromFile(String filename) {\n-        Map<String, String> map = new HashMap<>();\n-        \/\/ load properties file\n-        Properties properties = new Properties();\n-        try (Reader reader = Files.newBufferedReader(Path.of(filename))) {\n-            properties.load(reader);\n-        } catch (IOException e) {\n-            Log.error(\"Exception: \" + e.getMessage());\n-        }\n-\n-        for (final String name: properties.stringPropertyNames()) {\n-            map.put(name, properties.getProperty(name));\n-        }\n-\n-        return map;\n-    }\n-\n-    static List<String> getArgumentList(String inputString) {\n-        List<String> list = new ArrayList<>();\n-        if (inputString == null || inputString.isEmpty()) {\n-             return list;\n-        }\n-\n-        \/\/ The \"pattern\" regexp attempts to abide to the rule that\n-        \/\/ strings are delimited by whitespace unless surrounded by\n-        \/\/ quotes, then it is anything (including spaces) in the quotes.\n-        Matcher m = pattern.matcher(inputString);\n-        while (m.find()) {\n-            String s = inputString.substring(m.start(), m.end()).trim();\n-            \/\/ Ensure we do not have an empty string. trim() will take care of\n-            \/\/ whitespace only strings. The regex preserves quotes and escaped\n-            \/\/ chars so we need to clean them before adding to the List\n-            if (!s.isEmpty()) {\n-                list.add(unquoteIfNeeded(s));\n-            }\n-        }\n-        return list;\n-    }\n-\n-    static void putUnlessNull(Map<String, ? super Object> params,\n-            String param, Object value) {\n-        if (value != null) {\n-            params.put(param, value);\n-        }\n-    }\n-\n-    private static String unquoteIfNeeded(String in) {\n-        if (in == null) {\n-            return null;\n-        }\n-\n-        if (in.isEmpty()) {\n-            return \"\";\n-        }\n-\n-        \/\/ Use code points to preserve non-ASCII chars\n-        StringBuilder sb = new StringBuilder();\n-        int codeLen = in.codePointCount(0, in.length());\n-        int quoteChar = -1;\n-        for (int i = 0; i < codeLen; i++) {\n-            int code = in.codePointAt(i);\n-            if (code == '\"' || code == '\\'') {\n-                \/\/ If quote is escaped make sure to copy it\n-                if (i > 0 && in.codePointAt(i - 1) == '\\\\') {\n-                    sb.deleteCharAt(sb.length() - 1);\n-                    sb.appendCodePoint(code);\n-                    continue;\n-                }\n-                if (quoteChar != -1) {\n-                    if (code == quoteChar) {\n-                        \/\/ close quote, skip char\n-                        quoteChar = -1;\n-                    } else {\n-                        sb.appendCodePoint(code);\n-                    }\n-                } else {\n-                    \/\/ opening quote, skip char\n-                    quoteChar = code;\n-                }\n-            } else {\n-                sb.appendCodePoint(code);\n-            }\n-        }\n-        return sb.toString();\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":0,"deletions":867,"binary":false,"changes":867,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.ServiceLoader;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-\n-\/**\n- * BasicBundlers\n- *\n- * A basic bundlers collection that loads the default bundlers.\n- * Loads the common bundlers.\n- * <UL>\n- *     <LI>Windows file image<\/LI>\n- *     <LI>Mac .app<\/LI>\n- *     <LI>Linux file image<\/LI>\n- *     <LI>Windows MSI<\/LI>\n- *     <LI>Windows EXE<\/LI>\n- *     <LI>Mac DMG<\/LI>\n- *     <LI>Mac PKG<\/LI>\n- *     <LI>Linux DEB<\/LI>\n- *     <LI>Linux RPM<\/LI>\n- *\n- * <\/UL>\n- *\/\n-public class BasicBundlers implements Bundlers {\n-\n-    boolean defaultsLoaded = false;\n-\n-    private final Collection<Bundler> bundlers = new CopyOnWriteArrayList<>();\n-\n-    @Override\n-    public Collection<Bundler> getBundlers() {\n-        return Collections.unmodifiableCollection(bundlers);\n-    }\n-\n-    @Override\n-    public Collection<Bundler> getBundlers(String type) {\n-        if (type == null) return Collections.emptySet();\n-        switch (type) {\n-            case \"NONE\":\n-                return Collections.emptySet();\n-            case \"ALL\":\n-                return getBundlers();\n-            default:\n-                return Arrays.asList(getBundlers().stream()\n-                        .filter(b -> type.equalsIgnoreCase(b.getBundleType()))\n-                        .toArray(Bundler[]::new));\n-        }\n-    }\n-\n-    \/\/ Loads bundlers from the META-INF\/services direct\n-    @Override\n-    public void loadBundlersFromServices(ClassLoader cl) {\n-        ServiceLoader<Bundler> loader = ServiceLoader.load(Bundler.class, cl);\n-        for (Bundler aLoader : loader) {\n-            bundlers.add(aLoader);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BasicBundlers.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -27,2 +27,2 @@\n-import java.io.IOException;\n-import java.nio.file.Files;\n+import static jdk.jpackage.internal.cli.StandardValidator.IS_DIRECTORY_EMPTY_OR_NON_EXISTENT_PREDICATE;\n+\n@@ -34,1 +34,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -44,14 +43,6 @@\n-    BuildEnv create() throws ConfigException {\n-        var exceptionBuilder = I18N.buildConfigException(\"ERR_BuildRootInvalid\", root);\n-        if (Files.isDirectory(root)) {\n-            try (var rootDirContents = Files.list(root)) {\n-                if (rootDirContents.findAny().isPresent()) {\n-                    \/\/ The root directory is not empty.\n-                    throw exceptionBuilder.create();\n-                }\n-            } catch (IOException ioe) {\n-                throw exceptionBuilder.cause(ioe).create();\n-            }\n-        } else if (Files.exists(root)) {\n-            \/\/ The root is not a directory.\n-            throw exceptionBuilder.create();\n+    BuildEnv create() {\n+        \/\/ The directory should be validated earlier with a proper error message.\n+        \/\/ Here is only a sanity check.\n+        if (!IS_DIRECTORY_EMPTY_OR_NON_EXISTENT_PREDICATE.test(root)) {\n+            throw new UnsupportedOperationException(\n+                    String.format(\"Root work directory [%s] should be empty or non existent\", root));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvBuilder.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.RESOURCE_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.TEMP_ROOT;\n+import static jdk.jpackage.internal.cli.StandardOption.VERBOSE;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+\n+final class BuildEnvFromOptions {\n+\n+    BuildEnvFromOptions() {\n+        predefinedRuntimeImageLayout(RuntimeLayout.DEFAULT);\n+    }\n+\n+    BuildEnvFromOptions predefinedAppImageLayout(Function<Path, ApplicationLayout> v) {\n+        predefinedAppImageLayout = v;\n+        return this;\n+    }\n+\n+    BuildEnvFromOptions predefinedAppImageLayout(ApplicationLayout v) {\n+        return predefinedAppImageLayout(path -> v.resolveAt(path));\n+    }\n+\n+    BuildEnvFromOptions predefinedRuntimeImageLayout(Function<Path, RuntimeLayout> v) {\n+        predefinedRuntimeImageLayout = v;\n+        return this;\n+    }\n+\n+    BuildEnvFromOptions predefinedRuntimeImageLayout(RuntimeLayout v) {\n+        return predefinedRuntimeImageLayout(path -> v.resolveAt(path));\n+    }\n+\n+    BuildEnv create(Options options, Application app) {\n+        return create(options, app, Optional.empty());\n+    }\n+\n+    BuildEnv create(Options options, Package pkg) {\n+        return create(options, pkg.app(), Optional.of(pkg));\n+    }\n+\n+    private BuildEnv create(Options options, Application app, Optional<Package> pkg) {\n+        Objects.requireNonNull(options);\n+        Objects.requireNonNull(app);\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(predefinedAppImageLayout);\n+        Objects.requireNonNull(predefinedRuntimeImageLayout);\n+\n+        final var builder = new BuildEnvBuilder(TEMP_ROOT.getFrom(options));\n+\n+        RESOURCE_DIR.ifPresentIn(options, builder::resourceDir);\n+        VERBOSE.ifPresentIn(options, builder::verbose);\n+\n+        if (app.isRuntime()) {\n+            var path = PREDEFINED_RUNTIME_IMAGE.getFrom(options);\n+            builder.appImageLayout(predefinedRuntimeImageLayout.apply(path));\n+        } else if (PREDEFINED_APP_IMAGE.containsIn(options)) {\n+            var path = PREDEFINED_APP_IMAGE.getFrom(options);\n+            builder.appImageLayout(predefinedAppImageLayout.apply(path));\n+        } else {\n+            pkg.ifPresentOrElse(builder::appImageDirFor, () -> {\n+                builder.appImageDirFor(app);\n+            });\n+        }\n+\n+        return builder.create();\n+    }\n+\n+    private Function<Path, ApplicationLayout> predefinedAppImageLayout;\n+    private Function<Path, RuntimeLayout> predefinedRuntimeImageLayout;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromOptions.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERBOSE;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.function.Function;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.RuntimeLayout;\n-\n-final class BuildEnvFromParams {\n-\n-    static BuildEnv create(Map<String, ? super Object> params,\n-            Function<Path, ApplicationLayout> predefinedAppImageLayoutProvider,\n-            Function<Path, RuntimeLayout> predefinedRuntimeImageLayoutProvider) throws ConfigException {\n-\n-        final var builder = new BuildEnvBuilder(TEMP_ROOT.fetchFrom(params));\n-\n-        RESOURCE_DIR.copyInto(params, builder::resourceDir);\n-        VERBOSE.copyInto(params, builder::verbose);\n-\n-        final var app = FromParams.APPLICATION.findIn(params).orElseThrow();\n-\n-        final var pkg = FromParams.getCurrentPackage(params);\n-\n-        if (app.isRuntime()) {\n-            var layout = predefinedRuntimeImageLayoutProvider.apply(PREDEFINED_RUNTIME_IMAGE.findIn(params).orElseThrow());\n-            builder.appImageLayout(layout);\n-        } else if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n-            var layout = predefinedAppImageLayoutProvider.apply(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow());\n-            builder.appImageLayout(layout);\n-        } else if (pkg.isPresent()) {\n-            builder.appImageDirFor(pkg.orElseThrow());\n-        } else {\n-            builder.appImageDirFor(app);\n-        }\n-\n-        return builder.create();\n-    }\n-\n-    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(BuildEnv.class, params -> {\n-        return create(params, PLATFORM_APPLICATION_LAYOUT::resolveAt, RuntimeLayout.DEFAULT::resolveAt);\n-    });\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-\n-public class BundleParams {\n-\n-    protected final Map<String, ? super Object> params;\n-\n-    \/**\n-     * create a new bundle with all default values\n-     *\/\n-    public BundleParams() {\n-        params = new HashMap<>();\n-    }\n-\n-    \/**\n-     * Create a bundle params with a copy of the params\n-     * @param params map of initial parameters to be copied in.\n-     *\/\n-    public BundleParams(Map<String, ?> params) {\n-        this.params = new HashMap<>(params);\n-    }\n-\n-    public void addAllBundleParams(Map<String, ? super Object> params) {\n-        this.params.putAll(params);\n-    }\n-\n-    \/\/ NOTE: we do not care about application parameters here\n-    \/\/ as they will be embedded into jar file manifest and\n-    \/\/ java launcher will take care of them!\n-\n-    public Map<String, ? super Object> getBundleParamsAsMap() {\n-        return new HashMap<>(params);\n-    }\n-\n-    public String getName() {\n-        return APP_NAME.fetchFrom(params);\n-    }\n-\n-    private void putUnlessNull(String param, Object value) {\n-        if (value != null) {\n-            params.put(param, value);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BundleParams.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-\/**\n- * Bundler\n- *\n- * The basic interface implemented by all Bundlers.\n- *\/\n-public interface Bundler {\n-    \/**\n-     * @return User Friendly name of this bundler.\n-     *\/\n-    String getName();\n-\n-    \/**\n-     * @return Command line identifier of the bundler.  Should be unique.\n-     *\/\n-    String getID();\n-\n-    \/**\n-     * @return The bundle type of the bundle that is created by this bundler.\n-     *\/\n-    String getBundleType();\n-\n-    \/**\n-     * Determines if this bundler will execute with the given parameters.\n-     *\n-     * @param params The parameters to be validate.  Validation may modify\n-     *               the map, so if you are going to be using the same map\n-     *               across multiple bundlers you should pass in a deep copy.\n-     * @return true if valid\n-     * @throws ConfigException If the configuration params are incorrect.  The\n-     *         exception may contain advice on how to modify the params map\n-     *         to make it valid.\n-     *\/\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException;\n-\n-    \/**\n-     * Creates a bundle from existing content.\n-     *\n-     * If a call to {@link #validate(java.util.Map)} date} returns true with\n-     * the parameters map, then you can expect a valid output.\n-     * However if an exception was thrown out of validate or it returned\n-     * false then you should not expect sensible results from this call.\n-     * It may or may not return a value, and it may or may not throw an\n-     * exception.  But any output should not be considered valid or sane.\n-     *\n-     * @param params The Bundle parameters,\n-     *               Keyed by the id from the ParamInfo.  Execution may\n-     *               modify the map, so if you are going to be using the\n-     *               same map across multiple bundlers you should pass\n-     *               in a deep copy.\n-     * @param outputParentDir\n-     *   The parent dir that the returned bundle will be placed in.\n-     * @return The resulting bundled file\n-     *\n-     * For a bundler that produces a single artifact file this will be the\n-     * location of that artifact (.exe file, .deb file, etc)\n-     *\n-     * For a bundler that produces a specific directory format output this will\n-     * be the location of that specific directory (.app file, etc).\n-     *\n-     * For a bundler that produce multiple files, this will be a parent\n-     * directory of those files (linux and windows images), whose name is not\n-     * relevant to the result.\n-     *\n-     * @throws java.lang.IllegalArgumentException for any of the following\n-     * reasons:\n-     *  <ul>\n-     *      <li>A required parameter is not found in the params list, for\n-     *      example missing the main class.<\/li>\n-     *      <li>A parameter has the wrong type of an object, for example a\n-     *      String where a File is required<\/li>\n-     *      <li>Bundler specific incompatibilities with the parameters, for\n-     *      example a bad version number format or an application id with\n-     *      forward slashes.<\/li>\n-     *  <\/ul>\n-     *\/\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException;\n-\n-     \/**\n-     * Removes temporary files that are used for bundling.\n-     *\/\n-    public void cleanup(Map<String, ? super Object> params);\n-\n-    \/**\n-     * Returns \"true\" if this bundler is supported on current platform.\n-     *\/\n-    public boolean supported(boolean runtimeInstaller);\n-\n-    \/**\n-     * Returns \"true\" if this bundler is he default for the current platform.\n-     *\/\n-    public boolean isDefault();\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Bundler.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.BiFunction;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-import jdk.jpackage.internal.util.function.ThrowingFunction;\n-\n-\/**\n- * BundlerParamInfo<T>\n- *\n- * A BundlerParamInfo encapsulates an individual bundler parameter of type <T>.\n- *\n- * @param id The command line and hashmap name of the parameter\n- *\n- * @param valueType Type of the parameter\n- *\n- * @param defaultValueFunction If the value is not set, and no fallback value is found, the\n- * parameter uses the value returned by the producer.\n- *\n- * @param stringConverter An optional string converter for command line arguments.\n- *\/\n-record BundlerParamInfo<T>(String id, Class<T> valueType,\n-        Function<Map<String, ? super Object>, T> defaultValueFunction,\n-        BiFunction<String, Map<String, ? super Object>, T> stringConverter) {\n-\n-    BundlerParamInfo {\n-        Objects.requireNonNull(id);\n-        Objects.requireNonNull(valueType);\n-    }\n-\n-    static BundlerParamInfo<String> createStringBundlerParam(String id) {\n-        return new BundlerParamInfo<>(id, String.class, null, null);\n-    }\n-\n-    static BundlerParamInfo<Boolean> createBooleanBundlerParam(String id) {\n-        return new BundlerParamInfo<>(id, Boolean.class, null, BundlerParamInfo::toBoolean);\n-    }\n-\n-    static BundlerParamInfo<Path> createPathBundlerParam(String id) {\n-        return new BundlerParamInfo<>(id, Path.class, null, BundlerParamInfo::toPath);\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    static <U> BundlerParamInfo<U> createBundlerParam(String id, Class<? super U> valueType,\n-            ThrowingFunction<Map<String, ? super Object>, U> valueCtor) {\n-        return new BundlerParamInfo(id, valueType, ThrowingFunction.toFunction(valueCtor), null);\n-    }\n-\n-    static <U> BundlerParamInfo<U> createBundlerParam(Class<? super U> valueType,\n-            ThrowingFunction<Map<String, ? super Object>, U> valueCtor) {\n-        return createBundlerParam(valueType.getName(), valueType, valueCtor);\n-    }\n-\n-    static boolean toBoolean(String value, Map<String, ? super Object> params) {\n-        if (value == null || \"null\".equalsIgnoreCase(value)) {\n-            return false;\n-        } else {\n-            return Boolean.valueOf(value);\n-        }\n-    }\n-\n-    static Path toPath(String value, Map<String, ? super Object> params) {\n-        return Path.of(value);\n-    }\n-\n-    String getID() {\n-        return id;\n-    }\n-\n-    Class<T> getValueType() {\n-        return valueType;\n-    }\n-\n-    \/**\n-     * Returns true if value was not provided on command line for this parameter.\n-     *\n-     * @param params - params from which value will be fetch\n-     * @return true if value was not provided on command line, false otherwise\n-     *\/\n-    boolean getIsDefaultValue(Map<String, ? super Object> params) {\n-        Object o = params.get(getID());\n-        if (o != null) {\n-            return false; \/\/ We have user provided value\n-        }\n-\n-        if (params.containsKey(getID())) {\n-            return false; \/\/ explicit nulls are allowed for provided value\n-        }\n-\n-        return true;\n-    }\n-\n-    Function<Map<String, ? super Object>, T> getDefaultValueFunction() {\n-        return defaultValueFunction;\n-    }\n-\n-    BiFunction<String, Map<String, ? super Object>, T> getStringConverter() {\n-        return stringConverter;\n-    }\n-\n-    final T fetchFrom(Map<String, ? super Object> params) {\n-        return fetchFrom(params, true);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    final T fetchFrom(Map<String, ? super Object> params,\n-            boolean invokeDefault) {\n-        Object o = params.get(getID());\n-        if (o instanceof String && getStringConverter() != null) {\n-            return getStringConverter().apply((String) o, params);\n-        }\n-\n-        Class<T> klass = getValueType();\n-        if (klass.isInstance(o)) {\n-            return (T) o;\n-        }\n-        if (o != null) {\n-            throw new IllegalArgumentException(\"Param \" + getID()\n-                    + \" should be of type \" + getValueType()\n-                    + \" but is a \" + o.getClass());\n-        }\n-        if (params.containsKey(getID())) {\n-            \/\/ explicit nulls are allowed\n-            return null;\n-        }\n-\n-        if (invokeDefault && (getDefaultValueFunction() != null)) {\n-            T result = getDefaultValueFunction().apply(params);\n-            if (result != null) {\n-                params.put(getID(), result);\n-            }\n-            return result;\n-        }\n-\n-        \/\/ ultimate fallback\n-        return null;\n-    }\n-\n-    Optional<T> findIn(Map<String, ? super Object> params) {\n-        if (params.containsKey(getID())) {\n-            return Optional.of(fetchFrom(params, true));\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    void copyInto(Map<String, ? super Object> params, Consumer<T> consumer) {\n-        findIn(params).ifPresent(consumer);\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BundlerParamInfo.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.ServiceLoader;\n-\n-\/**\n- * Bundlers\n- *\n- * The interface implemented by BasicBundlers\n- *\/\n-public interface Bundlers {\n-\n-    \/**\n-     * This convenience method will call\n-     * {@link #createBundlersInstance(ClassLoader)}\n-     * with the classloader that this Bundlers is loaded from.\n-     *\n-     * @return an instance of Bundlers loaded and configured from\n-     *         the current ClassLoader.\n-     *\/\n-    public static Bundlers createBundlersInstance() {\n-        return createBundlersInstance(Bundlers.class.getClassLoader());\n-    }\n-\n-    \/**\n-     * This convenience method will automatically load a Bundlers instance\n-     * from either META-INF\/services or the default\n-     * {@link BasicBundlers} if none are found in\n-     * the services meta-inf.\n-     *\n-     * After instantiating the bundlers instance it will load the default\n-     * bundlers via {@link #loadDefaultBundlers()} as well as requesting\n-     * the services loader to load any other bundelrs via\n-     * {@link #loadBundlersFromServices(ClassLoader)}.\n-\n-     *\n-     * @param servicesClassLoader the classloader to search for\n-     *                            META-INF\/service registered bundlers\n-     * @return an instance of Bundlers loaded and configured from\n-     *         the specified ClassLoader\n-     *\/\n-    public static Bundlers createBundlersInstance(\n-            ClassLoader servicesClassLoader) {\n-        ServiceLoader<Bundlers> bundlersLoader =\n-                ServiceLoader.load(Bundlers.class, servicesClassLoader);\n-        Bundlers bundlers = null;\n-        Iterator<Bundlers> iter = bundlersLoader.iterator();\n-        if (iter.hasNext()) {\n-            bundlers = iter.next();\n-        }\n-        if (bundlers == null) {\n-            bundlers = new BasicBundlers();\n-        }\n-\n-        bundlers.loadBundlersFromServices(servicesClassLoader);\n-        return bundlers;\n-    }\n-\n-    \/**\n-     * Returns all of the preconfigured, requested, and manually\n-     * configured bundlers loaded with this instance.\n-     *\n-     * @return  a read-only collection of the requested bundlers\n-     *\/\n-    Collection<Bundler> getBundlers();\n-\n-    \/**\n-     * Returns all of the preconfigured, requested, and manually\n-     * configured bundlers loaded with this instance that are of\n-     * a specific BundleType, such as disk images, installers, or\n-     * remote installers.\n-     *\n-     * @return a read-only collection of the requested bundlers\n-     *\/\n-    Collection<Bundler> getBundlers(String type);\n-\n-    \/**\n-     * Loads bundlers from the META-INF\/services directly.\n-     *\n-     * This method is called from the\n-     * {@link #createBundlersInstance(ClassLoader)}\n-     * and {@link #createBundlersInstance()} methods.\n-     *\/\n-    void loadBundlersFromServices(ClassLoader cl);\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Bundlers.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import jdk.internal.util.OperatingSystem;\n-\n-import java.util.ResourceBundle;\n-import java.io.File;\n-import java.text.MessageFormat;\n-\n-\n-\/**\n- * CLIHelp\n- *\n- * Generate and show the command line interface help message(s).\n- *\/\n-public class CLIHelp {\n-\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.HelpResources\");\n-\n-    \/\/ generates --help for jpackage's CLI\n-    public static void showHelp(boolean noArgs) {\n-\n-        if (noArgs) {\n-            Log.info(I18N.getString(\"MSG_Help_no_args\"));\n-        } else {\n-            OperatingSystem platform = OperatingSystem.current();\n-            String types;\n-            String pLaunchOptions;\n-            String pInstallOptions;\n-            String pInstallDir;\n-            String pAppImageDescription;\n-            String pSignSampleUsage;\n-            String pAppContentNote;\n-            switch (platform) {\n-                case MACOS:\n-                    types = \"{\\\"app-image\\\", \\\"dmg\\\", \\\"pkg\\\"}\";\n-                    pLaunchOptions = I18N.getString(\"MSG_Help_mac_launcher\");\n-                    pInstallOptions = I18N.getString(\"MSG_Help_mac_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_mac_linux_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_mac_app_image\");\n-                    pSignSampleUsage\n-                            = I18N.getString(\"MSG_Help_mac_sign_sample_usage\");\n-                    pAppContentNote\n-                            = I18N.getString(\"MSG_Help_mac_app_content_note\");\n-                    break;\n-                case LINUX:\n-                    types = \"{\\\"app-image\\\", \\\"rpm\\\", \\\"deb\\\"}\";\n-                    pLaunchOptions = \"\";\n-                    pInstallOptions = I18N.getString(\"MSG_Help_linux_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_mac_linux_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_default_app_image\");\n-                    pSignSampleUsage = \"\";\n-                    pAppContentNote = \"\";\n-                    break;\n-                case WINDOWS:\n-                    types = \"{\\\"app-image\\\", \\\"exe\\\", \\\"msi\\\"}\";\n-                    pLaunchOptions = I18N.getString(\"MSG_Help_win_launcher\");\n-                    pInstallOptions = I18N.getString(\"MSG_Help_win_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_win_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_default_app_image\");\n-                    pSignSampleUsage = \"\";\n-                    pAppContentNote = \"\";\n-                    break;\n-                default:\n-                    types = \"{\\\"app-image\\\", \\\"exe\\\", \\\"msi\\\", \\\"rpm\\\", \\\"deb\\\", \\\"pkg\\\", \\\"dmg\\\"}\";\n-                    pLaunchOptions = I18N.getString(\"MSG_Help_win_launcher\")\n-                            + I18N.getString(\"MSG_Help_mac_launcher\");\n-                    pInstallOptions = I18N.getString(\"MSG_Help_win_install\")\n-                            + I18N.getString(\"MSG_Help_linux_install\")\n-                            + I18N.getString(\"MSG_Help_mac_install\");\n-                    pInstallDir\n-                            = I18N.getString(\"MSG_Help_default_install_dir\");\n-                    pAppImageDescription\n-                            = I18N.getString(\"MSG_Help_default_app_image\");\n-                    pSignSampleUsage = \"\";\n-                    pAppContentNote = \"\";\n-                    break;\n-            }\n-            Log.info(MessageFormat.format(I18N.getString(\"MSG_Help\"),\n-                    File.pathSeparator, types, pLaunchOptions,\n-                    pInstallOptions, pInstallDir, pAppImageDescription,\n-                    pSignSampleUsage, pAppContentNote));\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CLIHelp.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.Optional;\n+import java.util.Objects;\n@@ -50,1 +50,1 @@\n-        version = app.version();\n+        version = Objects.requireNonNull(app.version());\n@@ -54,0 +54,4 @@\n+        Objects.requireNonNull(appLayout);\n+\n+        Objects.requireNonNull(startupInfo.qualifiedClassName());\n+\n@@ -61,1 +65,1 @@\n-            content.add(Map.entry(\"app.mainmodule\", modularStartupInfo.moduleName()\n+            content.add(Map.entry(\"app.mainmodule\", Objects.requireNonNull(modularStartupInfo.moduleName())\n@@ -70,3 +74,0 @@\n-            }\n-\n-            if (!jarStartupInfo.isJarWithMainClass()) {\n@@ -79,1 +80,1 @@\n-        for (var value : Optional.ofNullable(startupInfo.classPath()).orElseGet(List::of)) {\n+        for (var value : startupInfo.classPath()) {\n@@ -91,1 +92,1 @@\n-        for (var value : Optional.ofNullable(startupInfo.javaOptions()).orElseGet(List::of)) {\n+        for (var value : startupInfo.javaOptions()) {\n@@ -101,1 +102,1 @@\n-        var arguments = Optional.ofNullable(startupInfo.defaultParameters()).orElseGet(List::of);\n+        var arguments = startupInfo.defaultParameters();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CfgFile.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.CliBundlingEnvironment;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+import jdk.jpackage.internal.model.AppImagePackageType;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n+\n+class DefaultBundlingEnvironment implements CliBundlingEnvironment {\n+\n+    DefaultBundlingEnvironment(Builder builder) {\n+        this(Optional.ofNullable(builder.defaultOperationSupplier), builder.bundlers);\n+    }\n+\n+    DefaultBundlingEnvironment(Optional<Supplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier,\n+            Map<BundlingOperationDescriptor, Supplier<Result<Consumer<Options>>>> bundlers) {\n+\n+        this.bundlers = bundlers.entrySet().stream().collect(toMap(Map.Entry::getKey, e -> {\n+            return new CachingSupplier<>(e.getValue());\n+        }));\n+\n+        this.defaultOperationSupplier = Objects.requireNonNull(defaultOperationSupplier).map(CachingSupplier::new);\n+    }\n+\n+\n+    static final class Builder {\n+\n+        Builder defaultOperation(Supplier<Optional<BundlingOperationDescriptor>> v) {\n+            defaultOperationSupplier = v;\n+            return this;\n+        }\n+\n+        Builder defaultOperation(StandardBundlingOperation v) {\n+            return defaultOperation(() -> Optional.of(v.descriptor()));\n+        }\n+\n+        Builder bundler(StandardBundlingOperation op, Supplier<Result<Consumer<Options>>> bundlerSupplier) {\n+            bundlers.put(Objects.requireNonNull(op.descriptor()), Objects.requireNonNull(bundlerSupplier));\n+            return this;\n+        }\n+\n+        <T extends SystemEnvironment> Builder bundler(StandardBundlingOperation op,\n+                Supplier<Result<T>> sysEnvResultSupplier, BiConsumer<Options, T> bundler) {\n+            return bundler(op, createBundlerSupplier(sysEnvResultSupplier, bundler));\n+        }\n+\n+        Builder bundler(StandardBundlingOperation op, Consumer<Options> bundler) {\n+            Objects.requireNonNull(bundler);\n+            return bundler(op, () -> Result.ofValue(bundler));\n+        }\n+\n+        private Supplier<Optional<BundlingOperationDescriptor>> defaultOperationSupplier;\n+        private final Map<BundlingOperationDescriptor, Supplier<Result<Consumer<Options>>>> bundlers = new HashMap<>();\n+    }\n+\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    static <T extends SystemEnvironment> Supplier<Result<Consumer<Options>>> createBundlerSupplier(\n+            Supplier<Result<T>> sysEnvResultSupplier, BiConsumer<Options, T> bundler) {\n+        Objects.requireNonNull(sysEnvResultSupplier);\n+        Objects.requireNonNull(bundler);\n+        return () -> {\n+            return sysEnvResultSupplier.get().map(sysEnv -> {\n+                return options -> {\n+                    bundler.accept(options, sysEnv);\n+                };\n+            });\n+        };\n+    }\n+\n+    static void createApplicationImage(Options options, Application app, PackagingPipeline.Builder pipelineBuilder) {\n+        Objects.requireNonNull(options);\n+        Objects.requireNonNull(app);\n+        Objects.requireNonNull(pipelineBuilder);\n+\n+        final var outputDir = OptionUtils.outputDir(options).resolve(app.appImageDirName());\n+\n+        IOUtils.writableOutputDir(outputDir.getParent());\n+\n+        final var env = new BuildEnvFromOptions()\n+                .predefinedAppImageLayout(app.asApplicationLayout().orElseThrow())\n+                .create(options, app);\n+\n+        Log.verbose(I18N.format(\"message.creating-app-bundle\", outputDir.getFileName(), outputDir.toAbsolutePath().getParent()));\n+\n+        if (Files.exists(outputDir)) {\n+            throw new JPackageException(I18N.format(\"error.root-exists\", outputDir.toAbsolutePath()));\n+        }\n+\n+        pipelineBuilder.excludeDirFromCopying(outputDir.getParent())\n+                .create().execute(BuildEnv.withAppImageDir(env, outputDir), app);\n+    }\n+\n+    static <T extends Package> void createNativePackage(Options options,\n+            Function<Options, T> createPackage,\n+            BiFunction<Options, T, BuildEnv> createBuildEnv,\n+            PackagingPipeline.Builder pipelineBuilder,\n+            Packager.PipelineBuilderMutatorFactory<T> pipelineBuilderMutatorFactory) {\n+\n+        Objects.requireNonNull(pipelineBuilder);\n+        createNativePackage(options, createPackage, createBuildEnv, _ -> pipelineBuilder, pipelineBuilderMutatorFactory);\n+    }\n+\n+    static <T extends Package> void createNativePackage(Options options,\n+            Function<Options, T> createPackage,\n+            BiFunction<Options, T, BuildEnv> createBuildEnv,\n+            Function<T, PackagingPipeline.Builder> createPipelineBuilder,\n+            Packager.PipelineBuilderMutatorFactory<T> pipelineBuilderMutatorFactory) {\n+\n+        Objects.requireNonNull(options);\n+        Objects.requireNonNull(createPackage);\n+        Objects.requireNonNull(createBuildEnv);\n+        Objects.requireNonNull(createPipelineBuilder);\n+        Objects.requireNonNull(pipelineBuilderMutatorFactory);\n+\n+        var pkg = Objects.requireNonNull(createPackage.apply(options));\n+\n+        Packager.<T>build().pkg(pkg)\n+            .outputDir(OptionUtils.outputDir(options))\n+            .env(Objects.requireNonNull(createBuildEnv.apply(options, pkg)))\n+            .pipelineBuilderMutatorFactory(pipelineBuilderMutatorFactory)\n+            .execute(Objects.requireNonNull(createPipelineBuilder.apply(pkg)));\n+    }\n+\n+    @Override\n+    public Optional<BundlingOperationDescriptor> defaultOperation() {\n+        return defaultOperationSupplier.flatMap(Supplier::get);\n+    }\n+\n+    @Override\n+    public void createBundle(BundlingOperationDescriptor op, Options cmdline) {\n+        final var bundler = getBundlerSupplier(op).get().orElseThrow();\n+        Optional<Path> permanentWorkDirectory = Optional.empty();\n+        try (var tempDir = new TempDirectory(cmdline)) {\n+            if (!tempDir.deleteOnClose()) {\n+                permanentWorkDirectory = Optional.of(tempDir.path());\n+            }\n+            bundler.accept(tempDir.options());\n+\n+            var packageType = OptionUtils.bundlingOperation(cmdline).packageType();\n+\n+            Log.verbose(I18N.format(\"message.bundle-created\", I18N.getString(bundleTypeDescription(packageType, op.os()))));\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } finally {\n+            permanentWorkDirectory.ifPresent(workDir -> {\n+                Log.verbose(I18N.format(\"message.debug-working-directory\", workDir.toAbsolutePath()));\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public Collection<? extends Exception> configurationErrors(BundlingOperationDescriptor op) {\n+        return getBundlerSupplier(op).get().errors();\n+    }\n+\n+    private Supplier<Result<Consumer<Options>>> getBundlerSupplier(BundlingOperationDescriptor op) {\n+        return Optional.ofNullable(bundlers.get(op)).orElseThrow(NoSuchElementException::new);\n+    }\n+\n+    private String bundleTypeDescription(PackageType type, OperatingSystem os) {\n+        switch (type) {\n+            case StandardPackageType stdType -> {\n+                switch (stdType) {\n+                    case WIN_MSI -> {\n+                        return \"bundle-type.win-msi\";\n+                    }\n+                    case WIN_EXE -> {\n+                        return \"bundle-type.win-exe\";\n+                    }\n+                    case LINUX_DEB -> {\n+                        return \"bundle-type.linux-deb\";\n+                    }\n+                    case LINUX_RPM -> {\n+                        return \"bundle-type.linux-rpm\";\n+                    }\n+                    case MAC_DMG -> {\n+                        return \"bundle-type.mac-dmg\";\n+                    }\n+                    case MAC_PKG -> {\n+                        return \"bundle-type.mac-pkg\";\n+                    }\n+                    default -> {\n+                        throw new AssertionError();\n+                    }\n+                }\n+            }\n+            case AppImagePackageType appImageType -> {\n+                switch (os) {\n+                    case WINDOWS -> {\n+                        return \"bundle-type.win-app\";\n+                    }\n+                    case LINUX -> {\n+                        return \"bundle-type.linux-app\";\n+                    }\n+                    case MACOS -> {\n+                        return \"bundle-type.mac-app\";\n+                    }\n+                    default -> {\n+                        throw new AssertionError();\n+                    }\n+                }\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+\n+    private static final class CachingSupplier<T> implements Supplier<T> {\n+\n+        CachingSupplier(Supplier<T> getter) {\n+            this.getter = Objects.requireNonNull(getter);\n+        }\n+\n+        @Override\n+        public T get() {\n+            return cachedValue.updateAndGet(v -> {\n+                return Optional.ofNullable(v).orElseGet(getter);\n+            });\n+        }\n+\n+        private final Supplier<T> getter;\n+        private final AtomicReference<T> cachedValue = new AtomicReference<>();\n+    }\n+\n+\n+    private final Map<BundlingOperationDescriptor, Supplier<Result<Consumer<Options>>>> bundlers;\n+    private final Optional<CachingSupplier<Optional<BundlingOperationDescriptor>>> defaultOperationSupplier;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DefaultBundlingEnvironment.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -1,362 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.InvalidPathException;\n-import java.util.Arrays;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-\/**\n- * DeployParams\n- *\n- * This class is generated and used in Arguments.processArguments() as\n- * intermediate step in generating the BundleParams and ultimately the Bundles\n- *\/\n-public class DeployParams {\n-\n-    String targetFormat = null; \/\/ means default type for this platform\n-\n-    \/\/ raw arguments to the bundler\n-    Map<String, ? super Object> bundlerArguments = new LinkedHashMap<>();\n-\n-    static class Template {\n-        Path in;\n-        Path out;\n-\n-        Template(Path in, Path out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-    }\n-\n-    \/\/ we need to expand as in some cases\n-    \/\/ (most notably jpackage)\n-    \/\/ we may get \".\" as filename and assumption is we include\n-    \/\/ everything in the given folder\n-    \/\/ (IOUtils.copyfiles() have recursive behavior)\n-    List<Path> expandFileset(Path root) throws IOException {\n-        List<Path> files = new LinkedList<>();\n-        if (!Files.isSymbolicLink(root)) {\n-            if (Files.isDirectory(root)) {\n-                try (Stream<Path> stream = Files.list(root)) {\n-                    List<Path> children = stream.toList();\n-                    if (children != null && children.size() > 0) {\n-                        children.forEach(f -> {\n-                            try {\n-                                files.addAll(expandFileset(f));\n-                            } catch (IOException ex) {\n-                                throw new RuntimeException(ex);\n-                            }\n-                        });\n-                    } else {\n-                        \/\/ Include empty folders\n-                        files.add(root);\n-                    }\n-                }\n-            } else {\n-                files.add(root);\n-            }\n-        }\n-        return files;\n-    }\n-\n-    static void validateName(String s, boolean forApp)\n-            throws PackagerException {\n-\n-        String exceptionKey = forApp ?\n-            \"ERR_InvalidAppName\" : \"ERR_InvalidSLName\";\n-\n-        if (s == null) {\n-            if (forApp) {\n-                return;\n-            } else {\n-                throw new PackagerException(exceptionKey);\n-            }\n-        }\n-        if (s.length() == 0 || s.charAt(s.length() - 1) == '\\\\') {\n-            throw new PackagerException(exceptionKey, s);\n-        }\n-        try {\n-            \/\/ name must be valid path element for this file system\n-            Path p = Path.of(s);\n-            \/\/ and it must be a single name element in a path\n-            if (p.getNameCount() != 1) {\n-                throw new PackagerException(exceptionKey, s);\n-            }\n-        } catch (InvalidPathException ipe) {\n-            throw new PackagerException(ipe, exceptionKey, s);\n-        }\n-\n-        for (int i = 0; i < s.length(); i++) {\n-            char a = s.charAt(i);\n-            \/\/ We check for ASCII codes first which we accept. If check fails,\n-            \/\/ check if it is acceptable extended ASCII or unicode character.\n-            if (a < ' ' || a > '~') {\n-                \/\/ Accept anything else including special chars like copyright\n-                \/\/ symbols. Note: space will be included by ASCII check above,\n-                \/\/ but other whitespace like tabs or new line will be rejected.\n-                if (Character.isISOControl(a)  ||\n-                        Character.isWhitespace(a)) {\n-                    throw new PackagerException(exceptionKey, s);\n-                }\n-            } else if (a == '\"' || a == '%') {\n-                throw new PackagerException(exceptionKey, s);\n-            }\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void validate() throws PackagerException {\n-        boolean hasModule = (bundlerArguments.get(\n-                Arguments.CLIOptions.MODULE.getId()) != null);\n-        boolean hasAppImage = (bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId()) != null);\n-        boolean hasMain = (bundlerArguments.get(\n-                Arguments.CLIOptions.MAIN_JAR.getId()) != null);\n-        boolean hasRuntimeImage = (bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId()) != null);\n-        boolean hasInput = (bundlerArguments.get(\n-                Arguments.CLIOptions.INPUT.getId()) != null);\n-        boolean hasModulePath = (bundlerArguments.get(\n-                Arguments.CLIOptions.MODULE_PATH.getId()) != null);\n-        boolean hasMacAppStore = (bundlerArguments.get(\n-                Arguments.CLIOptions.MAC_APP_STORE.getId()) != null);\n-        boolean runtimeInstaller = !isTargetAppImage() &&\n-                !hasAppImage && !hasModule && !hasMain && hasRuntimeImage;\n-\n-        if (isTargetAppImage()) {\n-            \/\/ Module application requires --runtime-image or --module-path\n-            if (hasModule) {\n-                if (!hasModulePath && !hasRuntimeImage && !hasAppImage) {\n-                    throw new PackagerException(\"ERR_MissingArgument\",\n-                            \"--runtime-image or --module-path\");\n-                }\n-            } else {\n-                if (!hasInput && !hasAppImage) {\n-                    throw new PackagerException(\"error.no-input-parameter\");\n-                }\n-            }\n-        } else {\n-            if (!runtimeInstaller) {\n-                if (hasModule) {\n-                    if (!hasModulePath && !hasRuntimeImage && !hasAppImage) {\n-                        throw new PackagerException(\"ERR_MissingArgument\",\n-                            \"--runtime-image, --module-path or --app-image\");\n-                    }\n-                } else {\n-                    if (!hasInput && !hasAppImage) {\n-                        throw new PackagerException(\"ERR_MissingArgument\",\n-                                \"--input or --app-image\");\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ if bundling non-modular image, or installer without app-image\n-        \/\/ then we need some resources and a main class\n-        if (!hasModule && !hasAppImage && !runtimeInstaller && !hasMain) {\n-            throw new PackagerException(\"ERR_MissingArgument\", \"--main-jar\");\n-        }\n-\n-        String name = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.NAME.getId());\n-        validateName(name, true);\n-\n-        \/\/ Validate app image if set\n-        String appImage = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId());\n-        if (appImage != null) {\n-            Path appImageDir = Path.of(appImage);\n-            if (!Files.exists(appImageDir)\n-                    || appImageDir.toFile().list() == null\n-                    || appImageDir.toFile().list().length == 0) {\n-                throw new PackagerException(\"ERR_AppImageNotExist\", appImage);\n-            }\n-        }\n-\n-        \/\/ Validate temp dir\n-        String root = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.TEMP_ROOT.getId());\n-        if (root != null && Files.exists(Path.of(root))) {\n-            try (Stream<Path> stream = Files.walk(Path.of(root), 1)) {\n-                Path [] contents = stream.toArray(Path[]::new);\n-                \/\/ contents.length > 1 because Files.walk(path) includes path\n-                if (contents != null && contents.length > 1) {\n-                    throw new PackagerException(\n-                            \"ERR_BuildRootInvalid\", root);\n-                }\n-            } catch (IOException ioe) {\n-                throw new PackagerException(ioe);\n-            }\n-        }\n-\n-        \/\/ Validate resource dir\n-        String resources = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.RESOURCE_DIR.getId());\n-        if (resources != null) {\n-            if (!(Files.exists(Path.of(resources)))) {\n-                throw new PackagerException(\n-                    \"message.resource-dir-does-not-exist\",\n-                    Arguments.CLIOptions.RESOURCE_DIR.getId(), resources);\n-            }\n-        }\n-\n-        \/\/ Validate predefined runtime dir\n-        String runtime = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId());\n-        if (runtime != null) {\n-            if (!(Files.exists(Path.of(runtime)))) {\n-                throw new PackagerException(\n-                    \"message.runtime-image-dir-does-not-exist\",\n-                    Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId(),\n-                    runtime);\n-            }\n-        }\n-\n-\n-        \/\/ Validate license file if set\n-        String license = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.LICENSE_FILE.getId());\n-        if (license != null) {\n-            if (!(Files.exists(Path.of(license)))) {\n-                throw new PackagerException(\"ERR_LicenseFileNotExit\");\n-            }\n-        }\n-\n-        \/\/ Validate icon file if set\n-        String icon = (String)bundlerArguments.get(\n-                Arguments.CLIOptions.ICON.getId());\n-        if (icon != null) {\n-            if (!(Files.exists(Path.of(icon)))) {\n-                throw new PackagerException(\"ERR_IconFileNotExit\",\n-                        Path.of(icon).toAbsolutePath().toString());\n-            }\n-        }\n-\n-\n-        if (hasMacAppStore) {\n-            \/\/ Validate jlink-options if mac-app-store is set\n-            Object jlinkOptions = bundlerArguments.get(\n-                    Arguments.CLIOptions.JLINK_OPTIONS.getId());\n-            if (jlinkOptions instanceof List) {\n-                List<String> options = (List<String>) jlinkOptions;\n-                if (!options.contains(\"--strip-native-commands\")) {\n-                    throw new PackagerException(\n-                            \"ERR_MissingJLinkOptMacAppStore\",\n-                            \"--strip-native-commands\");\n-                }\n-            }\n-        }\n-    }\n-\n-    void setTargetFormat(String t) {\n-        targetFormat = t;\n-    }\n-\n-    String getTargetFormat() {\n-        return targetFormat;\n-    }\n-\n-    boolean isTargetAppImage() {\n-        return (\"app-image\".equals(targetFormat));\n-    }\n-\n-    private static final Set<String> multi_args = new TreeSet<>(Arrays.asList(\n-            StandardBundlerParam.JAVA_OPTIONS.getID(),\n-            StandardBundlerParam.ARGUMENTS.getID(),\n-            StandardBundlerParam.MODULE_PATH.getID(),\n-            StandardBundlerParam.ADD_MODULES.getID(),\n-            StandardBundlerParam.LIMIT_MODULES.getID(),\n-            StandardBundlerParam.FILE_ASSOCIATIONS.getID(),\n-            StandardBundlerParam.DMG_CONTENT.getID(),\n-            StandardBundlerParam.APP_CONTENT.getID(),\n-            StandardBundlerParam.JLINK_OPTIONS.getID()\n-    ));\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public void addBundleArgument(String key, Object value) {\n-        \/\/ special hack for multi-line arguments\n-        if (multi_args.contains(key)) {\n-            Object existingValue = bundlerArguments.get(key);\n-            if (existingValue instanceof String && value instanceof String) {\n-                String delim = \"\\n\\n\";\n-                if (key.equals(StandardBundlerParam.MODULE_PATH.getID())) {\n-                    delim = File.pathSeparator;\n-                } else if (\n-                        key.equals(StandardBundlerParam.DMG_CONTENT.getID()) ||\n-                        key.equals(StandardBundlerParam.APP_CONTENT.getID()) ||\n-                        key.equals(StandardBundlerParam.ADD_MODULES.getID())) {\n-                    delim = \",\";\n-                }\n-                bundlerArguments.put(key, existingValue + delim + value);\n-            } else if (existingValue instanceof List && value instanceof List) {\n-                ((List)existingValue).addAll((List)value);\n-            } else if (existingValue instanceof Map &&\n-                value instanceof String && ((String)value).contains(\"=\")) {\n-                String[] mapValues = ((String)value).split(\"=\", 2);\n-                ((Map)existingValue).put(mapValues[0], mapValues[1]);\n-            } else {\n-                bundlerArguments.put(key, value);\n-            }\n-        } else {\n-            bundlerArguments.put(key, value);\n-        }\n-    }\n-\n-    BundleParams getBundleParams() {\n-        BundleParams bundleParams = new BundleParams();\n-\n-        \/\/ check for collisions\n-        TreeSet<String> keys = new TreeSet<>(bundlerArguments.keySet());\n-        keys.retainAll(bundleParams.getBundleParamsAsMap().keySet());\n-\n-        if (!keys.isEmpty()) {\n-            throw new RuntimeException(\"Deploy Params and Bundler Arguments \"\n-                    + \"overlap in the following values:\" + keys.toString());\n-        }\n-\n-        bundleParams.addAllBundleParams(bundlerArguments);\n-\n-        return bundleParams;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"DeployParams {\" + \"output: \" + \"}\";\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":0,"deletions":362,"binary":false,"changes":362,"status":"deleted"},{"patch":"@@ -114,0 +114,4 @@\n+        Optional<String> description() {\n+            return Optional.ofNullable(description);\n+        }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FileAssociationGroup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.ApplicationBuilder.normalizeIcons;\n+import static jdk.jpackage.internal.JLinkRuntimeBuilder.ensureBaseModuleInModulePath;\n+import static jdk.jpackage.internal.OptionUtils.isRuntimeInstaller;\n+import static jdk.jpackage.internal.cli.StandardOption.ABOUT_URL;\n+import static jdk.jpackage.internal.cli.StandardOption.ADDITIONAL_LAUNCHERS;\n+import static jdk.jpackage.internal.cli.StandardOption.ADD_MODULES;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_CONTENT;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.COPYRIGHT;\n+import static jdk.jpackage.internal.cli.StandardOption.DESCRIPTION;\n+import static jdk.jpackage.internal.cli.StandardOption.INPUT;\n+import static jdk.jpackage.internal.cli.StandardOption.INSTALL_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.JLINK_OPTIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.LICENSE_FILE;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE_PATH;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.RESOURCE_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.VENDOR;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfo;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+\n+final class FromOptions {\n+\n+    static ApplicationBuilderBuilder buildApplicationBuilder() {\n+        return new ApplicationBuilderBuilder();\n+    }\n+\n+    static PackageBuilder createPackageBuilder(Options options, Application app, PackageType type) {\n+\n+        final var builder = new PackageBuilder(app, type);\n+\n+        NAME.ifPresentIn(options, builder::name);\n+        DESCRIPTION.ifPresentIn(options, builder::description);\n+        APP_VERSION.ifPresentIn(options, builder::version);\n+        ABOUT_URL.ifPresentIn(options, builder::aboutURL);\n+        LICENSE_FILE.ifPresentIn(options, builder::licenseFile);\n+        PREDEFINED_APP_IMAGE.ifPresentIn(options, builder::predefinedAppImage);\n+        PREDEFINED_RUNTIME_IMAGE.ifPresentIn(options, builder::predefinedAppImage);\n+        INSTALL_DIR.ifPresentIn(options, builder::installDir);\n+\n+        return builder;\n+    }\n+\n+\n+    static final class ApplicationBuilderBuilder {\n+\n+        private ApplicationBuilderBuilder() {\n+        }\n+\n+        <T extends Launcher> ApplicationBuilder create(Options options,\n+                Function<Options, Launcher> launcherCtor,\n+                BiFunction<T, Launcher, T> launcherOverrideCtor,\n+                ApplicationLayout appLayout) {\n+\n+            final Optional<RuntimeLayout> thePredefinedRuntimeLayout;\n+            if (PREDEFINED_RUNTIME_IMAGE.containsIn(options)) {\n+                thePredefinedRuntimeLayout = Optional.ofNullable(\n+                        predefinedRuntimeLayout).or(() -> Optional.of(RuntimeLayout.DEFAULT));\n+            } else {\n+                thePredefinedRuntimeLayout = Optional.empty();\n+            }\n+\n+            final var transfomer = new OptionsTransformer(options, appLayout);\n+            final var appBuilder = createApplicationBuilder(\n+                    transfomer.appOptions(),\n+                    launcherCtor,\n+                    launcherOverrideCtor,\n+                    appLayout,\n+                    Optional.ofNullable(runtimeLayout).orElse(RuntimeLayout.DEFAULT),\n+                    thePredefinedRuntimeLayout);\n+\n+            transfomer.externalApp().ifPresent(appBuilder::externalApplication);\n+\n+            return appBuilder;\n+        }\n+\n+        \/**\n+         * Sets the layout of the predefined runtime image.\n+         * @param v the layout of the predefined runtime image. Null is permitted.\n+         * @return this\n+         *\/\n+        ApplicationBuilderBuilder predefinedRuntimeLayout(RuntimeLayout v) {\n+            predefinedRuntimeLayout = v;\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the layout of a runtime bundle.\n+         * @param v the layout of a runtime bundle. Null is permitted.\n+         * @return this\n+         *\/\n+        ApplicationBuilderBuilder runtimeLayout(RuntimeLayout v) {\n+            runtimeLayout = v;\n+            return this;\n+        }\n+\n+        private RuntimeLayout runtimeLayout;\n+        private RuntimeLayout predefinedRuntimeLayout;\n+    }\n+\n+\n+    private static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Options options,\n+            Function<Options, Launcher> launcherCtor,\n+            BiFunction<T, Launcher, T> launcherOverrideCtor,\n+            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n+            Optional<RuntimeLayout> predefinedRuntimeLayout) {\n+\n+        final var appBuilder = new ApplicationBuilder();\n+\n+        final var isRuntimeInstaller = isRuntimeInstaller(options);\n+\n+        final var predefinedRuntimeImage = PREDEFINED_RUNTIME_IMAGE.findIn(options);\n+\n+        final var predefinedRuntimeDirectory = predefinedRuntimeLayout.flatMap(layout -> {\n+            return predefinedRuntimeImage.map(layout::resolveAt);\n+        }).map(RuntimeLayout::runtimeDirectory);\n+\n+        NAME.findIn(options).or(() -> {\n+            if (isRuntimeInstaller) {\n+                return predefinedRuntimeImage.map(Path::getFileName).map(Path::toString);\n+            } else {\n+                return Optional.empty();\n+            }\n+        }).ifPresent(appBuilder::name);\n+        DESCRIPTION.ifPresentIn(options, appBuilder::description);\n+        APP_VERSION.ifPresentIn(options, appBuilder::version);\n+        VENDOR.ifPresentIn(options, appBuilder::vendor);\n+        COPYRIGHT.ifPresentIn(options, appBuilder::copyright);\n+        INPUT.ifPresentIn(options, appBuilder::srcDir);\n+        APP_CONTENT.ifPresentIn(options, appBuilder::contentDirs);\n+\n+        if (isRuntimeInstaller) {\n+            appBuilder.appImageLayout(runtimeLayout);\n+        } else {\n+            appBuilder.appImageLayout(appLayout);\n+\n+            final var launchers = createLaunchers(options, launcherCtor);\n+\n+            if (PREDEFINED_APP_IMAGE.containsIn(options)) {\n+                appBuilder.launchers(launchers);\n+            } else {\n+                appBuilder.launchers(normalizeIcons(launchers, RESOURCE_DIR.findIn(options), launcherOverrideCtor));\n+\n+                final var runtimeBuilderBuilder = new RuntimeBuilderBuilder();\n+\n+                runtimeBuilderBuilder.modulePath(ensureBaseModuleInModulePath(MODULE_PATH.findIn(options).orElseGet(List::of)));\n+\n+                if (!APP_VERSION.containsIn(options)) {\n+                    \/\/ Version is not specified explicitly. Try to get it from the app's module.\n+                    launchers.mainLauncher().startupInfo().ifPresent(startupInfo -> {\n+                        if (startupInfo instanceof LauncherModularStartupInfo modularStartupInfo) {\n+                            modularStartupInfo.moduleVersion().ifPresent(moduleVersion -> {\n+                                appBuilder.version(moduleVersion);\n+                                Log.verbose(I18N.format(\"message.module-version\",\n+                                        moduleVersion, modularStartupInfo.moduleName()));\n+                            });\n+                        }\n+                    });\n+                }\n+\n+                predefinedRuntimeDirectory.ifPresentOrElse(runtimeBuilderBuilder::forRuntime, () -> {\n+                    final var startupInfos = launchers.asList().stream()\n+                            .map(Launcher::startupInfo)\n+                            .map(Optional::orElseThrow).toList();\n+                    final var jlinkOptionsBuilder = runtimeBuilderBuilder.forNewRuntime(startupInfos);\n+                    ADD_MODULES.findIn(options).map(Set::copyOf).ifPresent(jlinkOptionsBuilder::addModules);\n+                    JLINK_OPTIONS.ifPresentIn(options, jlinkOptionsBuilder::options);\n+                    jlinkOptionsBuilder.apply();\n+                });\n+\n+                appBuilder.runtimeBuilder(runtimeBuilderBuilder.create());\n+            }\n+        }\n+\n+        return appBuilder;\n+    }\n+\n+    private static ApplicationLaunchers createLaunchers(Options options, Function<Options, Launcher> launcherCtor) {\n+        var launchers = ADDITIONAL_LAUNCHERS.getFrom(options);\n+\n+        var mainLauncher = launcherCtor.apply(options);\n+\n+        \/\/\n+        \/\/ Additional launcher should:\n+        \/\/  - Use description from the main launcher by default.\n+        \/\/\n+        var mainLauncherDefaults = Options.of(Map.of(DESCRIPTION, mainLauncher.description()));\n+\n+        var additionalLaunchers = launchers.stream().map(launcherOptions -> {\n+            return launcherOptions.copyWithParent(mainLauncherDefaults);\n+        }).map(launcherCtor).toList();\n+\n+        return new ApplicationLaunchers(mainLauncher, additionalLaunchers);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromOptions.java","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.Arguments.CLIOptions.LINUX_SHORTCUT_HINT;\n-import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_MENU_HINT;\n-import static jdk.jpackage.internal.Arguments.CLIOptions.WIN_SHORTCUT_HINT;\n-import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_MODULES;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_CONTENT;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.COPYRIGHT;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALLER_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.JLINK_OPTIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.LIMIT_MODULES;\n-import static jdk.jpackage.internal.StandardBundlerParam.MODULE_PATH;\n-import static jdk.jpackage.internal.StandardBundlerParam.NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.SOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.hasPredefinedAppImage;\n-import static jdk.jpackage.internal.StandardBundlerParam.isRuntimeInstaller;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.function.BiFunction;\n-import java.util.function.Function;\n-import jdk.jpackage.internal.model.Application;\n-import jdk.jpackage.internal.model.ApplicationLaunchers;\n-import jdk.jpackage.internal.model.ApplicationLayout;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.ExternalApplication;\n-import jdk.jpackage.internal.model.ExternalApplication.LauncherInfo;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.LauncherShortcut;\n-import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n-import jdk.jpackage.internal.model.PackageType;\n-import jdk.jpackage.internal.model.ParseUtils;\n-import jdk.jpackage.internal.model.RuntimeLayout;\n-import jdk.jpackage.internal.util.function.ThrowingFunction;\n-\n-final class FromParams {\n-\n-    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n-            Function<Map<String, ? super Object>, Launcher> launcherMapper,\n-            BiFunction<T, Launcher, T> launcherOverrideCtor,\n-            ApplicationLayout appLayout) throws ConfigException, IOException {\n-        return createApplicationBuilder(params, launcherMapper, launcherOverrideCtor, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n-    }\n-\n-    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n-            Function<Map<String, ? super Object>, Launcher> launcherMapper,\n-            BiFunction<T, Launcher, T> launcherOverrideCtor,\n-            ApplicationLayout appLayout, RuntimeLayout runtimeLayout,\n-            Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n-\n-        final var appBuilder = new ApplicationBuilder();\n-\n-        APP_NAME.copyInto(params, appBuilder::name);\n-        DESCRIPTION.copyInto(params, appBuilder::description);\n-        appBuilder.version(VERSION.fetchFrom(params));\n-        VENDOR.copyInto(params, appBuilder::vendor);\n-        COPYRIGHT.copyInto(params, appBuilder::copyright);\n-        SOURCE_DIR.copyInto(params, appBuilder::srcDir);\n-        APP_CONTENT.copyInto(params, appBuilder::contentDirs);\n-\n-        final var isRuntimeInstaller = isRuntimeInstaller(params);\n-\n-        final var predefinedRuntimeImage = PREDEFINED_RUNTIME_IMAGE.findIn(params);\n-\n-        final var predefinedRuntimeDirectory = predefinedRuntimeLayout.flatMap(\n-                layout -> predefinedRuntimeImage.map(layout::resolveAt)).map(RuntimeLayout::runtimeDirectory);\n-\n-        if (isRuntimeInstaller) {\n-            appBuilder.appImageLayout(runtimeLayout);\n-        } else {\n-            appBuilder.appImageLayout(appLayout);\n-\n-            if (hasPredefinedAppImage(params)) {\n-                final var appImageFile = PREDEFINED_APP_IMAGE_FILE.fetchFrom(params);\n-                appBuilder.initFromExternalApplication(appImageFile, launcherInfo -> {\n-                    var launcherParams = mapLauncherInfo(appImageFile, launcherInfo);\n-                    return launcherMapper.apply(mergeParams(params, launcherParams));\n-                });\n-            } else {\n-                final var launchers = createLaunchers(params, launcherMapper);\n-\n-                final var runtimeBuilderBuilder = new RuntimeBuilderBuilder();\n-\n-                runtimeBuilderBuilder.modulePath(MODULE_PATH.fetchFrom(params));\n-\n-                predefinedRuntimeDirectory.ifPresentOrElse(runtimeBuilderBuilder::forRuntime, () -> {\n-                    final var startupInfos = launchers.asList().stream()\n-                            .map(Launcher::startupInfo)\n-                            .map(Optional::orElseThrow).toList();\n-                    final var jlinkOptionsBuilder = runtimeBuilderBuilder.forNewRuntime(startupInfos);\n-                    ADD_MODULES.copyInto(params, jlinkOptionsBuilder::addModules);\n-                    LIMIT_MODULES.copyInto(params, jlinkOptionsBuilder::limitModules);\n-                    JLINK_OPTIONS.copyInto(params, jlinkOptionsBuilder::options);\n-                    jlinkOptionsBuilder.apply();\n-                });\n-\n-                final var normalizedLaunchers = ApplicationBuilder.normalizeIcons(launchers, RESOURCE_DIR.findIn(params), launcherOverrideCtor);\n-\n-                appBuilder.launchers(normalizedLaunchers).runtimeBuilder(runtimeBuilderBuilder.create());\n-            }\n-        }\n-\n-        return appBuilder;\n-    }\n-\n-    static PackageBuilder createPackageBuilder(\n-            Map<String, ? super Object> params, Application app,\n-            PackageType type) throws ConfigException {\n-\n-        final var builder = new PackageBuilder(app, type);\n-\n-        builder.name(INSTALLER_NAME.fetchFrom(params));\n-        DESCRIPTION.copyInto(params, builder::description);\n-        VERSION.copyInto(params, builder::version);\n-        ABOUT_URL.copyInto(params, builder::aboutURL);\n-        LICENSE_FILE.findIn(params).map(Path::of).ifPresent(builder::licenseFile);\n-        PREDEFINED_APP_IMAGE.findIn(params).ifPresent(builder::predefinedAppImage);\n-        PREDEFINED_RUNTIME_IMAGE.findIn(params).ifPresent(builder::predefinedAppImage);\n-        INSTALL_DIR.findIn(params).map(Path::of).ifPresent(builder::installDir);\n-\n-        return builder;\n-    }\n-\n-    static <T extends Application> BundlerParamInfo<T> createApplicationBundlerParam(\n-            ThrowingFunction<Map<String, ? super Object>, T> ctor) {\n-        return BundlerParamInfo.createBundlerParam(Application.class, ctor);\n-    }\n-\n-    static <T extends jdk.jpackage.internal.model.Package> BundlerParamInfo<T> createPackageBundlerParam(\n-            ThrowingFunction<Map<String, ? super Object>, T> ctor) {\n-        return BundlerParamInfo.createBundlerParam(jdk.jpackage.internal.model.Package.class, ctor);\n-    }\n-\n-    static Optional<jdk.jpackage.internal.model.Package> getCurrentPackage(Map<String, ? super Object> params) {\n-        return Optional.ofNullable((jdk.jpackage.internal.model.Package)params.get(\n-                jdk.jpackage.internal.model.Package.class.getName()));\n-    }\n-\n-    static Optional<LauncherShortcut> findLauncherShortcut(\n-            BundlerParamInfo<String> shortcutParam,\n-            Map<String, ? super Object> mainParams,\n-            Map<String, ? super Object> launcherParams) {\n-\n-        Optional<String> launcherValue;\n-        if (launcherParams == mainParams) {\n-            \/\/ The main launcher\n-            launcherValue = Optional.empty();\n-        } else {\n-            launcherValue = shortcutParam.findIn(launcherParams);\n-        }\n-\n-        return launcherValue.map(ParseUtils::parseLauncherShortcutForAddLauncher).or(() -> {\n-            return Optional.ofNullable(mainParams.get(shortcutParam.getID())).map(toFunction(value -> {\n-                if (value instanceof Boolean) {\n-                    return new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT);\n-                } else {\n-                    try {\n-                        return ParseUtils.parseLauncherShortcutForMainLauncher((String)value);\n-                    } catch (IllegalArgumentException ex) {\n-                        throw I18N.buildConfigException(\"error.invalid-option-value\", value, \"--\" + shortcutParam.getID()).create();\n-                    }\n-                }\n-            }));\n-        });\n-    }\n-\n-    private static ApplicationLaunchers createLaunchers(\n-            Map<String, ? super Object> params,\n-            Function<Map<String, ? super Object>, Launcher> launcherMapper) {\n-        var launchers = ADD_LAUNCHERS.findIn(params).orElseGet(List::of);\n-\n-        var mainLauncher = launcherMapper.apply(params);\n-        var additionalLaunchers = launchers.stream().map(launcherParams -> {\n-            return launcherMapper.apply(mergeParams(params, launcherParams));\n-        }).toList();\n-\n-        return new ApplicationLaunchers(mainLauncher, additionalLaunchers);\n-    }\n-\n-    private static Map<String, ? super Object> mapLauncherInfo(ExternalApplication appImageFile, LauncherInfo launcherInfo) {\n-        Map<String, ? super Object> launcherParams = new HashMap<>();\n-        launcherParams.put(NAME.getID(), launcherInfo.name());\n-        if (!appImageFile.getLauncherName().equals(launcherInfo.name())) {\n-            \/\/ This is not the main launcher, accept the value\n-            \/\/ of \"launcher-as-service\" from the app image file (.jpackage.xml).\n-            launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n-        }\n-        launcherParams.putAll(launcherInfo.extra());\n-        return launcherParams;\n-    }\n-\n-    private static Map<String, ? super Object> mergeParams(Map<String, ? super Object> mainParams,\n-            Map<String, ? super Object> launcherParams) {\n-        if (!launcherParams.containsKey(DESCRIPTION.getID())) {\n-            launcherParams = new HashMap<>(launcherParams);\n-\/\/ FIXME: this is a good improvement but it fails existing tests\n-\/\/            launcherParams.put(DESCRIPTION.getID(), String.format(\"%s (%s)\", DESCRIPTION.fetchFrom(\n-\/\/                    mainParams), APP_NAME.fetchFrom(launcherParams)));\n-            launcherParams.put(DESCRIPTION.getID(), DESCRIPTION.fetchFrom(mainParams));\n-        }\n-        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(),\n-                ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID(), WIN_MENU_HINT.getId(),\n-                WIN_SHORTCUT_HINT.getId(), LINUX_SHORTCUT_HINT.getId());\n-    }\n-\n-    static final BundlerParamInfo<Application> APPLICATION = createApplicationBundlerParam(null);\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -35,1 +35,1 @@\n-import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -93,1 +93,1 @@\n-    static void writableOutputDir(Path outdir) throws PackagerException {\n+    static void writableOutputDir(Path outdir) {\n@@ -98,2 +98,1 @@\n-                throw new PackagerException(\"error.cannot-create-output-dir\",\n-                    outdir.toAbsolutePath().toString());\n+                throw new JPackageException(I18N.format(\"error.cannot-create-output-dir\", outdir.toAbsolutePath()));\n@@ -104,2 +103,1 @@\n-            throw new PackagerException(\"error.cannot-write-to-output-dir\",\n-                    outdir.toAbsolutePath().toString());\n+            throw new JPackageException(I18N.format(\"error.cannot-write-to-output-dir\", outdir.toAbsolutePath()));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.text.MessageFormat;\n@@ -54,1 +53,1 @@\n-import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -57,1 +56,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -67,1 +65,1 @@\n-    public void create(AppImageLayout appImageLayout) throws PackagerException {\n+    public void create(AppImageLayout appImageLayout) {\n@@ -82,1 +80,1 @@\n-            throw new PackagerException(\"error.jlink.failed\", jlinkOut);\n+            throw new JPackageException(I18N.format(\"error.jlink.failed\", jlinkOut));\n@@ -99,1 +97,1 @@\n-            Set<String> limitModules, List<String> options, List<LauncherStartupInfo> startupInfos) throws ConfigException {\n+            Set<String> limitModules, List<String> options, List<LauncherStartupInfo> startupInfos) {\n@@ -151,1 +149,1 @@\n-            Set<String> limitModules, List<String> options, List<LauncherStartupInfo> startupInfos) throws ConfigException {\n+            Set<String> limitModules, List<String> options, List<LauncherStartupInfo> startupInfos) {\n@@ -185,2 +183,1 @@\n-                    throw new ConfigException(MessageFormat.format(I18N.getString(\n-                            \"error.blocked.option\"), option), null);\n+                    throw I18N.buildConfigException(\"error.blocked.option\", option).create();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.PrintWriter;\n-import java.util.Optional;\n-import java.util.spi.ToolProvider;\n-\n-\/**\n- * JPackageToolProvider\n- *\n- * This is the ToolProvider implementation exported\n- * to java.util.spi.ToolProvider and ultimately javax.tools.ToolProvider\n- *\/\n-public class JPackageToolProvider implements ToolProvider {\n-\n-    public String name() {\n-        return \"jpackage\";\n-    }\n-\n-    public Optional<String> description() {\n-        return Optional.of(jdk.jpackage.main.Main.I18N.getString(\"jpackage.description\"));\n-    }\n-\n-    public synchronized int run(\n-            PrintWriter out, PrintWriter err, String... args) {\n-        try {\n-            return new jdk.jpackage.main.Main().execute(out, err, args);\n-        } catch (RuntimeException re) {\n-            Log.fatalError(re.getMessage());\n-            Log.verbose(re);\n-            return 1;\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JPackageToolProvider.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -28,1 +28,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -37,1 +36,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -39,1 +37,0 @@\n-import jdk.jpackage.internal.model.DefaultLauncherIcon;\n@@ -43,1 +40,0 @@\n-import jdk.jpackage.internal.util.PathUtils;\n@@ -46,1 +42,1 @@\n-import jdk.jpackage.internal.model.ResourceDirLauncherIcon;\n+import jdk.jpackage.internal.util.PathUtils;\n@@ -50,1 +46,1 @@\n-    Launcher create() throws ConfigException {\n+    Launcher create() {\n@@ -53,1 +49,1 @@\n-                .ifPresent(toConsumer(LauncherBuilder::validateIcon));\n+                .ifPresent(LauncherBuilder::validateIcon);\n@@ -126,1 +122,1 @@\n-    static void validateIcon(Path icon) throws ConfigException {\n+    static Path validateIcon(Path icon) {\n@@ -147,0 +143,2 @@\n+\n+        return icon;\n@@ -153,1 +151,1 @@\n-            List<FileAssociationGroup> groups, FileAssociationTraits faTraits) throws ConfigException {\n+            List<FileAssociationGroup> groups, FileAssociationTraits faTraits) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherBuilder.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,307 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import jdk.jpackage.internal.model.ConfigException;\n-import java.io.File;\n-import java.io.IOException;\n-import java.lang.module.ModuleReference;\n-import java.nio.file.Files;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.jar.Attributes;\n-import java.util.jar.JarFile;\n-import java.util.jar.Manifest;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-\n-\/**\n- * Extracts data needed to run application from parameters.\n- *\/\n-final class LauncherData {\n-    boolean isModular() {\n-        return moduleInfo != null;\n-    }\n-\n-    String qualifiedClassName() {\n-        return qualifiedClassName;\n-    }\n-\n-    boolean isClassNameFromMainJar() {\n-        return jarMainClass != null;\n-    }\n-\n-    String packageName() {\n-        int sepIdx = qualifiedClassName.lastIndexOf('.');\n-        if (sepIdx < 0) {\n-            return \"\";\n-        }\n-        return qualifiedClassName.substring(sepIdx + 1);\n-    }\n-\n-    String moduleName() {\n-        verifyIsModular(true);\n-        return moduleInfo.name();\n-    }\n-\n-    List<Path> modulePath() {\n-        verifyIsModular(true);\n-        return modulePath;\n-    }\n-\n-    Path mainJarName() {\n-        verifyIsModular(false);\n-        return mainJarName;\n-    }\n-\n-    List<Path> classPath() {\n-        return classPath;\n-    }\n-\n-    String getAppVersion() {\n-        if (isModular()) {\n-            return moduleInfo.version().orElse(null);\n-        }\n-\n-        return null;\n-    }\n-\n-    private LauncherData() {\n-    }\n-\n-    private void verifyIsModular(boolean isModular) {\n-        if ((moduleInfo == null) == isModular) {\n-            throw new IllegalStateException();\n-        }\n-    }\n-\n-    static LauncherData create(Map<String, ? super Object> params) throws\n-            ConfigException, IOException {\n-\n-        final String mainModule = getMainModule(params);\n-        final LauncherData result;\n-        if (mainModule == null) {\n-            result = createNonModular(params);\n-        } else {\n-            result = createModular(mainModule, params);\n-        }\n-        result.initClasspath(params);\n-        return result;\n-    }\n-\n-    private static LauncherData createModular(String mainModule,\n-            Map<String, ? super Object> params) throws ConfigException,\n-            IOException {\n-\n-        LauncherData launcherData = new LauncherData();\n-\n-        final int sepIdx = mainModule.indexOf(\"\/\");\n-        final String moduleName;\n-        if (sepIdx > 0) {\n-            launcherData.qualifiedClassName = mainModule.substring(sepIdx + 1);\n-            moduleName = mainModule.substring(0, sepIdx);\n-        } else {\n-            moduleName = mainModule;\n-        }\n-        launcherData.modulePath = getModulePath(params);\n-\n-        \/\/ Try to find module in the specified module path list.\n-        ModuleReference moduleRef = JLinkRuntimeBuilder.createModuleFinder(\n-                launcherData.modulePath).find(moduleName).orElse(null);\n-\n-        if (moduleRef != null) {\n-            launcherData.moduleInfo = ModuleInfo.fromModuleReference(moduleRef);\n-        } else if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {\n-            \/\/ Failed to find module in the specified module path list and\n-            \/\/ there is external runtime given to jpackage.\n-            \/\/ Lookup module in this runtime.\n-            Path cookedRuntime = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-            launcherData.moduleInfo = ModuleInfo.fromCookedRuntime(moduleName,\n-                    cookedRuntime).orElse(null);\n-        }\n-\n-        if (launcherData.moduleInfo == null) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.no-module-in-path\"), moduleName), null);\n-        }\n-\n-        if (launcherData.qualifiedClassName == null) {\n-            launcherData.qualifiedClassName = launcherData.moduleInfo.mainClass().orElse(null);\n-            if (launcherData.qualifiedClassName == null) {\n-                throw new ConfigException(I18N.getString(\"ERR_NoMainClass\"), null);\n-            }\n-        }\n-\n-        return launcherData;\n-    }\n-\n-    private static LauncherData createNonModular(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-        LauncherData launcherData = new LauncherData();\n-\n-        launcherData.qualifiedClassName = getMainClass(params);\n-\n-        launcherData.mainJarName = getMainJarName(params);\n-\n-        Path mainJarDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);\n-\n-        final Path mainJarPath;\n-        if (launcherData.mainJarName != null && mainJarDir != null) {\n-            mainJarPath = mainJarDir.resolve(launcherData.mainJarName);\n-            if (!Files.exists(mainJarPath)) {\n-                throw new ConfigException(MessageFormat.format(I18N.getString(\n-                        \"error.main-jar-does-not-exist\"),\n-                        launcherData.mainJarName), I18N.getString(\n-                        \"error.main-jar-does-not-exist.advice\"));\n-            }\n-        } else {\n-            mainJarPath = null;\n-        }\n-\n-        if (launcherData.qualifiedClassName == null) {\n-            if (mainJarPath == null) {\n-                throw new ConfigException(I18N.getString(\"error.no-main-class\"),\n-                        I18N.getString(\"error.no-main-class.advice\"));\n-            }\n-\n-            try (JarFile jf = new JarFile(mainJarPath.toFile())) {\n-                Manifest m = jf.getManifest();\n-                Attributes attrs = (m != null) ? m.getMainAttributes() : null;\n-                if (attrs != null) {\n-                    launcherData.qualifiedClassName = attrs.getValue(\n-                            Attributes.Name.MAIN_CLASS);\n-                    launcherData.jarMainClass = launcherData.qualifiedClassName;\n-                }\n-            }\n-        }\n-\n-        if (launcherData.qualifiedClassName == null) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.no-main-class-with-main-jar\"),\n-                    launcherData.mainJarName), MessageFormat.format(\n-                            I18N.getString(\n-                                    \"error.no-main-class-with-main-jar.advice\"),\n-                            launcherData.mainJarName));\n-        }\n-\n-        return launcherData;\n-    }\n-\n-    private void initClasspath(Map<String, ? super Object> params)\n-            throws IOException {\n-        Path inputDir = StandardBundlerParam.SOURCE_DIR.fetchFrom(params);\n-        if (inputDir == null) {\n-            classPath = Collections.emptyList();\n-        } else {\n-            try (Stream<Path> walk = Files.walk(inputDir, Integer.MAX_VALUE)) {\n-                Set<Path> jars = walk.filter(Files::isRegularFile)\n-                        .filter(file -> file.toString().endsWith(\".jar\"))\n-                        .map(p -> inputDir.toAbsolutePath()\n-                                  .relativize(p.toAbsolutePath()))\n-                        .collect(Collectors.toSet());\n-                jars.remove(mainJarName);\n-                classPath = jars.stream().sorted().toList();\n-            }\n-        }\n-    }\n-\n-    private static String getMainClass(Map<String, ? super Object> params) {\n-       return getStringParam(params, Arguments.CLIOptions.APPCLASS.getId());\n-    }\n-\n-    private static Path getMainJarName(Map<String, ? super Object> params)\n-            throws ConfigException {\n-       return getPathParam(params, Arguments.CLIOptions.MAIN_JAR.getId());\n-    }\n-\n-    private static String getMainModule(Map<String, ? super Object> params) {\n-       return getStringParam(params, Arguments.CLIOptions.MODULE.getId());\n-    }\n-\n-    private static String getStringParam(Map<String, ? super Object> params,\n-            String paramName) {\n-        Optional<Object> value = Optional.ofNullable(params.get(paramName));\n-        return value.map(Object::toString).orElse(null);\n-    }\n-\n-    private static <T> T getPathParam(String paramName, Supplier<T> func) throws ConfigException {\n-        try {\n-            return func.get();\n-        } catch (InvalidPathException ex) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.not-path-parameter\"), paramName,\n-                    ex.getLocalizedMessage()), null, ex);\n-        }\n-    }\n-\n-    private static Path getPathParam(Map<String, ? super Object> params,\n-            String paramName) throws ConfigException {\n-        return getPathParam(paramName, () -> {\n-            String value = getStringParam(params, paramName);\n-            Path result = null;\n-            if (value != null) {\n-                result = Path.of(value);\n-            }\n-            return result;\n-        });\n-    }\n-\n-    private static List<Path> getModulePath(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        List<Path> modulePath = getPathListParameter(Arguments.CLIOptions.MODULE_PATH.getId(), params);\n-\n-        if (params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID())) {\n-            Path runtimePath = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-            runtimePath = runtimePath.resolve(\"lib\");\n-            modulePath = Stream.of(modulePath, List.of(runtimePath))\n-                    .flatMap(List::stream)\n-                    .toList();\n-        }\n-\n-        return modulePath;\n-    }\n-\n-    private static List<Path> getPathListParameter(String paramName,\n-            Map<String, ? super Object> params) throws ConfigException {\n-        return getPathParam(paramName, () ->\n-                params.get(paramName) instanceof String value ?\n-                        Stream.of(value.split(File.pathSeparator)).map(Path::of).toList() : List.of());\n-    }\n-\n-    private String qualifiedClassName;\n-    private String jarMainClass;\n-    private Path mainJarName;\n-    private List<Path> classPath;\n-    private List<Path> modulePath;\n-    private ModuleInfo moduleInfo;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherData.java","additions":0,"deletions":307,"binary":false,"changes":307,"status":"deleted"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.APPCLASS;\n+import static jdk.jpackage.internal.cli.StandardOption.ARGUMENTS;\n+import static jdk.jpackage.internal.cli.StandardOption.DESCRIPTION;\n+import static jdk.jpackage.internal.cli.StandardOption.FILE_ASSOCIATIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.INPUT;\n+import static jdk.jpackage.internal.cli.StandardOption.JAVA_OPTIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.cli.StandardOption.MAIN_JAR;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE_PATH;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.stream.IntStream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.FileAssociationGroup.FileAssociationException;\n+import jdk.jpackage.internal.FileAssociationGroup.FileAssociationNoExtensionsException;\n+import jdk.jpackage.internal.FileAssociationGroup.FileAssociationNoMimesException;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardFaOption;\n+import jdk.jpackage.internal.model.CustomLauncherIcon;\n+import jdk.jpackage.internal.model.DefaultLauncherIcon;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherIcon;\n+\n+final class LauncherFromOptions {\n+\n+    LauncherFromOptions() {\n+    }\n+\n+    LauncherFromOptions faGroupBuilderMutator(BiConsumer<FileAssociationGroup.Builder, LauncherBuilder> v) {\n+        faGroupBuilderMutator = v;\n+        return this;\n+    }\n+\n+    LauncherFromOptions faMapper(BiFunction<Options, FileAssociation, FileAssociation> v) {\n+        faMapper = v;\n+        return this;\n+    }\n+\n+    LauncherFromOptions faWithDefaultDescription() {\n+        return faGroupBuilderMutator((faGroupBuilder, launcherBuilder) -> {\n+            if (faGroupBuilder.description().isEmpty()) {\n+                var description = String.format(\"%s association\", launcherBuilder.create().name());\n+                faGroupBuilder.description(description);\n+            }\n+        });\n+    }\n+\n+    Launcher create(Options options) {\n+        final var builder = new LauncherBuilder().defaultIconResourceName(defaultIconResourceName());\n+\n+        DESCRIPTION.ifPresentIn(options, builder::description);\n+        builder.icon(toLauncherIcon(ICON.findIn(options).orElse(null)));\n+        LAUNCHER_AS_SERVICE.ifPresentIn(options, builder::isService);\n+        NAME.ifPresentIn(options, builder::name);\n+\n+        if (PREDEFINED_APP_IMAGE.findIn(options).isEmpty()) {\n+            final var startupInfoBuilder = new LauncherStartupInfoBuilder();\n+\n+            INPUT.ifPresentIn(options, startupInfoBuilder::inputDir);\n+            ARGUMENTS.ifPresentIn(options, startupInfoBuilder::defaultParameters);\n+            JAVA_OPTIONS.ifPresentIn(options, startupInfoBuilder::javaOptions);\n+            MAIN_JAR.ifPresentIn(options, startupInfoBuilder::mainJar);\n+            APPCLASS.ifPresentIn(options, startupInfoBuilder::mainClassName);\n+            MODULE.ifPresentIn(options, startupInfoBuilder::moduleName);\n+            MODULE_PATH.ifPresentIn(options, startupInfoBuilder::modulePath);\n+            PREDEFINED_RUNTIME_IMAGE.ifPresentIn(options, startupInfoBuilder::predefinedRuntimeImage);\n+\n+            builder.startupInfo(startupInfoBuilder.create());\n+        }\n+\n+        final var faOptionsList = FILE_ASSOCIATIONS.findIn(options).orElseGet(List::of);\n+\n+        final var faGroups = IntStream.range(0, faOptionsList.size()).mapToObj(idx -> {\n+            final var faOptions = faOptionsList.get(idx);\n+\n+            final var faGroupBuilder = FileAssociationGroup.build();\n+\n+            StandardFaOption.DESCRIPTION.ifPresentIn(faOptions, faGroupBuilder::description);\n+            StandardFaOption.ICON.ifPresentIn(faOptions, faGroupBuilder::icon);\n+            StandardFaOption.EXTENSIONS.ifPresentIn(faOptions, faGroupBuilder::extensions);\n+            StandardFaOption.CONTENT_TYPE.ifPresentIn(faOptions, faGroupBuilder::mimeTypes);\n+\n+            faGroupBuilderMutator().ifPresent(mutator -> {\n+                mutator.accept(faGroupBuilder, builder);\n+            });\n+\n+            final var faID = idx + 1;\n+\n+            final FileAssociationGroup faGroup;\n+            try {\n+                faGroup = faGroupBuilder.create();\n+            } catch (FileAssociationNoMimesException ex) {\n+                throw I18N.buildConfigException()\n+                        .message(\"error.no-content-types-for-file-association\", faID)\n+                        .advice(\"error.no-content-types-for-file-association.advice\", faID)\n+                        .create();\n+            } catch (FileAssociationNoExtensionsException ex) {\n+                \/\/ TODO: Must do something about this condition!\n+                throw new AssertionError();\n+            } catch (FileAssociationException ex) {\n+                \/\/ Should never happen\n+                throw new UnsupportedOperationException(ex);\n+            }\n+\n+            return faMapper().map(mapper -> {\n+                return new FileAssociationGroup(faGroup.items().stream().map(fa -> {\n+                    return mapper.apply(faOptions, fa);\n+                }).toList());\n+            }).orElse(faGroup);\n+\n+        }).toList();\n+\n+        return builder.faGroups(faGroups).create();\n+    }\n+\n+    private Optional<BiConsumer<FileAssociationGroup.Builder, LauncherBuilder>> faGroupBuilderMutator() {\n+        return Optional.ofNullable(faGroupBuilderMutator);\n+    }\n+\n+    private Optional<BiFunction<Options, FileAssociation, FileAssociation>> faMapper() {\n+        return Optional.ofNullable(faMapper);\n+    }\n+\n+    private static LauncherIcon toLauncherIcon(Path launcherIconPath) {\n+        if (launcherIconPath == null) {\n+            return DefaultLauncherIcon.INSTANCE;\n+        } else if (launcherIconPath.toString().isEmpty()) {\n+            return null;\n+        } else {\n+            return CustomLauncherIcon.create(launcherIconPath);\n+        }\n+    }\n+\n+    private static String defaultIconResourceName() {\n+        switch (OperatingSystem.current()) {\n+            case WINDOWS -> {\n+                return \"JavaApp.ico\";\n+            }\n+            case LINUX -> {\n+                return \"JavaApp.png\";\n+            }\n+            case MACOS -> {\n+                return \"JavaApp.icns\";\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+    private BiConsumer<FileAssociationGroup.Builder, LauncherBuilder> faGroupBuilderMutator;\n+    private BiFunction<Options, FileAssociation, FileAssociation> faMapper;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherFromOptions.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -1,156 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.I18N.buildConfigException;\n-import static jdk.jpackage.internal.StandardBundlerParam.ARGUMENTS;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_CONTENT_TYPE;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_EXTENSIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.JAVA_OPTIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n-\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.function.BiFunction;\n-import java.util.stream.IntStream;\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.CustomLauncherIcon;\n-import jdk.jpackage.internal.model.DefaultLauncherIcon;\n-import jdk.jpackage.internal.model.FileAssociation;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.LauncherIcon;\n-\n-record LauncherFromParams(Optional<BiFunction<FileAssociation, Map<String, ? super Object>, FileAssociation>> faExtension) {\n-\n-    LauncherFromParams {\n-        Objects.requireNonNull(faExtension);\n-    }\n-\n-    LauncherFromParams() {\n-        this(Optional.empty());\n-    }\n-\n-    Launcher create(Map<String, ? super Object> params) throws ConfigException {\n-        final var builder = new LauncherBuilder().defaultIconResourceName(defaultIconResourceName());\n-\n-        DESCRIPTION.copyInto(params, builder::description);\n-        builder.icon(toLauncherIcon(ICON.findIn(params).orElse(null)));\n-        LAUNCHER_AS_SERVICE.copyInto(params, builder::isService);\n-        NAME.copyInto(params, builder::name);\n-\n-        if (PREDEFINED_APP_IMAGE.findIn(params).isEmpty()) {\n-            final var startupInfoBuilder = new LauncherStartupInfoBuilder();\n-\n-            startupInfoBuilder.launcherData(LAUNCHER_DATA.fetchFrom(params));\n-            ARGUMENTS.copyInto(params, startupInfoBuilder::defaultParameters);\n-            JAVA_OPTIONS.copyInto(params, startupInfoBuilder::javaOptions);\n-\n-            builder.startupInfo(startupInfoBuilder.create());\n-        }\n-\n-        final var faParamsList = FILE_ASSOCIATIONS.findIn(params).orElseGet(List::of);\n-\n-        final var faGroups = IntStream.range(0, faParamsList.size()).mapToObj(idx -> {\n-            final var faParams = faParamsList.get(idx);\n-            return toSupplier(() -> {\n-                final var faGroupBuilder = FileAssociationGroup.build();\n-\n-                if (OperatingSystem.current() == OperatingSystem.MACOS) {\n-                    FA_DESCRIPTION.copyInto(faParams, faGroupBuilder::description);\n-                } else {\n-                    faGroupBuilder.description(FA_DESCRIPTION.findIn(faParams).orElseGet(() -> {\n-                        return String.format(\"%s association\", toSupplier(builder::create).get().name());\n-                    }));\n-                }\n-\n-                FA_ICON.copyInto(faParams, faGroupBuilder::icon);\n-                FA_EXTENSIONS.copyInto(faParams, faGroupBuilder::extensions);\n-                FA_CONTENT_TYPE.copyInto(faParams, faGroupBuilder::mimeTypes);\n-\n-                final var faID = idx + 1;\n-\n-                final FileAssociationGroup faGroup;\n-                try {\n-                    faGroup = faGroupBuilder.create();\n-                } catch (FileAssociationGroup.FileAssociationNoMimesException ex) {\n-                    throw buildConfigException()\n-                            .message(\"error.no-content-types-for-file-association\", faID)\n-                            .advice(\"error.no-content-types-for-file-association.advice\", faID)\n-                            .create();\n-                }\n-\n-                if (faExtension.isPresent()) {\n-                    return new FileAssociationGroup(faGroup.items().stream().map(fa -> {\n-                        return faExtension.get().apply(fa, faParams);\n-                    }).toList());\n-                } else {\n-                    return faGroup;\n-                }\n-            }).get();\n-        }).toList();\n-\n-        return builder.faGroups(faGroups).create();\n-    }\n-\n-    private static LauncherIcon toLauncherIcon(Path launcherIconPath) {\n-        if (launcherIconPath == null) {\n-            return DefaultLauncherIcon.INSTANCE;\n-        } else if (launcherIconPath.toString().isEmpty()) {\n-            return null;\n-        } else {\n-            return CustomLauncherIcon.create(launcherIconPath);\n-        }\n-    }\n-\n-    private static String defaultIconResourceName() {\n-        switch (OperatingSystem.current()) {\n-            case WINDOWS -> {\n-                return \"JavaApp.ico\";\n-            }\n-            case LINUX -> {\n-                return \"JavaApp.png\";\n-            }\n-            case MACOS -> {\n-                return \"JavaApp.icns\";\n-            }\n-            default -> {\n-                throw new UnsupportedOperationException();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherFromParams.java","additions":0,"deletions":156,"binary":false,"changes":156,"status":"deleted"},{"patch":"@@ -27,0 +27,3 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n@@ -29,1 +32,9 @@\n-import java.util.function.UnaryOperator;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.jar.Attributes;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -34,1 +45,0 @@\n-import jdk.jpackage.internal.model.LauncherStartupInfo.Stub;\n@@ -40,7 +50,4 @@\n-        return decorator.apply(new Stub(qualifiedClassName, javaOptions,\n-                defaultParameters, classPath));\n-    }\n-\n-    LauncherStartupInfoBuilder launcherData(LauncherData launcherData) {\n-        if (launcherData.isModular()) {\n-            decorator = new ModuleStartupInfo(launcherData.moduleName());\n+        if (moduleName != null) {\n+            return createModular();\n+        } else if (mainJar != null) {\n+            return createNonModular();\n@@ -48,2 +55,1 @@\n-            decorator = new JarStartupInfo(launcherData.mainJarName(),\n-                    launcherData.isClassNameFromMainJar());\n+            throw new JPackageException(I18N.format(\"ERR_NoEntryPoint\"));\n@@ -51,2 +57,4 @@\n-        classPath = launcherData.classPath();\n-        qualifiedClassName = launcherData.qualifiedClassName();\n+    }\n+\n+    LauncherStartupInfoBuilder inputDir(Path v) {\n+        inputDir = v;\n@@ -57,0 +65,3 @@\n+        if (v != null) {\n+            v.forEach(Objects::requireNonNull);\n+        }\n@@ -62,0 +73,3 @@\n+        if (v != null) {\n+            v.forEach(Objects::requireNonNull);\n+        }\n@@ -66,1 +80,9 @@\n-    private static record ModuleStartupInfo(String moduleName) implements UnaryOperator<LauncherStartupInfo> {\n+    LauncherStartupInfoBuilder mainJar(Path v) {\n+        mainJar = v;\n+        return this;\n+    }\n+\n+    LauncherStartupInfoBuilder mainClassName(String v) {\n+        mainClassName = v;\n+        return this;\n+    }\n@@ -68,4 +90,18 @@\n-        @Override\n-        public LauncherStartupInfo apply(LauncherStartupInfo base) {\n-            return LauncherModularStartupInfo.create(base,\n-                    new LauncherModularStartupInfoMixin.Stub(moduleName));\n+    LauncherStartupInfoBuilder predefinedRuntimeImage(Path v) {\n+        cookedRuntimePath = v;\n+        return this;\n+    }\n+\n+    LauncherStartupInfoBuilder moduleName(String v) {\n+        if (v == null) {\n+            moduleName = null;\n+        } else {\n+            var slashIdx = v.indexOf('\/');\n+            if (slashIdx < 0) {\n+                moduleName = v;\n+            } else {\n+                moduleName = v.substring(0, slashIdx);\n+                if (slashIdx < v.length() - 1) {\n+                    mainClassName(v.substring(slashIdx + 1));\n+                }\n+            }\n@@ -73,0 +109,1 @@\n+        return this;\n@@ -75,3 +112,4 @@\n-    private static record JarStartupInfo(Path jarPath,\n-            boolean isClassNameFromMainJar) implements\n-            UnaryOperator<LauncherStartupInfo> {\n+    LauncherStartupInfoBuilder modulePath(List<Path> v) {\n+        modulePath = v;\n+        return this;\n+    }\n@@ -79,5 +117,87 @@\n-        @Override\n-        public LauncherStartupInfo apply(LauncherStartupInfo base) {\n-            return LauncherJarStartupInfo.create(base,\n-                    new LauncherJarStartupInfoMixin.Stub(jarPath,\n-                            isClassNameFromMainJar));\n+    private Optional<Path> inputDir() {\n+        return Optional.ofNullable(inputDir);\n+    }\n+\n+    private Optional<String> mainClassName() {\n+        return Optional.ofNullable(mainClassName);\n+    }\n+\n+    private Optional<Path> cookedRuntimePath() {\n+        return Optional.ofNullable(cookedRuntimePath);\n+    }\n+\n+    private LauncherStartupInfo createLauncherStartupInfo(String mainClassName, List<Path> classpath) {\n+        Objects.requireNonNull(mainClassName);\n+        classpath.forEach(Objects::requireNonNull);\n+        return new LauncherStartupInfo.Stub(mainClassName,\n+                Optional.ofNullable(javaOptions).orElseGet(List::of),\n+                Optional.ofNullable(defaultParameters).orElseGet(List::of),\n+                classpath);\n+    }\n+\n+    private static List<Path> createClasspath(Path inputDir, Set<Path> excludes) {\n+        excludes.forEach(Objects::requireNonNull);\n+        try (final var walk = Files.walk(inputDir)) {\n+            return walk.filter(Files::isRegularFile)\n+                    .filter(file -> file.getFileName().toString().endsWith(\".jar\"))\n+                    .map(inputDir::relativize)\n+                    .filter(Predicate.not(excludes::contains))\n+                    .distinct()\n+                    .toList();\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private LauncherModularStartupInfo createModular() {\n+        final var fullModulePath = getFullModulePath();\n+\n+        \/\/ Try to find the module in the specified module path list.\n+        final var moduleInfo = JLinkRuntimeBuilder.createModuleFinder(fullModulePath).find(moduleName)\n+                .map(ModuleInfo::fromModuleReference).or(() -> {\n+                    \/\/ Failed to find the module in the specified module path list.\n+                    return cookedRuntimePath().flatMap(cookedRuntime -> {\n+                        \/\/ Lookup the module in the external runtime.\n+                        return ModuleInfo.fromCookedRuntime(moduleName, cookedRuntime);\n+                    });\n+                }).orElseThrow(() -> {\n+                    return I18N.buildConfigException(\"error.no-module-in-path\", moduleName).create();\n+                });\n+\n+        final var effectiveMainClassName = mainClassName().or(moduleInfo::mainClass).orElseThrow(() -> {\n+            return I18N.buildConfigException(\"ERR_NoMainClass\").create();\n+        });\n+\n+        \/\/ If module is located in the file system, exclude it from the classpath.\n+        final var classpath = inputDir().map(theInputDir -> {\n+            var classpathExcludes = moduleInfo.fileLocation().filter(moduleFile -> {\n+                return moduleFile.startsWith(theInputDir);\n+            }).map(theInputDir::relativize).map(Set::of).orElseGet(Set::of);\n+            return createClasspath(theInputDir, classpathExcludes);\n+        }).orElseGet(List::of);\n+\n+        return LauncherModularStartupInfo.create(\n+                createLauncherStartupInfo(effectiveMainClassName, classpath),\n+                new LauncherModularStartupInfoMixin.Stub(moduleInfo.name(), moduleInfo.version()));\n+    }\n+\n+    private List<Path> getFullModulePath() {\n+        return cookedRuntimePath().map(runtimeImage -> {\n+            return Stream.of(modulePath(), List.of(runtimeImage.resolve(\"lib\"))).flatMap(List::stream).toList();\n+        }).orElse(modulePath());\n+    }\n+\n+    private List<Path> modulePath() {\n+        return Optional.ofNullable(modulePath).orElseGet(List::of);\n+    }\n+\n+    private LauncherJarStartupInfo createNonModular() {\n+        final var theInputDir = inputDir().orElseThrow();\n+\n+        final var mainJarPath = theInputDir.resolve(mainJar);\n+\n+        if (!Files.exists(mainJarPath)) {\n+            throw I18N.buildConfigException()\n+                    .message(\"error.main-jar-does-not-exist\", mainJar)\n+                    .advice(\"error.main-jar-does-not-exist.advice\")\n+                    .create();\n@@ -85,0 +205,19 @@\n+\n+        final var effectiveMainClassName = mainClassName().or(() -> {\n+            try (final var jf = new JarFile(mainJarPath.toFile())) {\n+                return Optional.ofNullable(jf.getManifest()).map(Manifest::getMainAttributes).map(attrs -> {\n+                    return attrs.getValue(Attributes.Name.MAIN_CLASS);\n+                });\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }).orElseThrow(() -> {\n+            return I18N.buildConfigException()\n+                    .message(\"error.no-main-class-with-main-jar\", mainJar)\n+                    .advice(\"error.no-main-class-with-main-jar.advice\", mainJar)\n+                    .create();\n+        });\n+\n+        return LauncherJarStartupInfo.create(\n+                createLauncherStartupInfo(effectiveMainClassName, createClasspath(theInputDir, Set.of(mainJar))),\n+                new LauncherJarStartupInfoMixin.Stub(mainJar, mainClassName().isEmpty()));\n@@ -87,1 +226,10 @@\n-    private String qualifiedClassName;\n+    \/\/ Modular options\n+    private String moduleName;\n+    private List<Path> modulePath;\n+\n+    \/\/ Non-modular options\n+    private Path mainJar;\n+\n+    \/\/ Common options\n+    private Path inputDir;\n+    private String mainClassName;\n@@ -90,2 +238,1 @@\n-    private List<Path> classPath;\n-    private UnaryOperator<LauncherStartupInfo> decorator;\n+    private Path cookedRuntimePath;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherStartupInfoBuilder.java","additions":176,"deletions":29,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.BUNDLING_OPERATION_DESCRIPTOR;\n+import static jdk.jpackage.internal.cli.StandardOption.DEST;\n+import static jdk.jpackage.internal.cli.StandardOption.MAIN_JAR;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardBundlingOperation;\n+\n+final class OptionUtils {\n+\n+    static boolean isRuntimeInstaller(Options options) {\n+        return PREDEFINED_RUNTIME_IMAGE.containsIn(options)\n+                && !PREDEFINED_APP_IMAGE.containsIn(options)\n+                && !MAIN_JAR.containsIn(options)\n+                && !MODULE.containsIn(options);\n+    }\n+\n+    static Path outputDir(Options options) {\n+        return DEST.getFrom(options);\n+    }\n+\n+    static StandardBundlingOperation bundlingOperation(Options options) {\n+        return StandardBundlingOperation.valueOf(BUNDLING_OPERATION_DESCRIPTOR.getFrom(options)).orElseThrow();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OptionUtils.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.ADDITIONAL_LAUNCHERS;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.WithOptionIdentifier;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ExternalApplication;\n+\n+record OptionsTransformer(Options mainOptions, Optional<ExternalApplication> externalApp) {\n+\n+    OptionsTransformer {\n+        Objects.requireNonNull(mainOptions);\n+        Objects.requireNonNull(externalApp);\n+    }\n+\n+    OptionsTransformer(Options mainOptions, ApplicationLayout appLayout) {\n+        this(mainOptions, PREDEFINED_APP_IMAGE.findIn(mainOptions).map(appLayout::resolveAt).map(AppImageFile::load));\n+    }\n+\n+    Options appOptions() {\n+        return externalApp.map(ea -> {\n+            var overrideOptions = Map.<WithOptionIdentifier, Object>of(\n+                    NAME, ea.appName(),\n+                    APP_VERSION, ea.appVersion(),\n+                    ADDITIONAL_LAUNCHERS, ea.addLaunchers().stream().map(li -> {\n+                        return Options.concat(li.extra(), Options.of(Map.of(\n+                                NAME, li.name(),\n+                                \/\/ This should prevent the code building the Launcher instance\n+                                \/\/ from the Options object from trying to create a startup info object.\n+                                PREDEFINED_APP_IMAGE, PREDEFINED_APP_IMAGE.getFrom(mainOptions)\n+                        )));\n+                    }).toList()\n+            );\n+            return Options.concat(\n+                    Options.of(overrideOptions),\n+                    ea.extra(),\n+                    \/\/ Remove icon if any from the application\/launcher options.\n+                    \/\/ If the icon is specified in the main options, it for the installer.\n+                    mainOptions.copyWithout(ICON.id())\n+            );\n+        }).orElse(mainOptions);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OptionsTransformer.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -47,1 +46,1 @@\n-    Package create() throws ConfigException {\n+    Package create() {\n@@ -211,2 +210,1 @@\n-    private static Path mapInstallDir(Path installDir, PackageType pkgType)\n-            throws ConfigException {\n+    private static Path mapInstallDir(Path installDir, PackageType pkgType) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageBuilder.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -72,1 +71,1 @@\n-    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n+    Path execute(PackagingPipeline.Builder pipelineBuilder) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Packager.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -65,1 +64,1 @@\n-    void execute(BuildEnv env, Application app) throws PackagerException {\n+    void execute(BuildEnv env, Application app) {\n@@ -84,1 +83,1 @@\n-    void execute(BuildEnv env, Package pkg, Path outputDir) throws PackagerException {\n+    void execute(BuildEnv env, Package pkg, Path outputDir) {\n@@ -94,1 +93,1 @@\n-    void execute(StartupParameters startupParameters) throws PackagerException {\n+    void execute(StartupParameters startupParameters) {\n@@ -135,1 +134,1 @@\n-        void execute(TaskAction taskAction) throws IOException, PackagerException;\n+        void execute(TaskAction taskAction) throws IOException;\n@@ -164,1 +163,1 @@\n-        void execute(AppImageBuildEnv<T, U> env) throws IOException, PackagerException;\n+        void execute(AppImageBuildEnv<T, U> env) throws IOException;\n@@ -169,1 +168,1 @@\n-        void execute(AppImageBuildEnv<T, U> env) throws IOException, PackagerException;\n+        void execute(AppImageBuildEnv<T, U> env) throws IOException;\n@@ -174,1 +173,1 @@\n-        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException, PackagerException;\n+        void execute(T pkg, AppImageLayout srcAppImage, AppImageLayout dstAppImage) throws IOException;\n@@ -179,1 +178,1 @@\n-        void execute(PackageBuildEnv<T, U> env) throws IOException, PackagerException;\n+        void execute(PackageBuildEnv<T, U> env) throws IOException;\n@@ -184,1 +183,1 @@\n-        void execute() throws IOException, PackagerException;\n+        void execute() throws IOException;\n@@ -496,1 +495,1 @@\n-    private void execute(TaskContext context) throws PackagerException {\n+    private void execute(TaskContext context) {\n@@ -511,6 +510,0 @@\n-        } catch (ExceptionBox ex) {\n-            throw new PackagerException(ex.getCause());\n-        } catch (RuntimeException ex) {\n-            throw ex;\n-        } catch (PackagerException ex) {\n-            throw ex;\n@@ -518,1 +511,1 @@\n-            throw new PackagerException(ex);\n+            throw ExceptionBox.rethrowUnchecked(ex);\n@@ -549,1 +542,1 @@\n-        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+        public void execute(TaskAction taskAction) throws IOException {\n@@ -603,1 +596,1 @@\n-        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+        public void execute(TaskAction taskAction) throws IOException {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -41,1 +40,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -115,2 +113,1 @@\n-    private static RuntimeBuilder createCopyingRuntimeBuilder(Path runtimeDir,\n-            Path... modulePath) throws ConfigException {\n+    private static RuntimeBuilder createCopyingRuntimeBuilder(Path runtimeDir, Path... modulePath) {\n@@ -150,1 +147,1 @@\n-            return toSupplier(() -> createCopyingRuntimeBuilder(\n+            return createCopyingRuntimeBuilder(\n@@ -152,2 +149,1 @@\n-                    Optional.ofNullable(thiz.modulePath).orElseGet(List::of).toArray(Path[]::new))\n-            ).get();\n+                    Optional.ofNullable(thiz.modulePath).orElseGet(List::of).toArray(Path[]::new));\n@@ -163,1 +159,1 @@\n-            return toSupplier(() -> JLinkRuntimeBuilder.createJLinkRuntimeBuilder(\n+            return JLinkRuntimeBuilder.createJLinkRuntimeBuilder(\n@@ -168,2 +164,1 @@\n-                    startupInfos)\n-            ).get();\n+                    startupInfos);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/RuntimeBuilderBuilder.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,513 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.ExternalApplication;\n-import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n-\n-\/**\n- * Standard bundler parameters.\n- *\n- * Contains static definitions of all of the common bundler parameters.\n- * (additional platform specific and mode specific bundler parameters\n- * are defined in each of the specific bundlers)\n- *\n- * Also contains static methods that operate on maps of parameters.\n- *\/\n-final class StandardBundlerParam {\n-\n-    private static final String DEFAULT_VERSION = \"1.0\";\n-    private static final String DEFAULT_RELEASE = \"1\";\n-    private static final String[] DEFAULT_JLINK_OPTIONS = {\n-            \"--strip-native-commands\",\n-            \"--strip-debug\",\n-            \"--no-man-pages\",\n-            \"--no-header-files\"};\n-\n-    static final BundlerParamInfo<LauncherData> LAUNCHER_DATA = BundlerParamInfo.createBundlerParam(\n-            LauncherData.class, LauncherData::create);\n-\n-    static final BundlerParamInfo<Path> SOURCE_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.INPUT.getId(),\n-                    Path.class,\n-                    p -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    static final BundlerParamInfo<Path> OUTPUT_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.OUTPUT.getId(),\n-                    Path.class,\n-                    p -> Path.of(\"\").toAbsolutePath(),\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    \/\/ note that each bundler is likely to replace this one with\n-    \/\/ their own converter\n-    static final BundlerParamInfo<Path> MAIN_JAR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MAIN_JAR.getId(),\n-                    Path.class,\n-                    params -> LAUNCHER_DATA.fetchFrom(params).mainJarName(),\n-                    null\n-            );\n-\n-    static final BundlerParamInfo<Path> PREDEFINED_APP_IMAGE =\n-            new BundlerParamInfo<>(\n-            Arguments.CLIOptions.PREDEFINED_APP_IMAGE.getId(),\n-            Path.class,\n-            params -> null,\n-            (s, p) -> Path.of(s));\n-\n-    static final BundlerParamInfo<ExternalApplication> PREDEFINED_APP_IMAGE_FILE = BundlerParamInfo.createBundlerParam(\n-            ExternalApplication.class, params -> {\n-                if (hasPredefinedAppImage(params)) {\n-                    var appImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-                    return AppImageFile.load(appImage, PLATFORM_APPLICATION_LAYOUT);\n-                } else {\n-                    return null;\n-                }\n-            });\n-\n-    static final BundlerParamInfo<String> MAIN_CLASS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.APPCLASS.getId(),\n-                    String.class,\n-                    params -> {\n-                        if (isRuntimeInstaller(params)) {\n-                            return null;\n-                        } else if (hasPredefinedAppImage(params)) {\n-                            PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass();\n-                        }\n-                        return LAUNCHER_DATA.fetchFrom(params).qualifiedClassName();\n-                    },\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> PREDEFINED_RUNTIME_IMAGE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId(),\n-                    Path.class,\n-                    params -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    \/\/ this is the raw --app-name arg - used in APP_NAME and INSTALLER_NAME\n-    static final BundlerParamInfo<String> NAME =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.NAME.getId(),\n-                    String.class,\n-                    params -> null,\n-                    (s, p) -> s\n-            );\n-\n-    \/\/ this is the application name, either from the app-image (if given),\n-    \/\/ the name (if given) derived from the main-class, or the runtime image\n-    static final BundlerParamInfo<String> APP_NAME =\n-            new BundlerParamInfo<>(\n-                    \"application-name\",\n-                    String.class,\n-                    params -> {\n-                        String appName = NAME.fetchFrom(params);\n-                        if (hasPredefinedAppImage(params)) {\n-                            appName = PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getLauncherName();\n-                        } else if (appName == null) {\n-                            String s = MAIN_CLASS.fetchFrom(params);\n-                            if (s != null) {\n-                                int idx = s.lastIndexOf(\".\");\n-                                appName = (idx < 0) ? s : s.substring(idx+1);\n-                            } else if (isRuntimeInstaller(params)) {\n-                                Path f = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-                                if (f != null) {\n-                                    appName = f.getFileName().toString();\n-                                }\n-                            }\n-                        }\n-                        return appName;\n-                    },\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> INSTALLER_NAME =\n-            new BundlerParamInfo<>(\n-                    \"installer-name\",\n-                    String.class,\n-                    params -> {\n-                        String installerName = NAME.fetchFrom(params);\n-                        return (installerName != null) ? installerName :\n-                                APP_NAME.fetchFrom(params);\n-                    },\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> ICON =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ICON.getId(),\n-                    Path.class,\n-                    params -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    static final BundlerParamInfo<String> ABOUT_URL =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ABOUT_URL.getId(),\n-                    String.class,\n-                    params -> null,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> VENDOR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.VENDOR.getId(),\n-                    String.class,\n-                    params -> I18N.getString(\"param.vendor.default\"),\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> DESCRIPTION =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.DESCRIPTION.getId(),\n-                    String.class,\n-                    params -> params.containsKey(APP_NAME.getID())\n-                            ? APP_NAME.fetchFrom(params)\n-                            : I18N.getString(\"param.description.default\"),\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> COPYRIGHT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.COPYRIGHT.getId(),\n-                    String.class,\n-                    params -> MessageFormat.format(I18N.getString(\n-                            \"param.copyright.default\"), new Date()),\n-                    (s, p) -> s\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> ARGUMENTS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ARGUMENTS.getId(),\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> Collections.emptyList(),\n-                    (s, p) -> null\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> JAVA_OPTIONS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.JAVA_OPTIONS.getId(),\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> Collections.emptyList(),\n-                    (s, p) -> Arrays.asList(s.split(\"\\n\\n\"))\n-            );\n-\n-    static final BundlerParamInfo<String> VERSION =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.VERSION.getId(),\n-                    String.class,\n-                    StandardBundlerParam::getDefaultAppVersion,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<String> RELEASE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.RELEASE.getId(),\n-                    String.class,\n-                    params -> DEFAULT_RELEASE,\n-                    (s, p) -> s\n-            );\n-\n-    public static final BundlerParamInfo<String> LICENSE_FILE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.LICENSE_FILE.getId(),\n-                    String.class,\n-                    params -> null,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> TEMP_ROOT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.TEMP_ROOT.getId(),\n-                    Path.class,\n-                    params -> {\n-                        try {\n-                            return Files.createTempDirectory(\"jdk.jpackage\");\n-                        } catch (IOException ioe) {\n-                            return null;\n-                        }\n-                    },\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    public static final BundlerParamInfo<Path> CONFIG_ROOT =\n-            new BundlerParamInfo<>(\n-                \"configRoot\",\n-                Path.class,\n-                params -> {\n-                    Path root = TEMP_ROOT.fetchFrom(params).resolve(\"config\");\n-                    try {\n-                        Files.createDirectories(root);\n-                    } catch (IOException ioe) {\n-                        return null;\n-                    }\n-                    return root;\n-                },\n-                (s, p) -> null\n-            );\n-\n-    static final BundlerParamInfo<Boolean> VERBOSE  =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.VERBOSE.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n-    static final BundlerParamInfo<Path> RESOURCE_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.RESOURCE_DIR.getId(),\n-                    Path.class,\n-                    params -> null,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    static final BundlerParamInfo<String> INSTALL_DIR =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.INSTALL_DIR.getId(),\n-                    String.class,\n-                     params -> null,\n-                    (s, p) -> s\n-    );\n-\n-    static final BundlerParamInfo<Boolean> LAUNCHER_AS_SERVICE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.LAUNCHER_AS_SERVICE.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                            true : Boolean.valueOf(s)\n-            );\n-\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Map<String, ? super Object>>> ADD_LAUNCHERS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ADD_LAUNCHER.getId(),\n-                    (Class<List<Map<String, ? super Object>>>) (Object)\n-                            List.class,\n-                    params -> new ArrayList<>(1),\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> null\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo\n-            <List<Map<String, ? super Object>>> FILE_ASSOCIATIONS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.FILE_ASSOCIATIONS.getId(),\n-                    (Class<List<Map<String, ? super Object>>>) (Object)\n-                            List.class,\n-                    params -> new ArrayList<>(1),\n-                    \/\/ valueOf(null) is false, and we actually do want null\n-                    (s, p) -> null\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> FA_EXTENSIONS =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.extension\",\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> null, \/\/ null means not matched to an extension\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> FA_CONTENT_TYPE =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.contentType\",\n-                    (Class<List<String>>) (Object) List.class,\n-                    params -> null,\n-                            \/\/ null means not matched to a content\/mime type\n-                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-            );\n-\n-    static final BundlerParamInfo<String> FA_DESCRIPTION =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.description\",\n-                    String.class,\n-                    p -> null,\n-                    (s, p) -> s\n-            );\n-\n-    static final BundlerParamInfo<Path> FA_ICON =\n-            new BundlerParamInfo<>(\n-                    \"fileAssociation.icon\",\n-                    Path.class,\n-                    ICON::fetchFrom,\n-                    (s, p) -> Path.of(s)\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Path>> DMG_CONTENT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.DMG_CONTENT.getId(),\n-                    (Class<List<Path>>) (Object)List.class,\n-                    p -> Collections.emptyList(),\n-                    (s, p) -> Stream.of(s.split(\",\")).map(Path::of).toList()\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Path>> APP_CONTENT =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.APP_CONTENT.getId(),\n-                    (Class<List<Path>>) (Object)List.class,\n-                    p->Collections.emptyList(),\n-                    (s, p) -> Stream.of(s.split(\",\")).map(Path::of).toList()\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<Path>> MODULE_PATH =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MODULE_PATH.getId(),\n-                    (Class<List<Path>>) (Object)List.class,\n-                    p -> JLinkRuntimeBuilder.ensureBaseModuleInModulePath(List.of()),\n-                    (s, p) -> {\n-                        List<Path> modulePath = Stream.of(s.split(File.pathSeparator))\n-                                .map(Path::of)\n-                                .toList();\n-                        return JLinkRuntimeBuilder.ensureBaseModuleInModulePath(modulePath);\n-                    });\n-\n-    static final BundlerParamInfo<String> MODULE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MODULE.getId(),\n-                    String.class,\n-                    p -> null,\n-                    (s, p) -> {\n-                        return String.valueOf(s);\n-                    });\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<Set<String>> ADD_MODULES =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.ADD_MODULES.getId(),\n-                    (Class<Set<String>>) (Object) Set.class,\n-                    p -> new LinkedHashSet<String>(),\n-                    (s, p) -> new LinkedHashSet<>(Arrays.asList(s.split(\",\")))\n-            );\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<List<String>> JLINK_OPTIONS =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.JLINK_OPTIONS.getId(),\n-                    (Class<List<String>>) (Object) List.class,\n-                    p -> Arrays.asList(DEFAULT_JLINK_OPTIONS),\n-                    (s, p) -> null);\n-\n-    @SuppressWarnings(\"unchecked\")\n-    static final BundlerParamInfo<Set<String>> LIMIT_MODULES =\n-            new BundlerParamInfo<>(\n-                    \"limit-modules\",\n-                    (Class<Set<String>>) (Object) Set.class,\n-                    p -> new LinkedHashSet<String>(),\n-                    (s, p) -> new LinkedHashSet<>(Arrays.asList(s.split(\",\")))\n-            );\n-\n-    static final BundlerParamInfo<Boolean> SIGN_BUNDLE =\n-            new BundlerParamInfo<>(\n-                    Arguments.CLIOptions.MAC_SIGN.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                    null : Boolean.valueOf(s)\n-        );\n-\n-    static boolean isRuntimeInstaller(Map<String, ? super Object> params) {\n-        if (params.containsKey(MODULE.getID()) ||\n-                params.containsKey(MAIN_JAR.getID()) ||\n-                params.containsKey(PREDEFINED_APP_IMAGE.getID())) {\n-            return false; \/\/ we are building or are given an application\n-        }\n-        \/\/ runtime installer requires --runtime-image, if this is false\n-        \/\/ here then we should have thrown error validating args.\n-        return params.containsKey(PREDEFINED_RUNTIME_IMAGE.getID());\n-    }\n-\n-    static boolean hasPredefinedAppImage(Map<String, ? super Object> params) {\n-        return params.containsKey(PREDEFINED_APP_IMAGE.getID());\n-    }\n-\n-    private static String getDefaultAppVersion(Map<String, ? super Object> params) {\n-        String appVersion = DEFAULT_VERSION;\n-\n-        if (isRuntimeInstaller(params)) {\n-            return appVersion;\n-        }\n-\n-        LauncherData launcherData = null;\n-        try {\n-            launcherData = LAUNCHER_DATA.fetchFrom(params);\n-        } catch (RuntimeException ex) {\n-            if (ex.getCause() instanceof ConfigException) {\n-                return appVersion;\n-            }\n-            throw ex;\n-        }\n-\n-        if (launcherData.isModular()) {\n-            String moduleVersion = launcherData.getAppVersion();\n-            if (moduleVersion != null) {\n-                Log.verbose(MessageFormat.format(I18N.getString(\n-                        \"message.module-version\"),\n-                        moduleVersion,\n-                        launcherData.moduleName()));\n-                appVersion = moduleVersion;\n-            }\n-        }\n-\n-        return appVersion;\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":0,"deletions":513,"binary":false,"changes":513,"status":"deleted"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardOption;\n+import jdk.jpackage.internal.util.FileUtils;\n+\n+final class TempDirectory implements Closeable {\n+\n+    TempDirectory(Options options) throws IOException {\n+        final var tempDir = StandardOption.TEMP_ROOT.findIn(options);\n+        if (tempDir.isPresent()) {\n+            this.path = tempDir.orElseThrow();\n+            this.options = options;\n+        } else {\n+            this.path = Files.createTempDirectory(\"jdk.jpackage\");\n+            this.options = options.copyWithDefaultValue(StandardOption.TEMP_ROOT, path);\n+        }\n+\n+        deleteOnClose = tempDir.isEmpty();\n+    }\n+\n+    Options options() {\n+        return options;\n+    }\n+\n+    Path path() {\n+        return path;\n+    }\n+\n+    boolean deleteOnClose() {\n+        return deleteOnClose;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (deleteOnClose) {\n+            FileUtils.deleteRecursive(path);\n+        }\n+    }\n+\n+    private final Path path;\n+    private final Options options;\n+    private final boolean deleteOnClose;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/TempDirectory.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.Arguments.CLIOptions;\n-\n-\/**\n- * ValidOptions\n- *\n- * Two basic methods for validating command line options.\n- *\n- * initArgs()\n- *      Computes the Map of valid options for each mode on this Platform.\n- *\n- * checkIfSupported(CLIOptions arg)\n- *      Determine if the given arg is valid on this platform.\n- *\n- * checkIfImageSupported(CLIOptions arg)\n- *      Determine if the given arg is valid for creating app image.\n- *\n- * checkIfInstallerSupported(CLIOptions arg)\n- *      Determine if the given arg is valid for creating installer.\n- *\n- * checkIfSigningSupported(CLIOptions arg)\n- *      Determine if the given arg is valid for signing app image.\n- *\n- *\/\n-class ValidOptions {\n-\n-    enum USE {\n-        ALL,        \/\/ valid in all cases\n-        LAUNCHER,   \/\/ valid when creating a launcher\n-        INSTALL,    \/\/ valid when creating an installer\n-        SIGN,       \/\/ valid when signing is requested\n-    }\n-\n-    private static final HashMap<String, EnumSet<USE>> options = new HashMap<>();\n-\n-    \/\/ initializing list of mandatory arguments\n-    static {\n-        put(CLIOptions.NAME.getId(), USE.ALL);\n-        put(CLIOptions.VERSION.getId(), USE.ALL);\n-        put(CLIOptions.OUTPUT.getId(), USE.ALL);\n-        put(CLIOptions.TEMP_ROOT.getId(), USE.ALL);\n-        put(CLIOptions.VERBOSE.getId(),\n-                EnumSet.of(USE.ALL, USE.SIGN));\n-        put(CLIOptions.PREDEFINED_RUNTIME_IMAGE.getId(), USE.ALL);\n-        put(CLIOptions.RESOURCE_DIR.getId(), USE.ALL);\n-        put(CLIOptions.DESCRIPTION.getId(), USE.ALL);\n-        put(CLIOptions.VENDOR.getId(), USE.ALL);\n-        put(CLIOptions.COPYRIGHT.getId(), USE.ALL);\n-        put(CLIOptions.PACKAGE_TYPE.getId(),\n-                EnumSet.of(USE.ALL, USE.SIGN));\n-        put(CLIOptions.ICON.getId(), USE.ALL);\n-\n-        put(CLIOptions.INPUT.getId(), USE.LAUNCHER);\n-        put(CLIOptions.MODULE.getId(), USE.LAUNCHER);\n-        put(CLIOptions.MODULE_PATH.getId(), USE.LAUNCHER);\n-        put(CLIOptions.ADD_MODULES.getId(), USE.LAUNCHER);\n-        put(CLIOptions.MAIN_JAR.getId(), USE.LAUNCHER);\n-        put(CLIOptions.APPCLASS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.ARGUMENTS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.JAVA_OPTIONS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.ADD_LAUNCHER.getId(), USE.LAUNCHER);\n-        put(CLIOptions.JLINK_OPTIONS.getId(), USE.LAUNCHER);\n-        put(CLIOptions.APP_CONTENT.getId(), USE.LAUNCHER);\n-\n-        put(CLIOptions.LICENSE_FILE.getId(), USE.INSTALL);\n-        put(CLIOptions.INSTALL_DIR.getId(), USE.INSTALL);\n-        put(CLIOptions.PREDEFINED_APP_IMAGE.getId(),\n-                (OperatingSystem.isMacOS()) ?\n-                        EnumSet.of(USE.INSTALL, USE.SIGN) :\n-                        EnumSet.of(USE.INSTALL));\n-        put(CLIOptions.LAUNCHER_AS_SERVICE.getId(), USE.INSTALL);\n-\n-        put(CLIOptions.ABOUT_URL.getId(), USE.INSTALL);\n-\n-        put(CLIOptions.FILE_ASSOCIATIONS.getId(),\n-            (OperatingSystem.isMacOS()) ? USE.ALL : USE.INSTALL);\n-\n-        if (OperatingSystem.isWindows()) {\n-            put(CLIOptions.WIN_CONSOLE_HINT.getId(), USE.LAUNCHER);\n-\n-            put(CLIOptions.WIN_HELP_URL.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_UPDATE_URL.getId(), USE.INSTALL);\n-\n-            put(CLIOptions.WIN_MENU_HINT.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_MENU_GROUP.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_SHORTCUT_HINT.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_SHORTCUT_PROMPT.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_DIR_CHOOSER.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_UPGRADE_UUID.getId(), USE.INSTALL);\n-            put(CLIOptions.WIN_PER_USER_INSTALLATION.getId(),\n-                    USE.INSTALL);\n-        }\n-\n-        if (OperatingSystem.isMacOS()) {\n-            put(CLIOptions.MAC_SIGN.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_BUNDLE_NAME.getId(), USE.ALL);\n-            put(CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(), USE.ALL);\n-            put(CLIOptions.MAC_BUNDLE_SIGNING_PREFIX.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_SIGNING_KEY_NAME.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId(),\n-                    EnumSet.of(USE.INSTALL, USE.SIGN));\n-            put(CLIOptions.MAC_SIGNING_KEYCHAIN.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.MAC_APP_STORE.getId(), USE.ALL);\n-            put(CLIOptions.MAC_CATEGORY.getId(), USE.ALL);\n-            put(CLIOptions.MAC_ENTITLEMENTS.getId(),\n-                    EnumSet.of(USE.ALL, USE.SIGN));\n-            put(CLIOptions.DMG_CONTENT.getId(), USE.INSTALL);\n-        }\n-\n-        if (OperatingSystem.isLinux()) {\n-            put(CLIOptions.LINUX_BUNDLE_NAME.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_DEB_MAINTAINER.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_CATEGORY.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_RPM_LICENSE_TYPE.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_PACKAGE_DEPENDENCIES.getId(),\n-                    USE.INSTALL);\n-            put(CLIOptions.LINUX_MENU_GROUP.getId(), USE.INSTALL);\n-            put(CLIOptions.RELEASE.getId(), USE.INSTALL);\n-            put(CLIOptions.LINUX_SHORTCUT_HINT.getId(), USE.INSTALL);\n-        }\n-    }\n-\n-    static boolean checkIfSupported(CLIOptions arg) {\n-        return options.containsKey(arg.getId());\n-    }\n-\n-    static boolean checkIfImageSupported(CLIOptions arg) {\n-        EnumSet<USE> value = options.get(arg.getId());\n-        return value.contains(USE.ALL) ||\n-                value.contains(USE.LAUNCHER) ||\n-                value.contains(USE.SIGN);\n-    }\n-\n-    static boolean checkIfInstallerSupported(CLIOptions arg) {\n-        EnumSet<USE> value = options.get(arg.getId());\n-        return value.contains(USE.ALL) || value.contains(USE.INSTALL);\n-    }\n-\n-    static boolean checkIfSigningSupported(CLIOptions arg) {\n-        EnumSet<USE> value = options.get(arg.getId());\n-        return value.contains(USE.SIGN);\n-    }\n-\n-    private static EnumSet<USE> put(String key, USE value) {\n-        return options.put(key, EnumSet.of(value));\n-    }\n-\n-    private static EnumSet<USE> put(String key, EnumSet<USE> value) {\n-        return options.put(key, value);\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ValidOptions.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+\n+\n+record AdditionalLauncher(String name, Path propertyFile) {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/AdditionalLauncher.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * Modifiers for jpackage operations.\n+ *\/\n+enum BundlingOperationModifier implements OptionScope {\n+    \/**\n+     * Create runtime native bundle.\n+     *\/\n+    BUNDLE_RUNTIME,\n+\n+    \/**\n+     * Create native bundle from the predefined app image.\n+     *\/\n+    BUNDLE_PREDEFINED_APP_IMAGE,\n+\n+    ;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/BundlingOperationModifier.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+\n+\/**\n+ * Bundling operation scope.\n+ * <p>\n+ * The scope of bundling operations. E.g., app image or native package bundling.\n+ *\/\n+interface BundlingOperationOptionScope extends OptionScope {\n+    BundlingOperationDescriptor descriptor();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/BundlingOperationOptionScope.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.NoSuchElementException;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+\n+\/**\n+ * CLI bundling environment.\n+ *\/\n+public interface CliBundlingEnvironment extends BundlingEnvironment {\n+\n+    \/**\n+     * Requests to run a bundling operation denoted with the given descriptor with\n+     * the given values of command line options.\n+     *\n+     * @param op      the descriptor of the requested bundling operation\n+     * @param cmdline the validated values of the command line options\n+     * @throws NoSuchElementException if the specified descriptor is not one of the\n+     *                                items in the list returned by\n+     *                                {@link #supportedOperations()} method\n+     *\/\n+    void createBundle(BundlingOperationDescriptor op, Options cmdline);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/CliBundlingEnvironment.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\n+final class DefaultOptions implements Options {\n+\n+    DefaultOptions(Map<? extends WithOptionIdentifier, Object> values) {\n+        this(values, Optional.empty());\n+    }\n+\n+    DefaultOptions(\n+            Map<? extends WithOptionIdentifier, Object> values,\n+            Predicate<OptionName> optionNamesFilter) {\n+\n+        this(values, Optional.of(optionNamesFilter));\n+    }\n+\n+    DefaultOptions(\n+            Map<? extends WithOptionIdentifier, Object> values,\n+            Optional<Predicate<OptionName>> optionNamesFilter) {\n+\n+        map = values.entrySet().stream().collect(toUnmodifiableMap(e -> {\n+            return e.getKey().id();\n+        }, e -> {\n+            return new OptionIdentifierWithValue(e.getKey(), e.getValue());\n+        }));\n+\n+        var optionNamesStream = optionNames(values.keySet().stream());\n+        optionNames = optionNamesFilter.map(optionNamesStream::filter).orElse(optionNamesStream)\n+                .collect(toUnmodifiableSet());\n+    }\n+\n+    private DefaultOptions(Snapshot snapshot) {\n+        map = snapshot.map();\n+        optionNames = snapshot.optionNames();\n+    }\n+\n+    static DefaultOptions create(Snapshot snapshot) {\n+        var options = new DefaultOptions(snapshot);\n+\n+        var mapOptionNames = optionNames(\n+                options.map.values().stream().map(OptionIdentifierWithValue::withId)\n+        ).collect(toUnmodifiableSet());\n+\n+        for (var e : options.map.entrySet()) {\n+            if (e.getKey() != e.getValue().withId().id()) {\n+                throw new IllegalArgumentException(\"Corrupted options map\");\n+            }\n+        }\n+\n+        if (!mapOptionNames.containsAll(snapshot.optionNames())) {\n+            throw new IllegalArgumentException(\"Unexpected option names\");\n+        }\n+        return options;\n+    }\n+\n+    @Override\n+    public Optional<Object> find(OptionIdentifier id) {\n+        return Optional.ofNullable(map.get(Objects.requireNonNull(id))).map(OptionIdentifierWithValue::value);\n+    }\n+\n+    @Override\n+    public boolean contains(OptionName optionName) {\n+        return optionNames.contains(Objects.requireNonNull(optionName));\n+    }\n+\n+    @Override\n+    public Set<? extends OptionIdentifier> ids() {\n+        return Collections.unmodifiableSet(map.keySet());\n+    }\n+\n+    @Override\n+    public DefaultOptions copyWithout(Iterable<? extends OptionIdentifier> ids) {\n+        return copy(StreamSupport.stream(ids.spliterator(), false), false);\n+    }\n+\n+    @Override\n+    public DefaultOptions copyWith(Iterable<? extends OptionIdentifier> ids) {\n+        return copy(StreamSupport.stream(ids.spliterator(), false), true);\n+    }\n+\n+    DefaultOptions add(DefaultOptions other) {\n+        return new DefaultOptions(new Snapshot(Stream.of(this, other).flatMap(v -> {\n+            return v.map.values().stream();\n+        }).collect(toUnmodifiableMap(OptionIdentifierWithValue::id, x -> x, (first, _) -> {\n+            return first;\n+        })), Stream.of(this, other)\n+                .map(DefaultOptions::optionNames)\n+                .flatMap(Collection::stream)\n+                .collect(toUnmodifiableSet())));\n+    }\n+\n+    Set<OptionName> optionNames() {\n+        return optionNames;\n+    }\n+\n+    Set<WithOptionIdentifier> withOptionIdentifierSet() {\n+        return map.values().stream()\n+                .map(OptionIdentifierWithValue::withId)\n+                .collect(toUnmodifiableSet());\n+    }\n+\n+    record Snapshot(Map<OptionIdentifier, OptionIdentifierWithValue> map, Set<OptionName> optionNames) {\n+        Snapshot {\n+            Objects.requireNonNull(map);\n+            Objects.requireNonNull(optionNames);\n+        }\n+    }\n+\n+    record OptionIdentifierWithValue(WithOptionIdentifier withId, Object value) {\n+        OptionIdentifierWithValue {\n+            Objects.requireNonNull(withId);\n+            Objects.requireNonNull(value);\n+        }\n+\n+        OptionIdentifier id() {\n+            return withId.id();\n+        }\n+\n+        OptionIdentifierWithValue copyWithValue(Object value) {\n+            return new OptionIdentifierWithValue(withId, value);\n+        }\n+    }\n+\n+    private DefaultOptions copy(Stream<? extends OptionIdentifier> ids, boolean includes) {\n+        var includeIds = ids.collect(toUnmodifiableSet());\n+        return new DefaultOptions(map.values().stream().filter(v -> {\n+            return includeIds.contains(v.id()) == includes;\n+        }).collect(toUnmodifiableMap(OptionIdentifierWithValue::withId, OptionIdentifierWithValue::value)));\n+    }\n+\n+    private static Stream<OptionName> optionNames(Stream<? extends WithOptionIdentifier> options) {\n+        return options.map(v -> {\n+            Optional<? extends OptionSpec<?>> spec;\n+            switch (v) {\n+                case Option option -> {\n+                    spec = Optional.of(option.spec());\n+                }\n+                case OptionValue<?> optionValue -> {\n+                    spec = optionValue.asOption().map(Option::spec);\n+                }\n+                default -> {\n+                    spec = Optional.empty();\n+                }\n+            }\n+            return spec;\n+        }).filter(Optional::isPresent).map(Optional::get).map(OptionSpec::names).flatMap(Collection::stream);\n+    }\n+\n+    static final DefaultOptions EMPTY = new DefaultOptions(Map.of());\n+\n+    private final Map<OptionIdentifier, OptionIdentifierWithValue> map;\n+    private final Set<OptionName> optionNames;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/DefaultOptions.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\n+\/**\n+ * Generic help formatter.\n+ *\/\n+final class HelpFormatter {\n+\n+    private HelpFormatter(List<OptionGroup> optionGroups, OptionGroupFormatter formatter) {\n+        this.optionGroups = Objects.requireNonNull(optionGroups);\n+        this.formatter = Objects.requireNonNull(formatter);\n+    }\n+\n+    void format(Consumer<CharSequence> sink) {\n+        for (var group : optionGroups) {\n+            formatter.format(group, sink);\n+        }\n+    }\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+\n+    static final class Builder {\n+\n+        private Builder() {\n+        }\n+\n+        HelpFormatter create() {\n+            return new HelpFormatter(groups, validatedGroupFormatter());\n+        }\n+\n+        Builder groups(Collection<OptionGroup> v) {\n+            groups.addAll(v);\n+            return this;\n+        }\n+\n+        Builder groups(OptionGroup... v) {\n+            return groups(List.of(v));\n+        }\n+\n+        Builder groupFormatter(OptionGroupFormatter v) {\n+            groupFormatter = v;\n+            return this;\n+        }\n+\n+        private OptionGroupFormatter validatedGroupFormatter() {\n+            return Optional.ofNullable(groupFormatter).orElseGet(Builder::createConsoleFormatter);\n+        }\n+\n+        private static OptionGroupFormatter createConsoleFormatter() {\n+            return new ConsoleOptionGroupFormatter(new ConsoleOptionFormatter(2, 10));\n+        }\n+\n+        private final List<OptionGroup> groups = new ArrayList<>();\n+        private OptionGroupFormatter groupFormatter;\n+    }\n+\n+\n+    interface OptionFormatter {\n+\n+        public default void format(OptionSpec<?> optionSpec, Consumer<CharSequence> sink) {\n+            format(optionSpec.names().stream().map(OptionName::formatForCommandLine).collect(Collectors.joining(\" \")),\n+                    optionSpec.valuePattern(),\n+                    optionSpec.description(), sink);\n+        }\n+\n+        void format(String optionNames, Optional<String> valuePattern, String description, Consumer<CharSequence> sink);\n+    }\n+\n+    interface OptionGroupFormatter {\n+\n+        default void format(OptionGroup group, Consumer<CharSequence> sink) {\n+            formatHeader(group.name(), sink);\n+            formatBody(group.options(), sink);\n+        }\n+\n+        void formatHeader(String gropName, Consumer<CharSequence> sink);\n+\n+        void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink);\n+    }\n+\n+\n+    record ConsoleOptionFormatter(int nameOffset, int descriptionOffset) implements OptionFormatter {\n+\n+        @Override\n+        public void format(String optionNames, Optional<String> valuePattern, String description, Consumer<CharSequence> sink) {\n+            sink.accept(\" \".repeat(nameOffset));\n+            sink.accept(optionNames);\n+            valuePattern.map(v -> \" \" + v).ifPresent(sink);\n+            eol(sink);\n+            final var descriptionOffsetStr = \" \".repeat(descriptionOffset);\n+            Stream.of(description.split(\"\\\\R\")).map(line -> {\n+                return descriptionOffsetStr + line;\n+            }).forEach(line -> {\n+                sink.accept(line);\n+                eol(sink);\n+            });\n+        }\n+    }\n+\n+\n+    record ConsoleOptionGroupFormatter(OptionFormatter optionFormatter) implements OptionGroupFormatter {\n+\n+        ConsoleOptionGroupFormatter {\n+            Objects.requireNonNull(optionFormatter);\n+        }\n+\n+        @Override\n+        public void formatHeader(String groupName, Consumer<CharSequence> sink) {\n+            Objects.requireNonNull(groupName);\n+            eol(sink);\n+            sink.accept(groupName + \":\");\n+            eol(sink);\n+        }\n+\n+        @Override\n+        public void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink) {\n+            optionSpecs.forEach(optionSpec -> {\n+                optionFormatter.format(optionSpec, sink);\n+            });\n+        }\n+    }\n+\n+\n+    record OptionGroup(String name, List<? extends OptionSpec<?>> options) {\n+\n+        OptionGroup {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(options);\n+        }\n+    }\n+\n+\n+    static Consumer<CharSequence> eol(Consumer<CharSequence> sink) {\n+        sink.accept(System.lineSeparator());\n+        return sink;\n+    }\n+\n+\n+    private final List<OptionGroup> optionGroups;\n+    private final OptionGroupFormatter formatter;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/HelpFormatter.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.List;\n+import java.util.Map;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.util.MultiResourceBundle;\n+import jdk.jpackage.internal.util.StringBundle;\n+\n+final class I18N {\n+\n+    private I18N() {\n+    }\n+\n+    static String format(String key, Object ... args) {\n+        return BUNDLE.format(key, args);\n+    }\n+\n+    private static final StringBundle BUNDLE;\n+\n+    static {\n+        var prefix = \"jdk.jpackage.internal.resources.\";\n+        BUNDLE = StringBundle.fromResourceBundle(MultiResourceBundle.create(\n+                prefix + \"MainResources\",\n+                Map.of(\n+                        OperatingSystem.LINUX, List.of(prefix + \"LinuxResources\"),\n+                        OperatingSystem.MACOS, List.of(prefix + \"MacResources\"),\n+                        OperatingSystem.WINDOWS, List.of(prefix + \"WinResources\")\n+                )\n+        ));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/I18N.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,817 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.internal.joptsimple.ArgumentAcceptingOptionSpec;\n+import jdk.internal.joptsimple.OptionParser;\n+import jdk.internal.joptsimple.OptionSet;\n+import jdk.jpackage.internal.cli.DefaultOptions.OptionIdentifierWithValue;\n+import jdk.jpackage.internal.cli.DefaultOptions.Snapshot;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+import jdk.jpackage.internal.util.Result;\n+\n+\n+\/**\n+ * Builds an instance of {@link Options} interface backed with joptsimple command\n+ * line parser.\n+ *\n+ * Two types of command line argument processing are supported:\n+ * <ol>\n+ * <li>Parse command line. Parsed data is stored as a map of strings.\n+ * <li>Convert strings to objects. Parsed data is stored as a map of objects.\n+ * <\/ol>\n+ *\/\n+final class JOptSimpleOptionsBuilder {\n+\n+    Function<String[], Result<OptionsBuilder>> create() {\n+        return createJOptSimpleParser()::parse;\n+    }\n+\n+    JOptSimpleOptionsBuilder options(Collection<? extends WithOptionIdentifier> v) {\n+        v.stream().map(u -> {\n+            switch (u) {\n+                case Option o -> {\n+                    return o;\n+                }\n+                case OptionValue<?> ov -> {\n+                    return ov.getOption();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }).forEach(options::add);\n+        return this;\n+    }\n+\n+    JOptSimpleOptionsBuilder options(WithOptionIdentifier... v) {\n+        return options(List.of(v));\n+    }\n+\n+    JOptSimpleOptionsBuilder optionSpecMapper(UnaryOperator<OptionSpec<?>> v) {\n+        optionSpecMapper = v;\n+        return this;\n+    }\n+\n+    JOptSimpleOptionsBuilder jOptSimpleParserErrorHandler(Function<JOptSimpleError, ? extends Exception> v) {\n+        jOptSimpleParserErrorHandler = v;\n+        return this;\n+    }\n+\n+    private JOptSimpleParser createJOptSimpleParser() {\n+        return JOptSimpleParser.create(options, Optional.ofNullable(optionSpecMapper),\n+                Optional.ofNullable(jOptSimpleParserErrorHandler));\n+    }\n+\n+\n+    static final class ConvertedOptionsBuilder {\n+\n+        private ConvertedOptionsBuilder(TypedOptions options) {\n+            impl = Objects.requireNonNull(options);\n+        }\n+\n+        Options create() {\n+            return impl;\n+        }\n+\n+        ConvertedOptionsBuilder copyWithExcludes(Collection<? extends OptionIdentifier> v) {\n+            return new ConvertedOptionsBuilder(impl.copyWithout(v));\n+        }\n+\n+        List<String> nonOptionArguments() {\n+            return impl.nonOptionArguments();\n+        }\n+\n+        List<OptionName> detectedOptions() {\n+            return impl.detectedOptions();\n+        }\n+\n+        private final TypedOptions impl;\n+    }\n+\n+\n+    static final class OptionsBuilder {\n+\n+        private OptionsBuilder(UntypedOptions options) {\n+            impl = Objects.requireNonNull(options);\n+        }\n+\n+        Result<ConvertedOptionsBuilder> convertedOptions() {\n+            return impl.toTypedOptions().map(ConvertedOptionsBuilder::new);\n+        }\n+\n+        Options create() {\n+            return impl;\n+        }\n+\n+        OptionsBuilder copyWithExcludes(Collection<? extends OptionIdentifier> v) {\n+            return new OptionsBuilder(impl.copyWithout(v));\n+        }\n+\n+        List<String> nonOptionArguments() {\n+            return impl.nonOptionArguments();\n+        }\n+\n+        List<OptionName> detectedOptions() {\n+            return impl.detectedOptions();\n+        }\n+\n+        private final UntypedOptions impl;\n+    }\n+\n+\n+    enum JOptSimpleErrorType {\n+\n+        \/\/ jdk.internal.joptsimple.UnrecognizedOptionException\n+        UNRECOGNIZED_OPTION(() -> {\n+            new OptionParser(false).parse(\"--foo\");\n+        }),\n+\n+        \/\/ jdk.internal.joptsimple.OptionMissingRequiredArgumentException\n+        OPTION_MISSING_REQUIRED_ARGUMENT(() -> {\n+            var parser = new OptionParser(false);\n+            parser.accepts(\"foo\").withRequiredArg();\n+            parser.parse(\"--foo\");\n+        }),\n+        ;\n+\n+        JOptSimpleErrorType(Runnable initializer) {\n+            try {\n+                initializer.run();\n+                \/\/ Should never get to this point as the above line is expected to throw\n+                \/\/ an exception of type `jdk.internal.joptsimple.OptionException`.\n+                throw new AssertionError();\n+            } catch (jdk.internal.joptsimple.OptionException ex) {\n+                type = ex.getClass();\n+            }\n+        }\n+\n+        private final Class<? extends jdk.internal.joptsimple.OptionException> type;\n+    }\n+\n+\n+    record JOptSimpleError(JOptSimpleErrorType type, OptionName optionName) {\n+\n+        JOptSimpleError {\n+            Objects.requireNonNull(type);\n+            Objects.requireNonNull(optionName);\n+        }\n+\n+        static JOptSimpleError create(jdk.internal.joptsimple.OptionException ex) {\n+            var optionName = OptionName.of(ex.options().getFirst());\n+            return Stream.of(JOptSimpleErrorType.values()).filter(v -> {\n+                return v.type.isInstance(ex);\n+            }).findFirst().map(v -> {\n+                return new JOptSimpleError(v, optionName);\n+            }).orElseThrow();\n+        }\n+    }\n+\n+\n+    private record JOptSimpleParser(\n+            OptionParser parser,\n+            Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap,\n+            Optional<Function<JOptSimpleError, ? extends Exception>> jOptSimpleParserErrorHandler) {\n+\n+        private JOptSimpleParser {\n+            Objects.requireNonNull(parser);\n+            Objects.requireNonNull(optionMap);\n+            Objects.requireNonNull(jOptSimpleParserErrorHandler);\n+        }\n+\n+        Result<OptionsBuilder> parse(String... args) {\n+            return applyParser(parser, args).map(optionSet -> {\n+                final OptionSet mergerOptionSet;\n+                if (optionMap.values().stream().allMatch(spec -> spec.names().size() == 1)) {\n+                    \/\/ No specs with multiple names, merger not needed.\n+                    mergerOptionSet = optionSet;\n+                } else {\n+                    final var parser2 = createOptionParser();\n+                    final var optionSpecApplier = new OptionSpecApplier();\n+                    for (final var spec : optionMap.values()) {\n+                        optionSpecApplier.applyToParser(parser2, spec);\n+                    }\n+\n+                    mergerOptionSet = parser2.parse(args);\n+                }\n+                return new OptionsBuilder(new UntypedOptions(optionSet, mergerOptionSet, optionMap));\n+            });\n+        }\n+\n+        static JOptSimpleParser create(Iterable<Option> options,\n+                Optional<UnaryOperator<OptionSpec<?>>> optionSpecMapper,\n+                Optional<Function<JOptSimpleError, ? extends Exception>> jOptSimpleParserErrorHandler) {\n+            final var parser = createOptionParser();\n+\n+            \/\/ Create joptsimple option specs for distinct option names,\n+            \/\/ i.e., individual joptsimple option spec for every name of jpackage option spec.\n+            \/\/ This is needed to accurately detect what option names were passed.\n+            final var optionSpecApplier = new OptionSpecApplier().generateForEveryName(true);\n+\n+            final var optionStream = StreamSupport.stream(options.spliterator(), false);\n+\n+            final var optionMap = optionSpecMapper.map(mapper -> {\n+                return optionStream.map(option -> {\n+                    return option.copyWithSpec(mapper.apply(option.spec()));\n+                });\n+            }).orElse(optionStream).peek(option -> {\n+                optionSpecApplier.applyToParser(parser, option.spec());\n+            }).collect(toUnmodifiableMap(Option::id, Option::spec));\n+\n+            return new JOptSimpleParser(parser, optionMap, jOptSimpleParserErrorHandler);\n+        }\n+\n+        private Result<OptionSet> applyParser(OptionParser parser, String[] args) {\n+            try {\n+                return Result.ofValue(parser.parse(args));\n+            } catch (jdk.internal.joptsimple.OptionException ex) {\n+                return Result.ofError(jOptSimpleParserErrorHandler.map(handler -> {\n+                    var err = handler.apply(JOptSimpleError.create(ex));\n+                    return Objects.requireNonNull(err);\n+                }).orElse(ex));\n+            }\n+        }\n+\n+        private static OptionParser createOptionParser() {\n+            \/\/ No abbreviations!\n+            \/\/ Otherwise for the configured option \"foo\" it will recognize \"f\" as its abbreviation.\n+            return new OptionParser(false);\n+        }\n+    }\n+\n+\n+    private static final class OptionSpecApplier {\n+\n+        <T> void applyToParser(OptionParser parser, OptionSpec<T> spec) {\n+            final Stream<OptionSpec<T>> optionSpecs;\n+            if (generateForEveryName) {\n+                optionSpecs = spec.copyForEveryName();\n+            } else {\n+                optionSpecs = Stream.of(spec);\n+            }\n+\n+            optionSpecs.forEach(v -> {\n+                final var specBuilder = parser.acceptsAll(v.names().stream().map(OptionName::name).toList());\n+                if (v.hasValue()) {\n+                    if (v.isValueOptional()) {\n+                        specBuilder.withOptionalArg();\n+                    } else {\n+                        specBuilder.withRequiredArg();\n+                    }\n+                }\n+            });\n+        }\n+\n+        OptionSpecApplier generateForEveryName(boolean v) {\n+            generateForEveryName = v;\n+            return this;\n+        }\n+\n+        private boolean generateForEveryName;\n+    }\n+\n+\n+    sealed interface ExtendedOptions<T extends ExtendedOptions<T>> extends Options {\n+\n+        \/**\n+         * Gets the list of command line tokens not linked to any option in the order\n+         * they appear on the command line.\n+         *\n+         * @return Gets the list of command line tokens not linked to any option in the\n+         *         order they appear on the command line\n+         *\/\n+        List<String> nonOptionArguments();\n+\n+        \/**\n+         * Gets the list of names of detected options in the order they appear on the\n+         * command line. A name will appear in the list as many times as the\n+         * corresponding option on the command line.\n+         *\n+         * @return the list of names of detected options in the order they appear on the\n+         *         command line\n+         *\/\n+        List<OptionName> detectedOptions();\n+\n+        DefaultOptions toDefaultOptions();\n+    }\n+\n+\n+    private static final class UntypedOptions implements ExtendedOptions<UntypedOptions> {\n+\n+        UntypedOptions(OptionSet optionSet, OptionSet mergerOptionSet, Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap) {\n+            this.optionSet = Objects.requireNonNull(optionSet);\n+            this.mergerOptionSet = Objects.requireNonNull(mergerOptionSet);\n+            optionNames = optionMap.values().stream()\n+                    .map(OptionSpec::names)\n+                    .flatMap(Collection::stream)\n+                    .filter(optionName -> {\n+                        return optionSet.has(optionName.name());\n+                    }).collect(toUnmodifiableSet());\n+            this.optionMap = optionMap.entrySet().stream().filter(e -> {\n+                return !Collections.disjoint(optionNames, e.getValue().names());\n+            }).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+        }\n+\n+        private UntypedOptions(UntypedOptions other, Collection<? extends OptionIdentifier> excludes) {\n+            this(other.optionSet, other.mergerOptionSet, other.optionMap.entrySet().stream().filter(e -> {\n+                return !excludes.contains(e.getKey());\n+            }).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue)));\n+        }\n+\n+        @Override\n+        public UntypedOptions copyWithout(Iterable<? extends OptionIdentifier> ids) {\n+            return new UntypedOptions(this, StreamSupport.stream(ids.spliterator(), false).toList());\n+        }\n+\n+        @Override\n+        public Set<? extends OptionIdentifier> ids() {\n+            return optionMap.keySet();\n+        }\n+\n+        @Override\n+        public List<String> nonOptionArguments() {\n+            return optionSet.nonOptionArguments().stream().map(String.class::cast).toList();\n+        }\n+\n+        @Override\n+        public List<OptionName> detectedOptions() {\n+            return optionSet.specs().stream().flatMap(joptSpec -> {\n+                return joptSpec.options().stream().map(OptionName::new);\n+            }).filter(optionNames::contains).toList();\n+        }\n+\n+        @Override\n+        public DefaultOptions toDefaultOptions() {\n+            return new DefaultOptions(optionMap.entrySet().stream().collect(toUnmodifiableMap(e -> {\n+                return new Option(e.getKey(), e.getValue());\n+            }, e -> {\n+                return find(e.getKey()).orElseThrow();\n+            })), optionNames::contains);\n+        }\n+\n+        Result<TypedOptions> toTypedOptions() {\n+\n+            final List<Exception> errors = new ArrayList<>();\n+\n+            final var optionNameToOption = optionMap.entrySet().stream().map(e -> {\n+                return e.getValue().names().stream().map(optionName -> {\n+                    return Map.entry(optionName, new Option(e.getKey(), e.getValue()));\n+                });\n+            }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            var entries = OptionSpecWithValue.create(optionSet, mergerOptionSet, optionMap).stream().map(oswv -> {\n+                var option = optionNameToOption.get(oswv.optionName());\n+                if (!oswv.optionSpec().hasValue()) {\n+                    return new OptionIdentifierWithValue(option, Boolean.TRUE);\n+                } else {\n+                    return oswv.convertValue().map(v -> {\n+                        if (oswv.optionSpec().arrayValueConverter().isEmpty()) {\n+                            return new OptionIdentifierWithValue(option, v);\n+                        } else {\n+                            return new OptionIdentifierWithValue(option, new ArrayList<>(List.of(v)));\n+                        }\n+                    }).peekErrors(errors::addAll).value().orElse(null);\n+                }\n+            }).filter(Objects::nonNull).toList();\n+\n+            if (!errors.isEmpty()) {\n+                return Result.ofErrors(errors);\n+            } else {\n+                final Map<OptionIdentifier, OptionIdentifierWithValue> map = new HashMap<>();\n+\n+                for (var e : entries) {\n+                    var option = (Option)e.withId();\n+                    map.merge(option.id(), e, (a, b) -> {\n+                        if (option.spec().arrayValueConverter().isEmpty()) {\n+                            throw new AssertionError();\n+                        } else {\n+                            @SuppressWarnings(\"unchecked\")\n+                            var ar = ((List<Object>)a.value());\n+\n+                            @SuppressWarnings(\"unchecked\")\n+                            var br = ((List<Object>)b.value());\n+\n+                            ar.addAll(br);\n+                            return e.copyWithValue(ar);\n+                        }\n+                    });\n+                }\n+\n+                for (var value : map.values()) {\n+                    var option = (Option)value.withId();\n+                    if (option.spec().arrayValueConverter().isPresent()) {\n+                        var arr = mergeArrayValues(option.spec().mergePolicy(), (List<?>)value.value());\n+                        map.put(value.id(), value.copyWithValue(arr));\n+                    }\n+                }\n+\n+                return Result.ofValue(new TypedOptions(\n+                        DefaultOptions.create(new Snapshot(map, optionNames)),\n+                        detectedOptions(),\n+                        nonOptionArguments()));\n+            }\n+        }\n+\n+        @Override\n+        public Optional<Object> find(OptionIdentifier id) {\n+            Objects.requireNonNull(id);\n+            return Optional.ofNullable(optionMap.get(id)).map(spec -> {\n+                var values = getValues(spec);\n+                if (spec.hasValue()) {\n+                    return values.toArray(String[]::new);\n+                } else {\n+                    return new String[0];\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public boolean contains(OptionName optionName) {\n+            return optionNames.contains(optionName);\n+        }\n+\n+        private List<String> getValues(OptionSpec<?> spec) {\n+            Objects.requireNonNull(spec);\n+\n+            final var values = optionValues(mergerOptionSet, spec.name());\n+\n+            if (!values.isEmpty()) {\n+                return getOptionValue(values, spec.mergePolicy());\n+            } else if (spec.names().stream().anyMatch(this::contains)) {\n+                \/\/ The spec belongs to an option detected on the command line.\n+                if (!spec.hasValue()) {\n+                    \/\/ The spec belongs to an option without a value.\n+                    return List.of();\n+                } else if (spec.isValueOptional()) {\n+                    \/\/ The spec belongs to an option with an optional value.\n+                    return List.of(spec.name().formatForCommandLine());\n+                }\n+            }\n+\n+            throw new AssertionError();\n+        }\n+\n+        private static Object mergeArrayValues(OptionSpec.MergePolicy mergePolicy, List<?> value) {\n+            switch (mergePolicy) {\n+                case USE_FIRST -> {\n+                    \/\/ Find the first non-empty array, get its first element and wrap it into one-element array.\n+                    return value.stream().filter(arr -> {\n+                        return Array.getLength(arr) > 0;\n+                    }).findFirst().map(arr -> {\n+                        return asArray(Array.get(arr, 0));\n+                    }).orElseGet(value::getFirst);\n+                }\n+                case USE_LAST -> {\n+                    \/\/ Find the last non-empty array, get its last element and wrap it into one-element array.\n+                    return value.reversed().stream().filter(arr -> {\n+                        return Array.getLength(arr) > 0;\n+                    }).findFirst().map(arr -> {\n+                        return asArray(Array.get(arr, Array.getLength(arr) - 1));\n+                    }).orElseGet(value::getFirst);\n+                }\n+                case CONCATENATE -> {\n+                    return value.stream().filter(arr -> {\n+                        return Array.getLength(arr) > 0;\n+                    }).map(Object.class::cast).reduce((a, b) -> {\n+                        final var al = Array.getLength(a);\n+                        final var bl = Array.getLength(b);\n+                        final var arr = Array.newInstance(a.getClass().componentType(), al + bl);\n+                        System.arraycopy(a, 0, arr, 0, al);\n+                        System.arraycopy(b, 0, arr, al, bl);\n+                        return arr;\n+                    }).orElseGet(value::getFirst);\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        }\n+\n+        private static Object asArray(Object v) {\n+            final var arr = Array.newInstance(v.getClass(), 1);\n+            Array.set(arr, 0, v);\n+            return arr;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static List<String> optionValues(OptionSet optionSet, OptionName optionName) {\n+            return (List<String>)optionSet.valuesOf(optionName.name());\n+        }\n+\n+\n+        private record OptionSpecWithValue<T>(OptionSpec<T> optionSpec, Optional<String> optionValue) {\n+\n+            OptionSpecWithValue {\n+                Objects.requireNonNull(optionSpec);\n+                Objects.requireNonNull(optionValue);\n+\n+                if (optionSpec.names().size() != 1) {\n+                    throw new IllegalArgumentException();\n+                }\n+\n+                if (optionValue.isEmpty() && optionSpec.hasValue() && !optionSpec.isValueOptional()) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+\n+            OptionName optionName() {\n+                return optionSpec.name();\n+            }\n+\n+            Result<T> convertValue() {\n+                final var converter = optionSpec.converter().orElseThrow();\n+\n+                final Result<T> conversionResult = optionValue.map(v -> {\n+                    return converter.convert(optionName(), StringToken.of(v));\n+                }).orElseGet(() -> {\n+                    return Result.ofValue(optionSpec.defaultOptionalValue().orElseThrow());\n+                });\n+\n+                if (conversionResult.hasErrors()) {\n+                    final var arrConverter = optionSpec.arrayValueConverter().orElse(null);\n+\n+                    if (arrConverter != null && optionSpec.mergePolicy() != MergePolicy.CONCATENATE) {\n+                        \/\/ Maybe recoverable array conversion error\n+                        final var tokens = arrConverter.tokenize(optionValue.orElseThrow());\n+                        final String str = getOptionValue(List.of(tokens), optionSpec.mergePolicy()).getFirst();\n+                        final String[] token = arrConverter.tokenize(str);\n+                        if (token.length == 1 && str.equals(token[0])) {\n+                            final var singleTokenConversionResult = converter.convert(optionName(), StringToken.of(str));\n+                            if (singleTokenConversionResult.hasValue()) {\n+                                return singleTokenConversionResult;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                return conversionResult;\n+            }\n+\n+            static List<? extends OptionSpecWithValue<?>> create(OptionSet optionSet,\n+                    OptionSet mergerOptionSet, Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap) {\n+\n+                Objects.requireNonNull(optionSet);\n+                Objects.requireNonNull(mergerOptionSet);\n+                Objects.requireNonNull(optionMap);\n+\n+                final var optionsWithOptionalValues = optionsWithOptionalValues(mergerOptionSet);\n+\n+                final var nameToOptionValues = optionMap.values().stream().map(optionSpec -> {\n+                    return optionSpec.names().stream();\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(OptionName::name, optionName -> {\n+                    if (optionSet.has(optionName.name())) {\n+                        return Optional.ofNullable(optionsWithOptionalValues.get(optionName)).orElseGet(() -> {\n+                            return optionValues(optionSet, optionName).iterator();\n+                        });\n+                    } else {\n+                        return List.<String>of().iterator();\n+                    }\n+                }));\n+\n+                final var nameToOptionSpec = optionMap.values().stream().map(spec -> {\n+                    return spec.names().stream().map(name -> {\n+                        return Map.entry(name.name(), spec.copyWithName(name));\n+                    });\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+                final var nameGroups = optionMap.values().stream().map(optionSpec -> {\n+                    return optionSpec.names().stream().map(optionName -> {\n+                        return Map.entry(optionName, optionSpec.names());\n+                    });\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+                \/\/ Iterate option values in the order they appear on the command line.\n+                \/\/ OptionSet.specs() guarantees such order of option values.\n+                try {\n+                    return filterUnusedValues(nameGroups, optionSet.specs().stream().map(joptSpec -> {\n+                        var optionNames = joptSpec.options();\n+                        if (optionNames.size() != 1) {\n+                            throw new AssertionError();\n+                        }\n+                        return optionNames.getFirst();\n+                    }).filter(nameToOptionSpec::containsKey).map(name -> {\n+                        var optionSpec = nameToOptionSpec.get(name);\n+                        String optionValue;\n+                        if (!optionSpec.hasValue()) {\n+                            optionValue = null;\n+                        } else {\n+                            var it = nameToOptionValues.get(name);\n+                            if (it.hasNext()) {\n+                                optionValue = it.next();\n+                            } else if (optionSpec.isValueOptional()) {\n+                                return null;\n+                            } else {\n+                                throw new AssertionError();\n+                            }\n+                        }\n+                        OptionSpecWithValue<?> oswv = new OptionSpecWithValue<>(optionSpec, Optional.ofNullable(optionValue));\n+                        return oswv;\n+                    }).filter(Objects::nonNull).toList());\n+                } finally {\n+                    if (nameToOptionValues.values().stream().anyMatch(Iterator::hasNext)) {\n+                        throw new AssertionError(\"Unfetched option values detected\");\n+                    }\n+                }\n+            }\n+\n+            private static Map<OptionName, Iterator<String>> optionsWithOptionalValues(OptionSet optionSet) {\n+                Objects.requireNonNull(optionSet);\n+                return optionSet.specs().stream().distinct().filter(joptSpec -> {\n+                    if (joptSpec instanceof ArgumentAcceptingOptionSpec<?> v) {\n+                        return !v.requiresArgument();\n+                    } else {\n+                        return false;\n+                    }\n+                }).map(joptSpec -> {\n+                    @SuppressWarnings(\"unchecked\")\n+                    List<String> optionValues = ((List<String>)optionSet.valuesOf(joptSpec));\n+                    if (optionValues.isEmpty()) {\n+                        \/\/ `joptSpec` is detected on the command line without a value.\n+                        optionValues = Arrays.asList((String)null);\n+                    }\n+                    final var it = optionValues.iterator();\n+                    return joptSpec.options().stream().map(OptionName::of).map(optionName -> {\n+                        return Map.entry(optionName, it);\n+                    });\n+                }).flatMap(x -> x).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+            }\n+\n+            private static List<? extends OptionSpecWithValue<?>> filterUnusedValues(\n+                    Map<OptionName, List<OptionName>> nameGroups, List<? extends OptionSpecWithValue<?>> items) {\n+\n+                items = filterFirstValues(nameGroups, items.reversed(), OptionSpec.MergePolicy.USE_LAST);\n+                items = filterFirstValues(nameGroups, items.reversed(), OptionSpec.MergePolicy.USE_FIRST);\n+\n+                return items;\n+            }\n+\n+            private static List<? extends OptionSpecWithValue<?>> filterFirstValues(\n+                    Map<OptionName, List<OptionName>> nameGroups,\n+                    List<? extends OptionSpecWithValue<?>> items,\n+                    OptionSpec.MergePolicy mergePolicy) {\n+\n+                Objects.requireNonNull(nameGroups);\n+                Objects.requireNonNull(items);\n+                Objects.requireNonNull(mergePolicy);\n+\n+                Set<OptionName> encounteredNames = new HashSet<>();\n+\n+                return items.stream().filter(item -> {\n+                    if (item.optionSpec().mergePolicy() != mergePolicy) {\n+                        return true;\n+                    } else if (!encounteredNames.contains(item.optionSpec().name())) {\n+                        encounteredNames.addAll(Objects.requireNonNull(nameGroups.get(item.optionSpec().name())));\n+                        return true;\n+                    } else {\n+                        return false;\n+                    }\n+                }).toList();\n+            }\n+        }\n+\n+        private final OptionSet optionSet;\n+        private final OptionSet mergerOptionSet;\n+        private final Map<OptionIdentifier, ? extends OptionSpec<?>> optionMap;\n+        private final Set<OptionName> optionNames;\n+    }\n+\n+\n+    private static final class TypedOptions implements ExtendedOptions<TypedOptions> {\n+\n+        TypedOptions(\n+                DefaultOptions options,\n+                List<OptionName> detectedOptions,\n+                List<String> nonOptionArguments) {\n+\n+            this.options = Objects.requireNonNull(options);\n+            this.nonOptionArguments = Objects.requireNonNull(nonOptionArguments);\n+            this.detectedOptions = Objects.requireNonNull(detectedOptions);\n+            assertNoUnexpectedOptionNames(options.withOptionIdentifierSet(), detectedOptions);\n+        }\n+\n+        @Override\n+        public TypedOptions copyWithout(Iterable<? extends OptionIdentifier> ids) {\n+            var newOptions = options.copyWithout(ids);\n+            var newDetectedOptions = detectedOptions.stream().filter(newOptions::contains).toList();\n+            return new TypedOptions(newOptions, newDetectedOptions, nonOptionArguments);\n+        }\n+\n+        @Override\n+        public List<String> nonOptionArguments() {\n+            return nonOptionArguments;\n+        }\n+\n+        @Override\n+        public List<OptionName> detectedOptions() {\n+            return detectedOptions;\n+        }\n+\n+        @Override\n+        public Set<? extends OptionIdentifier> ids() {\n+            return options.ids();\n+        }\n+\n+        @Override\n+        public Optional<Object> find(OptionIdentifier id) {\n+            return options.find(id);\n+        }\n+\n+        @Override\n+        public boolean contains(OptionName optionName) {\n+            return options.contains(optionName);\n+        }\n+\n+        @Override\n+        public DefaultOptions toDefaultOptions() {\n+            return options;\n+        }\n+\n+        private final DefaultOptions options;\n+        private final List<String> nonOptionArguments;\n+        private final List<OptionName> detectedOptions;\n+    }\n+\n+\n+    private static void assertNoUnexpectedOptionNames(Set<? extends WithOptionIdentifier> options, Collection<OptionName> optionNames) {\n+        final var allowedOptionNames = options.stream()\n+                .map(Option.class::cast)\n+                .map(Option::spec)\n+                .map(OptionSpec::names)\n+                .flatMap(Collection::stream)\n+                .toList();\n+        if (!allowedOptionNames.containsAll(optionNames)) {\n+            final var diff = new HashSet<>(optionNames);\n+            diff.removeAll(allowedOptionNames);\n+            throw new AssertionError(String.format(\"Unexpected option names: %s\", diff.stream().map(OptionName::name).sorted().toList()));\n+        }\n+    }\n+\n+    private static <T> List<T> getOptionValue(List<T> values, OptionSpec.MergePolicy mergePolicy) {\n+        Objects.requireNonNull(mergePolicy);\n+        if (values.size() == 1) {\n+            return values;\n+        } else {\n+            switch (mergePolicy) {\n+                case USE_LAST -> {\n+                    return List.of(values.getLast());\n+                }\n+                case USE_FIRST -> {\n+                    return List.of(values.getFirst());\n+                }\n+                case CONCATENATE -> {\n+                    return values;\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        }\n+    }\n+\n+    private Collection<Option> options = new ArrayList<>();\n+    private UnaryOperator<OptionSpec<?>> optionSpecMapper;\n+    private Function<JOptSimpleError, ? extends Exception> jOptSimpleParserErrorHandler;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/JOptSimpleOptionsBuilder.java","additions":817,"deletions":0,"binary":false,"changes":817,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.HELP;\n+import static jdk.jpackage.internal.cli.StandardOption.VERBOSE;\n+import static jdk.jpackage.internal.cli.StandardOption.VERSION;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.NoSuchFileException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ServiceLoader;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.spi.ToolProvider;\n+import jdk.internal.opt.CommandLine;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.Log;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\/**\n+ * Main jpackage entry point.\n+ *\/\n+public final class Main {\n+\n+    public static final class Provider implements ToolProvider {\n+\n+        @Override\n+        public String name() {\n+            return \"jpackage\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            return Main.run(out, err, args);\n+        }\n+    }\n+\n+\n+    private Main() {\n+    }\n+\n+    public static void main(String... args) {\n+        var out = new PrintWriter(System.out, true);\n+        var err = new PrintWriter(System.err, true);\n+        System.exit(run(out, err, args));\n+    }\n+\n+    public static int run(PrintWriter out, PrintWriter err, String... args) {\n+        Objects.requireNonNull(out);\n+        Objects.requireNonNull(err);\n+\n+        Log.setPrintWriter(out, err);\n+\n+        try {\n+            try {\n+                args = CommandLine.parse(args);\n+            } catch (FileNotFoundException|NoSuchFileException ex) {\n+                Log.fatalError(I18N.format(\"ERR_CannotParseOptions\", ex.getMessage()));\n+                return 1;\n+            } catch (IOException ex) {\n+                throw ExceptionBox.rethrowUnchecked(ex);\n+            }\n+\n+            final var bundlingEnv = ServiceLoader.load(CliBundlingEnvironment.class,\n+                    CliBundlingEnvironment.class.getClassLoader()).findFirst().orElseThrow();\n+\n+            final var parseResult = Utils.buildParser(OperatingSystem.current(), bundlingEnv).create().apply(args);\n+\n+            return new Runner().run(() -> {\n+                final var parsedOptionsBuilder = parseResult.orElseThrow();\n+\n+                final var options = parsedOptionsBuilder.create();\n+\n+                final var nonOptionArgumentsError = !parsedOptionsBuilder.nonOptionArguments().isEmpty();\n+\n+                if (options.ids().isEmpty() && !nonOptionArgumentsError) {\n+                    StandardHelpFormatter.INSTANCE.formatNoArgsHelp(out::append);\n+                    return List.of();\n+                } else if (HELP.containsIn(options)) {\n+                    if (VERSION.containsIn(options)) {\n+                        out.println(getVersion() + \"\\n\");\n+                    }\n+                    StandardHelpFormatter.INSTANCE.format(out::append);\n+                    return List.of();\n+                } else if (VERSION.containsIn(options) && !nonOptionArgumentsError) {\n+                    out.println(getVersion());\n+                    return List.of();\n+                }\n+\n+                if (VERBOSE.containsIn(options)) {\n+                    Log.setVerbose();\n+                }\n+\n+                final var optionsProcessor = new OptionsProcessor(parsedOptionsBuilder, bundlingEnv);\n+\n+                final var validationResult = optionsProcessor.validate();\n+\n+                final var bundlingResult = validationResult.map(optionsProcessor::runBundling);\n+\n+                if (bundlingResult.hasValue()) {\n+                    return bundlingResult.orElseThrow();\n+                } else {\n+                    return bundlingResult.errors();\n+                }\n+            });\n+        } finally {\n+            try {\n+                out.flush();\n+            } finally {\n+                err.flush();\n+            }\n+        }\n+    }\n+\n+\n+    record ErrorReporter(Consumer<Throwable> stackTracePrinter, Consumer<String> messagePrinter) {\n+        ErrorReporter {\n+            Objects.requireNonNull(stackTracePrinter);\n+            Objects.requireNonNull(messagePrinter);\n+        }\n+\n+        void reportError(Throwable t) {\n+            if (t instanceof ConfigException cfgEx) {\n+                printError(cfgEx, Optional.ofNullable(cfgEx.getAdvice()));\n+            } else if (t instanceof ExceptionBox ex) {\n+                reportError(ex.getCause());\n+            } else if (t instanceof UncheckedIOException ex) {\n+                reportError(ex.getCause());\n+            } else {\n+                printError(t, Optional.empty());\n+            }\n+        }\n+\n+        private void printError(Throwable t, Optional<String> advice) {\n+            stackTracePrinter.accept(t);\n+\n+            String msg;\n+            if (isAlienExceptionType(t)) {\n+                msg = t.toString();\n+            } else {\n+                msg = t.getMessage();\n+            }\n+\n+            messagePrinter.accept(I18N.format(\"message.error-header\", msg));\n+            advice.ifPresent(v -> messagePrinter.accept(I18N.format(\"message.advice-header\", v)));\n+        }\n+\n+        private static boolean isAlienExceptionType(Throwable t) {\n+            switch (t) {\n+                case JPackageException _ -> {\n+                    return false;\n+                }\n+                case Utils.ParseException _ -> {\n+                    return false;\n+                }\n+                case StandardOption.AddLauncherIllegalArgumentException _ -> {\n+                    return false;\n+                }\n+                default -> {\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    static final class Runner {\n+\n+        int run(Supplier<? extends Collection<? extends Exception>> r) {\n+            final var exceptions = runIt(r);\n+            if (exceptions.isEmpty()) {\n+                return 0;\n+            } else {\n+                var errorReporter = new ErrorReporter(Log::verbose, Log::fatalError);\n+                exceptions.forEach(errorReporter::reportError);\n+                return 1;\n+            }\n+        }\n+\n+        private static Collection<? extends Exception> runIt(Supplier<? extends Collection<? extends Exception>> r) {\n+            try {\n+                return r.get();\n+            } catch (RuntimeException ex) {\n+                return List.of(ex);\n+            }\n+        }\n+    }\n+\n+    private static String getVersion() {\n+        return System.getProperty(\"java.version\");\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Main.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+final class MessageFormatUtils {\n+\n+    private MessageFormatUtils() {\n+    }\n+\n+    static String createMessage(Options cmdline, String formatId, Object... args) {\n+        return I18N.format(formatId, mapFormatArguments(cmdline, args));\n+    }\n+\n+    static String createMessage(String formatId, Object... args) {\n+        return I18N.format(formatId, mapFormatArguments(args));\n+    }\n+\n+    static Object[] mapFormatArguments(Object... args) {\n+        return mapFormatArguments(optionSpec -> {\n+            return optionSpec.name().formatForCommandLine();\n+        }, args);\n+    }\n+\n+    static Object[] mapFormatArguments(Options cmdline, Object... args) {\n+        Objects.requireNonNull(cmdline);\n+        return mapFormatArguments(optionSpec -> {\n+            return optionSpec.getFirstNameIn(cmdline).formatForCommandLine();\n+        }, args);\n+    }\n+\n+    private static Object[] mapFormatArguments(Function<OptionSpec<?>, String> optionSpecFormatter, Object... args) {\n+        Objects.requireNonNull(optionSpecFormatter);\n+        return Stream.of(args).map(arg -> {\n+            return asOptionSpec(arg).map(optionSpecFormatter).orElseGet(() -> {\n+                return Optional.ofNullable(arg).map(Object::toString).orElse(null);\n+            });\n+        }).toArray();\n+    }\n+\n+    private static Optional<OptionSpec<?>> asOptionSpec(Object v) {\n+        if (v instanceof OptionSpec<?> optionSpec) {\n+            return Optional.of(optionSpec);\n+        } else if (v instanceof OptionValue<?> ov) {\n+            return asOptionSpec(ov.getSpec());\n+        } else if (v instanceof Option option) {\n+            return asOptionSpec(option.spec());\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/MessageFormatUtils.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.function.Predicate;\n+\n+\/**\n+ * Option identifier associated with option specification.\n+ *\/\n+record Option(OptionIdentifier id, OptionSpec<?> spec) implements WithOptionIdentifier {\n+\n+    Option {\n+        Objects.requireNonNull(id);\n+        Objects.requireNonNull(spec);\n+    }\n+\n+    Option(OptionSpec<?> spec) {\n+        this(OptionIdentifier.createIdentifier(), spec);\n+    }\n+\n+    Option copyWithSpec(OptionSpec<?> spec) {\n+        return new Option(id, spec);\n+    }\n+\n+    static Predicate<Option> fromOptionSpecPredicate(Predicate<OptionSpec<?>> p) {\n+        return option -> {\n+            return p.test(option.spec());\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Option.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * Defines creating an option value of type {@link T[]} from a string.\n+ *\n+ * @param <T> option value element type\n+ *\/\n+interface OptionArrayValueConverter<T> extends OptionValueConverter<T[]> {\n+\n+    \/**\n+     * Splits the given string into tokens and returns the result.\n+     *\n+     * @param str the string to tokenize\n+     * @return the result of tokenization of the input string\n+     *\/\n+    String[] tokenize(String str);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionArrayValueConverter.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+public sealed interface OptionIdentifier {\n+\n+    static OptionIdentifier createIdentifier() {\n+        return new Details.DefaultOptionIdentifier();\n+    }\n+\n+    static OptionIdentifier of(String id) {\n+        return new Details.StringOptionIdentifier(id);\n+    }\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        static final class DefaultOptionIdentifier implements OptionIdentifier {}\n+\n+        record StringOptionIdentifier(String value) implements OptionIdentifier {\n+            StringOptionIdentifier {\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionIdentifier.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+record OptionName(String name) implements Comparable<OptionName> {\n+\n+    OptionName(String name) {\n+        Objects.requireNonNull(name);\n+        if (name.isEmpty()) {\n+            throw new IllegalArgumentException(\"Name should not be empty\");\n+        }\n+\n+        if (name.charAt(0) != '-') {\n+            this.name = name;\n+        } else if (name.length() == 1) {\n+            throw new IllegalArgumentException(\"Short option without a name\");\n+        } else if (name.charAt(1) != '-') {\n+            \/\/ Reverse operation for a short option name\n+            this.name = name.substring(1, 2);\n+        } else if (name.length() == 2) {\n+            throw new IllegalArgumentException(\"Long option without a name\");\n+        } else {\n+            \/\/ Reverse operation for a long option name\n+            this.name = name.substring(2);\n+        }\n+    }\n+\n+    static OptionName of(String name) {\n+        return new OptionName(name);\n+    }\n+\n+    boolean isShort() {\n+        return name.length() == 1;\n+    }\n+\n+    String formatForCommandLine() {\n+        return (isShort() ? \"-\" : \"--\") + name;\n+    }\n+\n+    @Override\n+    public int compareTo(OptionName other) {\n+        return name.compareTo(other.name);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionName.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * Option scope.\n+ *\/\n+interface OptionScope {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionScope.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * Source where command line options come from.\n+ *\/\n+sealed interface OptionSource {\n+\n+    static boolean isCommandLine(OptionSource v) {\n+        return v.equals(COMMAND_LINE);\n+    }\n+\n+    static Optional<Path> asFile(OptionSource v) {\n+        return Optional.of(v)\n+                .filter(Details.FileOptionSource.class::isInstance)\n+                .map(Details.FileOptionSource.class::cast)\n+                .map(Details.FileOptionSource::path);\n+    }\n+\n+    static OptionSource fromFile(Path v) {\n+        return new Details.FileOptionSource(v);\n+    }\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        private enum CommandLineOptionSource implements OptionSource {\n+            VALUE\n+        }\n+\n+        private record FileOptionSource(Path path) implements OptionSource {\n+            FileOptionSource {\n+                Objects.requireNonNull(path);\n+            }\n+        }\n+    }\n+\n+    static final OptionSource COMMAND_LINE = Details.CommandLineOptionSource.VALUE;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSource.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+\n+\/**\n+ * Option spec.\n+ *\n+ * Names are used to identify an option. Converter converts option value from a\n+ * {@link String} to an object of type {@link T}. Scope defines where the option\n+ * applies. The standard scopes are: {@link BundlingOperationOptionScope},\n+ * {@link BundlingOperationModifier}. Merge policy defines how to handle\n+ * multiple values of the option. Value pattern and description are targeted for\n+ * help output.\n+ *\n+ * @param names                the names. Must be non-empty\n+ * @param converter            the converter. Converts from a {@link String} to\n+ *                             an object of type {@link T}\n+ * @param scope                the scope. Must be non-empty\n+ * @param defaultOptionalValue the default optional value or an empty\n+ *                             {@link Optional} instance if the option has a\n+ *                             mandatory value or doesn't have a value\n+ * @param mergePolicy          the merge policy\n+ * @param valuePattern         the value pattern. Used in help output\n+ * @param description          the description. Used in help output\n+ * @param <T>                  option value type\n+ *\/\n+record OptionSpec<T>(\n+        List<OptionName> names,\n+        Optional<OptionValueConverter<T>> converter,\n+        Set<OptionScope> scope,\n+        MergePolicy mergePolicy,\n+        Optional<T> defaultOptionalValue,\n+        Optional<String> valuePattern,\n+        String description) {\n+\n+    enum MergePolicy {\n+        USE_FIRST,\n+        USE_LAST,\n+        CONCATENATE\n+    }\n+\n+    OptionSpec {\n+        Objects.requireNonNull(names);\n+        if (names.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty name list\");\n+        }\n+        Objects.requireNonNull(converter);\n+        Objects.requireNonNull(scope);\n+        if (scope.isEmpty()) {\n+            throw new IllegalArgumentException(\"Empty scope\");\n+        }\n+        Objects.requireNonNull(mergePolicy);\n+        Objects.requireNonNull(valuePattern);\n+        if (converter.isEmpty() && valuePattern.isPresent()) {\n+            throw new IllegalArgumentException(\"Option without a value can not have a value pattern\");\n+        }\n+        if (converter.isEmpty() && defaultOptionalValue.isPresent()) {\n+            throw new IllegalArgumentException(\"Option with optional value should have a converter\");\n+        }\n+        Objects.requireNonNull(description);\n+\n+        final var typeMustBeArray = mergePolicy.equals(MergePolicy.CONCATENATE);\n+        final var type = valueType(converter);\n+        if (typeMustBeArray && !type.map(Class::isArray).orElse(false)) {\n+            throw new IllegalArgumentException(String.format(\"Invalid merge policy [%s] for type [%s]\",\n+                    mergePolicy, type.map(Class::getName).orElse(\"\")));\n+        }\n+\n+        names = List.copyOf(names);\n+        scope = Set.copyOf(scope);\n+    }\n+\n+    \/**\n+     * Returns the first (primary) name of this option spec.\n+     *\n+     * @return the first name of this option spec\n+     *\/\n+    OptionName name() {\n+        return names.getFirst();\n+    }\n+\n+    \/**\n+     * Returns all names but the first of this option spec. Returns an empty list if\n+     * the option spec has only one name.\n+     *\n+     * @return the additional names\n+     *\/\n+    List<OptionName> otherNames() {\n+        return names.subList(1, names.size());\n+    }\n+\n+    \/**\n+     * Returns a stream of copy option spec objects, each having a single name.\n+     * <p>\n+     * If the option has three names \"a\", \"b\", and \"c\", the stream will have three\n+     * option spec objects each with a single name. The first will have name \"a\", the\n+     * second - \"b\", and the third \"c\".\n+     *\n+     * @return the stream of copy option spec objects each having a single name\n+     *\/\n+    Stream<OptionSpec<T>> copyForEveryName() {\n+        return names().stream().map(v -> {\n+            return new OptionSpec<>(List.of(v), converter, scope, mergePolicy, defaultOptionalValue, valuePattern, description);\n+        });\n+    }\n+\n+    <U> OptionSpec<U> copyWithConverter(OptionValueConverter<U> converter) {\n+        if (!defaultOptionalValue.isEmpty()) {\n+            throw new UnsupportedOperationException(\"Can not convert an option spec with optional value\");\n+        }\n+        return new OptionSpec<>(names, Optional.of(converter), scope, mergePolicy, Optional.empty(), valuePattern, description);\n+    }\n+\n+    OptionSpec<T> copyWithDescription(String description) {\n+        return new OptionSpec<>(names, converter, scope, mergePolicy, defaultOptionalValue, valuePattern, Objects.requireNonNull(description));\n+    }\n+\n+    OptionSpec<T> copyWithName(OptionName name) {\n+        return new OptionSpec<>(List.of(name), converter, scope, mergePolicy, defaultOptionalValue, valuePattern, description);\n+    }\n+\n+    List<OptionName> findNamesIn(Options cmdline) {\n+        return names().stream().filter(cmdline::contains).toList();\n+    }\n+\n+    OptionName getFirstNameIn(Options cmdline) {\n+        return findNamesIn(cmdline).getFirst();\n+    }\n+\n+    boolean hasValue() {\n+        return converter.isPresent();\n+    }\n+\n+    boolean isValueOptional() {\n+        return defaultOptionalValue.isPresent();\n+    }\n+\n+    Class<? extends T> valueType() {\n+        return valueType(converter).orElseThrow();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <U> Optional<OptionArrayValueConverter<U>> arrayValueConverter() {\n+        return converter.filter(OptionArrayValueConverter.class::isInstance).map(v -> (OptionArrayValueConverter<U>)v);\n+    }\n+\n+    private static <T> Optional<Class<? extends T>> valueType(Optional<OptionValueConverter<T>> valueConverter) {\n+        return valueConverter.map(OptionValueConverter::valueType);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpec.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,475 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.io.File;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+\n+final class OptionSpecBuilder<T> {\n+\n+    static <T> OptionSpecBuilder<T> create(Class<? extends T> valueType) {\n+        return new OptionSpecBuilder<>(valueType);\n+    }\n+\n+    static String pathSeparator() {\n+        return File.pathSeparator;\n+    }\n+\n+    static <T> Function<OptionValue.Builder<T[]>, OptionValue<List<T>>> toList() {\n+        return builder -> {\n+            return builder.to(List::of).create();\n+        };\n+    }\n+\n+    private OptionSpecBuilder(Class<? extends T> valueType) {\n+        this.valueType = Objects.requireNonNull(valueType);\n+    }\n+\n+    OptionSpecBuilder(OptionSpecBuilder<T> other) {\n+        valueType = other.valueType;\n+        name = other.name;\n+        nameAliases.addAll(other.nameAliases);\n+        description = other.description;\n+        mergePolicy = other.mergePolicy;\n+        scope = Set.copyOf(other.scope);\n+        defaultValue = other.defaultValue;\n+        defaultOptionalValue = other.defaultOptionalValue;\n+        valuePattern = other.valuePattern;\n+        converterBuilder = other.converterBuilder.copy();\n+        validatorBuilder = other.validatorBuilder.copy();\n+\n+        if (other.arrayDefaultValue != null) {\n+            arrayDefaultValue = Arrays.copyOf(other.arrayDefaultValue, other.arrayDefaultValue.length);\n+        }\n+        arrayValuePatternSeparator = other.arrayValuePatternSeparator;\n+        arrayTokenizer = other.arrayTokenizer;\n+    }\n+\n+    OptionSpecBuilder<T> copy() {\n+        return new OptionSpecBuilder<>(this);\n+    }\n+\n+    Class<? extends T> valueType() {\n+        return valueType;\n+    }\n+\n+    OptionValue<T> create() {\n+        return toOptionValueBuilder().create();\n+    }\n+\n+    OptionValue<T[]> createArray() {\n+        return toArrayOptionValueBuilder().create();\n+    }\n+\n+    <U> OptionValue<U> create(Function<OptionValue.Builder<T>, OptionValue<U>> transformer) {\n+        return transformer.apply(toOptionValueBuilder());\n+    }\n+\n+    <U> OptionValue<U> createArray(Function<OptionValue.Builder<T[]>, OptionValue<U>> transformer) {\n+        return transformer.apply(toArrayOptionValueBuilder());\n+    }\n+\n+    OptionValue.Builder<T> toOptionValueBuilder() {\n+        final var builder = OptionValue.<T>build().spec(createOptionSpec());\n+        defaultValue().ifPresent(builder::defaultValue);\n+        return builder;\n+    }\n+\n+    OptionValue.Builder<T[]> toArrayOptionValueBuilder() {\n+        final var builder = OptionValue.<T[]>build().spec(createArrayOptionSpec());\n+        defaultArrayValue().ifPresent(builder::defaultValue);\n+        return builder;\n+    }\n+\n+    OptionSpec<T> createOptionSpec() {\n+        return new OptionSpec<>(\n+                names(),\n+                createConverter(),\n+                scope,\n+                mergePolicy().orElse(MergePolicy.USE_LAST),\n+                defaultOptionalValue(),\n+                valuePattern(),\n+                description().orElse(\"\"));\n+    }\n+\n+    OptionSpec<T[]> createArrayOptionSpec() {\n+        return new OptionSpec<>(\n+                names(),\n+                Optional.of(createArrayConverter()),\n+                scope,\n+                OptionSpecBuilder.this.mergePolicy().orElse(MergePolicy.CONCATENATE),\n+                defaultArrayOptionalValue(),\n+                Optional.of(arryValuePattern()),\n+                OptionSpecBuilder.this.description().orElse(\"\"));\n+    }\n+\n+    OptionSpecBuilder<T> tokenizer(String splitRegexp) {\n+        Objects.requireNonNull(splitRegexp);\n+        return tokenizer(str -> {\n+            return str.split(splitRegexp);\n+        }).arrayValuePatternSeparator(splitRegexp);\n+    }\n+\n+    OptionSpecBuilder<T> tokenizeOne() {\n+        return tokenizer((Function<String, String[]>)null);\n+    }\n+\n+    OptionSpecBuilder<T> tokenizer(Function<String, String[]> v) {\n+        arrayTokenizer = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> mutate(Consumer<OptionSpecBuilder<T>> mutator) {\n+        mutator.accept(this);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFormatString(String v) {\n+        validatorBuilder.formatString(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFormatString(UnaryOperator<String> mutator) {\n+        validatorBuilder.formatString(mutator.apply(validatorBuilder.formatString().orElse(null)));\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFormatString(String v) {\n+        converterBuilder.formatString(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFormatString(UnaryOperator<String> mutator) {\n+        converterBuilder.formatString(mutator.apply(converterBuilder.formatString().orElse(null)));\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+        validatorBuilder.exceptionFactory(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validatorExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n+        return validatorExceptionFactory(mutator.apply(validatorBuilder.exceptionFactory().orElse(null)));\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+        converterBuilder.exceptionFactory(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converterExceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n+        return converterExceptionFactory(mutator.apply(converterBuilder.exceptionFactory().orElse(null)));\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFormatString(String v) {\n+        return validatorExceptionFormatString(v).converterExceptionFormatString(v);\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFormatString(UnaryOperator<String> mutator) {\n+        return validatorExceptionFormatString(mutator).converterExceptionFormatString(mutator);\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+        return validatorExceptionFactory(v).converterExceptionFactory(v);\n+    }\n+\n+    OptionSpecBuilder<T> exceptionFactory(UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> mutator) {\n+        return validatorExceptionFactory(mutator).converterExceptionFactory(mutator);\n+    }\n+\n+    OptionSpecBuilder<T> converter(ValueConverter<T> v) {\n+        converterBuilder.converter(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> converter(Function<String, T> v) {\n+        return converter(ValueConverter.create(v, valueType));\n+    }\n+\n+    OptionSpecBuilder<T> validator(Predicate<T> v) {\n+        validatorBuilder.predicate(v::test);\n+        return this;\n+    }\n+\n+    @SuppressWarnings(\"overloads\")\n+    OptionSpecBuilder<T> validator(Consumer<T> v) {\n+        validatorBuilder.consumer(v::accept);\n+        return this;\n+    }\n+\n+    @SuppressWarnings(\"overloads\")\n+    OptionSpecBuilder<T> validator(UnaryOperator<Validator.Builder<T, RuntimeException>> mutator) {\n+        validatorBuilder = mutator.apply(validatorBuilder);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> withoutConverter() {\n+        converterBuilder.converter(null);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> withoutValidator() {\n+        validatorBuilder.predicate(null).consumer(null);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> name(String v) {\n+        name = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> addAliases(String... v) {\n+        nameAliases.addAll(List.of(v));\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> description(String v) {\n+        description = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> mergePolicy(MergePolicy v) {\n+        mergePolicy = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> scope(OptionScope... v) {\n+        return scope(Set.of(v));\n+    }\n+\n+    OptionSpecBuilder<T> scope(Collection<? extends OptionScope> v) {\n+        scope = Set.copyOf(v);\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> scope(UnaryOperator<Set<OptionScope>> mutator) {\n+        return scope(mutator.apply(scope().orElseGet(Set::of)));\n+    }\n+\n+    OptionSpecBuilder<T> inScope(OptionScope... v) {\n+        return inScope(Set.of(v));\n+    }\n+\n+    OptionSpecBuilder<T> inScope(Collection<? extends OptionScope> v) {\n+        final Set<OptionScope> newScope = new HashSet<>(v);\n+        scope().ifPresent(newScope::addAll);\n+        scope = newScope;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> outOfScope(OptionScope... v) {\n+        return outOfScope(Set.of(v));\n+    }\n+\n+    OptionSpecBuilder<T> outOfScope(Collection<? extends OptionScope> v) {\n+        if (scope != null) {\n+            final Set<OptionScope> newScope = new HashSet<>(scope);\n+            newScope.removeAll(v);\n+            scope = newScope;\n+        }\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> defaultValue(T v) {\n+        defaultValue = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> defaultOptionalValue(T v) {\n+        defaultOptionalValue = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> defaultArrayValue(T[] v) {\n+        arrayDefaultValue = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> arrayValuePatternSeparator(String v) {\n+        arrayValuePatternSeparator = v;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> valuePattern(String v) {\n+        valuePattern = v;\n+        return this;\n+    }\n+\n+    private Optional<String> name() {\n+        return Optional.ofNullable(name);\n+    }\n+\n+    private Optional<String> description() {\n+        return Optional.ofNullable(description);\n+    }\n+\n+    private Optional<MergePolicy> mergePolicy() {\n+        return Optional.ofNullable(mergePolicy);\n+    }\n+\n+    private Optional<Set<OptionScope>> scope() {\n+        return Optional.ofNullable(scope);\n+    }\n+\n+    private Optional<T> defaultValue() {\n+        return Optional.ofNullable(defaultValue);\n+    }\n+\n+    private Optional<T[]> defaultArrayValue() {\n+        return Optional.ofNullable(arrayDefaultValue).or(() -> {\n+            return OptionSpecBuilder.this.defaultValue().map(this::toOneElementArray);\n+        });\n+    }\n+\n+    private Optional<T> defaultOptionalValue() {\n+        return Optional.ofNullable(defaultOptionalValue);\n+    }\n+\n+    private Optional<T[]> defaultArrayOptionalValue() {\n+        return defaultOptionalValue().map(this::toOneElementArray);\n+    }\n+\n+    private Optional<String> valuePattern() {\n+        var hasOptionalValue = defaultOptionalValue().isPresent();\n+        return Optional.ofNullable(valuePattern).or(this::defaultValuePattern).map(str -> {\n+            if (str.isEmpty()) {\n+                return \"<>\";\n+            } else {\n+                var sb = new StringBuilder();\n+                switch (str.charAt(0)) {\n+                    case '<', '[' -> {\n+                    }\n+                    default -> {\n+                        if (hasOptionalValue) {\n+                            sb.append(\"[\");\n+                        }\n+                        sb.append(\"<\");\n+                    }\n+                }\n+                sb.append(str);\n+                switch (str.charAt(str.length() - 1)) {\n+                    case '>', ']' -> {\n+                    }\n+                    default -> {\n+                        sb.append(\">\");\n+                        if (hasOptionalValue) {\n+                            sb.append(\"]\");\n+                        }\n+                    }\n+                }\n+                return sb.toString();\n+            }\n+        });\n+    }\n+\n+    private Optional<String> defaultValuePattern() {\n+        return converterBuilder.converter().map(_ -> {\n+            final var tokens = name.split(\"-\");\n+            return tokens[tokens.length - 1];\n+        });\n+    }\n+\n+    private List<OptionName> names() {\n+        return Stream.of(\n+                List.of(name().orElseThrow()),\n+                nameAliases\n+        ).flatMap(Collection::stream).map(OptionName::new).distinct().toList();\n+    }\n+\n+    private Optional<OptionValueConverter<T>> createConverter() {\n+        if (converterBuilder.converter().isPresent()) {\n+            final var newBuilder = converterBuilder.copy();\n+            createValidator().ifPresent(newBuilder::validator);\n+            return Optional.of(newBuilder.create());\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Optional<Validator<T, ? extends RuntimeException>> createValidator() {\n+        if (validatorBuilder.hasValidatingMethod()) {\n+            return Optional.of(validatorBuilder.create());\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private OptionValueConverter<T[]> createArrayConverter() {\n+        final var newBuilder = converterBuilder.copy();\n+        newBuilder.tokenizer(Optional.ofNullable(arrayTokenizer).orElse(str -> {\n+            return new String[] { str };\n+        }));\n+        createValidator().ifPresent(newBuilder::validator);\n+        return newBuilder.createArray();\n+    }\n+\n+    private String arryValuePattern() {\n+        final var elementValuePattern = OptionSpecBuilder.this.valuePattern().orElseThrow();\n+        if (arrayValuePatternSeparator == null) {\n+            return elementValuePattern;\n+        } else {\n+            return String.format(\"%s[%s%s...]\", elementValuePattern, arrayValuePatternSeparator, elementValuePattern);\n+        }\n+    }\n+\n+    private T[] toOneElementArray(T v) {\n+        Objects.requireNonNull(v);\n+        @SuppressWarnings(\"unchecked\")\n+        final var arr = (T[]) Array.newInstance(valueType, 1);\n+        arr[0] = v;\n+        return arr;\n+    }\n+\n+    private final Class<? extends T> valueType;\n+    private String name;\n+    private Collection<String> nameAliases = new LinkedHashSet<>();\n+    private String description;\n+    private MergePolicy mergePolicy;\n+    private Set<OptionScope> scope;\n+    private T defaultValue;\n+    private T defaultOptionalValue;\n+    private String valuePattern;\n+    private OptionValueConverter.Builder<T> converterBuilder = OptionValueConverter.build();\n+    private Validator.Builder<T, RuntimeException> validatorBuilder = Validator.build();\n+\n+    private T[] arrayDefaultValue;\n+    private String arrayValuePatternSeparator;\n+    private Function<String, String[]> arrayTokenizer;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecBuilder.java","additions":475,"deletions":0,"binary":false,"changes":475,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import jdk.jpackage.internal.util.SetBuilder;\n+\n+\/**\n+ * Option scope facilitating mapping of {@link OptionSpec} instances based on\n+ * the given context.\n+ *\n+ * <p>\n+ * Use with option specs whose behavior is a function of a context. E.g.: if\n+ * option value validation depends on the current OS; if option description\n+ * varies depending on the current OS.\n+ *\n+ * @param <T> the type of option value\n+ * @param <T> the type of context\n+ *\/\n+interface OptionSpecMapperOptionScope<T, U> extends OptionScope {\n+\n+    OptionSpec<T> createOptionSpec(U context, boolean createArray);\n+\n+    Class<? extends U> contextType();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U> OptionSpec<T> mapOptionSpec(OptionSpec<T> optionSpec, U context) {\n+        return optionSpec.scope().stream()\n+                .filter(OptionSpecMapperOptionScope.class::isInstance)\n+                .map(OptionSpecMapperOptionScope.class::cast)\n+                .filter(scope -> {\n+                    return scope.contextType().isInstance(context);\n+                })\n+                .findFirst().map(scope -> {\n+                    return ((OptionSpecMapperOptionScope<T, U>)scope).createOptionSpec(\n+                            context, optionSpec.arrayValueConverter().isPresent());\n+                }).orElse(optionSpec);\n+    }\n+\n+    static <T, U> Consumer<OptionSpecBuilder<T>> createOptionSpecBuilderMutator(\n+            Class<? extends U> contextType,\n+            BiConsumer<OptionSpecBuilder<T>, U> mutator) {\n+        Objects.requireNonNull(mutator);\n+\n+        return builder -> {\n+            builder.scope(scope -> {\n+                return Details.<T, U>addOptionSpecBuilderMutator(contextType, scope, mutator, builder);\n+            });\n+        };\n+    }\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        private static <T, U> Set<OptionScope> addOptionSpecBuilderMutator(\n+                Class<? extends U> contextType,\n+                Set<OptionScope> scope,\n+                BiConsumer<OptionSpecBuilder<T>, U> optionSpecBuilderMutator,\n+                OptionSpecBuilder<T> optionSpecBuilder) {\n+\n+            Objects.requireNonNull(contextType);\n+            Objects.requireNonNull(scope);\n+            Objects.requireNonNull(optionSpecBuilderMutator);\n+            Objects.requireNonNull(optionSpecBuilder);\n+\n+            var contextOptionScope = scope.stream()\n+                    .filter(AccumulatingContextOptionScope.class::isInstance)\n+                    .map(AccumulatingContextOptionScope.class::cast)\n+                    .filter(s -> {\n+                        return s.contextType().equals(contextType);\n+                    })\n+                    .findFirst();\n+            contextOptionScope.ifPresent(v -> {\n+                @SuppressWarnings(\"unchecked\")\n+                var mutators = (AccumulatingContextOptionScope<T, U>)v;\n+                mutators.addMutator(optionSpecBuilderMutator);\n+                if (optionSpecBuilder != mutators.optionSpecBuilder) {\n+                    throw new IllegalArgumentException();\n+                }\n+            });\n+\n+            if (contextOptionScope.isEmpty()) {\n+                var mutators = new AccumulatingContextOptionScope<T, U>(optionSpecBuilder, contextType);\n+                mutators.addMutator(optionSpecBuilderMutator);\n+                scope = SetBuilder.build(OptionScope.class).add(scope).add(mutators).create();\n+            }\n+\n+            return scope;\n+        }\n+\n+        private static final class AccumulatingContextOptionScope<T, U> implements OptionSpecMapperOptionScope<T, U> {\n+\n+            AccumulatingContextOptionScope(OptionSpecBuilder<T> optionSpecBuilder, Class<? extends U> contextType) {\n+                this.optionSpecBuilder = Objects.requireNonNull(optionSpecBuilder);\n+                this.contextType = Objects.requireNonNull(contextType);\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public OptionSpec<T> createOptionSpec(U context, boolean createArray) {\n+                var copy = optionSpecBuilder.copy();\n+                for (var mutator : optionSpecBuilderMutators) {\n+                    mutator.accept(copy, context);\n+                }\n+\n+                if (createArray) {\n+                    return (OptionSpec<T>)copy.createArrayOptionSpec();\n+                } else {\n+                    return copy.createOptionSpec();\n+                }\n+            }\n+\n+            @Override\n+            public Class<? extends U> contextType() {\n+                return contextType;\n+            }\n+\n+            void addMutator(BiConsumer<OptionSpecBuilder<T>, U> mutator) {\n+                optionSpecBuilderMutators.add(mutator);\n+            }\n+\n+            private final OptionSpecBuilder<T> optionSpecBuilder;\n+            private final Class<? extends U> contextType;\n+            private final List<BiConsumer<OptionSpecBuilder<T>, U>> optionSpecBuilderMutators = new ArrayList<>();\n+        }\n+\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecMapperOptionScope.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+\/**\n+ * Typed getter of option values in {@link Options} objects.\n+ *\n+ * @param <T> option value type.\n+ *\/\n+public sealed interface OptionValue<T> extends WithOptionIdentifier {\n+\n+    Optional<Option> asOption();\n+\n+    default Option getOption() {\n+        return asOption().orElseThrow();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default OptionSpec<T> getSpec() {\n+        return (OptionSpec<T>)getOption().spec();\n+    }\n+\n+    default String getName() {\n+        return getSpec().name().name();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    default Optional<T> findIn(Options cmdline) {\n+        return (Optional<T>)cmdline.find(id());\n+    }\n+\n+    default T getFrom(Options cmdline) {\n+        return findIn(cmdline).orElseThrow();\n+    }\n+\n+    default void ifPresentIn(Options cmdline, Consumer<T> consumer) {\n+        findIn(cmdline).ifPresent(consumer);\n+    }\n+\n+    default boolean containsIn(Options cmdline) {\n+        return cmdline.find(id()).isPresent();\n+    }\n+\n+    static <U> OptionValue<U> create() {\n+        return create(OptionIdentifier.createIdentifier());\n+    }\n+\n+    static <U> OptionValue<U> create(OptionIdentifier id) {\n+        return new Internal.Standard<>(id, Optional.empty(), Optional.empty());\n+    }\n+\n+    static <U> Builder<U> build() {\n+        return new Builder<>();\n+    }\n+\n+    static final class Builder<T> {\n+        OptionValue<T> create() {\n+            if (conv != null) {\n+                return conv.create(Optional.ofNullable(defaultValue));\n+            } else {\n+                return new Internal.Standard<>(\n+                        Optional.ofNullable(id).orElseGet(OptionIdentifier::createIdentifier),\n+                        Optional.ofNullable(spec),\n+                        Optional.ofNullable(defaultValue));\n+            }\n+        }\n+\n+        Builder<T> defaultValue(T v) {\n+            defaultValue = v;\n+            return this;\n+        }\n+\n+        Builder<T> spec(OptionSpec<?> v) {\n+            spec = v;\n+            conv = null;\n+            return this;\n+        }\n+\n+        Builder<T> id(OptionIdentifier v) {\n+            id = v;\n+            conv = null;\n+            return this;\n+        }\n+\n+        <U> Builder<T> from(OptionValue<U> base, Function<U, T> conv) {\n+            id(null).spec(null);\n+            this.conv = new Conv<>(base, conv);\n+            return this;\n+        }\n+\n+        <U> Builder<U> to(Function<T, U> conv) {\n+            return OptionValue.<U>build().from(create(), conv);\n+        }\n+\n+        private record Conv<U, V>(OptionValue<U> base, Function<U, V> conv) {\n+            Conv {\n+                Objects.requireNonNull(base);\n+                Objects.requireNonNull(conv);\n+            }\n+\n+            OptionValue<V> create(Optional<V> defaultValue) {\n+                return new Internal.Mapping<>(base, conv, defaultValue);\n+            }\n+        }\n+\n+        private Conv<?, T> conv;\n+        private T defaultValue;\n+        private OptionIdentifier id;\n+        private OptionSpec<?> spec;\n+    }\n+\n+\n+    static final class Internal {\n+\n+        private Internal() {\n+        }\n+\n+        private record Standard<T>(OptionIdentifier id, Optional<OptionSpec<?>> spec, Optional<T> defaultValue) implements OptionValue<T> {\n+\n+            Standard {\n+                Objects.requireNonNull(id);\n+                Objects.requireNonNull(spec);\n+                Objects.requireNonNull(defaultValue);\n+            }\n+\n+            @Override\n+            public Optional<Option> asOption() {\n+                return spec.map(v -> {\n+                    return new Option(id, v);\n+                });\n+            }\n+\n+            @Override\n+            public Optional<T> findIn(Options cmdline) {\n+                return OptionValue.super.findIn(cmdline).or(() -> defaultValue);\n+            }\n+        }\n+\n+        private record Mapping<T, U>(OptionValue<U> base, Function<U, T> conv, Optional<T> defaultValue) implements OptionValue<T> {\n+\n+            Mapping {\n+                Objects.requireNonNull(base);\n+                Objects.requireNonNull(conv);\n+                Objects.requireNonNull(defaultValue);\n+            }\n+\n+            @Override\n+            public OptionIdentifier id() {\n+                return base.id();\n+            }\n+\n+            @Override\n+            public Optional<Option> asOption() {\n+                return base.asOption();\n+            }\n+\n+            @Override\n+            public Optional<T> findIn(Options cmdline) {\n+                return base.findIn(cmdline).map(conv).or(() -> defaultValue);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionValue.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.cli.Validator.ParsedValue;\n+import jdk.jpackage.internal.util.Result;\n+\n+\/**\n+ * Defines creating an option value of type {@link T} from a string.\n+ *\n+ * @param <T> option value type\n+ *\/\n+interface OptionValueConverter<T> {\n+\n+    \/**\n+     * Converts the given string value corresponding to the given option name into a\n+     * Java type.\n+     *\n+     * @param optionName  the option name\n+     * @param optionValue the string value of the option to convert\n+     * @return the conversion result\n+     *\/\n+    Result<T> convert(OptionName optionName, StringToken optionValue);\n+\n+    \/**\n+     * Gives the class of the type of values this converter converts to.\n+     *\n+     * @return the target class for conversion\n+     *\/\n+    Class<? extends T> valueType();\n+\n+    \/**\n+     * Thrown to indicate an error in the normal execution of the converter.\n+     *\/\n+    static final class ConverterException extends RuntimeException {\n+\n+        private ConverterException(Throwable cause) {\n+            super(cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    static <T> Builder<T> build() {\n+        return new Builder<>();\n+    }\n+\n+    static final class Builder<T> {\n+\n+        private Builder() {\n+        }\n+\n+        private Builder(Builder<T> other) {\n+            converter = other.converter;\n+            validator = other.validator;\n+            tokenizer = other.tokenizer;\n+            formatString = other.formatString;\n+            exceptionFactory = other.exceptionFactory;\n+        }\n+\n+        Builder<T> copy() {\n+            return new Builder<>(this);\n+        }\n+\n+        OptionValueConverter<T> create() {\n+            return new DefaultOptionValueConverter<>(\n+                    converter,\n+                    formatString().orElseGet(() -> {\n+                        if (exceptionFactory == null) {\n+                            return \"\";\n+                        } else {\n+                            return null;\n+                        }\n+                    }),\n+                    exceptionFactory().orElseGet(() -> {\n+                        if (formatString == null) {\n+                            return OptionValueExceptionFactory.unreachable();\n+                        } else {\n+                            return null;\n+                        }\n+                    }),\n+                    validator());\n+        }\n+\n+        OptionArrayValueConverter<T> createArray() {\n+            return new DefaultOptionArrayValueConverter<>(create(), tokenizer);\n+        }\n+\n+        Builder<T> converter(ValueConverter<T> v) {\n+            converter = v;\n+            return this;\n+        }\n+\n+        Builder<T> validator(Validator<T, ? extends RuntimeException> v) {\n+            validator = v;\n+            return this;\n+        }\n+\n+        Builder<T> tokenizer(Function<String, String[]> v) {\n+            tokenizer = v;\n+            return this;\n+        }\n+\n+        Builder<T> formatString(String v) {\n+            formatString = v;\n+            return this;\n+        }\n+\n+        Builder<T> exceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> v) {\n+            exceptionFactory = v;\n+            return this;\n+        }\n+\n+        Builder<T> mutate(Consumer<Builder<T>> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        Optional<ValueConverter<T>> converter() {\n+            return Optional.ofNullable(converter);\n+        }\n+\n+        Optional<Validator<T, ? extends RuntimeException>> validator() {\n+            return Optional.ofNullable(validator);\n+        }\n+\n+        Optional<Function<String, String[]>> tokenizer() {\n+            return Optional.ofNullable(tokenizer);\n+        }\n+\n+        Optional<String> formatString() {\n+            return Optional.ofNullable(formatString);\n+        }\n+\n+        Optional<OptionValueExceptionFactory<? extends RuntimeException>> exceptionFactory() {\n+            return Optional.ofNullable(exceptionFactory);\n+        }\n+\n+\n+        private record DefaultOptionValueConverter<T>(ValueConverter<T> converter, String formatString,\n+                OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory,\n+                Optional<Validator<T, ? extends RuntimeException>> validator) implements OptionValueConverter<T> {\n+\n+            DefaultOptionValueConverter {\n+                Objects.requireNonNull(converter);\n+                Objects.requireNonNull(formatString);\n+                Objects.requireNonNull(exceptionFactory);\n+                Objects.requireNonNull(validator);\n+            }\n+\n+            @Override\n+            public Result<T> convert(OptionName optionName, StringToken optionValue) {\n+                Objects.requireNonNull(optionName);\n+\n+                final T convertedValue;\n+                try {\n+                    convertedValue = converter.convert(optionValue.value());\n+                } catch (Exception ex) {\n+                    return handleException(optionName, optionValue, ex);\n+                }\n+\n+                final List<? extends Exception> validationExceptions = validator.map(val -> {\n+                    try {\n+                        return val.validate(optionName, ParsedValue.create(convertedValue, optionValue));\n+                    } catch (Validator.ValidatorException ex) {\n+                        \/\/ All unexpected exceptions that the converter yields should be tunneled via ConverterException.\n+                        throw new ConverterException(ex.getCause());\n+                    }\n+                }).orElseGet(List::of);\n+\n+                if (validationExceptions.isEmpty()) {\n+                    return Result.ofValue(convertedValue);\n+                } else {\n+                    return Result.ofErrors(validationExceptions);\n+                }\n+            }\n+\n+            @Override\n+            public Class<? extends T> valueType() {\n+                return converter.valueType();\n+            }\n+\n+            private Result<T> handleException(OptionName optionName, StringToken optionValue, Exception ex) {\n+                if (ex instanceof IllegalArgumentException) {\n+                    return Result.ofError(exceptionFactory.create(optionName, optionValue, formatString, Optional.of(ex)));\n+                } else {\n+                    throw new ConverterException(ex);\n+                }\n+            }\n+        }\n+\n+\n+        private record DefaultOptionArrayValueConverter<T>(OptionValueConverter<T> elementConverter,\n+                Function<String, String[]> tokenizer) implements OptionArrayValueConverter<T> {\n+\n+            DefaultOptionArrayValueConverter {\n+                Objects.requireNonNull(elementConverter);\n+                Objects.requireNonNull(tokenizer);\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public Result<T[]> convert(OptionName optionName, StringToken optionValue) {\n+\n+                final List<Exception> exceptions = new ArrayList<>();\n+                final List<T> convertedValues = new ArrayList<>();\n+\n+                final var tokens = tokenize(optionValue.value());\n+                for (var token : tokens) {\n+                    final var result = elementConverter.convert(optionName, StringToken.of(optionValue.value(), token));\n+                    exceptions.addAll(result.errors());\n+                    if (exceptions.isEmpty()) {\n+                        result.value().ifPresent(convertedValues::add);\n+                    }\n+                }\n+\n+                if (!exceptions.isEmpty()) {\n+                    return Result.ofErrors(exceptions);\n+                } else {\n+                    return Result.ofValue(convertedValues.toArray(length -> {\n+                        return (T[])Array.newInstance(elementConverter.valueType(), length);\n+                    }));\n+                }\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public Class<? extends T[]> valueType() {\n+                return (Class<? extends T[]>)elementConverter.valueType().arrayType();\n+            }\n+\n+            @Override\n+            public String[] tokenize(String str) {\n+                return tokenizer.apply(Objects.requireNonNull(str));\n+            }\n+        }\n+\n+        private ValueConverter<T> converter;\n+        private Validator<T, ? extends RuntimeException> validator;\n+        private Function<String, String[]> tokenizer;\n+        private String formatString;\n+        private OptionValueExceptionFactory<? extends RuntimeException> exceptionFactory;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionValueConverter.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Factory producing exception objects for option value processing failures.\n+ * <p>\n+ * Errors in converting option string values into objects or validating objects\n+ * created from option string values are typical option value processing\n+ * failures.\n+ *\n+ * @param T type of produced exceptions\n+ *\/\n+@FunctionalInterface\n+interface OptionValueExceptionFactory<T extends Exception> {\n+\n+    \/**\n+     * Create an exception object for the specified option name, value and optional\n+     * cause.\n+     *\n+     * @param optionName   the name of the option\n+     * @param optionValue  the value of the option\n+     * @param formatString the format string for formatting the exception message\n+     * @param cause        the cause if any, an empty {@ @link Optional} instance\n+     *                     otherwise\n+     * @return exception object\n+     *\/\n+    T create(OptionName optionName, StringToken optionValue, String formatString, Optional<Exception> cause);\n+\n+    static <T extends Exception> Builder<T> build() {\n+        return new Builder<>();\n+    }\n+\n+    static <T extends Exception> Builder<T> build(BiFunction<String, Throwable, T> ctor) {\n+        final Builder<T> builder = build();\n+        return builder.ctor(ctor);\n+    }\n+\n+    static <T extends Exception> OptionValueExceptionFactory<T> unreachable() {\n+        return (_, _, _, _) -> {\n+            throw new UnsupportedOperationException();\n+        };\n+    }\n+\n+\n+    @FunctionalInterface\n+    interface ArgumentsMapper {\n+        String[] apply(String formattedOptionName, StringToken optionValue);\n+\n+        static ArgumentsMapper appendArguments(ArgumentsMapper target, Object... args) {\n+            return (optionName, optionValue) -> {\n+                var arr = target.apply(optionName, optionValue);\n+                return Stream.concat(Stream.of(arr), Stream.of(args).map(Object::toString)).toArray(String[]::new);\n+            };\n+        }\n+    }\n+\n+\n+    enum StandardArgumentsMapper implements ArgumentsMapper {\n+        NAME_AND_VALUE((formattedOptionName, optionValue) -> {\n+            return new String[] { formattedOptionName, optionValue.tokenizedString() };\n+        }),\n+        VALUE_AND_NAME((formattedOptionName, optionValue) -> {\n+            return new String[] { optionValue.tokenizedString(), formattedOptionName };\n+        }),\n+        VALUE((formattedOptionName, optionValue) -> {\n+            return new String[] { optionValue.tokenizedString() };\n+        }),\n+        NONE((formattedOptionName, optionValue) -> {\n+            return new String[] {};\n+        });\n+\n+        StandardArgumentsMapper(ArgumentsMapper impl) {\n+            this.impl = Objects.requireNonNull(impl);\n+        }\n+\n+        @Override\n+        public String[] apply(String formattedOptionName, StringToken optionValue) {\n+            return impl.apply(formattedOptionName, optionValue);\n+        }\n+\n+        private final ArgumentsMapper impl;\n+    }\n+\n+\n+    static final class Builder<T extends Exception> {\n+\n+        OptionValueExceptionFactory<T> create() {\n+            return OptionValueExceptionFactory.create(ctor,\n+                    Optional.ofNullable(formatArgumentsTransformer).orElse(StandardArgumentsMapper.NAME_AND_VALUE),\n+                    Optional.ofNullable(messageFormatter).orElse(I18N::format),\n+                    printOptionPrefix);\n+        }\n+\n+        Builder<T> messageFormatter(BiFunction<String, Object[], String> v) {\n+            messageFormatter = v;\n+            return this;\n+        }\n+\n+        Builder<T> ctor(BiFunction<String, Throwable, T> v) {\n+            ctor = v;\n+            return this;\n+        }\n+\n+        Builder<T> formatArgumentsTransformer(ArgumentsMapper v) {\n+            formatArgumentsTransformer = v;\n+            return this;\n+        }\n+\n+        Builder<T> printOptionPrefix(boolean v) {\n+            printOptionPrefix = v;\n+            return this;\n+        }\n+\n+        private BiFunction<String, Throwable, T> ctor;\n+        private ArgumentsMapper formatArgumentsTransformer;\n+        private BiFunction<String, Object[], String> messageFormatter;\n+        private boolean printOptionPrefix = true;\n+    }\n+\n+\n+    private static <T extends Exception> OptionValueExceptionFactory<T> create(\n+            BiFunction<String, Throwable, T> ctor,\n+            ArgumentsMapper formatArgumentsTransformer,\n+            BiFunction<String, Object[], String> messageFormatter,\n+            boolean printOptionPrefix) {\n+        Objects.requireNonNull(ctor);\n+        Objects.requireNonNull(formatArgumentsTransformer);\n+        Objects.requireNonNull(messageFormatter);\n+\n+        return new OptionValueExceptionFactory<>() {\n+\n+            @Override\n+            public T create(OptionName optionName, StringToken optionValue, String formatString, Optional<Exception> cause) {\n+                return Objects.requireNonNull(ctor.apply(createMessage(optionName, optionValue, formatString), cause.orElse(null)));\n+            }\n+\n+            private String createMessage(OptionName optionName, StringToken optionValue, String formatString) {\n+                Objects.requireNonNull(optionName);\n+                Objects.requireNonNull(optionValue);\n+                Objects.requireNonNull(formatString);\n+\n+                final String formattedOptionName;\n+                if (printOptionPrefix) {\n+                    formattedOptionName = optionName.formatForCommandLine();\n+                } else {\n+                    formattedOptionName = optionName.name();\n+                }\n+\n+                final var args = Stream.of(formatArgumentsTransformer.apply(formattedOptionName, optionValue)).toArray();\n+                return Objects.requireNonNull(messageFormatter.apply(formatString, args));\n+            }\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionValueExceptionFactory.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\n+\/**\n+ * R\/O collection of objects associated with option identifiers.\n+ * <p>\n+ * Use {@link OptionValue} for typed access of the stored objects.\n+ *\/\n+public sealed interface Options permits\n+        JOptSimpleOptionsBuilder.ExtendedOptions,\n+        DefaultOptions {\n+\n+    Optional<Object> find(OptionIdentifier id);\n+\n+    boolean contains(OptionName optionName);\n+\n+    Set<? extends OptionIdentifier> ids();\n+\n+    default Optional<Object> find(WithOptionIdentifier withId) {\n+        return find(withId.id());\n+    }\n+\n+    default boolean contains(OptionIdentifier id) {\n+        return find(id).isPresent();\n+    }\n+\n+    default boolean contains(WithOptionIdentifier withId) {\n+        return find(withId).isPresent();\n+    }\n+\n+    default Options copyWithDefaultValue(WithOptionIdentifier withId, Object value) {\n+        Objects.requireNonNull(value);\n+        return copyWithDefaultValue(withId, () -> value);\n+    }\n+\n+    default Options copyWithDefaultValue(WithOptionIdentifier withId, Supplier<Object> valueSupplier) {\n+        Objects.requireNonNull(withId);\n+        Objects.requireNonNull(valueSupplier);\n+        if (contains(withId)) {\n+            return this;\n+        } else {\n+            return copyWithParent(of(Map.of(withId, valueSupplier.get())));\n+        }\n+    }\n+\n+    default Options copyWithParent(Options other) {\n+        return concat(this, other);\n+    }\n+\n+    \/**\n+     * Creates a copy of this instance without the given option identifiers.\n+     * <p>\n+     * {@link #contains(OptionIdentifier)} called on the return instance with any of\n+     * the given identifiers will return {@code false}.\n+     * {@link #contains(OptionName)} called on the return instance with any option\n+     * name of option specifications associated with given identifiers will return\n+     * {@code false}.\n+     *\n+     * @param ids the identifiers to exclude\n+     * @return a copy of this instance without the given option identifiers\n+     *\/\n+    default Options copyWithout(OptionIdentifier... ids) {\n+        return copyWithout(List.of(ids));\n+    }\n+\n+    \/**\n+     * Creates a copy of this instance without the given option identifiers.\n+     * <p>\n+     * Same as {@link #copyWithout(OptionIdentifier...)} but takes an\n+     * {@code Iterable<OptionIdentifier>} instead of an {@code OptionIdentifier[]}.\n+     *\n+     * @param ids the identifiers to exclude\n+     * @return a copy of this instance without the given option identifiers\n+     *\/\n+    Options copyWithout(Iterable<? extends OptionIdentifier> ids);\n+\n+    \/**\n+     * Creates a copy of this instance with all but the given option identifiers\n+     * filtered out.\n+     * <p>\n+     * {@link #contains(OptionIdentifier)} called on the returned instance with any\n+     * identifiers not in the given array will return {@code false}.\n+     * {@link #contains(OptionName)} called on the returned instance with any name\n+     * returned by {@link OptionSpec#name()} method called on option specifications\n+     * of identifiers of type {@code Option} not from the given identifier array\n+     * will return {@code false}.\n+     *\n+     * @param ids the identifiers to keep in the copy\n+     * @return a copy of this instance with all but the given option identifiers\n+     *         filtered out\n+     *\/\n+    default Options copyWith(OptionIdentifier... ids) {\n+        return copyWith(List.of(ids));\n+    }\n+\n+    \/**\n+     * Creates a copy of this instance with all but the given option identifiers\n+     * filtered out.\n+     * <p>\n+     * Same as {@link #copyWith(OptionIdentifier...)} but takes an\n+     * {@code Iterable<OptionIdentifier>} instead of an {@code OptionIdentifier[]}.\n+     *\n+     * @param ids the identifiers to keep in the copy\n+     * @return a copy of this instance with all but the given option identifiers\n+     *         filtered out\n+     *\/\n+    default Options copyWith(Iterable<? extends OptionIdentifier> ids) {\n+        var excludes = new HashSet<>(ids());\n+        ids.forEach(excludes::remove);\n+        return copyWithout(excludes);\n+    }\n+\n+    \/**\n+     * Returns a map representation of this instance.\n+     * @return the map representation of this instance.\n+     *\/\n+    default Map<OptionIdentifier, Object> toMap() {\n+        return StreamSupport.stream(ids().spliterator(), false).collect(toUnmodifiableMap(x -> x, id -> {\n+            return find(id).orElseThrow();\n+        }));\n+    }\n+\n+    \/**\n+     * Creates {@code Options} instance from the map of objects with option\n+     * identifiers and associated option values.\n+     *\n+     * @param map the map of objects with option identifiers and associated option\n+     *            values\n+     * @return a new {@code Options} instance\n+     *\/\n+    public static Options of(Map<? extends WithOptionIdentifier, Object> map) {\n+        return new DefaultOptions(map);\n+    }\n+\n+    \/**\n+     * Creates {@code Options} instance from the map of option identifiers and\n+     * associated option values.\n+     * <p>\n+     * Similar to {@link #of(Map)} method, but {@link #contains(OptionName)} called\n+     * on the return instance will always return {@code false}.\n+     *\n+     * @param map the map of option identifiers and associated option values\n+     * @return a new {@code Options} instance\n+     *\/\n+    public static Options ofIDs(Map<OptionIdentifier, Object> map) {\n+        return new DefaultOptions(map.entrySet().stream().collect(toUnmodifiableMap(e -> {\n+            return new WithOptionIdentifierStub(e.getKey());\n+        }, Map.Entry::getValue)));\n+    }\n+\n+    public static Options concat(Options... options) {\n+        return Stream.of(options).map(Options::toDefaultOptions).reduce(DefaultOptions.EMPTY, DefaultOptions::add);\n+    }\n+\n+    private static DefaultOptions toDefaultOptions(Options v) {\n+        switch (Objects.requireNonNull(v)) {\n+            case DefaultOptions u -> {\n+                return u;\n+            }\n+            case JOptSimpleOptionsBuilder.ExtendedOptions<?> u -> {\n+                return u.toDefaultOptions();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Options.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,427 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.StandardOption.ADD_MODULES;\n+import static jdk.jpackage.internal.cli.StandardOption.INPUT;\n+import static jdk.jpackage.internal.cli.StandardOption.JLINK_OPTIONS;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_IMAGE_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_INSTALLER_SIGN_IDENTITY;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGN;\n+import static jdk.jpackage.internal.cli.StandardOption.MAC_SIGNING_KEY_NAME;\n+import static jdk.jpackage.internal.cli.StandardOption.MAIN_JAR;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE;\n+import static jdk.jpackage.internal.cli.StandardOption.MODULE_PATH;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardOption.TYPE;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.PackageType;\n+\n+\/**\n+ * Analyzes jpackage command line structure.\n+ *\/\n+final class OptionsAnalyzer {\n+\n+    OptionsAnalyzer(Options cmdline, BundlingEnvironment bundlingEnv) {\n+        this(cmdline, getBundlingOperation(cmdline, OperatingSystem.current(), bundlingEnv), false);\n+    }\n+\n+    OptionsAnalyzer(Options cmdline, StandardBundlingOperation bundlingOperation) {\n+        this(cmdline, bundlingOperation, true);\n+    }\n+\n+    private OptionsAnalyzer(Options cmdline, StandardBundlingOperation bundlingOperation, boolean typedOptions) {\n+        this.cmdline = Objects.requireNonNull(cmdline);\n+        this.bundlingOperation = Objects.requireNonNull(bundlingOperation);\n+        this.typedOptions = typedOptions;\n+        hasAppImage = PREDEFINED_APP_IMAGE.containsIn(cmdline);\n+        isRuntimeInstaller = isRuntimeInstaller(cmdline, bundlingOperation);\n+    }\n+\n+    BundlingOperationDescriptor bundlingOperation() {\n+        return bundlingOperation.descriptor();\n+    }\n+\n+    List<ExceptionWithOrigin> findErrors() {\n+        if (hasAppImage && PREDEFINED_RUNTIME_IMAGE.containsIn(cmdline)) {\n+            \/\/ Short circuit this erroneous case as bundling operation is ambiguous.\n+            return List.of(new MutualExclusiveOptions(asOptionList(\n+                    PREDEFINED_RUNTIME_IMAGE, PREDEFINED_APP_IMAGE)).validate(cmdline).orElseThrow());\n+        }\n+\n+        final List<ExceptionWithOrigin> errors = new ArrayList<>();\n+\n+        StandardOption.options().stream()\n+                .filter(cmdline::contains)\n+                .map(Option::spec)\n+                .filter(matchInScope(bundlingOperation).and(matchInScope(bundlingOperationModifiers())).negate())\n+                .map(optionSpec -> {\n+                    var err = onOutOfScopeOption(optionSpec);\n+                    return errorWithOrigin(err, optionSpec);\n+                }).forEach(errors::add);\n+\n+        MUTUAL_EXCLUSIVE_OPTIONS.stream().map(v -> {\n+            return v.validate(cmdline);\n+        }).filter(Optional::isPresent).map(Optional::orElseThrow).forEach(errors::add);\n+\n+        if (isBundlingAppImage() && Stream.of(MODULE, MAIN_JAR).noneMatch(ov -> {\n+            return ov.containsIn(cmdline);\n+        })) {\n+            errors.add(errorWithOrigin(error(\"ERR_NoEntryPoint\")));\n+        }\n+\n+        if (bundlingOperation == StandardBundlingOperation.SIGN_MAC_APP_IMAGE && !MAC_SIGN.containsIn(cmdline)) {\n+            errors.add(errorWithOrigin(error(\"error.app-image.mac-sign.required\")));\n+        }\n+\n+        if (isBuildingAppImage()) {\n+            if (MAIN_JAR.containsIn(cmdline) && !INPUT.containsIn(cmdline)) {\n+                errors.add(errorWithOrigin(error(\"error.no-input-parameter\"), MAIN_JAR.getSpec()));\n+            }\n+\n+            if (MODULE.containsIn(cmdline) && Stream.of(PREDEFINED_RUNTIME_IMAGE, MODULE_PATH).noneMatch(ov -> {\n+                return ov.containsIn(cmdline);\n+            })) {\n+                errors.add(errorWithOrigin(error(\"ERR_MissingArgument2\", PREDEFINED_RUNTIME_IMAGE, MODULE_PATH), MODULE.getSpec()));\n+            }\n+        }\n+\n+        if (typedOptions) {\n+            errors.addAll(findErrorsInTypedOptions());\n+        }\n+\n+        return errors;\n+    }\n+\n+\n+    record ExceptionWithOrigin(Exception error, List<? extends OptionSpec<?>> origin) {\n+        ExceptionWithOrigin {\n+            Objects.requireNonNull(error);\n+            Objects.requireNonNull(origin);\n+        }\n+    }\n+\n+\n+    static Stream<ExceptionWithOrigin> orderErrors(List<OptionName> optionNames, Collection<ExceptionWithOrigin> unorderedErrors) {\n+        Objects.requireNonNull(optionNames);\n+        Objects.requireNonNull(unorderedErrors);\n+        return unorderedErrors.stream().sorted(Comparator.<ExceptionWithOrigin, Integer>comparing(err -> {\n+            \/\/ Return minimal index of an option name from the origin of this error in the `optionNames` list.\n+            return err.origin().stream()\n+                    .map(OptionSpec::names)\n+                    .flatMap(Collection::stream)\n+                    .mapToInt(optionNames::indexOf)\n+                    .filter(idx -> {\n+                        return idx >= 0;\n+                    }).min()\n+                    \/\/ Errors without origin go first.\n+                    .orElse(-1);\n+        }));\n+    }\n+\n+    private List<ExceptionWithOrigin> findErrorsInTypedOptions() {\n+        final List<ExceptionWithOrigin> errors = new ArrayList<>();\n+\n+        if (MAC_APP_STORE.containsIn(cmdline)) {\n+            JLINK_OPTIONS.ifPresentIn(cmdline, jlinkOptions -> {\n+                if (!jlinkOptions.contains(\"--strip-native-commands\")) {\n+                    errors.add(errorWithOrigin(\n+                            error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"),\n+                            Stream.of(MAC_APP_STORE, JLINK_OPTIONS).map(OptionValue::getSpec).toList()));\n+                }\n+            });\n+        }\n+\n+        return errors;\n+    }\n+\n+    private Set<BundlingOperationModifier> bundlingOperationModifiers() {\n+        final Set<BundlingOperationModifier> modifiers = new HashSet<>();\n+        if (isBundlingNativePackage()) {\n+            if (hasAppImage) {\n+                modifiers.add(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE);\n+            }\n+            if (isRuntimeInstaller) {\n+                modifiers.add(BundlingOperationModifier.BUNDLE_RUNTIME);\n+            }\n+        }\n+        return modifiers;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the output of the bundling operation is a new app\n+     * image.\n+     *\n+     * @return {@code true} if the output of the bundling operation is a new app\n+     *         image\n+     *\/\n+    private boolean isBundlingAppImage() {\n+        return StandardBundlingOperation.CREATE_APP_IMAGE.contains(bundlingOperation);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the output of the bundling operation is a new native\n+     * package.\n+     *\n+     * @return {@code true} if the output of the bundling operation is a new native\n+     *         package\n+     *\/\n+    private boolean isBundlingNativePackage() {\n+        return StandardBundlingOperation.CREATE_NATIVE.contains(bundlingOperation);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the output of the bundling operation is either a new\n+     * app image or a new native package.\n+     *\n+     * @return {@code true} if the output of the bundling operation is either a new\n+     *         app image or a new native package\n+     *\/\n+    private boolean isBundling() {\n+        return StandardBundlingOperation.CREATE_BUNDLE.contains(bundlingOperation);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the bundling operation will create an app image as\n+     * an intermediate or final step.\n+     *\n+     * @return {@code true} if the bundling operation will create an app image as\n+     *         an intermediate or final step\n+     *\/\n+    private boolean isBuildingAppImage() {\n+        return bundlingOperationModifiers().isEmpty() && isBundling();\n+    }\n+\n+    private RuntimeException onOutOfScopeOption(OptionSpec<?> optionSpec) {\n+        Objects.requireNonNull(optionSpec);\n+\n+        if (optionSpec.scope().stream()\n+                .filter(StandardBundlingOperation.class::isInstance)\n+                .map(StandardBundlingOperation.class::cast)\n+                .map(StandardBundlingOperation::os).noneMatch(bundlingOperation.os()::equals)) {\n+            \/\/ The option is for different OS.\n+            return error(\"ERR_UnsupportedOption\", mapFormatArguments(optionSpec));\n+        } else if (StandardBundlingOperation.SIGN_MAC_APP_IMAGE.equals(bundlingOperation)) {\n+            \/\/ The option is not applicable when signing a predefined app image.\n+            return error(\"ERR_InvalidOptionWithAppImageSigning\", mapFormatArguments(optionSpec));\n+        } else if (StandardBundlingOperation.CREATE_NATIVE.contains(bundlingOperation) && isRuntimeInstaller) {\n+            \/\/ The option is not applicable when packaging of a runtime in a native bundle.\n+            return error(\"ERR_NoInstallerEntryPoint\", mapFormatArguments(optionSpec));\n+        } else {\n+            return error(\"ERR_InvalidTypeOption\", mapFormatArguments(\n+                    optionSpec, bundlingOperation.packageTypeValue()));\n+        }\n+    }\n+\n+    private Object[] mapFormatArguments(Object... args) {\n+        return MessageFormatUtils.mapFormatArguments(cmdline, args);\n+    }\n+\n+    private static StandardBundlingOperation getBundlingOperation(Options cmdline,\n+            OperatingSystem os, BundlingEnvironment env) {\n+        Objects.requireNonNull(cmdline);\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(env);\n+\n+        final var typeOption = TYPE.getOption();\n+\n+        return cmdline.find(typeOption).map(obj -> {\n+            if (obj instanceof PackageType packageType) {\n+                return packageType;\n+            } else {\n+                return typeOption.spec()\n+                        .converter().orElseThrow()\n+                        .convert(typeOption.spec().name(), StringToken.of(((String[])obj)[0]))\n+                        .orElseThrow();\n+            }\n+        }).map(packageType -> {\n+            \/\/ Find standard bundling operations producing the given package type.\n+            var bundlingOperations = Stream.of(StandardBundlingOperation.values()).filter(op -> {\n+                return op.packageType().equals(packageType);\n+            }).toList();\n+\n+            if (bundlingOperations.isEmpty()) {\n+                \/\/ jpackage internal error: none of the standard bundling operations produce\n+                \/\/ bundles of the `packageType`.\n+                throw new AssertionError(String.format(\n+                        \"None of the standard bundling operations produce bundles of type [%s]\",\n+                        packageType));\n+            } else if (bundlingOperations.size() == 1) {\n+                return bundlingOperations.getFirst();\n+            } else {\n+                \/\/ Multiple standard bundling operations produce the `packageType` package type.\n+                \/\/ Filter those that belong to the current OS\n+                bundlingOperations = bundlingOperations.stream().filter(op -> {\n+                    return op.os().equals(OperatingSystem.current());\n+                }).toList();\n+\n+                if (bundlingOperations.isEmpty()) {\n+                    \/\/ jpackage internal error: none of the standard bundling operations produce\n+                    \/\/ bundles of the `packageType` on the current OS.\n+                    throw new AssertionError(String.format(\n+                            \"None of the standard bundling operations produce bundles of type [%s] on %s\",\n+                            packageType, OperatingSystem.current()));\n+                } else if (bundlingOperations.size() == 1) {\n+                    return bundlingOperations.getFirst();\n+                } else if (StandardBundlingOperation.MACOS_APP_IMAGE.containsAll(bundlingOperations)) {\n+                    if (PREDEFINED_APP_IMAGE.containsIn(cmdline)) {\n+                        return StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+                    } else {\n+                        return StandardBundlingOperation.CREATE_MAC_APP_IMAGE;\n+                    }\n+                } else {\n+                    \/\/ Pick the first one.\n+                    return bundlingOperations.getFirst();\n+                }\n+            }\n+        }).orElseGet(() -> {\n+            \/\/ No package type specified, use the default bundling operation in the given environment.\n+            return env.defaultOperation().map(descriptor -> {\n+                return Stream.of(StandardBundlingOperation.values()).filter(op -> {\n+                    return descriptor.equals(op.descriptor());\n+                }).findFirst().orElseThrow(() -> {\n+                    \/\/ jpackage internal error: none of the standard bundling operations match the\n+                    \/\/ descriptor of the default bundling operation in the given environment.\n+                    throw new AssertionError(String.format(\n+                            \"None of the standard bundling operations match bundling operation descriptor [%s]\",\n+                            descriptor));\n+                });\n+            }).orElseThrow(() -> {\n+                throw new ConfigException(\n+                        I18N.format(\"error.undefined-default-bundling-operation\"),\n+                        I18N.format(\"error.undefined-default-bundling-operation.advice\", TYPE.getSpec().name().formatForCommandLine()));\n+            });\n+        });\n+    }\n+\n+    private static boolean isRuntimeInstaller(Options cmdline, OptionScope bundlingOperation) {\n+        return StandardBundlingOperation.CREATE_BUNDLE.contains(bundlingOperation)\n+                && PREDEFINED_RUNTIME_IMAGE.containsIn(cmdline)\n+                && !PREDEFINED_APP_IMAGE.containsIn(cmdline)\n+                && !MAIN_JAR.containsIn(cmdline)\n+                && !MODULE.containsIn(cmdline);\n+    }\n+\n+    private static Predicate<OptionSpec<?>> matchInScope(Collection<? extends OptionScope> scope) {\n+        Objects.requireNonNull(scope);\n+        return optionSpec -> {\n+            return optionSpec.scope().containsAll(scope);\n+        };\n+    }\n+\n+    private static Predicate<OptionSpec<?>> matchInScope(OptionScope... scope) {\n+        return matchInScope(List.of(scope));\n+    }\n+\n+    private static List<Option> asOptionList(OptionValue<?>... options) {\n+        return Stream.of(options).map(OptionValue::getOption).toList();\n+    }\n+\n+    private static RuntimeException error(String formatId, Object ... args) {\n+        return new JPackageException(MessageFormatUtils.createMessage(formatId, args));\n+    }\n+\n+    private static ExceptionWithOrigin errorWithOrigin(Exception error, OptionSpec<?>... origin) {\n+        return errorWithOrigin(error, List.of(origin));\n+    }\n+\n+    private static ExceptionWithOrigin errorWithOrigin(Exception error, List<? extends OptionSpec<?>> origin) {\n+        return new ExceptionWithOrigin(error, origin);\n+    }\n+\n+\n+    private record MutualExclusiveOptions(List<Option> options, Function<Object[], RuntimeException> createException) {\n+        MutualExclusiveOptions {\n+            options.forEach(Objects::requireNonNull);\n+            if (options.size() < 2) {\n+                throw new IllegalArgumentException();\n+            }\n+            Objects.requireNonNull(createException);\n+        }\n+\n+        Optional<ExceptionWithOrigin> validate(Options cmdline) {\n+            final var detectedOptions = options.stream().filter(cmdline::contains).toList();\n+            if (detectedOptions.size() > 1) {\n+                final var errMesageformatArgs = detectedOptions.stream().map(Option::spec).map(optionSpec -> {\n+                    return MessageFormatUtils.mapFormatArguments(cmdline, optionSpec)[0];\n+                }).toArray();\n+                return Optional.of(errorWithOrigin(\n+                        createException.apply(errMesageformatArgs),\n+                        detectedOptions.stream().map(Option::spec).toList()));\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        MutualExclusiveOptions(List<Option> options) {\n+            this(options, args -> {\n+                return error(\"ERR_MutuallyExclusiveOptions\", args);\n+            });\n+        }\n+    }\n+\n+\n+    private final Options cmdline;\n+    private final StandardBundlingOperation bundlingOperation;\n+    private final boolean typedOptions;\n+    private final boolean hasAppImage;\n+    private final boolean isRuntimeInstaller;\n+\n+    private static final List<MutualExclusiveOptions> MUTUAL_EXCLUSIVE_OPTIONS;\n+\n+    static {\n+        final List<MutualExclusiveOptions> config = new ArrayList<>();\n+\n+        Stream.of(\n+                asOptionList(PREDEFINED_RUNTIME_IMAGE, PREDEFINED_APP_IMAGE),\n+                asOptionList(PREDEFINED_RUNTIME_IMAGE, ADD_MODULES),\n+                asOptionList(PREDEFINED_RUNTIME_IMAGE, JLINK_OPTIONS),\n+                asOptionList(MAC_SIGNING_KEY_NAME, MAC_APP_IMAGE_SIGN_IDENTITY),\n+                asOptionList(MAC_SIGNING_KEY_NAME, MAC_INSTALLER_SIGN_IDENTITY),\n+                asOptionList(MODULE, MAIN_JAR)\n+        ).map(MutualExclusiveOptions::new).forEach(config::add);\n+\n+        MUTUAL_EXCLUSIVE_OPTIONS = List.copyOf(config);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsAnalyzer.java","additions":427,"deletions":0,"binary":false,"changes":427,"status":"added"},{"patch":"@@ -0,0 +1,428 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.counting;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.cli.Option.fromOptionSpecPredicate;\n+import static jdk.jpackage.internal.cli.StandardOption.ADDITIONAL_LAUNCHERS;\n+import static jdk.jpackage.internal.cli.StandardOption.platformOption;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.ConvertedOptionsBuilder;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.OptionsBuilder;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.util.Result;\n+\n+\/**\n+ * Processes jpackage command line.\n+ *\/\n+final class OptionsProcessor {\n+\n+    OptionsProcessor(OptionsBuilder optionsBuilder, CliBundlingEnvironment bundlingEnv) {\n+        this.optionsBuilder = Objects.requireNonNull(optionsBuilder);\n+        this.bundlingEnv = Objects.requireNonNull(bundlingEnv);\n+    }\n+\n+    record ValidatedOptions(Options options, BundlingOperationDescriptor bundlingOperation) {\n+        ValidatedOptions {\n+            Objects.requireNonNull(options);\n+            Objects.requireNonNull(bundlingOperation);\n+        }\n+\n+        String bundleTypeName() {\n+            return bundlingOperation.bundleType();\n+        }\n+    }\n+\n+    Result<ValidatedOptions> validate() {\n+        final Collection<Exception> allErrors = new ArrayList<>();\n+\n+        \/\/ Check for non-option arguments.\n+        validateNonOptionArguments(optionsBuilder).ifPresent(allErrors::add);\n+\n+        \/\/ Parse the command line. The result is Options container of strings.\n+        final var untypedOptions = optionsBuilder.create();\n+\n+        \/\/ Create command line structure analyzer.\n+        final var analyzerResult = Result.create(() -> new OptionsAnalyzer(untypedOptions, bundlingEnv));\n+        if (analyzerResult.hasErrors()) {\n+            \/\/ Failed to derive the bundling operation from the command line.\n+            allErrors.addAll(analyzerResult.mapErrors().errors());\n+            return Result.ofErrors(allErrors);\n+        }\n+\n+        final var analyzer = analyzerResult.orElseThrow();\n+\n+        \/\/ Validate the bundling operation.\n+        final var bundlingOperationResult = validateBundlingOperation(analyzer.bundlingOperation()).map(op -> {\n+            return Map.entry(StandardOption.BUNDLING_OPERATION_DESCRIPTOR, op);\n+        });\n+\n+        bundlingOperationResult.peekErrors(allErrors::addAll);\n+\n+        \/\/ Validate command line structure.\n+        final var structureErrors = analyzer.findErrors();\n+        if (!structureErrors.isEmpty()) {\n+            OptionsAnalyzer.orderErrors(\n+                    optionsBuilder.detectedOptions(),\n+                    structureErrors\n+            ).map(err -> err.error()).forEach(allErrors::add);\n+            return Result.ofErrors(allErrors);\n+        }\n+\n+        final Result<ValidatedOptions> validatedOptionsResult = optionsBuilder\n+                \/\/ Command line structure is valid.\n+                \/\/ Run value converters that will convert strings into objects (e.g.: String -> Path)\n+                .convertedOptions().map(ConvertedOptionsBuilder::create).map(convertedOptions -> {\n+                    return new ValidatedOptions(convertedOptions, analyzer.bundlingOperation());\n+                });\n+\n+        validatedOptionsResult.peekErrors(allErrors::addAll);\n+\n+        if (validatedOptionsResult.hasErrors()) {\n+            \/\/ There are errors in the command line.\n+            \/\/ Inspect additional launcher names to see if there are duplicates.\n+            final var addLaunchers = untypedOptions.find(StandardOption.ADD_LAUNCHER_INTERNAL.id())\n+                    .map(String[].class::cast)\n+                    .map(Stream::of)\n+                    .orElseGet(Stream::of).map(addLauncherStr -> {\n+                        return addLauncherStr.split(\"=\", 2)[0];\n+                    }).map(addLauncherName -> {\n+                        return Options.of(Map.of(StandardOption.NAME, addLauncherName));\n+                    }).toArray(Options[]::new);\n+\n+            Map<WithOptionIdentifier, Object> options = new HashMap<>();\n+            options.put(ADD_LAUNCHER_INTERNAL, addLaunchers);\n+            untypedOptions.find(StandardOption.NAME.id()).ifPresent(strArray -> {\n+                options.put(StandardOption.NAME, ((String[])strArray)[0]);\n+            });\n+\n+            var result = validateAdditionalLaunchers(Options.of(options));\n+            result.peekErrors(allErrors::addAll);\n+        }\n+\n+        final var validatedAddLaunchersResult = validatedOptionsResult.value()\n+                .map(ValidatedOptions::options)\n+                .map(this::validateAdditionalLaunchers).map(result -> {\n+                    return result.map(addLaunchers -> {\n+                        return Map.entry(ADDITIONAL_LAUNCHERS, addLaunchers);\n+                    });\n+                }).orElseGet(() -> {\n+                    return Result.ofValue(Map.entry(ADDITIONAL_LAUNCHERS, List.of()));\n+                });\n+\n+        validatedAddLaunchersResult.peekErrors(allErrors::addAll);\n+\n+        final var validatedFaResult = Result.ofValue(Map.entry(\n+                StandardOption.FILE_ASSOCIATIONS,\n+                validatedOptionsResult.value()\n+                        .map(ValidatedOptions::options)\n+                        .map(FILE_ASSOCIATIONS_INTERNAL::getFrom)\n+                        .orElseGet(List::of)\n+        ));\n+\n+        validatedOptionsResult.value().ifPresent(validatedOptions -> {\n+            \/\/ Second pass: analyze command line options with values converted from strings.\n+            var errors = new OptionsAnalyzer(validatedOptions.options(),\n+                    StandardBundlingOperation.valueOf(validatedOptions.bundlingOperation()).orElseThrow(() -> {\n+                        \/\/ The bundle operation descriptor should correspond to one of the standard bundling operations.\n+                        throw new AssertionError();\n+                    })).findErrors();\n+            OptionsAnalyzer.orderErrors(\n+                    optionsBuilder.detectedOptions(),\n+                    errors\n+            ).map(err -> err.error()).forEach(allErrors::add);\n+        });\n+\n+        if (!allErrors.isEmpty()) {\n+            return Result.ofErrors(allErrors);\n+        } else {\n+            \/\/ No errors.\n+            \/\/ Add synthesized option values and return the result.\n+            final Map<WithOptionIdentifier, Object> extra = Stream.of(\n+                    bundlingOperationResult,\n+                    validatedAddLaunchersResult,\n+                    validatedFaResult\n+            ).map(Result::orElseThrow).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            return validatedOptionsResult.map(validatedOptions -> {\n+                return new ValidatedOptions(\n+                        Options.concat(\n+                                Options.of(extra),\n+                                validatedOptions.options().copyWithout(ADD_LAUNCHER_INTERNAL.id(), FILE_ASSOCIATIONS_INTERNAL.id())),\n+                        validatedOptions.bundlingOperation());\n+            });\n+        }\n+    }\n+\n+    private static Optional<? extends Exception> validateNonOptionArguments(OptionsBuilder optionsBuilder) {\n+        final var nonOptionArguments = optionsBuilder.nonOptionArguments();\n+        if (nonOptionArguments.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(new JPackageException(I18N.format(\"error.non-option-arguments\", nonOptionArguments.size())));\n+        }\n+    }\n+\n+    private Result<BundlingOperationDescriptor> validateBundlingOperation(BundlingOperationDescriptor bundlingOperation) {\n+        Objects.requireNonNull(bundlingOperation);\n+        try {\n+            var errors = bundlingEnv.configurationErrors(bundlingOperation);\n+            if (errors.isEmpty()) {\n+                return Result.ofValue(bundlingOperation);\n+            } else {\n+                return Result.ofErrors(errors);\n+            }\n+        } catch (NoSuchElementException ex) {\n+            \/\/ Bundling environment doesn't recognize the descriptor of a bundling operation.\n+            return Result.ofError(new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", bundlingOperation.bundleType())));\n+        }\n+    }\n+\n+    Collection<? extends Exception> runBundling(ValidatedOptions validatedOptions) {\n+        try {\n+            bundlingEnv.createBundle(validatedOptions.bundlingOperation(), validatedOptions.options());\n+            return List.of();\n+        } catch (Exception ex) {\n+            return List.of(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Loads property file and processes properties as a command line.\n+     * <p>\n+     * Unrecognized options will be silently ignored.\n+     *\n+     * @param file             the source property file\n+     * @param options          the recognized options\n+     * @param optionSpecMapper optional option spec mapper\n+     * @return {@link Options} instance containing validated property values or the list\n+     *         of errors occured during option values processing\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     *\/\n+    static Result<Options> processPropertyFile(Path file, Collection<Option> options,\n+            Optional<UnaryOperator<OptionSpec<?>>> optionSpecMapper) {\n+        final var props = new Properties();\n+        try (var in = Files.newBufferedReader(file)) {\n+            props.load(in);\n+        } catch (IOException ex) {\n+            return Result.ofError(ex);\n+        }\n+\n+        \/\/ Convert the property file into command line arguments.\n+        \/\/ Silently ignore unknown properties.\n+        final var args = options.stream().map(option -> {\n+            return option.spec().names().stream().map(optionName -> {\n+                return Optional.ofNullable(props.getProperty(optionName.name())).map(stringOptionValue -> {\n+                    return Stream.of(optionName.formatForCommandLine(), stringOptionValue);\n+                }).orElse(null);\n+            }).flatMap(x -> x);\n+        }).flatMap(x -> x).filter(Objects::nonNull).toArray(String[]::new);\n+\n+        \/\/ Feed the contents of the property file as a command line arguments to the command line parser.\n+        final var builder = new JOptSimpleOptionsBuilder().options(options);\n+\n+        optionSpecMapper.ifPresent(builder::optionSpecMapper);\n+\n+        final var result = builder.create().apply(args)\n+                .flatMap(OptionsBuilder::convertedOptions)\n+                .map(ConvertedOptionsBuilder::create);\n+\n+        return result.map(cmdline -> {\n+            return cmdline.copyWithDefaultValue(StandardOption.SOURCE_PROPERY_FILE, file);\n+        });\n+    }\n+\n+    static UnaryOperator<OptionSpec<?>> optionSpecMapper(OperatingSystem os, BundlingEnvironment bundlingEnv) {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(bundlingEnv);\n+\n+        var context = new StandardOptionContext(os);\n+\n+        return optionSpec -> {\n+            if (optionSpec.name().equals(StandardOption.ADD_LAUNCHER_INTERNAL.getSpec().name())) {\n+                final var options = filterForPlatform(os, StandardOption.launcherOptions());\n+                return optionSpec.copyWithConverter(new OptionsConverter<>(addLauncher -> {\n+                    var localContext = context.forFile(addLauncher.propertyFile());\n+                    var optionValues = processPropertyFile(addLauncher.propertyFile(), options, Optional.of(localContext::mapOptionSpec));\n+                    return optionValues.map(o -> {\n+                        return o.copyWithParent(Options.of(Map.of(StandardOption.NAME, addLauncher.name())));\n+                    });\n+                }, StandardOption.ADD_LAUNCHER_INTERNAL.getSpec()));\n+            } else if (optionSpec.name().equals(StandardOption.FILE_ASSOCIATIONS_INTERNAL.getSpec().name())) {\n+                final var options = filterForPlatform(os, StandardFaOption.options());\n+                return optionSpec.copyWithConverter(new OptionsConverter<>(fa -> {\n+                    var localContext = context.forFile(fa);\n+                    return processPropertyFile(fa, options, Optional.of(localContext::mapOptionSpec));\n+                }, StandardOption.FILE_ASSOCIATIONS_INTERNAL.getSpec()));\n+            } else {\n+                return context.mapOptionSpec(optionSpec);\n+            }\n+        };\n+    }\n+\n+    private Result<List<Options>> validateAdditionalLaunchers(Options cmdline) {\n+\n+        final var addLaunchers = ADD_LAUNCHER_INTERNAL.getFrom(cmdline);\n+\n+        final List<Exception> errors = new ArrayList<>();\n+\n+        \/\/ Count launcher names.\n+        final var names = Stream.concat(\n+                StandardOption.NAME.findIn(cmdline).stream(),\n+                addLaunchers.stream().map(StandardOption.NAME::getFrom)\n+        ).collect(groupingBy(x -> x, counting()));\n+\n+        \/\/ Sort duplicated names alphabetically\n+        names.entrySet().stream().filter(e -> {\n+            \/\/ Filter duplicated names.\n+            return e.getValue() > 1;\n+        }).map(Map.Entry::getKey).sorted().map(name -> {\n+            return new JPackageException(I18N.format(\"error.launcher-duplicate-name\", name));\n+        }).forEach(errors::add);\n+\n+        if (!errors.isEmpty()) {\n+            return Result.ofErrors(errors);\n+        } else {\n+            return Result.ofValue(addLaunchers.stream().map(addLauncherOptionValues -> {\n+\n+                \/\/\n+                \/\/ For additional launcher:\n+                \/\/  - Override name.\n+                \/\/  - Ignore icon configured for the app\/main launcher.\n+                \/\/  - Ignore shortcuts configured for the app\/main launcher.\n+                \/\/  - If the additional launcher is modular, delete non-modular options of the main launcher.\n+                \/\/  - If the additional launcher is non-modular, delete modular options of the main launcher.\n+                \/\/  - Combine other option values with the main option values.\n+                \/\/\n+\n+                List<OptionValue<?>> excludes = new ArrayList<>();\n+                excludes.add(StandardOption.ICON);\n+                excludes.add(StandardOption.LINUX_SHORTCUT_HINT);\n+                excludes.add(StandardOption.WIN_MENU_HINT);\n+                excludes.add(StandardOption.WIN_SHORTCUT_HINT);\n+                if (StandardOption.MODULE.containsIn(addLauncherOptionValues)) {\n+                    excludes.add(StandardOption.MAIN_JAR);\n+                    excludes.add(StandardOption.APPCLASS);\n+                }\n+                if (StandardOption.MAIN_JAR.containsIn(addLauncherOptionValues)) {\n+                    excludes.add(StandardOption.MODULE);\n+                }\n+\n+                return Options.concat(\n+                        addLauncherOptionValues,\n+                        cmdline.copyWithout(excludes.stream().map(WithOptionIdentifier::id).toList()));\n+            }).toList());\n+        }\n+    }\n+\n+    private static Collection<Option> filterForPlatform(OperatingSystem os, Collection<Option> options) {\n+        return options.stream().filter(fromOptionSpecPredicate(platformOption(os))).toList();\n+    }\n+\n+\n+    private static final class OptionsConverter<T> implements OptionArrayValueConverter<Options> {\n+\n+        OptionsConverter(Function<T, Result<Options>> mapper, OptionSpec<T[]> optionSpec) {\n+            this(mapper, optionSpec.<T>arrayValueConverter().orElseThrow());\n+        }\n+\n+        OptionsConverter(Function<T, Result<Options>> mapper, OptionArrayValueConverter<T> converter) {\n+            this.mapper = Objects.requireNonNull(mapper);\n+            this.converter = Objects.requireNonNull(converter);\n+        }\n+\n+        static <T> OptionValue<List<Options>> optionValue(OptionIdentifier id) {\n+            return OptionValue.<Options[]>build().id(id).to(List::of).defaultValue(List.of()).create();\n+        }\n+\n+        @Override\n+        public Result<Options[]> convert(OptionName optionName, StringToken optionValue) {\n+            return converter.convert(optionName, optionValue).flatMap(arr -> {\n+                return Stream.of(arr).map(mapper).reduce(Result.<List<Options>>ofValue(new ArrayList<>()), (result, o) -> {\n+                    if (Result.allHaveValues(result, o)) {\n+                        return result.map(v -> {\n+                            v.add(o.orElseThrow());\n+                            return v;\n+                        });\n+                    } else {\n+                        return o.mapErrors();\n+                    }\n+                }, (x, y) -> {\n+                    var errors = Stream.of(x, y).map(Result::errors).flatMap(Collection::stream).toList();\n+                    if (errors.isEmpty()) {\n+                        return Result.ofValue(Stream.of(x, y).map(Result::orElseThrow).flatMap(Collection::stream).toList());\n+                    } else {\n+                        return Result.ofErrors(errors);\n+                    }\n+                }).map(v -> v.toArray(Options[]::new));\n+            });\n+        }\n+\n+        @Override\n+        public Class<Options[]> valueType() {\n+            return Options[].class;\n+        }\n+\n+        @Override\n+        public String[] tokenize(String str) {\n+            return converter.tokenize(str);\n+        }\n+\n+        private final OptionArrayValueConverter<T> converter;\n+        private final Function<T, Result<Options>> mapper;\n+    }\n+\n+\n+    private final JOptSimpleOptionsBuilder.OptionsBuilder optionsBuilder;\n+    private final CliBundlingEnvironment bundlingEnv;\n+\n+    private static final OptionValue<List<Options>> ADD_LAUNCHER_INTERNAL =\n+            OptionsConverter.optionValue(StandardOption.ADD_LAUNCHER_INTERNAL.id());\n+\n+    private static final OptionValue<List<Options>> FILE_ASSOCIATIONS_INTERNAL =\n+            OptionsConverter.optionValue(StandardOption.FILE_ASSOCIATIONS_INTERNAL.id());\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionsProcessor.java","additions":428,"deletions":0,"binary":false,"changes":428,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.fromOptionName;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+\n+\/**\n+ * jpackage options in the app image (\".jpackage.xml\") file\n+ *\/\n+public final class StandardAppImageFileOption {\n+\n+    private StandardAppImageFileOption() {\n+    }\n+\n+\n+    public enum AppImageFileOptionScope implements OptionScope {\n+        APP,\n+        LAUNCHER,\n+        ;\n+\n+        public Stream<? extends OptionValue<?>> options(OperatingSystem os) {\n+            var scope = StandardBundlingOperation.ofPlatform(os).collect(toSet());\n+            return options().filter(ov -> {\n+                return !Collections.disjoint(ov.getSpec().scope(), scope);\n+            });\n+        }\n+\n+        public Stream<? extends OptionValue<?>> options() {\n+            return Utils.getOptionsWithSpecs(StandardAppImageFileOption.class).filter(ov -> {\n+                return ov.getSpec().scope().contains(AppImageFileOptionScope.this);\n+            });\n+        }\n+\n+        public Options parse(Path appImageFile, Map<String, String> properties, OperatingSystem os) throws InvalidOptionValueException {\n+            return parseProperties(appImageFile, properties, os, options().map(OptionValue::getOption));\n+        }\n+    }\n+\n+\n+    private enum MandatoryOption implements OptionScope {\n+        VALUE;\n+    }\n+\n+\n+    \/**\n+     * The name of a launcher.\n+     *\/\n+    public static final OptionValue<String> LAUNCHER_NAME = stringOption(\"name\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .inScope(MandatoryOption.VALUE)\n+            .toOptionValueBuilder().id(StandardOption.NAME.id()).create();\n+\n+    \/**\n+     * The version of the application.\n+     *\/\n+    public static final OptionValue<String> APP_VERSION = stringOption(\"app-version\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .inScope(MandatoryOption.VALUE)\n+            .toOptionValueBuilder().id(StandardOption.APP_VERSION.id()).create();\n+\n+    \/**\n+     * Should install a launcher as a service?\n+     *\/\n+    public static final OptionValue<Boolean> LAUNCHER_AS_SERVICE = booleanOption(\"service\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.LAUNCHER_AS_SERVICE.id()).create();\n+\n+    \/**\n+     * The description of a launcher.\n+     *\/\n+    public static final OptionValue<String> DESCRIPTION = stringOption(\"description\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .inScope(MandatoryOption.VALUE)\n+            .toOptionValueBuilder().id(StandardOption.DESCRIPTION.id()).create();\n+\n+\n+    \/\/\n+    \/\/ Linux-specific\n+    \/\/\n+\n+    \/**\n+     * Configuration of the shortcut for a launcher. Linux-only.\n+     *\/\n+    public static final OptionValue<LauncherShortcut> LINUX_LAUNCHER_SHORTCUT = launcherShortcutOption(\"linux-shortcut\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.LINUX_SHORTCUT_HINT.id()).create();\n+\n+\n+    \/\/\n+    \/\/ Windows-specific\n+    \/\/\n+\n+    \/**\n+     * Configuration of the desktop shortcut for a launcher. Windows-only.\n+     *\/\n+    public static final OptionValue<LauncherShortcut> WIN_LAUNCHER_DESKTOP_SHORTCUT = launcherShortcutOption(\"win-shortcut\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.WIN_SHORTCUT_HINT.id()).create();\n+\n+    \/**\n+     * Configuration of the start menu shortcut for a launcher. Windows-only.\n+     *\/\n+    public static final OptionValue<LauncherShortcut> WIN_LAUNCHER_MENU_SHORTCUT = launcherShortcutOption(\"win-menu\")\n+            .inScope(AppImageFileOptionScope.LAUNCHER)\n+            .toOptionValueBuilder().id(StandardOption.WIN_MENU_HINT.id()).create();\n+\n+\n+    \/\/\n+    \/\/ macOS-specific\n+    \/\/\n+\n+    \/**\n+     * Fully-qualified name of the main class of the main launcher.\n+     *\/\n+    public static final OptionValue<String> MAC_MAIN_CLASS = stringOption(\"main-class\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .inScope(MandatoryOption.VALUE)\n+            .mutate(setPlatformScope(OperatingSystem.MACOS))\n+            .validator(StandardValidator.IS_CLASSNAME)\n+            \/\/ In case of validation failure, report it with\n+            \/\/ an exception of type InvalidOptionValueException with empty message.\n+            .validatorExceptionFactory(\n+                    OptionValueExceptionFactory.build(InvalidOptionValueException::new)\n+                            .messageFormatter((_, _) -> \"\") \/\/ just a stub\n+                            .create()\n+            )\n+            .validatorExceptionFormatString(\"\") \/\/ just a stub, not used\n+            .toOptionValueBuilder().id(StandardOption.APPCLASS.id()).create();\n+\n+    \/**\n+     * Is an application is for the App Store. macOS-only.\n+     *\/\n+    public static final OptionValue<Boolean> MAC_APP_STORE = booleanOption(\"app-store\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .mutate(setPlatformScope(OperatingSystem.MACOS))\n+            .toOptionValueBuilder().id(StandardOption.MAC_APP_STORE.id()).create();\n+\n+    \/**\n+     * Is an application image is signed. macOS-only.\n+     *\/\n+    public static final OptionValue<Boolean> MAC_SIGNED = booleanOption(\"signed\")\n+            .inScope(AppImageFileOptionScope.APP)\n+            .mutate(setPlatformScope(OperatingSystem.MACOS))\n+            .toOptionValueBuilder().id(StandardOption.MAC_SIGN.id()).create();\n+\n+\n+    public static final class InvalidOptionValueException extends RuntimeException {\n+\n+        InvalidOptionValueException(String str, Throwable t) {\n+            super(str, t);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    public static final class MissingMandatoryOptionException extends RuntimeException {\n+\n+        MissingMandatoryOptionException(String str) {\n+            super(str);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .description(\"\")\n+                .scope(fromOptionName(name))\n+                .valuePattern(\"\");\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).mutate(StandardOption.stringOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).mutate(StandardOption.booleanOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<LauncherShortcut> launcherShortcutOption(String name) {\n+        return option(name, LauncherShortcut.class).mutate(StandardOption.launcherShortcutOptionMutator());\n+    }\n+\n+    private static Options parseProperties(\n+            Path appImageFile,\n+            Map<String, String> properties,\n+            OperatingSystem os,\n+            Stream<Option> options) throws InvalidOptionValueException, MissingMandatoryOptionException {\n+\n+        var scope = StandardBundlingOperation.ofPlatform(os).collect(toSet());\n+\n+        var context = new StandardOptionContext(os).forFile(appImageFile);\n+\n+        return Options.of(options.filter(option -> {\n+            return !Collections.disjoint(option.spec().scope(), scope);\n+        }).map(option -> {\n+            var spec = context.mapOptionSpec(option.spec());\n+            var strValue = Optional.ofNullable(properties.get(spec.name().name()));\n+\n+            if (strValue.isEmpty() && spec.scope().contains(MandatoryOption.VALUE)) {\n+                throw new MissingMandatoryOptionException(String.format(\"Missing mandatory '%s' property\", spec.name().name()));\n+            }\n+\n+            return strValue.map(v -> {\n+                return spec.converter().orElseThrow().convert(spec.name(), StringToken.of(v)).orElseThrow();\n+            }).map(v -> {\n+                return Map.entry(option, v);\n+            });\n+        }).filter(Optional::isPresent).map(Optional::get).collect(toMap(Map.Entry::getKey, Map.Entry::getValue)));\n+    }\n+\n+    private static <T> Consumer<OptionSpecBuilder<T>> setPlatformScope(OperatingSystem os) {\n+        return builder -> {\n+            builder.outOfScope(StandardBundlingOperation.values()).inScope(StandardBundlingOperation.ofPlatform(os).toList());\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardAppImageFileOption.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.model.AppImagePackageType.APP_IMAGE;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.SetBuilder;\n+\n+\n+\/**\n+ * Standard jpackage operations.\n+ *\/\n+public enum StandardBundlingOperation implements BundlingOperationOptionScope {\n+    CREATE_WIN_APP_IMAGE(APP_IMAGE, \"^(?!(linux-|mac-|win-exe-|win-msi-))\", OperatingSystem.WINDOWS),\n+    CREATE_LINUX_APP_IMAGE(APP_IMAGE, \"^(?!(win-|mac-|linux-rpm-|linux-deb-))\", OperatingSystem.LINUX),\n+    CREATE_MAC_APP_IMAGE(APP_IMAGE, \"^(?!(linux-|win-|mac-dmg-|mac-pkg-))\", OperatingSystem.MACOS),\n+    CREATE_WIN_EXE(StandardPackageType.WIN_EXE, \"^(?!(linux-|mac-|win-msi-))\", OperatingSystem.WINDOWS),\n+    CREATE_WIN_MSI(StandardPackageType.WIN_MSI, \"^(?!(linux-|mac-|win-exe-))\", OperatingSystem.WINDOWS),\n+    CREATE_LINUX_RPM(StandardPackageType.LINUX_RPM, \"^(?!(win-|mac-|linux-deb-))\", OperatingSystem.LINUX),\n+    CREATE_LINUX_DEB(StandardPackageType.LINUX_DEB, \"^(?!(win-|mac-|linux-rpm-))\", OperatingSystem.LINUX),\n+    CREATE_MAC_PKG(StandardPackageType.MAC_PKG, \"^(?!(linux-|win-|mac-dmg-))\", OperatingSystem.MACOS),\n+    CREATE_MAC_DMG(StandardPackageType.MAC_DMG, \"^(?!(linux-|win-|mac-pkg-))\", OperatingSystem.MACOS),\n+    SIGN_MAC_APP_IMAGE(APP_IMAGE, OperatingSystem.MACOS, \"sign\");\n+\n+    StandardBundlingOperation(PackageType packageType, String optionNameRegexp, OperatingSystem os, String descriptorVerb) {\n+        this.packageType = Objects.requireNonNull(packageType);\n+        optionNamePredicate = Pattern.compile(optionNameRegexp).asPredicate();\n+        this.os = Objects.requireNonNull(os);\n+        this.descriptorVerb = Objects.requireNonNull(descriptorVerb);\n+    }\n+\n+    StandardBundlingOperation(PackageType packageType, String optionNameRegexp, OperatingSystem os) {\n+        this(packageType, optionNameRegexp, os, \"create\");\n+    }\n+\n+    StandardBundlingOperation(PackageType packageType, OperatingSystem os, String descriptorVerb) {\n+        this.packageType = Objects.requireNonNull(packageType);\n+        optionNamePredicate = v -> false;\n+        this.os = Objects.requireNonNull(os);\n+        this.descriptorVerb = Objects.requireNonNull(descriptorVerb);\n+    }\n+\n+    OperatingSystem os() {\n+        return os;\n+    }\n+\n+    public String packageTypeValue() {\n+        if (packageType.equals(APP_IMAGE)) {\n+            return \"app-image\";\n+        } else {\n+            return ((StandardPackageType)packageType).suffix().substring(1);\n+        }\n+    }\n+\n+    public PackageType packageType() {\n+        return packageType;\n+    }\n+\n+    @Override\n+    public BundlingOperationDescriptor descriptor() {\n+        return new BundlingOperationDescriptor(os(), packageTypeValue(), descriptorVerb);\n+    }\n+\n+    public static Optional<StandardBundlingOperation> valueOf(BundlingOperationDescriptor descriptor) {\n+        Objects.requireNonNull(descriptor);\n+        return Stream.of(values()).filter(op -> {\n+            return op.descriptor().equals(descriptor);\n+        }).findFirst();\n+    }\n+\n+    static Stream<StandardBundlingOperation> ofPlatform(OperatingSystem os) {\n+        return Stream.of(values()).filter(platform(os));\n+    }\n+\n+    static Set<BundlingOperationOptionScope> fromOptionName(String optionName) {\n+        Objects.requireNonNull(optionName);\n+        return Stream.of(StandardBundlingOperation.values()).filter(v -> {\n+            return v.optionNamePredicate.test(optionName);\n+        }).collect(Collectors.toUnmodifiableSet());\n+    }\n+\n+    static Predicate<StandardBundlingOperation> platform(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        return op -> {\n+            return  op.os() == os;\n+        };\n+    }\n+\n+    static Stream<StandardBundlingOperation> narrow(Stream<OptionScope> scope) {\n+        return scope.filter(StandardBundlingOperation.class::isInstance).map(StandardBundlingOperation.class::cast);\n+    }\n+\n+    static final Set<BundlingOperationOptionScope> WINDOWS_CREATE_BUNDLE = Set.of(\n+            CREATE_WIN_APP_IMAGE, CREATE_WIN_MSI, CREATE_WIN_EXE);\n+\n+    static final Set<BundlingOperationOptionScope> LINUX_CREATE_BUNDLE = Set.of(\n+            CREATE_LINUX_APP_IMAGE, CREATE_LINUX_RPM, CREATE_LINUX_DEB);\n+\n+    static final Set<BundlingOperationOptionScope> MACOS_CREATE_BUNDLE = Set.of(\n+            CREATE_MAC_APP_IMAGE, CREATE_MAC_DMG, CREATE_MAC_PKG);\n+\n+    static final Set<BundlingOperationOptionScope> WINDOWS_CREATE_NATIVE = Set.of(\n+            CREATE_WIN_MSI, CREATE_WIN_EXE);\n+\n+    static final Set<BundlingOperationOptionScope> LINUX_CREATE_NATIVE = Set.of(\n+            CREATE_LINUX_RPM, CREATE_LINUX_DEB);\n+\n+    static final Set<BundlingOperationOptionScope> MACOS_CREATE_NATIVE = Set.of(\n+            CREATE_MAC_DMG, CREATE_MAC_PKG);\n+\n+    static final Set<BundlingOperationOptionScope> WINDOWS = WINDOWS_CREATE_BUNDLE;\n+\n+    static final Set<BundlingOperationOptionScope> LINUX = LINUX_CREATE_BUNDLE;\n+\n+    static final Set<BundlingOperationOptionScope> MACOS = SetBuilder.build(\n+            BundlingOperationOptionScope.class).add(MACOS_CREATE_BUNDLE).add(SIGN_MAC_APP_IMAGE).create();\n+\n+    static final Set<BundlingOperationOptionScope> MACOS_APP_IMAGE = Set.of(\n+            SIGN_MAC_APP_IMAGE, CREATE_MAC_APP_IMAGE);\n+\n+    static final Set<BundlingOperationOptionScope> MAC_SIGNING = MACOS;\n+\n+    static final Set<BundlingOperationOptionScope> CREATE_APP_IMAGE = Set.of(\n+            CREATE_WIN_APP_IMAGE, CREATE_LINUX_APP_IMAGE, CREATE_MAC_APP_IMAGE);\n+\n+    static final Set<BundlingOperationOptionScope> CREATE_NATIVE = Set.of(\n+            CREATE_WIN_MSI, CREATE_WIN_EXE,\n+            CREATE_LINUX_RPM, CREATE_LINUX_DEB,\n+            CREATE_MAC_DMG, CREATE_MAC_PKG);\n+\n+    static final Set<BundlingOperationOptionScope> CREATE_BUNDLE = Stream.of(\n+            CREATE_APP_IMAGE,\n+            CREATE_NATIVE\n+    ).flatMap(Set::stream).collect(Collectors.toUnmodifiableSet());\n+\n+    private final Predicate<String> optionNamePredicate;\n+    private final OperatingSystem os;\n+    private final PackageType packageType;\n+    private final String descriptorVerb;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardBundlingOperation.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.toList;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\/**\n+ * jpackage file association options\n+ *\/\n+public final class StandardFaOption {\n+\n+    private StandardFaOption() {\n+    }\n+\n+    public static final OptionValue<String> DESCRIPTION = stringOption(\"description\").create();\n+\n+    public static final OptionValue<Path> ICON = fileOption(\"icon\").create();\n+\n+    public static final OptionValue<List<String>> EXTENSIONS = stringOption(\"extension\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    public static final OptionValue<List<String>> CONTENT_TYPE = stringOption(\"mime-type\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    \/\/\n+    \/\/ MacOS-specific\n+    \/\/\n+\n+    public static final OptionValue<String> MAC_CFBUNDLETYPEROLE = stringOption(\"mac.CFBundleTypeRole\").create();\n+\n+    public static final OptionValue<String> MAC_LSHANDLERRANK = stringOption(\"mac.LSHandlerRank\").create();\n+\n+    public static final OptionValue<String> MAC_NSSTORETYPEKEY = stringOption(\"mac.NSPersistentStoreTypeKey\").create();\n+\n+    public static final OptionValue<String> MAC_NSDOCUMENTCLASS = stringOption(\"mac.NSDocumentClass\").create();\n+\n+    public static final OptionValue<Boolean> MAC_LSTYPEISPACKAGE = booleanOption(\"mac.LSTypeIsPackage\").create();\n+\n+    public static final OptionValue<Boolean> MAC_LSDOCINPLACE = booleanOption(\"mac.LSSupportsOpeningDocumentsInPlace\").create();\n+\n+    public static final OptionValue<Boolean> MAC_UIDOCBROWSER = booleanOption(\"mac.UISupportsDocumentBrowser\").create();\n+\n+    public static final OptionValue<List<String>> MAC_NSEXPORTABLETYPES = stringOption(\"mac.NSExportableTypes\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    public static final OptionValue<List<String>> MAC_UTTYPECONFORMSTO = stringOption(\"mac.UTTypeConformsTo\").tokenizer(\"(,|\\\\s)+\").createArray(toList());\n+\n+    \/**\n+     * Returns public and package-private options with option specs defined in\n+     * {@link StandardFaOption} class.\n+     *\n+     * @return public and package-private options defined in\n+     *         {@link StandardFaOption} class\n+     *\/\n+    static Set<Option> options() {\n+        return Utils.getOptionsWithSpecs(StandardFaOption.class).map(OptionValue::getOption).collect(toUnmodifiableSet());\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .description(\"\")\n+                .scope(scopeFromOptionName(name))\n+                .valuePattern(\"\");\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).mutate(StandardOption.stringOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Path> fileOption(String name) {\n+        return option(name, Path.class).mutate(StandardOption.fileOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).mutate(StandardOption.booleanOptionMutator()).defaultValue(null);\n+    }\n+\n+    private static Set<? extends OptionScope> scopeFromOptionName(String name) {\n+        if (name.startsWith(\"mac.\")) {\n+            return Set.of(StandardBundlingOperation.CREATE_MAC_PKG);\n+        } else {\n+            return StandardBundlingOperation.CREATE_NATIVE;\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardFaOption.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,398 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.cli.HelpFormatter.eol;\n+import static jdk.jpackage.internal.cli.StandardOption.platformOption;\n+import static jdk.jpackage.internal.cli.StandardOption.sharedOption;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.HelpFormatter.ConsoleOptionFormatter;\n+import jdk.jpackage.internal.cli.HelpFormatter.ConsoleOptionGroupFormatter;\n+import jdk.jpackage.internal.cli.HelpFormatter.OptionFormatter;\n+import jdk.jpackage.internal.cli.HelpFormatter.OptionGroup;\n+import jdk.jpackage.internal.cli.HelpFormatter.OptionGroupFormatter;\n+import jdk.jpackage.internal.util.StringBundle;\n+\n+\/**\n+ * jpackage help formatter\n+ *\/\n+final class StandardHelpFormatter {\n+\n+    enum OptionGroupID {\n+        SAMPLES(\"sample\", OptionGroupContent::sampleGroupContent),\n+\n+        GENERIC_OPTIONS(\"generic\", OptionGroupContent::genericGroupContent),\n+\n+        RUNTIME_IMAGE_OPTIONS(\"runtime-image\", OptionGroupContent::runtimeImageGroupContent),\n+\n+        APPLICATION_IMAGE_OPTIONS(\"app-image\", OptionGroupContent::appImageGroupContent),\n+\n+        LAUNCHER_OPTIONS_SHARED(\"launcher\", OptionGroupContent::launcherGroupContent),\n+        LAUNCHER_OPTIONS_PLATFORM(\"launcher-platform\", OptionGroupContent::launcherPlatformGroupContent),\n+\n+        PACKAGE_OPTIONS_SHARED(\"package\", OptionGroupContent::nativePackageGroupContent),\n+        PACKAGE_OPTIONS_PLATFORM(\"package-platform\", OptionGroupContent::nativePackagePlatformGroupContent),\n+        ;\n+\n+        OptionGroupID(String name, Function<OperatingSystem, OptionGroupContent> optionGroupContentCreator) {\n+            this.name = \"help.option-group.\" + Objects.requireNonNull(name);\n+            this.optionGroupContentCreator = Objects.requireNonNull(optionGroupContentCreator);\n+        }\n+\n+        String groupName() {\n+            return name;\n+        }\n+\n+        Optional<OptionGroup> createNonEmptyOptionGroup(OperatingSystem os) {\n+            var optionGroup = optionGroupContentCreator.apply(os).createOptionGroup(name);\n+            if (optionGroup.options().isEmpty()) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(optionGroup);\n+            }\n+        }\n+\n+        private final String name;\n+        private final Function<OperatingSystem, OptionGroupContent> optionGroupContentCreator;\n+    }\n+\n+    static final class OptionGroupContent {\n+\n+        static OptionGroupContent sampleGroupContent(OperatingSystem os) {\n+            List<String> ids = new ArrayList<>();\n+            ids.add(\"help.option-group.sample.create-native-package\");\n+            ids.add(\"help.option-group.sample.create-app-image\");\n+            ids.add(\"help.option-group.sample.create-runtime-installer\");\n+            if (os.equals(OperatingSystem.MACOS)) {\n+                ids.add(\"help.option-group.sample.sign-app-image\");\n+            }\n+            return new OptionGroupContent(ids.stream().map(descriptionId -> {\n+                return dummyOptionSpec(descriptionId, descriptionId);\n+            }).toList());\n+        }\n+\n+        static OptionGroupContent genericGroupContent(OperatingSystem os) {\n+            return shared(os).options(genericOptions()).create();\n+        }\n+\n+        static OptionGroupContent runtimeImageGroupContent(OperatingSystem os) {\n+            return shared(os).options(runtimeImageOptions()).create();\n+        }\n+\n+        static OptionGroupContent appImageGroupContent(OperatingSystem os) {\n+            return shared(os).options(appImageOptions()).create();\n+        }\n+\n+        static OptionGroupContent launcherGroupContent(OperatingSystem os) {\n+            return shared(os).options(launcherOptions(os)).create();\n+        }\n+\n+        static OptionGroupContent launcherPlatformGroupContent(OperatingSystem os) {\n+            return platform(os).options(launcherOptions(os)).create();\n+        }\n+\n+        static OptionGroupContent nativePackageGroupContent(OperatingSystem os) {\n+            return shared(os).options(nativePackageOptions(os)).create();\n+        }\n+\n+        static OptionGroupContent nativePackagePlatformGroupContent(OperatingSystem os) {\n+            return platform(os).options(nativePackageOptions(os)).create();\n+        }\n+\n+        private OptionGroupContent(List<? extends OptionSpec<?>> optionSpecs) {\n+            this.optionSpecs = List.copyOf(optionSpecs);\n+        }\n+\n+        private OptionGroup createOptionGroup(String name) {\n+            return new OptionGroup(name, optionSpecs);\n+        }\n+\n+        private static Builder shared(OperatingSystem os) {\n+            return new Builder(os, sharedOption()).optionSpecDescriptionGetter(standardOptionSpecDescriptionGetter(os));\n+        }\n+\n+        private static Builder platform(OperatingSystem os) {\n+            return new Builder(os, Predicate.not(sharedOption()));\n+        }\n+\n+        private static final class Builder {\n+\n+            private Builder(OperatingSystem os, Predicate<OptionSpec<?>> platformFilter) {\n+                this.context = new StandardOptionContext(os);\n+                this.platformFilter = Objects.requireNonNull(platformFilter);\n+            }\n+\n+            OptionGroupContent create() {\n+                return new OptionGroupContent(optionSpecs.stream()\n+                        .filter(platformFilter).sorted(optionSpecSorter()).toList());\n+            }\n+\n+            Builder optionSpecDescriptionGetter(Function<OptionSpec<?>, String> v) {\n+                descriptionGetter = v;\n+                return this;\n+            }\n+\n+            Builder options(Stream<? extends OptionSpec<?>> v) {\n+                optionSpecs.addAll(v.<OptionSpec<?>>map(context::mapOptionSpec).map(optionSpec -> {\n+                    return optionSpec.copyWithDescription(getDescription(optionSpec));\n+                }).toList());\n+                return this;\n+            }\n+\n+            private String getDescription(OptionSpec<?> optionSpec) {\n+                Objects.requireNonNull(optionSpec);\n+                return Optional.ofNullable(descriptionGetter).orElse(\n+                        OptionGroupContent::getDefaultOptionSpecDescription).apply(optionSpec);\n+            }\n+\n+            private final StandardOptionContext context;\n+            private final Predicate<OptionSpec<?>> platformFilter;\n+            private Function<OptionSpec<?>, String> descriptionGetter;\n+            private List<OptionSpec<?>> optionSpecs = new ArrayList<>();\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> genericOptions() {\n+            return Stream.of(\n+                    StandardOption.TYPE,\n+                    StandardOption.APP_VERSION,\n+                    StandardOption.COPYRIGHT,\n+                    StandardOption.DESCRIPTION,\n+                    StandardOption.HELP,\n+                    StandardOption.ICON,\n+                    StandardOption.NAME,\n+                    StandardOption.DEST,\n+                    StandardOption.TEMP_ROOT,\n+                    StandardOption.VENDOR,\n+                    StandardOption.VERBOSE,\n+                    StandardOption.VERSION\n+            ).map(OptionValue::getSpec);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> appImageOptions() {\n+            return Stream.of(\n+                    StandardOption.INPUT,\n+                    StandardOption.APP_CONTENT\n+            ).map(OptionValue::getSpec);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> runtimeImageOptions() {\n+            return Stream.of(\n+                    StandardOption.ADD_MODULES,\n+                    StandardOption.MODULE_PATH,\n+                    StandardOption.JLINK_OPTIONS,\n+                    StandardOption.PREDEFINED_RUNTIME_IMAGE\n+            ).map(OptionValue::getSpec);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> launcherOptions(OperatingSystem os) {\n+            final var fromPropertyFile = StandardOption.launcherOptions().stream()\n+                    .map(Option::spec)\n+                    .filter(platformOption(os))\n+                    .filter(spec -> {\n+                        \/\/ Want options applicable to the app image bundling on the current platform.\n+                        return StandardBundlingOperation.narrow(spec.scope().stream())\n+                                .filter(StandardBundlingOperation.CREATE_APP_IMAGE::contains)\n+                                .findFirst().isPresent();\n+                    })\n+                    .filter(Predicate.not(genericOptions().toList()::contains));\n+\n+            final Stream<? extends OptionSpec<?>> additional = Stream.of(\n+                    StandardOption.ADD_LAUNCHER_INTERNAL\n+            ).map(OptionValue::getSpec);\n+\n+            return Stream.concat(fromPropertyFile, additional);\n+        }\n+\n+        private static Stream<? extends OptionSpec<?>> nativePackageOptions(OperatingSystem os) {\n+            \/\/ The most straightforward way to get the list of these options is to\n+            \/\/ subtract the options from other groups from the list of all supported options.\n+            \/\/ This presumes this method is called after the other enum elements have been initialized.\n+            final var base = StandardOption.options().stream().map(Option::spec).filter(platformOption(os))\n+                    .filter(Predicate.not(Stream.of(\n+                            genericOptions(),\n+                            appImageOptions(),\n+                            runtimeImageOptions(),\n+                            launcherOptions(os)).flatMap(x -> x).collect(toSet())::contains));\n+\n+            return Stream.concat(base, Stream.of(StandardOption.RUNTIME_INSTALLER_RUNTIME_IMAGE));\n+        }\n+\n+        private static String getDefaultOptionSpecDescription(OptionSpec<?> optionSpec) {\n+            return I18N.getString(optionSpec.description());\n+        }\n+\n+        private static Function<OptionSpec<?>, String> standardOptionSpecDescriptionGetter(OperatingSystem os) {\n+            return optionSpec -> {\n+                return getDefaultOptionSpecDescription(optionSpec);\n+            };\n+        }\n+\n+        private final List<OptionSpec<?>> optionSpecs;\n+    }\n+\n+\n+    private static final class GroupFormatter implements OptionGroupFormatter {\n+\n+        @Override\n+        public void formatHeader(String groupName, Consumer<CharSequence> sink) {\n+            groupFormatter.formatHeader(I18N.getString(groupName), sink);\n+        }\n+\n+        @Override\n+        public void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink) {\n+            groupFormatter.formatBody(optionSpecs, sink);\n+        }\n+\n+        @Override\n+        public void format(HelpFormatter.OptionGroup group, Consumer<CharSequence> sink) {\n+            formatHeader(group.name(), sink);\n+            if (group.name().equals(OptionGroupID.GENERIC_OPTIONS.groupName())) {\n+                optionSpecFormatter.format(\"@<filename>\", Optional.empty(), I18N.getString(\"help.option.argument-file\"), sink);\n+            }\n+            formatBody(group.options(), sink);\n+        }\n+\n+        private final OptionFormatter optionSpecFormatter = new ConsoleOptionFormatter(2, 0);\n+        private final OptionGroupFormatter groupFormatter = new ConsoleOptionGroupFormatter(optionSpecFormatter);\n+    }\n+\n+\n+    private static final class SampleGroupFormatter implements OptionGroupFormatter {\n+\n+        @Override\n+        public void formatHeader(String groupName, Consumer<CharSequence> sink) {\n+            var formattedName = I18N.getString(groupName) + \":\";\n+            sink.accept(formattedName);\n+            eol(sink);\n+            sink.accept(\"-\".repeat(formattedName.length()));\n+            eol(sink);\n+        }\n+\n+        @Override\n+        public void formatBody(Iterable<? extends OptionSpec<?>> optionSpecs, Consumer<CharSequence> sink) {\n+            boolean first = true;\n+            for (var optionSpec : optionSpecs) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    eol(sink);\n+                }\n+                sink.accept(I18N.getString(optionSpec.description()));\n+                eol(sink);\n+            }\n+        }\n+    }\n+\n+\n+    StandardHelpFormatter(OperatingSystem os) {\n+\n+        samplesHelpFormatter = HelpFormatter.build()\n+                .groupFormatter(new SampleGroupFormatter())\n+                .groups(OptionGroupID.SAMPLES.createNonEmptyOptionGroup(os).orElseThrow())\n+                .create();\n+\n+        final var builder = HelpFormatter.build().groupFormatter(new GroupFormatter());\n+\n+        Stream.of(OptionGroupID.values())\n+                .filter(Predicate.<OptionGroupID>isEqual(OptionGroupID.SAMPLES).negate())\n+                .map(optionGroupID -> {\n+                    return optionGroupID.createNonEmptyOptionGroup(os);\n+                })\n+                .filter(Optional::isPresent)\n+                .map(Optional::orElseThrow)\n+                .forEach(builder::groups);\n+\n+        mainHelpFormatter = builder.create();\n+    }\n+\n+    void format(Consumer<CharSequence> sink) {\n+        sink.accept(I18N.getString(\"help.header\"));\n+        eol(sink);\n+        eol(sink);\n+        samplesHelpFormatter.format(sink);\n+        mainHelpFormatter.format(sink);\n+    }\n+\n+    void formatNoArgsHelp(Consumer<CharSequence> sink) {\n+        sink.accept(I18N.getString(\"help.header\"));\n+        eol(sink);\n+        sink.accept(I18N.format(\"help.short\"));\n+        eol(sink);\n+    }\n+\n+    static Comparator<OptionSpec<?>> optionSpecSorter() {\n+        \/\/ Sort alphabetically by the first name except of the \"--type\" option, it goes first.\n+        return Comparator.comparing(OptionSpec::name, new Comparator<OptionName>() {\n+\n+            @Override\n+            public int compare(OptionName o1, OptionName o2) {\n+                if (o1.equals(TYPE) && o2.equals(TYPE)) {\n+                    return 0;\n+                } else if (o1.equals(TYPE)) {\n+                    return -1;\n+                } else if (o2.equals(TYPE)) {\n+                    return 1;\n+                } else {\n+                    return o1.compareTo(o2);\n+                }\n+            }\n+\n+            private static final OptionName TYPE = StandardOption.TYPE.getSpec().name();\n+        });\n+    }\n+\n+    private static OptionSpec<?> dummyOptionSpec(String name, String description) {\n+        return new OptionSpec<>(\n+                List.of(OptionName.of(name)),\n+                Optional.empty(),\n+                Set.copyOf(StandardBundlingOperation.CREATE_BUNDLE),\n+                OptionSpec.MergePolicy.USE_FIRST,\n+                Optional.empty(),\n+                Optional.empty(),\n+                description);\n+    }\n+\n+    private final HelpFormatter samplesHelpFormatter;\n+    private final HelpFormatter mainHelpFormatter;\n+\n+    private static final StringBundle I18N = StringBundle.fromResourceBundle(ResourceBundle.getBundle(\n+            \"jdk.jpackage.internal.resources.HelpResources\"));\n+\n+    static final StandardHelpFormatter INSTANCE = new StandardHelpFormatter(OperatingSystem.current());\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardHelpFormatter.java","additions":398,"deletions":0,"binary":false,"changes":398,"status":"added"},{"patch":"@@ -0,0 +1,794 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.pathSeparator;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.toList;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_MAC_PKG;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_NATIVE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.SIGN_MAC_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.fromOptionName;\n+import static jdk.jpackage.internal.cli.StandardOptionContext.createOptionSpecBuilderMutator;\n+import static jdk.jpackage.internal.cli.StandardOptionValueExceptionFactory.ERROR_WITH_VALUE;\n+import static jdk.jpackage.internal.cli.StandardOptionValueExceptionFactory.ERROR_WITH_VALUE_AND_OPTION_NAME;\n+import static jdk.jpackage.internal.cli.StandardOptionValueExceptionFactory.forMessageWithOptionValueAndName;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.addLauncherShortcutConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.booleanConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.identityConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.mainLauncherShortcutConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.pathConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.uuidConv;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.util.SetBuilder;\n+\n+\/**\n+ * jpackage command line options\n+ *\/\n+public final class StandardOption {\n+\n+    private StandardOption() {\n+    }\n+\n+    private static final Set<OperatingSystem> SUPPORTED_OS = Set.of(\n+            OperatingSystem.LINUX, OperatingSystem.WINDOWS, OperatingSystem.MACOS);\n+\n+\n+    \/**\n+     * Scope of options configuring a launcher.\n+     *\/\n+    enum LauncherProperty implements OptionScope {\n+        VALUE\n+    }\n+\n+\n+    \/**\n+     * Modes in which bundling operations don't involve building of an app image.\n+     *\/\n+    private static final Set<BundlingOperationModifier> NOT_BUILDING_APP_IMAGE = Set.of(\n+            \/\/ jpackage will not build an app image when bundling runtime native package\n+            BundlingOperationModifier.BUNDLE_RUNTIME,\n+            \/\/ jpackage will not build an app image if predefined app image is supplied\n+            BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE);\n+\n+    private static final Set<OptionScope> MAC_SIGNING = new SetBuilder<OptionScope>()\n+            .add(StandardBundlingOperation.MAC_SIGNING)\n+            .add(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+\n+    static final OptionValue<Boolean> HELP = auxilaryOption(\"help\").addAliases(\"h\", \"?\").create();\n+\n+    static final OptionValue<Boolean> VERSION = auxilaryOption(\"version\").create();\n+\n+    public static final OptionValue<Boolean> VERBOSE = auxilaryOption(\"verbose\").create();\n+\n+    public static final OptionValue<PackageType> TYPE = option(\"type\", PackageType.class).addAliases(\"t\")\n+            .scope(StandardBundlingOperation.values()).inScope(NOT_BUILDING_APP_IMAGE)\n+            .converterExceptionFactory(ERROR_WITH_VALUE).converterExceptionFormatString(\"ERR_InvalidInstallerType\")\n+            .converter(str -> {\n+                Objects.requireNonNull(str);\n+                return Stream.of(StandardBundlingOperation.values()).filter(bundlingOperation -> {\n+                    return bundlingOperation.packageTypeValue().equals(str);\n+                }).map(StandardBundlingOperation::packageType).findFirst().orElseThrow(IllegalArgumentException::new);\n+            })\n+            .description(\"help.option.type\" + resourceKeySuffix(OperatingSystem.current()))\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                b.description(\"help.option.type\" + resourceKeySuffix(context.os()));\n+            })).create();\n+\n+    public static final OptionValue<Path> INPUT = directoryOption(\"input\").addAliases(\"i\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<Path> DEST = directoryOption(\"dest\").addAliases(\"d\")\n+            .valuePattern(\"destination path\")\n+            .validator(StandardValidator.IS_DIRECTORY_OR_NON_EXISTENT)\n+            .defaultValue(Path.of(\"\").toAbsolutePath())\n+            .create();\n+\n+    public static final OptionValue<String> DESCRIPTION = stringOption(\"description\")\n+            .inScope(LauncherProperty.VALUE)\n+            .valuePattern(\"description string\")\n+            .create();\n+\n+    public static final OptionValue<String> VENDOR = stringOption(\"vendor\").valuePattern(\"vendor string\").create();\n+\n+    public static final OptionValue<String> APPCLASS = stringOption(\"main-class\")\n+            .valuePattern(\"class name\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> NAME = stringOption(\"name\").addAliases(\"n\")\n+            .validator(StandardValidator.IS_NAME_VALID)\n+            .validatorExceptionFactory(ERROR_WITH_VALUE).validatorExceptionFormatString(\"ERR_InvalidAppName\")\n+            .create();\n+\n+    public static final OptionValue<Path> RESOURCE_DIR = directoryOption(\"resource-dir\")\n+            .scope(StandardBundlingOperation.values()).inScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<List<String>> ARGUMENTS = escapedStringListOption(\"arguments\")\n+            .valuePattern(\"main class arguments\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<List<String>> JLINK_OPTIONS = escapedStringListOption(\"jlink-options\")\n+            .valuePattern(\"jlink options\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<Path> ICON = fileOption(\"icon\")\n+            .validator(new Predicate<>() {\n+                @Override\n+                public boolean test(Path path) {\n+                    if (!path.toString().isEmpty()) {\n+                        return StandardValidator.IS_FILE_OR_SYMLINK.test(path);\n+                    } else {\n+                        return true;\n+                    }\n+                }\n+            })\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> COPYRIGHT = stringOption(\"copyright\").valuePattern(\"copyright string\").create();\n+\n+    public static final OptionValue<Path> LICENSE_FILE = fileOption(\"license-file\").create();\n+\n+    public static final OptionValue<String> APP_VERSION = stringOption(\"app-version\").create();\n+\n+    public static final OptionValue<String> ABOUT_URL = urlOption(\"about-url\")\n+            .scope(CREATE_NATIVE).inScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<List<String>> JAVA_OPTIONS = escapedStringListOption(\"java-options\")\n+            .valuePattern(\"java options\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<List<Path>> APP_CONTENT = pathOption(\"app-content\")\n+            .tokenizer(\",\")\n+            .valuePattern(\"additional content\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.MACOS) {\n+                    b.description(\"help.option.app-content\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .createArray(toList());\n+\n+    static final OptionValue<Path[]> FILE_ASSOCIATIONS_INTERNAL = fileOption(\"file-associations\")\n+            .tokenizer(pathSeparator())\n+            .outOfScope(BundlingOperationModifier.BUNDLE_RUNTIME)\n+            .createArray();\n+\n+    static final OptionValue<AdditionalLauncher[]> ADD_LAUNCHER_INTERNAL = createAddLauncherOption(\"add-launcher\");\n+\n+    public static final OptionValue<Path> TEMP_ROOT = directoryOption(\"temp\")\n+            .validatorExceptionFactory((optionName, optionValue, formatString, cause) -> {\n+                if (cause.orElseThrow() instanceof StandardValidator.DirectoryListingIOException) {\n+                    formatString = \"error.path-parameter-ioexception\";\n+                }\n+                return ERROR_WITH_VALUE_AND_OPTION_NAME.create(optionName, optionValue, formatString, cause);\n+            })\n+            .validatorExceptionFormatString(\"error.parameter-not-empty-directory\")\n+            .validator(StandardValidator.IS_DIRECTORY_EMPTY_OR_NON_EXISTENT)\n+            .create();\n+\n+    public static final OptionValue<Path> INSTALL_DIR = pathOption(\"install-dir\")\n+            .valuePattern(\"directory path\")\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.WINDOWS) {\n+                    b.description(\"help.option.install-dir\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .create();\n+\n+    public static final OptionValue<Path> PREDEFINED_APP_IMAGE = directoryOption(\"app-image\")\n+            .scope(CREATE_NATIVE).inScope(SIGN_MAC_APP_IMAGE).inScope(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE)\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.MACOS) {\n+                    b.description(\"help.option.app-image\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .create();\n+\n+    public static final OptionValue<Path> PREDEFINED_RUNTIME_IMAGE = directoryOption(\"runtime-image\")\n+            .outOfScope(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE)\n+            .create();\n+\n+    static final OptionSpec<Path> RUNTIME_INSTALLER_RUNTIME_IMAGE = directoryOption(\"runtime-image\")\n+            .outOfScope(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE)\n+            .description(\"help.option.installer-runtime-image\")\n+            .createOptionSpec();\n+\n+    public static final OptionValue<Path> MAIN_JAR = pathOption(\"main-jar\")\n+            .valuePattern(\"main jar file\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> MODULE = stringOption(\"module\").addAliases(\"m\")\n+            .valuePattern(\"<module name>[\/<main class>]\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<List<String>> ADD_MODULES = stringOption(\"add-modules\").tokenizer(\",\")\n+            .valuePattern(\"module name\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .createArray(toList());\n+\n+    public static final OptionValue<List<Path>> MODULE_PATH = pathOption(\"module-path\").addAliases(\"p\").tokenizer(pathSeparator())\n+            .valuePattern(\"module path\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                if (context.os() == OperatingSystem.WINDOWS) {\n+                    b.description(\"help.option.module-path\" + resourceKeySuffix(context.os()));\n+                }\n+            }))\n+            .createArray(toList());\n+\n+    public static final OptionValue<Boolean> LAUNCHER_AS_SERVICE = booleanOption(\"launcher-as-service\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    \/\/\n+    \/\/ Linux-specific\n+    \/\/\n+\n+    public static final OptionValue<String> LINUX_RELEASE = stringOption(\"linux-app-release\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_PACKAGE_NAME = stringOption(\"linux-package-name\")\n+            .valuePattern(\"package name\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_DEB_MAINTAINER_EMAIL = stringOption(\"linux-deb-maintainer\")\n+            .valuePattern(\"email address\")\n+            .create();\n+\n+    public static final OptionValue<String> LINUX_APP_CATEGORY = stringOption(\"linux-app-category\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_RPM_LICENSE_TYPE = stringOption(\"linux-rpm-license-type\")\n+            .valuePattern(\"license type\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> LINUX_PACKAGE_DEPENDENCIES = stringOption(\"linux-package-deps\")\n+            .valuePattern(\"package-dep-string\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<LauncherShortcut> LINUX_SHORTCUT_HINT = launcherShortcutOption(\"linux-shortcut\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> LINUX_MENU_GROUP = stringOption(\"linux-menu-group\")\n+            .valuePattern(\"menu-group-name\")\n+            .scope(nativeBundling()).create();\n+\n+    \/\/\n+    \/\/ MacOS-specific\n+    \/\/\n+\n+    public static final OptionValue<List<Path>> MAC_DMG_CONTENT = pathOption(\"mac-dmg-content\")\n+            .valuePattern(\"additional content path\")\n+            .tokenizer(\",\")\n+            .createArray(toList());\n+\n+    public static final OptionValue<Boolean> MAC_SIGN = booleanOption(\"mac-sign\").scope(MAC_SIGNING).addAliases(\"s\").create();\n+\n+    public static final OptionValue<Boolean> MAC_APP_STORE = booleanOption(\"mac-app-store\").create();\n+\n+    public static final OptionValue<String> MAC_APP_CATEGORY = stringOption(\"mac-app-category\").create();\n+\n+    public static final OptionValue<String> MAC_BUNDLE_NAME = stringOption(\"mac-package-name\")\n+            .valuePattern(\"package name\")\n+            .create();\n+\n+    public static final OptionValue<String> MAC_BUNDLE_IDENTIFIER = stringOption(\"mac-package-identifier\")\n+            .valuePattern(\"package identifier\")\n+            .create();\n+\n+    public static final OptionValue<String> MAC_BUNDLE_SIGNING_PREFIX = stringOption(\"mac-package-signing-prefix\").scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<String> MAC_SIGNING_KEY_NAME = stringOption(\"mac-signing-key-user-name\").scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<String> MAC_APP_IMAGE_SIGN_IDENTITY = stringOption(\"mac-app-image-sign-identity\").scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<String> MAC_INSTALLER_SIGN_IDENTITY = stringOption(\"mac-installer-sign-identity\")\n+            .scope(CREATE_MAC_PKG).inScope(NOT_BUILDING_APP_IMAGE)\n+            .create();\n+\n+    public static final OptionValue<Path> MAC_SIGNING_KEYCHAIN = pathOption(\"mac-signing-keychain\")\n+            .valuePattern(\"keychain name\")\n+            .scope(MAC_SIGNING).create();\n+\n+    public static final OptionValue<Path> MAC_ENTITLEMENTS = fileOption(\"mac-entitlements\")\n+            .valuePattern(\"file path\")\n+            .scope(MAC_SIGNING).create();\n+\n+    \/\/\n+    \/\/ Windows-specific\n+    \/\/\n+\n+    public static final OptionValue<String> WIN_HELP_URL = urlOption(\"win-help-url\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<String> WIN_UPDATE_URL = urlOption(\"win-update-url\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<LauncherShortcut> WIN_MENU_HINT = launcherShortcutOption(\"win-menu\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<String> WIN_MENU_GROUP = stringOption(\"win-menu-group\")\n+            .valuePattern(\"menu group name\")\n+            .scope(nativeBundling()).create();\n+\n+    public static final OptionValue<LauncherShortcut> WIN_SHORTCUT_HINT = launcherShortcutOption(\"win-shortcut\")\n+            .scope(nativeBundling())\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    public static final OptionValue<Boolean> WIN_SHORTCUT_PROMPT = booleanOption(\"win-shortcut-prompt\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<Boolean> WIN_PER_USER_INSTALLATION = booleanOption(\"win-per-user-install\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<Boolean> WIN_INSTALLDIR_CHOOSER = booleanOption(\"win-dir-chooser\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<UUID> WIN_UPGRADE_UUID = uuidOption(\"win-upgrade-uuid\").scope(nativeBundling()).create();\n+\n+    public static final OptionValue<Boolean> WIN_CONSOLE_HINT = booleanOption(\"win-console\")\n+            .outOfScope(NOT_BUILDING_APP_IMAGE)\n+            .inScope(LauncherProperty.VALUE)\n+            .create();\n+\n+    \/\/\n+    \/\/ Synthetic options\n+    \/\/\n+\n+    \/**\n+     * Processed additional launcher property files.\n+     * <p>\n+     * Items in the list are in the order \"--add-launcher\" options appeared on the\n+     * command line. Every item in the list has {@link #SOURCE_PROPERY_FILE} option\n+     * with the value set to the source property file and {@link #NAME} option with\n+     * the value set to the additional launcher name.\n+     *\/\n+    public static final OptionValue<List<Options>> ADDITIONAL_LAUNCHERS = OptionValue.create();\n+\n+    \/**\n+     * Processed file association property files.\n+     * <p>\n+     * Items in the list are in the order \"--file-associations\" options appeared on\n+     * the command line. Every item in the list has {@link #SOURCE_PROPERY_FILE}\n+     * option with the value set to the source property file.\n+     *\/\n+    public static final OptionValue<List<Options>> FILE_ASSOCIATIONS = OptionValue.create();\n+\n+    public static final OptionValue<Path> SOURCE_PROPERY_FILE = OptionValue.create();\n+\n+    public static final OptionValue<BundlingOperationDescriptor> BUNDLING_OPERATION_DESCRIPTOR = OptionValue.create();\n+\n+    \/**\n+     * Returns options configuring a launcher.\n+     *\n+     * @return the options configuring a launcher\n+     *\/\n+    static Set<Option> launcherOptions() {\n+        return options().stream().filter(option -> {\n+            return option.spec().scope().stream().anyMatch(LauncherProperty.class::isInstance);\n+        }).collect(toUnmodifiableSet());\n+    }\n+\n+    \/**\n+     * Returns public and package-private options with option specs defined in\n+     * {@link StandardOption} class.\n+     *\n+     * @return public and package-private options defined in\n+     *         {@link StandardOption} class\n+     *\/\n+    static Set<Option> options() {\n+        return Utils.getOptionsWithSpecs(StandardOption.class).map(OptionValue::getOption).collect(toUnmodifiableSet());\n+    }\n+\n+    \/**\n+     * Returns a {@link Predicate} that returns {@code true} if the given option\n+     * spec denotes an option supported on all platforms.\n+     *\n+     * @return the predicate\n+     *\/\n+    static Predicate<OptionSpec<?>> sharedOption() {\n+        return optionSpec -> {\n+            final var optionSupportedOSs = StandardBundlingOperation.narrow(optionSpec.scope().stream())\n+                    .map(StandardBundlingOperation::os).collect(toUnmodifiableSet());\n+            return optionSupportedOSs.equals(SUPPORTED_OS);\n+        };\n+    }\n+\n+    \/**\n+     * Returns a {@link Predicate} that returns {@code true} if the given option\n+     * spec denotes an option supported on the given platform.\n+     *\n+     * @param os the platform\n+     * @return the predicate\n+     *\/\n+    static Predicate<OptionSpec<?>> platformOption(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        return optionSpec -> {\n+            return StandardBundlingOperation.narrow(optionSpec.scope().stream()).filter(op -> {\n+                return op.os().equals(os);\n+            }).findFirst().isPresent();\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<String>> stringOptionMutator() {\n+        return builder -> {\n+            builder.converter(identityConv());\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Path>> pathOptionMutator() {\n+        return builder -> {\n+            builder.converter(pathConv())\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.converterExceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.converterExceptionFormatString(\"error.properties-parameter-not-path\");\n+                });\n+            }))\n+            .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+            .converterExceptionFormatString(\"error.parameter-not-path\");\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Path>> fileOptionMutator() {\n+        return builder -> {\n+            builder.mutate(pathOptionMutator())\n+            .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.validatorExceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.validatorExceptionFormatString(\"error.properties-parameter-not-file\");\n+                });\n+            }))\n+            .validator(StandardValidator.IS_FILE_OR_SYMLINK)\n+            .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+            .validatorExceptionFormatString(\"error.parameter-not-file\");\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Path>> directoryOptionMutator() {\n+        return builder -> {\n+            builder.mutate(pathOptionMutator())\n+            .validator(StandardValidator.IS_DIRECTORY)\n+            .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+            .validatorExceptionFormatString(\"error.parameter-not-directory\");\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<Boolean>> booleanOptionMutator() {\n+        return builder -> {\n+            builder.mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.converter(booleanConv());\n+                });\n+            })).valuePattern(null).defaultValue(Boolean.FALSE);\n+        };\n+    }\n+\n+    static Consumer<OptionSpecBuilder<LauncherShortcut>> launcherShortcutOptionMutator() {\n+        return builder -> {\n+            builder.mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                context.asFileSource().ifPresent(propertyFile -> {\n+                    b.converter(addLauncherShortcutConv()).defaultOptionalValue(null);\n+                    b.converterExceptionFactory(forMessageWithOptionValueAndName(propertyFile));\n+                    b.converterExceptionFormatString(\"error.properties-parameter-not-launcher-shortcut-dir\");\n+                });\n+            }))\n+            .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+            .converterExceptionFormatString(\"error.parameter-not-launcher-shortcut-dir\")\n+            .converter(mainLauncherShortcutConv())\n+            .defaultOptionalValue(new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT))\n+            .valuePattern(\"shortcut startup directory\");\n+        };\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .description(\"help.option.\" + name)\n+                .scope(fromOptionName(name))\n+                .scope(scope -> {\n+                    return SetBuilder.build(OptionScope.class)\n+                            .add(scope)\n+                            .add(BundlingOperationModifier.values())\n+                            .create();\n+                });\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).mutate(stringOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<UUID> uuidOption(String name) {\n+        return option(name, UUID.class)\n+                .converter(uuidConv())\n+                .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .converterExceptionFormatString(\"error.parameter-not-uuid\");\n+    }\n+\n+    private static OptionSpecBuilder<Path> pathOption(String name) {\n+        return option(name, Path.class).mutate(pathOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Path> fileOption(String name) {\n+        return option(name, Path.class)\n+                .valuePattern(\"file path\")\n+                .mutate(fileOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Path> directoryOption(String name) {\n+        return option(name, Path.class)\n+                .valuePattern(\"directory path\")\n+                .mutate(directoryOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<String> urlOption(String name) {\n+        return stringOption(name)\n+                .valuePattern(\"url\")\n+                .validator(StandardValidator.IS_URL)\n+                .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .validatorExceptionFormatString(\"error.parameter-not-url\");\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).mutate(booleanOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<LauncherShortcut> launcherShortcutOption(String name) {\n+        return option(name, LauncherShortcut.class).mutate(launcherShortcutOptionMutator());\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> auxilaryOption(String name) {\n+        return booleanOption(name)\n+                .scope(StandardBundlingOperation.values())\n+                .inScope(NOT_BUILDING_APP_IMAGE);\n+    }\n+\n+    private static OptionSpecBuilder<String> escapedStringListOption(String name) {\n+        return stringOption(name).tokenizer(str -> {\n+            return Arguments.getArgumentList(str).toArray(String[]::new);\n+        }).converter(Arguments::unquoteIfNeeded);\n+    }\n+\n+    private static UnaryOperator<Set<OptionScope>> nativeBundling() {\n+        return scope -> {\n+            return new SetBuilder<OptionScope>()\n+                    .set(scope)\n+                    .remove(new SetBuilder<OptionScope>().set(StandardBundlingOperation.values()).remove(CREATE_NATIVE).create())\n+                    .create();\n+        };\n+    }\n+\n+    private static OptionValue<AdditionalLauncher[]> createAddLauncherOption(String name) {\n+        OptionValueConverter<Path> propertyFileConverter = fileOption(name)\n+                .create().getSpec().converter().orElseThrow();\n+\n+        return option(name, AdditionalLauncher.class)\n+                .valuePattern(\"<launcher name>=<file path>\")\n+                .description(\"help.option.add-launcher\" + resourceKeySuffix(OperatingSystem.current()))\n+                .mutate(createOptionSpecBuilderMutator((b, context) -> {\n+                    b.description(\"help.option.add-launcher\" + resourceKeySuffix(context.os()));\n+                }))\n+                .outOfScope(NOT_BUILDING_APP_IMAGE)\n+                .converterExceptionFormatString(\"\")\n+                .converterExceptionFactory((optionName, optionValue, formatString, cause) -> {\n+                    final var theCause = cause.orElseThrow();\n+                    if (theCause instanceof AddLauncherSyntaxException) {\n+                        return ERROR_WITH_VALUE_AND_OPTION_NAME.create(optionName,\n+                                optionValue, \"error.parameter-add-launcher-malformed\", cause);\n+                    } else {\n+                        return (RuntimeException)theCause;\n+                    }\n+                }).converter(value -> {\n+                    var components = value.split(\"=\", 2);\n+                    if (components.length != 2) {\n+                        throw new AddLauncherSyntaxException();\n+                    }\n+\n+                    final var launcherName = components[0];\n+\n+                    if (!StandardValidator.IS_NAME_VALID.test(launcherName)) {\n+                        throw new AddLauncherInvalidNameException(I18N.format(\"ERR_InvalidSLName\", launcherName));\n+                    }\n+\n+                    final Path propertyFile;\n+                    try {\n+                        propertyFile = propertyFileConverter.convert(OptionName.of(name),\n+                                StringToken.of(value, components[1])).orElseThrow();\n+                    } catch (JPackageException ex) {\n+                        throw new AddLauncherInvalidPropertyFileException(I18N.format(\n+                                \"error.parameter-add-launcher-not-file\", components[1], launcherName));\n+                    }\n+\n+                    return new AdditionalLauncher(launcherName, propertyFile);\n+                }).defaultArrayValue(new AdditionalLauncher[0]).createArray();\n+    }\n+\n+    private static String resourceKeySuffix(OperatingSystem os) {\n+        switch (os) {\n+            case LINUX -> {\n+                return \".linux\";\n+            }\n+            case MACOS -> {\n+                return \".mac\";\n+            }\n+            case WINDOWS -> {\n+                return \".win\";\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+\n+    static class AddLauncherIllegalArgumentException extends IllegalArgumentException {\n+\n+        AddLauncherIllegalArgumentException(String message) {\n+            super(message);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    static final class AddLauncherInvalidNameException extends AddLauncherIllegalArgumentException {\n+\n+        AddLauncherInvalidNameException(String message) {\n+            super(message);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    static final class AddLauncherInvalidPropertyFileException extends AddLauncherIllegalArgumentException {\n+\n+        AddLauncherInvalidPropertyFileException(String msg) {\n+            super(msg);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private static final class AddLauncherSyntaxException extends IllegalArgumentException {\n+\n+        AddLauncherSyntaxException() {\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private static final class Arguments {\n+\n+        \/\/\n+        \/\/ This is a an extract copied from jdk.jpackage.internal.Arguments class with the following changes:\n+        \/\/  - Don't call unquoteIfNeeded() from getArgumentList().\n+        \/\/  - Edit a comment in getArgumentList().\n+        \/\/  - Insert Objects.requireNonNull() calls.\n+        \/\/  - throw IllegalArgumentException from unquoteIfNeeded() if the input string is empty.\n+        \/\/\n+\n+        \/\/ regexp for parsing args (for example, for additional launchers)\n+        private static Pattern pattern = Pattern.compile(\n+              \"(?:(?:([\\\"'])(?:\\\\\\\\\\\\1|.)*?(?:\\\\1|$))|(?:\\\\\\\\[\\\"'\\\\s]|[^\\\\s]))++\");\n+\n+        static List<String> getArgumentList(String inputString) {\n+            Objects.requireNonNull(inputString);\n+\n+            List<String> list = new ArrayList<>();\n+            if (inputString.isEmpty()) {\n+                 return list;\n+            }\n+\n+            \/\/ The \"pattern\" regexp attempts to abide to the rule that\n+            \/\/ strings are delimited by whitespace unless surrounded by\n+            \/\/ quotes, then it is anything (including spaces) in the quotes.\n+            Matcher m = pattern.matcher(inputString);\n+            while (m.find()) {\n+                String s = inputString.substring(m.start(), m.end()).trim();\n+                \/\/ Ensure we do not have an empty string. trim() will take care of\n+                \/\/ whitespace only strings. The regex preserves quotes and escaped\n+                \/\/ chars.\n+                if (!s.isEmpty()) {\n+                    list.add(s);\n+                }\n+            }\n+            return list;\n+        }\n+\n+        static String unquoteIfNeeded(String in) {\n+            Objects.requireNonNull(in);\n+            if (in.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            \/\/ Use code points to preserve non-ASCII chars\n+            StringBuilder sb = new StringBuilder();\n+            int codeLen = in.codePointCount(0, in.length());\n+            int quoteChar = -1;\n+            for (int i = 0; i < codeLen; i++) {\n+                int code = in.codePointAt(i);\n+                if (code == '\"' || code == '\\'') {\n+                    \/\/ If quote is escaped make sure to copy it\n+                    if (i > 0 && in.codePointAt(i - 1) == '\\\\') {\n+                        sb.deleteCharAt(sb.length() - 1);\n+                        sb.appendCodePoint(code);\n+                        continue;\n+                    }\n+                    if (quoteChar != -1) {\n+                        if (code == quoteChar) {\n+                            \/\/ close quote, skip char\n+                            quoteChar = -1;\n+                        } else {\n+                            sb.appendCodePoint(code);\n+                        }\n+                    } else {\n+                        \/\/ opening quote, skip char\n+                        quoteChar = code;\n+                    }\n+                } else {\n+                    sb.appendCodePoint(code);\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOption.java","additions":794,"deletions":0,"binary":false,"changes":794,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import jdk.internal.util.OperatingSystem;\n+\n+\/**\n+ * The standard context for parsing command line options.\n+ *\/\n+record StandardOptionContext(OperatingSystem os, OptionSource src) {\n+\n+    StandardOptionContext {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(src);\n+    }\n+\n+    StandardOptionContext(OperatingSystem os) {\n+        this(os, OptionSource.COMMAND_LINE);\n+    }\n+\n+    StandardOptionContext() {\n+        this(OperatingSystem.current());\n+    }\n+\n+    StandardOptionContext forFile(Path file) {\n+        return new StandardOptionContext(os, OptionSource.fromFile(file));\n+    }\n+\n+    Optional<Path> asFileSource() {\n+        return OptionSource.asFile(src);\n+    }\n+\n+    <T> OptionSpec<T> mapOptionSpec(OptionSpec<T> optionSpec) {\n+        return OptionSpecMapperOptionScope.mapOptionSpec(optionSpec, this);\n+    }\n+\n+    static <T> Consumer<OptionSpecBuilder<T>> createOptionSpecBuilderMutator(\n+            BiConsumer<OptionSpecBuilder<T>, StandardOptionContext> mutator) {\n+        return OptionSpecMapperOptionScope.createOptionSpecBuilderMutator(StandardOptionContext.class, mutator);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOptionContext.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.Path;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.ArgumentsMapper;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.StandardArgumentsMapper;\n+import jdk.jpackage.internal.model.JPackageException;\n+\n+final class StandardOptionValueExceptionFactory {\n+\n+    static OptionValueExceptionFactory<JPackageException> forMessageWithOptionValueAndName(Path propertyFile) {\n+        return forMessageWithOptionValueAndName(appendPath(propertyFile)).printOptionPrefix(false).create();\n+    }\n+\n+    private StandardOptionValueExceptionFactory() {\n+    }\n+\n+    private static UnaryOperator<ArgumentsMapper> appendPath(Path path) {\n+        return argumentsMapper -> {\n+            return ArgumentsMapper.appendArguments(argumentsMapper, path);\n+        };\n+    }\n+\n+    private static OptionValueExceptionFactory.Builder<JPackageException> forMessageWithOptionValue(UnaryOperator<ArgumentsMapper> mapper) {\n+        return OptionValueExceptionFactory.build(JPackageException::new)\n+                .formatArgumentsTransformer(mapper.apply(StandardArgumentsMapper.VALUE));\n+    }\n+\n+    private static OptionValueExceptionFactory.Builder<JPackageException> forMessageWithOptionValueAndName(UnaryOperator<ArgumentsMapper> mapper) {\n+        return OptionValueExceptionFactory.build(JPackageException::new)\n+                .formatArgumentsTransformer(mapper.apply(StandardArgumentsMapper.VALUE_AND_NAME));\n+    }\n+\n+    static final OptionValueExceptionFactory<JPackageException> ERROR_WITH_VALUE =\n+            forMessageWithOptionValue(UnaryOperator.identity()).create();\n+\n+    static final OptionValueExceptionFactory<JPackageException> ERROR_WITH_VALUE_AND_OPTION_NAME =\n+            forMessageWithOptionValueAndName(UnaryOperator.identity()).create();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOptionValueExceptionFactory.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import jdk.jpackage.internal.cli.Validator.ValidatingConsumerException;\n+import jdk.jpackage.internal.util.FileUtils;\n+\n+final public class StandardValidator {\n+\n+    private StandardValidator() {\n+    }\n+\n+    public static final Predicate<Path> IS_DIRECTORY = Files::isDirectory;\n+\n+    public static final Predicate<Path> IS_FILE_OR_SYMLINK = path -> {\n+        if (Files.isRegularFile(path)) {\n+            return true;\n+        } else if (Files.isSymbolicLink(path)) {\n+            try {\n+                return Files.isRegularFile(FileUtils.readSymlinkTargetRecursive(path));\n+            } catch (IOException ex) {\n+                return false;\n+            }\n+        } else {\n+            return false;\n+        }\n+    };\n+\n+    public static final Predicate<Path> IS_DIRECTORY_OR_NON_EXISTENT = path -> {\n+        return !Files.exists(path) || Files.isDirectory(path);\n+    };\n+\n+    static final Consumer<Path> IS_DIRECTORY_EMPTY_OR_NON_EXISTENT = path -> {\n+        if (Files.exists(path)) {\n+            if (Files.isDirectory(path)) {\n+                try (var dirContents = Files.list(path)) {\n+                    if (dirContents.findAny().isPresent()) {\n+                        throw new ValidatingConsumerException(new DirectoryNotEmptyException(path.toString()));\n+                    }\n+                } catch (IOException ex) {\n+                    throw new ValidatingConsumerException(new DirectoryListingIOException(ex));\n+                }\n+            } else {\n+                throw new ValidatingConsumerException(new NotDirectoryException(path.toString()));\n+            }\n+        }\n+    };\n+\n+    public static Predicate<Path> IS_DIRECTORY_EMPTY_OR_NON_EXISTENT_PREDICATE = toPredicate(IS_DIRECTORY_EMPTY_OR_NON_EXISTENT);\n+\n+    static final Consumer<String> IS_URL = url -> {\n+        try {\n+            new URI(url);\n+        } catch (URISyntaxException ex) {\n+            throw new ValidatingConsumerException(ex);\n+        }\n+    };\n+\n+    public static Predicate<String> IS_URL_PREDICATE = toPredicate(IS_URL);\n+\n+    static final Consumer<String> IS_CLASSNAME = str -> {\n+        try {\n+            ClassDesc.of(str);\n+        } catch (IllegalArgumentException ex) {\n+            throw new ValidatingConsumerException(ex);\n+        }\n+    };\n+\n+    public static Predicate<String> IS_CLASSNAME_PREDICATE = toPredicate(IS_CLASSNAME);\n+\n+    \/\/ Copied from DeployParams.validateName()\n+    public static final Predicate<String> IS_NAME_VALID = s -> {\n+        if (s.length() == 0 || s.indexOf('\\\\') != -1 || s.indexOf('\/') != -1 || s.isBlank() || !s.equals(s.trim())) {\n+            return false;\n+        }\n+\n+        try {\n+            \/\/ name must be valid path element for this file system\n+            Path p = Path.of(s);\n+            \/\/ and it must be a single name element in a path\n+            if (p.getNameCount() != 1) {\n+                return false;\n+            }\n+        } catch (InvalidPathException ipe) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < s.length(); i++) {\n+            char a = s.charAt(i);\n+            \/\/ We check for ASCII codes first which we accept. If check fails,\n+            \/\/ check if it is acceptable extended ASCII or unicode character.\n+            if (a < ' ' || a > '~') {\n+                \/\/ Accept anything else including special chars like copyright\n+                \/\/ symbols. Note: space will be included by ASCII check above,\n+                \/\/ but other whitespace like tabs or new line will be rejected.\n+                if (Character.isISOControl(a)|| Character.isWhitespace(a)) {\n+                    return false;\n+                }\n+            } else if (a == '\"' || a == '%') {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    };\n+\n+\n+    public static final class DirectoryListingIOException extends RuntimeException {\n+\n+        DirectoryListingIOException(IOException cause) {\n+            super(Objects.requireNonNull(cause));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private static <T> Predicate<T> toPredicate(Consumer<T> validator) {\n+        return v -> {\n+            try {\n+                validator.accept(v);\n+                return true;\n+            } catch (ValidatingConsumerException ex) {\n+                return false;\n+            }\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardValidator.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.util.UUID;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.ParseUtils;\n+\n+\n+final class StandardValueConverter {\n+\n+    private StandardValueConverter() {\n+    }\n+\n+    static ValueConverter<String> identityConv() {\n+        return IDENTITY_CONV;\n+    }\n+\n+    static ValueConverter<Path> pathConv() {\n+        return PATH_CONV;\n+    }\n+\n+    static ValueConverter<UUID> uuidConv() {\n+        return UUID_CONV;\n+    }\n+\n+    static ValueConverter<Boolean> booleanConv() {\n+        return BOOLEAN_CONV;\n+    }\n+\n+    static ValueConverter<LauncherShortcut> mainLauncherShortcutConv() {\n+        return MAIN_LAUNCHER_SHORTCUT_CONV;\n+    }\n+\n+    static ValueConverter<LauncherShortcut> addLauncherShortcutConv() {\n+        return ADD_LAUNCHER_SHORTCUT_CONV;\n+    }\n+\n+    private static final ValueConverter<String> IDENTITY_CONV = ValueConverter.create(x -> x, String.class);\n+\n+    private static final ValueConverter<Path> PATH_CONV = ValueConverter.create(str -> {\n+        try {\n+            return Path.of(str);\n+        } catch (InvalidPathException ex) {\n+            throw new IllegalArgumentException(ex);\n+        }\n+    }, Path.class);\n+\n+    private static final ValueConverter<UUID> UUID_CONV = ValueConverter.create(UUID::fromString, UUID.class);\n+\n+    private static final ValueConverter<Boolean> BOOLEAN_CONV = ValueConverter.create(Boolean::valueOf, Boolean.class);\n+\n+    private static final ValueConverter<LauncherShortcut> MAIN_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n+            ParseUtils::parseLauncherShortcutForMainLauncher, LauncherShortcut.class);\n+\n+    private static final ValueConverter<LauncherShortcut> ADD_LAUNCHER_SHORTCUT_CONV = ValueConverter.create(\n+            ParseUtils::parseLauncherShortcutForAddLauncher, LauncherShortcut.class);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardValueConverter.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * A token of a tokenized string.\n+ *\n+ * @param tokenizedString the tokenized string from which this token was extracted\n+ * @param value           the value of this token\n+ *\/\n+record StringToken(String tokenizedString, String value) {\n+    StringToken {\n+        Objects.requireNonNull(tokenizedString);\n+        Objects.requireNonNull(value);\n+\n+        if (!tokenizedString.contains(value)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"String token [%s] must be a substring of the tokenized string [%s]\", value, tokenizedString));\n+        }\n+    }\n+\n+    StringToken(String value) {\n+        this(value, value);\n+    }\n+\n+    static StringToken of(String value) {\n+        return new StringToken(value);\n+    }\n+\n+    static StringToken of(String tokenizedString, String value) {\n+        return new StringToken(tokenizedString, value);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StringToken.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.Objects;\n+import java.util.function.IntPredicate;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+\n+final class Utils {\n+\n+    private Utils() {\n+    }\n+\n+    \/**\n+     * Returns stream of option values with option specs defined in the specified\n+     * class.\n+     * <p>\n+     * The method uses reflection to get public and package private fields of type\n+     * {@link OptionValue} and filters those associated with {@link OptionSpec}\n+     * instances.\n+     *\n+     * @param c the target class\n+     * @return stream of option values with option specs defined in the specified\n+     *         class\n+     *\/\n+    static Stream<? extends OptionValue<?>> getOptionsWithSpecs(Class<?> c) {\n+        return Stream.of(c.getDeclaredFields()).filter(f -> {\n+            return Modifier.isStatic(f.getModifiers());\n+        }).filter(f -> {\n+            if (Modifier.isPublic(f.getModifiers())) {\n+                \/\/ Public is OK.\n+                return true;\n+            } else {\n+                \/\/ Package-private is OK.\n+                return Stream.<IntPredicate>of(Modifier::isPublic, Modifier::isPrivate, Modifier::isProtected).map(p -> {\n+                    return p.test(f.getModifiers());\n+                }).allMatch(v -> !v);\n+            }\n+        }).map(f -> {\n+            f.setAccessible(true);\n+            return toFunction(f::get).apply(null);\n+        }).map(v -> {\n+            OptionValue<?> result;\n+            if (v instanceof OptionValue<?> ov && ov.asOption().isPresent()) {\n+                result = ov;\n+            } else {\n+                result = null;\n+            }\n+            return result;\n+        }).filter(Objects::nonNull);\n+    }\n+\n+    static JOptSimpleOptionsBuilder buildParser(OperatingSystem os, BundlingEnvironment bundlingEnv) {\n+        return new JOptSimpleOptionsBuilder()\n+                .options(StandardOption.options())\n+                .optionSpecMapper(OptionsProcessor.optionSpecMapper(os, bundlingEnv))\n+                .jOptSimpleParserErrorHandler(errDesc -> {\n+                    final String formatId;\n+                    switch (errDesc.type()) {\n+                        case UNRECOGNIZED_OPTION -> {\n+                            formatId = \"ERR_InvalidOption\";\n+                        }\n+                        case OPTION_MISSING_REQUIRED_ARGUMENT -> {\n+                            formatId = \"ERR_InvalidOption\";\n+                        }\n+                        default -> {\n+                            throw new AssertionError();\n+                        }\n+                    }\n+                    return new ParseException(I18N.format(formatId, errDesc.optionName().formatForCommandLine()));\n+                });\n+    }\n+\n+    static final class ParseException extends RuntimeException {\n+\n+        ParseException(String msg) {\n+            super(msg);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Utils.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+@FunctionalInterface\n+interface Validator<T, U extends Exception> {\n+\n+    List<U> validate(OptionName optionName, ParsedValue<T> optionValue);\n+\n+    default Validator<T, ? extends Exception> andThen(Validator<T, ? extends Exception> after) {\n+        return reduce(this, after);\n+    }\n+\n+    \/**\n+     * Thrown to indicate that the given value didn't pass validation.\n+     *\/\n+    static final class ValidatingConsumerException extends RuntimeException {\n+\n+        ValidatingConsumerException(String msg, Exception cause) {\n+            super(msg, Objects.requireNonNull(cause));\n+        }\n+\n+        ValidatingConsumerException(Throwable cause) {\n+            super(Objects.requireNonNull(cause));\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    \/**\n+     * Thrown to indicate an error in the normal execution of a validator.\n+     *\/\n+    static final class ValidatorException extends RuntimeException {\n+\n+        private ValidatorException(Exception cause) {\n+            super(cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    sealed interface ParsedValue<T> {\n+        StringToken sourceToken();\n+        T value();\n+\n+        static <T> ParsedValue<T> create(T value, StringToken sourceToken) {\n+            return new Details.DefaultParsedValue<>(value, sourceToken);\n+        }\n+    }\n+\n+\n+    static <T, U extends Exception> Builder<T, U> build() {\n+        return new Builder<>();\n+    }\n+\n+\n+    static final class Builder<T, U extends Exception> {\n+\n+        Validator<T, U> create() {\n+            return new Details.ScalarValidator<>(\n+                    Optional.ofNullable(predicate),\n+                    Optional.ofNullable(consumer),\n+                    formatString().orElseGet(() -> {\n+                        if (exceptionFactory == null) {\n+                            return \"\";\n+                        } else {\n+                            return null;\n+                        }\n+                    }),\n+                    exceptionFactory().orElseGet(() -> {\n+                        if (formatString == null) {\n+                            return OptionValueExceptionFactory.unreachable();\n+                        } else {\n+                            return null;\n+                        }\n+                    }));\n+        }\n+\n+        private Builder() {\n+        }\n+\n+        Builder(Builder<T, U> other) {\n+            predicate = other.predicate;\n+            consumer = other.consumer;\n+            formatString = other.formatString;\n+            exceptionFactory = other.exceptionFactory;\n+        }\n+\n+        Builder<T, U> copy() {\n+            return new Builder<>(this);\n+        }\n+\n+        Builder<T, U> predicate(Predicate<T> v) {\n+            consumer = null;\n+            predicate = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> consumer(Consumer<T> v) {\n+            predicate = null;\n+            consumer = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> formatString(String v) {\n+            formatString = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> exceptionFactory(OptionValueExceptionFactory<? extends U> v) {\n+            exceptionFactory = v;\n+            return this;\n+        }\n+\n+        Builder<T, U> mutate(Consumer<Builder<T, U>> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n+        Optional<Predicate<T>> predicate() {\n+            return Optional.ofNullable(predicate);\n+        }\n+\n+        Optional<Consumer<T>> consumer() {\n+            return Optional.ofNullable(consumer);\n+        }\n+\n+        boolean hasValidatingMethod() {\n+            return predicate().isPresent() || consumer().isPresent();\n+        }\n+\n+        Optional<String> formatString() {\n+            return Optional.ofNullable(formatString);\n+        }\n+\n+        Optional<OptionValueExceptionFactory<? extends U>> exceptionFactory() {\n+            return Optional.ofNullable(exceptionFactory);\n+        }\n+\n+        private Predicate<T> predicate;\n+        private Consumer<T> consumer;\n+        private String formatString;\n+        private OptionValueExceptionFactory<? extends U> exceptionFactory;\n+    }\n+\n+\n+    static final class Details {\n+\n+        private Details() {\n+        }\n+\n+        private record ScalarValidator<T, U extends Exception>(Optional<Predicate<T>> predicate, Optional<Consumer<T>> consumer,\n+                String formatString, OptionValueExceptionFactory<? extends U> exceptionFactory) implements Validator<T, U> {\n+\n+            ScalarValidator {\n+                Objects.requireNonNull(predicate);\n+                Objects.requireNonNull(consumer);\n+                if (predicate.isEmpty() == consumer.isEmpty()) {\n+                    throw new IllegalArgumentException(\"Either consumer or predicate must be non-empty\");\n+                }\n+                Objects.requireNonNull(formatString);\n+                Objects.requireNonNull(exceptionFactory);\n+            }\n+\n+            @Override\n+            public List<U> validate(OptionName optionName, ParsedValue<T> optionValue) {\n+                Objects.requireNonNull(optionName);\n+                Objects.requireNonNull(optionValue);\n+\n+                try {\n+                    return predicate.map(validator -> {\n+                        if (validator.test(optionValue.value())) {\n+                            return List.<U>of();\n+                        } else {\n+                            return List.of((U)exceptionFactory.create(\n+                                    optionName,\n+                                    optionValue.sourceToken(),\n+                                    formatString,\n+                                    Optional.empty()));\n+                        }\n+                    }).or(() -> {\n+                        return consumer.map(validator -> {\n+                            try {\n+                                validator.accept(optionValue.value());\n+                                return List.of();\n+                            } catch (RuntimeException ex) {\n+                                return handleException(optionName, optionValue, ex);\n+                            }\n+                        });\n+                    }).orElseThrow();\n+                } catch (Exception ex) {\n+                    throw new ValidatorException(ex);\n+                }\n+            }\n+\n+            private List<U> handleException(OptionName optionName,  ParsedValue<T> optionValue, RuntimeException ex) {\n+                if (ex instanceof ValidatingConsumerException) {\n+                    return List.of((U)exceptionFactory.create(\n+                            optionName,\n+                            optionValue.sourceToken(),\n+                            formatString,\n+                            Optional.of((Exception)ex.getCause())));\n+                } else if (ex instanceof IllegalArgumentException) {\n+                    return List.of((U)exceptionFactory.create(\n+                            optionName,\n+                            optionValue.sourceToken(),\n+                            formatString,\n+                            Optional.of(ex)));\n+                } else {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+\n+        private record DefaultParsedValue<T>(T value, StringToken sourceToken) implements ParsedValue<T> {\n+            DefaultParsedValue {\n+                Objects.requireNonNull(sourceToken);\n+                Objects.requireNonNull(value);\n+            }\n+        }\n+    }\n+\n+    @SafeVarargs\n+    private static <T> Validator<T, ? extends Exception> reduce(Validator<T, ? extends Exception>... validators) {\n+        @SuppressWarnings(\"varargs\")\n+        var theValidators = List.of(validators);\n+        return (optionName, optionValue) -> {\n+            return theValidators.stream().map(validator -> {\n+                return validator.validate(optionName, optionValue);\n+            }).flatMap(Collection::stream).map(Exception.class::cast).toList();\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Validator.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+interface ValueConverter<T> {\n+\n+    \/**\n+     * Converts the given string value into a Java type.\n+     *\n+     * @param value the string to convert\n+     * @return the converted value\n+     * @throws IllegalArgumentException if the given string value can not be\n+     *                                  converted to an object of type {@link T}\n+     *\/\n+    T convert(String value) throws IllegalArgumentException;\n+\n+    \/**\n+     * Gives the class of the type of values this converter converts to.\n+     *\n+     * @return the target class for conversion\n+     *\/\n+    Class<? extends T> valueType();\n+\n+    static <T> ValueConverter<T> create(Function<String, T> mapper, Class<? extends T> type) {\n+        Objects.requireNonNull(mapper);\n+        Objects.requireNonNull(type);\n+\n+        return new ValueConverter<>() {\n+\n+            @Override\n+            public T convert(String value) {\n+                Objects.requireNonNull(value);\n+                return Objects.requireNonNull(mapper.apply(value));\n+            }\n+\n+            @Override\n+            public Class<? extends T> valueType() {\n+                return type;\n+            }\n+\n+        };\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/ValueConverter.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+\/**\n+ * A type with an option identifier.\n+ *\/\n+public sealed interface WithOptionIdentifier permits Option, OptionValue, WithOptionIdentifierStub {\n+\n+    OptionIdentifier id();\n+\n+    static WithOptionIdentifier stub(OptionIdentifier id) {\n+        return new WithOptionIdentifierStub(id);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/WithOptionIdentifier.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.Objects;\n+\n+record WithOptionIdentifierStub(OptionIdentifier id) implements WithOptionIdentifier {\n+\n+    WithOptionIdentifierStub {\n+        Objects.requireNonNull(id);\n+    }\n+\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/WithOptionIdentifierStub.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal.model;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-\n-\n-\/**\n- * Creates a bundle from the given specification.\n- *\/\n-@FunctionalInterface\n-public interface BundleCreator<T extends BundleSpec> {\n-\n-    \/**\n-     * Creates a bundle from the given specification in the given directory.\n-     *\n-     * @param spec the bundle specification\n-     * @param dst the directory where to create the bundle\n-     * @throws PackagerException if packaging error occurs\n-     * @throws IOException if an I\/O error occurs\n-     *\/\n-    void create(T spec, Path dst) throws PackagerException, IOException;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundleCreator.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -27,1 +27,4 @@\n-import java.util.Set;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n@@ -35,5 +38,5 @@\n-     * Returns the default bundling operation.\n-     * <p>\n-     * The returned value should be one of the elements in the collection returned by {@link #enabledOperations()} method.\n-     * @return the default bundling operation\n-     * @throws ConfigException in not a single bundling operation can be performed.\n+     * Returns descriptor of the default bundling operation if there is such or an\n+     * empty {@link Optional} instance otherwise.\n+     *\n+     * @return the default bundling operation or an empty {@link Optional} instance\n+     *         if there is no such\n@@ -41,1 +44,1 @@\n-    BundlingOperation defaultOperation() throws ConfigException;\n+    Optional<BundlingOperationDescriptor> defaultOperation();\n@@ -44,2 +47,8 @@\n-     * Returns supported bundling operations.\n-     * @return the supported bundling operations\n+     * Returns configuration errors or an empty list if there are no such errors for\n+     * the target bundling operation.\n+     *\n+     * @param op the descriptor of the target bundling operation\n+     * @return the list of configuration errors or an empty list if there are no\n+     *         such errors for the specified bundling operation\n+     * @throws NoSuchElementException if the specified descriptor denotes an\n+     *                                unsupported bundling operation\n@@ -47,10 +56,2 @@\n-    Set<BundlingOperation> supportedOperations();\n-\n-    \/**\n-     * Returns enabled bundling operations.\n-     * <p>\n-     * The returned value should be a subset of the set returned by {@link #supportedOperations()} method.\n-     * @return the enabled bundling operations\n-     *\/\n-    default Set<BundlingOperation> enabledOperations() {\n-        return supportedOperations();\n+    default Collection<? extends Exception> configurationErrors(BundlingOperationDescriptor op) {\n+        return List.of();\n@@ -58,8 +59,0 @@\n-\n-    \/**\n-     * Returns a bundle creator corresponding to the given bundling operation in this bundling environment.\n-     * @param op the bundling operation\n-     * @return bundle creator corresponding to the given bundling operation in this bundling environment\n-     * @throws IllegalArgumentException if the given bundling operation is not enabled in this bundling environment\n-     *\/\n-    BundleCreator<?> getBundleCreator(BundlingOperation op);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundlingEnvironment.java","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal.model;\n-\n-\/**\n- * Generic bundling operation.\n- * <p>\n- * Bundling operation is comprised of creating of {@link BundleSpec} instance\n- * and using it as an input for {@link BundleCreator#create()} method to create\n- * a bundle.\n- *\/\n-public interface BundlingOperation {\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundlingOperation.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import jdk.internal.util.OperatingSystem;\n+\n+\/**\n+ * Descriptor of a generic bundling operation.\n+ *\n+ * @param os         the target bundle platform\n+ * @param bundleType the target bundle type\n+ * @param verb       the action to be applied to the target bundle\n+ *\/\n+public record BundlingOperationDescriptor(OperatingSystem os, String bundleType, String verb) {\n+    public BundlingOperationDescriptor {\n+        Objects.requireNonNull(os);\n+        Objects.requireNonNull(bundleType);\n+        Objects.requireNonNull(verb);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return os.name() + \":\" + verb + \":\" + bundleType;\n+    }\n+\n+    public static BundlingOperationDescriptor valueOf(String str) {\n+        final var components = str.split(\":\");\n+        return new BundlingOperationDescriptor(OperatingSystem.valueOf(components[0]), components[1], components[2]);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/BundlingOperationDescriptor.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-public class ConfigException extends Exception {\n+public class ConfigException extends JPackageException {\n@@ -63,3 +63,2 @@\n-    public ConfigException(Throwable cause) {\n-        super(cause);\n-        this.advice = null;\n+    public ConfigException(String msg, Throwable cause) {\n+        this(msg, null, cause);\n@@ -108,19 +107,0 @@\n-\n-    \/**\n-     * Throws the cause of the given {@link RuntimeException} exception\n-     * as {@link ConfigException} if the cause is of this type or re-throws the given\n-     * {@link RuntimeException} exception as-is otherwise.\n-     * <p>\n-     * Never return a value. It always throws some exception object.\n-     *\n-     * @param ex exception to re-throw\n-     * @return doesn't return value\n-     * @throws ConfigException\n-     *\/\n-    public static RuntimeException rethrowConfigException(RuntimeException ex) throws ConfigException {\n-        if (ex.getCause() instanceof ConfigException configEx) {\n-            throw configEx;\n-        } else {\n-            throw ex;\n-        }\n-    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ConfigException.java","additions":3,"deletions":23,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n+\n@@ -30,0 +33,5 @@\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.AppImageFileOptionScope;\n+import jdk.jpackage.internal.cli.WithOptionIdentifier;\n@@ -35,1 +43,7 @@\n-public interface ExternalApplication {\n+public sealed interface ExternalApplication {\n+\n+    \/**\n+     * Returns the main launcher configured for the application.\n+     * @return the main launcher configured for the application\n+     *\/\n+    LauncherInfo mainLauncher();\n@@ -43,1 +57,1 @@\n-    List<LauncherInfo> getAddLaunchers();\n+    List<LauncherInfo> addLaunchers();\n@@ -49,1 +63,1 @@\n-    String getAppVersion();\n+    String appVersion();\n@@ -55,13 +69,1 @@\n-    String getAppName();\n-\n-    \/**\n-     * Returns main launcher name.\n-     * @return the main launcher name\n-     *\/\n-    String getLauncherName();\n-\n-    \/**\n-     * Returns main class name.\n-     * @return the main class name\n-     *\/\n-    String getMainClass();\n+    String appName();\n@@ -73,1 +75,1 @@\n-    Map<String, String> getExtra();\n+    Options extra();\n@@ -76,1 +78,1 @@\n-     * Additional launcher description.\n+     * Launcher description.\n@@ -78,6 +80,101 @@\n-    record LauncherInfo(String name, boolean service, Map<String, String> extra) {\n-        public LauncherInfo {\n-            Objects.requireNonNull(name);\n-            Objects.requireNonNull(extra);\n-            if (name.isBlank()) {\n-                throw new IllegalArgumentException();\n+    sealed interface LauncherInfo {\n+\n+        \/**\n+         * Gets the name of the launcher.\n+         * @return the name of the launcher\n+         *\/\n+        String name();\n+\n+        \/**\n+         * Gets optional properties of the launcher.\n+         * @return the optional properties of the launcher\n+         *\/\n+        Options extra();\n+\n+        \/**\n+         * Returns {@code Options} representation of this instance.\n+         * <p>\n+         * Return value contains the value of {@link #NAME} property merged with the\n+         * {@code Options} instance returned by the {@link #extra()} method.\n+         *\n+         * @return the {@code Options} representation of this instance\n+         *\/\n+        default Options asOptions() {\n+            return Options.concat(Options.of(Map.of(NAME, name())), extra());\n+        }\n+\n+        static LauncherInfo create(Options options) {\n+            return new Internal.DefaultLauncherInfo(options);\n+        }\n+    }\n+\n+    static ExternalApplication create(Options appOptions, List<Options> addLauncherOptions, OperatingSystem os) {\n+\n+        var launcherRecognizedOptions = AppImageFileOptionScope.LAUNCHER.options(os).map(WithOptionIdentifier::id).toList();\n+\n+        var recognizedOptions = Stream.concat(\n+                launcherRecognizedOptions.stream(),\n+                AppImageFileOptionScope.APP.options(os).map(WithOptionIdentifier::id)\n+        ).toList();\n+\n+        appOptions = appOptions.copyWith(recognizedOptions);\n+\n+        var addLaunchres = addLauncherOptions.stream().map(options -> {\n+            return options.copyWith(launcherRecognizedOptions);\n+        }).map(Internal.DefaultLauncherInfo::new).map(LauncherInfo.class::cast).toList();\n+\n+        return new Internal.DefaultExternalApplication(appOptions, addLaunchres);\n+    }\n+\n+\n+    static final class Internal {\n+\n+        private Internal() {\n+        }\n+\n+        private record DefaultExternalApplication(Options options, List<LauncherInfo> addLaunchers) implements ExternalApplication {\n+\n+            DefaultExternalApplication {\n+                Objects.requireNonNull(options);\n+                Objects.requireNonNull(addLaunchers);\n+            }\n+\n+            @Override\n+            public String appVersion() {\n+                return APP_VERSION.getFrom(options);\n+            }\n+\n+            @Override\n+            public String appName() {\n+                return NAME.getFrom(options);\n+            }\n+\n+            @Override\n+            public Options extra() {\n+                return options\n+                        .copyWithout(APP_VERSION.id(), NAME.id())\n+                        .copyWithout(AppImageFileOptionScope.LAUNCHER.options().map(WithOptionIdentifier::id).toList());\n+            }\n+\n+            @Override\n+            public LauncherInfo mainLauncher() {\n+                return new DefaultLauncherInfo(options.copyWithout(extra().ids()));\n+            }\n+        }\n+\n+        private record DefaultLauncherInfo(Options options) implements LauncherInfo {\n+\n+            DefaultLauncherInfo {\n+                Objects.requireNonNull(options);\n+            }\n+\n+            @Override\n+            public String name() {\n+                return NAME.getFrom(options);\n+            }\n+\n+            @Override\n+            public Options extra() {\n+                return options\n+                        .copyWithout(NAME.id())\n+                        .copyWithout(AppImageFileOptionScope.APP.options().map(WithOptionIdentifier::id).toList());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ExternalApplication.java","additions":121,"deletions":24,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * Generic jpackage exception with non-null message.\n+ *\/\n+public class JPackageException extends RuntimeException {\n+\n+    public JPackageException(String msg) {\n+        super(Objects.requireNonNull(msg));\n+    }\n+\n+    public JPackageException(String msg, Throwable cause) {\n+        super(Objects.requireNonNull(msg), cause);\n+    }\n+\n+    private static final long serialVersionUID = 1L;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/JPackageException.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Optional;\n+\n@@ -38,0 +40,9 @@\n+    \/**\n+     * Gets the main module version if available or an empty {@link Optional}\n+     * otherwise.\n+     *\n+     * @return the main module version if available or an empty {@link Optional}\n+     *         otherwise\n+     *\/\n+    Optional<String> moduleVersion();\n+\n@@ -41,1 +52,1 @@\n-    record Stub(String moduleName) implements LauncherModularStartupInfoMixin {\n+    record Stub(String moduleName, Optional<String> moduleVersion) implements LauncherModularStartupInfoMixin {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherModularStartupInfoMixin.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal.model;\n-\n-import jdk.jpackage.internal.util.StringBundle;\n-\n-\/**\n- * Signals that error has occurred at packaging phase.\n- * <p>\n- * The preferred way to construct instances of this class is to use\n- * {@link jdk.jpackage.internal.util.LocalizedExceptionBuilder#buildLocalizedException(StringBundle)} methods\n- *\n- * {@snippet :\n- * StringBundle i18n = getStringBundle(); \/\/ Some way to obtain a string bundle with localized messages\n- *\n- * throw buildLocalizedException(i18n).message(\"error.no.name\").create();\n- * }\n- *\/\n-public class PackagerException extends Exception {\n-\n-    private static final long serialVersionUID = 1L;\n-\n-    public PackagerException(Throwable cause) {\n-        super(cause);\n-    }\n-\n-    public PackagerException(String key, Throwable cause) {\n-        super(I18N.getString(key), cause);\n-    }\n-\n-    public PackagerException(String key) {\n-        super(I18N.getString(key));\n-    }\n-\n-    public PackagerException(String key, Object... arguments) {\n-        super(I18N.format(key, arguments));\n-    }\n-\n-    public PackagerException(Throwable cause, String key, Object... arguments) {\n-        super(I18N.format(key, arguments), cause);\n-    }\n-\n-    \/**\n-     * Throws the cause of the given {@link RuntimeException} exception\n-     * as {@link PackagerException} if the cause is of this type or re-throws the given\n-     * {@link RuntimeException} exception as-is otherwise.\n-     * <p>\n-     * Never return a value. It always throws some exception object.\n-     *\n-     * @param ex exception to re-throw\n-     * @return doesn't return value\n-     * @throws PackagerException\n-     *\/\n-    public static RuntimeException rethrowPackagerException(RuntimeException ex) throws PackagerException {\n-        if (ex.getCause() instanceof PackagerException pkgEx) {\n-            throw pkgEx;\n-        } else {\n-            throw ex;\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/PackagerException.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -47,1 +47,1 @@\n-    void create(AppImageLayout appImageLayout) throws PackagerException;\n+    void create(AppImageLayout appImageLayout);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,4 +27,5 @@\n-MSG_Help=Usage: jpackage <options>\\n\\\n-\\n\\\n-Sample usages:\\n\\\n---------------\\n\\\n+help.header=Usage: jpackage <options>\n+\n+help.short=Use jpackage --help (or -h) for a list of possible options\n+\n+help.option-group.sample.create-native-package=\\\n@@ -38,1 +39,3 @@\n-\\            jpackage -n name --app-image appImageDir\\n\\\n+\\            jpackage -n name --app-image appImageDir\n+\n+help.option-group.sample.create-app-image=\\\n@@ -51,1 +54,3 @@\n-\\                -m moduleName\/className --runtime-image appRuntimeImage\\n\\\n+\\                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+help.option-group.sample.create-runtime-installer=\\\n@@ -53,23 +58,28 @@\n-\\        jpackage -n name --runtime-image <runtime-image>\\n\\\n-\\{6}\\\n-\\n\\\n-Generic Options:\\n\\\n-\\  @<filename> \\n\\\n-\\          Read options and\/or mode from a file \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --type -t <type> \\n\\\n-\\          The type of package to create\\n\\\n-\\          Valid values are: {1} \\n\\\n-\\          If this option is not specified a platform dependent\\n\\\n-\\          default type will be created.\\n\\\n-\\  --app-version <version>\\n\\\n-\\          Version of the application and\/or package\\n\\\n-\\  --copyright <copyright string>\\n\\\n-\\          Copyright for the application\\n\\\n-\\  --description <description string>\\n\\\n-\\          Description of the application\\n\\\n-\\  --help -h \\n\\\n-\\          Print the usage text with a list and description of each valid\\n\\\n-\\          option for the current platform to the output stream, and exit\\n\\\n-\\  --icon <file path>\\n\\\n-\\          Path of the icon of the application package\\n\\\n+\\        jpackage -n name --runtime-image <runtime-image>\n+\n+help.option-group.sample.sign-app-image=\\\n+\\    Sign the predefined application image:\\n\\\n+\\        jpackage --type app-image --app-image <app-image> \\\\\\n\\\n+\\            --mac-sign [<additional signing options>...]\\n\\\n+\\        Note: the only additional options that are permitted in this mode are:\\n\\\n+\\              the set of additional mac signing options and --verbose\n+\n+help.option-group.sample=Sample usages\n+help.option-group.generic=Generic Options\n+help.option-group.runtime-image=Options for creating the runtime image\n+help.option-group.app-image=Options for creating the application image\n+help.option-group.launcher=Options for creating the application launcher(s)\n+help.option-group.launcher-platform=Platform dependent option for creating the application launcher\n+help.option-group.package=Options for creating the application package\n+help.option-group.package-platform=Platform dependent options for creating the application package\n+\n+help.option.argument-file=\\\n+\\          Read options and\/or mode from a file\\n\\\n+\\          This option can be used multiple times.\n+\n+help.option.about-url=\\\n+\\          URL of the application's home page\n+\n+help.option.add-launcher.win=\\\n+\\          Name of launcher, and a path to a Properties file that contains\\n\\\n+\\          a list of key, value pairs\\n\\\n@@ -77,4 +87,13 @@\n-\\  --name -n <name>\\n\\\n-\\          Name of the application and\/or package\\n\\\n-\\  --dest -d <destination path>\\n\\\n-\\          Path where generated output file is placed\\n\\\n+\\          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\\n\\\n+\\          \"launcher-as-service\", \"main-class\", \"main-jar\", \"module\",\\n\\\n+\\          \"win-console\", \"win-menu\", and \"win-shortcut\" can be used.\\n\\\n+\\          These options are added to, or used to overwrite, the original\\n\\\n+\\          command line options to build an additional alternative launcher.\\n\\\n+\\          The main application launcher will be built from the command line\\n\\\n+\\          options. Additional alternative launchers can be built using\\n\\\n+\\          this option, and this option can be used multiple times to\\n\\\n+\\          build multiple additional launchers.\n+\n+help.option.add-launcher.linux=\\\n+\\          Name of launcher, and a path to a Properties file that contains\\n\\\n+\\          a list of key, value pairs\\n\\\n@@ -82,3 +101,13 @@\n-\\          Defaults to the current working directory.\\n\\\n-\\  --temp <directory path>\\n\\\n-\\          Path of a new or empty directory used to create temporary files\\n\\\n+\\          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\\n\\\n+\\          \"launcher-as-service\", \"linux-shortcut\", \"main-class\", \"main-jar\",\\n\\\n+\\          and \"module\" can be used.\\n\\\n+\\          These options are added to, or used to overwrite, the original\\n\\\n+\\          command line options to build an additional alternative launcher.\\n\\\n+\\          The main application launcher will be built from the command line\\n\\\n+\\          options. Additional alternative launchers can be built using\\n\\\n+\\          this option, and this option can be used multiple times to\\n\\\n+\\          build multiple additional launchers.\n+\n+help.option.add-launcher.mac=\\\n+\\          Name of launcher, and a path to a Properties file that contains\\n\\\n+\\          a list of key, value pairs\\n\\\n@@ -86,13 +115,11 @@\n-\\          If specified, the temp dir will not be removed upon the task\\n\\\n-\\          completion and must be removed manually.\\n\\\n-\\          If not specified, a temporary directory will be created and\\n\\\n-\\          removed upon the task completion.\\n\\\n-\\  --vendor <vendor string>\\n\\\n-\\          Vendor of the application\\n\\\n-\\  --verbose\\n\\\n-\\          Enables verbose output\\n\\\n-\\  --version\\n\\\n-\\          Print the product version to the output stream and exit.\\n\\\n-\\n\\\n-\\Options for creating the runtime image:\\n\\\n-\\  --add-modules <module name>[,<module name>...]\\n\\\n+\\          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\\n\\\n+\\          \"launcher-as-service\", \"main-class\", \"main-jar\", and \"module\"\\n\\\n+\\          can be used.\\n\\\n+\\          These options are added to, or used to overwrite, the original\\n\\\n+\\          command line options to build an additional alternative launcher.\\n\\\n+\\          The main application launcher will be built from the command line\\n\\\n+\\          options. Additional alternative launchers can be built using\\n\\\n+\\          this option, and this option can be used multiple times to\\n\\\n+\\          build multiple additional launchers.\n+\n+help.option.add-modules=\\\n@@ -103,1 +130,1 @@\n-\\          specified), or the default set of modules (if --main-jar is \\n\\\n+\\          specified), or the default set of modules (if --main-jar is\\n\\\n@@ -105,28 +132,8 @@\n-\\          This option can be used multiple times.\\n\\\n-\\  --module-path -p <module path>...\\n\\\n-\\          A {0} separated list of paths\\n\\\n-\\          Each path is either a directory of modules or the path to a\\n\\\n-\\          modular jar.\\n\\\n-\\          (Each path is absolute or relative to the current directory.)\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --jlink-options <jlink options> \\n\\\n-\\          A space separated list of options to pass to jlink \\n\\\n-\\          If not specified, defaults to \"--strip-native-commands \\n\\\n-\\          --strip-debug --no-man-pages --no-header-files\". \\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --runtime-image <directory path>\\n\\\n-\\          Path of the predefined runtime image that will be copied into\\n\\\n-\\          the application image\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          If --runtime-image is not specified, jpackage will run jlink to\\n\\\n-\\          create the runtime image using options:\\n\\\n-\\          --strip-debug, --no-header-files, --no-man-pages, and\\n\\\n-\\          --strip-native-commands.\\n\\\n-\\n\\\n-\\Options for creating the application image:\\n\\\n-\\  --input -i <directory path>\\n\\\n-\\          Path of the input directory that contains the files to be packaged\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          All files in the input directory will be packaged into the\\n\\\n-\\          application image.\\n\\\n-\\  --app-content <additional content>[,<additional content>...]\\n\\\n+\\          This option can be used multiple times.\n+\n+help.option.app-content=\\\n+\\          A comma separated list of paths to files and\/or directories\\n\\\n+\\          to add to the application payload.\\n\\\n+\\          This option can be used more than once.\n+\n+help.option.app-content.mac=\\\n@@ -136,18 +143,21 @@\n-{7}\\n\\\n-\\Options for creating the application launcher(s):\\n\\\n-\\  --add-launcher <launcher name>=<file path>\\n\\\n-\\          Name of launcher, and a path to a Properties file that contains\\n\\\n-\\          a list of key, value pairs\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\          The keys \"module\", \"main-jar\", \"main-class\", \"description\",\\n\\\n-\\          \"arguments\", \"java-options\", \"app-version\", \"icon\",\\n\\\n-\\          \"launcher-as-service\",\\n\\\n-\\          \"win-console\", \"win-shortcut\", \"win-menu\",\\n\\\n-\\          \"linux-app-category\", and \"linux-shortcut\" can be used.\\n\\\n-\\          These options are added to, or used to overwrite, the original\\n\\\n-\\          command line options to build an additional alternative launcher.\\n\\\n-\\          The main application launcher will be built from the command line\\n\\\n-\\          options. Additional alternative launchers can be built using\\n\\\n-\\          this option, and this option can be used multiple times to\\n\\\n-\\          build multiple additional launchers. \\n\\\n-\\  --arguments <main class arguments>\\n\\\n+\\          Note: The value should be a directory with the \"Resources\"\\n\\\n+\\          subdirectory (or any other directory that is valid in the \"Contents\"\\n\\\n+\\          directory of the application bundle). Otherwise, jpackage may produce\\n\\\n+\\          invalid application bundle which may fail code signing and\/or\\n\\\n+\\          notarization.\n+\n+help.option.app-image=\\\n+\\          Location of the predefined application image that is used\\n\\\n+\\          to build an installable package\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+help.option.app-image.mac=\\\n+\\          Location of the predefined application image that is used\\n\\\n+\\          to build an installable package or to sign the predefined\\n\\\n+\\          application image\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+help.option.app-version=\\\n+\\          Version of the application and\/or package\n+\n+help.option.arguments=\\\n@@ -156,24 +166,10 @@\n-\\          This option can be used multiple times.\\n\\\n-\\  --java-options <java options>\\n\\\n-\\          Options to pass to the Java runtime\\n\\\n-\\          This option can be used multiple times.\\n\\\n-\\  --main-class <class name>\\n\\\n-\\          Qualified name of the application main class to execute\\n\\\n-\\          This option can only be used if --main-jar is specified.\\n\\\n-\\  --main-jar <main jar file>\\n\\\n-\\          The main JAR of the application; containing the main class\\n\\\n-\\          (specified as a path relative to the input path)\\n\\\n-\\          Either --module or --main-jar option can be specified but not\\n\\\n-\\          both.\\n\\\n-\\  --module -m <module name>[\/<main class>]\\n\\\n-\\          The main module (and optionally main class) of the application\\n\\\n-\\          This module must be located on the module path.\\n\\\n-\\          When this option is specified, the main module will be linked\\n\\\n-\\          in the Java runtime image.  Either --module or --main-jar\\n\\\n-\\          option can be specified but not both.\\n\\\n-{2}\\n\\\n-\\Options for creating the application package:\\n\\\n-\\  --about-url <url>\\n\\\n-\\          URL of the application''s home page\\n\\\n-\\  --app-image <directory path>\\n\\\n-\\          {5}\\\n+\\          This option can be used multiple times.\n+\n+help.option.copyright=\\\n+\\          Copyright for the application\n+\n+help.option.description=\\\n+\\          Description of the application\n+\n+help.option.dest=\\\n+\\          Path where generated output file is placed\\n\\\n@@ -181,1 +177,3 @@\n-\\  --file-associations <file path>\\n\\\n+\\          Defaults to the current working directory.\n+\n+help.option.file-associations=\\\n@@ -186,10 +184,12 @@\n-\\          This option can be used multiple times.\\n\\\n-\\  --install-dir <directory path>\\n\\\n-\\          {4}\\\n-\\  --license-file <file path>\\n\\\n-\\          Path to the license file\\n\\\n-\\          (absolute path or relative to the current directory)\\n\\\n-\\  --resource-dir <directory path>\\n\\\n-\\          Path to override jpackage resources\\n\\\n-\\          Icons, template files, and other resources of jpackage can be\\n\\\n-\\          over-ridden by adding replacement resources to this directory.\\n\\\n+\\          This option can be used multiple times.\n+\n+help.option.help=\\\n+\\          Print the usage text with a list and description of each valid\\n\\\n+\\          option for the current platform to the output stream, and exit\n+\n+help.option.icon=\\\n+\\          Path of the icon of the application package\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+help.option.input=\\\n+\\          Path of the input directory that contains the files to be packaged\\n\\\n@@ -197,1 +197,11 @@\n-\\  --runtime-image <directory path>\\n\\\n+\\          All files in the input directory will be packaged into the\\n\\\n+\\          application image.\n+\n+help.option.install-dir=\\\n+\\          Absolute path of the installation directory of the application\n+\n+help.option.install-dir.win=\\\n+\\          Relative sub-path of the installation location of\\n\\\n+\\          the application such as \"Program Files\" or \"AppData\".\n+\n+help.option.installer-runtime-image=\\\n@@ -200,2 +210,13 @@\n-\\          Option is required when creating a runtime package.\\n\\\n-\\  --launcher-as-service\\n\\\n+\\          Option is required when creating a runtime package.\n+\n+help.option.java-options=\\\n+\\          Options to pass to the Java runtime\\n\\\n+\\          This option can be used multiple times.\n+\n+help.option.jlink-options=\\\n+\\          A space separated list of options to pass to jlink\\n\\\n+\\          If not specified, defaults to \"--strip-native-commands\\n\\\n+\\          --strip-debug --no-man-pages --no-header-files\".\\n\\\n+\\          This option can be used multiple times.\n+\n+help.option.launcher-as-service=\\\n@@ -203,11 +224,1 @@\n-\\          application launcher as a background service-type application.\\n\\\n-\\n\\\n-\\Platform dependent options for creating the application package:\\n\\\n-{3}\n-\n-MSG_Help_win_launcher=\\\n-\\n\\\n-\\Platform dependent option for creating the application launcher:\\n\\\n-\\  --win-console\\n\\\n-\\          Creates a console launcher for the application, should be\\n\\\n-\\          specified for application which requires console interactions\\n\\\n+\\          application launcher as a background service-type application.\n@@ -215,21 +226,20 @@\n-MSG_Help_win_install=\\\n-\\  --win-dir-chooser\\n\\\n-\\          Adds a dialog to enable the user to choose a directory in which\\n\\\n-\\          the product is installed.\\n\\\n-\\  --win-help-url <url>\\n\\\n-\\          URL where user can obtain further information or technical support\\n\\\n-\\  --win-menu\\n\\\n-\\          Request to add a Start menu shortcut for this application\\n\\\n-\\  --win-menu-group <menu group name>\\n\\\n-\\          Start Menu group this application is placed in\\n\\\n-\\  --win-per-user-install\\n\\\n-\\          Request to perform an install on a per-user basis\\n\\\n-\\  --win-shortcut\\n\\\n-\\          Request to add desktop shortcut for this application\\n\\\n-\\  --win-shortcut-prompt\\n\\\n-\\          Adds a dialog to enable the user to choose if shortcuts\\n\\\n-\\          will be created by installer.\\n\\\n-\\  --win-update-url <url>\\n\\\n-\\          URL of available application update information\\n\\\n-\\  --win-upgrade-uuid <id string>\\n\\\n-\\          UUID associated with upgrades for this package\\n\\\n+help.option.license-file=\\\n+\\          Path to the license file\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+help.option.linux-app-category=\\\n+\\          Group value of the RPM <name>.spec file or\\n\\\n+\\          Section value of DEB control file\n+\n+help.option.linux-app-release=\\\n+\\          Release value of the RPM <name>.spec file or\\n\\\n+\\          Debian revision value of the DEB control file\n+\n+help.option.linux-deb-maintainer=\\\n+\\          Maintainer for .deb package\n+\n+help.option.linux-menu-group=\\\n+\\          Menu group this application is placed in\n+\n+help.option.linux-package-deps=\\\n+\\          Required packages or capabilities for the application\n@@ -237,2 +247,2 @@\n-MSG_Help_win_install_dir=\\\n-\\Relative sub-path under the default installation location\\n\\\n+help.option.linux-package-name=\\\n+\\          Name for Linux package, defaults to the application name\n@@ -240,2 +250,20 @@\n-MSG_Help_mac_install=\\\n-\\  --mac-dmg-content <additional content path>[,<additional content path>...]\\n\\\n+help.option.linux-rpm-license-type=\\\n+\\          Type of the license (\"License: <value>\" of the RPM .spec)\n+\n+help.option.linux-shortcut=\\\n+\\          Creates a shortcut for the application.\n+\n+help.option.mac-app-category=\\\n+\\          String used to construct LSApplicationCategoryType in\\n\\\n+\\          application plist.  The default value is \"utilities\".\n+\n+help.option.mac-app-image-sign-identity=\\\n+\\          Identity used to sign application image. This value will be passed\\n\\\n+\\          directly to --sign option of \"codesign\" tool. This option cannot\\n\\\n+\\          be combined with --mac-signing-key-user-name.\n+\n+help.option.mac-app-store=\\\n+\\          Indicates that the jpackage output is intended for the\\n\\\n+\\          Mac App Store.\n+\n+help.option.mac-dmg-content=\\\n@@ -243,1 +271,10 @@\n-\\          This option can be used multiple times. \\n\\\n+\\          This option can be used multiple times.\n+\n+help.option.mac-entitlements=\\\n+\\          Path to file containing entitlements to use when signing\\n\\\n+\\          executables and libraries in the bundle.\n+\n+help.option.mac-installer-sign-identity=\\\n+\\          Identity used to sign \"pkg\" installer. This value will be passed\\n\\\n+\\          directly to --sign option of \"productbuild\" tool. This option\\n\\\n+\\          cannot be combined with --mac-signing-key-user-name.\n@@ -245,2 +282,1 @@\n-MSG_Help_mac_launcher=\\\n-\\  --mac-package-identifier <ID string>\\n\\\n+help.option.mac-package-identifier=\\\n@@ -250,2 +286,3 @@\n-\\          and period (.) characters.\\n\\\n-\\  --mac-package-name <name string>\\n\\\n+\\          and period (.) characters.\n+\n+help.option.mac-package-name=\\\n@@ -256,2 +293,3 @@\n-\\          Defaults to the application name.\\n\\\n-\\  --mac-package-signing-prefix <prefix string>\\n\\\n+\\          Defaults to the application name.\n+\n+help.option.mac-package-signing-prefix=\\\n@@ -260,2 +298,3 @@\n-\\          an existing package identifier.\\n\\\n-\\  --mac-sign\\n\\\n+\\          an existing package identifier.\n+\n+help.option.mac-sign=\\\n@@ -263,2 +302,3 @@\n-\\          signed.\\n\\\n-\\  --mac-signing-keychain <keychain name>\\n\\\n+\\          signed.\n+\n+help.option.mac-signing-keychain=\\\n@@ -266,2 +306,3 @@\n-\\          If not specified, the standard keychains are used.\\n\\\n-\\  --mac-signing-key-user-name <team name>\\n\\\n+\\          If not specified, the standard keychains are used.\n+\n+help.option.mac-signing-key-user-name=\\\n@@ -272,53 +313,1 @@\n-\\          --mac-app-image-sign-identity or --mac-installer-sign-identity.\\n\\\n-\\  --mac-app-image-sign-identity <identity>\\n\\\n-\\          Identity used to sign application image. This value will be passed\\n\\\n-\\          directly to --sign option of \"codesign\" tool. This option cannot\\n\\\n-\\          be combined with --mac-signing-key-user-name.\\n\\\n-\\  --mac-installer-sign-identity <identity>\\n\\\n-\\          Identity used to sign \"pkg\" installer. This value will be passed\\n\\\n-\\          directly to --sign option of \"productbuild\" tool. This option\\n\\\n-\\          cannot be combined with --mac-signing-key-user-name.\\n\\\n-\\  --mac-app-store\\n\\\n-\\          Indicates that the jpackage output is intended for the\\n\\\n-\\          Mac App Store.\\n\\\n-\\  --mac-entitlements <file path>\\n\\\n-\\          Path to file containing entitlements to use when signing\\n\\\n-\\          executables and libraries in the bundle.\\n\\\n-\\  --mac-app-category <category string>\\n\\\n-\\          String used to construct LSApplicationCategoryType in\\n\\\n-\\          application plist.  The default value is \"utilities\".\\n\\\n-\n-MSG_Help_linux_install=\\\n-\\  --linux-package-name <package name>\\n\\\n-\\          Name for Linux package, defaults to the application name\\n\\\n-\\  --linux-deb-maintainer <email address>\\n\\\n-\\          Maintainer for .deb package\\n\\\n-\\  --linux-menu-group <menu-group-name>\\n\\\n-\\          Menu group this application is placed in\\n\\\n-\\  --linux-package-deps <package-dep-string>\\n\\\n-\\          Required packages or capabilities for the application\\n\\\n-\\  --linux-rpm-license-type <type string>\\n\\\n-\\          Type of the license (\"License: <value>\" of the RPM .spec)\\n\\\n-\\  --linux-app-release <release value>\\n\\\n-\\          Release value of the RPM <name>.spec file or \\n\\\n-\\          Debian revision value of the DEB control file\\n\\\n-\\  --linux-app-category <category value>\\n\\\n-\\          Group value of the RPM <name>.spec file or \\n\\\n-\\          Section value of DEB control file\\n\\\n-\\  --linux-shortcut\\n\\\n-\\          Creates a shortcut for the application.\\n\\\n-\n-MSG_Help_mac_linux_install_dir=\\\n-\\Absolute path of the installation directory of the application\\n\\\n-\n-MSG_Help_default_install_dir=\\\n-\\Absolute path of the installation directory of the application on OS X\\n\\\n-\\          or Linux. Relative sub-path of the installation location of\\n\\\n-\\          the application such as \"Program Files\" or \"AppData\" on Windows.\\n\\\n-\n-MSG_Help_no_args=Usage: jpackage <options>\\n\\\n-\\Use jpackage --help (or -h) for a list of possible options\\\n-\n-MSG_Help_default_app_image=\\\n-\\Location of the predefined application image that is used\\n\\\n-\\          to build an installable package\\n\\\n+\\          --mac-app-image-sign-identity or --mac-installer-sign-identity.\n@@ -326,4 +315,3 @@\n-MSG_Help_mac_app_image=\\\n-\\Location of the predefined application image that is used\\n\\\n-\\          to build an installable package or to sign the predefined\\n\\\n-\\          application image\\n\\\n+help.option.main-class=\\\n+\\          Qualified name of the application main class to execute\\n\\\n+\\          This option can only be used if --main-jar is specified.\n@@ -331,6 +319,109 @@\n-MSG_Help_mac_sign_sample_usage=\\\n-\\    Sign the predefined application image:\\n\\\n-\\        jpackage --type app-image --app-image <app-image> \\\\\\n\\\n-\\            --mac-sign [<additional signing options>...]\\n\\\n-\\        Note: the only additional options that are permitted in this mode are:\\n\\\n-\\              the set of additional mac signing options and --verbose\\n\\\n+help.option.main-jar=\\\n+\\          The main JAR of the application; containing the main class\\n\\\n+\\          (specified as a path relative to the input path)\\n\\\n+\\          Either --module or --main-jar option can be specified but not\\n\\\n+\\          both.\n+\n+help.option.module=\\\n+\\          The main module (and optionally main class) of the application\\n\\\n+\\          This module must be located on the module path.\\n\\\n+\\          When this option is specified, the main module will be linked\\n\\\n+\\          in the Java runtime image.  Either --module or --main-jar\\n\\\n+\\          option can be specified but not both.\n+\n+help.option.module-path=\\\n+\\          A : separated list of paths\\n\\\n+\\          Each path is either a directory of modules or the path to a\\n\\\n+\\          modular jar.\\n\\\n+\\          (Each path is absolute or relative to the current directory.)\\n\\\n+\\          This option can be used multiple times.\n+help.option.module-path.win=\\\n+\\          A ; separated list of paths\\n\\\n+\\          Each path is either a directory of modules or the path to a\\n\\\n+\\          modular jar.\\n\\\n+\\          (Each path is absolute or relative to the current directory.)\\n\\\n+\\          This option can be used multiple times.\n+\n+help.option.name=\\\n+\\          Name of the application and\/or package\n+\n+help.option.resource-dir=\\\n+\\          Path to override jpackage resources\\n\\\n+\\          Icons, template files, and other resources of jpackage can be\\n\\\n+\\          over-ridden by adding replacement resources to this directory.\\n\\\n+\\          (absolute path or relative to the current directory)\n+\n+help.option.runtime-image=\\\n+\\          Path of the predefined runtime image that will be copied into\\n\\\n+\\          the application image\\n\\\n+\\          (absolute path or relative to the current directory)\\n\\\n+\\          If --runtime-image is not specified, jpackage will run jlink to\\n\\\n+\\          create the runtime image using options:\\n\\\n+\\          --strip-debug, --no-header-files, --no-man-pages, and\\n\\\n+\\          --strip-native-commands.\n+\n+help.option.temp=\\\n+\\          Path of a new or empty directory used to create temporary files\\n\\\n+\\          (absolute path or relative to the current directory)\\n\\\n+\\          If specified, the temp dir will not be removed upon the task\\n\\\n+\\          completion and must be removed manually.\\n\\\n+\\          If not specified, a temporary directory will be created and\\n\\\n+\\          removed upon the task completion.\n+\n+help.option.type.win=\\\n+\\          The type of package to create\\n\\\n+\\          Valid values are: {\"app-image\", \"exe\", \"msi\"}\\n\\\n+\\          If this option is not specified a platform dependent\\n\\\n+\\          default type will be created.\n+help.option.type.linux=\\\n+\\          The type of package to create\\n\\\n+\\          Valid values are: {\"app-image\", \"deb\", \"rpm\"}\\n\\\n+\\          If this option is not specified a platform dependent\\n\\\n+\\          default type will be created.\n+help.option.type.mac=\\\n+\\          The type of package to create\\n\\\n+\\          Valid values are: {\"app-image\", \"dmg\", \"pkg\"}\\n\\\n+\\          If this option is not specified a platform dependent\\n\\\n+\\          default type will be created.\n+\n+help.option.vendor=\\\n+\\          Vendor of the application\n+\n+help.option.verbose=\\\n+\\          Enables verbose output\n+\n+help.option.version=\\\n+\\          Print the product version to the output stream and exit.\n+\n+help.option.win-console=\\\n+\\          Creates a console launcher for the application, should be\\n\\\n+\\          specified for application which requires console interactions\n+\n+help.option.win-dir-chooser=\\\n+\\          Adds a dialog to enable the user to choose a directory in which\\n\\\n+\\          the product is installed.\n+\n+help.option.win-help-url=\\\n+\\          URL where user can obtain further information or technical support\n+\n+help.option.win-menu=\\\n+\\          Request to add a Start menu shortcut for this application\n+\n+help.option.win-menu-group=\\\n+\\          Start Menu group this application is placed in\n+\n+help.option.win-per-user-install=\\\n+\\          Request to perform an install on a per-user basis\n+\n+help.option.win-shortcut=\\\n+\\          Request to add desktop shortcut for this application\n+\n+help.option.win-shortcut-prompt=\\\n+\\          Adds a dialog to enable the user to choose if shortcuts\\n\\\n+\\          will be created by installer.\n+\n+help.option.win-update-url=\\\n+\\          URL of available application update information\n+\n+help.option.win-upgrade-uuid=\\\n+\\          UUID associated with upgrades for this package\n@@ -338,6 +429,0 @@\n-MSG_Help_mac_app_content_note=\\\n-\\          Note: The value should be a directory with the \"Resources\"\\n\\\n-\\          subdirectory (or any other directory that is valid in the \"Contents\"\\n\\\n-\\          directory of the application bundle). Otherwise, jpackage may produce\\n\\\n-\\          invalid application bundle which may fail code signing and\/or\\n\\\n-\\          notarization.\\n\\\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/HelpResources.properties","additions":337,"deletions":252,"binary":false,"changes":589,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-jpackage.description=package a self-contained Java application\n-\n@@ -30,1 +28,0 @@\n-param.description.default=None\n@@ -33,0 +30,10 @@\n+bundle-type.win-app=Windows Application Image\n+bundle-type.win-exe=EXE Installer Package\n+bundle-type.win-msi=MSI Installer Package\n+bundle-type.mac-app=Mac Application Image\n+bundle-type.mac-dmg=Mac DMG Package\n+bundle-type.mac-pkg=Mac PKG Package\n+bundle-type.linux-app=Linux Application Image\n+bundle-type.linux-deb=DEB Bundle\n+bundle-type.linux-rpm=RPM Bundle\n+\n@@ -40,2 +47,0 @@\n-message.runtime-image-dir-does-not-exist=Specified runtime image directory {0}: {1} does not exist\n-message.resource-dir-does-not-exist=Specified resource directory {0}: {1} does not exist\n@@ -45,1 +50,3 @@\n-message.module-class=Using class \"{0}\" from module \"{1}\" as application main class\n+\n+message.error-header={0}\n+message.advice-header=Advice to fix: {0}\n@@ -53,1 +60,1 @@\n-error.root-exists=Error: Application destination directory {0} already exists\n+error.root-exists=Application destination directory {0} already exists\n@@ -56,2 +63,0 @@\n-error.no-main-class=A main class was not specified nor was one found in the supplied application resources\n-error.no-main-class.advice=Please specify a application class or ensure that the appResources has a jar containing one in the manifest\n@@ -61,1 +66,0 @@\n-error.not-path-parameter=\"Invalid value of {0} parameter: {1}\"\n@@ -64,0 +68,17 @@\n+error.non-option-arguments=Found {0} non-option arguments on the command line. Non-option arguments are not allowed\n+error.undefined-default-bundling-operation=Default bundling operation is undefined\n+error.undefined-default-bundling-operation.advice=Add {0} parameter to the command line\n+error.parameter-not-uuid=The value \"{0}\" provided for parameter {1} is not a valid UUID\n+error.parameter-not-path=The value \"{0}\" provided for parameter {1} is not a valid path\n+error.parameter-not-file=The value \"{0}\" provided for parameter {1} is not a file\n+error.parameter-not-directory=The value \"{0}\" provided for parameter {1} is not a directory\n+error.parameter-not-empty-directory=The value \"{0}\" provided for parameter {1} is not an empty directory or non existent path\n+error.parameter-not-url=The value \"{0}\" provided for parameter {1} is not a valid URL\n+error.parameter-not-launcher-shortcut-dir=The value \"{0}\" provided for parameter {1} is not a valid shortcut startup directory\n+error.path-parameter-ioexception=I\/O error accessing path value \"{0}\" of parameter {1}\n+error.parameter-add-launcher-malformed=The value \"{0}\" provided for parameter {1} does not match the pattern <name>=<file path>\n+error.parameter-add-launcher-not-file=The value of path to a property file \"{0}\" provided for additional launcher \"{1}\" is not a valid file path\n+error.properties-parameter-not-path=The value \"{0}\" provided for property \"{1}\" in \"{2}\" file is not a valid path\n+error.properties-parameter-not-file=The value \"{0}\" provided for property \"{1}\" in \"{2}\" file is not a file\n+error.properties-parameter-not-launcher-shortcut-dir=The value \"{0}\" provided for property \"{1}\" in \"{2}\" file is not a valid shortcut startup directory\n+\n@@ -69,0 +90,2 @@\n+error.launcher-duplicate-name=Multiple launchers have the same name \"{0}\". Launchers should have unique names\n+\n@@ -81,2 +104,4 @@\n-error.foreign-app-image=Error: Missing .jpackage.xml file in app-image dir \"{0}\"\n-error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\" file\n+error.missing-app-image-file=\"{0}\" file is missing in the predefined app image \"{1}\"\n+error.invalid-app-image-file=\"{0}\" file in the predefined app image \"{1}\" is corrupted or was created by another version of jpackage\n+error.malformed-app-image-file=\"{0}\" file in the predefined app image \"{1}\" contains malformed XML data\n+error.reading-app-image-file=Failed to read \"{0}\" file in the predefined app image \"{1}\"\n@@ -86,31 +111,15 @@\n-error.invalid-option-value=Invalid value \"{0}\" of option {1}\n-\n-MSG_BundlerFailed=Error: Bundler \"{1}\" ({0}) failed to produce a package\n-MSG_BundlerConfigException=Bundler {0} skipped because of a configuration problem: {1} \\n\\\n-Advice to fix: {2}\n-MSG_BundlerConfigExceptionNoAdvice=Bundler {0} skipped because of a configuration problem: {1}\n-MSG_BundlerRuntimeException=Bundler {0} failed because of {1}\n-\n-ERR_NoMainClass=Error: Main application class is missing\n-ERR_UnsupportedOption=Error: Option [{0}] is not valid on this platform\n-ERR_InvalidTypeOption=Error: Option [{0}] is not valid with type [{1}]\n-ERR_NoInstallerEntryPoint=Error: Option [{0}] is not valid without --module or --main-jar entry point option\n-ERR_MutuallyExclusiveOptions=Error: Mutually exclusive options [{0}] and [{1}]\n-ERR_InvalidOptionWithAppImageSigning=Error: Option [{0}] is not valid when signing application image\n-\n-ERR_MissingArgument=Error: Missing argument: {0}\n-ERR_MissingRequiredArgument=Error: {0} argument requires at least one of [{1}] argument(s)\n-ERR_AppImageNotExist=Error: App image directory \"{0}\" does not exist\n-ERR_NoAddLauncherName=Error: --add-launcher option requires a name and a file path (--add-launcher <name>=<file path>)\n-ERR_NoUniqueName=Error: --add-launcher <name>=<file path> requires a unique name\n-ERR_InvalidAppName=Error: Invalid Application name: {0}\n-ERR_InvalidSLName=Error: Invalid Add Launcher name: {0}\n-ERR_IconFileNotExit=Error: Specified icon file [{0}] does not exist\n-ERR_LicenseFileNotExit=Error: Specified license file does not exist\n-ERR_BuildRootInvalid=Error: temp ({0}) must be non-existent or empty directory\n-ERR_InvalidOption=Error: Invalid Option: [{0}]\n-ERR_InvalidInstallerType=Error: Invalid or unsupported type: [{0}]\n-ERR_BothMainJarAndModule=Error: Cannot have both --main-jar and --module Options\n-ERR_NoEntryPoint=Error: creating application image requires --main-jar or --module Option\n-ERR_CannotParseOptions=Error: Processing @filename option: {0}\n-ERR_MissingJLinkOptMacAppStore=Error: --mac-app-store argument requires a {0} option for --jlink-options argument\n+ERR_NoMainClass=Main application class is missing\n+ERR_UnsupportedOption=Option [{0}] is not valid on this platform\n+ERR_InvalidTypeOption=Option [{0}] is not valid with type [{1}]\n+ERR_NoInstallerEntryPoint=Option [{0}] is not valid without --module or --main-jar entry point option\n+ERR_MutuallyExclusiveOptions=Mutually exclusive options [{0}] and [{1}]\n+ERR_InvalidOptionWithAppImageSigning=Option [{0}] is not valid when signing application image\n+\n+ERR_MissingArgument2=Missing argument: {0} or {1}\n+ERR_InvalidAppName=Invalid Application name: {0}\n+ERR_InvalidSLName=Invalid Add Launcher name: {0}\n+ERR_InvalidOption=Invalid Option: [{0}]\n+ERR_InvalidInstallerType=Invalid or unsupported type: [{0}]\n+ERR_NoEntryPoint=creating application image requires --main-jar or --module Option\n+ERR_CannotParseOptions=Processing @filename option: {0}\n+ERR_MissingJLinkOptMacAppStore=--mac-app-store argument requires a {0} option for --jlink-options argument\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":52,"deletions":43,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.file.NotLinkException;\n@@ -103,0 +104,13 @@\n+    public static Path readSymlinkTargetRecursive(Path symlink) throws IOException, NotLinkException {\n+        try {\n+            var target = Files.readSymbolicLink(symlink);\n+            if (Files.isSymbolicLink(target)) {\n+                return readSymlinkTargetRecursive(target);\n+            } else {\n+                return target;\n+            }\n+        } catch (NotLinkException ex) {\n+            throw ex;\n+        }\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/FileUtils.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+public final class SetBuilder<T> {\n+\n+    public static <T> SetBuilder<T> build(Class<? extends T> type) {\n+        return new SetBuilder<>();\n+    }\n+\n+    public SetBuilder<T> set(Collection<? extends T> v) {\n+        return clear().add(v);\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"varargs\")\n+    public final SetBuilder<T> set(T... v) {\n+        return set(List.of(v));\n+    }\n+\n+    public SetBuilder<T> add(Collection<? extends T> v) {\n+        values.addAll(v);\n+        return this;\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"varargs\")\n+    public final SetBuilder<T> add(T... v) {\n+        return add(List.of(v));\n+    }\n+\n+    public SetBuilder<T> remove(Collection<? extends T> v) {\n+        values.removeAll(v);\n+        return this;\n+    }\n+\n+    @SafeVarargs\n+    @SuppressWarnings(\"varargs\")\n+    public final SetBuilder<T> remove(T... v) {\n+        return remove(List.of(v));\n+    }\n+\n+    public SetBuilder<T> clear() {\n+        values.clear();\n+        return this;\n+    }\n+\n+    public SetBuilder<T> emptyAllowed(boolean v) {\n+        emptyAllowed = v;\n+        return this;\n+    }\n+\n+    public Set<T> create() {\n+        if (values.isEmpty() && !emptyAllowed) {\n+            throw new UnsupportedOperationException();\n+        }\n+        return Set.copyOf(values);\n+    }\n+\n+    private boolean emptyAllowed;\n+    private final Set<T> values = new HashSet<>();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/SetBuilder.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -28,11 +28,0 @@\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.nio.file.NoSuchFileException;\n-import java.text.MessageFormat;\n-import java.util.ResourceBundle;\n-import jdk.internal.opt.CommandLine;\n-import jdk.jpackage.internal.Arguments;\n-import jdk.jpackage.internal.CLIHelp;\n-import jdk.jpackage.internal.Log;\n-\n@@ -41,3 +30,0 @@\n-    public static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MainResources\");\n-\n@@ -50,70 +36,2 @@\n-    public static void main(String... args) throws Exception {\n-\n-        PrintWriter out = new PrintWriter(System.out);\n-        PrintWriter err = new PrintWriter(System.err);\n-        int status = new jdk.jpackage.main.Main().execute(out, err, args);\n-        System.exit(status);\n-    }\n-\n-    \/**\n-     * execute() - this is the entry point for the ToolProvider API.\n-     *\n-     * @param out output stream\n-     * @param err error output stream\n-     * @param args command line arguments\n-     * @return an exit code. 0 means success, non-zero means an error occurred.\n-     *\/\n-    public int execute(PrintWriter out, PrintWriter err, String... args) {\n-        Log.setPrintWriter(out, err);\n-\n-        try {\n-            String[] newArgs;\n-            try {\n-                newArgs = CommandLine.parse(args);\n-            } catch (FileNotFoundException|NoSuchFileException fnfe) {\n-                Log.fatalError(MessageFormat.format(I18N.getString(\n-                        \"ERR_CannotParseOptions\"), fnfe.getMessage()));\n-                return 1;\n-            } catch (IOException ioe) {\n-                Log.fatalError(ioe.getMessage());\n-                return 1;\n-            }\n-\n-            if (newArgs.length == 0) {\n-                CLIHelp.showHelp(true);\n-            } else if (hasHelp(newArgs)){\n-                if (hasVersion(newArgs)) {\n-                    Log.info(System.getProperty(\"java.version\") + \"\\n\");\n-                }\n-                CLIHelp.showHelp(false);\n-            } else if (hasVersion(newArgs)) {\n-                Log.info(System.getProperty(\"java.version\"));\n-            } else {\n-                Arguments arguments = new Arguments(newArgs);\n-                if (!arguments.processArguments()) {\n-                    \/\/ processArguments() will log error message if failed.\n-                    return 1;\n-                }\n-            }\n-            return 0;\n-        } finally {\n-            Log.flush();\n-        }\n-    }\n-\n-    private boolean hasHelp(String[] args) {\n-        for (String a : args) {\n-            if (\"--help\".equals(a) || \"-h\".equals(a)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private boolean hasVersion(String[] args) {\n-        for (String a : args) {\n-            if (\"--version\".equals(a)) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    public static void main(String... args) {\n+        jdk.jpackage.internal.cli.Main.main(args);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/main\/Main.java","additions":2,"deletions":84,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -38,6 +38,0 @@\n- * @implNote The {@code jpackage} tool is not thread-safe. An application\n- * should not call either of the\n- * {@link java.util.spi.ToolProvider ToolProvider} {@code run} methods\n- * concurrently, even with separate {@code \"jpackage\"} {@code ToolProvider}\n- * instances, or undefined behavior may result.\n- *\n@@ -59,5 +53,1 @@\n-    uses jdk.jpackage.internal.Bundler;\n-    uses jdk.jpackage.internal.Bundlers;\n-\n-    provides jdk.jpackage.internal.Bundlers with\n-        jdk.jpackage.internal.BasicBundlers;\n+        uses jdk.jpackage.internal.cli.CliBundlingEnvironment;\n@@ -66,1 +56,1 @@\n-        with jdk.jpackage.internal.JPackageToolProvider;\n+        with jdk.jpackage.internal.cli.Main.Provider;\n","filename":"src\/jdk.jpackage\/share\/classes\/module-info.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-public class WinAppBundler extends AppImageBundler {\n-    public WinAppBundler() {\n-        setAppImageSupplier((params, output) -> {\n-            \/\/ Order is important!\n-            var app = WinFromParams.APPLICATION.fetchFrom(params);\n-            var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-            WinPackagingPipeline.build()\n-                    .excludeDirFromCopying(output.getParent())\n-                    .create().execute(BuildEnv.withAppImageDir(env, output), app);\n-        });\n-    }\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinAppBundler.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.WinFromOpions.createWinApplication;\n+import static jdk.jpackage.internal.WinPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_WIN_APP_IMAGE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_WIN_EXE;\n+import static jdk.jpackage.internal.cli.StandardBundlingOperation.CREATE_WIN_MSI;\n+\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.util.Result;\n+\n+public class WinBundlingEnvironment extends DefaultBundlingEnvironment {\n+\n+    public WinBundlingEnvironment() {\n+        super(build()\n+                .defaultOperation(CREATE_WIN_EXE)\n+                .bundler(CREATE_WIN_APP_IMAGE, WinBundlingEnvironment::createAppImage)\n+                .bundler(CREATE_WIN_EXE, LazyLoad::sysEnv, WinBundlingEnvironment::createExePackage)\n+                .bundler(CREATE_WIN_MSI, LazyLoad::sysEnv, WinBundlingEnvironment::createMsiPackage));\n+    }\n+\n+    private static void createMsiPackage(Options options, WinSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                WinFromOpions::createWinMsiPackage,\n+                buildEnv()::create,\n+                WinPackagingPipeline.build(),\n+                (env, pkg, outputDir) -> {\n+\n+                    traceWixToolset(sysEnv);\n+\n+                    return new WinMsiPackager(env, pkg, outputDir, sysEnv);\n+                });\n+    }\n+\n+    private static void createExePackage(Options options, WinSystemEnvironment sysEnv) {\n+\n+        createNativePackage(options,\n+                WinFromOpions::createWinExePackage,\n+                buildEnv()::create,\n+                WinPackagingPipeline.build(),\n+                (env, pkg, outputDir) -> {\n+\n+                    traceWixToolset(sysEnv);\n+\n+                    final var msiOutputDir = env.buildRoot().resolve(\"msi\");\n+\n+                    var msiPackager = new WinMsiPackager(env, pkg.msiPackage(),\n+                            msiOutputDir, sysEnv);\n+                    var exePackager = new WinExePackager(env, pkg, outputDir, msiOutputDir);\n+\n+                    return msiPackager.andThen(exePackager);\n+                });\n+    }\n+\n+    private static void createAppImage(Options options) {\n+\n+        final var app = createWinApplication(options);\n+\n+        createApplicationImage(options, app, WinPackagingPipeline.build());\n+    }\n+\n+    private static BuildEnvFromOptions buildEnv() {\n+        return new BuildEnvFromOptions().predefinedAppImageLayout(APPLICATION_LAYOUT);\n+    }\n+\n+    private static void traceWixToolset(WinSystemEnvironment sysEnv) {\n+        final var wixToolset = sysEnv.wixToolset();\n+\n+        for (var tool : wixToolset.getType().getTools()) {\n+            Log.verbose(I18N.format(\"message.tool-version\",\n+                    wixToolset.getToolPath(tool).getFileName(),\n+                    wixToolset.getVersion()));\n+        }\n+    }\n+\n+    private static final class LazyLoad {\n+\n+        static Result<WinSystemEnvironment> sysEnv() {\n+            return SYS_ENV;\n+        }\n+\n+        private static final Result<WinSystemEnvironment> SYS_ENV = WinSystemEnvironment.create();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinBundlingEnvironment.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -27,6 +27,0 @@\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-\n@@ -34,1 +28,1 @@\n-public class WinExeBundler extends AbstractBundler {\n+final class WinExeBundler {\n@@ -40,52 +34,0 @@\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"exe.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"exe\";\n-    }\n-\n-    @Override\n-    public String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean platformInstaller) {\n-        return msiBundler.supported(platformInstaller);\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params)\n-            throws ConfigException {\n-        return msiBundler.validate(params, WinFromParams.EXE_PACKAGE);\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params, Path outdir)\n-            throws PackagerException {\n-\n-        \/\/ Order is important!\n-        var pkg = WinFromParams.EXE_PACKAGE.fetchFrom(params);\n-        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-        var msiOutputDir = env.buildRoot().resolve(\"msi\");\n-\n-        return Packager.<WinMsiPackage>build().outputDir(msiOutputDir)\n-                .pkg(pkg.msiPackage())\n-                .env(env)\n-                .pipelineBuilderMutatorFactory((packagingEnv, msiPackage, _) -> {\n-                    var msiPackager = new WinMsiPackager(packagingEnv, msiPackage,\n-                            msiOutputDir, msiBundler.sysEnv.orElseThrow());\n-                    var exePackager = new WinExePackager(packagingEnv, pkg, outdir, msiOutputDir);\n-                    return msiPackager.andThen(exePackager);\n-                }).execute(WinPackagingPipeline.build());\n-    }\n-\n@@ -93,2 +35,0 @@\n-\n-    private final WinMsiBundler msiBundler = new WinMsiBundler();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":61,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -40,5 +39,2 @@\n-    WinExePackage create() throws ConfigException {\n-        if (icon != null) {\n-            LauncherBuilder.validateIcon(icon);\n-        }\n-        return WinExePackage.create(pkg, Optional.ofNullable(icon));\n+    WinExePackage create() {\n+        return WinExePackage.create(pkg, Optional.ofNullable(icon).map(LauncherBuilder::validateIcon));\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExePackageBuilder.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.FromOptions.buildApplicationBuilder;\n+import static jdk.jpackage.internal.FromOptions.createPackageBuilder;\n+import static jdk.jpackage.internal.WinPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n+import static jdk.jpackage.internal.cli.StandardOption.RESOURCE_DIR;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_CONSOLE_HINT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_HELP_URL;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_INSTALLDIR_CHOOSER;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_MENU_GROUP;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_MENU_HINT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_PER_USER_INSTALLATION;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_SHORTCUT_HINT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_SHORTCUT_PROMPT;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_UPDATE_URL;\n+import static jdk.jpackage.internal.cli.StandardOption.WIN_UPGRADE_UUID;\n+import static jdk.jpackage.internal.model.StandardPackageType.WIN_MSI;\n+\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.WinApplication;\n+import jdk.jpackage.internal.model.WinExePackage;\n+import jdk.jpackage.internal.model.WinLauncher;\n+import jdk.jpackage.internal.model.WinLauncherMixin;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+\n+final class WinFromOpions {\n+\n+    static WinApplication createWinApplication(Options options) {\n+\n+        final var launcherFromOptions = new LauncherFromOptions().faWithDefaultDescription();\n+\n+        final var appBuilder = buildApplicationBuilder().create(options, launcherOptions -> {\n+\n+            final var launcher = launcherFromOptions.create(launcherOptions);\n+\n+            final boolean isConsole = WIN_CONSOLE_HINT.getFrom(launcherOptions);\n+\n+            final var startMenuShortcut = WIN_MENU_HINT.findIn(launcherOptions);\n+\n+            final var desktopShortcut = WIN_SHORTCUT_HINT.findIn(launcherOptions);\n+\n+            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, startMenuShortcut, desktopShortcut));\n+\n+        }, (WinLauncher winLauncher, Launcher launcher) -> {\n+            return WinLauncher.create(launcher, winLauncher);\n+        }, APPLICATION_LAYOUT);\n+\n+        appBuilder.launchers().map(WinPackagingPipeline::normalizeShortcuts).ifPresent(appBuilder::launchers);\n+\n+        return WinApplication.create(appBuilder.create());\n+    }\n+\n+    static WinMsiPackage createWinMsiPackage(Options options) {\n+\n+        final var app = createWinApplication(options);\n+\n+        final var superPkgBuilder = createPackageBuilder(options, app, WIN_MSI);\n+\n+        final var pkgBuilder = new WinMsiPackageBuilder(superPkgBuilder);\n+\n+        WIN_HELP_URL.ifPresentIn(options, pkgBuilder::helpURL);\n+        pkgBuilder.isSystemWideInstall(!WIN_PER_USER_INSTALLATION.getFrom(options));\n+        WIN_MENU_GROUP.ifPresentIn(options, pkgBuilder::startMenuGroupName);\n+        WIN_UPDATE_URL.ifPresentIn(options, pkgBuilder::updateURL);\n+        WIN_INSTALLDIR_CHOOSER.ifPresentIn(options, pkgBuilder::withInstallDirChooser);\n+        WIN_SHORTCUT_PROMPT.ifPresentIn(options, pkgBuilder::withShortcutPrompt);\n+\n+        if (app.isService()) {\n+            RESOURCE_DIR.ifPresentIn(options, resourceDir -> {\n+                pkgBuilder.serviceInstaller(resourceDir.resolve(\"service-installer.exe\"));\n+            });\n+        }\n+\n+        WIN_UPGRADE_UUID.ifPresentIn(options, pkgBuilder::upgradeCode);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static WinExePackage createWinExePackage(Options options) {\n+\n+        final var msiPkg = createWinMsiPackage(options);\n+\n+        final var pkgBuilder = new WinExePackageBuilder(msiPkg);\n+\n+        ICON.ifPresentIn(options, pkgBuilder::icon);\n+\n+        return pkgBuilder.create();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromOpions.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.BundlerParamInfo.createBooleanBundlerParam;\n-import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n-import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n-import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n-import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n-import static jdk.jpackage.internal.FromParams.findLauncherShortcut;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import static jdk.jpackage.internal.WinPackagingPipeline.APPLICATION_LAYOUT;\n-import static jdk.jpackage.internal.model.StandardPackageType.WIN_MSI;\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n-\n-import java.io.IOException;\n-import java.util.Map;\n-import java.util.UUID;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.Launcher;\n-import jdk.jpackage.internal.model.WinApplication;\n-import jdk.jpackage.internal.model.WinExePackage;\n-import jdk.jpackage.internal.model.WinLauncher;\n-import jdk.jpackage.internal.model.WinLauncherMixin;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-\n-final class WinFromParams {\n-\n-    private static WinApplication createWinApplication(\n-            Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var launcherFromParams = new LauncherFromParams();\n-\n-        final var app = createApplicationBuilder(params, toFunction(launcherParams -> {\n-\n-            final var launcher = launcherFromParams.create(launcherParams);\n-\n-            final boolean isConsole = CONSOLE_HINT.findIn(launcherParams).orElse(false);\n-\n-            final var startMenuShortcut = findLauncherShortcut(WIN_MENU_HINT, params, launcherParams);\n-\n-            final var desktopShortcut = findLauncherShortcut(WIN_SHORTCUT_HINT, params, launcherParams);\n-\n-            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, startMenuShortcut, desktopShortcut));\n-\n-        }), (WinLauncher winLauncher, Launcher launcher) -> {\n-            return WinLauncher.create(launcher, winLauncher);\n-        }, APPLICATION_LAYOUT).create();\n-\n-        return WinApplication.create(app);\n-    }\n-\n-    private static WinMsiPackage createWinMsiPackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var app = APPLICATION.fetchFrom(params);\n-\n-        final var superPkgBuilder = createPackageBuilder(params, app, WIN_MSI);\n-\n-        final var pkgBuilder = new WinMsiPackageBuilder(superPkgBuilder);\n-\n-        HELP_URL.copyInto(params, pkgBuilder::helpURL);\n-        MSI_SYSTEM_WIDE.copyInto(params, pkgBuilder::isSystemWideInstall);\n-        MENU_GROUP.copyInto(params, pkgBuilder::startMenuGroupName);\n-        UPDATE_URL.copyInto(params, pkgBuilder::updateURL);\n-        INSTALLDIR_CHOOSER.copyInto(params, pkgBuilder::withInstallDirChooser);\n-        SHORTCUT_PROMPT.copyInto(params, pkgBuilder::withShortcutPrompt);\n-\n-        if (app.isService()) {\n-            RESOURCE_DIR.copyInto(params, resourceDir -> {\n-                pkgBuilder.serviceInstaller(resourceDir.resolve(\"service-installer.exe\"));\n-            });\n-        }\n-\n-        try {\n-            UPGRADE_UUID.findIn(params).map(UUID::fromString).ifPresent(pkgBuilder::upgradeCode);\n-        } catch (IllegalArgumentException ex) {\n-            throw new ConfigException(ex);\n-        }\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    private static WinExePackage createWinExePackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n-\n-        final var msiPkg = MSI_PACKAGE.fetchFrom(params);\n-\n-        final var pkgBuilder = new WinExePackageBuilder(msiPkg);\n-\n-        ICON.copyInto(params, pkgBuilder::icon);\n-\n-        return pkgBuilder.create();\n-    }\n-\n-    static final BundlerParamInfo<WinApplication> APPLICATION = createApplicationBundlerParam(\n-            WinFromParams::createWinApplication);\n-\n-    static final BundlerParamInfo<WinMsiPackage> MSI_PACKAGE = createPackageBundlerParam(\n-            WinFromParams::createWinMsiPackage);\n-\n-    static final BundlerParamInfo<WinExePackage> EXE_PACKAGE = createPackageBundlerParam(\n-            WinFromParams::createWinExePackage);\n-\n-    private static final BundlerParamInfo<String> WIN_MENU_HINT = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_MENU_HINT.getId());\n-\n-    private static final BundlerParamInfo<String> WIN_SHORTCUT_HINT = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_SHORTCUT_HINT.getId());\n-\n-    public static final BundlerParamInfo<Boolean> CONSOLE_HINT = createBooleanBundlerParam(\n-            Arguments.CLIOptions.WIN_CONSOLE_HINT.getId());\n-\n-    private static final BundlerParamInfo<Boolean> INSTALLDIR_CHOOSER = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.WIN_DIR_CHOOSER.getId(),\n-            Boolean.class,\n-            null,\n-            (s, p) -> Boolean.valueOf(s)\n-    );\n-\n-    private static final BundlerParamInfo<Boolean> SHORTCUT_PROMPT = new BundlerParamInfo<>(\n-            Arguments.CLIOptions.WIN_SHORTCUT_PROMPT.getId(),\n-            Boolean.class,\n-            null,\n-            (s, p) -> Boolean.valueOf(s)\n-    );\n-\n-    private static final BundlerParamInfo<String> MENU_GROUP = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_MENU_GROUP.getId());\n-\n-    private static final BundlerParamInfo<Boolean> MSI_SYSTEM_WIDE = createBooleanBundlerParam(\n-            Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId());\n-\n-    private static final BundlerParamInfo<String> HELP_URL = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_HELP_URL.getId());\n-\n-    private static final BundlerParamInfo<String> UPDATE_URL = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_UPDATE_URL.getId());\n-\n-    private static final BundlerParamInfo<String> UPGRADE_UUID = createStringBundlerParam(\n-            Arguments.CLIOptions.WIN_UPGRADE_UUID.getId());\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import static jdk.jpackage.internal.model.ConfigException.rethrowConfigException;\n-\n-import java.nio.file.Path;\n-import java.util.Map;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.Package;\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.model.WinMsiPackage;\n-import jdk.jpackage.internal.util.Result;\n-\n-public class WinMsiBundler  extends AbstractBundler {\n-\n-    public WinMsiBundler() {\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return I18N.getString(\"msi.bundler.name\");\n-    }\n-\n-    @Override\n-    public String getID() {\n-        return \"msi\";\n-    }\n-\n-    @Override\n-    public String getBundleType() {\n-        return \"INSTALLER\";\n-    }\n-\n-    @Override\n-    public boolean supported(boolean platformInstaller) {\n-        try {\n-            try {\n-                sysEnv.orElseThrow();\n-                return true;\n-            } catch (RuntimeException ex) {\n-                ConfigException.rethrowConfigException(ex);\n-            }\n-        } catch (ConfigException ce) {\n-            Log.error(ce.getMessage());\n-            if (ce.getAdvice() != null) {\n-                Log.error(ce.getAdvice());\n-            }\n-        } catch (Exception e) {\n-            Log.error(e.getMessage());\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean isDefault() {\n-        return false;\n-    }\n-\n-    @Override\n-    public boolean validate(Map<String, ? super Object> params) throws ConfigException {\n-        return validate(params, WinFromParams.MSI_PACKAGE);\n-    }\n-\n-    boolean validate(Map<String, ? super Object> params, BundlerParamInfo<? extends Package> pkgParam)\n-            throws ConfigException {\n-        try {\n-            \/\/ Order is important!\n-            pkgParam.fetchFrom(params);\n-            BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n-\n-            final var wixToolset = sysEnv.orElseThrow().wixToolset();\n-\n-            for (var tool : wixToolset.getType().getTools()) {\n-                Log.verbose(I18N.format(\"message.tool-version\",\n-                        wixToolset.getToolPath(tool).getFileName(),\n-                        wixToolset.getVersion()));\n-            }\n-\n-            return true;\n-        } catch (RuntimeException re) {\n-            throw rethrowConfigException(re);\n-        }\n-    }\n-\n-    @Override\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-\n-        return Packager.<WinMsiPackage>build().outputDir(outputParentDir)\n-                .pkg(WinFromParams.MSI_PACKAGE.fetchFrom(params))\n-                .env(BuildEnvFromParams.BUILD_ENV.fetchFrom(params))\n-                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n-                    return new WinMsiPackager(env, pkg, outputDir, sysEnv.orElseThrow());\n-                }).execute(WinPackagingPipeline.build());\n-    }\n-\n-    final Result<WinSystemEnvironment> sysEnv = WinSystemEnvironment.create();\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -35,1 +35,0 @@\n-\n@@ -37,1 +36,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -48,1 +46,1 @@\n-    WinMsiPackage create() throws ConfigException {\n+    WinMsiPackage create() {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackageBuilder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -175,1 +174,1 @@\n-    private void prepareConfigFiles() throws PackagerException, IOException {\n+    private void prepareConfigFiles() throws IOException {\n@@ -317,1 +316,1 @@\n-    private void buildPackage() throws PackagerException, IOException {\n+    private void buildPackage() throws IOException {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackager.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static jdk.jpackage.internal.ApplicationBuilder.normalizeLauncherProperty;\n@@ -31,0 +32,4 @@\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n@@ -36,0 +41,1 @@\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n@@ -37,1 +43,1 @@\n-import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n@@ -40,0 +46,1 @@\n+import jdk.jpackage.internal.model.WinLauncherMixin;\n@@ -56,0 +63,27 @@\n+    static ApplicationLaunchers normalizeShortcuts(ApplicationLaunchers appLaunchers) {\n+\n+        appLaunchers = normalizeShortcuts(appLaunchers, WinLauncher::startMenuShortcut, (launcher, shortcut) -> {\n+            return new WinLauncherMixin.Stub(launcher.isConsole(), shortcut, launcher.desktopShortcut());\n+        });\n+\n+        appLaunchers = normalizeShortcuts(appLaunchers, WinLauncher::desktopShortcut, (launcher, shortcut) -> {\n+            return new WinLauncherMixin.Stub(launcher.isConsole(), launcher.startMenuShortcut(), shortcut);\n+        });\n+\n+        return appLaunchers;\n+    }\n+\n+    private static ApplicationLaunchers normalizeShortcuts(\n+            ApplicationLaunchers appLaunchers,\n+            Function<WinLauncher, Optional<LauncherShortcut>> shortcutGetter,\n+            BiFunction<WinLauncherMixin, Optional<LauncherShortcut>, WinLauncherMixin> shortcutOverrider) {\n+        return normalizeLauncherProperty(appLaunchers, launcher -> {\n+            \/\/ Return \"true\" if shortcut is not configured for the launcher.\n+            return shortcutGetter.apply(launcher).isEmpty();\n+        }, (WinLauncher launcher) -> {\n+            return shortcutGetter.apply(launcher).flatMap(LauncherShortcut::startupDirectory);\n+        }, (launcher, shortcut) -> {\n+            return WinLauncher.create(launcher, shortcutOverrider.apply(launcher, Optional.of(new LauncherShortcut(shortcut))));\n+        });\n+    }\n+\n@@ -57,1 +91,1 @@\n-            throws IOException, PackagerException {\n+            throws IOException {\n@@ -82,1 +116,6 @@\n-    static final ApplicationLayout APPLICATION_LAYOUT = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n+    static final ApplicationLayout APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .setAll(\"\")\n+            .appDirectory(\"app\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(Path.of(\"app\", \"mods\"))\n+            .create();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":42,"deletions":3,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n-\n@@ -39,1 +37,1 @@\n-        return Result.create(toSupplier(WixTool::createToolset)).map(WinSystemEnvironment::new);\n+        return Result.create(WixTool::createToolset).map(WinSystemEnvironment::new);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinSystemEnvironment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    static WixToolset createToolset() throws ConfigException {\n+    static WixToolset createToolset() {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_MENU_SHORTCUT;\n+\n@@ -51,1 +54,1 @@\n-            shortcut.store(SHORTCUT_DESKTOP_ID, map::put);\n+            shortcut.store(WIN_LAUNCHER_DESKTOP_SHORTCUT.getName(), map::put);\n@@ -54,1 +57,1 @@\n-            shortcut.store(SHORTCUT_START_MENU_ID, map::put);\n+            shortcut.store(WIN_LAUNCHER_MENU_SHORTCUT.getName(), map::put);\n@@ -62,3 +65,0 @@\n-\n-    public static final String SHORTCUT_START_MENU_ID = \"win-menu\";\n-    public static final String SHORTCUT_DESKTOP_ID = \"win-shortcut\";\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,5 +26,0 @@\n-\n-app.bundler.name=Windows Application Image\n-exe.bundler.name=EXE Installer Package\n-msi.bundler.name=MSI Installer Package\n-\n@@ -34,1 +29,0 @@\n-resource.setup-icon=setup dialog icon\n@@ -68,1 +62,0 @@\n-message.creating-association-with-null-extension=Creating association with null extension.\n@@ -75,1 +68,0 @@\n-message.invalid.install.dir=Warning: Invalid install directory {0}. Install directory should be a relative sub-path under the default installation location such as \"Program Files\". Defaulting to application name \"{1}\".\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/WinResources.properties","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,2 @@\n-provides jdk.jpackage.internal.Bundler with\n-    jdk.jpackage.internal.WinAppBundler,\n-    jdk.jpackage.internal.WinExeBundler,\n-    jdk.jpackage.internal.WinMsiBundler;\n-\n+provides jdk.jpackage.internal.cli.CliBundlingEnvironment with\n+    jdk.jpackage.internal.WinBundlingEnvironment;\n","filename":"src\/jdk.jpackage\/windows\/classes\/module-info.java.extra","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,6 @@\n+        <!--\n+         the code below is being compiled with source 25, see JDK-8372023,\n+         if the source version being compiled changes to 26 or 26+, then\n+         some adjustments will be needed at:\n+         test\/benchmarks\/micros-javac\/src\/main\/java\/org\/openjdk\/bench\/langtools\/javac\/JavacBenchmark.java\n+        -->\n","filename":"test\/benchmarks\/micros-javac\/pom.xml","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-                    if (!ename.startsWith(\"java.desktop\") && !ename.startsWith(\"jdk.internal.vm.compiler\") && !ename.startsWith(\"jdk.aot\") && !ename.startsWith(\"jdk.accessibility\")) {\n+                    if (!ename.startsWith(\"java.desktop\") && !ename.startsWith(\"jdk.internal.vm.compiler\") && !ename.startsWith(\"jdk.aot\") && !ename.startsWith(\"jdk.accessibility\") && !ename.startsWith(\"jdk.jsobject\")) {\n@@ -191,1 +191,1 @@\n-            String[] cmdLine = new String[] {\"-XDcompilePolicy=simple\", \"-implicit:none\", \"-nowarn\", \"--module-source-path\", root.toString(), \"-d\", root.toString(), \"-XDignore.symbol.file=true\", \"@\" + srcList.toString()};\n+            String[] cmdLine = new String[] {\"-source\", \"25\", \"-XDcompilePolicy=simple\", \"-implicit:none\", \"-nowarn\", \"--module-source-path\", root.toString(), \"-d\", root.toString(), \"-XDignore.symbol.file=true\", \"@\" + srcList.toString()};\n","filename":"test\/benchmarks\/micros-javac\/src\/main\/java\/org\/openjdk\/bench\/langtools\/javac\/JavacBenchmark.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-TEST_VM(G1StaticIHOPControl, simple) {\n+TEST_VM(G1IHOPControl, static_simple) {\n@@ -70,1 +70,1 @@\n-\n+  const bool is_adaptive = false;\n@@ -74,1 +74,1 @@\n-  G1StaticIHOPControl ctrl(initial_ihop, &alloc_tracker);\n+  G1IHOPControl ctrl(initial_ihop, &alloc_tracker, is_adaptive, nullptr, 0, 0);\n@@ -102,1 +102,1 @@\n-TEST_VM(G1AdaptiveIHOPControl, simple) {\n+TEST_VM(G1IHOPControl, adaptive_simple) {\n@@ -108,0 +108,1 @@\n+  const bool is_adaptive = true;\n@@ -117,1 +118,1 @@\n-  G1AdaptiveIHOPControl ctrl(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n@@ -180,1 +181,1 @@\n-TEST_VM(G1AdaptiveIHOPControl, humongous) {\n+TEST_VM(G1IHOPControl, adaptive_humongous) {\n@@ -186,0 +187,1 @@\n+  const bool is_adaptive = true;\n@@ -194,1 +196,1 @@\n-  G1AdaptiveIHOPControl ctrl(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n@@ -216,1 +218,1 @@\n-  G1AdaptiveIHOPControl ctrl2(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl2(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n@@ -232,1 +234,1 @@\n-  G1AdaptiveIHOPControl ctrl3(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl3(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -36,1 +37,1 @@\n-                   size_t* to_length_addr) {\n+                   Atomic<size_t>* to_length_addr) {\n@@ -45,1 +46,1 @@\n-                     size_t* to_length_addr) {\n+                     Atomic<size_t>* to_length_addr) {\n@@ -47,1 +48,1 @@\n-  *to_length_addr = init._index;\n+  to_length_addr->store_relaxed(init._index);\n@@ -60,1 +61,1 @@\n-  size_t to_length;\n+  Atomic<size_t> to_length;\n@@ -62,1 +63,1 @@\n-  ASSERT_EQ(length, to_length);\n+  ASSERT_EQ(length, to_length.load_relaxed());\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_partialArrayTaskStepper.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -256,0 +256,2 @@\n+  AsyncLogWriter::flush();\n+  fflush(nullptr);\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t007\/TestDescription.java\t8362350 generic-all\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t007\/TestDescription.java    8362350 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-jvmti-stress-agent.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,0 +271,1 @@\n+vmTestbase\/nsk\/jvmti\/scenarios\/events\/EM02\/em02t006\/TestDescription.java 8372206 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        return Template.make(() -> Template.body(\n+        return Template.make(() -> Template.scope(\n@@ -118,1 +118,1 @@\n-        return Template.make(() -> Template.body(\n+        return Template.make(() -> Template.scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMethodArguments.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,7 @@\n-        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:CompileCommand=inline,jdk.incubator.vector.Float16::*\");\n+        \/\/ Disable inlining for java.lang.Float::float16ToFloat and java.lang.Float::floatToFloat16.\n+        \/\/ Otherwise, they could be inlined into testHalfFloat on platforms where there is no support\n+        \/\/ for fp16, which causes unexpected IR graph.\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\",\n+                                   \"-XX:CompileCommand=inline,jdk.incubator.vector.Float16::*\",\n+                                   \"-XX:CompileCommand=dontinline,java.lang.Float::float16ToFloat\",\n+                                   \"-XX:CompileCommand=dontinline,java.lang.Float::floatToFloat16\");\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestSubNodeFloatDoubleNegation.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -102,1 +102,1 @@\n-        var bodyTemplate = Template.make(\"expression\", \"arguments\", \"checksum\", (Expression expression, List<Object> arguments, String checksum) -> body(\n+        var bodyTemplate = Template.make(\"expression\", \"arguments\", \"checksum\", (Expression expression, List<Object> arguments, String checksum) -> scope(\n@@ -170,1 +170,1 @@\n-            return body(\n+            return scope(\n@@ -177,1 +177,1 @@\n-        var checksumTemplate = Template.make(\"expression\", \"checksum\", (Expression expression, String checksum) -> body(\n+        var checksumTemplate = Template.make(\"expression\", \"checksum\", (Expression expression, String checksum) -> scope(\n@@ -204,1 +204,1 @@\n-        var valueTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> body(\n+        var valueTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> scope(\n@@ -216,1 +216,1 @@\n-        var constrainArgumentMethodTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> body(\n+        var constrainArgumentMethodTemplate = Template.make(\"name\", \"type\", (String name, CodeGenerationDataNameType type) -> scope(\n@@ -250,1 +250,1 @@\n-        var constrainArgumentTemplate = Template.make(\"name\", (String name) -> body(\n+        var constrainArgumentTemplate = Template.make(\"name\", (String name) -> scope(\n@@ -282,1 +282,1 @@\n-            return body(\n+            return scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/ExpressionFuzzer.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3268,1 +3268,3 @@\n-    \/\/ @fully\/qualified\/package\/name\/to\/TheClass+12 *\n+    \/\/ @ptrtype:fully\/qualified\/package\/name\/to\/TheClass:ptrlattice+12\n+    \/\/ with ptrtype being the kind of the type such as instptr, aryptr, etc, and ptrlattice being\n+    \/\/ the kind of the value such as BotPTR, NotNull, etc.\n@@ -3270,2 +3272,2 @@\n-    \/\/ - after @, we can have \"stable:\" or other labels, with optional space after ':'\n-    \/\/ - the class can actually be a subclass, with $ separator (and it must be ok to give only the deepest one\n+    \/\/ - after ptrtype, we can have \"stable:\" or other labels, with optional space after ':'\n+    \/\/ - the class can actually be a nested class, with $ separator (and it must be ok to give only the deepest one\n@@ -3273,1 +3275,0 @@\n-    \/\/ - before the offset, we can have something like \":NotNull\", either way, seeing \"+\" or \":\" means the end of the type\n@@ -3275,3 +3276,12 @@\n-    \/\/ @bla: bli:a\/b\/c$d$e (f\/g,h\/i\/j):NotNull+24 *\n-    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)*[\\\\w\/\\\\$]*\\\\b\";\n-    private static final String LOAD_STORE_SUFFIX = \"( \\\\([^\\\\)]+\\\\))?(:|\\\\+)\\\\S* \\\\*\";\n+    \/\/ @bla: bli:a\/b\/c$d$e (f\/g,h\/i\/j):NotNull+24\n+\n+    \/\/ @ matches the start character of the pattern\n+    \/\/ (\\w+: ?)+ tries to match the pattern 'ptrtype:' or 'stable:' with optional trailing whitespaces\n+    \/\/ (\\w\/)* tries to match the pattern 'a\/b\/`\n+    \/\/ (\\w$)* tries to match the pattern 'c$d$'\n+    \/\/ \\b asserts that the next character is a word character\n+    private static final String LOAD_STORE_PREFIX = \"@(\\\\w+: ?)+(\\\\w\/)*(\\\\w$)*\\\\b\";\n+    \/\/ ( \\([^\\)]+\\))? tries to match the pattern ' (f\/g,h\/i\/j)'\n+    \/\/ :\\w+ tries to match the pattern ':NotNull'\n+    \/\/ .* tries to match the remaining of the pattern\n+    private static final String LOAD_STORE_SUFFIX = \"( \\\\([^\\\\)]+\\\\))?:\\\\w+.*\";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,4 @@\n+\/**\n+ * Represents the addition of the specified {@link Name} to the current scope,\n+ * or an outer scope if the inner scope is transparent to {@link Name}s.\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/AddNameToken.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * The {@link CodeFrame} represents a frame (i.e. scope) of code, appending {@link Code} to the {@code 'codeList'}\n+ * The {@link CodeFrame} represents a frame (i.e. scope) of generated code by appending {@link Code} to the {@link #codeList}\n@@ -34,3 +34,2 @@\n- * {@link Template#addDataName}. {@link Hook}s can be added to a frame, which allows code to be inserted at that\n- * location later. When a {@link Hook} is {@link Hook#anchor}ed, it separates the Template into an outer and inner\n- * {@link CodeFrame}, ensuring that names that are added inside the inner frame are only available inside that frame.\n+ * {@link Template#addDataName}. {@link Hook}s can be added to a code frame, which allows code to be inserted at that\n+ * location later.\n@@ -39,2 +38,1 @@\n- * On the other hand, each {@link TemplateFrame} represents the frame (or scope) of exactly one use of a\n- * Template.\n+ * The {@link CodeFrame} thus implements the {@link Name} non-transparency aspect of {@link ScopeToken}.\n@@ -43,5 +41,81 @@\n- * For simple Template nesting, the {@link CodeFrame}s and {@link TemplateFrame}s overlap exactly.\n- * However, when using {@link Hook#insert}, we simply nest {@link TemplateFrame}s, going further \"in\",\n- * but we jump to an outer {@link CodeFrame}, ensuring that we insert {@link Code} at the outer frame,\n- * and operating on the names of the outer frame. Once the {@link Hook#insert}ion is complete, we jump\n- * back to the caller {@link TemplateFrame} and {@link CodeFrame}.\n+ * The {@link CodeFrame}s are nested relative to the order of the final rendered code. This can\n+ * diverge from the nesting order of the {@link Template} when using {@link Hook#insert}, where\n+ * the execution jumps from the current (caller) {@link CodeFrame} scope to the scope of the\n+ * {@link Hook#anchor}. This ensures that the {@link Name}s of the anchor scope are accessed,\n+ * and not the ones from the caller scope. Once the {@link Hook#insert}ion is complete, we\n+ * jump back to the caller {@link CodeFrame}.\n+ *\n+ * <p>\n+ * Note, that {@link CodeFrame}s and {@link TemplateFrame}s often go together. But they do diverge when\n+ * we call {@link Hook#insert}. On the {@link CodeFrame} side, the inserted scope is nested in the anchoring\n+ * scope, so that the inserted scope has access to the Names of the anchoring scope, and not the caller\n+ * scope. But the {@link TemplateFrame} of the inserted scope is nested in the caller scope, so\n+ * that the inserted scope has access to hashtag replacements of the caller scope, and not the\n+ * anchoring scope.\n+ *\/\n+\n+\/*\n+ * Below, we look at an example, and show the use of CodeFrames (c) and TemplateFrames (t).\n+ *\n+ * Explanations:\n+ *  - Generally, every scope has a CodeFrame and a TemplateFrame. There can be multiple\n+ *    scopes inside a Template, and so there can be multiple CodeFrames and TemplateFrames.\n+ *    In the drawing below, we draw the frames vertically, and give each a unique id.\n+ *  - When we nest scopes inside scopes, we create a new CodeFrame and a new TemplateFrame,\n+ *    and so they grow the same nested structure. Example: t3 is nested inside t2 and\n+ *    c3 is nested inside c2b.\n+ *  - The exception to this:\n+ *    - At a hook.anchor, there are two CodeFrames. The first one (e.g. c2a) we call the\n+ *      hook CodeFrame, it is kept empty until we insert code to the hook. The second\n+ *      (e.g. c2b) we call the inner CodeFrame of the anchoring, into which we keep\n+ *      generating the code that is inside the scope of the hook.anchor.\n+ *    - At a hook.insert, the TemplateFrame (e.g. t4) is nested into the caller (e.g. t3),\n+ *      while the CodeFrame (e.g. c4) is nested into the anchoring CodeFrame (e.g. c2a).\n+ *\n+ * Template(\n+ *   t1 c1\n+ *   t1 c1\n+ *   t1 c1  Anchoring Scope\n+ *   t1 c1  hook.anchor(scope(\n+ *   t1 c1  t2 c2a\n+ *   t1 c1  t2 c2a <------ CodeFrame nesting--------+\n+ *   t1 c1  t2 c2a         with generated code      |\n+ *   t1 c1  t2             and Names                |\n+ *   t1 c1  t2  ^                                   |\n+ *   t1 c1  t2  +- Two CodeFramees                  |\n+ *   t1 c1  t2  v                                   |\n+ *   t1 c1  t2                                      |\n+ *   t1 c1  t2 c2b                                  |\n+ *   t1 c1  t2 c2b                                  |\n+ *   t1 c1  t2 c2b     Caller Scope                 |\n+ *   t1 c1  t2 c2b ... scope(                       |\n+ *   t1 c1  t2 c2b ... t3 c3                        |     Insertion Scope\n+ *   t1 c1  t2 c2b ... t3 c3                        |     hook.insert(transparentScope(\n+ *   t1 c1  t2 c2b ... t3 c3                        |     t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                        +---- t4 ----c4\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3 <-- TemplateFrame nesting ---t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3     with hashtag             t4     c4                            \/\/ t: Concerns Template Frame\n+ *   t1 c1  t2 c2b ... t3 c3     and setFuelCost          t4     c4                            \/\/ c: Concerns Code Frame\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 \"use hashtag #x\"           -> t: hashtag queried in Insertion (t4) and Caller Scope (t3)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                               c: code added to Anchoring Scope (c2a)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 let(\"x\", 42)               -> t: hashtag definition escapes to Caller Scope (t3) because\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                                  Insertion Scope is transparent\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 dataNames(...)...sample()  -> c: sample from Insertion (c4) and Anchoring Scope (c2a)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                                  (CodeFrame nesting: c2a -> c4)\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4 addDataName(...)           -> c: names escape to the Caller Scope (c3) because\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4                                  Insertion Scope is transparent\n+ *   t1 c1  t2 c2b ... t3 c3                              t4     c4\n+ *   t1 c1  t2 c2b ... t3 c3                              ))\n+ *   t1 c1  t2 c2b ... t3 c3\n+ *   t1 c1  t2 c2b ... t3 c3\n+ *   t1 c1  t2 c2b ... )\n+ *   t1 c1  t2 c2b\n+ *   t1 c1  t2 c2b\n+ *   t1 c1  ))\n+ *   t1 c1\n+ *   t1 c1\n+ * )\n+ *\n@@ -81,16 +155,7 @@\n-     * Creates a normal frame, which has a {@link #parent} and which defines an inner\n-     * {@link NameSet}, for the names that are generated inside this frame. Once this\n-     * frame is exited, the name from inside this frame are not available anymore.\n-     *\/\n-    public static CodeFrame make(CodeFrame parent) {\n-        return new CodeFrame(parent, false);\n-    }\n-\n-    \/**\n-     * Creates a special frame, which has a {@link #parent} but uses the {@link NameSet}\n-     * from the parent frame, allowing {@link Template#addDataName}\/\n-     * {@link Template#addStructuralName} to persist in the outer frame when the current frame\n-     * is exited. This is necessary for {@link Hook#insert},  where we would possibly want to\n-     * make field or variable definitions during the insertion that are not just local to the\n-     * insertion but affect the {@link CodeFrame} that we {@link Hook#anchor} earlier and are\n-     * now {@link Hook#insert}ing into.\n+     * Creates a normal frame, which has a {@link #parent}. It can either be\n+     * transparent for names, meaning that names are added and accessed to and\n+     * from an outer frame. Names that are added in a transparent frame are\n+     * still available in the outer frames, as far out as the next non-transparent\n+     * frame. If a frame is non-transparent, this frame defines an inner\n+     * {@link NameSet}, for the names that are generated inside this frame. Once\n+     * this frame is exited, the names from inside this frame are not available.\n@@ -98,2 +163,2 @@\n-    public static CodeFrame makeTransparentForNames(CodeFrame parent) {\n-        return new CodeFrame(parent, true);\n+    public static CodeFrame make(CodeFrame parent, boolean isTransparentForNames) {\n+        return new CodeFrame(parent, isTransparentForNames);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/CodeFrame.java","additions":94,"deletions":29,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.function.Function;\n@@ -117,0 +118,10 @@\n+        \/\/ Wrap the FilteredSet as a Predicate.\n+        private record DataNamePredicate(FilteredSet fs) implements NameSet.Predicate {\n+            public boolean check(Name type) {\n+                return fs.check(type);\n+            }\n+            public String toString() {\n+                return fs.toString();\n+            }\n+        }\n+\n@@ -121,8 +132,16 @@\n-            return (Name name) -> {\n-                if (!(name instanceof DataName dataName)) { return false; }\n-                if (mutability == Mutability.MUTABLE && !dataName.mutable()) { return false; }\n-                if (mutability == Mutability.IMMUTABLE && dataName.mutable()) { return false; }\n-                if (subtype != null && !dataName.type().isSubtypeOf(subtype)) { return false; }\n-                if (supertype != null && !supertype.isSubtypeOf(dataName.type())) { return false; }\n-                return true;\n-            };\n+            return new DataNamePredicate(this);\n+        }\n+\n+        boolean check(Name name) {\n+            if (!(name instanceof DataName dataName)) { return false; }\n+            if (mutability == Mutability.MUTABLE && !dataName.mutable()) { return false; }\n+            if (mutability == Mutability.IMMUTABLE && dataName.mutable()) { return false; }\n+            if (subtype != null && !dataName.type().isSubtypeOf(subtype)) { return false; }\n+            if (supertype != null && !supertype.isSubtypeOf(dataName.type())) { return false; }\n+            return true;\n+        }\n+\n+        public String toString() {\n+            String msg1 = (subtype == null) ? \"\" : \", subtypeOf(\" + subtype + \")\";\n+            String msg2 = (supertype == null) ? \"\" : \", supertypeOf(\" + supertype + \")\";\n+            return \"DataName.FilterdSet(\" + mutability + msg1 + msg2 + \")\";\n@@ -176,1 +195,2 @@\n-         * of the contained {@link DataName}s.\n+         * of the contained {@link DataName}s, making the sampled {@link DataName}\n+         * available to an inner scope.\n@@ -178,1 +198,3 @@\n-         * @return The sampled {@link DataName}.\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the sampled {@link DataName}.\n+         * @return a token that represents the sampling and inner scope.\n@@ -181,10 +203,3 @@\n-         * @throws RendererException If the set was empty.\n-         *\/\n-        public DataName sample() {\n-            DataName n = (DataName)Renderer.getCurrent().sampleName(predicate());\n-            if (n == null) {\n-                String msg1 = (subtype == null) ? \"\" : \", subtypeOf(\" + subtype + \")\";\n-                String msg2 = (supertype == null) ? \"\" : \", supertypeOf(\" + supertype + \")\";\n-                throw new RendererException(\"No variable: \" + mutability + msg1 + msg2 + \".\");\n-            }\n-            return n;\n+         *\/\n+        public Token sample(Function<DataName, ScopeToken> function) {\n+            return new NameSampleToken<>(predicate(), null, null, function);\n@@ -194,1 +209,6 @@\n-         * Counts the number of {@link DataName}s in the filtered set.\n+         * Samples a random {@link DataName} from the filtered set, according to the weights\n+         * of the contained {@link DataName}s, and makes a hashtag replacement for both\n+         * the name and type of the {@link DataName}, in the current scope.\n+         *\n+         * <p>\n+         * Note, that the following two do the equivalent:\n@@ -196,1 +216,27 @@\n-         * @return The number of {@link DataName}s in the filtered set.\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name\", \"type\"),\n+         *     \"\"\"\n+         *     #name #type\n+         *     \"\"\"\n+         * ));\n+         * }\n+         *\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sample((DataName dn) -> transparentScope(\n+         *         \/\/ The \"let\" hashtag definitions escape the \"transparentScope\".\n+         *         let(\"name\", dn.name()),\n+         *         let(\"type\", dn.type())\n+         *     )),\n+         *     \"\"\"\n+         *     #name #type\n+         *     \"\"\"\n+         * ));\n+         * }\n+         *\n+         * @param name the key of the hashtag replacement for the {@link DataName} name.\n+         * @param type the key of the hashtag replacement for the {@link DataName} type.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n@@ -200,2 +246,2 @@\n-        public int count() {\n-            return Renderer.getCurrent().countNames(predicate());\n+        public Token sampleAndLetAs(String name, String type) {\n+            return new NameSampleToken<DataName>(predicate(), name, type, n -> Template.transparentScope());\n@@ -205,1 +251,29 @@\n-         * Checks if there are any {@link DataName}s in the filtered set.\n+         * Samples a random {@link DataName} from the filtered set, according to the weights\n+         * of the contained {@link DataName}s, and makes a hashtag replacement for the\n+         * name of the {@link DataName}, in the current scope.\n+         *\n+         * <p>\n+         * Note, that the following two do the equivalent:\n+         *\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name\"),\n+         *     \"\"\"\n+         *     #name\n+         *     \"\"\"\n+         * ));\n+         * }\n+         *\n+         * <p>\n+         * {@snippet lang=java :\n+         * var template = Template.make(() -> scope(\n+         *     dataNames(MUTABLE).subtypeOf(type).sample((DataName dn) -> transparentScope(\n+         *         \/\/ The \"let\" hashtag definition escape the \"transparentScope\".\n+         *         let(\"name\", dn.name())\n+         *     )),\n+         *     \"\"\"\n+         *     #name\n+         *     \"\"\"\n+         * ));\n+         * }\n@@ -207,1 +281,2 @@\n-         * @return Returns {@code true} iff there is at least one {@link DataName} in the filtered set.\n+         * @param name the key of the hashtag replacement for the {@link DataName} name.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n@@ -211,2 +286,2 @@\n-        public boolean hasAny() {\n-            return Renderer.getCurrent().hasAnyNames(predicate());\n+        public Token sampleAndLetAs(String name) {\n+            return new NameSampleToken<DataName>(predicate(), name, null, n -> Template.transparentScope());\n@@ -216,1 +291,2 @@\n-         * Collects all {@link DataName}s in the filtered set.\n+         * Counts the number of {@link DataName}s in the filtered set, making the count\n+         * available to an inner scope.\n@@ -218,0 +294,30 @@\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the count.\n+         * @return a token that represents the counting and inner scope.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token count(Function<Integer, ScopeToken> function) {\n+            return new NameCountToken(predicate(), function);\n+        }\n+\n+        \/**\n+         * Checks if there are any {@link DataName}s in the filtered set, making the resulting boolean\n+         * available to an inner scope.\n+         *\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the boolean indicating iff there are any {@link DataName}s in the filtered set.\n+         * @return a token that represents the checking and inner scope.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token hasAny(Function<Boolean, ScopeToken> function) {\n+            return new NameHasAnyToken(predicate(), function);\n+        }\n+\n+        \/**\n+         * Collects all {@link DataName}s in the filtered set, making the collected list\n+         * available to an inner scope.\n+         *\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the list of {@link DataName}.\n@@ -222,3 +328,40 @@\n-        public List<DataName> toList() {\n-            List<Name> list = Renderer.getCurrent().listNames(predicate());\n-            return list.stream().map(n -> (DataName)n).toList();\n+        public Token toList(Function<List<DataName>, ScopeToken> function) {\n+            return new NamesToListToken<>(predicate(), function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link DataName}s in the filtered set,\n+         * making each of these {@link DataName}s available to a separate inner scope.\n+         *\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link DataName}s in the filtered set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(Function<DataName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), null, null, function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link DataName}s in the filtered set,\n+         * making each of these {@link DataName}s available to a separate inner scope, and additionally\n+         * setting hashtag replacements for the {@code name} and {@code type} of the respective\n+         * {@link DataName}s.\n+         *\n+         * <p>\n+         * Note, to avoid duplication of the {@code name} and {@code type}\n+         * hashtag replacements, the scope created by the provided {@code function} should be\n+         * non-transparent to hashtag replacements, for example {@link Template#scope} or\n+         * {@link Template#hashtagScope}.\n+         *\n+         * @param name the key of the hashtag replacement for each individual {@link DataName} name.\n+         * @param type the key of the hashtag replacement for each individual {@link DataName} type.\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link DataName}s in the filtereds set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(String name, String type, Function<DataName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), name, type, function);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/DataName.java","additions":175,"deletions":32,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.util.function.Function;\n+\n@@ -27,5 +29,10 @@\n- * {@link Hook}s can be {@link #anchor}ed for a certain scope in a Template, and all nested\n- * Templates in this scope, and then from within this scope, any Template can\n- * {@link #insert} code to where the {@link Hook} was {@link #anchor}ed. This can be useful to reach\n- * \"back\" or to some outer scope, e.g. while generating code for a method, one can reach out\n- * to the class scope to insert fields.\n+ * A {@link Hook} can be {@link #anchor}ed for a certain scope ({@link ScopeToken}), and that\n+ * anchoring stays active for any nested scope or nested {@link Template}. With {@link #insert},\n+ * one can insert a template ({@link TemplateToken}) or scope ({@link ScopeToken}) to where the\n+ * {@link Hook} was {@link #anchor}'ed. If the hook was anchored for multiple outer scopes, the\n+ * innermost is chosen for insertion.\n+ *\n+ * <p>\n+ * This can be useful to reach \"back\" or to some outer scope, e.g. while generating code for a\n+ * method, one can reach out to the class scope to insert fields. Or one may want to reach back\n+ * to the beginning of a method to insert local variables that should be live for the whole method.\n@@ -34,0 +41,6 @@\n+ * The choice of {@link ScopeToken} is very important and powerful.\n+ * For example, if you want to insert a {@link DataName} to the scope of an anchor,\n+ * it is important that the scope of the insertion is transparent for {@link DataName}s,\n+ * e.g. using {@link Template#transparentScope}. In most cases, we want {@link DataName}s to escape\n+ * the inserted scope but not the anchor scope, so the anchor scope should be\n+ * non-transparent for {@link DataName}s, e.g. using {@link Template#scope}.\n@@ -35,0 +48,2 @@\n+ *\n+ * <p>\n@@ -38,7 +53,1 @@\n- * var template1 = Template.make(\"name\", (String name) -> body(\n- *     \"\"\"\n- *     public static int #name = 42;\n- *     \"\"\"\n- * ));\n- *\n- * var template2 = Template.make(() -> body(\n+ * var template = Template.make(() -> scope(\n@@ -49,1 +58,1 @@\n- *     myHook.anchor(\n+ *     myHook.anchor(scope(\n@@ -54,2 +63,8 @@\n- *         \/\/ Reach out to where the hook was anchored, and insert the code of template1.\n- *         myHook.insert(template1.asToken($(\"field\"))),\n+ *         \/\/ Reach out to where the hook was anchored, and insert some code.\n+ *         myHook.insert(transparentScope(\n+ *             \/\/ The field (DataName) escapes because the inserted scope is \"transparentScope\"\n+ *             addDataName($(\"field\"), Primitives.INTS, MUTABLE),\n+ *             \"\"\"\n+ *             public static int $field = 42;\n+ *             \"\"\"\n+ *         )),\n@@ -59,1 +74,1 @@\n- *     ),\n+ *     )),\n@@ -66,0 +81,10 @@\n+ * <p>\n+ * Note that if we use {@link #insert} with {@link Template#transparentScope}, then\n+ * {@link DataName}s  and {@link StructuralName}s escape from the inserted scope to the\n+ * anchor scope, but hashtag replacements and {@link Template#setFuelCost} escape to\n+ * the caller, i.e. from where we inserted the scope. This makes sense if we consider\n+ * {@link DataName}s belonging to the structure of the generated code and the inserted\n+ * scope belonging to the anchor scope. On the other hand, hashtag replacements and\n+ * {@link Template#setFuelCost} rather belong to the code generation that happens\n+ * within the context of a template.\n+ *\n@@ -70,1 +95,1 @@\n-     * Anchor this {@link Hook} for the scope of the provided {@code 'tokens'}.\n+     * Anchor this {@link Hook} for the provided inner scope.\n@@ -74,2 +99,2 @@\n-     * @param tokens A list of tokens, which have the same restrictions as {@link Template#body}.\n-     * @return A {@link Token} that captures the anchoring of the scope and the list of validated {@link Token}s.\n+     * @param innerScope An inner scope, for which the {@link Hook} is anchored.\n+     * @return A {@link Token} that captures the anchoring and the inner scope.\n@@ -77,2 +102,2 @@\n-    public Token anchor(Object... tokens) {\n-        return new HookAnchorToken(this, TokenParser.parse(tokens));\n+    public Token anchor(ScopeToken innerScope) {\n+        return new HookAnchorToken(this, innerScope);\n@@ -86,1 +111,1 @@\n-     * @return The {@link Token} which when used inside a {@link Template#body} performs the code insertion into the {@link Hook}.\n+     * @return The {@link Token} which represents the code insertion into the {@link Hook}.\n@@ -89,1 +114,12 @@\n-        return new HookInsertToken(this, templateToken);\n+        return new HookInsertToken(this, Template.transparentScope(templateToken));\n+    }\n+\n+    \/**\n+     * Inserts a scope ({@link ScopeToken}) to the innermost location where this {@link Hook} was {@link #anchor}ed.\n+     * This could be in the same Template, or one nested further out.\n+     *\n+     * @param scopeToken The scope to be inserted at the {@link Hook}.\n+     * @return The {@link Token} which represents the code insertion into the {@link Hook}.\n+     *\/\n+    public Token insert(ScopeToken scopeToken) {\n+        return new HookInsertToken(this, scopeToken);\n@@ -93,1 +129,2 @@\n-     * Checks if the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope.\n+     * Checks if the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope,\n+     * and makes the boolean result available to an inner scope.\n@@ -95,1 +132,2 @@\n-     * @return If the {@link Hook} was {@link Hook#anchor}ed for the current scope or an outer scope.\n+     * @param function the function that generates the inner scope given the boolean result.\n+     * @return the token that represents the check and inner scope.\n@@ -97,2 +135,2 @@\n-    public boolean isAnchored() {\n-        return Renderer.getCurrent().isAnchored(this);\n+    public Token isAnchored(Function<Boolean, ScopeToken> function) {\n+        return new HookIsAnchoredToken(this, function);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Hook.java","additions":65,"deletions":27,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-record HookAnchorToken(Hook hook, List<Token> tokens) implements Token {}\n+\/**\n+ * Represents the {@link Hook#anchor} with its inner scope.\n+ *\/\n+record HookAnchorToken(Hook hook, ScopeToken innerScope) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookAnchorToken.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,5 @@\n-record HookInsertToken(Hook hook, TemplateToken templateToken) implements Token {}\n+\/**\n+ * Represents the {@link Hook#insert} with the {@link ScopeToken} of the\n+ * scope that is to be inserted.\n+ *\/\n+record HookInsertToken(Hook hook, ScopeToken scopeToken) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookInsertToken.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents an {@link Hook#isAnchored} query with the function that creates an inner scope\n+ * given the boolean answer.\n+ *\/\n+record HookIsAnchoredToken(Hook hook, Function<Boolean, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(boolean isAnchored) {\n+        return function().apply(isAnchored);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/HookIsAnchoredToken.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents a let (aka hashtag) definition. The hashtag replacement is active for the\n+ * scope ({@link ScopeToken}) that the {@code function} creates, but can escape that\n+ * scope if it is transparent to hashtags.\n+ *\/\n+record LetToken<T>(String key, T value, Function<T, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken() {\n+        return function().apply(value);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/LetToken.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the counting of {@link Name}s, and the function that is called\n+ * to create an inner scope given the count.\n+ *\/\n+record NameCountToken(\n+        NameSet.Predicate predicate,\n+        Function<Integer, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(int count) {\n+        return function().apply(count);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameCountToken.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the for-each execution of the provided function and (optional) hashtag replacement\n+ * keys for name and type of each name.\n+ *\/\n+record NameForEachToken<N>(\n+        NameSet.Predicate predicate,\n+        String name,\n+        String type,\n+        Function<N, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(Name n) {\n+        return function().apply((N)n);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameForEachToken.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the check if there is any name and the function that is to\n+ * be called given the boolean value (true iff there are any names).\n+ *\/\n+record NameHasAnyToken(\n+        NameSet.Predicate predicate,\n+        Function<Boolean, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(boolean hasAny) {\n+        return function().apply(hasAny);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameHasAnyToken.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+\n+\/**\n+ * Represents the sampling of {@link Name}s, and the function that is called given\n+ * the sampled name, as well as the (optional) hashtag replacement keys for the\n+ * name and type of the sampled name, which are then available in the inner scope\n+ * created by the provided function.\n+ *\/\n+record NameSampleToken<N>(\n+        NameSet.Predicate predicate,\n+        String name,\n+        String type,\n+        Function<N, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(Name n) {\n+        return function().apply((N)n);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSampleToken.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+        String toString(); \/\/ used when sampling fails.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NameSet.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.function.Function;\n+import java.util.List;\n+\n+\/**\n+ * Represents the {@code toList} on a filtered name set, including the collection of the\n+ * names and the creation of the inner scope with the function.\n+ *\/\n+record NamesToListToken<N>(\n+        NameSet.Predicate predicate,\n+        Function<List<N>, ScopeToken> function) implements Token {\n+\n+    ScopeToken getScopeToken(List<Name> names) {\n+        List<N> castNames = names.stream().map(n -> (N)n).toList();\n+        return function().apply(castNames);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NamesToListToken.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -79,1 +79,1 @@\n-     * {@link Template#body}. This would be a bad pattern: the outer and nested {@link Template} would\n+     * {@link Template#scope}. This would be a bad pattern: the outer and nested {@link Template} would\n@@ -87,2 +87,2 @@\n-     * Instead, the user should create a {@link TemplateToken} from the inner {@link Template}, and\n-     * use that {@link TemplateToken} in the {@link Template#body} of the outer {@link Template}.\n+     * Instead, the user must create a {@link TemplateToken} from the inner {@link Template}, and\n+     * use that {@link TemplateToken} in the {@link Template#scope} of the outer {@link Template}.\n@@ -116,1 +116,1 @@\n-            throw new RendererException(\"A Template method such as '$', 'let', 'sample', 'count' etc. was called outside a template rendering.\");\n+            throw new RendererException(\"A Template method such as '$', 'fuel', etc. was called outside a template rendering call.\");\n@@ -174,20 +174,0 @@\n-    void setFuelCost(float fuelCost) {\n-        currentTemplateFrame.setFuelCost(fuelCost);\n-    }\n-\n-    Name sampleName(NameSet.Predicate predicate) {\n-        return currentCodeFrame.sampleName(predicate);\n-    }\n-\n-    int countNames(NameSet.Predicate predicate) {\n-        return currentCodeFrame.countNames(predicate);\n-    }\n-\n-    boolean hasAnyNames(NameSet.Predicate predicate) {\n-        return currentCodeFrame.hasAnyNames(predicate);\n-    }\n-\n-    List<Name> listNames(NameSet.Predicate predicate) {\n-        return currentCodeFrame.listNames(predicate);\n-    }\n-\n@@ -246,0 +226,3 @@\n+        \/\/ We need a TemplateFrame in all cases, this ensures that the outermost scope of the template\n+        \/\/ is not transparent for hashtags and setFuelCost, and also that the id of the template is\n+        \/\/ unique.\n@@ -250,2 +233,3 @@\n-        TemplateBody body = templateToken.instantiate();\n-        renderTokenList(body.tokens());\n+\n+        \/\/ If the ScopeToken is transparent to Names, then the Template is transparent to names.\n+        renderScopeToken(templateToken.instantiate());\n@@ -259,0 +243,51 @@\n+    private void renderScopeToken(ScopeToken st) {\n+        renderScopeToken(st, () -> {});\n+    }\n+\n+    private void renderScopeToken(ScopeToken st, Runnable preamble) {\n+        if (!(st instanceof ScopeTokenImpl(List<Token> tokens,\n+                                           boolean isTransparentForNames,\n+                                           boolean isTransparentForHashtags,\n+                                           boolean isTransparentForSetFuelCost))) {\n+            throw new RuntimeException(\"Internal error: could not unpack ScopeTokenImpl.\");\n+        }\n+\n+        \/\/ We need the CodeFrame for local names.\n+        CodeFrame outerCodeFrame = currentCodeFrame;\n+        if (!isTransparentForNames) {\n+            currentCodeFrame = CodeFrame.make(currentCodeFrame, false);\n+        }\n+\n+        \/\/ We need to be able to define local hashtag replacements, but still\n+        \/\/ see the outer ones. We also need to have the same id for dollar\n+        \/\/ replacement as the outer frame. And we need to be able to allow\n+        \/\/ local setFuelCost definitions.\n+        TemplateFrame innerTemplateFrame = null;\n+        if (!isTransparentForHashtags || !isTransparentForSetFuelCost) {\n+            innerTemplateFrame = TemplateFrame.makeInnerScope(currentTemplateFrame,\n+                                                              isTransparentForHashtags,\n+                                                              isTransparentForSetFuelCost);\n+            currentTemplateFrame = innerTemplateFrame;\n+        }\n+\n+        \/\/ Allow definition of hashtags and variables to be placed in the nested frames.\n+        preamble.run();\n+\n+        \/\/ Now render the nested code.\n+        renderTokenList(tokens);\n+\n+        if (!isTransparentForHashtags || !isTransparentForSetFuelCost) {\n+            if (currentTemplateFrame != innerTemplateFrame) {\n+                throw new RuntimeException(\"Internal error: TemplateFrame mismatch!\");\n+            }\n+            currentTemplateFrame = currentTemplateFrame.parent;\n+        }\n+\n+        \/\/ Tear down CodeFrame nesting. If no nesting happened, the code is already\n+        \/\/ in the currentCodeFrame.\n+        if (!isTransparentForNames) {\n+            outerCodeFrame.addCode(currentCodeFrame.getCode());\n+            currentCodeFrame = outerCodeFrame;\n+        }\n+    }\n+\n@@ -264,4 +299,1 @@\n-            case NothingToken() -> {\n-                \/\/ Nothing.\n-            }\n-            case HookAnchorToken(Hook hook, List<Token> tokens) -> {\n+            case HookAnchorToken(Hook hook, ScopeTokenImpl innerScope) -> {\n@@ -270,3 +302,3 @@\n-                \/\/ We need a CodeFrame to which the hook can insert code. That way, name\n-                \/\/ definitions at the hook cannot escape the hookCodeFrame.\n-                CodeFrame hookCodeFrame = CodeFrame.make(outerCodeFrame);\n+                \/\/ We need a CodeFrame to which the hook can insert code. If the nested names\n+                \/\/ are to be local, the CodeFrame must be non-transparent for names.\n+                CodeFrame hookCodeFrame = CodeFrame.make(outerCodeFrame, innerScope.isTransparentForNames());\n@@ -275,4 +307,3 @@\n-                \/\/ We need a CodeFrame where the tokens can be rendered. That way, name\n-                \/\/ definitions from the tokens cannot escape the innerCodeFrame to the\n-                \/\/ hookCodeFrame.\n-                CodeFrame innerCodeFrame = CodeFrame.make(hookCodeFrame);\n+                \/\/ We need a CodeFrame where the tokens can be rendered for code that is\n+                \/\/ generated inside the anchor scope, but not inserted directly to the hook.\n+                CodeFrame innerCodeFrame = CodeFrame.make(hookCodeFrame, innerScope.isTransparentForNames());\n@@ -281,1 +312,1 @@\n-                renderTokenList(tokens);\n+                renderScopeToken(innerScope);\n@@ -289,1 +320,1 @@\n-            case HookInsertToken(Hook hook, TemplateToken templateToken) -> {\n+            case HookInsertToken(Hook hook, ScopeTokenImpl scopeToken) -> {\n@@ -295,2 +326,2 @@\n-                \/\/ by the TemplateToken can be collected, and hook insertions from it can still\n-                \/\/ be made to the hookCodeFrame before the code from the TemplateToken is added to\n+                \/\/ by the scopeToken can be collected, and hook insertions from it can still\n+                \/\/ be made to the hookCodeFrame before the code from the scopeToken is added to\n@@ -299,2 +330,2 @@\n-                \/\/ the hookCodeFrame, and are not limited to the CodeFrame for the TemplateToken.\n-                currentCodeFrame = CodeFrame.makeTransparentForNames(hookCodeFrame);\n+                \/\/ the hookCodeFrame, and are not limited to the CodeFrame for the scopeToken.\n+                currentCodeFrame = CodeFrame.make(hookCodeFrame, true);\n@@ -302,1 +333,1 @@\n-                renderTemplateToken(templateToken);\n+                renderScopeToken(scopeToken);\n@@ -310,4 +341,0 @@\n-                \/\/ Use a nested CodeFrame.\n-                CodeFrame callerCodeFrame = currentCodeFrame;\n-                currentCodeFrame = CodeFrame.make(currentCodeFrame);\n-\n@@ -315,3 +342,0 @@\n-\n-                callerCodeFrame.addCode(currentCodeFrame.getCode());\n-                currentCodeFrame = callerCodeFrame;\n@@ -322,0 +346,57 @@\n+            case ScopeToken scopeToken -> {\n+                renderScopeToken(scopeToken);\n+            }\n+            case NameSampleToken nameScopeToken -> {\n+                Name name = currentCodeFrame.sampleName(nameScopeToken.predicate());\n+                if (name == null) {\n+                    throw new RendererException(\"No Name found for \" + nameScopeToken.predicate().toString());\n+                }\n+                ScopeToken scopeToken = nameScopeToken.getScopeToken(name);\n+                renderScopeToken(scopeToken, () -> {\n+                    if (nameScopeToken.name() != null) {\n+                        addHashtagReplacement(nameScopeToken.name(), name.name());\n+                    }\n+                    if (nameScopeToken.type() != null) {\n+                        addHashtagReplacement(nameScopeToken.type(), name.type());\n+                    }\n+                });\n+            }\n+            case NameForEachToken nameForEachToken -> {\n+                List<Name> list = currentCodeFrame.listNames(nameForEachToken.predicate());\n+                list.stream().forEach(name -> {\n+                    ScopeToken scopeToken = nameForEachToken.getScopeToken(name);\n+                    renderScopeToken(scopeToken, () -> {\n+                        if (nameForEachToken.name() != null) {\n+                            addHashtagReplacement(nameForEachToken.name(), name.name());\n+                        }\n+                        if (nameForEachToken.type() != null) {\n+                            addHashtagReplacement(nameForEachToken.type(), name.type());\n+                        }\n+                    });\n+                });\n+            }\n+            case NamesToListToken nameToListToken -> {\n+                List<Name> list = currentCodeFrame.listNames(nameToListToken.predicate());\n+                renderScopeToken(nameToListToken.getScopeToken(list));\n+            }\n+            case NameCountToken nameCountToken -> {\n+                int count = currentCodeFrame.countNames(nameCountToken.predicate());\n+                renderScopeToken(nameCountToken.getScopeToken(count));\n+            }\n+            case NameHasAnyToken nameHasAnyToken -> {\n+                boolean hasAny = currentCodeFrame.hasAnyNames(nameHasAnyToken.predicate());\n+                renderScopeToken(nameHasAnyToken.getScopeToken(hasAny));\n+            }\n+            case SetFuelCostToken(float fuelCost) -> {\n+                currentTemplateFrame.setFuelCost(fuelCost);\n+            }\n+            case LetToken letToken -> {\n+                ScopeToken scopeToken = letToken.getScopeToken();\n+                renderScopeToken(scopeToken, () -> {\n+                    addHashtagReplacement(letToken.key(), letToken.value());\n+                });\n+            }\n+            case HookIsAnchoredToken hookIsAnchoredToken -> {\n+                boolean isAnchored = currentCodeFrame.codeFrameForHook(hookIsAnchoredToken.hook()) != null;\n+                renderScopeToken(hookIsAnchoredToken.getScopeToken(isAnchored));\n+            }\n@@ -426,4 +507,0 @@\n-    boolean isAnchored(Hook hook) {\n-        return currentCodeFrame.codeFrameForHook(hook) != null;\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Renderer.java","additions":132,"deletions":55,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * A {@link ScopeToken} represents a scope in a {@link Template}, which can be\n+ * created with {@link Template#scope}, {@link Template#transparentScope}, and other related methods.\n+ *\/\n+public sealed interface ScopeToken extends Token permits ScopeTokenImpl {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/ScopeToken.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+import java.util.List;\n+\n+\/**\n+ * Represents a scope with its tokens. Boolean flags indicate if names,\n+ * hashtag replacements and {@link Template#setFuelCost} are local, or escape to\n+ * outer scopes.\n+ *\n+ * <p>\n+ * Note: We want the {@link ScopeToken} to be public, but the internals of the\n+ *       record should be private. One way to solve this is with a public interface\n+ *       that exposes nothing but its name, and a private implementation via a\n+ *       record that allows easy destructuring with pattern matching.\n+ *\/\n+record ScopeTokenImpl(List<Token> tokens,\n+                      boolean isTransparentForNames,\n+                      boolean isTransparentForHashtags,\n+                      boolean isTransparentForSetFuelCost) implements ScopeToken, Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/ScopeTokenImpl.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.template_framework;\n+\n+\/**\n+ * Represents the setting of the fuel cost in the current scope.\n+ *\/\n+record SetFuelCostToken(float fuelCost) implements Token {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/SetFuelCostToken.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.function.Function;\n@@ -92,0 +93,10 @@\n+        \/\/ Wrap the FilteredSet as a Predicate.\n+        private record StructuralNamePredicate(FilteredSet fs) implements NameSet.Predicate {\n+            public boolean check(Name type) {\n+                return fs.check(type);\n+            }\n+            public String toString() {\n+                return fs.toString();\n+            }\n+        }\n+\n@@ -96,6 +107,14 @@\n-            return (Name name) -> {\n-                if (!(name instanceof StructuralName structuralName)) { return false; }\n-                if (subtype != null && !structuralName.type().isSubtypeOf(subtype)) { return false; }\n-                if (supertype != null && !supertype.isSubtypeOf(structuralName.type())) { return false; }\n-                return true;\n-            };\n+            return new StructuralNamePredicate(this);\n+        }\n+\n+        boolean check(Name name) {\n+            if (!(name instanceof StructuralName structuralName)) { return false; }\n+            if (subtype != null && !structuralName.type().isSubtypeOf(subtype)) { return false; }\n+            if (supertype != null && !supertype.isSubtypeOf(structuralName.type())) { return false; }\n+            return true;\n+        }\n+\n+        public String toString() {\n+            String msg1 = (subtype == null) ? \"\" : \" subtypeOf(\" + subtype + \")\";\n+            String msg2 = (supertype == null) ? \"\" : \" supertypeOf(\" + supertype + \")\";\n+            return \"StructuralName.FilteredSet(\" + msg1 + msg2 + \")\";\n@@ -149,1 +168,2 @@\n-         * of the contained {@link StructuralName}s.\n+         * of the contained {@link StructuralName}s, making the sampled {@link StructuralName}\n+         * available to an inner scope.\n@@ -151,1 +171,3 @@\n-         * @return The sampled {@link StructuralName}.\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the sampled {@link StructuralName}.\n+         * @return a token that represents the sampling and inner scope.\n@@ -154,1 +176,0 @@\n-         * @throws RendererException If the set was empty.\n@@ -156,8 +177,17 @@\n-        public StructuralName sample() {\n-            StructuralName n = (StructuralName)Renderer.getCurrent().sampleName(predicate());\n-            if (n == null) {\n-                String msg1 = (subtype == null) ? \"\" : \" subtypeOf(\" + subtype + \")\";\n-                String msg2 = (supertype == null) ? \"\" : \" supertypeOf(\" + supertype + \")\";\n-                throw new RendererException(\"No variable:\" + msg1 + msg2 + \".\");\n-            }\n-            return n;\n+        public Token sample(Function<StructuralName, ScopeToken> function) {\n+            return new NameSampleToken<>(predicate(), null, null, function);\n+        }\n+\n+        \/**\n+         * Samples a random {@link StructuralName} from the filtered set, according to the weights\n+         * of the contained {@link StructuralName}s, and makes a hashtag replacement for both\n+         * the name and type of the {@link StructuralName}, in the current scope.\n+         *\n+         * @param name the key of the hashtag replacement for the {@link StructuralName} name.\n+         * @param type the key of the hashtag replacement for the {@link StructuralName} type.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token sampleAndLetAs(String name, String type) {\n+            return new NameSampleToken<StructuralName>(predicate(), name, type, n -> Template.transparentScope());\n@@ -167,1 +197,3 @@\n-         * Counts the number of {@link StructuralName}s in the filtered set.\n+         * Samples a random {@link StructuralName} from the filtered set, according to the weights\n+         * of the contained {@link StructuralName}s, and makes a hashtag replacement for the\n+         * name of the {@link StructuralName}, in the current scope.\n@@ -169,1 +201,2 @@\n-         * @return The number of {@link StructuralName}s in the filtered set.\n+         * @param name the key of the hashtag replacement for the {@link StructuralName} name.\n+         * @return a token that represents the sampling and hashtag replacement definition.\n@@ -173,2 +206,2 @@\n-        public int count() {\n-            return Renderer.getCurrent().countNames(predicate());\n+        public Token sampleAndLetAs(String name) {\n+            return new NameSampleToken<StructuralName>(predicate(), name, null, n -> Template.transparentScope());\n@@ -178,1 +211,2 @@\n-         * Checks if there are any {@link StructuralName}s in the filtered set.\n+         * Counts the number of {@link StructuralName}s in the filtered set, making the count\n+         * available to an inner scope.\n@@ -180,1 +214,3 @@\n-         * @return Returns {@code true} iff there is at least one {@link StructuralName} in the filtered set.\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the count.\n+         * @return a token that represents the counting and inner scope.\n@@ -184,2 +220,2 @@\n-        public boolean hasAny() {\n-            return Renderer.getCurrent().hasAnyNames(predicate());\n+        public Token count(Function<Integer, ScopeToken> function) {\n+            return new NameCountToken(predicate(), function);\n@@ -189,1 +225,2 @@\n-         * Collects all {@link StructuralName}s in the filtered set.\n+         * Checks if there are any {@link StructuralName}s in the filtered set, making the resulting boolean\n+         * available to an inner scope.\n@@ -191,0 +228,15 @@\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the boolean indicating iff there are any {@link StructuralName}s in the filtered set.\n+         * @return a token that represents the checking and inner scope.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token hasAny(Function<Boolean, ScopeToken> function) {\n+            return new NameHasAnyToken(predicate(), function);\n+        }\n+        \/**\n+         * Collects all {@link StructuralName}s in the filtered set, making the collected list\n+         * available to an inner scope.\n+         *\n+         * @param function The {@link Function} that creates the inner {@link ScopeToken} given\n+         *                 the list of {@link StructuralName}.\n@@ -195,3 +247,40 @@\n-        public List<StructuralName> toList() {\n-            List<Name> list = Renderer.getCurrent().listNames(predicate());\n-            return list.stream().map(n -> (StructuralName)n).toList();\n+        public Token toList(Function<List<StructuralName>, ScopeToken> function) {\n+            return new NamesToListToken<>(predicate(), function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link StructuralName}s in the filtered set,\n+         * making each of these {@link StructuralName}s available to a separate inner scope.\n+         *\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link StructuralName}s in the filtereds set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(Function<StructuralName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), null, null, function);\n+        }\n+\n+        \/**\n+         * Calls the provided {@code function} for each {@link StructuralName}s in the filtered set,\n+         * making each of these {@link StructuralName}s available to a separate inner scope, and additionally\n+         * setting hashtag replacements for the {@code name} and {@code type} of the respective\n+         * {@link StructuralName}s.\n+         *\n+         * <p>\n+         * Note, to avoid duplication of the {@code name} and {@code type}\n+         * hashtag replacements, the scope created by the provided {@code function} should be\n+         * non-transparent to hashtag replacements, for example {@link Template#scope} or\n+         * {@link Template#hashtagScope}.\n+         *\n+         * @param name the key of the hashtag replacement for each individual {@link StructuralName} name.\n+         * @param type the key of the hashtag replacement for each individual {@link StructuralName} type.\n+         * @param function The {@link Function} that is called to create the inner {@link ScopeToken}s\n+         *                 for each of the {@link StructuralName}s in the filtereds set.\n+         * @return The token representing the for-each execution and the respective inner scopes.\n+         * @throws UnsupportedOperationException If the type was not constrained with either of\n+         *                                       {@link #subtypeOf}, {@link #supertypeOf} or {@link #exactOf}.\n+         *\/\n+        public Token forEach(String name, String type, Function<StructuralName, ScopeToken> function) {\n+            return new NameForEachToken<>(predicate(), name, type, function);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/StructuralName.java","additions":118,"deletions":29,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n- * var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+ * var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> scope(\n@@ -89,1 +89,1 @@\n- * To get an executable test, we define a {@link Template} that produces a class body with a main method. The Template\n+ * To get an executable test, we define a {@link Template} that produces a class scope with a main method. The Template\n@@ -95,1 +95,1 @@\n- * var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+ * var classTemplate = Template.make(\"types\", (List<Type> types) -> scope(\n@@ -151,1 +151,1 @@\n- *  It is currently only allowed to use up to three arguments.\n+ * It is currently only allowed to use up to three arguments.\n@@ -156,1 +156,1 @@\n- * (e.g. {@link Template.ZeroArgs#asToken()}), and use the {@link Token} inside another {@link Template#body}.\n+ * (e.g. {@link Template.ZeroArgs#asToken()}), and use the {@link Token} inside another {@link Template#scope}.\n@@ -164,0 +164,5 @@\n+ * We have decided to keep hashtag replacements constrained to the scope of one Template. They\n+ * do not escape to outer or inner Template uses. If one needs to pass values to inner Templates,\n+ * this can be done with Template arguments. Keeping hashtag replacements local to Templates\n+ * has the benefit that there is no conflict in recursive templates, where outer and inner Templates\n+ * define the same hashtag replacement.\n@@ -179,19 +184,0 @@\n- * A {@link TemplateToken} cannot just be used in {@link Template#body}, but it can also be\n- * {@link Hook#insert}ed to where a {@link Hook} was {@link Hook#anchor}ed earlier (in some outer scope of the code).\n- * For example, while generating code in a method, one can reach out to the scope of the class, and insert a\n- * new field, or define a utility method.\n- *\n- * <p>\n- * A {@link TemplateBinding} allows the recursive use of Templates. With the indirection of such a binding,\n- * a Template can reference itself.\n- *\n- * <p>\n- * The writer of recursive {@link Template}s must ensure that this recursion terminates. To unify the\n- * approach across {@link Template}s, we introduce the concept of {@link #fuel}. Templates are rendered starting\n- * with a limited amount of {@link #fuel} (default: 100, see {@link #DEFAULT_FUEL}), which is decreased at each\n- * Template nesting by a certain amount (default: 10, see {@link #DEFAULT_FUEL_COST}). The default fuel for a\n- * template can be changed when we {@code render()} it (e.g. {@link ZeroArgs#render(float)}) and the default\n- * fuel cost with {@link #setFuelCost}) when defining the {@link #body(Object...)}. Recursive templates are\n- * supposed to terminate once the {@link #fuel} is depleted (i.e. reaches zero).\n- *\n- * <p>\n@@ -214,12 +200,33 @@\n- * When working with {@link DataName}s and {@link StructuralName}s, it is important to be aware of the\n- * relevant scopes, as well as the execution order of the {@link Template} lambdas and the evaluation\n- * of the {@link Template#body} tokens. When a {@link Template} is rendered, its lambda is invoked. In the\n- * lambda, we generate the tokens, and create the {@link Template#body}. Once the lambda returns, the\n- * tokens are evaluated one by one. While evaluating the tokens, the {@link Renderer} might encounter a nested\n- * {@link TemplateToken}, which in turn triggers the evaluation of that nested {@link Template}, i.e.\n- * the evaluation of its lambda and later the evaluation of its tokens. It is important to keep in mind\n- * that the lambda is always executed first, and the tokens are evaluated afterwards. A method like\n- * {@code dataNames(MUTABLE).exactOf(type).count()} is a method that is executed during the evaluation\n- * of the lambda. But a method like {@link #addDataName} returns a token, and does not immediately add\n- * the {@link DataName}. This ensures that the {@link DataName} is only inserted when the tokens are\n- * evaluated, so that it is inserted at the exact scope where we would expect it.\n+ * Code generation can involve keeping track of scopes in the code (e.g. liveness and availability of\n+ * {@link DataName}s) and of the hashtag replacements in the templates. The {@link ScopeToken} serves\n+ * this purpose, and allows the definition of transparent scopes (e.g. {@link #transparentScope}) and\n+ * non-transparent scopes (e.g. {@link #scope}).\n+ *\n+ * <table border=\"1\">\n+ *   <caption>Scopes and (non-)transparency<\/caption>\n+ *   <tr>\n+ *     <th>                           <\/th><th> hashtag         <\/th><th> {@link DataName} and {@link StructuralName} <\/th><th> {@link #setFuelCost} <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #scope}            <\/th><th> non-transparent <\/th><th> non-transparent                             <\/th><th> non-transparent     <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #hashtagScope}     <\/th><th> non-transparent <\/th><th> transparent                                 <\/th><th> transparent         <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #nameScope}        <\/th><th> transparent     <\/th><th> non-transparent                             <\/th><th> transparent         <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #setFuelCostScope} <\/th><th> transparent     <\/th><th> transparent                                 <\/th><th> non-transparent     <\/th>\n+ *   <\/tr>\n+ *   <tr>\n+ *     <th> {@link #transparentScope} <\/th><th> transparent     <\/th><th> transparent                                 <\/th><th> transparent         <\/th>\n+ *   <\/tr>\n+ * <\/table>\n+ *\n+ * <p>\n+ * In some cases, we may be deeper nested in templates and scopes, and would like to reach \"back\" or\n+ * to outer scopes. This is possible with {@link Hook#anchor}ing in some outer scope, and later\n+ * {@link Hook#insert}ing from an inner scope to the scope of the anchoring. For example, while\n+ * generating code in a method, one can reach out to the scope of the class, and insert a new field,\n+ * or define a utility method.\n@@ -228,1 +235,2 @@\n- * Let us look at the following example to better understand the execution order.\n+ * A {@link TemplateBinding} allows the recursive use of Templates. With the indirection of such a binding,\n+ * a Template can reference itself.\n@@ -231,38 +239,25 @@\n- * {@snippet lang=java :\n- * var testTemplate = Template.make(() -> body(\n- *     \/\/ The lambda has just been invoked.\n- *     \/\/ We count the DataNames and assign the count to the hashtag replacement \"c1\".\n- *     let(\"c1\", dataNames(MUTABLE).exactOf(someType).count()),\n- *     \/\/ We want to define a DataName \"v1\", and create a token for it.\n- *     addDataName($(\"v1\"), someType, MUTABLE),\n- *     \/\/ We count the DataNames again, but the count does NOT change compared to \"c1\".\n- *     \/\/ This is because the token for \"v1\" is only evaluated later.\n- *     let(\"c2\", dataNames(MUTABLE).exactOf(someType).count()),\n- *     \/\/ Create a nested scope.\n- *     METHOD_HOOK.anchor(\n- *         \/\/ We want to define a DataName \"v2\", which is only valid inside this\n- *         \/\/ nested scope.\n- *         addDataName($(\"v2\"), someType, MUTABLE),\n- *         \/\/ The count is still not different to \"c1\".\n- *         let(\"c3\", dataNames(MUTABLE).exactOf(someType).count()),\n- *         \/\/ We nest a Template. This creates a TemplateToken, which is later evaluated.\n- *         \/\/ By the time the TemplateToken is evaluated, the tokens from above will\n- *         \/\/ be already evaluated. Hence, \"v1\" and \"v2\" are added by then, and if the\n- *         \/\/ \"otherTemplate\" were to count the DataNames, the count would be increased\n- *         \/\/ by 2 compared to \"c1\".\n- *         otherTemplate.asToken()\n- *     ),\n- *     \/\/ After closing the scope, \"v2\" is no longer available.\n- *     \/\/ The count is still the same as \"c1\", since \"v1\" is still only a token.\n- *     let(\"c4\", dataNames(MUTABLE).exactOf(someType).count()),\n- *     \/\/ We nest another Template. Again, this creates a TemplateToken, which is only\n- *     \/\/ evaluated later. By that time, the token for \"v1\" is evaluated, and so the\n- *     \/\/ nested Template would observe an increment in the count.\n- *     anotherTemplate.asToken()\n- *     \/\/ By this point, all methods are called, and the tokens generated.\n- *     \/\/ The lambda returns the \"body\", which is all of the tokens that we just\n- *     \/\/ generated. After returning from the lambda, the tokens will be evaluated\n- *     \/\/ one by one.\n- * ));\n- * }\n-\n+ * The writer of recursive {@link Template}s must ensure that this recursion terminates. To unify the\n+ * approach across {@link Template}s, we introduce the concept of {@link #fuel}. Templates are rendered starting\n+ * with a limited amount of {@link #fuel} (default: 100, see {@link #DEFAULT_FUEL}), which is decreased at each\n+ * Template nesting by a certain amount (default: 10, see {@link #DEFAULT_FUEL_COST}). The default fuel for a\n+ * template can be changed when we {@code render()} it (e.g. {@link ZeroArgs#render(float)}) and the default\n+ * fuel cost with {@link #setFuelCost}) when defining the {@link #scope(Object...)}. Recursive templates are\n+ * supposed to terminate once the {@link #fuel} is depleted (i.e. reaches zero).\n+ *\n+ * <p>\n+ * A note from the implementor to the user: We have decided to implement the Template Framework using\n+ * a functional (lambdas) and data-oriented (tokens) model. The consequence is that there are three\n+ * orders in template rendering: (1) the execution order in lambdas, where we usually assemble the\n+ * tokens and pass them to some scope ({@link ScopeToken}) as arguments. (2) the token evaluation\n+ * order, which occurs in the order of how tokens are listed in a scope. By design, the token order\n+ * is the same order as execution in lambdas. To keep the lambda and token order in sync, most of the\n+ * queries about the state of code generation, such as {@link DataName}s and {@link Hook}s cannot\n+ * return the values immediately, but have to be expressed as tokens. If we had a mix of tokens and\n+ * immediate queries, then the immediate queries would \"float\" by the tokens, because the immediate\n+ * queries are executed during the lambda execution, but the tokens are only executed later. Having\n+ * to express everything as tokens can be a little more cumbersome (e.g. sample requires a lambda\n+ * that captures the {@link DataName}, and sample does not return the {@link DataName} directly).\n+ * But this ensures that reasoning about execution order is relatively straight forward, namely in\n+ * the order of the specified tokens. (3) the final code order is the same as the lambda and token\n+ * order, except when using {@link Hook#insert}, which places the code at the innermost {@link Hook#anchor}.\n+ *\n@@ -284,1 +279,1 @@\n-     * @param function The {@link Supplier} that creates the {@link TemplateBody}.\n+     * @param function The {@link Supplier} that creates the {@link ScopeToken}.\n@@ -286,2 +281,2 @@\n-    record ZeroArgs(Supplier<TemplateBody> function) implements Template {\n-        TemplateBody instantiate() {\n+    record ZeroArgs(Supplier<ScopeToken> function) implements Template {\n+        ScopeToken instantiate() {\n@@ -327,1 +322,1 @@\n-     * @param function The {@link Function} that creates the {@link TemplateBody} given the template argument.\n+     * @param function The {@link Function} that creates the {@link ScopeToken} given the template argument.\n@@ -329,2 +324,2 @@\n-    record OneArg<T1>(String arg1Name, Function<T1, TemplateBody> function) implements Template {\n-        TemplateBody instantiate(T1 arg1) {\n+    record OneArg<T1>(String arg1Name, Function<T1, ScopeToken> function) implements Template {\n+        ScopeToken instantiate(T1 arg1) {\n@@ -375,1 +370,1 @@\n-     * @param function The {@link BiFunction} that creates the {@link TemplateBody} given the template arguments.\n+     * @param function The {@link BiFunction} that creates the {@link ScopeToken} given the template arguments.\n@@ -377,2 +372,2 @@\n-    record TwoArgs<T1, T2>(String arg1Name, String arg2Name, BiFunction<T1, T2, TemplateBody> function) implements Template {\n-        TemplateBody instantiate(T1 arg1, T2 arg2) {\n+    record TwoArgs<T1, T2>(String arg1Name, String arg2Name, BiFunction<T1, T2, ScopeToken> function) implements Template {\n+        ScopeToken instantiate(T1 arg1, T2 arg2) {\n@@ -450,1 +445,1 @@\n-     * @param function The function with three arguments that creates the {@link TemplateBody} given the template arguments.\n+     * @param function The function with three arguments that creates the {@link ScopeToken} given the template arguments.\n@@ -452,2 +447,2 @@\n-    record ThreeArgs<T1, T2, T3>(String arg1Name, String arg2Name, String arg3Name, TriFunction<T1, T2, T3, TemplateBody> function) implements Template {\n-        TemplateBody instantiate(T1 arg1, T2 arg2, T3 arg3) {\n+    record ThreeArgs<T1, T2, T3>(String arg1Name, String arg2Name, String arg3Name, TriFunction<T1, T2, T3, ScopeToken> function) implements Template {\n+        ScopeToken instantiate(T1 arg1, T2 arg2, T3 arg3) {\n@@ -499,1 +494,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -504,1 +499,1 @@\n-     * var template = Template.make(() -> body(\n+     * var template = Template.make(() -> scope(\n@@ -511,1 +506,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -514,2 +509,2 @@\n-    static Template.ZeroArgs make(Supplier<TemplateBody> body) {\n-        return new Template.ZeroArgs(body);\n+    static Template.ZeroArgs make(Supplier<ScopeToken> scope) {\n+        return new Template.ZeroArgs(scope);\n@@ -520,1 +515,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -528,1 +523,1 @@\n-     * var template = Template.make(\"a\", (Integer a) -> body(\n+     * var template = Template.make(\"a\", (Integer a) -> scope(\n@@ -537,1 +532,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -542,2 +537,2 @@\n-    static <T1> Template.OneArg<T1> make(String arg1Name, Function<T1, TemplateBody> body) {\n-        return new Template.OneArg<>(arg1Name, body);\n+    static <T1> Template.OneArg<T1> make(String arg1Name, Function<T1, ScopeToken> scope) {\n+        return new Template.OneArg<>(arg1Name, scope);\n@@ -548,1 +543,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -556,1 +551,1 @@\n-     * var template = Template.make(\"a\", \"b\", (Integer a, String b) -> body(\n+     * var template = Template.make(\"a\", \"b\", (Integer a, String b) -> scope(\n@@ -565,1 +560,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -572,2 +567,2 @@\n-    static <T1, T2> Template.TwoArgs<T1, T2> make(String arg1Name, String arg2Name, BiFunction<T1, T2, TemplateBody> body) {\n-        return new Template.TwoArgs<>(arg1Name, arg2Name, body);\n+    static <T1, T2> Template.TwoArgs<T1, T2> make(String arg1Name, String arg2Name, BiFunction<T1, T2, ScopeToken> scope) {\n+        return new Template.TwoArgs<>(arg1Name, arg2Name, scope);\n@@ -578,1 +573,1 @@\n-     * See {@link #body} for more details about how to construct a Template with {@link Token}s.\n+     * See {@link #scope} for more details about how to construct a Template with {@link Token}s.\n@@ -581,1 +576,1 @@\n-     * @param body The {@link TemplateBody} created by {@link Template#body}.\n+     * @param scope The {@link ScopeToken} created by {@link Template#scope}.\n@@ -590,2 +585,2 @@\n-    static <T1, T2, T3> Template.ThreeArgs<T1, T2, T3> make(String arg1Name, String arg2Name, String arg3Name, Template.TriFunction<T1, T2, T3, TemplateBody> body) {\n-        return new Template.ThreeArgs<>(arg1Name, arg2Name, arg3Name, body);\n+    static <T1, T2, T3> Template.ThreeArgs<T1, T2, T3> make(String arg1Name, String arg2Name, String arg3Name, Template.TriFunction<T1, T2, T3, ScopeToken> scope) {\n+        return new Template.ThreeArgs<>(arg1Name, arg2Name, arg3Name, scope);\n@@ -595,3 +590,20 @@\n-     * Creates a {@link TemplateBody} from a list of tokens, which can be {@link String}s,\n-     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}), any {@link Token},\n-     * or {@link List}s of any of these.\n+     * Creates a {@link ScopeToken} that represents a scope that is completely\n+     * non-transparent, <strong>not<\/strong> allowing anything to escape. This\n+     * means that no {@link DataName}, {@link StructuralName}s, hashtag-replacement\n+     * or {@link #setFuelCost} defined inside the scope is available outside. All\n+     * these usages are only local to the defining scope here.\n+     *\n+     * <p>\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is either fully transparent (i.e. everything escapes)\n+     * or only restricts a specific kind to not escape, consider using one of the other\n+     * provided scopes: {@link #transparentScope}, {@link #nameScope}, {@link #hashtagScope},\n+     * or {@link #setFuelCostScope}. A \"scope-transparency-matrix\" can also be found in\n+     * the interface comment for {@link Template}.\n+     *\n+     * <p>\n+     * The most common use of {@link #scope} is in the construction of templates:\n@@ -601,1 +613,1 @@\n-     * var template = Template.make(() -> body(\n+     * var template = Template.make(() -> scope(\n@@ -611,0 +623,36 @@\n+     * <p>\n+     * Note that regardless of the chosen scope for {@code Template.make},\n+     * hashtag-replacements and {@link #setFuelCost} are always implicitly\n+     * non-transparent (i.e. non-escaping). For example, {@link #let} will\n+     * not escape the template scope even when using {@link #transparentScope}.\n+     * As a default, it is recommended to use {@link #scope} for\n+     * {@code Template.make} since in most cases template scopes align with\n+     * code scopes that are non-transparent for fields, variables, etc. In\n+     * rare cases, where the scope of the template needs to be transparent\n+     * (e.g. because we need to insert a variable or field into an outer scope),\n+     * it is recommended to use {@link #transparentScope}. This allows to make\n+     * {@link DataName}s and {@link StructuralName}s available outside this\n+     * template crossing the template boundary.\n+     *\n+     * <p>\n+     * We can also use nested scopes inside of templates:\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> scope(\n+     *     \/\/ CODE1: some code in the outer scope\n+     *     scope(\n+     *       \/\/ CODE2: some code in the inner scope. Names, hashtags and setFuelCost\n+     *       \/\/        do not escape the inner scope.\n+     *     ),\n+     *     \/\/ CODE3: more code in the outer scope, names and hashtags from CODE2 are\n+     *     \/\/        not available anymore because of the non-transparent \"scope\".\n+     *     transparentScope(\n+     *       \/\/ CODE4: some code in the inner \"transparentScope\". Names, hashtags and setFuelCost\n+     *       \/\/        escape the \"transparentScope\" and are still available after the \"transparentScope\"\n+     *       \/\/        closes.\n+     *     )\n+     *     \/\/ CODE5: we still have access to names and hashtags from CODE4.\n+     * ));\n+     * }\n+     *\n@@ -614,1 +662,1 @@\n-     * @return The {@link TemplateBody} which captures the list of validated {@link Token}s.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n@@ -617,2 +665,152 @@\n-    static TemplateBody body(Object... tokens) {\n-        return new TemplateBody(TokenParser.parse(tokens));\n+    static ScopeToken scope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), false, false, false);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a completely transparent scope.\n+     * This means that {@link DataName}s, {@link StructuralName}s,\n+     * hashtag-replacements and {@link #setFuelCost} declared inside the scope will be available\n+     * in the outer scope.\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is non-transparent (i.e. nothing escapes) or only restricts\n+     * a specific kind to not escape, consider using one of the other provided scopes:\n+     * {@link #scope}, {@link #nameScope}, {@link #hashtagScope}, or {@link #setFuelCostScope}.\n+     * A \"scope-transparency-matrix\" can also be found in the interface comment for {@link Template}.\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken transparentScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), true, true, true);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a scope that is non-transparent for\n+     * {@link DataName}s and {@link StructuralName}s (i.e. cannot escape), but\n+     * transparent for hashtag-replacements and {@link #setFuelCost} (i.e. available\n+     * in outer scope).\n+     *\n+     * <p>\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is transparent or uses a different restriction, consider\n+     * using one of the other provided scopes: {@link #scope}, {@link #transparentScope},\n+     * {@link #hashtagScope}, or {@link #setFuelCostScope}. A \"scope-transparency-matrix\" can\n+     * also be found in the interface comment for {@link Template}.\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken nameScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), false, true, true);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a scope that is non-transparent for\n+     * hashtag-replacements (i.e. cannot escape), but transparent for {@link DataName}s\n+     * and {@link StructuralName}s and {@link #setFuelCost} (i.e. available in outer scope).\n+     *\n+     * <p>\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is transparent or uses a different restriction, consider\n+     * using one of the other provided scopes: {@link #scope}, {@link #transparentScope},\n+     * {@link #nameScope}, or {@link #setFuelCostScope}. A \"scope-transparency-matrix\" can\n+     * also be found in the interface comment for {@link Template}.\n+     *\n+     * <p>\n+     * Keeping hashtag-replacements local but letting {@link DataName}s escape can be\n+     * useful in cases like the following, where we may want to reuse the hashtag\n+     * multiple times:\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> scope(\n+     *     List.of(\"a\", \"b\", \"c\").stream().map(name -> hashtagScope(\n+     *         let(\"name\", name), \/\/ assumes values: a, b, c\n+     *         addDataName(name, PrimitiveType.INTS, MUTABLE), \/\/ escapes\n+     *         \"\"\"\n+     *         int #name = 42;\n+     *         \"\"\"\n+     *     ))\n+     *     \/\/ We still have access to the three DataNames.\n+     * ));\n+     * }\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken hashtagScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), true, false, true);\n+    }\n+\n+    \/**\n+     * Creates a {@link ScopeToken} that represents a scope that is non-transparent for\n+     * {@link #setFuelCost} (i.e. cannot escape), but transparent for hashtag-replacements,\n+     * {@link DataName}s and {@link StructuralName}s (i.e. available in outer scope).\n+     * The scope is formed from a list of tokens, which can be {@link String}s,\n+     * boxed primitive types (for example {@link Integer} or auto-boxed {@code int}),\n+     * any {@link Token}, or {@link List}s of any of these.\n+     *\n+     * <p>\n+     * If you require a scope that is transparent or uses a different restriction, consider\n+     * using one of the other provided scopes: {@link #scope}, {@link #transparentScope},\n+     * {@link #hashtagScope}, or {@link #nameScope}. A \"scope-transparency-matrix\" can\n+     * also be found in the interface comment for {@link Template}.\n+     *\n+     * <p>\n+     * In some cases, it can be helpful to have different {@link #setFuelCost} within\n+     * a single template, depending on the code nesting depth. Example:\n+     *\n+     * <p>\n+     * {@snippet lang=java :\n+     * var template = Template.make(() -> scope(\n+     *     setFuelCost(1),\n+     *     \/\/ CODE1: some shallow code, allowing recursive template uses here\n+     *     \/\/        to use more fuel.\n+     *     \"\"\"\n+     *     for (int i = 0; i < 1000; i++) {\n+     *     \"\"\",\n+     *     setFuelCostScope(\n+     *         setFuelCost(100)\n+     *         \/\/ CODE2: with the for-loop, we already have a deeper nesting\n+     *         \/\/        depth, and recursive template uses should not get\n+     *         \/\/        as much fuel as in CODE1.\n+     *     ),\n+     *     \"\"\"\n+     *     }\n+     *     \"\"\"\n+     *     \/\/ CODE3: we are back in the outer scope of CODE1, and can use\n+     *     \/\/        more fuel again in nested template uses. setFuelCost\n+     *     \/\/        is automatically restored to what was set before the\n+     *     \/\/        inner scope.\n+     * ));\n+     * }\n+     *\n+     * @param tokens A list of tokens, which can be {@link String}s, boxed primitive types\n+     *               (for example {@link Integer}), any {@link Token}, or {@link List}s\n+     *               of any of these.\n+     * @return The {@link ScopeToken} which captures the list of validated {@link Token}s.\n+     * @throws IllegalArgumentException if the list of tokens contains an unexpected object.\n+     *\/\n+    static ScopeToken setFuelCostScope(Object... tokens) {\n+        return new ScopeTokenImpl(TokenParser.parse(tokens), true, true, false);\n@@ -631,1 +829,1 @@\n-     * var template = Template.make(() -> body(\n+     * var template = Template.make(() -> scope(\n@@ -643,0 +841,3 @@\n+        \/\/ Note, since the dollar replacements do not change within a template\n+        \/\/ and the retrieval has no side effects, we can return the value immediately,\n+        \/\/ and do not need a token.\n@@ -651,1 +852,1 @@\n-     * var template = Template.make(\"a\", (Integer a) -> body(\n+     * var template = Template.make(\"a\", (Integer a) -> scope(\n@@ -659,0 +860,9 @@\n+     * <p>\n+     * Note that a {@code let} definition makes the hashtag replacement available\n+     * for anything that follows it, until the the end of the next outer scope\n+     * that is non-transparent for hashtag replacements. Additionally, hashtag\n+     * replacements are limited to the template they were defined in.\n+     * If you want to pass values from an outer to an inner template, this cannot\n+     * be done with hashtags directly. Instead, one has to pass the values via\n+     * template arguments.\n+     *\n@@ -661,3 +871,1 @@\n-     * @return A token that does nothing, so that the {@link #let} can easily be put in a list of tokens\n-     *         inside a {@link Template#body}.\n-     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     * @return A token that represents the hashtag replacement definition.\n@@ -666,2 +874,1 @@\n-        Renderer.getCurrent().addHashtagReplacement(key, value);\n-        return new NothingToken();\n+        return new LetToken(key, value, v -> transparentScope());\n@@ -672,1 +879,4 @@\n-     * by the provided {@code function} with type {@code <T>}.\n+     * by the provided {@code function} with type {@code <T>}. While the argument of the lambda that\n+     * captures the value is naturally bounded to the scope of the lambda, the hashtag replacement\n+     * may be bound to the scope or escape it, depending on the choice of scope, see {@link #scope}\n+     * and {@link #transparentScope}.\n@@ -676,6 +886,8 @@\n-     * var template = Template.make(\"a\", (Integer a) -> let(\"b\", a * 2, (Integer b) -> body(\n-     *     \"\"\"\n-     *     System.out.println(\"Use a and b with hashtag replacement: #a and #b\");\n-     *     \"\"\",\n-     *     \"System.out.println(\\\"Use a and b as capture variables:\\\"\" + a + \" and \" + b + \");\\n\"\n-     * )));\n+     * var template = Template.make(\"a\", (Integer a) -> scope(\n+     *     let(\"b\", a * 2, (Integer b) -> scope(\n+     *         \"\"\"\n+     *         System.out.println(\"Use a and b with hashtag replacement: #a and #b\");\n+     *         \"\"\",\n+     *         \"System.out.println(\\\"Use a and b as capture variables:\\\"\" + a + \" and \" + b + \");\\n\"\n+     *     ))\n+     * ));\n@@ -688,2 +900,1 @@\n-     * @return A {@link TemplateBody}.\n-     * @throws RendererException if there is a duplicate hashtag {@code key}.\n+     * @return A {@link Token} representing the hashtag replacement definition and inner scope.\n@@ -691,3 +902,2 @@\n-    static <T> TemplateBody let(String key, T value, Function<T, TemplateBody> function) {\n-        Renderer.getCurrent().addHashtagReplacement(key, value);\n-        return function.apply(value);\n+    static <T> Token let(String key, T value, Function<T, ScopeToken> function) {\n+        return new LetToken(key, value, function);\n@@ -705,1 +915,1 @@\n-     * with {@link #setFuelCost(float)} inside {@link #body(Object...)}.\n+     * with {@link #setFuelCost(float)} inside {@link #scope(Object...)}.\n@@ -724,1 +934,1 @@\n-     * var template = Template.make(\"depth\", (Integer depth) -> body(\n+     * var template = Template.make(\"depth\", (Integer depth) -> scope(\n@@ -740,0 +950,3 @@\n+        \/\/ Note, since the fuel amount does not change within a template\n+        \/\/ and the retrieval has no side effects, we can return the value immediately,\n+        \/\/ and do not need a token.\n@@ -748,1 +961,1 @@\n-     * @return A token for convenient use in {@link Template#body}.\n+     * @return A token for convenient use in {@link Template#scope}.\n@@ -751,2 +964,1 @@\n-        Renderer.getCurrent().setFuelCost(fuelCost);\n-        return new NothingToken();\n+        return new SetFuelCostToken(fuelCost);\n@@ -756,2 +968,4 @@\n-     * Add a {@link DataName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}.\n+     * Add a {@link DataName} in the current {@link #scope}.\n+     * If the current scope is transparent to {@link DataName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addDataName} until the end of that non-transparent scope.\n@@ -782,2 +996,4 @@\n-     * Add a {@link DataName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}, with a {@code weight} of 1.\n+     * Add a {@link DataName} in the current {@link #scope}, with a {@code weight} of 1.\n+     * If the current scope is transparent to {@link DataName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addDataName} until the end of that non-transparent scope.\n@@ -807,2 +1023,4 @@\n-     * Add a {@link StructuralName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}.\n+     * Add a {@link StructuralName} in the current {@link #scope}.\n+     * If the current scope is transparent to {@link StructuralName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addStructuralName} until the end of that non-transparent scope.\n@@ -825,2 +1043,4 @@\n-     * Add a {@link StructuralName} in the current scope, that is the innermost of either\n-     * {@link Template#body} or {@link Hook#anchor}, with a {@code weight} of 1.\n+     * Add a {@link StructuralName} in the current {@link #scope}, with a {@code weight} of 1.\n+     * If the current scope is transparent to {@link StructuralName}s, it escapes to the next\n+     * outer scope that is non-transparent, and is available for everything that follows\n+     * the {@code addStructuralName} until the end of that non-transparent scope.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Template.java","additions":365,"deletions":145,"binary":false,"changes":510,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.template_framework;\n-\n-import java.util.List;\n-\n-\/**\n- * A Template generates a {@link TemplateBody}, which is a list of {@link Token}s,\n- * which are then later rendered to {@link String}s.\n- *\n- * @param tokens The list of {@link Token}s that are later rendered to {@link String}s.\n- *\/\n-public record TemplateBody(List<Token> tokens) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateBody.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -30,8 +30,6 @@\n- * The {@link TemplateFrame} is the frame for a {@link Template}, i.e. the corresponding\n- * {@link TemplateToken}. It ensures that each template use has its own unique {@link #id}\n- * used to deconflict names using {@link Template#$}. It also has a set of hashtag\n- * replacements, which combine the key-value pairs from the template argument and the\n- * {@link Template#let} definitions. The {@link #parent} relationship provides a trace\n- * for the use chain of templates. The {@link #fuel} is reduced over this chain, to give\n- * a heuristic on how much time is spent on the code from the template corresponding to\n- * the frame, and to give a termination criterion to avoid nesting templates too deeply.\n+ * The {@link TemplateFrame} keeps track of the nested hashtag replacements available\n+ * inside the {@link Template}, as well as the unique id of the {@link Template} use,\n+ * and how much fuel is available for recursive {@link Template} calls. The name of\n+ * the {@link TemplateFrame} indicates that it corresponds to the structure of the\n+ * {@link Template}, whereas the {@link CodeFrame} corresponds to the structure of\n+ * the generated code.\n@@ -40,1 +38,39 @@\n- * See also {@link CodeFrame} for more explanations about the frames.\n+ * The unique id is used to deconflict names using {@link Template#$}.\n+ *\n+ * <p>\n+ * A {@link Template} can have multiple {@link TemplateFrame}s, if there are nested\n+ * scopes. The outermost {@link TemplateFrame} determines the id of the {@link Template}\n+ * use and performs the subtraction of fuel from the outer {@link Template}. Inner\n+ * {@link TemplateFrame}s ensure the correct availability of hashtag replacement and\n+ * {@link Template#setFuelCost} definitions, so that they are local to their scope and\n+ * nested scopes, and only escape if the scope is transparent.\n+ *\n+ * <p>\n+ * The hashtag replacements are a set of key-value pairs from the template arguments\n+ * and queries such as {@link Template#let} definitions. Each {@link TemplateFrame}\n+ * has such a set of hashtag replacements, and implicitly provides access to the\n+ * hashtag replacements of the outer {@link TemplateFrame}s, up to the outermost\n+ * of the current {@link Template}. If a hashtag replacement is added in a scope,\n+ * we have to traverse to outer scopes until we find one that is not transparent\n+ * for hashtags (at most it is the frame of the Template), and insert it there.\n+ * The hashtag replacent is local to that frame, and accessible for any frames nested\n+ * inside it, but not inside other Templates. The hashtag replacement disappears once\n+ * the corresponding scope is exited, i.e. the frame removed.\n+ *\n+ * <p>\n+ * The {@link #parent} relationship provides a trace for the use chain of templates and\n+ * their inner scopes. The {@link #fuel} is reduced over this chain to give a heuristic\n+ * on how deeply nested the code is at a given point, correlating to the runtime that\n+ * would be spent if the code was executed. The idea is that once the fuel is depleated,\n+ * we do not want to nest more deeply, so that there is a reasonable chance that the\n+ * execution of the generated code can terminate.\n+ *\n+ * <p>\n+ * The {@link TemplateFrame} thus implements the hashtag and {@link Template#setFuelCost}\n+ * non-transparency aspect of {@link ScopeToken}.\n+ *\n+ * <p>\n+ * See also {@link CodeFrame} for more explanations about the frames. Note, that while\n+ * {@link TemplateFrame} always nests inward, even with {@link Hook#insert}, the\n+ * {@link CodeFrame} can also jump to the {@link Hook#anchor} {@link CodeFrame} when\n+ * using {@link Hook#insert}.\n@@ -44,0 +80,1 @@\n+    private final boolean isInnerScope;\n@@ -48,0 +85,2 @@\n+    private final boolean isTransparentForHashtag;\n+    private final boolean isTransparentForFuel;\n@@ -50,1 +89,1 @@\n-        return new TemplateFrame(null, id, fuel, 0.0f);\n+        return new TemplateFrame(null, false, id, fuel, 0.0f, false, false);\n@@ -54,1 +93,2 @@\n-        return new TemplateFrame(parent, id, parent.fuel - parent.fuelCost, Template.DEFAULT_FUEL_COST);\n+        float fuel = parent.fuel - parent.fuelCost;\n+        return new TemplateFrame(parent, false, id, fuel, Template.DEFAULT_FUEL_COST, false, false);\n@@ -57,1 +97,16 @@\n-    private TemplateFrame(TemplateFrame parent, int id, float fuel, float fuelCost) {\n+    public static TemplateFrame makeInnerScope(TemplateFrame parent,\n+                                               boolean isTransparentForHashtag,\n+                                               boolean isTransparentForFuel) {\n+        \/\/ We keep the id of the parent, so that we have the same dollar replacements.\n+        \/\/ And we subtract no fuel, but forward the cost.\n+        return new TemplateFrame(parent, true, parent.id, parent.fuel, parent.fuelCost,\n+                                 isTransparentForHashtag, isTransparentForFuel);\n+    }\n+\n+    private TemplateFrame(TemplateFrame parent,\n+                          boolean isInnerScope,\n+                          int id,\n+                          float fuel,\n+                          float fuelCost,\n+                          boolean isTransparentForHashtag,\n+                          boolean isTransparentForFuel) {\n@@ -59,0 +114,1 @@\n+        this.isInnerScope = isInnerScope;\n@@ -62,0 +118,2 @@\n+        this.isTransparentForHashtag = isTransparentForHashtag;\n+        this.isTransparentForFuel = isTransparentForFuel;\n@@ -81,2 +139,9 @@\n-        if (hashtagReplacements.putIfAbsent(key, value) != null) {\n-            throw new RendererException(\"Duplicate hashtag replacement for #\" + key);\n+        String previous = findHashtagReplacementInScopes(key);\n+        if (previous != null) {\n+            throw new RendererException(\"Duplicate hashtag replacement for #\" + key + \". \" +\n+                                        \"previous: \" + previous + \", new: \" + value);\n+        }\n+        if (isTransparentForHashtag) {\n+            parent.addHashtagReplacement(key, value);\n+        } else {\n+            hashtagReplacements.put(key, value);\n@@ -90,0 +155,8 @@\n+        String value = findHashtagReplacementInScopes(key);\n+        if (value != null) {\n+            return value;\n+        }\n+        throw new RendererException(\"Missing hashtag replacement for #\" + key);\n+    }\n+\n+    private String findHashtagReplacementInScopes(String key) {\n@@ -93,1 +166,4 @@\n-        throw new RendererException(\"Missing hashtag replacement for #\" + key);\n+        if (!isInnerScope) {\n+            return null;\n+        }\n+        return parent.findHashtagReplacementInScopes(key);\n@@ -98,0 +174,3 @@\n+        if (isTransparentForFuel) {\n+            parent.setFuelCost(fuelCost);\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateFrame.java","additions":94,"deletions":15,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -77,1 +77,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -107,1 +107,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -141,1 +141,1 @@\n-        public TemplateBody instantiate() {\n+        public ScopeToken instantiate() {\n@@ -153,1 +153,1 @@\n-    abstract TemplateBody instantiate();\n+    abstract ScopeToken instantiate();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TemplateToken.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * The {@link Template#scope} and {@link Hook#anchor} are given a list of tokens, which are either\n@@ -31,9 +31,18 @@\n-                               TemplateToken,\n-                               TemplateToken.ZeroArgs,\n-                               TemplateToken.OneArg,\n-                               TemplateToken.TwoArgs,\n-                               TemplateToken.ThreeArgs,\n-                               HookAnchorToken,\n-                               HookInsertToken,\n-                               AddNameToken,\n-                               NothingToken {}\n+                                      TemplateToken,\n+                                      TemplateToken.ZeroArgs,\n+                                      TemplateToken.OneArg,\n+                                      TemplateToken.TwoArgs,\n+                                      TemplateToken.ThreeArgs,\n+                                      HookAnchorToken,\n+                                      HookInsertToken,\n+                                      HookIsAnchoredToken,\n+                                      AddNameToken,\n+                                      NameSampleToken,\n+                                      NameForEachToken,\n+                                      NamesToListToken,\n+                                      NameCountToken,\n+                                      NameHasAnyToken,\n+                                      LetToken,\n+                                      ScopeToken,\n+                                      ScopeTokenImpl,\n+                                      SetFuelCostToken {}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/Token.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * The {@link Template#body} and {@link Hook#anchor} are given a list of tokens, which are either\n+ * The {@link Template#scope} and {@link Hook#anchor} are given a list of tokens, which are either\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/TokenParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -360,1 +360,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/Expression.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -193,1 +193,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/PrimitiveType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -54,1 +54,1 @@\n-     * This method renders a list of {@code testTemplateTokens} into the body of a class\n+     * This method renders a list of {@code testTemplateTokens} into the scope of a class\n@@ -84,1 +84,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -99,1 +99,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -111,1 +111,1 @@\n-            ),\n+            )),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/library\/TestFrameworkClass.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8366888\n+ * @summary C2: incorrect assertion predicate with short running long counted loop\n+  *\n+ * @run main\/othervm -XX:-BackgroundCompilation TestShortCountedLoopWithLongRCBadAssertPredicate\n+ * @run main TestShortCountedLoopWithLongRCBadAssertPredicate\n+ *\/\n+\n+import java.util.Objects;\n+\n+public class TestShortCountedLoopWithLongRCBadAssertPredicate {\n+    public static void main(String[] args) {\n+        float[] floatArray = new float[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(floatArray, 10000);\n+            test2(floatArray, 10000);\n+            test3(100, 1100, floatArray, 10000);\n+            test4(999, 0, floatArray, 10000);\n+        }\n+    }\n+\n+    private static float test1(float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = 100; i < 1100; i++) {\n+            v += floatArray[i - 100];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+\n+    private static float test2(float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = 999; i >= 0; i--) {\n+            v += floatArray[i];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+\n+    private static float test3(int start, int stop, float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = start; i < stop; i++) {\n+            v += floatArray[i - 100];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+\n+    private static float test4(int start, int stop, float[] floatArray, long longRange) {\n+        float v = 0;\n+        for (int i = start; i >= stop; i--) {\n+            v += floatArray[i];\n+            Objects.checkIndex(i, longRange);\n+        }\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortCountedLoopWithLongRCBadAssertPredicate.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8366888\n+ * @summary C2: incorrect assertion predicate with short running long counted loop\n+ *\n+ * @run main\/othervm -XX:CompileOnly=TestShortCountedLoopWithLongRCBadAssertPredicate2::test -Xbatch TestShortCountedLoopWithLongRCBadAssertPredicate2\n+ * @run main\/othervm TestShortCountedLoopWithLongRCBadAssertPredicate2\n+ *\/\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+public class TestShortCountedLoopWithLongRCBadAssertPredicate2 {\n+    private static MemorySegment ms = MemorySegment.ofArray(new byte[80000]);\n+    private static final ValueLayout.OfByte BYTE = ValueLayout.JAVA_BYTE;\n+    static byte[] bArr = new byte[80000];\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10000; i++) {\n+            test(i);\n+        }\n+    }\n+\n+    public static void test(int start) {\n+        int end = start + 100;\n+        int i = 0;\n+        while (start < end) {\n+            bArr[i++] = ms.get(BYTE, start++);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortCountedLoopWithLongRCBadAssertPredicate2.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -40,1 +40,1 @@\n- *      -XX:StressSeed=1870557292\n+ *      -XX:StressSeed=1870557292 -XX:-StressDuplicateBackedge\n@@ -46,1 +46,1 @@\n- *      -XX:+StressLoopPeeling -XX:+VerifyLoopOptimizations\n+ *      -XX:+StressLoopPeeling -XX:+VerifyLoopOptimizations -XX:-StressDuplicateBackedge\n@@ -48,1 +48,2 @@\n- * @run main compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-StressDuplicateBackedge\n+ *                   compiler.loopopts.TestVerifyLoopOptimizationsHitsMemLimit\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestVerifyLoopOptimizationsHitsMemLimit.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=all-flags-fixed-stress-seed\n+ * @bug 8371146\n+ * @summary Test where the pre_init was pinned before the pre-loop but after the\n+ *          Auto_Vectorization_Check, and so it should not be used for the auto\n+ *          vectorization aliasing check, to avoid a bad (circular) graph.\n+ * @requires vm.gc == \"ZGC\" | vm.gc == \"null\"\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCheckPreLimitNotAvailable::test\n+ *      -XX:-TieredCompilation\n+ *      -Xcomp\n+ *      -XX:+UseZGC\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressLoopPeeling -XX:StressSeed=4\n+ *      -XX:LoopUnrollLimit=48\n+ *      compiler.loopopts.superword.TestAliasingCheckPreLimitNotAvailable\n+ *\/\n+\n+\/*\n+ * @test id=all-flags-no-stress-seed\n+ * @bug 8371146\n+ * @requires vm.gc == \"ZGC\" | vm.gc == \"null\"\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCheckPreLimitNotAvailable::test\n+ *      -XX:-TieredCompilation\n+ *      -Xcomp\n+ *      -XX:+UseZGC\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressLoopPeeling\n+ *      -XX:LoopUnrollLimit=48\n+ *      compiler.loopopts.superword.TestAliasingCheckPreLimitNotAvailable\n+ *\/\n+\n+\/*\n+ * @test id=fewer-flags\n+ * @bug 8371146\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCheckPreLimitNotAvailable::test\n+ *      -XX:-TieredCompilation\n+ *      -Xcomp\n+ *      -XX:LoopUnrollLimit=48\n+ *      compiler.loopopts.superword.TestAliasingCheckPreLimitNotAvailable\n+ *\/\n+\n+\/*\n+ * @test id=minimal-flags\n+ * @bug 8371146\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCheckPreLimitNotAvailable::test\n+ *      -XX:-TieredCompilation\n+ *      -Xcomp\n+ *      compiler.loopopts.superword.TestAliasingCheckPreLimitNotAvailable\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8371146\n+ * @run main compiler.loopopts.superword.TestAliasingCheckPreLimitNotAvailable\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestAliasingCheckPreLimitNotAvailable {\n+    static int sum;\n+    static boolean condition;\n+    static int zero;\n+    static int twoDimensional[][] = new int[20][20];\n+\n+    static void test() {\n+        int innerCount = 0;\n+        int conditionCount = 0;\n+        int oneDimensional[] = new int[10];\n+        for (int i = 2; i > 0; --i) {\n+            for (int j = i; j < 10; j++) {\n+                innerCount += 1;\n+                oneDimensional[1] += innerCount;\n+                oneDimensional[j] += zero;\n+                if (condition) {\n+                    conditionCount += 1;\n+                    oneDimensional[1] += conditionCount;\n+                    sum += oneDimensional[1];\n+                }\n+                twoDimensional[j] = twoDimensional[j + 1];\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingCheckPreLimitNotAvailable.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -64,1 +64,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -336,1 +336,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -352,1 +352,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -368,1 +368,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -613,1 +613,1 @@\n-                return body(\n+                return scope(\n@@ -665,1 +665,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -679,1 +679,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -701,1 +701,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -712,1 +712,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -744,1 +744,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -756,1 +756,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -768,1 +768,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -787,1 +787,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -801,1 +801,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -835,1 +835,1 @@\n-            var templateSplitRanges = Template.make(() -> body(\n+            var templateSplitRanges = Template.make(() -> scope(\n@@ -868,1 +868,1 @@\n-            var templateWholeRanges = Template.make(() -> body(\n+            var templateWholeRanges = Template.make(() -> scope(\n@@ -876,1 +876,1 @@\n-            var templateRandomRanges = Template.make(() -> body(\n+            var templateRandomRanges = Template.make(() -> scope(\n@@ -886,1 +886,1 @@\n-            var templateSmallOverlapRanges = Template.make(() -> body(\n+            var templateSmallOverlapRanges = Template.make(() -> scope(\n@@ -910,1 +910,1 @@\n-            var templateAnyRanges = Template.make(() -> body(\n+            var templateAnyRanges = Template.make(() -> scope(\n@@ -920,1 +920,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -944,1 +944,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -952,1 +952,1 @@\n-                    Template.make(() -> body(\n+                    Template.make(() -> scope(\n@@ -993,1 +993,1 @@\n-                                Template.make(() -> body(\n+                                Template.make(() -> scope(\n@@ -1024,1 +1024,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1037,1 +1037,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1097,1 +1097,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1148,1 +1148,1 @@\n-           var template = Template.make(() -> body(\n+           var template = Template.make(() -> scope(\n@@ -1161,1 +1161,1 @@\n-           var template = Template.make(() -> body(\n+           var template = Template.make(() -> scope(\n@@ -1172,1 +1172,1 @@\n-           var template = Template.make(() -> body(\n+           var template = Template.make(() -> scope(\n@@ -1183,1 +1183,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1233,1 +1233,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1248,1 +1248,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n@@ -1268,1 +1268,1 @@\n-            var template = Template.make(() -> body(\n+            var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.oracle;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import compiler.lib.ir_framework.CompilePhase;\n+\n+\/**\n+ * @test\n+ * @bug 8372097\n+ * @summary Checks that -XX:CompileCommand=PhasePrintLevel,... interacts with\n+ *          -XX:PrintPhaseLevel as expected.\n+ * @library \/test\/lib \/\n+ * @requires vm.debug & vm.compiler2.enabled & vm.flagless\n+ * @run driver compiler.oracle.TestPhasePrintLevel\n+ *\/\n+\n+public class TestPhasePrintLevel {\n+\n+    static final String level1Phase = CompilePhase.FINAL_CODE.getName();\n+    static final String level2Phase = CompilePhase.GLOBAL_CODE_MOTION.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Test flag level < 0: nothing should be printed regardless of the compile command level.\n+        test(-1, -1, null,        level1Phase);\n+        test(-1,  0, null,        level1Phase);\n+        test(-1,  1, null,        level1Phase);\n+\n+        \/\/ Test flag level = 0: the compile command level should determine what is printed.\n+        test(0,  -1, null,        level1Phase);\n+        test(0,   0, null,        level1Phase);\n+        test(0,   1, level1Phase, null);\n+        test(0,   2, level2Phase, null);\n+\n+        \/\/ Test flag level > 0: the compile command level should take precedence.\n+        test(1,  -1, null,        level1Phase);\n+        test(1,   0, null,        level1Phase);\n+        test(1,   1, level1Phase, null);\n+        test(2,   1, level1Phase, level2Phase);\n+        test(1,   2, level2Phase, null);\n+    }\n+\n+    static void test(int flagLevel, int compileCommandLevel, String expectedPhase, String unexpectedPhase) throws Exception {\n+        List<String> options = new ArrayList<String>();\n+        options.add(\"-Xbatch\");\n+        options.add(\"-XX:CompileOnly=\" + getTestName());\n+        options.add(\"-XX:PrintPhaseLevel=\" + flagLevel);\n+        options.add(\"-XX:CompileCommand=PhasePrintLevel,\" + getTestName() + \",\" + compileCommandLevel);\n+        options.add(getTestClass());\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(options);\n+        oa.shouldHaveExitValue(0)\n+            .shouldContain(\"CompileCommand: PhasePrintLevel compiler\/oracle\/TestPhasePrintLevel$TestMain.test intx PhasePrintLevel = \" + compileCommandLevel)\n+            .shouldNotContain(\"CompileCommand: An error occurred during parsing\")\n+            .shouldNotContain(\"# A fatal error has been detected by the Java Runtime Environment\");\n+        if (expectedPhase != null) {\n+            oa.shouldContain(expectedPhase);\n+        }\n+        if (unexpectedPhase != null) {\n+            oa.shouldNotContain(unexpectedPhase);\n+        }\n+    }\n+\n+    static String getTestClass() {\n+        return TestMain.class.getName();\n+    }\n+\n+    static String getTestName() {\n+        return getTestClass() + \"::test\";\n+    }\n+\n+    static class TestMain {\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 10_000; i++) {\n+                test(i);\n+            }\n+        }\n+\n+        static void test(int i) {\n+            if ((i % 1000) == 0) {\n+                System.out.println(\"Hello World!\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/TestPhasePrintLevel.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -144,0 +144,13 @@\n+ *                   compiler.predicates.assertion.TestAssertionPredicates DataUpdate\n+ *\/\n+\n+\/*\n+ * @test id=DataUpdateZGC\n+ * @key randomness\n+ * @bug 8288981 8350577 0360510\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.gc.Z\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+AbortVMOnCompilationFailure -XX:+UseZGC\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8360510\n+ * @summary Test that StressDuplicateBackedge correctly clones Template Assertion Predicates to the inner counted loop.\n+ * @run main\/othervm -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+StressDuplicateBackedge\n+ *                   compiler.predicates.assertion.TestStressDuplicateBackedgeWithAssertionPredicate\n+ * @run main compiler.predicates.assertion.TestStressDuplicateBackedgeWithAssertionPredicate\n+ *\/\n+\n+package compiler.predicates.assertion;\n+\n+public class TestStressDuplicateBackedgeWithAssertionPredicate {\n+    static int[] iArr = new int[100];\n+    static int iFld;\n+    static long lFld;\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        \/\/ 5) Once the inner empty loop is removed (step 4), we can apply the \"duplicate backedge\n+        \/\/    optimization\" to the initial outer counted loop which is now the only loop left. Note\n+        \/\/    that we can do that even though it is a counted loop: This is stressed with\n+        \/\/    StressDuplicateLoopBackedge.\n+        \/\/ 6) We do the following \"duplicate loop backedge\" transformation with current mainline:\n+        \/\/\n+        \/\/                                     Template Assertion\n+        \/\/      Template Assertion                 Predicates\n+        \/\/          Predicates                         |\n+        \/\/              |              ====>          ...\n+        \/\/             ...                             |\n+        \/\/              |                             Loop       # Outer Non-Counted Loop (newly added)\n+        \/\/          CountedLoop                       |\n+        \/\/                                        CountedLoop    # Inner Counted Loop (old)\n+        \/\/\n+        \/\/ 7) After the transformation, the Template Assertion Predicates are still at the Outer Non-Counted Loop.\n+        \/\/    As a result, we find them to be useless in the next predicate elimination call with\n+        \/\/    EliminateUselessPredicates because they cannot be found from the Inner Counted Loop (we stop at\n+        \/\/    Loop which is not a predicate). However, we have verification code in place that checks that we\n+        \/\/    can only find useless Template Assertion Predicates if the associated counted loop node is dead.\n+        \/\/    This is not the case and we crash with an assertion failure.\n+        \/\/\n+        \/\/    The fix is to move the Template Assertion Predicates to the Inner Counted Loop again.\n+        for (int i = 0; i < 100; i++) {\n+            \/\/ 3) Loop Predication will hoist this range checkout out of the loop with Template\n+            \/\/    Assertion Predicates.\n+            iArr[i] = 34;\n+\n+            \/\/ 1) We need an inner empty loop to make sure the outer counter loop is not strip mined.\n+            \/\/    Otherwise, we cannot apply the duplicate backedge optimization to the outer loop.\n+            \/\/ 4) Found to be empty and removed.\n+            for (int j = 0; j < 10; j++) {}\n+\n+            \/\/ 2) We need some region inside the outer loop, otherwise, we cannot apply the duplicate\n+            \/\/    backedge optimization.\n+            if (i == 3) {\n+                lFld = 34;\n+            } else {\n+                iFld = 2;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestStressDuplicateBackedgeWithAssertionPredicate.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,2 +118,2 @@\n-                    \/\/ Unlimited pids accept max or -1\n-                    if (actual.equals(\"max\") || actual.equals(\"-1\")) {\n+                    \/\/ Unlimited pids accept max\/-1\/unlimited\n+                    if (actual.equals(\"max\") || actual.equals(\"-1\") || actual.equals(\"unlimited\")) {\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestPids.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      \"-XX:GCTimeLimit=90\",           \/\/ Ease the CPU requirement a little.\n+      \"-XX:GCTimeLimit=80\",           \/\/ Ease the CPU requirement.\n","filename":"test\/hotspot\/jtreg\/gc\/TestUseGCOverheadLimit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,0 +195,11 @@\n+        \/\/ This used to assert that _conservative_max_heap_alignment is not a power-of-2.\n+        {\n+            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\"-XX:+UnlockExperimentalVMOptions\",\n+                    \"-XX:+UseShenandoahGC\",\n+                    \"-Xms100m\",\n+                    \"-Xmx1g\",\n+                    \"-XX:ShenandoahMaxRegionSize=33m\",\n+                    \"-version\");\n+            output.shouldHaveExitValue(0);\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestRegionSizeArgs.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-           # Core dump will be written. Default location: Core dumps may be processed with \"\/usr\/share\/apport\/apport %p %s %c %P\" (or dumping to\n-             \/home\/cheleswer\/Desktop\/core.6212)\n+           # Core dump will be written. Default location: Determined by the following:\n+           \"\/usr\/share\/apport\/apport %p %s %c %P\" (alternatively, falling back to \/home\/cheleswer\/Desktop\/core.6212)\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestCrashOnOutOfMemoryError.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2025, Microsoft, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.cds.write.archived.java.heap\n+ * @summary Sanity test for DiagnosticCommand MBean ability to invoke AOT.end_recording\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/test-classes\n+ * @build DiagnosticCommandMBeanTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar DiagnosticCommandMBeanApp\n+ * @run driver DiagnosticCommandMBeanTest\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import javax.management.MBeanServer;\n+import javax.management.ObjectName;\n+import javax.management.InstanceNotFoundException;\n+import javax.management.MBeanException;\n+import javax.management.ReflectionException;\n+import javax.management.MalformedObjectNameException;\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class DiagnosticCommandMBeanTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"DiagnosticCommandMBeanApp\";\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.runAOTWorkflow();\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+               \"-Xlog:cds+class=trace\",\n+                \"--add-modules=jdk.management\"\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass, runMode.name()\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            var name = runMode.name();\n+            if (runMode.isApplicationExecuted()) {\n+                if(runMode == RunMode.TRAINING) {\n+                    out.shouldContain(\"Hello Leyden \" + name);\n+                    out.shouldContain(\"AOT.end_recording invoked successfully\");\n+                    out.shouldContain(\"Successfully stopped recording\");\n+                } else if (runMode == RunMode.ASSEMBLY) {\n+                    out.shouldNotContain(\"Hello Leyden \");\n+                } else if (runMode == RunMode.PRODUCTION) {\n+                    out.shouldContain(\"Hello Leyden \" + name);\n+                    out.shouldContain(\"AOT.end_recording invoked successfully\");\n+                    out.shouldContain(\"Failed to stop recording\");\n+                }\n+                out.shouldNotContain(\"Exception occurred!\");\n+                out.shouldHaveExitValue(0);\n+            }\n+        }\n+    }\n+}\n+\n+class DiagnosticCommandMBeanApp {\n+    public static void main(String[] args) {\n+        System.out.println(\"Hello Leyden \" + args[0]);\n+       \/*\n+        * The following code is based on: docs\/api\/jdk.management\/com\/sun\/management\/DiagnosticCommandMBean.html\n+        *\n+        * Copied from the documentation for reference:\n+        *\n+        * ... The DiagnosticCommandMBean is generated at runtime and is subject to modifications during the lifetime of\n+        * the Java virtual machine. A diagnostic command is represented as an operation of the DiagnosticCommandMBean\n+        * interface. Each diagnostic command has:\n+        *\n+        *    - the diagnostic command name which is the name being referenced in the HotSpot Virtual Machine\n+        *    - the MBean operation name which is the name generated for the diagnostic command operation invocation. The\n+        *      MBean operation name is implementation dependent\n+        *\n+        * The recommended way to transform a diagnostic command name into a MBean operation name is as follows:\n+        *\n+        *    - All characters from the first one to the first dot are set to be lower-case characters\n+        *    - Every dot or underline character is removed and the following character is set to be an upper-case character\n+        *    - All other characters are copied without modification\n+        *\n+        * A diagnostic command may or may not support options or arguments. All the operations return String and\n+        * either take no parameter for operations that do not support any option or argument, or take a String[]\n+        * parameter for operations that support at least one option or argument. Each option or argument must be stored in\n+        * a single String.\n+        *\/\n+        try {\n+            MBeanServer server = ManagementFactory.getPlatformMBeanServer();\n+            ObjectName diagName = new ObjectName(\"com.sun.management:type=DiagnosticCommand\");\n+\n+            \/\/ The DiagnosticCommand MBean operations expect a String array parameter for command arguments\n+            \/\/ Even though AOT.end_recording doesn't need any arguments, you still need to pass an empty String array\n+            \/\/ The MBean framework requires you to specify both the parameters and their types (signatures)\n+            Object[] params = { new String[0] };\n+            String[] signature = { \"[Ljava.lang.String;\" };\n+\n+            \/\/ The JCmd AOT.end_recording is invoked using 'aotEndRecording'\n+            String result = (String) server.invoke(diagName, \"aotEndRecording\", params, signature);\n+\n+            \/\/ The result is the string output from the command\n+            System.out.println(\"AOT.end_recording invoked successfully\");\n+            if (result.contains(\"Recording ended successfully\")) {\n+                System.out.println(\"Successfully stopped recording\");\n+            } else {\n+                System.out.println(\"Failed to stop recording\");\n+            }\n+        } catch (MBeanException e) {\n+            System.out.println(\"MBeanException occurred!\");\n+        } catch (ReflectionException e) {\n+            System.out.println(\"ReflectionException occurred!\");\n+        } catch (MalformedObjectNameException e) {\n+            System.out.println(\"MalformedObjectNameException occurred!\");\n+        } catch (InstanceNotFoundException e) {\n+            System.out.println(\"InstanceNotFoundException occurred!\");\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/DiagnosticCommandMBeanTest.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Microsoft, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.cds.write.archived.java.heap\n+ * @summary Sanity test for Jcmd AOT.end_recording command\n+ * @library \/test\/lib\n+ * @build JcmdAOTEndRecordingTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LingeredApp.jar\n+ *              jdk\/test\/lib\/apps\/LingeredApp\n+ *              jdk\/test\/lib\/apps\/LingeredApp$1\n+ *              jdk\/test\/lib\/apps\/LingeredApp$SteadyStateLock\n+ *              jdk\/test\/lib\/process\/OutputBuffer\n+ * @run driver JcmdAOTEndRecordingTest\n+ *\/\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import java.io.IOException;\n+\n+public class JcmdAOTEndRecordingTest {\n+    public static void main(String[] args)  throws Exception {\n+        test(false);\n+        test(true);\n+    }\n+\n+    static void test(boolean isTraining) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new LingeredApp();\n+            theApp.setUseDefaultClasspath(false);\n+            if (isTraining) {\n+                LingeredApp.startApp(theApp,\n+                                     \"-cp\", \"LingeredApp.jar\",\n+                                     \"-XX:AOTMode=record\",\n+                                     \"-XX:AOTConfiguration=LingeredApp.aotconfig\");\n+            } else {\n+                LingeredApp.startApp(theApp,\n+                                     \"-cp\", \"LingeredApp.jar\");\n+            }\n+            long pid = theApp.getPid();\n+\n+            JDKToolLauncher jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\");\n+            jcmd.addToolArg(String.valueOf(pid));\n+            jcmd.addToolArg(\"AOT.end_recording\");\n+\n+            try {\n+                OutputAnalyzer output = ProcessTools.executeProcess(jcmd.getCommand());\n+                if (isTraining) {\n+                    output.shouldContain(\"Recording ended successfully\");\n+                } else {\n+                    \/\/ this message is output when the VM is not recording AOT data\n+                    output.shouldContain(\"AOT.end_recording is unsupported\");\n+                }\n+                output.shouldHaveExitValue(0);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Test failed: \" + e);\n+            }\n+        }\n+        catch (IOException e) {\n+            throw new RuntimeException(\"Test failed: \" + e);\n+        }\n+        finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/JcmdAOTEndRecordingTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=vthread-deopt-c1\n+ * @summary Deoptimization test for virtual threads (C1)\n+ * @requires vm.continuations\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.opt.TieredStopAtLevel != 0\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:TieredStopAtLevel=1\n+ *                   Deoptimization\n+ *\/\n+\n+\/**\n+ * @test id=vthread-deopt-c2\n+ * @summary Deoptimization test for virtual threads (C2)\n+ * @requires vm.continuations\n+ * @requires vm.compiler2.enabled\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:-TieredCompilation\n+ *                   Deoptimization\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.Objects;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class Deoptimization {\n+    static final WhiteBox white_box = WhiteBox.getWhiteBox();\n+\n+    static class TestTask implements Runnable {\n+        CyclicBarrier start_barrier = null;\n+        AtomicInteger completed_number = new AtomicInteger(0);\n+\n+        public void reset(int barrier_parties) {\n+            start_barrier = new CyclicBarrier(barrier_parties);\n+            completed_number.set(0);\n+        }\n+\n+        public int getNumberWaiting() {\n+            return start_barrier.getNumberWaiting();\n+        }\n+\n+        public int getNumberCompleted() {\n+            return completed_number.get();\n+        }\n+\n+        public void await() throws BrokenBarrierException, InterruptedException {\n+            start_barrier.await();\n+        }\n+\n+        public void run() {\n+            try {\n+                await();\n+            } catch(BrokenBarrierException e) {\n+                return;\n+            } catch(InterruptedException e) {\n+                return;\n+            }\n+\n+            completed_number.getAndIncrement();\n+        }\n+    }\n+\n+    static void test(TestTask task, Method method, int vthreads_num) throws Exception {\n+        task.reset(vthreads_num + 1 \/* 1 for the main thread *\/);\n+\n+        Thread[] vthreads = new Thread[vthreads_num];\n+        for (int i = 0; i < vthreads_num; i++) {\n+            vthreads[i] = Thread.startVirtualThread(task);\n+        }\n+\n+        while (task.getNumberWaiting() != vthreads_num) {\n+            Thread.onSpinWait();\n+        }\n+\n+        if (method != null) {\n+            if (!white_box.isMethodCompiled(method, false)) {\n+                throw new Error(\"Unexpectedly, it is not compiled.\");\n+            }\n+\n+            white_box.deoptimizeMethod(method);\n+\n+            if (white_box.isMethodCompiled(method, false)) {\n+                throw new Error(\"Unexpectedly, it is compiled.\");\n+            }\n+        }\n+\n+        task.await();\n+\n+        for (int i = 0; i < vthreads_num; i++) {\n+            vthreads[i].join();\n+        }\n+\n+        if (task.getNumberCompleted() != vthreads_num) {\n+            throw new Error(\"Some threads didn't reach completion\");\n+        }\n+    }\n+\n+    static int getIntegerOption(String option_name) {\n+        Object option_object = white_box.getVMFlag(option_name);\n+        String option_string = Objects.toString(option_object);\n+        return Integer.parseInt(option_string);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int tiered_stop_at_level = getIntegerOption(\"TieredStopAtLevel\");\n+\n+        Method method_run = TestTask.class.getMethod(\"run\");\n+        white_box.testSetDontInlineMethod(method_run, true);\n+\n+        Method method_await = TestTask.class.getMethod(\"await\");\n+        white_box.testSetDontInlineMethod(method_await, true);\n+\n+        TestTask task = new TestTask();\n+\n+        \/\/ Warm-up\n+        test(task, null, 2);\n+\n+        white_box.enqueueMethodForCompilation(method_run, tiered_stop_at_level);\n+\n+        \/\/ Deoptimization test\n+        test(task, method_run, 10000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/Deoptimization.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -46,1 +46,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -99,1 +99,1 @@\n-        var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> body(\n+        var testTemplate = Template.make(\"typeName\", \"operator\", \"generator\", (String typeName, String operator, MyGenerator generator) -> scope(\n@@ -119,1 +119,1 @@\n-        var classTemplate = Template.make(\"types\", (List<Type> types) -> body(\n+        var classTemplate = Template.make(\"types\", (List<Type> types) -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestAdvanced.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -81,1 +81,1 @@\n-            return body(\n+            return scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestExpressions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.transparentScope;\n@@ -80,1 +81,1 @@\n-        var boxingTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+        var boxingTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> scope(\n@@ -102,1 +103,1 @@\n-        var integralFloatTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> body(\n+        var integralFloatTemplate = Template.make(\"name\", \"type\", (String name, PrimitiveType type) -> scope(\n@@ -132,1 +133,5 @@\n-        var variableTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+        \/\/ IMPORTANT: since we are adding the DataName via an inserted Template, we\n+        \/\/            must chose a \"transparentScope\", so that the DataName escapes. If we\n+        \/\/            instead chose \"scope\", the test would fail, because it later\n+        \/\/            finds no DataNames when we sample.\n+        var variableTemplate = Template.make(\"type\", (PrimitiveType type) -> transparentScope(\n@@ -134,1 +139,1 @@\n-            addDataName($(\"var\"), type, MUTABLE),\n+            addDataName($(\"var\"), type, MUTABLE), \/\/ escapes the Template\n@@ -140,2 +145,1 @@\n-        var sampleTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n-            let(\"var\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+        var sampleTemplate = Template.make(\"type\", (PrimitiveType type) -> scope(\n@@ -143,0 +147,1 @@\n+            dataNames(MUTABLE).exactOf(type).sampleAndLetAs(\"var\"),\n@@ -148,1 +153,1 @@\n-        var namesTemplate = Template.make(() -> body(\n+        var namesTemplate = Template.make(() -> scope(\n@@ -152,1 +157,1 @@\n-            Hooks.METHOD_HOOK.anchor(\n+            Hooks.METHOD_HOOK.anchor(scope(\n@@ -164,1 +169,1 @@\n-            ),\n+            )),\n@@ -175,1 +180,1 @@\n-        var libraryRNGWithTypeTemplate = Template.make(\"type\", (PrimitiveType type) -> body(\n+        var libraryRNGWithTypeTemplate = Template.make(\"type\", (PrimitiveType type) -> scope(\n@@ -199,1 +204,1 @@\n-        var libraryRNGTemplate = Template.make(() -> body(\n+        var libraryRNGTemplate = Template.make(() -> scope(\n@@ -216,1 +221,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestPrimitiveTypes.java","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -64,1 +64,1 @@\n-        var template = Template.make(\"arg1\", \"arg2\", (Integer arg1, String arg2) -> body(\n+        var template = Template.make(\"arg1\", \"arg2\", (Integer arg1, String arg2) -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestSimple.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.transparentScope;\n+import static compiler.lib.template_framework.Template.hashtagScope;\n@@ -71,0 +73,1 @@\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest3c\", generateWithHashtagAndDollarReplacements3());\n@@ -76,2 +79,2 @@\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9a\", generateWithDataNamesAndScopes1());\n-        comp.addJavaSourceCode(\"p.xyz.InnerTest9b\", generateWithDataNamesAndScopes2());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9a\", generateWithScopes1());\n+        comp.addJavaSourceCode(\"p.xyz.InnerTest9b\", generateWithScopes2());\n@@ -94,0 +97,1 @@\n+        comp.invoke(\"p.xyz.InnerTest3c\", \"main\", new Object[] {});\n@@ -108,3 +112,3 @@\n-        \/\/ token body, which is a list of Tokens that are concatenated.\n-        var templateClass = Template.make(() -> body(\n-            \/\/ The \"body\" method is filled by a sequence of \"Tokens\".\n+        \/\/ scope, which contains a list of Tokens that are concatenated.\n+        var templateClass = Template.make(() -> scope(\n+            \/\/ The \"scope\" arguments are a sequence of \"Tokens\".\n@@ -144,1 +148,1 @@\n-        var templateHello = Template.make(() -> body(\n+        var templateHello = Template.make(() -> scope(\n@@ -151,1 +155,1 @@\n-        var templateCompare = Template.make(\"arg\", (Integer arg) -> body(\n+        var templateCompare = Template.make(\"arg\", (Integer arg) -> scope(\n@@ -159,1 +163,1 @@\n-            \/\/ 1) By appending to the comma-separated list of Tokens passed to body().\n+            \/\/ 1) By appending to the comma-separated list of Tokens passed to scope().\n@@ -183,1 +187,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -207,0 +211,8 @@\n+    \/\/\n+    \/\/ Important: hashtag replacements are always constrained to a single template\n+    \/\/            and are not available in any nested templates. Hashtag replacements\n+    \/\/            are only there to facilitate string templating within the limited\n+    \/\/            scope of a template. You may consider it like a \"local variable\"\n+    \/\/            for code generation purposes only.\n+    \/\/            If you need to pass some value to a nested Template, consider using\n+    \/\/            a Template argument, and capturing that Template argument.\n@@ -208,1 +220,1 @@\n-        var template1 = Template.make(\"x\", (Integer x) -> body(\n+        var template1 = Template.make(\"x\", (Integer x) -> scope(\n@@ -222,1 +234,1 @@\n-        var template2 = Template.make(\"x\", (Integer x) ->\n+        var template2 = Template.make(\"x\", (Integer x) -> scope(\n@@ -225,9 +237,7 @@\n-            let(\"y\", 11 * x, y ->\n-                body(\n-                    \"\"\"\n-                    System.out.println(\"T2: #x, #y\");\n-                    \"\"\",\n-                    template1.asToken(y)\n-                )\n-            )\n-        );\n+            let(\"y\", 11 * x, y -> scope(\n+                \"\"\"\n+                System.out.println(\"T2: #x, #y\");\n+                \"\"\",\n+                template1.asToken(y)\n+            ))\n+        ));\n@@ -238,1 +248,1 @@\n-        var template3 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+        var template3 = Template.make(\"name\", \"value\", (String name, Integer value) -> scope(\n@@ -244,1 +254,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -255,1 +265,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -303,1 +313,1 @@\n-        var template1 = Template.make(\"type\", (String type) -> body(\n+        var template1 = Template.make(\"type\", (String type) -> scope(\n@@ -312,1 +322,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -334,0 +344,139 @@\n+    \/\/ We already have used \"scope\" multiple times, but not explained it yet.\n+    \/\/ So far, we have seen \"scope\" mostly in the context of Template scopes, but they\n+    \/\/ can be used in many contexts as we will see below. They can also be used on\n+    \/\/ their own and in the use of \"let\", as we will show right now.\n+    \/\/\n+    \/\/ Scopes are even more relevant for DataNames and Structural names.\n+    \/\/ See: generateWithDataNamesForFieldsAndVariables\n+    \/\/ See: generateWithScopes1\n+    \/\/ See: generateWithScopes2\n+    public static String generateWithHashtagAndDollarReplacements3() {\n+\n+        var template1 = Template.make(() -> scope(\n+            \/\/ We can use scopes to limit the liveness of hashtag replacements.\n+            scope(\n+                let(\"x\", 3), \/\/ does not escape\n+                \"\"\"\n+                static int v1_3 = #x;\n+                \"\"\"\n+            ),\n+            scope(\n+                let(\"x\", 5), \/\/ does not escape\n+                \"\"\"\n+                static int v1_5 = #x;\n+                \"\"\"\n+            ),\n+            \/\/ Using \"scope\" does not just limit the liveness \/ availability\n+            \/\/ of hashtag replacements, but also of DataNames, StructuralNames,\n+            \/\/ and setFuelCost. We can use \"hashtagScope\" to only limit hashtag\n+            \/\/ replacements.\n+            hashtagScope(\n+                let(\"x\", 7), \/\/ does not escape\n+                \"\"\"\n+                static int v1_7 = #x;\n+                \"\"\"\n+            ),\n+            \/\/ Using \"transparentScope\" means the scope is transparent, and the hashtag\n+            \/\/ replacements escape the scope.\n+            transparentScope(\n+                let(\"x\", 11), \/\/ escapes the \"transparentScope\".\n+                \"\"\"\n+                static int v1_11a = #x;\n+                \"\"\"\n+            ),\n+            \/\/ The hashtag replacement from the \"transparentScope\" escaped, and is\n+            \/\/ still available.\n+            \"\"\"\n+            static int v1_11b = #x;\n+            \"\"\"\n+        ));\n+\n+        var template2 = Template.make(\"x\", (Integer x) -> scope(\n+            \/\/ We can map a list of values to a list of scopes. Using a scope that is\n+            \/\/ non-transparent for hashtag replacements means that we can reuse the same\n+            \/\/ hashtag key when looping \/ streaming over multiple values.\n+            List.of(3, 5, 7).stream().map(y -> scope(\n+                let(\"y\", y), \/\/ does not escape -> allows reuse of hashtag key \"y\".\n+                \"\"\"\n+                static int v2_#{x}_#{y} = #x * #y;\n+                \"\"\"\n+            )).toList()\n+        ));\n+\n+        var template3 = Template.make(\"x\", (Integer x) -> scope(\n+            \/\/ When using a \"let\" that captures the value in a lambda argument, we have\n+            \/\/ to choose what kind of scope we generate. In most cases \"scope\" or\n+            \/\/ \"hashtagScope\" are the best, because they limit the hashtag replacement\n+            \/\/ of \"y\" to the same scope as the lambda argument.\n+            let(\"y\", x * 11, y -> scope(\n+                \"\"\"\n+                static int v3a_#{x} = #y;\n+                \"\"\"\n+            )),\n+            \/\/ But in rare cases, we may want \"y\" and some nested \"z\" to escape.\n+            let(\"y\", x * 11, y -> transparentScope(\n+                let(\"z\", y * 2),\n+                \"\"\"\n+                static int v3b_#{x} = #y - #z;\n+                \"\"\"\n+            )),\n+            \/\/ Because of the \"transparentScope\", \"y\" and \"z\" have escaped.\n+            \"\"\"\n+            static int v3c_#{x} = #y - #z;\n+            \"\"\",\n+            \/\/ Side note: We can simulate a \"let\" without lambda with a \"let\" that has a lambda.\n+            \/\/ That is not very useful, but a similar trick can be used for other queries, that\n+            \/\/ only provide a lambda version, and where we only want to use the hashtag replacement.\n+            \/\/\n+            \/\/ Below we see the standard use of \"let\", where we add a hashtag replacement for \"a\"\n+            \/\/ for the rest of the enclosing scope. We then also use a lambda version of \"let\"\n+            \/\/ with a transparent scope, which means that \"b\" escapes that scope and is also\n+            \/\/ available in the enclosing scope. In the implementation of the framework, we\n+            \/\/ actually use a \"transparentScope\", so the standard \"let\" is really just syntactic\n+            \/\/ sugar for the lambda \"let\" with \"transparentScope\".\n+            let(\"a\", -x),\n+            let(\"b\", -x, b -> transparentScope()),\n+            \"\"\"\n+            static int v3d_#{x} = #a + #b;\n+            \"\"\"\n+        ));\n+\n+        \/\/ Let's write a simple class to demonstrate that this works, i.e. produces compilable code.\n+        var templateClass = Template.make(() -> scope(\n+            \"\"\"\n+            package p.xyz;\n+\n+            public class InnerTest3c {\n+            \"\"\",\n+            template1.asToken(),\n+            template2.asToken(1),\n+            template2.asToken(2),\n+            template3.asToken(2),\n+            \"\"\"\n+                public static void main() {\n+                    if (v1_3 != 3 ||\n+                        v1_5 != 5 ||\n+                        v1_7 != 7 ||\n+                        v1_11a != 11 ||\n+                        v1_11b != 11 ||\n+                        v2_1_3 != 3 ||\n+                        v2_1_5 != 5 ||\n+                        v2_1_7 != 7 ||\n+                        v2_2_3 != 6 ||\n+                        v2_2_5 != 10 ||\n+                        v2_2_7 != 14 ||\n+                        v3a_2 != 22 ||\n+                        v3b_2 != -22 ||\n+                        v3c_2 != -22 ||\n+                        v3d_2 != -4) {\n+                        throw new RuntimeException(\"Wrong result!\");\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+\n+        \/\/ Render templateClass to String.\n+        return templateClass.render();\n+    }\n+\n@@ -337,0 +486,11 @@\n+    \/\/\n+    \/\/ When we insert to a hook, we have 3 relevant scopes:\n+    \/\/ - Anchor scope: the scope defined at \"hook.anchor(scope(...))\"\n+    \/\/ - Insertion scope: the scope that is inserted, see \"hook.insert(scope(...))\"\n+    \/\/ - Caller scope: the scope we insert from.\n+    \/\/\n+    \/\/ The choice of transparency of an insertion scope (the scope that is inserted) is quite\n+    \/\/ important. A common use case is to insert a DataName.\n+    \/\/ See: generateWithDataNamesForFieldsAndVariables\n+    \/\/ See: generateWithScopes1\n+    \/\/ See: generateWithScopes2\n@@ -343,1 +503,1 @@\n-        var template1 = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n+        var template1 = Template.make(\"name\", \"value\", (String name, Integer value) -> scope(\n@@ -349,1 +509,12 @@\n-        var template2 = Template.make(\"x\", (Integer x) -> body(\n+        var template2 = Template.make(\"x\", (Integer x) -> scope(\n+            \"\"\"\n+            \/\/ Let us go back to where we anchored the hook with anchor() (see 'templateClass' below) and define a field\n+            \/\/ named $field1 there.\n+            \"\"\",\n+            myHook.insert(scope( \/\/ <- insertion scope\n+                \"\"\"\n+                public static int $field1 = #x;\n+                \"\"\"\n+                \/\/ Note that we were able to use the dollar replacement \"$field1\" and the hashtag\n+                \/\/ replacement \"#x\" inside the scope that is inserted to myHook.\n+            )),\n@@ -351,4 +522,7 @@\n-            \/\/ Let us go back to where we anchored the hook with anchor() and define a field named $field there.\n-            \/\/ Note that in the Java code we have not defined anchor() on the hook, yet. But since it's a lambda\n-            \/\/ expression, it is not evaluated, yet! Eventually, anchor() will be evaluated before insert() in\n-            \/\/ this example.\n+            \/\/ We can do that by inserting a scope like above, or by inserting a template, like below.\n+            \/\/\n+            \/\/ Which method is used is up to the user. General guidance is if the same code may also\n+            \/\/ be inserted elsewhere, one should lean towards inserting templates. But in many cases\n+            \/\/ it is nice to see the inserted code directly, and to be able to use hashtag replacements\n+            \/\/ from the outer scope directly, without having to route them via template arguments,\n+            \/\/ as we have to do below.\n@@ -356,1 +530,2 @@\n-            myHook.insert(template1.asToken($(\"field\"), x)),\n+            \/\/ <- caller scope\n+            myHook.insert(template1.asToken($(\"field2\"), x)),\n@@ -358,2 +533,4 @@\n-            System.out.println(\"$field: \" + $field);\n-            if ($field != #x) { throw new RuntimeException(\"Wrong value!\"); }\n+            System.out.println(\"$field1: \" + $field1);\n+            System.out.println(\"$field2: \" + $field2);\n+            if ($field1 != #x) { throw new RuntimeException(\"Wrong value 1!\"); }\n+            if ($field2 != #x) { throw new RuntimeException(\"Wrong value 2!\"); }\n@@ -363,1 +540,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -370,4 +547,5 @@\n-            \/\/ Anchoring a Hook creates a scope, spanning the braces of the\n-            \/\/ \"anchor\" call. Any Hook.insert that happens inside this scope\n-            \/\/ goes to the top of that scope.\n-            myHook.anchor(\n+            \/\/ Anchoring a Hook requires the definition of an inner scope,\n+            \/\/ aka the \"anchor scope\", spanning the braces of the \"anchor\" call.\n+            \/\/ Any Hook.insert that happens inside this scope goes to the top of\n+            \/\/ that scope.\n+            myHook.anchor(scope( \/\/ <- anchor scope\n@@ -376,2 +554,5 @@\n-                \/\/ <-------- field_X = 5 ------------------+\n-                \/\/ <-------- field_Y = 7 -------------+    |\n+                \/\/ <-------- field1_X = 5 -----------------+\n+                \/\/           field2_X = 5                  |\n+                \/\/                                         |\n+                \/\/ <-------- field1_Y = 7 ------------+    |\n+                \/\/           field2_Y = 7             |    |\n@@ -387,1 +568,1 @@\n-            ), \/\/ The Hook scope ends here.\n+            )), \/\/ The Hook scope ends here.\n@@ -411,13 +592,0 @@\n-        var templateStaticField = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n-            \"\"\"\n-            static { System.out.println(\"Defining static field #name\"); }\n-            public static int #name = #value;\n-            \"\"\"\n-        ));\n-\n-        var templateLocalVariable = Template.make(\"name\", \"value\", (String name, Integer value) -> body(\n-            \"\"\"\n-            System.out.println(\"Defining local variable #name\");\n-            int #name = #value;\n-            \"\"\"\n-        ));\n@@ -425,1 +593,1 @@\n-        var templateMethodBody = Template.make(() -> body(\n+        var templateMethodBody = Template.make(() -> scope(\n@@ -428,4 +596,2 @@\n-            \"\"\",\n-            Hooks.CLASS_HOOK.insert(templateStaticField.asToken($(\"field\"), 5)),\n-            Hooks.METHOD_HOOK.insert(templateLocalVariable.asToken($(\"var\"), 11)),\n-            \"\"\"\n+            \/\/ Since we are inserting them at the anchor before the code below,\n+            \/\/ they will already be available:\n@@ -434,0 +600,14 @@\n+            \"\"\",\n+            Hooks.CLASS_HOOK.insert(scope(\n+                \"\"\"\n+                static { System.out.println(\"Defining static field $field\"); }\n+                public static int $field = 5;\n+                \"\"\"\n+            )),\n+            Hooks.METHOD_HOOK.insert(scope(\n+                \"\"\"\n+                System.out.println(\"Defining local variable $var\");\n+                int $var = 11;\n+                \"\"\"\n+            )),\n+            \"\"\"\n@@ -436,0 +616,9 @@\n+            \/\/ Note: we have used \"scope\" for the \"insert\" scope. This is fine here as\n+            \/\/ we are only working with code and hashtags, but not with DataNames. If\n+            \/\/ we were to also \"addDataName\" inside the insert scope, we would have to\n+            \/\/ make sure that the scope is transparent for DataNames, so that they can\n+            \/\/ escape to the anchor scope, and can be available to the caller of the\n+            \/\/ insertion. One might want to use \"transparentScope\" for the insertion scope.\n+            \/\/ See: generateWithDataNamesForFieldsAndVariables.\n+            \/\/ See: generateWithScopes1\n+            \/\/ See: generateWithScopes2\n@@ -438,1 +627,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -445,1 +634,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -450,1 +639,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -460,1 +649,1 @@\n-                ),\n+                )),\n@@ -468,1 +657,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -476,1 +665,1 @@\n-                ),\n+                )),\n@@ -480,1 +669,1 @@\n-            ),\n+            )),\n@@ -496,1 +685,1 @@\n-        var template1 = Template.make(\"depth\", (Integer depth) -> body(\n+        var template1 = Template.make(\"depth\", (Integer depth) -> scope(\n@@ -517,1 +706,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -564,0 +753,6 @@\n+    \/\/\n+    \/\/ Note: the template library contains a lot of types that model the Java types,\n+    \/\/       such as primitive types ({@code PrimitiveType}). The following examples\n+    \/\/       give insight into how those types work. If you are just interested in\n+    \/\/       how to use the predefined types, then you can find other examples in\n+    \/\/       {@code examples\/TestPrimitiveTypes.java}.\n@@ -580,3 +775,3 @@\n-    \/\/ current scope. In a nested Template, we can then sample one of these\n-    \/\/ DataNames, which gives us one of the fields. We increment that randomly\n-    \/\/ chosen field. At the end, we print all three fields.\n+    \/\/ current scope. We can then sample some of these DataNames, which\n+    \/\/ gives us one of those fields each time. We increment those randomly\n+    \/\/ chosen fields. At the end, we print all three fields.\n@@ -584,13 +779,1 @@\n-        var templateMain = Template.make(() -> body(\n-            \/\/ Sample a random DataName, i.e. field, and assign its name to\n-            \/\/ the hashtag replacement \"#f\".\n-            \/\/ We are picking a mutable DataName, because we are not just\n-            \/\/ reading but also writing to the field.\n-            let(\"f\", dataNames(MUTABLE).exactOf(mySimpleInt).sample().name()),\n-            \"\"\"\n-            \/\/ Let us now sample a random field #f, and increment it.\n-            #f += 42;\n-            \"\"\"\n-        ));\n-\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -598,1 +781,0 @@\n-            \/\/ We can then sample from these names in a nested Template.\n@@ -602,0 +784,4 @@\n+            \/\/\n+            \/\/ Also note that DataNames are only available once they are defined:\n+            \/\/\n+            \/\/ Nothing defined, yet: dataNames() = {}\n@@ -603,0 +789,1 @@\n+            \/\/ Only now dataNames() contains f1: dataNames() = {f1}\n@@ -604,0 +791,1 @@\n+            \/\/ dataNames() = {f1, f2}\n@@ -605,0 +793,1 @@\n+            \/\/ dataNames() = {f1, f2, f3}\n@@ -615,2 +804,2 @@\n-                    \/\/ Let us now call the nested template that samples\n-                    \/\/ a random field and increments it.\n+                    \/\/ Let us now sample a random field and assign its name to\n+                    \/\/ the hashtag replacement \"a\".\n@@ -618,1 +807,18 @@\n-                    templateMain.asToken(),\n+                    dataNames(MUTABLE).exactOf(mySimpleInt).sampleAndLetAs(\"a\"),\n+                    \"\"\"\n+                    \/\/ We can now access the field, and increment it.\n+                    #a += 42;\n+                    \/\/ If we are also interested in the type of the field, we can do:\n+                    \"\"\",\n+                    dataNames(MUTABLE).exactOf(mySimpleInt).sampleAndLetAs(\"b\", \"bType\"),\n+                    \"\"\"\n+                    #b += 7;\n+                    \/\/ In some cases, we may want to capture the DataName directly, which\n+                    \/\/ requires capturing the value in a lambda that creates an inner scope:\n+                    \"\"\",\n+                    dataNames(MUTABLE).exactOf(mySimpleInt).sample((DataName dn) -> scope(\n+                        let(\"c\", dn.name()),\n+                        \"\"\"\n+                        #c += 12;\n+                        \"\"\"\n+                    )),\n@@ -621,1 +827,1 @@\n-                    \/\/ one was incremented.\n+                    \/\/ ones were incremented.\n@@ -625,2 +831,2 @@\n-                    \/\/ We have two zeros, and one 42.\n-                    if ($f1 + $f2 + $f3 != 42) { throw new RuntimeException(\"wrong result!\"); }\n+                    \/\/ Make sure they add up to the correct sum.\n+                    if ($f1 + $f2 + $f3 != 42 + 7 + 12) { throw new RuntimeException(\"wrong result!\"); }\n@@ -665,2 +871,9 @@\n-        var templateStaticField = Template.make(\"type\", (DataName.Type type) -> body(\n-            addDataName($(\"field\"), type, MUTABLE),\n+        \/\/ Note: it is very important that we use a \"transparentScope\" for the template here,\n+        \/\/       so that the DataName can escape to outer scopes, so that it is available to\n+        \/\/       everything that follows the DataName definition in the outer scope.\n+        \/\/       (We could also use \"hashtagScope\", since those are also transparent for\n+        \/\/        names. But it is not great style, because template boundaries are\n+        \/\/        non-transparent for hashtags and setFuelCost anyway. So we might as\n+        \/\/        well just use \"transparentScope\".)\n+        var templateStaticField = Template.make(\"type\", (DataName.Type type) -> transparentScope(\n+            addDataName($(\"field\"), type, MUTABLE), \/\/ escapes template because of \"transparentScope\"\n@@ -676,2 +889,4 @@\n-        var templateLocalVariable = Template.make(\"type\", (DataName.Type type) -> body(\n-            addDataName($(\"var\"), type, MUTABLE),\n+        \/\/ Note: it is very important that we use a \"transparentScope\" for the template here,\n+        \/\/       so that the DataName can escape to outer scopes.\n+        var templateLocalVariable = Template.make(\"type\", (DataName.Type type) -> transparentScope(\n+            addDataName($(\"var\"), type, MUTABLE), \/\/ escapes template because of \"transparentScope\"\n@@ -685,2 +900,2 @@\n-        var templateSample = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"name\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+        var templateSample = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE).exactOf(type).sampleAndLetAs(\"name\"),\n@@ -695,5 +910,23 @@\n-        var templateStatus = Template.make(() -> body(\n-            let(\"ints\", dataNames(MUTABLE).exactOf(myInt).count()),\n-            let(\"longs\", dataNames(MUTABLE).exactOf(myLong).count()),\n-            \/\/ Note: we could also count the MUTABLE_OR_IMMUTABLE, we will\n-            \/\/       cover the concept of mutability in an example further down.\n+        var templateStatus = Template.make(() -> scope(\n+            dataNames(MUTABLE).exactOf(myInt).count(ints -> scope(\n+                dataNames(MUTABLE).exactOf(myLong).count(longs -> scope(\n+                    \/\/ We have now captured the values as Java variables, and can\n+                    \/\/ use them inside the scope in some \"let\" definitions.\n+                    let(\"ints\", ints),\n+                    let(\"longs\", longs),\n+                    \/\/ Note: we could also count the MUTABLE_OR_IMMUTABLE, we will\n+                    \/\/       cover the concept of mutability in an example further down.\n+                    \"\"\"\n+                    System.out.println(\"Status: #ints ints, #longs longs.\");\n+                    \"\"\"\n+                ))\n+            )),\n+            \/\/ In a real code generation case, we would most likely want to\n+            \/\/ have the count as a Java variable so that one can take conditional\n+            \/\/ action based on the value. For that we have to capture the count\n+            \/\/ with a lambda and inner scope as above. If we only need to have\n+            \/\/ the count as a hashtag replacement, we can also use the following\n+            \/\/ trick:\n+            dataNames(MUTABLE).exactOf(myInt).count(c -> transparentScope(let(\"ints\", c))),\n+            dataNames(MUTABLE).exactOf(myLong).count(c -> transparentScope(let(\"longs\", c))),\n+            \/\/ Because of the \"transparentScope\", the hashtag replacements escape.\n@@ -706,1 +939,1 @@\n-        var templateMain = Template.make(() -> body(\n+        var templateMain = Template.make(() -> scope(\n@@ -739,1 +972,1 @@\n-        var templateOther = Template.make(() -> body(\n+        var templateOther = Template.make(() -> scope(\n@@ -758,1 +991,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -765,1 +998,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -770,1 +1003,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -780,1 +1013,1 @@\n-                ),\n+                )),\n@@ -788,1 +1021,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -796,1 +1029,1 @@\n-                ),\n+                )),\n@@ -800,1 +1033,1 @@\n-            ),\n+            )),\n@@ -810,32 +1043,16 @@\n-    \/\/ Let us have a closer look at how DataNames interact with scopes created by\n-    \/\/ Templates and Hooks. Additionally, we see how the execution order of the\n-    \/\/ lambdas and token evaluation affects the availability of DataNames.\n-    \/\/\n-    \/\/ We inject the results directly into verification inside the code, so it\n-    \/\/ is relatively simple to see what the expected results are.\n-    \/\/\n-    \/\/ For simplicity, we define a simple \"list\" function. It collects all\n-    \/\/ field and variable names, and immediately returns the comma separated\n-    \/\/ list of the names. We can use that to visualize the available names\n-    \/\/ at any point.\n-    public static String listNames() {\n-        return \"{\" + String.join(\", \", dataNames(MUTABLE).exactOf(myInt).toList()\n-                                       .stream().map(DataName::name).toList()) + \"}\";\n-    }\n-\n-    \/\/ Even simpler: count the available variables and return the count immediately.\n-    public static int countNames() {\n-        return dataNames(MUTABLE).exactOf(myInt).count();\n-    }\n-\n-    \/\/ Having defined these helper methods, let us start with the first example.\n-    \/\/ You should start reading this example bottom-up, starting at\n-    \/\/ templateClass, then going to templateMain and last to templateInner.\n-    public static String generateWithDataNamesAndScopes1() {\n-\n-        var templateInner = Template.make(() -> body(\n-            \/\/ We just got called from the templateMain. All tokens from there\n-            \/\/ are already evaluated, so \"v1\" is now available:\n-            let(\"l1\", listNames()),\n-            \"\"\"\n-            if (!\"{v1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{v1}' but was '#l1'\"); }\n+    public static String generateWithScopes1() {\n+\n+        \/\/ For the examples below, we need a convenient way of asserting the state\n+        \/\/ of the available DataNames.\n+        var templateVerify = Template.make(\"count\", \"hasAny\", \"toList\", (Integer count, Boolean hasAny, String toList) -> scope(\n+            dataNames(MUTABLE).exactOf(myInt).count(c -> transparentScope(let(\"count2\", c))),\n+            dataNames(MUTABLE).exactOf(myInt).hasAny(h -> transparentScope(let(\"hasAny2\", h))),\n+            dataNames(MUTABLE).exactOf(myInt).toList(list -> transparentScope(\n+                let(\"toList2\", String.join(\", \", list.stream().map(DataName::name).toList()))\n+            )),\n+            \"\"\"\n+            if (#count != #count2 ||\n+                #hasAny != #hasAny2 ||\n+                !\"#toList\".equals(\"#toList2\")) {\n+                throw new RuntimeException(\"verify failed\");\n+            }\n@@ -845,10 +1062,4 @@\n-        var templateMain = Template.make(() -> body(\n-            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n-            let(\"c1\", countNames()),\n-            \"\"\"\n-            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n-            \"\"\",\n-            \/\/ We now add a local variable \"v1\" to the scope of this templateMain.\n-            \/\/ This only generates a token, and does not immediately add the name.\n-            \/\/ The name is only added once we evaluate the tokens, and arrive at\n-            \/\/ this particular token.\n+        var templateMain = Template.make(() -> scope(\n+            \"\/\/ Start with nothing:\\n\",\n+            templateVerify.asToken(0, false, \"\"),\n+            \"\/\/ Add v1:\\n\",\n@@ -856,6 +1067,59 @@\n-            \/\/ We count again with \"c2\". The variable \"v1\" is at this point still\n-            \/\/ in token form, hence it is not yet made available while executing\n-            \/\/ the template lambda of templateMain.\n-            let(\"c2\", countNames()),\n-            \"\"\"\n-            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n+            \"int v1 = 1;\\n\",\n+            \"\/\/ Check that it is visible:\\n\",\n+            templateVerify.asToken(1, true, \"v1\"),\n+            \"\/\/ Add v2:\\n\",\n+            addDataName(\"v2\", myInt, MUTABLE),\n+            \"int v2 = 2;\\n\",\n+            \"\/\/ Check that both are visible:\\n\",\n+            templateVerify.asToken(2, true, \"v1, v2\"),\n+\n+            \"\/\/ Create a local scope:\\n\",\n+            \"{\\n\", scope( \/\/ for consistency, we model the code and template scope together.\n+                \"\/\/ Add v3:\\n\",\n+                addDataName(\"v3\", myInt, MUTABLE),\n+                \"int v3 = 3;\\n\",\n+                \"\/\/ Check that all are visible:\\n\",\n+                templateVerify.asToken(3, true, \"v1, v2, v3\")\n+            ), \"}\\n\",\n+            \"\/\/ But after the scope, v3 is no longer available:\\n\",\n+            templateVerify.asToken(2, true, \"v1, v2\"),\n+\n+            \"\/\/ Now let's create a list of variables.\\n\",\n+            List.of(4, 5, 6).stream().map(i -> hashtagScope(\n+                \/\/ The hashtagScope allows hashtag replacements to be local,\n+                \/\/ and DataNames to escape, so we can use them afterwards.\n+                let(\"i\", i),\n+                addDataName(\"v\" + i, myInt, MUTABLE),\n+                \"int v#i = #i;\\n\"\n+            )).toList(),\n+            templateVerify.asToken(5, true, \"v1, v2, v4, v5, v6\"),\n+\n+            \"\/\/ Let's multiply all variables by a factor of 2, using forEach:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(dn -> scope(\n+                let(\"v\", dn.name()),\n+                \"#v *= 2;\\n\"\n+            )),\n+            \"\/\/ We can also capture the name (v) and type of the DataName:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"v\", \"type\", dn -> scope(\n+                \"#v *= 2;\\n\"\n+            )),\n+            \"\/\/ Yet another option is using toList, but here that is more cumbersome:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).toList(list -> scope(\n+                list.stream().map(dn -> scope(\n+                    let(\"v\", dn.name()),\n+                    \"#v *= 2;\\n\"\n+                )).toList()\n+            )),\n+\n+            \"\"\"\n+            \/\/ We verify the result again.\n+            \"\"\",\n+            templateVerify.asToken(5, true, \"v1, v2, v4, v5, v6\"),\n+            \"\"\"\n+            if (v1 != 1 * 8 ||\n+                v2 != 2 * 8 ||\n+                v4 != 4 * 8 ||\n+                v5 != 5 * 8 ||\n+                v6 != 6 * 8) {\n+                throw new RuntimeException(\"wrong value!\");\n+            }\n@@ -863,5 +1127,10 @@\n-            \/\/ But now we call an inner Template. This is added as a TemplateToken.\n-            \/\/ This means it is not evaluated immediately, but only once we evaluate\n-            \/\/ the tokens. By that time, all tokens from above are already evaluated\n-            \/\/ and we see that \"v1\" is available.\n-            templateInner.asToken()\n+\n+            \"\/\/ Let us copy each variable:\\n\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"v\", \"type\", dn -> hashtagScope(\n+                \/\/ Note that we need a hashtagScope here, so that we can reuse \"v\" and\n+                \/\/ \"type\" as hashtag replacements in each iteration, but still let the\n+                \/\/ copied DataNames escape.\n+                addDataName(dn.name() + \"_copy\", myInt, MUTABLE),\n+                \"#type #{v}_copy = #v;\\n\"\n+            )),\n+            templateVerify.asToken(10, true, \"v1, v2, v4, v5, v6, v1_copy, v2_copy, v4_copy, v5_copy, v6_copy\")\n@@ -870,1 +1139,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -876,1 +1145,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -880,1 +1149,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -882,1 +1151,1 @@\n-                ),\n+                )),\n@@ -886,1 +1155,1 @@\n-            ),\n+            )),\n@@ -896,4 +1165,1 @@\n-    \/\/ Now that we understand this simple example, we go to a more complicated one\n-    \/\/ where we use Hook.insert. Just as above, you should read this example\n-    \/\/ bottom-up, starting at templateClass.\n-    public static String generateWithDataNamesAndScopes2() {\n+    public static String generateWithScopes2() {\n@@ -901,44 +1167,4 @@\n-        var templateFields = Template.make(() -> body(\n-            \/\/ We were just called from templateMain. But the code is not\n-            \/\/ generated into the main scope, rather into the class scope\n-            \/\/ out in templateClass.\n-            \/\/ Let us now add a field \"f1\".\n-            addDataName(\"f1\", myInt, MUTABLE),\n-            \/\/ And let's also generate the code for it.\n-            \"\"\"\n-            public static int f1 = 42;\n-            \"\"\",\n-            \/\/ But why is this DataName now available inside the scope of\n-            \/\/ templateInner? Does that not mean that \"f1\" escapes this\n-            \/\/ templateFields here? Yes it does!\n-            \/\/ For normal template nesting, the names do not escape the\n-            \/\/ scope of the nested template. But this here is no normal\n-            \/\/ template nesting, rather it is an insertion into a Hook,\n-            \/\/ and we treat those differently. We make the scope of the\n-            \/\/ inserted templateFields transparent, so that any added\n-            \/\/ DataNames are added to the scope of the Hook we just\n-            \/\/ inserted into, i.e. the CLASS_HOOK. This is very important,\n-            \/\/ if we did not make that scope transparent, we could not\n-            \/\/ add any DataNames to the class scope anymore, and we could\n-            \/\/ not add any fields that would be available in the class\n-            \/\/ scope.\n-            Hooks.METHOD_HOOK.anchor(\n-                \/\/ We now create a separate scope. This one is not the\n-                \/\/ template scope from above, and it is not transparent.\n-                \/\/ Hence, \"f2\" will not be available outside of this\n-                \/\/ scope.\n-                addDataName(\"f2\", myInt, MUTABLE),\n-                \/\/ And let's also generate the code for it.\n-                \"\"\"\n-                public static int f2 = 666;\n-                \"\"\"\n-                \/\/ Similarly, if we called any nested Template here,\n-                \/\/ and added DataNames inside, this would happen inside\n-                \/\/ nested scopes that are not transparent. If one wanted\n-                \/\/ to add names to the CLASS_HOOK from there, one would\n-                \/\/ have to do another Hook.insert, and make sure that\n-                \/\/ the names are added from the outermost scope of that\n-                \/\/ inserted Template, because only that outermost scope\n-                \/\/ is transparent to the CLASS_HOOK.\n-            )\n-        ));\n+        \/\/ In this section, we will look at some subtle facts about the behavior of\n+        \/\/ transparent scopes around hook insertion. This is intended for expert users\n+        \/\/ so feel free to skip it until you extensively use hook insertion.\n+        \/\/ More info can also be found in the Javadocs of the Hook class.\n@@ -946,5 +1172,5 @@\n-        var templateInner = Template.make(() -> body(\n-            \/\/ We just got called from the templateMain. All tokens from there\n-            \/\/ are already evaluated, so there should be some fields available.\n-            \/\/ We can see field \"f1\".\n-            let(\"l1\", listNames()),\n+        \/\/ Helper method to check that the expected DataNames are available.\n+        var templateVerify = Template.make(\"toList\", (String toList) -> scope(\n+            dataNames(MUTABLE).exactOf(myInt).toList(list -> transparentScope(\n+                let(\"toList2\", String.join(\", \", list.stream().map(DataName::name).toList()))\n+            )),\n@@ -952,1 +1178,3 @@\n-            if (!\"{f1}\".equals(\"#l1\")) { throw new RuntimeException(\"l1 should have been '{f1}' but was '#l1'\"); }\n+            if (!\"#toList\".equals(\"#toList2\")) {\n+                throw new RuntimeException(\"verify failed: '#toList' vs '#toList2'.\");\n+            }\n@@ -954,2 +1182,0 @@\n-            \/\/ Now go and have a look at templateFields, to understand how that\n-            \/\/ field was added, and why not any others.\n@@ -958,24 +1184,85 @@\n-        var templateMain = Template.make(() -> body(\n-            \/\/ So far, no names were defined. We expect \"c1\" to be zero.\n-            let(\"c1\", countNames()),\n-            \"\"\"\n-            if (#c1 != 0) { throw new RuntimeException(\"c1 was not zero but #c1\"); }\n-            \"\"\",\n-            \/\/ We would now like to add some fields to the class scope, out in the\n-            \/\/ templateClass. This creates a token, which is only evaluated after\n-            \/\/ the completion of the templateMain lambda. Before you go and look\n-            \/\/ at templateFields, just assume that it does add some fields, and\n-            \/\/ continue reading in templateMain.\n-            Hooks.CLASS_HOOK.insert(templateFields.asToken()),\n-            \/\/ We count again with \"c2\". The fields we wanted to add above are not\n-            \/\/ yet available, because the token is not yet evaluated. Hence, we\n-            \/\/ still only count zero names.\n-            let(\"c2\", countNames()),\n-            \"\"\"\n-            if (#c2 != 0) { throw new RuntimeException(\"c2 was not zero but #c2\"); }\n-            \"\"\",\n-            \/\/ Now we call an inner Template. This also creates a token, and so it\n-            \/\/ is not evaluated immediately. And by the time this token is evaluated\n-            \/\/ the tokens from above are already evaluated, and so the fields should\n-            \/\/ be available. Go have a look at templateInner now.\n-            templateInner.asToken()\n+        var myHook = new Hook(\"MyHook\");\n+\n+        var templateMain = Template.make(() -> scope(\n+            \/\/ Start with nothing:\n+            templateVerify.asToken(\"\"),\n+            addDataName(\"v1\", myInt, MUTABLE),\n+            templateVerify.asToken(\"v1\"),\n+            \/\/ Non-transparent hook anchor:\n+            myHook.anchor(scope(\n+                templateVerify.asToken(\"v1\"),\n+                addDataName(\"v2\", myInt, MUTABLE),\n+                templateVerify.asToken(\"v1, v2\"),\n+                \/\/ Insert a non-transparent scope: nothing escapes.\n+                myHook.insert(scope(\n+                    \/\/ Note that at the anchor insertion point, v2 is not yet\n+                    \/\/ available, because it is added after the anchoring.\n+                    templateVerify.asToken(\"v1\"),\n+                    let(\"x3\", 42),\n+                    addDataName(\"v3\", myInt, MUTABLE),\n+                    templateVerify.asToken(\"v1, v3\")\n+                )),\n+                \/\/ Note: x3 and v3 do not escape.\n+                let(\"x3\", 7), \/\/ we can define it again.\n+                templateVerify.asToken(\"v1, v2\"),\n+                \/\/ While not letting hashtags escape may be helpful, it is probably\n+                \/\/ not very helpful if the DataNames don't escape. For example, if\n+                \/\/ we are inserting some variable at an outer scope, we would like\n+                \/\/ it to be available for the rest of the scope.\n+                \/\/ That's where a transparent scope can be helpful.\n+                myHook.insert(transparentScope(\n+                    \/\/ At the anchoring, still only v1 is available.\n+                    templateVerify.asToken(\"v1\"),\n+                    let(\"x4\", 42), \/\/ escapes to caller scope\n+                    addDataName(\"v4\", myInt, MUTABLE), \/\/ escapes to anchor scope\n+                    templateVerify.asToken(\"v1, v4\")\n+                )),\n+                \/\/ x4 escapes to the caller out here, and not to the anchor scope.\n+                \"\/\/ x4: #x4\\n\",\n+                \/\/ And v4 escapes to the anchor scope, which is available from here too.\n+                \/\/ Interesting detail: the ordering in the list indicates that v1\n+                \/\/ is from the outermost scope of the template, v4 is located at the\n+                \/\/ anchor scope, and v2 is located inside the anchor scope, and\n+                \/\/ thus comes last.\n+                templateVerify.asToken(\"v1, v4, v2\"),\n+                \/\/ In most practical cases we probably don't want to let the hashtag\n+                \/\/ escape, because they just represent something local. So we can\n+                \/\/ use a hashtagScope, so that DataNames escape, but not hashtags.\n+                myHook.insert(hashtagScope(\n+                    \/\/ Note: both v1 and v4 are now available at the anchoring, since\n+                    \/\/ v1 was inserted outside the anchoring scope, and v4 was just\n+                    \/\/ inserted to the anchoring scope.\n+                    templateVerify.asToken(\"v1, v4\"),\n+                    let(\"x5\", 42), \/\/ local, does not escape.\n+                    addDataName(\"v5\", myInt, MUTABLE), \/\/ escapes to anchor scope\n+                    templateVerify.asToken(\"v1, v4, v5\")\n+                )),\n+                let(\"x5\", 7), \/\/ we can define it again.\n+                templateVerify.asToken(\"v1, v4, v5, v2\")\n+            )),\n+            \/\/ We left the non-transparent anchoring scope which does not let anything escape\n+            templateVerify.asToken(\"v1\"),\n+\n+            \/\/ Let us now do something that probably should never be done. But still\n+            \/\/ we want to demonstrate it for educational purposes: transparent anchoring\n+            \/\/ scopes.\n+            myHook.anchor(transparentScope(\n+                templateVerify.asToken(\"v1\"),\n+                \/\/ For one, this means that DataName escape the scope directly.\n+                addDataName(\"v6\", myInt, MUTABLE),\n+                templateVerify.asToken(\"v1, v6\"),\n+                \/\/ But also if we insert to the anchoring scope, DataNames don't just\n+                \/\/ escape from the anchoring scope, but further out to the enclosing\n+                \/\/ scope.\n+                myHook.insert(transparentScope(\n+                    templateVerify.asToken(\"v1, v6\"),\n+                    addDataName(\"v7\", myInt, MUTABLE),\n+                    templateVerify.asToken(\"v1, v6, v7\")\n+                )),\n+                templateVerify.asToken(\"v1, v6, v7\"),\n+                let(\"x6\", 42) \/\/ escapes the anchor scope\n+            )),\n+            \/\/ We left the transparent anchoring scope which lets the DataNames and\n+            \/\/ hashtags escape.\n+            \"\/\/ x6: #x6\\n\",\n+            templateVerify.asToken(\"v1, v6, v7\")\n@@ -984,1 +1271,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -990,1 +1277,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -994,1 +1281,1 @@\n-                Hooks.METHOD_HOOK.anchor(\n+                Hooks.METHOD_HOOK.anchor(scope(\n@@ -996,1 +1283,1 @@\n-                ),\n+                )),\n@@ -1000,1 +1287,1 @@\n-            ),\n+            )),\n@@ -1009,2 +1296,0 @@\n-\n-\n@@ -1048,2 +1333,4 @@\n-        var templateStaticField = Template.make(\"type\", \"mutable\", (DataName.Type type, Boolean mutable) -> body(\n-            addDataName($(\"field\"), type, mutable ? MUTABLE : IMMUTABLE),\n+        \/\/ This template is used to insert a DataName (field) into an outer scope, hence we must use\n+        \/\/ \"transparentScope\" instead of \"scope\".\n+        var templateStaticField = Template.make(\"type\", \"mutable\", (DataName.Type type, Boolean mutable) -> transparentScope(\n+            addDataName($(\"field\"), type, mutable ? MUTABLE : IMMUTABLE), \/\/ Escapes the template.\n@@ -1056,1 +1343,1 @@\n-        var templateLoad = Template.make(\"type\", (DataName.Type type) -> body(\n+        var templateLoad = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1062,1 +1349,1 @@\n-            let(\"field\", dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(type).sample().name()),\n+            dataNames(MUTABLE_OR_IMMUTABLE).subtypeOf(type).sampleAndLetAs(\"field\"),\n@@ -1069,1 +1356,1 @@\n-        var templateStore = Template.make(\"type\", (DataName.Type type) -> body(\n+        var templateStore = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1073,1 +1360,1 @@\n-            let(\"field\", dataNames(MUTABLE).supertypeOf(type).sample().name()),\n+            dataNames(MUTABLE).supertypeOf(type).sampleAndLetAs(\"field\"),\n@@ -1079,1 +1366,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -1097,1 +1384,1 @@\n-                Hooks.CLASS_HOOK.anchor(\n+                Hooks.CLASS_HOOK.anchor(scope(\n@@ -1121,1 +1408,1 @@\n-                ),\n+                )),\n@@ -1129,1 +1416,0 @@\n-\n@@ -1168,1 +1454,1 @@\n-        var templateMethod = Template.make(\"op\", (String op) -> body(\n+        var templateMethod = Template.make(\"op\", (String op) -> transparentScope(\n@@ -1170,1 +1456,1 @@\n-            addStructuralName($(\"methodName\"), myMethodType),\n+            addStructuralName($(\"methodName\"), myMethodType), \/\/ escapes the template because of \"transparentScope\"\n@@ -1178,1 +1464,1 @@\n-        var templateSample = Template.make(() -> body(\n+        var templateSample = Template.make(() -> scope(\n@@ -1180,1 +1466,1 @@\n-            let(\"methodName\", structuralNames().exactOf(myMethodType).sample().name()),\n+            structuralNames().exactOf(myMethodType).sampleAndLetAs(\"methodName\"),\n@@ -1187,1 +1473,1 @@\n-        var templateClass = Template.make(() -> body(\n+        var templateClass = Template.make(() -> scope(\n@@ -1195,1 +1481,1 @@\n-            Hooks.CLASS_HOOK.anchor(\n+            Hooks.CLASS_HOOK.anchor(scope(\n@@ -1221,1 +1507,1 @@\n-            )\n+            ))\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestTutorial.java","additions":561,"deletions":275,"binary":false,"changes":836,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -85,1 +85,1 @@\n-        var commentTemplate = Template.make(() -> body(\n+        var commentTemplate = Template.make(() -> scope(\n@@ -106,1 +106,1 @@\n-        var testTemplate = Template.make(\"op\", (String op) -> body(\n+        var testTemplate = Template.make(\"op\", (String op) -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/examples\/TestWithTestFrameworkClass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -96,1 +96,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -144,1 +144,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -187,1 +187,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestExpression.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n@@ -87,1 +87,1 @@\n-        var template1 = Template.make(\"info\", (FormatInfo info) -> body(\n+        var template1 = Template.make(\"info\", (FormatInfo info) -> scope(\n@@ -98,1 +98,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestFormat.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,1 +47,5 @@\n-import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.scope;\n+import static compiler.lib.template_framework.Template.transparentScope;\n+import static compiler.lib.template_framework.Template.nameScope;\n+import static compiler.lib.template_framework.Template.hashtagScope;\n+import static compiler.lib.template_framework.Template.setFuelCostScope;\n@@ -124,1 +128,1 @@\n-        testBodyTokens();\n+        testBasicTokens();\n@@ -128,2 +132,4 @@\n-        testNested();\n-        testHookSimple();\n+        testNestedTemplates();\n+        testHookSimple1();\n+        testHookSimple2();\n+        testHookSimple3();\n@@ -135,1 +141,2 @@\n-        testLet();\n+        testLet1();\n+        testLet2();\n@@ -141,0 +148,5 @@\n+        testFuelAndScopes();\n+        testDataNames0a();\n+        testDataNames0b();\n+        testDataNames0c();\n+        testDataNames0d();\n@@ -146,0 +158,2 @@\n+        testDataNames6();\n+        testStructuralNames0();\n@@ -148,0 +162,4 @@\n+        testStructuralNames3();\n+        testStructuralNames4();\n+        testStructuralNames5();\n+        testStructuralNames6();\n@@ -149,0 +167,6 @@\n+        testNestedScopes1();\n+        testNestedScopes2();\n+        testTemplateScopes();\n+        testHookAndScopes1();\n+        testHookAndScopes2();\n+        testHookAndScopes3();\n@@ -153,1 +177,0 @@\n-        expectRendererException(() -> let(\"x\",\"y\"),                       \"A Template method such as\");\n@@ -155,4 +178,0 @@\n-        expectRendererException(() -> setFuelCost(1.0f),                  \"A Template method such as\");\n-        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),  \"A Template method such as\");\n-        expectRendererException(() -> dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).sample(), \"A Template method such as\");\n-        expectRendererException(() -> (new Hook(\"abc\")).isAnchored(),     \"A Template method such as\");\n@@ -181,1 +200,2 @@\n-        expectRendererException(() -> testFailingSample1(),  \"No variable: MUTABLE, subtypeOf(int), supertypeOf(int).\");\n+        expectRendererException(() -> testFailingSample1a(),  \"No Name found for DataName.FilterdSet(MUTABLE, subtypeOf(int), supertypeOf(int))\");\n+        expectRendererException(() -> testFailingSample1b(),  \"No Name found for StructuralName.FilteredSet( subtypeOf(StructuralA) supertypeOf(StructuralA))\");\n@@ -186,0 +206,1 @@\n+        expectRendererException(() -> testFailingHashtag5(), \"Missing hashtag replacement for #a\");\n@@ -188,3 +209,15 @@\n-        expectIllegalArgumentException(() -> body(null),              \"Unexpected tokens: null\");\n-        expectIllegalArgumentException(() -> body(\"x\", null),         \"Unexpected token: null\");\n-        expectIllegalArgumentException(() -> body(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> scope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> scope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> scope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> transparentScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> transparentScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> transparentScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> nameScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> nameScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> nameScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> hashtagScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> hashtagScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> hashtagScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n+        expectIllegalArgumentException(() -> setFuelCostScope(null),              \"Unexpected tokens: null\");\n+        expectIllegalArgumentException(() -> setFuelCostScope(\"x\", null),         \"Unexpected token: null\");\n+        expectIllegalArgumentException(() -> setFuelCostScope(new Hook(\"Hook1\")), \"Unexpected token:\");\n@@ -192,3 +225,0 @@\n-        expectIllegalArgumentException(() -> hook1.anchor(null),      \"Unexpected tokens: null\");\n-        expectIllegalArgumentException(() -> hook1.anchor(\"x\", null), \"Unexpected token: null\");\n-        expectIllegalArgumentException(() -> hook1.anchor(hook1),     \"Unexpected token:\");\n@@ -202,1 +232,2 @@\n-        expectUnsupportedOperationException(() -> testFailingSample2(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+        expectUnsupportedOperationException(() -> testFailingSample2a(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n+        expectUnsupportedOperationException(() -> testFailingSample2b(), \"Must first call 'subtypeOf', 'supertypeOf', or 'exactOf'.\");\n@@ -211,0 +242,7 @@\n+        expectRendererException(() -> testFailingScope1(), \"Duplicate hashtag replacement for #x. previous: x1, new: x2\");\n+        expectRendererException(() -> testFailingScope2(), \"Duplicate hashtag replacement for #x. previous: x1, new: x2\");\n+        expectRendererException(() -> testFailingScope3(), \"Duplicate hashtag replacement for #x. previous: a, new: b\");\n+        expectRendererException(() -> testFailingScope4(), \"Duplicate hashtag replacement for #x. previous: a, new: b\");\n+        expectRendererException(() -> testFailingScope5(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingScope6(), \"Duplicate name:\");\n+        expectRendererException(() -> testFailingScope7(), \"Duplicate name:\");\n@@ -214,1 +252,1 @@\n-        var template = Template.make(() -> body(\"Hello World!\"));\n+        var template = Template.make(() -> scope(\"Hello World!\"));\n@@ -220,1 +258,1 @@\n-        var template = Template.make(() -> body(\n+        var template = Template.make(() -> scope(\n@@ -235,4 +273,4 @@\n-    public static void testBodyTokens() {\n-        \/\/ We can fill the body with Objects of different types, and they get concatenated.\n-        \/\/ Lists get flattened into the body.\n-        var template = Template.make(() -> body(\n+    public static void testBasicTokens() {\n+        \/\/ We can fill the scope with Objects of different types, and they get concatenated.\n+        \/\/ Lists get flattened into the scope.\n+        var template = Template.make(() -> scope(\n@@ -253,1 +291,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"start #a end\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"start #a end\"));\n@@ -259,1 +297,1 @@\n-        var template2 = Template.make(\"a\", (String a) -> body(\"start \", a, \" end\"));\n+        var template2 = Template.make(\"a\", (String a) -> scope(\"start \", a, \" end\"));\n@@ -265,1 +303,1 @@\n-        var template3 = Template.make(\"a\", (Integer a) -> body(\"start #a end\"));\n+        var template3 = Template.make(\"a\", (Integer a) -> scope(\"start #a end\"));\n@@ -271,1 +309,1 @@\n-        var template4 = Template.make(\"a\", (Integer a) -> body(\"start \", a, \" end\"));\n+        var template4 = Template.make(\"a\", (Integer a) -> scope(\"start \", a, \" end\"));\n@@ -277,1 +315,1 @@\n-        var template5 = Template.make(\"a\", (String a) -> body(\"start #a \" + a + \" end\"));\n+        var template5 = Template.make(\"a\", (String a) -> scope(\"start #a \" + a + \" end\"));\n@@ -285,1 +323,1 @@\n-        var template1 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start #a1 #a2 end\"));\n+        var template1 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\"start #a1 #a2 end\"));\n@@ -291,1 +329,1 @@\n-        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\"start \", a1, \" \", a2, \" end\"));\n@@ -297,1 +335,1 @@\n-        var template3 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start #a1 #a2 end\"));\n+        var template3 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> scope(\"start #a1 #a2 end\"));\n@@ -303,1 +341,1 @@\n-        var template4 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> body(\"start \", a1, \" \", a2, \" end\"));\n+        var template4 = Template.make(\"a1\", \"a2\", (Integer a1, Integer a2) -> scope(\"start \", a1, \" \", a2, \" end\"));\n@@ -311,1 +349,1 @@\n-        var template1 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        var template1 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> scope(\"start #a1 #a2 #a3 end\"));\n@@ -317,1 +355,1 @@\n-        var template2 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        var template2 = Template.make(\"a1\", \"a2\", \"a3\", (String a1, String a2, String a3) -> scope(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n@@ -323,1 +361,1 @@\n-        var template3 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start #a1 #a2 #a3 end\"));\n+        var template3 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> scope(\"start #a1 #a2 #a3 end\"));\n@@ -329,1 +367,1 @@\n-        var template4 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> body(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n+        var template4 = Template.make(\"a1\", \"a2\", \"a3\", (Integer a1, Integer a2, Integer a3) -> scope(\"start \", a1, \" \", a2, \" \", a3, \" end\"));\n@@ -335,2 +373,2 @@\n-    public static void testNested() {\n-        var template1 = Template.make(() -> body(\"proton\"));\n+    public static void testNestedTemplates() {\n+        var template1 = Template.make(() -> scope(\"proton\"));\n@@ -338,1 +376,1 @@\n-        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+        var template2 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\n@@ -343,1 +381,1 @@\n-        var template3 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> body(\n+        var template3 = Template.make(\"a1\", \"a2\", (String a1, String a2) -> scope(\n@@ -350,1 +388,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -377,1 +415,1 @@\n-    public static void testHookSimple() {\n+    public static void testHookSimple1() {\n@@ -380,1 +418,1 @@\n-        var template1 = Template.make(() -> body(\"Hello\\n\"));\n+        var template1 = Template.make(() -> scope(\"Hello\\n\"));\n@@ -382,1 +420,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -384,1 +422,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -389,1 +427,27 @@\n-            ),\n+            )),\n+            \"}\"\n+        ));\n+\n+        String code = template2.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            Hello\n+            World\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookSimple2() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        var template2 = Template.make(() -> scope(\n+            \"{\\n\",\n+            hook1.anchor(scope(\n+                \"World\\n\",\n+                \/\/ Note: \"Hello\" from the scope below will be inserted\n+                \/\/ above \"World\" above.\n+                hook1.insert(scope(\n+                    \"Hello\\n\"\n+                ))\n+            )),\n@@ -403,0 +467,33 @@\n+    public static void testHookSimple3() {\n+        var hook1 = new Hook(\"Hook1\");\n+\n+        \/\/ Ensure that insert inside insert really goes first.\n+        var template = Template.make(() -> scope(\n+            \"{\\n\",\n+            hook1.anchor(scope(\n+                \"<Anchor\\n\",\n+                hook1.insert(scope(\n+                    \"<Outer Insert\\n\",\n+                    hook1.insert(scope(\n+                        \"Inner Insert\\n\"\n+                    )),\n+                    \">Outer Insert\\n\"\n+                )),\n+                \">Anchor\\n\"\n+            )),\n+            \"}\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            {\n+            Inner Insert\n+            <Outer Insert\n+            >Outer Insert\n+            <Anchor\n+            >Anchor\n+            }\"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -406,1 +503,1 @@\n-        var template0 = Template.make(() -> body(\"isAnchored: \", hook1.isAnchored(), \"\\n\"));\n+        var template0 = Template.make(() -> scope(\"t0 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\"));\n@@ -408,1 +505,1 @@\n-        var template1 = Template.make(() -> body(\"Hello\\n\", template0.asToken()));\n+        var template1 = Template.make(() -> scope(\"Hello\\n\", template0.asToken()));\n@@ -410,1 +507,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -412,0 +509,1 @@\n+            \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\",\n@@ -413,1 +511,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -415,0 +513,1 @@\n+                \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\",\n@@ -416,2 +515,5 @@\n-                hook1.insert(template1.asToken())\n-            ),\n+                hook1.insert(template1.asToken()),\n+                hook1.insert(scope(\"Beautiful\\n\", template0.asToken())),\n+                \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\"\n+            )),\n+            \"t2 isAnchored: \", hook1.isAnchored(a -> scope(a)), \"\\n\",\n@@ -426,1 +528,2 @@\n-            isAnchored: false\n+            t2 isAnchored: false\n+            t0 isAnchored: false\n@@ -428,1 +531,3 @@\n-            isAnchored: true\n+            t0 isAnchored: true\n+            Beautiful\n+            t0 isAnchored: true\n@@ -430,2 +535,5 @@\n-            isAnchored: true\n-            isAnchored: false\n+            t2 isAnchored: true\n+            t0 isAnchored: true\n+            t2 isAnchored: true\n+            t2 isAnchored: false\n+            t0 isAnchored: false\n@@ -439,1 +547,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x #a x\\n\"));\n@@ -442,1 +550,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -444,1 +552,1 @@\n-            hook1.anchor(), \/\/ empty\n+            hook1.anchor(scope()), \/\/ empty\n@@ -446,1 +554,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -451,0 +559,2 @@\n+                hook1.insert(scope(\"y 1 y\\n\")),\n+                hook1.insert(scope(\"y 2 y\\n\")),\n@@ -452,1 +562,1 @@\n-                hook1.anchor(\n+                hook1.anchor(scope(\n@@ -455,0 +565,1 @@\n+                    hook1.insert(scope(\"y 3 y\\n\")),\n@@ -456,1 +567,1 @@\n-                ),\n+                )),\n@@ -458,1 +569,1 @@\n-                hook1.anchor(), \/\/ empty\n+                hook1.anchor(scope()), \/\/ empty\n@@ -461,0 +572,1 @@\n+                hook1.insert(scope(\"y 4 y\\n\")),\n@@ -462,1 +574,1 @@\n-                hook1.anchor(\n+                hook1.anchor(scope(\n@@ -465,0 +577,1 @@\n+                    hook1.insert(scope(\"y 5 y\\n\")),\n@@ -466,1 +579,1 @@\n-                ),\n+                )),\n@@ -468,1 +581,1 @@\n-            ),\n+            )),\n@@ -479,0 +592,2 @@\n+            y 1 y\n+            y 2 y\n@@ -480,0 +595,1 @@\n+            y 4 y\n@@ -484,0 +600,1 @@\n+            y 3 y\n@@ -490,0 +607,1 @@\n+            y 5 y\n@@ -501,1 +619,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x #a x\\n\"));\n@@ -503,1 +621,1 @@\n-        var template2 = Template.make(\"b\", (String b) -> body(\n+        var template2 = Template.make(\"b\", (String b) -> scope(\n@@ -509,1 +627,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -514,1 +632,1 @@\n-                hook2.anchor(\n+                hook2.anchor(scope(\n@@ -519,1 +637,1 @@\n-                ),\n+                )),\n@@ -524,1 +642,1 @@\n-            ),\n+            )),\n@@ -533,1 +651,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -536,1 +654,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -538,1 +656,1 @@\n-                hook2.anchor(\n+                hook2.anchor(scope(\n@@ -542,1 +660,1 @@\n-                ),\n+                )),\n@@ -544,1 +662,1 @@\n-            ),\n+            )),\n@@ -589,1 +707,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x #a x\\n\"));\n@@ -591,1 +709,1 @@\n-        var template2 = Template.make(\"b\", (String b) -> body(\n+        var template2 = Template.make(\"b\", (String b) -> scope(\n@@ -597,1 +715,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -602,1 +720,1 @@\n-            ),\n+            )),\n@@ -607,1 +725,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -610,1 +728,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -614,1 +732,1 @@\n-            ),\n+            )),\n@@ -645,1 +763,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\"x $name #a x\\n\"));\n+        var template1 = Template.make(\"a\", (String a) -> scope(\"x $name #a x\\n\"));\n@@ -647,1 +765,1 @@\n-        var template2 = Template.make(\"a\", (String a) -> body(\n+        var template2 = Template.make(\"a\", (String a) -> scope(\n@@ -654,1 +772,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -663,1 +781,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -665,1 +783,1 @@\n-            ),\n+            )),\n@@ -667,1 +785,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -675,1 +793,1 @@\n-            ),\n+            )),\n@@ -707,1 +825,1 @@\n-    public static void testLet() {\n+    public static void testLet1() {\n@@ -710,1 +828,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\n+        var template1 = Template.make(\"a\", (String a) -> scope(\n@@ -718,2 +836,2 @@\n-        var template2 = Template.make(\"a\", (Integer a) -> let(\"b\", a * 10, b ->\n-            body(\n+        var template2 = Template.make(\"a\", (Integer a) -> scope(\n+            let(\"b\", a * 10, b -> scope(\n@@ -722,1 +840,1 @@\n-            )\n+            ))\n@@ -725,1 +843,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -731,1 +849,1 @@\n-            hook1.anchor(\n+            hook1.anchor(transparentScope( \/\/ transparentScope allows hashtags to escape\n@@ -736,1 +854,1 @@\n-            ),\n+            )),\n@@ -769,0 +887,22 @@\n+    public static void testLet2() {\n+        var template = Template.make(() -> scope(\n+            \"outer {\\n\",\n+            let(\"x\", \"x1\", x -> scope(\n+                \"x: #x \", x, \".\\n\"\n+            )),\n+            let(\"x\", \"x2\"), \/\/ definition above is limited to its scope\n+            \"x: #x\\n\",\n+            \"} outer\\n\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            outer {\n+            x: x1 x1.\n+            x: x2\n+            } outer\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -770,1 +910,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -795,1 +935,1 @@\n-        var template1 = Template.make(\"a\", (String a) -> body(\n+        var template1 = Template.make(\"a\", (String a) -> scope(\n@@ -801,1 +941,1 @@\n-        var template2 = Template.make(\"a\", (String a) -> body(\n+        var template2 = Template.make(\"a\", (String a) -> scope(\n@@ -807,1 +947,1 @@\n-        var template3 = Template.make(\"a\", (Integer a) -> body(\n+        var template3 = Template.make(\"a\", (Integer a) -> scope(\n@@ -816,1 +956,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -868,1 +1008,1 @@\n-        var template1 = Template.make(\"i\", (Integer i) -> body(\n+        var template1 = Template.make(\"i\", (Integer i) -> scope(\n@@ -877,1 +1017,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -905,1 +1045,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -913,1 +1053,1 @@\n-        var template2 = Template.make(\"i\", (Integer i) -> body(\n+        var template2 = Template.make(\"i\", (Integer i) -> scope(\n@@ -923,1 +1063,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -951,1 +1091,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -960,1 +1100,1 @@\n-        var template2 = Template.make(\"i\", (Integer i) -> body(\n+        var template2 = Template.make(\"i\", (Integer i) -> scope(\n@@ -971,1 +1111,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -1005,0 +1145,216 @@\n+    public static void testFuelAndScopes() {\n+        var readFuelTemplate = Template.make(() -> scope(\n+            let(\"f\", fuel()),\n+            \"<#f>\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            let(\"f\", fuel()),\n+            \"{#f}\\n\",\n+            readFuelTemplate.asToken(),\n+\n+            \"scope:\\n\",\n+            setFuelCost(1.0f),\n+            scope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(2.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"transparentScope:\\n\",\n+            setFuelCost(4.0f),\n+            transparentScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(8.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"nameScope:\\n\",\n+            setFuelCost(16.0f),\n+            nameScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(32.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"hashtagScope:\\n\",\n+            setFuelCost(64.0f),\n+            hashtagScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(128.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken(),\n+\n+            \"setFuelCostScope:\\n\",\n+            setFuelCost(256.0f),\n+            setFuelCostScope(\n+                readFuelTemplate.asToken(),\n+                setFuelCost(512.0f),\n+                readFuelTemplate.asToken()\n+            ),\n+            readFuelTemplate.asToken()\n+        ));\n+\n+        String code = template.render(1000.0f);\n+        String expected =\n+            \"\"\"\n+            {1000.0f}\n+            <990.0f>\n+            scope:\n+            <999.0f>\n+            <998.0f>\n+            <999.0f>\n+            transparentScope:\n+            <996.0f>\n+            <992.0f>\n+            <992.0f>\n+            nameScope:\n+            <984.0f>\n+            <968.0f>\n+            <968.0f>\n+            hashtagScope:\n+            <936.0f>\n+            <872.0f>\n+            <872.0f>\n+            setFuelCostScope:\n+            <744.0f>\n+            <488.0f>\n+            <744.0f>\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames0a() {\n+        var template = Template.make(() -> scope(\n+            \/\/ When a DataName is added, it is immediately available afterwards.\n+            \/\/ This may seem trivial, but it requires that either both \"add\" and\n+            \/\/ \"sample\" happen in lambda execution, or in token evaluation.\n+            \/\/ Otherwise, one can float above the other, and lead to unintuitive\n+            \/\/ behavior.\n+            addDataName(\"x\", myInt, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"v\"),\n+            \"sample: #v.\"\n+        ));\n+\n+        String code = template.render();\n+        checkEQ(code, \"sample: x.\");\n+    }\n+\n+    public static void testDataNames0b() {\n+        \/\/ Test that the scope keeps local DataNames only for the scope, but that\n+        \/\/ we can see DataNames of outer scopes.\n+        var template = Template.make(() -> scope(\n+            \/\/ Outer scope DataName:\n+            addDataName(\"outerInt\", myInt, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).sample((DataName dn) -> scope(\n+                let(\"name1\", dn.name()),\n+                \"sample: #name1.\\n\",\n+                \/\/ We can also see the outer DataName:\n+                dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"name2\"),\n+                \"sample: #name2.\\n\",\n+                \/\/ Local DataName:\n+                addDataName(\"innerLong\", myLong, MUTABLE),\n+                dataNames(MUTABLE).exactOf(myLong).sampleAndLetAs(\"name3\"),\n+                \"sample: #name3.\\n\"\n+            )),\n+            \/\/ We can still see the outer scope DataName:\n+            dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"name4\"),\n+            \"sample: #name4.\\n\",\n+            \/\/ But we cannot see the DataNames that are local to the inner scope.\n+            \/\/ So here, we will always see \"outerLong\", and never \"innerLong\".\n+            addDataName(\"outerLong\", myLong, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myLong).sampleAndLetAs(\"name5\"),\n+            \"sample: #name5.\\n\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            sample: outerInt.\n+            sample: outerInt.\n+            sample: innerLong.\n+            sample: outerInt.\n+            sample: outerLong.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames0c() {\n+        \/\/ Test that hashtag replacements that are local to inner scopes are\n+        \/\/ only visible to inner scopes, but dollar replacements are the same\n+        \/\/ for the whole Template.\n+        var template = Template.make(() -> scope(\n+            let(\"global\", \"GLOBAL\"),\n+            \"g: #global. $a\\n\",\n+            \/\/ Create a dummy DataName so we don't get an exception from sample.\n+            addDataName(\"x\", myInt, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).sample((DataName dn) -> scope(\n+                \"g: #global. $b\\n\",\n+                let(\"local\", \"LOCAL1\"),\n+                \"l: #local. $c\\n\"\n+            )),\n+            \"g: #global. $d\\n\",\n+            \/\/ Open the scope again just to see if we can create the local again there.\n+            dataNames(MUTABLE).exactOf(myInt).sample((DataName dn) -> scope(\n+                \"g: #global. $e\\n\",\n+                let(\"local\", \"LOCAL2\"),\n+                \"l: #local. $f\\n\"\n+            )),\n+            \/\/ We can now use the \"local\" hashtag replacement again, since it\n+            \/\/ was previously only defined in an inner scope.\n+            let(\"local\", \"LOCAL3\"),\n+            \"g: #global. $g\\n\",\n+            \"l: #local. $h\\n\"\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            g: GLOBAL. a_1\n+            g: GLOBAL. b_1\n+            l: LOCAL1. c_1\n+            g: GLOBAL. d_1\n+            g: GLOBAL. e_1\n+            l: LOCAL2. f_1\n+            g: GLOBAL. g_1\n+            l: LOCAL3. h_1\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testDataNames0d() {\n+        var template = Template.make(() -> scope(\n+            addDataName(\"x\", myInt, MUTABLE),\n+            addDataName(\"y\", myInt, MUTABLE),\n+            addDataName(\"z\", myInt, MUTABLE),\n+            addDataName(\"a\", myLong, MUTABLE),\n+            addDataName(\"b\", myLong, MUTABLE),\n+            addDataName(\"c\", myLong, MUTABLE),\n+            dataNames(MUTABLE).exactOf(myInt).forEach((DataName dn) -> scope(\n+                let(\"name\", dn.name()),\n+                let(\"type\", dn.type()),\n+                \"listI: #name #type.\\n\"\n+            )),\n+            dataNames(MUTABLE).exactOf(myLong).forEach((DataName dn) -> scope(\n+                let(\"name\", dn.name()),\n+                let(\"type\", dn.type()),\n+                \"listL: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            listI: x int.\n+            listI: y int.\n+            listI: z int.\n+            listL: a long.\n+            listL: b long.\n+            listL: c long.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n@@ -1008,1 +1364,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1010,1 +1366,1 @@\n-            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).hasAny(),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).hasAny(h -> scope(h)),\n@@ -1012,1 +1368,1 @@\n-            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).count(c -> scope(c)),\n@@ -1014,1 +1370,3 @@\n-            String.join(\", \", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1018,2 +1376,3 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n-            addDataName(name, type, MUTABLE),\n+        \/\/ Note: the scope of the template must be transparentScope, so that the addDataName can escape.\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> transparentScope(\n+            addDataName(name, type, MUTABLE), \/\/ escapes\n@@ -1024,1 +1383,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -1031,1 +1390,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1034,1 +1393,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1037,1 +1396,1 @@\n-                template3.asToken(),\n+                template3.asToken(), \/\/ name_4 is inserted to hook1\n@@ -1041,1 +1400,1 @@\n-                template2.asToken($(\"name\"), myInt),\n+                template2.asToken($(\"name\"), myInt), \/\/ name_1 escapes\n@@ -1043,0 +1402,10 @@\n+                template1.asToken(),\n+                \"extra\\n\",\n+                hook1.insert(scope(\n+                    addDataName($(\"extra1\"), myInt, MUTABLE), \/\/ does not escape\n+                    \"$extra1 = 666\\n\"\n+                )),\n+                hook1.insert(transparentScope(\n+                    addDataName($(\"extra2\"), myInt, MUTABLE), \/\/ escapes\n+                    \"$extra2 = 42\\n\"\n+                )),\n@@ -1044,1 +1413,3 @@\n-            ),\n+            )),\n+            \/\/ But no names escape to down here, because the anchor scope is \"scope\".\n+            \"final:\\n\",\n@@ -1056,0 +1427,2 @@\n+            extra1_1 = 666\n+            extra2_1 = 42\n@@ -1067,1 +1440,4 @@\n-            [true, 1, names: {name_4}]\n+            [true, 2, names: {name_4, name_1}]\n+            extra\n+            [true, 3, names: {name_4, extra2_1, name_1}]\n+            final:\n@@ -1077,1 +1453,1 @@\n-        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> scope(\n@@ -1079,1 +1455,1 @@\n-            dataNames(mutability).exactOf(myInt).hasAny(),\n+            dataNames(mutability).exactOf(myInt).hasAny(h -> scope(h)),\n@@ -1081,1 +1457,1 @@\n-            dataNames(mutability).exactOf(myInt).count(),\n+            dataNames(mutability).exactOf(myInt).count(c -> scope(c)),\n@@ -1083,1 +1459,3 @@\n-            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            dataNames(mutability).exactOf(myInt).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1087,1 +1465,1 @@\n-        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1095,2 +1473,2 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n-            addDataName(name, type, MUTABLE),\n+        var template2 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> transparentScope(\n+            addDataName(name, type, MUTABLE), \/\/ escapes\n@@ -1101,2 +1479,2 @@\n-        var template3 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> body(\n-            addDataName(name, type, IMMUTABLE),\n+        var template3 = Template.make(\"name\", \"type\", (String name, DataName.Type type) -> transparentScope(\n+            addDataName(name, type, IMMUTABLE), \/\/ escapes\n@@ -1107,1 +1485,1 @@\n-        var template4 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template4 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1114,1 +1492,1 @@\n-        var template5 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template5 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1121,2 +1499,2 @@\n-        var template6 = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"v\", dataNames(MUTABLE).exactOf(type).sample().name()),\n+        var template6 = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE).exactOf(type).sampleAndLetAs(\"v\"),\n@@ -1128,2 +1506,2 @@\n-        var template7 = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"v\", dataNames(MUTABLE_OR_IMMUTABLE).exactOf(type).sample().name()),\n+        var template7 = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(type).sampleAndLetAs(\"v\"),\n@@ -1135,1 +1513,1 @@\n-        var template8 = Template.make(() -> body(\n+        var template8 = Template.make(() -> scope(\n@@ -1138,2 +1516,2 @@\n-            hook1.anchor(\n-                \"begin $body\\n\",\n+            hook1.anchor(scope(\n+                \"begin $scope\\n\",\n@@ -1151,1 +1529,1 @@\n-            ),\n+            )),\n@@ -1177,1 +1555,1 @@\n-            begin body_1\n+            begin scope_1\n@@ -1222,1 +1600,1 @@\n-        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> body(\n+        var template0 = Template.make(\"type\", \"mutability\", (DataName.Type type, DataName.Mutability mutability) -> scope(\n@@ -1224,1 +1602,1 @@\n-            dataNames(mutability).exactOf(myInt).hasAny(),\n+            dataNames(mutability).exactOf(myInt).hasAny(h -> scope(h)),\n@@ -1226,1 +1604,1 @@\n-            dataNames(mutability).exactOf(myInt).count(),\n+            dataNames(mutability).exactOf(myInt).count(c -> scope(c)),\n@@ -1228,1 +1606,3 @@\n-            String.join(\", \", dataNames(mutability).exactOf(myInt).toList().stream().map(DataName::name).toList()),\n+            dataNames(mutability).exactOf(myInt).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1232,1 +1612,1 @@\n-        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1240,1 +1620,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1243,2 +1623,2 @@\n-            hook1.anchor(\n-                \"begin $body\\n\",\n+            hook1.anchor(scope(\n+                \"begin $scope\\n\",\n@@ -1252,1 +1632,1 @@\n-            ),\n+            )),\n@@ -1266,1 +1646,1 @@\n-            begin body_1\n+            begin scope_1\n@@ -1297,1 +1677,1 @@\n-        var template1 = Template.make(\"type\", (DataName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (DataName.Type type) -> scope(\n@@ -1300,1 +1680,1 @@\n-            dataNames(MUTABLE).exactOf(type).hasAny(),\n+            dataNames(MUTABLE).exactOf(type).hasAny(h -> scope(h)),\n@@ -1302,1 +1682,1 @@\n-            dataNames(MUTABLE).exactOf(type).count(),\n+            dataNames(MUTABLE).exactOf(type).count(c -> scope(c)),\n@@ -1304,1 +1684,3 @@\n-            String.join(\", \", dataNames(MUTABLE).exactOf(type).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE).exactOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1307,1 +1689,1 @@\n-            dataNames(MUTABLE).subtypeOf(type).hasAny(),\n+            dataNames(MUTABLE).subtypeOf(type).hasAny(h -> scope(h)),\n@@ -1309,1 +1691,1 @@\n-            dataNames(MUTABLE).subtypeOf(type).count(),\n+            dataNames(MUTABLE).subtypeOf(type).count(c -> scope(c)),\n@@ -1311,1 +1693,4 @@\n-            String.join(\", \", dataNames(MUTABLE).subtypeOf(type).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE).subtypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n+\n@@ -1314,1 +1699,1 @@\n-            dataNames(MUTABLE).supertypeOf(type).hasAny(),\n+            dataNames(MUTABLE).supertypeOf(type).hasAny(h -> scope(h)),\n@@ -1316,1 +1701,1 @@\n-            dataNames(MUTABLE).supertypeOf(type).count(),\n+            dataNames(MUTABLE).supertypeOf(type).count(c -> scope(c)),\n@@ -1318,1 +1703,3 @@\n-            String.join(\", \", dataNames(MUTABLE).supertypeOf(type).toList().stream().map(DataName::name).toList()),\n+            dataNames(MUTABLE).supertypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(DataName::name).toList())\n+            )),\n@@ -1324,1 +1711,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1329,3 +1716,11 @@\n-        var template3 = Template.make(\"type\", (DataName.Type type) -> body(\n-            let(\"name\", dataNames(MUTABLE).subtypeOf(type).sample()),\n-            \"Sample #type: #name\\n\"\n+        var template3 = Template.make(\"type\", (DataName.Type type) -> scope(\n+            dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name1\"),\n+            \"Sample #type: #name1\\n\",\n+            dataNames(MUTABLE).subtypeOf(type).sampleAndLetAs(\"name2\", \"type2\"),\n+            \"Sample #type: #name2 #type2\\n\",\n+            dataNames(MUTABLE).subtypeOf(type).sample((DataName dn) -> scope(\n+                let(\"name3\", dn.name()),\n+                let(\"type3\", dn.type()),\n+                let(\"dn\", dn), \/\/ format the whole DataName with toString\n+                \"Sample #type: #name3 #type3 #dn\\n\"\n+            ))\n@@ -1334,1 +1729,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1337,1 +1732,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1348,1 +1743,1 @@\n-            ),\n+            )),\n@@ -1384,3 +1779,9 @@\n-            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA11: v1_1\n+            Sample myClassA11: v1_1 myClassA11\n+            Sample myClassA11: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: v1_1\n+            Sample myClassA1: v1_1 myClassA11\n+            Sample myClassA1: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA: v1_1\n+            Sample myClassA: v1_1 myClassA11\n+            Sample myClassA: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n@@ -1388,2 +1789,6 @@\n-            Sample myClassA11: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n-            Sample myClassA1: DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA11: v1_1\n+            Sample myClassA11: v1_1 myClassA11\n+            Sample myClassA11: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n+            Sample myClassA1: v1_1\n+            Sample myClassA1: v1_1 myClassA11\n+            Sample myClassA1: v1_1 myClassA11 DataName[name=v1_1, type=myClassA11, mutable=true, weight=1]\n@@ -1452,3 +1857,12 @@\n-        \/\/ It is safe in separate Hook scopes.\n-        var template1 = Template.make(() -> body(\n-            hook1.anchor(\n+        \/\/ It is safe in separate scopes.\n+        var template1 = Template.make(() -> scope(\n+            scope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ),\n+            scope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ),\n+            nameScope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ),\n+            nameScope(\n@@ -1457,1 +1871,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1459,1 +1873,4 @@\n-            )\n+            )),\n+            hook1.anchor(scope(\n+                addDataName(\"name1\", myInt, MUTABLE)\n+            ))\n@@ -1463,1 +1880,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1466,1 +1883,1 @@\n-        var template3 = Template.make(() -> body(\n+        var template3 = Template.make(() -> scope(\n@@ -1471,1 +1888,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1478,1 +1895,1 @@\n-            hook2.anchor(\n+            hook2.anchor(scope(\n@@ -1484,1 +1901,1 @@\n-            )\n+            ))\n@@ -1486,2 +1903,2 @@\n-        var template5 = Template.make(() -> body(\n-            hook1.anchor(\n+        var template5 = Template.make(() -> scope(\n+            hook1.anchor(scope(\n@@ -1490,1 +1907,1 @@\n-            )\n+            ))\n@@ -1494,1 +1911,1 @@\n-        var template6 = Template.make(() -> body(\n+        var template6 = Template.make(() -> scope(\n@@ -1505,0 +1922,91 @@\n+    public static void testDataNames6() {\n+        var template = Template.make(() -> scope(\n+            addDataName(\"x\", myInt, IMMUTABLE),\n+            \"int x = 5;\\n\",\n+            \/\/ A DataName can be captured, and used to define a new one with the same type.\n+            \/\/ It is important that the new DataName can escape the hashtagScope, so we have\n+            \/\/ access to it later.\n+            \/\/ Using \"scope\", it does not escape.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> scope(\n+                addDataName(\"a\", dn.type(), MUTABLE),\n+                let(\"v1\", \"a\"),\n+                \"int #v1 = x + 1;\\n\"\n+            )),\n+            \/\/ Using \"transparentScope\", it is available.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> transparentScope(\n+                addDataName(\"b\", dn.type(), MUTABLE),\n+                let(\"v2\", \"b\"),\n+                \"int #v2 = x + 2;\\n\"\n+            )),\n+            \/\/ Using \"nameScope\", it does not escape.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> nameScope(\n+                addDataName(\"c\", dn.type(), MUTABLE),\n+                let(\"v3\", \"c\"),\n+                \"int #v3 = x + 3;\\n\"\n+            )),\n+            \/\/ Using \"hashtagScope\", it is available.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> hashtagScope(\n+                addDataName(\"d\", dn.type(), MUTABLE),\n+                let(\"v4\", \"d\"),\n+                \"int #v4 = x + 4;\\n\"\n+            )),\n+            \/\/ Using \"setFuelCostScope\", it is available.\n+            dataNames(IMMUTABLE).exactOf(myInt).sample(dn -> setFuelCostScope(\n+                addDataName(\"e\", dn.type(), MUTABLE),\n+                let(\"v5\", \"e\"),\n+                \"int #v5 = x + 5;\\n\"\n+            )),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).forEach(\"name\", \"type\", dn -> scope(\n+                \"available1: #name #type.\\n\"\n+            )),\n+            dataNames(MUTABLE_OR_IMMUTABLE).exactOf(myInt).forEach(\"name\", \"type\", dn -> hashtagScope(\n+                \"available2: #name #type.\\n\"\n+            )),\n+            \/\/ Check that hashtags escape correctly too.\n+            \"hashtag v2: #v2.\\n\",\n+            \"hashtag v3: #v3.\\n\",\n+            \"hashtag v5: #v5.\\n\",\n+            let(\"v1\", \"aaa\"),\n+            let(\"v4\", \"ddd\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            int x = 5;\n+            int a = x + 1;\n+            int b = x + 2;\n+            int c = x + 3;\n+            int d = x + 4;\n+            int e = x + 5;\n+            available1: x int.\n+            available1: b int.\n+            available1: d int.\n+            available1: e int.\n+            available2: x int.\n+            available2: b int.\n+            available2: d int.\n+            available2: e int.\n+            hashtag v2: b.\n+            hashtag v3: c.\n+            hashtag v5: e.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames0() {\n+        var template = Template.make(() -> scope(\n+            \/\/ When a StructuralName is added, it is immediately available afterwards.\n+            \/\/ This may seem trivial, but it requires that either both \"add\" and\n+            \/\/ \"sample\" happen in lambda execution, or in token evaluation.\n+            \/\/ Otherwise, one can float above the other, and lead to unintuitive\n+            \/\/ behavior.\n+            addStructuralName(\"x\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).sampleAndLetAs(\"v\"),\n+            \"sample: #v.\"\n+        ));\n+\n+        String code = template.render();\n+        checkEQ(code, \"sample: x.\");\n+    }\n+\n@@ -1508,1 +2016,1 @@\n-        var template1 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n@@ -1511,1 +2019,1 @@\n-            structuralNames().exactOf(type).hasAny(),\n+            structuralNames().exactOf(type).hasAny(h -> scope(h)),\n@@ -1513,1 +2021,1 @@\n-            structuralNames().exactOf(type).count(),\n+            structuralNames().exactOf(type).count(c -> scope(c)),\n@@ -1515,1 +2023,3 @@\n-            String.join(\", \", structuralNames().exactOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().exactOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1518,1 +2028,1 @@\n-            structuralNames().subtypeOf(type).hasAny(),\n+            structuralNames().subtypeOf(type).hasAny(h -> scope(h)),\n@@ -1520,1 +2030,1 @@\n-            structuralNames().subtypeOf(type).count(),\n+            structuralNames().subtypeOf(type).count(c -> scope(c)),\n@@ -1522,1 +2032,3 @@\n-            String.join(\", \", structuralNames().subtypeOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().subtypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1525,1 +2037,1 @@\n-            structuralNames().supertypeOf(type).hasAny(),\n+            structuralNames().supertypeOf(type).hasAny(h -> scope(h)),\n@@ -1527,1 +2039,1 @@\n-            structuralNames().supertypeOf(type).count(),\n+            structuralNames().supertypeOf(type).count(c -> scope(c)),\n@@ -1529,1 +2041,3 @@\n-            String.join(\", \", structuralNames().supertypeOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().supertypeOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1539,1 +2053,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1544,3 +2058,11 @@\n-        var template3 = Template.make(\"type\", (StructuralName.Type type) -> body(\n-            let(\"name\", structuralNames().subtypeOf(type).sample()),\n-            \"Sample #type: #name\\n\"\n+        var template3 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n+            structuralNames().subtypeOf(type).sampleAndLetAs(\"name1\"),\n+            \"Sample #type: #name1\\n\",\n+            structuralNames().subtypeOf(type).sampleAndLetAs(\"name2\", \"type2\"),\n+            \"Sample #type: #name2 #type2\\n\",\n+            structuralNames().subtypeOf(type).sample((StructuralName sn) -> scope(\n+                let(\"name3\", sn.name()),\n+                let(\"type3\", sn.type()),\n+                let(\"sn\", sn), \/\/ format the whole StructuralName with toString\n+                \"Sample #type: #name3 #type3 #sn\\n\"\n+            ))\n@@ -1549,1 +2071,1 @@\n-        var template4 = Template.make(() -> body(\n+        var template4 = Template.make(() -> scope(\n@@ -1552,1 +2074,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -1563,1 +2085,1 @@\n-            ),\n+            )),\n@@ -1599,3 +2121,9 @@\n-            Sample StructuralA11: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n-            Sample StructuralA1: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n-            Sample StructuralA: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA11: v1_1\n+            Sample StructuralA11: v1_1 StructuralA11\n+            Sample StructuralA11: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA1: v1_1\n+            Sample StructuralA1: v1_1 StructuralA11\n+            Sample StructuralA1: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA: v1_1\n+            Sample StructuralA: v1_1 StructuralA11\n+            Sample StructuralA: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n@@ -1603,2 +2131,6 @@\n-            Sample StructuralA11: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n-            Sample StructuralA1: StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA11: v1_1\n+            Sample StructuralA11: v1_1 StructuralA11\n+            Sample StructuralA11: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n+            Sample StructuralA1: v1_1\n+            Sample StructuralA1: v1_1 StructuralA11\n+            Sample StructuralA1: v1_1 StructuralA11 StructuralName[name=v1_1, type=StructuralA11, weight=1]\n@@ -1665,1 +2197,1 @@\n-        var template1 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+        var template1 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n@@ -1667,1 +2199,1 @@\n-            structuralNames().exactOf(type).hasAny(),\n+            structuralNames().exactOf(type).hasAny(h -> scope(h)),\n@@ -1669,1 +2201,1 @@\n-            structuralNames().exactOf(type).count(),\n+            structuralNames().exactOf(type).count(c -> scope(c)),\n@@ -1671,1 +2203,3 @@\n-            String.join(\", \", structuralNames().exactOf(type).toList().stream().map(StructuralName::name).toList()),\n+            structuralNames().exactOf(type).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n@@ -1675,2 +2209,2 @@\n-        var template2 = Template.make(\"name\", \"type\", (String name, StructuralName.Type type) -> body(\n-            addStructuralName(name, type),\n+        var template2 = Template.make(\"name\", \"type\", (String name, StructuralName.Type type) -> transparentScope(\n+            addStructuralName(name, type), \/\/ escapes\n@@ -1680,1 +2214,1 @@\n-        var template3 = Template.make(\"type\", (StructuralName.Type type) -> body(\n+        var template3 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n@@ -1687,2 +2221,2 @@\n-        var template4 = Template.make(\"type\", (StructuralName.Type type) -> body(\n-            let(\"v\", structuralNames().exactOf(type).sample().name()),\n+        var template4 = Template.make(\"type\", (StructuralName.Type type) -> scope(\n+            structuralNames().exactOf(type).sampleAndLetAs(\"v\"),\n@@ -1694,1 +2228,1 @@\n-        var template8 = Template.make(() -> body(\n+        var template8 = Template.make(() -> scope(\n@@ -1698,2 +2232,2 @@\n-            hook1.anchor(\n-                \"begin $body\\n\",\n+            hook1.anchor(scope(\n+                \"begin $scope\\n\",\n@@ -1714,1 +2248,1 @@\n-            ),\n+            )),\n@@ -1728,1 +2262,1 @@\n-            begin body_1\n+            begin scope_1\n@@ -1758,0 +2292,253 @@\n+    public static void testStructuralNames3() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> scope(\n+                let(\"name1\", sn.name()),\n+                \"sn1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> nameScope(\n+                \/\/ We cannot use \"let\" here (at least not easily), otherwise we get\n+                \/\/ a duplicate hashtag replacement. It would probably be better style\n+                \/\/ to use a \"let\", but we are just checking that \"nameScope\" works\n+                \/\/ for reuse of names.\n+                \"sn2: \",  sn.name(), \".\\n\",\n+                \/\/ But for testing, we still do a \"let\", just with different key.\n+                \/\/ (This is probably bad practice, we just do this for testing)\n+                let(\"name2_\" + sn.name(), sn.name()),\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> transparentScope(\n+                \/\/ Same issue with hashtags as with \"nameScope\".\n+                \"sn3: \",  sn.name(), \".\\n\",\n+                let(\"name3_\" + sn.name(), sn.name()),\n+                \/\/ Using the same name for each would lead to duplicates,\n+                \/\/ so we have to modify the name here.\n+                addStructuralName(\"x_\" + sn.name(), myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> hashtagScope(\n+                let(\"name4\", sn.name()),\n+                \"sn4: #name4.\\n\",\n+                \/\/ Same issue with duplicate names as with \"transparentScope\".\n+                addStructuralName(\"y_\" + sn.name(), myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> setFuelCostScope(\n+                \/\/ Same issue with hashtags as with \"nameScope\".\n+                \"sn5: \",  sn.name(), \".\\n\",\n+                let(\"name5_\" + sn.name(), sn.name()),\n+                \/\/ Same issue with duplicate names as with \"transparentScope\".\n+                addStructuralName(\"z_\" + sn.name(), myStructuralTypeA)\n+            )),\n+            \"sn2: #name2_a #name2_b.\\n\", \/\/ hashtags escaped\n+            \"sn3: #name3_a #name3_b.\\n\", \/\/ hashtags escaped\n+            \"sn5: #name5_a #name5_b #name5_x_a #name5_x_b.\\n\", \/\/ hashtags escaped\n+            let(\"name1\", \"shouldBeOK1\"), \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\")  \/\/ hashtag did not escape\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            sn1: a.\n+            sn1: b.\n+            sn2: a.\n+            sn2: b.\n+            sn3: a.\n+            sn3: b.\n+            sn4: a.\n+            sn4: b.\n+            sn4: x_a.\n+            sn4: x_b.\n+            sn5: a.\n+            sn5: b.\n+            sn5: x_a.\n+            sn5: x_b.\n+            sn5: y_a.\n+            sn5: y_b.\n+            sn5: y_x_a.\n+            sn5: y_x_b.\n+            sn2: a b.\n+            sn3: a b.\n+            sn5: a b x_a x_b.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames4() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                let(\"name1\", list.size()),\n+                \"list1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> nameScope(\n+                let(\"name2\", list.size()),\n+                \"list2: #name2.\\n\",\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> transparentScope(\n+                let(\"name3\", list.size()),\n+                \"list3: #name3.\\n\",\n+                addStructuralName(\"x\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> hashtagScope(\n+                let(\"name4\", list.size()),\n+                \"list4: #name4.\\n\",\n+                addStructuralName(\"y\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> setFuelCostScope(\n+                let(\"name5\", list.size()),\n+                \"list5: #name5.\\n\",\n+                addStructuralName(\"z\", myStructuralTypeA)\n+            )),\n+            \"list2: #name2.\\n\", \/\/ hashtag escaped\n+            \"list3: #name3.\\n\", \/\/ hashtag escaped\n+            \"list5: #name5.\\n\", \/\/ hashtag escaped\n+            let(\"name1\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            structuralNames().exactOf(myStructuralTypeA).forEach(\"name\", \"type\", sn -> scope(\n+                \"available: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            list1: 2.\n+            list2: 2.\n+            list3: 2.\n+            list4: 3.\n+            list5: 4.\n+            list2: 2.\n+            list3: 2.\n+            list5: 4.\n+            available: a StructuralA.\n+            available: b StructuralA.\n+            available: x StructuralA.\n+            available: y StructuralA.\n+            available: z StructuralA.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames5() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> scope(\n+                let(\"name1\", c),\n+                \"list1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> nameScope(\n+                let(\"name2\", c),\n+                \"list2: #name2.\\n\",\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> transparentScope(\n+                let(\"name3\", c),\n+                \"list3: #name3.\\n\",\n+                addStructuralName(\"x\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> hashtagScope(\n+                let(\"name4\", c),\n+                \"list4: #name4.\\n\",\n+                addStructuralName(\"y\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).count(c -> setFuelCostScope(\n+                let(\"name5\", c),\n+                \"list5: #name5.\\n\",\n+                addStructuralName(\"z\", myStructuralTypeA)\n+            )),\n+            \"list2: #name2.\\n\", \/\/ hashtag escaped\n+            \"list3: #name3.\\n\", \/\/ hashtag escaped\n+            \"list5: #name5.\\n\", \/\/ hashtag escaped\n+            let(\"name1\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            structuralNames().exactOf(myStructuralTypeA).forEach(\"name\", \"type\", sn -> scope(\n+                \"available: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            list1: 2.\n+            list2: 2.\n+            list3: 2.\n+            list4: 3.\n+            list5: 4.\n+            list2: 2.\n+            list3: 2.\n+            list5: 4.\n+            available: a StructuralA.\n+            available: b StructuralA.\n+            available: x StructuralA.\n+            available: y StructuralA.\n+            available: z StructuralA.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testStructuralNames6() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> scope(\n+                let(\"name1\", h),\n+                \"list1: #name1.\\n\",\n+                addStructuralName(\"scope_garbage1\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> nameScope(\n+                let(\"name2\", h),\n+                \"list2: #name2.\\n\",\n+                addStructuralName(\"scope_garbage2\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> transparentScope(\n+                let(\"name3\", h),\n+                \"list3: #name3.\\n\",\n+                addStructuralName(\"x\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> hashtagScope(\n+                let(\"name4\", h),\n+                \"list4: #name4.\\n\",\n+                addStructuralName(\"y\", myStructuralTypeA)\n+            )),\n+            structuralNames().exactOf(myStructuralTypeA).hasAny(h -> setFuelCostScope(\n+                let(\"name5\", h),\n+                \"list5: #name5.\\n\",\n+                addStructuralName(\"z\", myStructuralTypeA)\n+            )),\n+            \"list2: #name2.\\n\", \/\/ hashtag escaped\n+            \"list3: #name3.\\n\", \/\/ hashtag escaped\n+            \"list5: #name5.\\n\", \/\/ hashtag escaped\n+            let(\"name1\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            let(\"name4\", \"shouldBeOk4\"),  \/\/ hashtag did not escape\n+            structuralNames().exactOf(myStructuralTypeA).forEach(\"name\", \"type\", sn -> scope(\n+                \"available: #name #type.\\n\"\n+            ))\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            list1: true.\n+            list2: true.\n+            list3: true.\n+            list4: true.\n+            list5: true.\n+            list2: true.\n+            list3: true.\n+            list5: true.\n+            available: a StructuralA.\n+            available: b StructuralA.\n+            available: x StructuralA.\n+            available: y StructuralA.\n+            available: z StructuralA.\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -1761,1 +2548,1 @@\n-        var template1 = Template.make(\"item\", (MyItem item) -> body(\n+        var template1 = Template.make(\"item\", (MyItem item) -> scope(\n@@ -1767,1 +2554,1 @@\n-        var template2 = Template.make(\"list\", (List<MyItem> list) -> body(\n+        var template2 = Template.make(\"list\", (List<MyItem> list) -> scope(\n@@ -1800,0 +2587,734 @@\n+    public static void testNestedScopes1() {\n+        var listDataNames = Template.make(() -> scope(\n+            \"dataNames: {\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"name\", \"type\", (DataName dn) -> scope(\n+                \"#name #type; \"\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(\"x\", (String x) -> scope(\n+            \"$start\\n\",\n+            addDataName(\"vx\", myInt, MUTABLE),\n+            \"x: #x.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"transparentScope\" nesting essencially does nothing but create\n+            \/\/ a list of tokens. It passes through names and hashtags.\n+            \"open transparentScope:\\n\",\n+            transparentScope(\n+                \"$transparentScope\\n\",\n+                let(\"y\", \"YYY\"),\n+                addDataName(\"vy\", myInt, MUTABLE),\n+                \"x: #x.\\n\",\n+                \"y: #y.\\n\",\n+                listDataNames.asToken()\n+            ),\n+            \"close transparentScope.\\n\",\n+            \"x: #x.\\n\",\n+            \"y: #y.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"hashtagScope\" nesting makes hashtags local, but names\n+            \/\/ escape the nesting.\n+            \"open hashtagScope:\\n\",\n+            hashtagScope(\n+                \"$hashtagScope\\n\",\n+                let(\"z\", \"ZZZ1\"),\n+                \"z: #z.\\n\",\n+                addDataName(\"vz\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close hashtagScope.\\n\",\n+            let(\"z\", \"ZZZ2\"), \/\/ we can define it again outside.\n+            \"z: #z.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ We can also use hashtagScopes for loops.\n+            List.of(\"a\", \"b\", \"c\").stream().map(str -> hashtagScope(\n+                \"$hashtagScope\\n\",\n+                let(\"str\", str), \/\/ the hashtag is local to every element\n+                \"str: #str.\\n\",\n+                addDataName(\"v_\" + str, myInt, MUTABLE),\n+                listDataNames.asToken()\n+            )).toList(),\n+            \"finish str list.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"nameScope\" nesting makes names local, but hashtags\n+            \/\/ escape the nesting.\n+            \"open nameScope:\\n\",\n+            nameScope(\n+                \"$nameScope\\n\",\n+                let(\"p\", \"PPP\"),\n+                \"p: #p.\\n\",\n+                addDataName(\"vp\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close hashtagScope.\\n\",\n+            \"p: #p.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"scope\" nesting makes names and hashtags local\n+            \"open scope:\\n\",\n+            scope(\n+                \"$scope\\n\",\n+                let(\"q\", \"QQQ1\"),\n+                \"q: #q.\\n\",\n+                addDataName(\"vq\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close scope.\\n\",\n+            let(\"q\", \"QQQ2\"),\n+            \"q: #q.\\n\",\n+            listDataNames.asToken(),\n+            \/\/ A \"setFuelCostScope\" nesting behaves the same as \"transparentScope\", as we are not using fuel here.\n+            \"open setFuelCostScope:\\n\",\n+            setFuelCostScope(\n+                \"$setFuelCostScope\\n\",\n+                let(\"r\", \"RRR\"),\n+                \"r: #r.\\n\",\n+                addDataName(\"vr\", myInt, MUTABLE),\n+                listDataNames.asToken()\n+            ),\n+            \"close setFuelCostScope.\\n\",\n+            \"r: #r.\\n\",\n+            listDataNames.asToken()\n+\n+        ));\n+\n+        String code = template.render(\"XXX\");\n+        String expected =\n+            \"\"\"\n+            start_1\n+            x: XXX.\n+            dataNames: {vx int; }\n+            open transparentScope:\n+            transparentScope_1\n+            x: XXX.\n+            y: YYY.\n+            dataNames: {vx int; vy int; }\n+            close transparentScope.\n+            x: XXX.\n+            y: YYY.\n+            dataNames: {vx int; vy int; }\n+            open hashtagScope:\n+            hashtagScope_1\n+            z: ZZZ1.\n+            dataNames: {vx int; vy int; vz int; }\n+            close hashtagScope.\n+            z: ZZZ2.\n+            dataNames: {vx int; vy int; vz int; }\n+            hashtagScope_1\n+            str: a.\n+            dataNames: {vx int; vy int; vz int; v_a int; }\n+            hashtagScope_1\n+            str: b.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; }\n+            hashtagScope_1\n+            str: c.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            finish str list.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            open nameScope:\n+            nameScope_1\n+            p: PPP.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vp int; }\n+            close hashtagScope.\n+            p: PPP.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            open scope:\n+            scope_1\n+            q: QQQ1.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vq int; }\n+            close scope.\n+            q: QQQ2.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; }\n+            open setFuelCostScope:\n+            setFuelCostScope_1\n+            r: RRR.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vr int; }\n+            close setFuelCostScope.\n+            r: RRR.\n+            dataNames: {vx int; vy int; vz int; v_a int; v_b int; v_c int; vr int; }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testNestedScopes2() {\n+        var listDataNames = Template.make(() -> scope(\n+            \"dataNames: {\",\n+            dataNames(MUTABLE).exactOf(myInt).forEach(\"name\", \"type\", (DataName dn) -> scope(\n+                \"#name #type; \"\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \/\/ Define some global variables.\n+            List.of(\"a\", \"b\", \"c\").stream().map(str -> hashtagScope(\n+                let(\"var\", \"g_\" + str),\n+                addDataName(\"g_\" + str, myInt, MUTABLE),\n+                \"def global #var.\\n\"\n+            )).toList(),\n+            listDataNames.asToken(),\n+            scope(\n+                \"open scope:\\n\",\n+                \/\/ Define some variables.\n+                List.of(\"i\", \"j\", \"k\").stream().map(str -> hashtagScope(\n+                    let(\"var\", \"v_\" + str),\n+                    addDataName(\"v_\" + str, myInt, MUTABLE),\n+                    \"def #var.\\n\"\n+                )).toList(),\n+                listDataNames.asToken(),\n+                scope(\n+                    \"open inner scope:\\n\",\n+                    addDataName(\"v_local\", myInt, MUTABLE),\n+                    \"def v_local.\\n\",\n+                    listDataNames.asToken(),\n+                    \"close inner scope.\\n\"\n+                ),\n+                listDataNames.asToken(),\n+                \"close scope.\\n\"\n+            ),\n+            listDataNames.asToken()\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            def global g_a.\n+            def global g_b.\n+            def global g_c.\n+            dataNames: {g_a int; g_b int; g_c int; }\n+            open scope:\n+            def v_i.\n+            def v_j.\n+            def v_k.\n+            dataNames: {g_a int; g_b int; g_c int; v_i int; v_j int; v_k int; }\n+            open inner scope:\n+            def v_local.\n+            dataNames: {g_a int; g_b int; g_c int; v_i int; v_j int; v_k int; v_local int; }\n+            close inner scope.\n+            dataNames: {g_a int; g_b int; g_c int; v_i int; v_j int; v_k int; }\n+            close scope.\n+            dataNames: {g_a int; g_b int; g_c int; }\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testTemplateScopes() {\n+        var statusTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\",\n+            let(\"fuel\", fuel()),\n+            \"fuel: #fuel\\n\"\n+        ));\n+\n+        var scopeTemplate = Template.make(() -> scope(\n+            \"scope:\\n\",\n+            let(\"local\", \"inner scope\"),\n+            addStructuralName(\"x\", myStructuralTypeA),\n+            statusTemplate.asToken(),\n+            setFuelCost(50)\n+        ));\n+\n+        var transparentScopeTemplate = Template.make(() -> transparentScope(\n+            \"transparentScope:\\n\",\n+            let(\"local\", \"inner flag\"),\n+            addStructuralName(\"y\", myStructuralTypeA), \/\/ should escape\n+            statusTemplate.asToken(),\n+            setFuelCost(50)\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            setFuelCost(1),\n+            let(\"local\", \"root\"),\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            statusTemplate.asToken(),\n+            scopeTemplate.asToken(),\n+            statusTemplate.asToken(),\n+            transparentScopeTemplate.asToken(),\n+            statusTemplate.asToken()\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            {a}\n+            fuel: 99.0f\n+            scope:\n+            {a, x}\n+            fuel: 89.0f\n+            {a}\n+            fuel: 99.0f\n+            transparentScope:\n+            {a, y}\n+            fuel: 89.0f\n+            {a, y}\n+            fuel: 99.0f\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookAndScopes1() {\n+        Hook hook1 = new Hook(\"Hook1\");\n+\n+        var listNamesTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var insertScopeTemplate = Template.make(\"name\", (String name) -> scope(\n+            let(\"local\", \"insert scope garbage\"),\n+            addStructuralName(name, myStructuralTypeA),\n+            \"inserted scope: #name\\n\",\n+            listNamesTemplate.asToken()\n+        ));\n+\n+        var insertTransparentScopeTemplate = Template.make(\"name\", (String name) -> transparentScope(\n+            let(\"local\", \"insert transparentScope garbage\"),\n+            addStructuralName(name, myStructuralTypeA),\n+            \"inserted transparentScope: #name\\n\",\n+            listNamesTemplate.asToken()\n+        ));\n+\n+        var probeTemplate = Template.make(() -> scope(\n+            \"inserted probe:\\n\",\n+            listNamesTemplate.asToken()\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \"scope:\\n\",\n+            hook1.anchor(scope(\n+                let(\"local\", \"scope garbage\"),\n+                addStructuralName(\"x1a\", myStructuralTypeA),\n+                \"scope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x1b\")),\n+                \"scope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"scope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x1c\")),\n+                \"scope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"scope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after scope:\\n\",\n+            listNamesTemplate.asToken(),\n+\n+            \"transparentScope:\\n\",\n+            hook1.anchor(transparentScope(\n+                let(\"transparentScope2\", \"abc\"),\n+                addStructuralName(\"x2a\", myStructuralTypeA),\n+                \"transparentScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x2b\")),\n+                \"transparentScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"transparentScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x2c\")),\n+                \"transparentScope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"transparentScope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after transparentScope:\\n\",\n+            listNamesTemplate.asToken(),\n+            \"transparentScope2: #transparentScope2\\n\",\n+\n+            \"hashtagScope:\\n\",\n+            hook1.anchor(hashtagScope(\n+                let(\"local\", \"hashtagScope garbage\"),\n+                addStructuralName(\"x3a\", myStructuralTypeA),\n+                \"hashtagScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x3b\")),\n+                \"hashtagScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"hashtagScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x3c\")),\n+                \"hashtagScope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"hashtagScope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after hashtagScope:\\n\",\n+            listNamesTemplate.asToken(),\n+\n+            \"nameScope:\\n\",\n+            hook1.anchor(nameScope(\n+                let(\"transparentScope4\", \"abcde\"),\n+                addStructuralName(\"x4a\", myStructuralTypeA),\n+                \"nameScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertScopeTemplate.asToken(\"x4b\")),\n+                \"nameScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"nameScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(insertTransparentScopeTemplate.asToken(\"x4c\")),\n+                \"nameScope after insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                \"nameScope insert probe.\\n\",\n+                hook1.insert(probeTemplate.asToken())\n+            )),\n+            \"after nameScope:\\n\",\n+            listNamesTemplate.asToken(),\n+            \"transparentScope4: #transparentScope4\\n\",\n+\n+            let(\"local\", \"outer garbage\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            scope:\n+            inserted scope: x1b\n+            {x1b}\n+            inserted transparentScope: x1c\n+            {x1c}\n+            inserted probe:\n+            {x1c}\n+            scope before insert scope:\n+            {x1a}\n+            scope after insert scope:\n+            {x1a}\n+            scope before insert transparentScope:\n+            {x1a}\n+            scope after insert transparentScope:\n+            {x1c, x1a}\n+            scope insert probe.\n+            after scope:\n+            {}\n+            transparentScope:\n+            inserted scope: x2b\n+            {x2a, x2b}\n+            inserted transparentScope: x2c\n+            {x2a, x2c}\n+            inserted probe:\n+            {x2a, x2c}\n+            transparentScope before insert scope:\n+            {x2a}\n+            transparentScope after insert scope:\n+            {x2a}\n+            transparentScope before insert transparentScope:\n+            {x2a}\n+            transparentScope after insert transparentScope:\n+            {x2a, x2c}\n+            transparentScope insert probe.\n+            after transparentScope:\n+            {x2a, x2c}\n+            transparentScope2: abc\n+            hashtagScope:\n+            inserted scope: x3b\n+            {x2a, x2c, x3a, x3b}\n+            inserted transparentScope: x3c\n+            {x2a, x2c, x3a, x3c}\n+            inserted probe:\n+            {x2a, x2c, x3a, x3c}\n+            hashtagScope before insert scope:\n+            {x2a, x2c, x3a}\n+            hashtagScope after insert scope:\n+            {x2a, x2c, x3a}\n+            hashtagScope before insert transparentScope:\n+            {x2a, x2c, x3a}\n+            hashtagScope after insert transparentScope:\n+            {x2a, x2c, x3a, x3c}\n+            hashtagScope insert probe.\n+            after hashtagScope:\n+            {x2a, x2c, x3a, x3c}\n+            nameScope:\n+            inserted scope: x4b\n+            {x2a, x2c, x3a, x3c, x4b}\n+            inserted transparentScope: x4c\n+            {x2a, x2c, x3a, x3c, x4c}\n+            inserted probe:\n+            {x2a, x2c, x3a, x3c, x4c}\n+            nameScope before insert scope:\n+            {x2a, x2c, x3a, x3c, x4a}\n+            nameScope after insert scope:\n+            {x2a, x2c, x3a, x3c, x4a}\n+            nameScope before insert transparentScope:\n+            {x2a, x2c, x3a, x3c, x4a}\n+            nameScope after insert transparentScope:\n+            {x2a, x2c, x3a, x3c, x4c, x4a}\n+            nameScope insert probe.\n+            after nameScope:\n+            {x2a, x2c, x3a, x3c}\n+            transparentScope4: abcde\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    public static void testHookAndScopes2() {\n+        Hook hook1 = new Hook(\"Hook1\");\n+\n+        var listNamesTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \"scope:\\n\",\n+            hook1.anchor(scope(\n+                let(\"local0\", \"scope garbage\"),\n+                let(\"local1\", \"LOCAL1\"),\n+                addStructuralName(\"x1a\", myStructuralTypeA),\n+\n+                \"scope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(scope(\n+                    let(\"local2\", \"insert scope garbage\"),\n+                    let(\"name\", \"x1b\"),\n+                    addStructuralName(\"x1b\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted scope: #name\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(transparentScope(\n+                    let(\"nameTransparentScope\", \"x1c\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1c\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted transparentScope: #nameTransparentScope\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert transparentScope:\\n\",\n+                \"nameTransparentScope: #nameTransparentScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope before insert nameScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(nameScope(\n+                    let(\"nameNameScope\", \"x1d\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1d\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted nameScope: #nameNameScope\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert nameScope:\\n\",\n+                \"nameNameScope: #nameNameScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope before insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(hashtagScope(\n+                    let(\"local2\", \"insert hashtagScope garbage\"),\n+                    let(\"name\", \"x1e\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1e\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted hashtagScope: #name\\n\",\n+                    \"local1: #local1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"scope after insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"scope insert probe.\\n\",\n+                hook1.insert(scope(\n+                    \"inserted probe:\\n\",\n+                    listNamesTemplate.asToken()\n+                ))\n+            )),\n+            \"after scope:\\n\",\n+            listNamesTemplate.asToken(),\n+\n+            let(\"name\", \"name garbage\"),\n+            let(\"local0\", \"outer garbage 0\"),\n+            let(\"local1\", \"outer garbage 1\"),\n+            let(\"local2\", \"outer garbage 2\"),\n+            let(\"nameTransparentScope\", \"outer garbage nameTransparentScope\"),\n+            let(\"nameNameScope\", \"outer garbage nameNameScope\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            scope:\n+            inserted scope: x1b\n+            local1: LOCAL1\n+            {x1b}\n+            inserted transparentScope: x1c\n+            local1: LOCAL1\n+            {x1c}\n+            inserted nameScope: x1d\n+            local1: LOCAL1\n+            {x1c, x1d}\n+            inserted hashtagScope: x1e\n+            local1: LOCAL1\n+            {x1c, x1e}\n+            inserted probe:\n+            {x1c, x1e}\n+            scope before insert scope:\n+            {x1a}\n+            scope after insert scope:\n+            {x1a}\n+            scope before insert transparentScope:\n+            {x1a}\n+            scope after insert transparentScope:\n+            nameTransparentScope: x1c\n+            {x1c, x1a}\n+            scope before insert nameScope:\n+            {x1c, x1a}\n+            scope after insert nameScope:\n+            nameNameScope: x1d\n+            {x1c, x1a}\n+            scope before insert hashtagScope:\n+            {x1c, x1a}\n+            scope after insert hashtagScope:\n+            {x1c, x1e, x1a}\n+            scope insert probe.\n+            after scope:\n+            {}\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n+    \/\/ Analogue to testHookAndScopes2, but with \"transparentScope\" instead of \"scope\".\n+    public static void testHookAndScopes3() {\n+        Hook hook1 = new Hook(\"Hook1\");\n+\n+        var listNamesTemplate = Template.make(() -> scope(\n+            \"{\",\n+            structuralNames().exactOf(myStructuralTypeA).toList(list -> scope(\n+                String.join(\", \", list.stream().map(StructuralName::name).toList())\n+            )),\n+            \"}\\n\"\n+        ));\n+\n+        var template = Template.make(() -> scope(\n+            \"transparentScope:\\n\",\n+            hook1.anchor(transparentScope(\n+                let(\"global0\", \"transparentScope garbage\"),\n+                let(\"global1\", \"GLOBAL1\"),\n+                addStructuralName(\"x1a\", myStructuralTypeA),\n+\n+                \"transparentScope before insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(scope(\n+                    let(\"local2\", \"insert scope garbage\"),\n+                    let(\"name\", \"x1b\"),\n+                    addStructuralName(\"x1b\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted scope: #name\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert scope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope before insert transparentScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(transparentScope(\n+                    let(\"nameTransparentScope\", \"x1c\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1c\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted transparentScope: #nameTransparentScope\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert transparentScope:\\n\",\n+                \"nameTransparentScope: #nameTransparentScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope before insert nameScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(nameScope(\n+                    let(\"nameNameScope\", \"x1d\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1d\", myStructuralTypeA), \/\/ does NOT escape to anchor scope\n+                    \"inserted nameScope: #nameNameScope\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert nameScope:\\n\",\n+                \"nameNameScope: #nameNameScope\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope before insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+                hook1.insert(hashtagScope(\n+                    let(\"local2\", \"insert hashtagScope garbage\"),\n+                    let(\"name\", \"x1e\"), \/\/ escapes to caller\n+                    addStructuralName(\"x1e\", myStructuralTypeA), \/\/ escapes to anchor scope\n+                    \"inserted hashtagScope: #name\\n\",\n+                    \"global1: #global1\\n\",\n+                    listNamesTemplate.asToken()\n+                )),\n+                \"transparentScope after insert hashtagScope:\\n\",\n+                listNamesTemplate.asToken(),\n+\n+                \"transparentScope insert probe.\\n\",\n+                hook1.insert(scope(\n+                    \"inserted probe:\\n\",\n+                    listNamesTemplate.asToken()\n+                ))\n+            )),\n+            \"after transparentScope:\\n\",\n+            listNamesTemplate.asToken(),\n+            \"\"\"\n+            global0: #global0\n+            global1: #global1\n+            nameTransparentScope: #nameTransparentScope\n+            nameNameScope: #nameNameScope\n+            \"\"\",\n+            let(\"name\", \"name garbage\"),\n+            let(\"local2\", \"outer garbage 2\")\n+        ));\n+\n+        String code = template.render();\n+        String expected =\n+            \"\"\"\n+            transparentScope:\n+            inserted scope: x1b\n+            global1: GLOBAL1\n+            {x1a, x1b}\n+            inserted transparentScope: x1c\n+            global1: GLOBAL1\n+            {x1a, x1c}\n+            inserted nameScope: x1d\n+            global1: GLOBAL1\n+            {x1a, x1c, x1d}\n+            inserted hashtagScope: x1e\n+            global1: GLOBAL1\n+            {x1a, x1c, x1e}\n+            inserted probe:\n+            {x1a, x1c, x1e}\n+            transparentScope before insert scope:\n+            {x1a}\n+            transparentScope after insert scope:\n+            {x1a}\n+            transparentScope before insert transparentScope:\n+            {x1a}\n+            transparentScope after insert transparentScope:\n+            nameTransparentScope: x1c\n+            {x1a, x1c}\n+            transparentScope before insert nameScope:\n+            {x1a, x1c}\n+            transparentScope after insert nameScope:\n+            nameNameScope: x1d\n+            {x1a, x1c}\n+            transparentScope before insert hashtagScope:\n+            {x1a, x1c}\n+            transparentScope after insert hashtagScope:\n+            {x1a, x1c, x1e}\n+            transparentScope insert probe.\n+            after transparentScope:\n+            {x1a, x1c, x1e}\n+            global0: transparentScope garbage\n+            global1: GLOBAL1\n+            nameTransparentScope: x1c\n+            nameNameScope: x1d\n+            \"\"\";\n+        checkEQ(code, expected);\n+    }\n+\n@@ -1801,1 +3322,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1805,1 +3326,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1816,1 +3337,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1823,1 +3344,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1830,1 +3351,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1837,1 +3358,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1844,1 +3365,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1851,1 +3372,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1858,1 +3379,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1865,1 +3386,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1872,1 +3393,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1880,1 +3401,1 @@\n-        var template1 = Template.make(\"\", (String x) -> body(\n+        var template1 = Template.make(\"\", (String x) -> scope(\n@@ -1887,1 +3408,1 @@\n-        var template1 = Template.make(\"abc#abc\", (String x) -> body(\n+        var template1 = Template.make(\"abc#abc\", (String x) -> scope(\n@@ -1893,1 +3414,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1901,1 +3422,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1909,1 +3430,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1916,1 +3437,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1923,1 +3444,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1930,1 +3451,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1937,1 +3458,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1944,1 +3465,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1951,1 +3472,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1958,1 +3479,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1967,1 +3488,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -1971,1 +3492,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -1981,4 +3502,4 @@\n-    public static void testFailingSample1() {\n-        var template1 = Template.make(() -> body(\n-            \/\/ No variable added yet.\n-            let(\"v\", dataNames(MUTABLE).exactOf(myInt).sample().name()),\n+    public static void testFailingSample1a() {\n+        var template1 = Template.make(() -> scope(\n+            \/\/ No DataName added yet.\n+            dataNames(MUTABLE).exactOf(myInt).sampleAndLetAs(\"v\"),\n@@ -1991,2 +3512,12 @@\n-    public static void testFailingSample2() {\n-        var template1 = Template.make(() -> body(\n+    public static void testFailingSample1b() {\n+        var template1 = Template.make(() -> scope(\n+            \/\/ No StructuralName added yet.\n+            structuralNames().exactOf(myStructuralTypeA).sampleAndLetAs(\"v\"),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingSample2a() {\n+        var template1 = Template.make(() -> scope(\n@@ -1994,1 +3525,11 @@\n-            let(\"v\", dataNames(MUTABLE).sample().name()),\n+            dataNames(MUTABLE).sampleAndLetAs(\"v\"),\n+            \"v is #v\\n\"\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n+    public static void testFailingSample2b() {\n+        var template1 = Template.make(() -> scope(\n+            \/\/ no type restriction\n+            structuralNames().sampleAndLetAs(\"v\"),\n@@ -2003,1 +3544,1 @@\n-        var template1 = Template.make(\"a\", \"a\", (String _, String _) -> body(\n+        var template1 = Template.make(\"a\", \"a\", (String _, String _) -> scope(\n@@ -2011,1 +3552,1 @@\n-        var template1 = Template.make(\"a\", (String _) -> body(\n+        var template1 = Template.make(\"a\", (String _) -> scope(\n@@ -2021,1 +3562,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2032,1 +3573,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2040,0 +3581,11 @@\n+    public static void testFailingHashtag5() {\n+        var template1 = Template.make(() -> scope(\n+            \"use before definition: #a\\n\",\n+            \/\/ let is a token, and is only evaluated after\n+            \/\/ the string above, and so the string above fails.\n+            let(\"a\", \"x\")\n+        ));\n+\n+        String code = template1.render();\n+    }\n+\n@@ -2042,1 +3594,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2052,1 +3604,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2062,1 +3614,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2070,1 +3622,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2078,1 +3630,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2086,1 +3638,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2094,1 +3646,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2102,1 +3654,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2110,1 +3662,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2119,1 +3671,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2128,1 +3680,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2137,1 +3689,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2146,1 +3698,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2155,1 +3707,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2164,1 +3716,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2167,1 +3719,1 @@\n-        var template2 = Template.make(() -> body(\n+        var template2 = Template.make(() -> scope(\n@@ -2178,1 +3730,1 @@\n-        var template1 = Template.make(() -> body(\n+        var template1 = Template.make(() -> scope(\n@@ -2180,1 +3732,1 @@\n-            hook1.anchor(\n+            hook1.anchor(scope(\n@@ -2182,1 +3734,1 @@\n-            )\n+            ))\n@@ -2191,2 +3743,2 @@\n-        var template1 = Template.make(() -> body(\n-            addDataName(\"name\", myInt, MUTABLE)\n+        var template1 = Template.make(() -> transparentScope(\n+            addDataName(\"name\", myInt, MUTABLE) \/\/ escapes\n@@ -2195,2 +3747,2 @@\n-        var template2 = Template.make(() -> body(\n-            hook1.anchor(\n+        var template2 = Template.make(() -> scope(\n+            hook1.anchor(scope(\n@@ -2199,1 +3751,1 @@\n-            )\n+            ))\n@@ -2204,0 +3756,75 @@\n+    public static void testFailingScope1() {\n+        var template = Template.make(() -> scope(\n+            transparentScope(\n+                let(\"x\", \"x1\") \/\/ escapes\n+            ),\n+            let(\"x\", \"x2\") \/\/ second definition\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope2() {\n+        var template = Template.make(() -> scope(\n+            nameScope(\n+                let(\"x\", \"x1\") \/\/ escapes\n+            ),\n+            let(\"x\", \"x2\") \/\/ second definition\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope3() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> transparentScope(\n+                let(\"x\", sn.name()) \/\/ leads to duplicate hashtag\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope4() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> nameScope(\n+                let(\"x\", sn.name()) \/\/ leads to duplicate hashtag\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope5() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> transparentScope(\n+                addStructuralName(\"x\", myStructuralTypeA) \/\/ leads to duplicate name\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope6() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> hashtagScope(\n+                addStructuralName(\"x\", myStructuralTypeA) \/\/ leads to duplicate name\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n+    public static void testFailingScope7() {\n+        var template = Template.make(() -> scope(\n+            addStructuralName(\"a\", myStructuralTypeA),\n+            addStructuralName(\"b\", myStructuralTypeA),\n+            structuralNames().exactOf(myStructuralTypeA).forEach(sn -> setFuelCostScope(\n+                addStructuralName(\"x\", myStructuralTypeA) \/\/ leads to duplicate name\n+            ))\n+        ));\n+        String code = template.render();\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/template_framework\/tests\/TestTemplate.java","additions":1917,"deletions":290,"binary":false,"changes":2207,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+#include <stdio.h>\n@@ -65,0 +66,3 @@\n+    printf(\"Test failed by setFailStatus(). See log.\");\n+    fflush(stdout);\n+    exit(97);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/agent_tools.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.spec.NamedParameterSpec;\n+\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_256_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE compliance test\n+ *\/\n+public class Compliance {\n+    public static void main(String[] args) throws Exception {\n+\n+        var kp = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(new byte[32], \"ONE\");\n+        var shortKey = new SecretKeySpec(new byte[31], \"ONE\");\n+        var psk_id = \"psk_id\".getBytes(StandardCharsets.UTF_8);\n+        var emptyKey = new SecretKey() {\n+            public String getAlgorithm() { return \"GENERIC\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return new byte[0]; }\n+        };\n+\n+        \/\/ HPKEParameterSpec\n+\n+        \/\/ A typical spec\n+        var spec = HPKEParameterSpec.of(\n+                KEM_DHKEM_X25519_HKDF_SHA256,\n+                KDF_HKDF_SHA256,\n+                AEAD_AES_256_GCM);\n+        Asserts.assertEQ(spec.kem_id(), KEM_DHKEM_X25519_HKDF_SHA256);\n+        Asserts.assertEQ(spec.kdf_id(), KDF_HKDF_SHA256);\n+        Asserts.assertEQ(spec.aead_id(), AEAD_AES_256_GCM);\n+        Asserts.assertEQ(spec.authKey(), null);\n+        Asserts.assertEQ(spec.encapsulation(), null);\n+        Asserts.assertEqualsByteArray(spec.info(), new byte[0]);\n+        Asserts.assertEQ(spec.psk(), null);\n+        Asserts.assertEqualsByteArray(spec.psk_id(), new byte[0]);\n+\n+        \/\/ A fake spec but still valid\n+        var specZero = HPKEParameterSpec.of(0, 0, 0);\n+        Asserts.assertEQ(specZero.kem_id(), 0);\n+        Asserts.assertEQ(specZero.kdf_id(), 0);\n+        Asserts.assertEQ(specZero.aead_id(), 0);\n+        Asserts.assertEQ(specZero.authKey(), null);\n+        Asserts.assertEQ(specZero.encapsulation(), null);\n+        Asserts.assertEqualsByteArray(specZero.info(), new byte[0]);\n+        Asserts.assertEQ(specZero.psk(), null);\n+        Asserts.assertEqualsByteArray(specZero.psk_id(), new byte[0]);\n+\n+        \/\/ identifiers\n+        HPKEParameterSpec.of(65535, 65535, 65535);\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(-1, 0, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, -1, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 0, -1));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(65536, 0, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 65536, 0));\n+        Asserts.assertThrows(IllegalArgumentException.class,\n+                () -> HPKEParameterSpec.of(0, 0, 65536));\n+\n+        \/\/ auth key\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPrivate()).authKey() != null);\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPublic()).authKey() != null);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withAuthKey(null));\n+\n+        \/\/ info\n+        Asserts.assertEqualsByteArray(spec.withInfo(info).info(), info);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withInfo(null));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withInfo(new byte[0]));\n+\n+        \/\/ encapsulation\n+        Asserts.assertEqualsByteArray(spec.withEncapsulation(info).encapsulation(), info);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withEncapsulation(null));\n+        Asserts.assertTrue(spec.withEncapsulation(new byte[0]).encapsulation().length == 0); \/\/ not emptiness check (yet)\n+\n+        \/\/ psk_id and psk\n+        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk().getEncoded(), psk.getEncoded());\n+        Asserts.assertEqualsByteArray(spec.withPsk(psk, psk_id).psk_id(), psk_id);\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(psk, null));\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(null, psk_id));\n+        Asserts.assertThrows(NullPointerException.class, () -> spec.withPsk(null, null));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(psk, new byte[0]));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(emptyKey, psk_id));\n+        Asserts.assertThrows(IllegalArgumentException.class, () -> spec.withPsk(shortKey, psk_id));\n+\n+        \/\/ toString\n+        Asserts.assertTrue(spec.toString().contains(\"kem_id=32, kdf_id=1, aead_id=2\"));\n+        Asserts.assertTrue(spec.toString().contains(\"info=(empty),\"));\n+        Asserts.assertTrue(spec.withInfo(new byte[3]).toString().contains(\"info=000000,\"));\n+        Asserts.assertTrue(spec.withInfo(\"info\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=696e666f (\\\"info\\\"),\"));\n+        Asserts.assertTrue(spec.withInfo(\"\\\"info\\\"\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=22696e666f22,\"));\n+        Asserts.assertTrue(spec.withInfo(\"'info'\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=27696e666f27 (\\\"'info'\\\"),\"));\n+        Asserts.assertTrue(spec.withInfo(\"i\\\\n\\\\f\\\\o\".getBytes(StandardCharsets.UTF_8))\n+                .toString().contains(\"info=695c6e5c665c6f (\\\"i\\\\n\\\\f\\\\o\\\"),\"));\n+        Asserts.assertTrue(spec.toString().contains(\"mode_base}\"));\n+        Asserts.assertTrue(spec.withPsk(psk, psk_id).toString().contains(\"mode_psk}\"));\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPrivate()).toString().contains(\"mode_auth}\"));\n+        Asserts.assertTrue(spec.withAuthKey(kp.getPrivate()).withPsk(psk, psk_id).toString().contains(\"mode_auth_psk}\"));\n+\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+\n+        Asserts.assertThrows(NoSuchAlgorithmException.class, () -> Cipher.getInstance(\"HPKE\/None\/NoPadding\"));\n+\n+        \/\/ Still at BEGIN, not initialized\n+        Asserts.assertEQ(c1.getIV(), null);\n+        Asserts.assertEQ(c1.getParameters(), null);\n+        Asserts.assertEquals(0, c1.getBlockSize());\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.getOutputSize(100));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.update(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.update(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.updateAAD(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.updateAAD(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal());\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1]));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1], 0, 1));\n+        Asserts.assertThrows(IllegalStateException.class, () -> c1.doFinal(new byte[1], 0, 1, new byte[1024], 0));\n+\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), spec);\n+        var encap = c1.getIV();\n+\n+        \/\/ Does not support WRAP and UNWRAP mode\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c1.init(Cipher.WRAP_MODE, kp.getPublic(), spec));\n+        Asserts.assertThrows(UnsupportedOperationException.class,\n+                () -> c1.init(Cipher.UNWRAP_MODE, kp.getPublic(), spec));\n+\n+        \/\/ Nulls\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, null, spec));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), (HPKEParameterSpec) null));\n+\n+        \/\/ Cannot init sender with private key\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPrivate(), spec));\n+\n+        \/\/ Cannot provide key encap msg to sender\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withEncapsulation(encap)));\n+\n+        \/\/ Cannot init without HPKEParameterSpec\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic()));\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate()));\n+\n+        \/\/ Cannot init with a spec not HPKEParameterSpec\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        NamedParameterSpec.X25519));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        NamedParameterSpec.X25519));\n+\n+        \/\/ Cannot init recipient with public key\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPublic(),\n+                        spec.withEncapsulation(new byte[32])));\n+        \/\/ Cannot provide key encap msg to sender\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), spec.withEncapsulation(encap)));\n+        \/\/ Must provide key encap msg to recipient\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(), spec));\n+\n+        \/\/ Unsupported identifiers\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(0x200, KDF_HKDF_SHA256, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, 4, AEAD_AES_256_GCM)));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        HPKEParameterSpec.of(KEM_DHKEM_X25519_HKDF_SHA256, KDF_HKDF_SHA256, 4)));\n+\n+        \/\/ HPKE\n+        checkEncryptDecrypt(kp, spec, spec);\n+\n+        \/\/ extra features\n+        var kp2 = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        checkEncryptDecrypt(kp,\n+                spec.withInfo(info),\n+                spec.withInfo(info));\n+        checkEncryptDecrypt(kp,\n+                spec.withPsk(psk, psk_id),\n+                spec.withPsk(psk, psk_id));\n+        checkEncryptDecrypt(kp,\n+                spec.withAuthKey(kp2.getPrivate()),\n+                spec.withAuthKey(kp2.getPublic()));\n+        checkEncryptDecrypt(kp,\n+                spec.withInfo(info).withPsk(psk, psk_id).withAuthKey(kp2.getPrivate()),\n+                spec.withInfo(info).withPsk(psk, psk_id).withAuthKey(kp2.getPublic()));\n+\n+        \/\/ wrong keys\n+        var kpRSA = KeyPairGenerator.getInstance(\"RSA\").generateKeyPair();\n+        var kpEC = KeyPairGenerator.getInstance(\"EC\").generateKeyPair();\n+\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kpRSA.getPublic(), spec));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kpEC.getPublic(), spec));\n+\n+        \/\/ mod_auth, wrong key type\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withAuthKey(kp2.getPublic())));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                        spec.withAuthKey(kp2.getPrivate())));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withAuthKey(kpRSA.getPrivate())));\n+        Asserts.assertThrows(InvalidAlgorithmParameterException.class,\n+                () -> c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(),\n+                        spec.withAuthKey(kpEC.getPrivate())));\n+    }\n+\n+    static void checkEncryptDecrypt(KeyPair kp, HPKEParameterSpec ps,\n+            HPKEParameterSpec pr) throws Exception {\n+\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+        var aad = \"AAD\".getBytes(StandardCharsets.UTF_8);\n+\n+        c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), ps);\n+        Asserts.assertEquals(16, c1.getBlockSize());\n+        Asserts.assertEquals(116, c1.getOutputSize(100));\n+        c1.updateAAD(aad);\n+        var ct = c1.doFinal(new byte[2]);\n+\n+        c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(),\n+                pr.withEncapsulation(c1.getIV()));\n+        Asserts.assertEquals(16, c2.getBlockSize());\n+        Asserts.assertEquals(84, c2.getOutputSize(100));\n+        c2.updateAAD(aad);\n+        Asserts.assertEqualsByteArray(c2.doFinal(ct), new byte[2]);\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Compliance.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.List;\n+\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_128_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_AES_256_GCM;\n+import static javax.crypto.spec.HPKEParameterSpec.AEAD_CHACHA20_POLY1305;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA384;\n+import static javax.crypto.spec.HPKEParameterSpec.KDF_HKDF_SHA512;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_256_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_384_HKDF_SHA384;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_P_521_HKDF_SHA512;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256;\n+import static javax.crypto.spec.HPKEParameterSpec.KEM_DHKEM_X448_HKDF_SHA512;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib\n+ * @summary HPKE running with different keys\n+ *\/\n+public class Functions {\n+\n+    record Params(String name, int kem) {}\n+    static List<Params> PARAMS = List.of(\n+            new Params(\"secp256r1\", KEM_DHKEM_P_256_HKDF_SHA256),\n+            new Params(\"secp384r1\", KEM_DHKEM_P_384_HKDF_SHA384),\n+            new Params(\"secp521r1\", KEM_DHKEM_P_521_HKDF_SHA512),\n+            new Params(\"X25519\", KEM_DHKEM_X25519_HKDF_SHA256),\n+            new Params(\"X448\", KEM_DHKEM_X448_HKDF_SHA512)\n+    );\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        var msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        var msg2 = \"goodbye\".getBytes(StandardCharsets.UTF_8);\n+        var info = \"info\".getBytes(StandardCharsets.UTF_8);\n+        var psk = new SecretKeySpec(\"K\".repeat(32).getBytes(StandardCharsets.UTF_8), \"Generic\");\n+        var psk_id = \"psk1\".getBytes(StandardCharsets.UTF_8);\n+\n+        for (var param : PARAMS) {\n+            var c1 = Cipher.getInstance(\"HPKE\");\n+            var c2 = Cipher.getInstance(\"HPKE\");\n+            var kp = genKeyPair(param.name());\n+            var kp2 = genKeyPair(param.name());\n+            for (var kdf : List.of(KDF_HKDF_SHA256, KDF_HKDF_SHA384, KDF_HKDF_SHA512)) {\n+                for (var aead : List.of(AEAD_AES_256_GCM, AEAD_AES_128_GCM, AEAD_CHACHA20_POLY1305)) {\n+\n+                    var params = HPKEParameterSpec.of(param.kem, kdf, aead);\n+                    System.out.println(params);\n+\n+                    c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), params);\n+                    c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params.withEncapsulation(c1.getIV()));\n+                    Asserts.assertEqualsByteArray(msg, c2.doFinal(c1.doFinal(msg)));\n+                    Asserts.assertEqualsByteArray(msg2, c2.doFinal(c1.doFinal(msg2)));\n+\n+                    c1.init(Cipher.ENCRYPT_MODE, kp.getPublic(), params\n+                            .withAuthKey(kp2.getPrivate())\n+                            .withInfo(info)\n+                            .withPsk(psk, psk_id));\n+                    c2.init(Cipher.DECRYPT_MODE, kp.getPrivate(), params\n+                            .withAuthKey(kp2.getPublic())\n+                            .withInfo(info)\n+                            .withPsk(psk, psk_id)\n+                            .withEncapsulation(c1.getIV()));\n+                    Asserts.assertEqualsByteArray(msg, c2.doFinal(c1.doFinal(msg)));\n+                    Asserts.assertEqualsByteArray(msg2, c2.doFinal(c1.doFinal(msg2)));\n+                }\n+            }\n+        }\n+    }\n+\n+    static KeyPair genKeyPair(String name) throws Exception {\n+        if (name.startsWith(\"secp\")) {\n+            var g = KeyPairGenerator.getInstance(\"EC\");\n+            g.initialize(new ECGenParameterSpec(name));\n+            return g.generateKeyPair();\n+        } else {\n+            return KeyPairGenerator.getInstance(name).generateKeyPair();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/Functions.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @summary KAT inside RFC 9180\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.artifacts.Artifact;\n+import jdk.test.lib.artifacts.ArtifactResolver;\n+import jdk.test.lib.json.JSONValue;\n+\n+import com.sun.crypto.provider.DHKEM;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.HPKEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HexFormat;\n+\n+import jtreg.SkippedException;\n+\n+\/\/\/ This test is based on Appendix A (Test Vectors) of\n+\/\/\/ [RFC 9180](https:\/\/datatracker.ietf.org\/doc\/html\/rfc9180#name-test-vectors)\n+\/\/\/ The test data is available as a JSON file at:\n+\/\/\/ https:\/\/github.com\/cfrg\/draft-irtf-cfrg-hpke\/blob\/5f503c564da00b0687b3de75f1dfbdfc4079ad31\/test-vectors.json.\n+\/\/\/\n+\/\/\/ The JSON file can either be hosted on an artifactory server or\n+\/\/\/ provided via a local path with\n+\/\/\/ ```\n+\/\/\/ jtreg -Djdk.test.lib.artifacts.rfc9180-test-vectors=<local-json-file> KAT9180.java\n+\/\/\/ ```\n+public class KAT9180 {\n+\n+    @Artifact(\n+            organization = \"jpg.tests.jdk.ietf\",\n+            name = \"rfc9180-test-vectors\",\n+            revision = \"5f503c5\",\n+            extension = \"json\",\n+            unpack = false)\n+    private static class RFC_9180_KAT {\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        var h = HexFormat.of();\n+        Path archivePath = null;\n+        try {\n+            archivePath = ArtifactResolver.fetchOne(RFC_9180_KAT.class);\n+        } catch (IOException e) {\n+            if (e.getMessage().contains(\"Cannot find the artifact\")) {\n+                throw new SkippedException(\"RFC_9180_KAT test vectors are not available.\");\n+            }\n+        }\n+        System.out.println(\"Data path: \" + archivePath);\n+        var c1 = Cipher.getInstance(\"HPKE\");\n+        var c2 = Cipher.getInstance(\"HPKE\");\n+        var ts = JSONValue.parse(new String(Files.readAllBytes(archivePath), StandardCharsets.UTF_8));\n+        for (var tg : ts.asArray()) {\n+            var mode = Integer.parseInt(tg.get(\"mode\").asString());\n+            System.err.print('I');\n+            var kem_id = Integer.parseInt(tg.get(\"kem_id\").asString());\n+            var kdf_id = Integer.parseInt(tg.get(\"kdf_id\").asString());\n+            var aead_id = Integer.parseInt(tg.get(\"aead_id\").asString());\n+            var ikmR = h.parseHex(tg.get(\"ikmR\").asString());\n+            var ikmE = h.parseHex(tg.get(\"ikmE\").asString());\n+            var info = h.parseHex(tg.get(\"info\").asString());\n+\n+            var kpR = new DHKEM.RFC9180DeriveKeyPairSR(ikmR).derive(kem_id);\n+            var spec = HPKEParameterSpec.of(kem_id, kdf_id, aead_id).withInfo(info);\n+            var rand = new DHKEM.RFC9180DeriveKeyPairSR(ikmE);\n+\n+            if (mode == 1 || mode == 3) {\n+                spec = spec.withPsk(\n+                        new SecretKeySpec(h.parseHex(tg.get(\"psk\").asString()), \"Generic\"),\n+                        h.parseHex(tg.get(\"psk_id\").asString()));\n+            }\n+            if (mode == 0 || mode == 1) {\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(), spec, rand);\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.withEncapsulation(c1.getIV()));\n+            } else {\n+                var ikmS = h.parseHex(tg.get(\"ikmS\").asString());\n+                var kpS = new DHKEM.RFC9180DeriveKeyPairSR(ikmS).derive(kem_id);\n+                c1.init(Cipher.ENCRYPT_MODE, kpR.getPublic(),\n+                        spec.withAuthKey(kpS.getPrivate()), rand);\n+                c2.init(Cipher.DECRYPT_MODE, kpR.getPrivate(),\n+                        spec.withEncapsulation(c1.getIV()).withAuthKey(kpS.getPublic()));\n+            }\n+            var enc = tg.get(\"encryptions\");\n+            if (enc != null) {\n+                System.err.print('e');\n+                var count = 0;\n+                for (var p : enc.asArray()) {\n+                    var aad = h.parseHex(p.get(\"aad\").asString());\n+                    var pt = h.parseHex(p.get(\"pt\").asString());\n+                    var ct = h.parseHex(p.get(\"ct\").asString());\n+                    c1.updateAAD(aad);\n+                    var ct1 = c1.doFinal(pt);\n+                    Asserts.assertEqualsByteArray(ct, ct1);\n+                    c2.updateAAD(aad);\n+                    var pt1 = c2.doFinal(ct);\n+                    Asserts.assertEqualsByteArray(pt, pt1);\n+                    count++;\n+                }\n+                System.err.print(count);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/HPKE\/KAT9180.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import jdk.test.lib.Utils;\n@@ -44,1 +43,0 @@\n-import java.util.Objects;\n@@ -46,1 +44,0 @@\n-import java.util.function.Consumer;\n@@ -69,6 +66,4 @@\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(null, new byte[0], null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(null, new byte[0], null));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null));\n@@ -89,16 +84,11 @@\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"OLALA\"),\n-                NoSuchAlgorithmException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"),\n-                NoSuchProviderException.class);\n-        Utils.runAndCheckException(\n-                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"),\n-                NoSuchAlgorithmException.class);\n-\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(null),\n-                InvalidKeyException.class);\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(null),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"OLALA\"));\n+        Asserts.assertThrows(NoSuchProviderException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"));\n+        Asserts.assertThrows(NoSuchAlgorithmException.class,\n+                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"));\n+\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newEncapsulator(null));\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(null));\n@@ -107,3 +97,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(badECKey()),\n-                ExChecker.of(InvalidKeyException.class).by(DHKEM.class));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(badECKey())),\n+                DHKEM.class.getName());\n@@ -113,3 +104,4 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newEncapsulator(kpRSA.getPublic()),\n-                ExChecker.of(InvalidKeyException.class).by(KEM.class.getName() + \"$DelayedKEM\"));\n+        checkThrownBy(Asserts.assertThrows(\n+                InvalidKeyException.class,\n+                () -> kem.newEncapsulator(kpRSA.getPublic())),\n+                KEM.class.getName() + \"$DelayedKEM\");\n@@ -117,3 +109,2 @@\n-        Utils.runAndCheckException(\n-                () -> kem.newDecapsulator(kpRSA.getPrivate()),\n-                InvalidKeyException.class);\n+        Asserts.assertThrows(InvalidKeyException.class,\n+                () -> kem.newDecapsulator(kpRSA.getPrivate()));\n@@ -128,9 +119,6 @@\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(-1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> e2.encapsulate(0, e2.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(-1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> e2.encapsulate(0, e2.secretSize(), null));\n@@ -165,12 +153,8 @@\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(null),\n-                NullPointerException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"),\n-                IndexOutOfBoundsException.class);\n-        Utils.runAndCheckException(\n-                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null),\n-                NullPointerException.class);\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(null));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"));\n+        Asserts.assertThrows(IndexOutOfBoundsException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"));\n+        Asserts.assertThrows(NullPointerException.class,\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null));\n@@ -181,3 +165,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(enc2.encapsulation()),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(enc2.encapsulation()));\n@@ -185,3 +168,2 @@\n-        Utils.runAndCheckException(\n-                () -> d3.decapsulate(new byte[100]),\n-                DecapsulateException.class);\n+        Asserts.assertThrows(DecapsulateException.class,\n+                () -> d3.decapsulate(new byte[100]));\n@@ -276,29 +258,3 @@\n-    \/\/ Used by Utils.runAndCheckException. Checks for type and final thrower.\n-    record ExChecker(Class<? extends Throwable> ex, String caller)\n-            implements Consumer<Throwable> {\n-        ExChecker {\n-            Objects.requireNonNull(ex);\n-        }\n-        static ExChecker of(Class<? extends Throwable> ex) {\n-            return new ExChecker(ex, null);\n-        }\n-        ExChecker by(String caller) {\n-            return new ExChecker(ex(), caller);\n-        }\n-        ExChecker by(Class<?> caller) {\n-            return new ExChecker(ex(), caller.getName());\n-        }\n-        @Override\n-        public void accept(Throwable t) {\n-            if (t == null) {\n-                throw new AssertionError(\"no exception thrown\");\n-            } else if (!ex.isAssignableFrom(t.getClass())) {\n-                throw new AssertionError(\"exception thrown is \" + t.getClass());\n-            } else if (caller == null) {\n-                return;\n-            } else if (t.getStackTrace()[0].getClassName().equals(caller)) {\n-                return;\n-            } else {\n-                throw new AssertionError(\"thrown by \" + t.getStackTrace()[0].getClassName());\n-            }\n-        }\n+    \/\/ Ensures `t` is thrown by `caller`\n+    static <T extends Throwable> void checkThrownBy(T t, String caller) {\n+        Asserts.assertEquals(caller, t.getStackTrace()[0].getClassName());\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":47,"deletions":91,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,3 @@\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n@@ -65,0 +68,2 @@\n+import static org.testng.Assert.assertNotSame;\n+import static org.testng.Assert.assertSame;\n@@ -291,0 +296,1 @@\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"\\r\"))));\n@@ -292,0 +298,6 @@\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"a\\r\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"a\\n\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"\\r\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"\\n\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\\r\", List.of(\"a\"))));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\\n\", List.of(\"a\"))));\n@@ -446,0 +458,76 @@\n+    @Test\n+    public static void testNormalizeOnNull() {\n+        assertThrows(NullPointerException.class, () -> normalize(null));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] illegalKeys() {\n+        var illegalChars = List.of('\\r', '\\n');\n+        var illegalStrings = Stream\n+                \/\/ Insert an illegal char at every possible position of following strings\n+                .of(\"Ab\", \"ab\", \"_a\", \"2a\")\n+                .flatMap(s -> IntStream\n+                        .range(0, s.length() + 1)\n+                        .boxed()\n+                        .flatMap(i -> illegalChars\n+                                .stream()\n+                                .map(c -> s.substring(0, i) + c + s.substring(i))));\n+        return Stream\n+                .concat(illegalChars.stream().map(c -> \"\" + c), illegalStrings)\n+                .map(s -> new Object[]{s})\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"illegalKeys\")\n+    public static void testNormalizeOnIllegalKeys(String illegalKey) {\n+        assertThrows(IllegalArgumentException.class, () -> normalize(illegalKey));\n+    }\n+\n+    @DataProvider\n+    public static Object[][] normalizedKeys() {\n+        return new Object[][]{\n+                \/\/ Empty string\n+                {\"\"},\n+                \/\/ Non-alpha prefix\n+                {\"_\"},\n+                {\"0\"},\n+                {\"_xy-@\"},\n+                {\"0xy-@\"},\n+                \/\/ Upper-case prefix\n+                {\"A\"},\n+                {\"B\"},\n+                {\"Ayz-@\"},\n+                {\"Byz-@\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"normalizedKeys\")\n+    public static void testNormalizeOnNormalizedKeys(String normalizedKey) {\n+        \/\/ Verify that the fast-path is taken\n+        assertSame(normalize(normalizedKey), normalizedKey);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] notNormalizedKeys() {\n+        return new Object[][]{\n+                {\"a\"},\n+                {\"b\"},\n+                {\"axy-@\"},\n+                {\"bxy-@\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"notNormalizedKeys\")\n+    public static void testNormalizeOnNotNormalizedKeys(String notNormalizedKey) {\n+        var normalizedKey = normalize(notNormalizedKey);\n+        \/\/ Verify that the fast-path is *not* taken\n+        assertNotSame(normalizedKey, notNormalizedKey);\n+        \/\/ Verify the result\n+        var expectedNormalizedKey = normalizedKey.substring(0, 1).toUpperCase() + normalizedKey.substring(1);\n+        assertEquals(normalizedKey, expectedNormalizedKey);\n+    }\n+\n+    private static String normalize(String key) {\n+        return Headers.of(key, \"foo\").keySet().iterator().next();\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HeadersTest.java","additions":89,"deletions":1,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8255800\n+ * @bug 8255800 8369129\n@@ -45,0 +45,1 @@\n+    static int[] bandMasks1 = new int[] { 0x0ff };\n@@ -47,0 +48,1 @@\n+    static DataBuffer dBuffer1 = new DataBufferByte(1);\n@@ -53,2 +55,9 @@\n-    \/* Except a version starting with \"17\" or higher *\/\n-    static void checkIsOldVersion(Throwable t) {\n+    \/**\n+      * If running on a JDK of the targetVersion or later, throw\n+      * a RuntimeException because the exception argument\n+      * should not have occured. However it is expected on\n+      * prior versions because that was the previous behaviour.\n+      * @param targetVersion to check\n+      * @param t the thrown exception to print\n+      *\/\n+    static void checkIsOldVersion(int targetVersion, Throwable t) {\n@@ -58,1 +67,1 @@\n-        if (v >= 17) {\n+        if (v >= targetVersion) {\n@@ -65,0 +74,5 @@\n+    \/* Except a version starting with \"17\" or higher *\/\n+    static void checkIsOldVersion(Throwable t) {\n+        checkIsOldVersion(17, t);\n+    }\n+\n@@ -76,0 +90,4 @@\n+         packedRasterTests1();\n+         packedRasterTests2();\n+         packedRasterTests3();\n+         packedRasterTests4();\n@@ -737,1 +755,1 @@\n-            Raster.createBandedRaster(DataBuffer.TYPE_INT, 1, 1, 0,\n+            Raster.createBandedRaster(DataBuffer.TYPE_INT, 1, 1, 1,\n@@ -750,1 +768,1 @@\n-            Raster.createBandedRaster(DataBuffer.TYPE_INT, 1, 1, 0,\n+            Raster.createBandedRaster(DataBuffer.TYPE_INT, 1, 1, 1,\n@@ -759,0 +777,15 @@\n+        try {\n+            \/* @throws IllegalArgumentException if the lengths of {@code bankIndices}\n+             *         and {@code bandOffsets} are different.\n+             *\/\n+            Raster.createBandedRaster(DataBuffer.TYPE_INT, 1, 1, 1,\n+                                      bankIndices, bandOffsets2, null);\n+            noException();\n+        } catch (ArrayIndexOutOfBoundsException t) {\n+          checkIsOldVersion(26, t);\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for different array lengths\");\n+            System.out.println(t);\n+        }\n+\n@@ -897,0 +930,15 @@\n+        try {\n+            \/* @throws ArrayIndexOutOfBoundsException if any element of {@code bankIndices}\n+             *         is greater or equal to the number of bands in {@code dataBuffer}\n+             *\/\n+            int[] indices = new int[] { 0, 1, 2 };\n+            int[] offsets = new int[] { 0, 0, 0 };\n+            Raster.createBandedRaster(dBuffer, 1, 1, 1,\n+                                      indices, offsets, null);\n+            noException();\n+        } catch (ArrayIndexOutOfBoundsException t) {\n+            System.out.println(\n+                   \"Got expected exception for bad bank index\");\n+            System.out.println(t);\n+        }\n+\n@@ -1048,0 +1096,19 @@\n+        try {\n+            \/* @throws IllegalArgumentException if the data size\n+             * needs to store all lines is greater than\n+             * {@code Integer.MAX_VALUE}\n+             *\/\n+            Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                    1000, 1000,\n+                    Integer.MAX_VALUE\/2 , 1,\n+                    bandOffsets, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\"Got expected exception for overflow\");\n+            System.out.println(t);\n+        } catch (NegativeArraySizeException t) {\n+            checkIsOldVersion(26, t);\n+            System.out.println(\"Got expected exception for overflow\");\n+            System.out.println(t);\n+        }\n+\n@@ -1065,1 +1132,1 @@\n-              * {@code scanlineStride} is less than 0\n+              * {@code scanlineStride} is less than or equal to 0\n@@ -1068,1 +1135,1 @@\n-                                      1, 1, -3, 1, bandOffsets, null);\n+                                      1, 1, 0, 1, bandOffsets, null);\n@@ -1078,1 +1145,1 @@\n-              * is less than 0\n+              * is less than or equal to 0\n@@ -1081,1 +1148,1 @@\n-                                      1, 1, 3, -1, bandOffsets, null);\n+                                      1, 1, 3, 0, bandOffsets, null);\n@@ -1087,0 +1154,2 @@\n+        } catch (RasterFormatException t) {\n+            checkIsOldVersion(26, t);\n@@ -1094,0 +1163,13 @@\n+        try {\n+            \/* @throws IllegalArgumentException if (w * pixelStride)\n+             * is greater than scanlineStride\n+             *\/\n+            Raster.createInterleavedRaster(DataBuffer.TYPE_BYTE,\n+                                  1, 1, 0, 1, bandOffsets, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for incorrect stride\");\n+            System.out.println(t);\n+        }\n+\n@@ -1099,1 +1181,1 @@\n-                                  1, 1, 0, 1, null, null);\n+                                  1, 1, 1, 1, null, null);\n@@ -1190,0 +1272,12 @@\n+        try {\n+             \/* @throws RasterFormatException if {@code dataBuffer} is too small.\n+              *\/\n+            Raster.createInterleavedRaster(dBuffer1, 5, 1, 15, 1,\n+                                      bandOffsets, null);\n+            noException();\n+        } catch (RasterFormatException t) {\n+            System.out.println(\n+                \"Got expected exception for databuffer too small\");\n+            System.out.println(t);\n+        }\n+\n@@ -1202,1 +1296,0 @@\n-if (t != null) throw t;\n@@ -1245,0 +1338,80 @@\n+            System.out.println(\n+                   \"Got expected exception for bad databuffer banks\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+             \/* @throws IllegalArgumentException if any element of {@code bandOffsets} is greater\n+             *  than {@code pixelStride} or the {@code scanlineStride}\n+             *\/\n+            int[] offsets = new int[] { 0, 1, 2};\n+            Raster.createInterleavedRaster(dBuffer,\n+                                  1, 1, 1, 1, offsets, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for element too large\");\n+            System.out.println(t);\n+        }\n+\n+    }\n+\n+    \/*  createPackedRaster(int dataType,\n+     *                     int w, int h,\n+     *                     int[] bandMasks,\n+     *                     Point location)\n+     *\n+     *\/\n+     static void packedRasterTests1() {\n+\n+        System.out.println();\n+        System.out.println(\"** packedRasterTests1\");\n+\n+         try {\n+             \/* @throws IllegalArgumentException if {@code w} and {@code h}\n+              *         are not both greater than 0\n+              *\/\n+             Raster.createPackedRaster(DataBuffer.TYPE_BYTE, 0, 0, bandMasks1, null);\n+            noException();\n+         } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for zero w \/ h\");\n+            System.out.println(t);\n+         }\n+\n+         try {\n+             \/* @throws IllegalArgumentException if {@code w} * {@code h}\n+              *         is greater than {@code Integer.MAX_VALUE}\n+              *\/\n+             Raster.createPackedRaster(DataBuffer.TYPE_BYTE,\n+                                       Integer.MAX_VALUE\/10, Integer.MAX_VALUE\/10,\n+                                       bandMasks1, null);\n+            noException();\n+         } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for overflow\");\n+            System.out.println(t);\n+         }\n+\n+        try {\n+            \/* @throws RasterFormatException if computing either\n+             * {@code location.x + w} or\n+             * {@code location.y + h} results in integer overflow\n+             *\/\n+            Point pt = new Point(5, 1);\n+            Raster.createPackedRaster(DataBuffer.TYPE_BYTE,\n+                                      Integer.MAX_VALUE-2, 1,\n+                                      bandMasks1, pt);\n+            noException();\n+        } catch (RasterFormatException t) {\n+            System.out.println(\"Got expected exception for overflow\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws IllegalArgumentException if {@code dataType}\n+             * is not one of the supported data types\n+             *\/\n+            Raster.createPackedRaster(1000, 1, 1, bandMasks1, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n@@ -1249,0 +1422,309 @@\n+     }\n+\n+    \/*  createPackedRaster(int dataType,\n+     *                     int w, int h,\n+     *                     int bands,\n+     *                     int bitsPerBand,\n+     *                     Point location)\n+     *\/\n+     static void packedRasterTests2() {\n+\n+        System.out.println();\n+        System.out.println(\"** packedRasterTests2\");\n+\n+         try {\n+             \/* @throws IllegalArgumentException if {@code w} and {@code h}\n+              *         are not both greater than 0\n+              *\/\n+             Raster.createPackedRaster(DataBuffer.TYPE_BYTE, 0, 0, 1, 8, null);\n+             noException();\n+         } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for zero w \/ h\");\n+            System.out.println(t);\n+         }\n+\n+         try {\n+             \/* @throws IllegalArgumentException if {@code w} * {@code h}\n+              *         is greater than {@code Integer.MAX_VALUE}\n+              *\/\n+             Raster.createPackedRaster(DataBuffer.TYPE_BYTE,\n+                                       Integer.MAX_VALUE\/10, Integer.MAX_VALUE\/10,\n+                                       1, 8, null);\n+             noException();\n+         } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for overflow\");\n+            System.out.println(t);\n+         }\n+\n+        try {\n+            \/* @throws RasterFormatException if computing either\n+             * {@code location.x + w} or\n+             * {@code location.y + h} results in integer overflow\n+             *\/\n+            Point pt = new Point(5, 1);\n+            Raster.createPackedRaster(DataBuffer.TYPE_BYTE,\n+                                      Integer.MAX_VALUE-2, 1,\n+                                      1, 8, pt);\n+            noException();\n+        } catch (RasterFormatException t) {\n+            System.out.println(\"Got expected exception for overflow\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+             \/* @throws IllegalArgumentException if {@code bitsPerBand} or\n+              *         {@code bands} is not greater than zero\n+              *\/\n+            Raster.createPackedRaster(DataBuffer.TYPE_BYTE, 1, 1,\n+                                       0, 8, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for 0 bands\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws IllegalArgumentException if {@code bitsPerBand} or\n+             *         {@code bands} is not greater than zero\n+             *\/\n+            Raster.createPackedRaster(DataBuffer.TYPE_BYTE, 1, 1,\n+                                       8, 0, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for 0 bitsPerBand\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws IllegalArgumentException if the product of\n+             *         {@code bitsPerBand} and {@code bands} is\n+             *         greater than the number of bits held by\n+             *         {@code dataType}\n+             *\/\n+            Raster.createPackedRaster(DataBuffer.TYPE_BYTE, 1, 1,\n+                                       2, 8, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for bands per sample\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws IllegalArgumentException if {@code dataType}\n+             * is not one of the supported data types\n+             *\/\n+            Raster.createPackedRaster(1000, 1, 1, 1, 8, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for bad databuffer type\");\n+            System.out.println(t);\n+        }\n+    }\n+\n+    \/*  createPackedRaster(DataBuffer dataBuffer,\n+     *                     int w, int h,\n+     *                     int scanlineStride,\n+     *                     int[] bandMasks,\n+     *                     Point location)\n+     *\/\n+    static void packedRasterTests3() {\n+\n+        System.out.println();\n+        System.out.println(\"** packedRasterTests3\");\n+\n+        try {\n+             \/* @throws IllegalArgumentException if {@code w} and {@code h}\n+              *         are not both greater than 0\n+              *\/\n+            Raster.createPackedRaster(dBuffer, 0, 1, 1, bandMasks1, null);\n+           noException();\n+        } catch (IllegalArgumentException t) {\n+           System.out.println(\n+                  \"Got expected exception for zero w \/ h\");\n+           System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws IllegalArgumentException if {@code w} * {@code h}\n+             *         is greater than {@code Integer.MAX_VALUE}\n+             *\/\n+            Raster.createPackedRaster(dBuffer,\n+                                      Integer.MAX_VALUE\/10, Integer.MAX_VALUE\/10,\n+                                      1, bandMasks1, null);\n+           noException();\n+        } catch (IllegalArgumentException t) {\n+           System.out.println(\n+                  \"Got expected exception for overflow\");\n+           System.out.println(t);\n+        }\n+\n+       try {\n+           \/* @throws RasterFormatException if computing either\n+            * {@code location.x + w} or\n+            * {@code location.y + h} results in integer overflow\n+            *\/\n+           Point pt = new Point(5, 1);\n+           Raster.createPackedRaster(dBuffer,\n+                                     Integer.MAX_VALUE-2, 1,\n+                                     1, bandMasks1, pt);\n+           noException();\n+       } catch (RasterFormatException t) {\n+           System.out.println(\"Got expected exception for overflow\");\n+           System.out.println(t);\n+       }\n+\n+       try {\n+            \/* @throws NullPointerException if databuffer is null.\n+             *\/\n+            Raster.createPackedRaster(null,\n+                                      1, 1,\n+                                      1, bandMasks1, null);\n+           noException();\n+       } catch (NullPointerException t) {\n+          System.out.println(\n+                  \"Got expected exception for null data buffer\");\n+           System.out.println(t);\n+       }\n+\n+       try {\n+            \/* @throws RasterFormatException if {@code dataBuffer}\n+             * has more than one bank.\n+             *\/\n+            DataBufferByte dbuffer2 = new DataBufferByte(20, 2);\n+            Raster.createPackedRaster(dbuffer2, 1, 1, 1, bandMasks1, null);\n+            noException();\n+        } catch (RasterFormatException t) {\n+            System.out.println(\n+                   \"Got expected exception for bad databuffer banks\");\n+            System.out.println(t);\n+        }\n+       try {\n+            \/* @throws IllegalArgumentException if {@code dataBuffer}\n+             * is not one of the supported data types\n+             *\/\n+            DataBufferFloat dbFloat = new DataBufferFloat(20);\n+            Raster.createPackedRaster(dbFloat, 1, 1, 1, bandMasks1, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for bad databuffer type\");\n+            System.out.println(t);\n+        }\n+   }\n+\n+    \/* createPackedRaster(DataBuffer dataBuffer,\n+     *               int w, int h,\n+     *               int bitsPerPixel,\n+     *               Point location)\n+     *\/\n+    static void packedRasterTests4() {\n+\n+        System.out.println();\n+        System.out.println(\"** packedRasterTests4\");\n+\n+        try {\n+             \/* @throws IllegalArgumentException if {@code w} and {@code h}\n+              *         are not both greater than 0\n+              *\/\n+            Raster.createPackedRaster(dBuffer, 0, 1, 8, null);\n+           noException();\n+        } catch (IllegalArgumentException t) {\n+           System.out.println(\n+                  \"Got expected exception for zero w \/ h\");\n+           System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws IllegalArgumentException if {@code w} * {@code h}\n+             *         is greater than {@code Integer.MAX_VALUE}\n+             *\/\n+            Raster.createPackedRaster(dBuffer,\n+                                      Integer.MAX_VALUE\/10, Integer.MAX_VALUE\/10,\n+                                      8, null);\n+           noException();\n+        } catch (IllegalArgumentException t) {\n+           System.out.println(\n+                  \"Got expected exception for overflow\");\n+           System.out.println(t);\n+        }\n+\n+       try {\n+           \/* @throws RasterFormatException if computing either\n+            * {@code location.x + w} or\n+            * {@code location.y + h} results in integer overflow\n+            *\/\n+           Point pt = new Point(5, 1);\n+           Raster.createPackedRaster(dBuffer,\n+                                     Integer.MAX_VALUE-2, 1,\n+                                     8, pt);\n+           noException();\n+       } catch (RasterFormatException t) {\n+           System.out.println(\"Got expected exception for overflow\");\n+           System.out.println(t);\n+       }\n+\n+       try {\n+            \/* @throws IllegalArgumentException if {@code dataBuffer}\n+             * is not one of the supported data types\n+             *\/\n+            DataBufferFloat dbFloat = new DataBufferFloat(20);\n+            Raster.createPackedRaster(dbFloat, 1, 1, 8, null);\n+            noException();\n+        } catch (IllegalArgumentException t) {\n+            System.out.println(\n+                   \"Got expected exception for bad databuffer type\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws RasterFormatException if {@code dataBuffer}\n+             * has more than one bank.\n+             *\/\n+            DataBufferByte dbb = new DataBufferByte(100, 2);\n+            Raster.createPackedRaster(dbb, 1, 1, 8, null);\n+            noException();\n+        } catch (RasterFormatException t) {\n+            System.out.println(\n+                   \"Got expected exception for bad databuffer banks\");\n+            System.out.println(t);\n+        }\n+\n+        try {\n+            \/* @throws NullPointerException if databuffer is null.\n+             *\/\n+           Raster.createPackedRaster(null, 1, 1, 8, null);\n+           noException();\n+       } catch (NullPointerException t) {\n+          System.out.println(\n+                  \"Got expected exception for null data buffer\");\n+           System.out.println(t);\n+       }\n+\n+       int[] badbpp = { 0, 6, 16 };\n+       for (int bpp : badbpp) {\n+           try {\n+               \/* @throws RasterFormatException if {@code bitsPixel} is less than 1 or\n+                * not a power of 2 or exceeds the {@code dataBuffer} element size.\n+                *\/\n+               System.out.println(\"Test bpp=\" + bpp);\n+               Raster.createPackedRaster(dBuffer, 1, 1, bpp, null);\n+               noException();\n+           } catch (RasterFormatException t) {\n+              System.out.println(\n+                      \"Got expected exception for bitsPerPixel\");\n+               System.out.println(t);\n+           } catch (ArithmeticException t) {\n+               checkIsOldVersion(26, t);\n+               if (bpp != 0) {\n+                   throw new RuntimeException(\"Unexpected arithmetic exception\");\n+               }\n+               System.out.println(\"Got expected arithmetic exception\");\n+               System.out.println(t);\n+        }\n+       }\n","filename":"test\/jdk\/java\/awt\/image\/Raster\/CreateRasterExceptionTest.java","additions":495,"deletions":13,"binary":false,"changes":508,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            MemorySegment segment = arena.allocate(aligned);;\n+            MemorySegment segment = arena.allocate(aligned);\n@@ -65,0 +65,6 @@\n+\n+            \/\/ Allocate another segment and fill it with data to\n+            \/\/ check that the first segment is not overwritten\n+            MemorySegment nextSegment = arena.allocate(aligned);\n+            vh.set(nextSegment, 0L, 0xffffff);\n+\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371953\n+ * @summary Check null argument behaviors for java.lang.Class APIs.\n+ * @run junit NullBehaviorTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class NullBehaviorTest {\n+    @Test\n+    void nullChecks() {\n+        assertThrows(NullPointerException.class, () -> Class.forName(null));\n+        assertDoesNotThrow(() -> Class.forName(\"java.lang.Object\", false, null));\n+        assertThrows(NullPointerException.class, () -> Class.forName(null, false, null));\n+        assertThrows(NullPointerException.class, () -> Class.forName(null, \"java.lang.Object\"));\n+        assertThrows(NullPointerException.class, () -> Class.forName(Object.class.getModule(), null));\n+        assertThrows(NullPointerException.class, () -> Class.forPrimitiveName(null));\n+        assertFalse(Object.class.isInstance(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.isAssignableFrom(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.getField(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.getDeclaredField(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.getMethod(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.getDeclaredMethod(null));\n+        assertDoesNotThrow(() -> Object.class.getMethod(\"hashCode\", (Class<?>[]) null));\n+        assertDoesNotThrow(() -> Object.class.getDeclaredMethod(\"hashCode\", (Class<?>[]) null));\n+        assertThrows(NoSuchMethodException.class, () -> Object.class.getMethod(\"hashCode\", new Class[]{null}));\n+        assertThrows(NoSuchMethodException.class, () -> Object.class.getDeclaredMethod(\"hashCode\", new Class[]{null}));\n+        assertDoesNotThrow(() -> Object.class.getConstructor((Class<?>[]) null));\n+        assertDoesNotThrow(() -> Object.class.getDeclaredConstructor((Class<?>[]) null));\n+        assertThrows(NoSuchMethodException.class, () -> Object.class.getConstructor(new Class[]{null}));\n+        assertThrows(NoSuchMethodException.class, () -> Object.class.getDeclaredConstructor(new Class[]{null}));\n+        assertThrows(NullPointerException.class, () -> Object.class.getResourceAsStream(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.getResource(null));\n+        assertDoesNotThrow(() -> Object.class.cast(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.asSubclass(null));\n+        assertThrows(NullPointerException.class, () -> Object.class.isNestmateOf(null));\n+        assertThrows(NullPointerException.class, () -> int.class.isNestmateOf(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Class\/NullBehaviorTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.reflect.GenericSignatureFormatError;\n@@ -96,2 +97,10 @@\n-        assertThrows(ClassFormatError.class, () -> loadTestClass(\"methodName\", \"(L[;)V\"));\n-        assertThrows(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(L[;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(\"methodName\", \"(L[;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(L[;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"(Lmissing\/;)V\"));\n+        assertThrowsExactly(ClassFormatError.class, () -> loadTestClass(INIT_NAME, \"()L\/Missing;\"));\n+        \/\/ only throw if the query type match the method\/constructor type\n+        assertDoesNotThrow(() -> loadTestClass(INIT_NAME, \"Ljava\/lang\/Object;\").getEnclosingMethod());\n+        assertDoesNotThrow(() -> loadTestClass(\"method\", \"[I\").getEnclosingConstructor());\n+        \/\/ We have to manually intercept field-typed \"methods\"\n+        assertThrows(GenericSignatureFormatError.class, () -> loadTestClass(INIT_NAME, \"Ljava\/lang\/Object;\").getEnclosingConstructor());\n+        assertThrows(GenericSignatureFormatError.class, () -> loadTestClass(\"method\", \"[I\").getEnclosingMethod());\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingMethod\/BadEnclosingMethodTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -227,9 +227,0 @@\n-    record Lazy<T>(LazyConstant<T> underlying) implements Supplier<T> {\n-        @Override\n-        public T get() { return underlying.get(); }\n-\n-        static <T> Lazy<T> of(Supplier<? extends T> computingFunction) {\n-            return new Lazy<>(LazyConstant.of(computingFunction));\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyConstantTest.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED LazyListTest\n+ * @modules java.base\/java.util:+open\n+ * @run junit LazyListTest\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyListTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * @run junit\/othervm --add-opens java.base\/java.util=ALL-UNNAMED LazyMapTest\n+ * @modules java.base\/java.util:+open\n+ * @run junit LazyMapTest\n","filename":"test\/jdk\/java\/lang\/LazyConstant\/LazyMapTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -44,0 +47,2 @@\n+import java.util.Arrays;\n+import java.util.stream.Stream;\n@@ -59,0 +64,16 @@\n+    static Stream<String> badFieldDescriptors() {\n+        return Arrays.stream(new String[] {\n+                \"Not a_descriptor\",\n+                \"()V\",\n+                \"Ljava\/lang\/Object\",\n+                \"Ljava\/\",\n+                \"Ljava\/util\/Map.Entry;\",\n+                \"[\".repeat(256) + \"I\",\n+                \"Lbad.Name;\",\n+                \"Lbad[Name;\",\n+                \"L;\",\n+                \"L\/Missing;\",\n+                \"Lmissing\/;\",\n+        });\n+    }\n+\n@@ -64,3 +85,9 @@\n-    @Test\n-    void testMalformedClassValue() throws Exception {\n-        var badDescString = \"Not a_descriptor\";\n+    @ParameterizedTest\n+    @MethodSource(\"badFieldDescriptors\")\n+    void testMalformedClassValue(String badDescString) throws Exception {\n+        var cl = spinClass(badDescString);\n+        var ex = assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n+        assertTrue(ex.getMessage().contains(badDescString), () -> \"Uninformative error: \" + ex);\n+    }\n+\n+    private static Class<?> spinClass(String desc) throws Exception {\n@@ -71,1 +98,1 @@\n-                                        .constantPool().utf8Entry(badDescString))))\n+                                        .constantPool().utf8Entry(desc))))\n@@ -73,3 +100,17 @@\n-        var cl = new ByteCodeLoader(\"Test\", bytes, MalformedAnnotationTest.class.getClassLoader()).loadClass(\"Test\");\n-        var ex = assertThrows(GenericSignatureFormatError.class, () -> cl.getDeclaredAnnotation(ClassCarrier.class));\n-        assertTrue(ex.getMessage().contains(badDescString), () -> \"Uninformative error: \" + ex);\n+        return new ByteCodeLoader(\"Test\", bytes, ClassCarrier.class.getClassLoader()).loadClass(\"Test\");\n+    }\n+\n+    static Stream<String> goodFieldDescriptors() {\n+        return Arrays.stream(new String[] {\n+                \"Ljava\/lang\/Object<*>;\", \/\/ previously MalformedParameterizedTypeException\n+                \"[Ljava\/util\/Optional<*>;\", \/\/ previously ClassCastException\n+                \"Ljava\/util\/Map$Entry<**>;\", \/\/ previously ClassCastException\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"goodFieldDescriptors\")\n+    void testLegalClassValue(String goodDescString) throws Exception {\n+        var cl = spinClass(goodDescString);\n+        var anno = cl.getDeclaredAnnotation(ClassCarrier.class);\n+        assertThrows(TypeNotPresentException.class, anno::value);\n","filename":"test\/jdk\/java\/lang\/annotation\/MalformedAnnotationTest.java","additions":48,"deletions":7,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -233,0 +233,5 @@\n+                \"()Lbad.Name;\",\n+                \"()Lbad[Name;\",\n+                \"(L;)V\",\n+                \"(L\/Missing;)I\",\n+                \"(Lmissing\/;)Z\",\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodTypeTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371953\n+ * @summary Null checks for AccessFlag and Location.\n+ * @run junit AccessFlagNullCheckTest\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.ClassFileFormatVersion;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AccessFlagNullCheckTest {\n+    @Test\n+    void accessFlagNullChecks() {\n+        assertThrows(NullPointerException.class, () -> AccessFlag.valueOf(null));\n+        assertThrows(NullPointerException.class, () -> AccessFlag.PUBLIC.locations(null));\n+        assertThrows(NullPointerException.class, () -> AccessFlag.maskToAccessFlags(0, null));\n+        assertThrows(NullPointerException.class, () -> AccessFlag.maskToAccessFlags(0, AccessFlag.Location.CLASS, null));\n+        assertThrows(NullPointerException.class, () -> AccessFlag.maskToAccessFlags(0, null, ClassFileFormatVersion.RELEASE_1));\n+    }\n+\n+    @Test\n+    void locationNullChecks() {\n+        assertThrows(NullPointerException.class, () -> AccessFlag.Location.valueOf(null));\n+        assertThrows(NullPointerException.class, () -> AccessFlag.Location.CLASS.flags(null));\n+        assertThrows(NullPointerException.class, () -> AccessFlag.Location.CLASS.flagsMask(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/AccessFlagNullCheckTest.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371953\n+ * @summary API null checks for AccessibleObject.\n+ * @run junit AccessibleObjectNullCheckTest\n+ *\/\n+\n+import java.lang.reflect.AccessibleObject;\n+import java.util.Objects;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AccessibleObjectNullCheckTest {\n+    @Test\n+    void nullChecks() throws ReflectiveOperationException {\n+        assertThrows(NullPointerException.class, () -> AccessibleObject.setAccessible(null, false));\n+        assertThrows(NullPointerException.class, () -> AccessibleObject.setAccessible(new AccessibleObject[]{ null }, false));\n+        var accessible = Objects.requireNonNull(Object.class.getMethod(\"toString\"));\n+        assertThrows(IllegalArgumentException.class, () -> accessible.canAccess(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/AccessibleObjectNullCheckTest.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371953\n+ * @summary General argument checks for Array APIs.\n+ * @run junit ArrayArgumentCheckTest\n+ *\/\n+\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Array;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class ArrayArgumentCheckTest {\n+    @Test\n+    void newArrayChecks() throws ReflectiveOperationException {\n+        \/\/ Single newInstance\n+        assertDoesNotThrow(() -> Array.newInstance(Object.class, 0));\n+        assertThrows(NullPointerException.class, () -> Array.newInstance(null, 0));\n+        assertThrows(NegativeArraySizeException.class, () -> Array.newInstance(Object.class, -1));\n+        assertThrows(IllegalArgumentException.class, () -> Array.newInstance(void.class, 0));\n+        var object255ArrayType = ConstantDescs.CD_Object.arrayType(255).resolveConstantDesc(MethodHandles.publicLookup());\n+        assertThrows(IllegalArgumentException.class, () -> Array.newInstance(object255ArrayType, 0));\n+        \/\/ Multi-level newInstance\n+        assertDoesNotThrow(() -> Array.newInstance(Object.class, 0));\n+        assertThrows(NullPointerException.class, () -> Array.newInstance(null, new int[1]));\n+        assertThrows(NullPointerException.class, () -> Array.newInstance(Object.class, (int[]) null));\n+        assertThrows(NegativeArraySizeException.class, () -> Array.newInstance(Object.class, new int[]{3, -1, 5}));\n+        assertThrows(IllegalArgumentException.class, () -> Array.newInstance(Object.class));\n+        var object254ArrayType = ConstantDescs.CD_Object.arrayType(254).resolveConstantDesc(MethodHandles.publicLookup());\n+        assertThrows(IllegalArgumentException.class, () -> Array.newInstance(object254ArrayType, new int[] {2, 3}));\n+    }\n+\n+    @Test\n+    void getLengthChecks() {\n+        assertThrows(NullPointerException.class, () -> Array.getLength(null));\n+        assertThrows(IllegalArgumentException.class, () -> Array.getLength(5));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Array\/ArrayArgumentCheckTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371953\n+ * @summary General tests for ClassFileFormatVersion.\n+ * @run junit ClassFileFormatVersionTest\n+ *\/\n+\n+import java.lang.reflect.ClassFileFormatVersion;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class ClassFileFormatVersionTest {\n+    @Test\n+    void argumentChecks() {\n+        assertThrows(NullPointerException.class, () -> ClassFileFormatVersion.valueOf((String) null));\n+        assertThrows(NullPointerException.class, () -> ClassFileFormatVersion.valueOf((Runtime.Version) null));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileFormatVersion.valueOf(\"Absent\"));\n+        var runtimeVersion = Runtime.Version.parse(\"99999999\");\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileFormatVersion.valueOf(runtimeVersion));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/ClassFileFormatVersionTest.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371953\n+ * @summary Null arguments for exception classes in java.lang.reflect package.\n+ * @run junit ExceptionClassesNullCheckTest\n+ *\/\n+\n+import java.lang.reflect.GenericSignatureFormatError;\n+import java.lang.reflect.InaccessibleObjectException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.MalformedParameterizedTypeException;\n+import java.lang.reflect.MalformedParametersException;\n+import java.lang.reflect.UndeclaredThrowableException;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n+class ExceptionClassesNullCheckTest {\n+    @Test\n+    void argumentChecks() {\n+        \/\/ Add casts to preserve compilation if they add new constructor overloads\n+        assertDoesNotThrow(() -> new GenericSignatureFormatError((String) null));\n+        assertDoesNotThrow(() -> new InaccessibleObjectException((String) null));\n+        assertDoesNotThrow(() -> new InvocationTargetException((Throwable) null));\n+        assertDoesNotThrow(() -> new InvocationTargetException(null, null));\n+        assertDoesNotThrow(() -> new MalformedParameterizedTypeException((String) null));\n+        assertDoesNotThrow(() -> new MalformedParametersException((String) null));\n+        assertDoesNotThrow(() -> new UndeclaredThrowableException((Throwable) null));\n+        assertDoesNotThrow(() -> new UndeclaredThrowableException(null, null));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/ExceptionClassesNullCheckTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371953\n+ * @summary Basic API null checks for Proxy.\n+ * @run junit ProxyNullCheckTest\n+ *\/\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Proxy;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ProxyNullCheckTest {\n+    @SuppressWarnings(\"deprecation\")\n+    @Test\n+    void nullChecks() throws ReflectiveOperationException {\n+        InvocationHandler h = (_, _, _) -> null;\n+        \/\/ newProxyInstance\n+        assertDoesNotThrow(() -> Proxy.newProxyInstance(null, new Class[0], h));\n+        assertThrows(NullPointerException.class, () -> Proxy.newProxyInstance(null, null, h));\n+        assertThrows(NullPointerException.class, () -> Proxy.newProxyInstance(null, new Class[] { null }, h));\n+        assertThrows(NullPointerException.class, () -> Proxy.newProxyInstance(null, new Class[0], null));\n+        \/\/ getProxyClass\n+        assertDoesNotThrow(() -> Proxy.getProxyClass(null, new Class[0]));\n+        assertThrows(NullPointerException.class, () -> Proxy.getProxyClass(null, (Class[]) null));\n+        assertThrows(NullPointerException.class, () -> Proxy.getProxyClass(null, new Class[] { null }));\n+        \/\/ isProxyClass\n+        assertFalse(Proxy.isProxyClass(Object.class));\n+        assertThrows(NullPointerException.class, () -> Proxy.isProxyClass(null));\n+        \/\/ getInvocationHandler\n+        assertThrows(NullPointerException.class, () -> Proxy.getInvocationHandler(null));\n+        assertThrows(IllegalArgumentException.class, () -> Proxy.getInvocationHandler(42));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyNullCheckTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\/\n+\n+\/*\n+* @test\n+* @bug 8367049\n+* @summary URLPermission must reject empty\/missing host authority with IAE (no SIOOBE)\n+* @run testng EmptyAuthorityTest\n+*\/\n+\n+import java.net.URLPermission;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class EmptyAuthorityTest {\n+\n+    @DataProvider(name = \"badUrls\")\n+    public Object[][] badUrls() {\n+        return new Object[][]{\n+                { \"http:\/\/\/path\" }, \/\/ empty authority\n+                { \"https:\/\/\/x\" }, \/\/ empty authority\n+                { \"http:\/\/@\/x\" }, \/\/ userinfo + empty host\n+                { \"http:\/\/user@\/x\" }, \/\/ userinfo + empty host\n+                { \"http:\/\/[]\/x\" } \/\/ empty IPv6 literal\n+        };\n+    }\n+\n+    @DataProvider(name = \"goodUrls\")\n+    public Object[][] goodUrls() {\n+        return new Object[][]{\n+                { \"http:\/\/example.com\/x\" },\n+                { \"http:\/\/example.com:80\/x\" },\n+                { \"http:\/\/[::1]\/x\" },\n+                { \"http:\/\/[::1]:8080\/x\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"badUrls\")\n+    public void rejectsEmptyOrMalformedAuthority(String url) {\n+        Assert.expectThrows(IllegalArgumentException.class, () -> new URLPermission(url));\n+    }\n+\n+    @Test(dataProvider = \"goodUrls\")\n+    public void acceptsValidAuthorities(String url) {\n+        new URLPermission(url); \/\/ should not throw\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLPermission\/EmptyAuthorityTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -393,6 +393,0 @@\n-    private boolean isSelectorManager(Thread t) {\n-        String name = t.getName();\n-        if (name == null) return false;\n-        return name.contains(\"SelectorManager\");\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http;\n+\n+import java.lang.reflect.Field;\n+import java.net.http.HttpClient;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public final class HttpClientImplAccess {\n+\n+    private static final Field openedConnections; \/\/ Set<> jdk.internal.net.http.HttpClientImpl#openedConnections\n+\n+    static {\n+        try {\n+            openedConnections = Class.forName(\"jdk.internal.net.http.HttpClientImpl\")\n+                    .getDeclaredField(\"openedConnections\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private HttpClientImplAccess() {\n+        throw new AssertionError();\n+    }\n+\n+    private static HttpClientImpl impl(final HttpClient client) {\n+        if (client instanceof HttpClientImpl impl) return impl;\n+        if (client instanceof HttpClientFacade facade) return facade.impl;\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the {@code jdk.internal.net.http.HttpClientImpl#openedConnections Set}.\n+     * Returns null if the underlying client isn't of type jdk.internal.net.http.HttpClientImpl.\n+     *\/\n+    public static Set<?> getOpenedConnections(final HttpClient client)\n+            throws IllegalAccessException {\n+        Objects.requireNonNull(client, \"client\");\n+        final HttpClientImpl clientImpl = impl(client);\n+        if (clientImpl == null) {\n+            return null;\n+        }\n+        openedConnections.setAccessible(true);\n+        return (Set<?>) openedConnections.get(clientImpl);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/access\/java.net.http\/jdk\/internal\/net\/http\/HttpClientImplAccess.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeSupplier;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.HttpClientImplAccess;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8326498 8361091\n+ * @summary verify that the HttpClient does not leak connections when dealing with\n+ *          sudden rush of HTTP\/2 requests\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib ..\/access\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ *        jdk.httpclient.test.lib.http2.Http2Handler\n+ *        jdk.httpclient.test.lib.http2.Http2TestExchange\n+ *        jdk.httpclient.test.lib.http2.Http2TestExchangeSupplier\n+ *        java.net.http\/jdk.internal.net.http.HttpClientImplAccess\n+ * @run junit ${test.main.class}\n+ *\/\n+class BurstyRequestsTest {\n+\n+    private static final String HANDLER_PATH = \"\/8326498\/\";\n+\n+    \/\/ we use a h2c server but it doesn't matter if it is h2c or h2\n+    private static Http2TestServer http2Server;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        http2Server = new Http2TestServer(false, 0);\n+        http2Server.setExchangeSupplier(new ExchangeSupplier());\n+        http2Server.addHandler(new Handler(), HANDLER_PATH);\n+        http2Server.start();\n+        System.err.println(\"started HTTP\/2 server \" + http2Server.getAddress());\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (http2Server != null) {\n+            System.err.println(\"stopping server \" + http2Server.getAddress());\n+            http2Server.stop();\n+        }\n+    }\n+\n+    \/*\n+     * Issues a burst of HTTP\/2 requests to the same server (host\/port) and expects all of\n+     * them to complete normally.\n+     * Once these requests have completed, the test then peeks into an internal field of the\n+     * HttpClientImpl to verify that the client is holding on to at most 1 connection.\n+     *\/\n+    @Test\n+    void testOpenConnections() throws Exception {\n+        final URI reqURI = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .host(http2Server.getAddress().getAddress())\n+                .port(http2Server.getAddress().getPort())\n+                .path(HANDLER_PATH)\n+                .build();\n+        final HttpRequest req = HttpRequest.newBuilder().uri(reqURI).build();\n+\n+        final int numRequests = 20;\n+        \/\/ latch for the tasks to wait on, before issuing the requests\n+        final CountDownLatch startLatch = new CountDownLatch(numRequests);\n+        final List<Future<Void>> futures = new ArrayList<>();\n+\n+        try (final ExecutorService executor = Executors.newCachedThreadPool();\n+             final HttpClient client = HttpClient.newBuilder()\n+                     .proxy(NO_PROXY)\n+                     .version(HTTP_2)\n+                     .build()) {\n+            \/\/ our test needs to peek into the internal field of jdk.internal.net.http.HttpClientImpl\n+            final Set<?> openedConnections = HttpClientImplAccess.getOpenedConnections(client);\n+            assertNotNull(openedConnections, \"HttpClientImpl#openedConnections field is null or not available\");\n+\n+            for (int i = 0; i < numRequests; i++) {\n+                final Future<Void> f = executor.submit(new RequestIssuer(startLatch, client, req));\n+                futures.add(f);\n+            }\n+            \/\/ wait for the requests to complete\n+            for (final Future<Void> f : futures) {\n+                f.get();\n+            }\n+            System.err.println(\"all \" + numRequests + \" requests completed successfully\");\n+            \/\/ the request completion happens asynchronously to the closing of the HTTP\/2 Stream\n+            \/\/ as well as the HTTP\/2 connection. we wait for at most 1 connection to be retained\n+            \/\/ by HttpClientImpl.\n+            System.err.println(\"waiting for at least \" + (numRequests - 1) + \" connections to be closed\");\n+            \/\/ now verify that the current open TCP connections is not more than 1.\n+            \/\/ we let the test timeout if we never reach that count.\n+            int size = openedConnections.size();\n+            System.err.println(\"currently \" + size + \" open connections: \" + openedConnections);\n+            while (size > 1) {\n+                \/\/ wait\n+                Thread.sleep(100);\n+                final int prev = size;\n+                size = openedConnections.size();\n+                if (prev != size) {\n+                    System.err.println(\"currently \" + size + \" open connections: \" + openedConnections);\n+                }\n+            }\n+            \/\/ we expect at most 1 connection will stay open\n+            assertTrue((size == 0 || size == 1),\n+                    \"unexpected number of current open connections: \" + size);\n+        }\n+    }\n+\n+    private static final class RequestIssuer implements Callable<Void> {\n+        private final CountDownLatch startLatch;\n+        private final HttpClient client;\n+        private final HttpRequest request;\n+\n+        private RequestIssuer(final CountDownLatch startLatch, final HttpClient client,\n+                              final HttpRequest request) {\n+            this.startLatch = startLatch;\n+            this.client = client;\n+            this.request = request;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            this.startLatch.countDown(); \/\/ announce our arrival\n+            this.startLatch.await(); \/\/ wait for other threads to arrive\n+            \/\/ issue the request\n+            final HttpResponse<Void> resp = this.client.send(request, BodyHandlers.discarding());\n+            if (resp.statusCode() != 200) {\n+                throw new AssertionError(\"unexpected response status code: \" + resp.statusCode());\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private static final class Handler implements Http2Handler {\n+        private static final int NO_RESP_BODY = -1;\n+\n+        @Override\n+        public void handle(final Http2TestExchange exchange) throws IOException {\n+            System.err.println(\"handling request \" + exchange.getRequestURI());\n+            exchange.sendResponseHeaders(200, NO_RESP_BODY);\n+        }\n+    }\n+\n+    private static final class ExchangeSupplier implements Http2TestExchangeSupplier {\n+\n+        @Override\n+        public Http2TestExchange get(int streamid, String method, HttpHeaders reqheaders,\n+                                     HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                                     SSLSession sslSession, BodyOutputStream os,\n+                                     Http2TestServerConnection conn, boolean pushAllowed) {\n+            \/\/ don't close the connection when\/if the client sends a GOAWAY\n+            conn.closeConnOnIncomingGoAway = false;\n+            return Http2TestExchangeSupplier.ofDefault().get(streamid, method, reqheaders,\n+                    rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BurstyRequestsTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -253,0 +253,2 @@\n+                                System.err.println(\"unexpected exception: \" + cause\n+                                        + \", for request \" + REQ_URI_BASE + reqQueryPart);\n@@ -258,0 +260,2 @@\n+                                System.err.println(\"unexpected exception message: \" + ioe.getMessage()\n+                                        + \", for request \" + REQ_URI_BASE + reqQueryPart);\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8372159\n+ * @summary Verifies whether `SelectorManager` uses virtual threads\n+ *          as expected when no explicit configuration is provided\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=never\n+ * @bug 8372159\n+ * @summary Verifies that `SelectorManager` does *not* use virtual threads\n+            when explicitly configured to \"never\" use them\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=never\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=always\n+ * @bug 8372159\n+ * @summary Verifies that `SelectorManager` does *always* use virtual threads\n+            when explicitly configured to \"always\" use them\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=always\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=explicit-default\n+ * @bug 8372159\n+ * @summary Verifies whether `SelectorManager` uses virtual threads\n+ *          as expected when `default` is explicitly configured\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=default\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=garbage\n+ * @bug 8372159\n+ * @summary Verifies whether `SelectorManager` uses virtual threads when\n+            it is configured using an invalid value\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=garbage\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/\/ -Djava.security.debug=all\n+class H2SelectorVTTest implements HttpServerAdapters {\n+\n+    private static SSLContext sslContext;\n+    private static HttpTestServer h2Server;\n+    private static String requestURI;\n+\n+    enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n+    private static final String PROP_NAME = \"jdk.internal.httpclient.tcp.selector.useVirtualThreads\";\n+    private static final UseVTForSelector USE_VT_FOR_SELECTOR;\n+    static {\n+        String useVtForSelector =\n+                System.getProperty(PROP_NAME, \"default\");\n+        USE_VT_FOR_SELECTOR = Stream.of(UseVTForSelector.values())\n+                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n+                .findFirst().orElse(UseVTForSelector.DEFAULT);\n+    }\n+\n+    private static boolean isTCPSelectorThreadVirtual() {\n+        return switch (USE_VT_FOR_SELECTOR) {\n+            case ALWAYS -> true;\n+            case NEVER  -> false;\n+            default     -> true;\n+        };\n+    }\n+\n+    @BeforeAll\n+    static void beforeClass() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        \/\/ create a h2 server\n+        h2Server = HttpTestServer.create(HTTP_2, sslContext);\n+        h2Server.addHandler((exchange) -> exchange.sendResponseHeaders(200, 0), \"\/hello\");\n+        h2Server.start();\n+        System.out.println(\"Server started at \" + h2Server.getAddress());\n+        requestURI = \"https:\/\/\" + h2Server.serverAuthority() + \"\/hello\";\n+    }\n+\n+    @AfterAll\n+    static void afterClass() throws Exception {\n+        if (h2Server != null) {\n+            System.out.println(\"Stopping server \" + h2Server.getAddress());\n+            h2Server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Issues various HTTP\/2 requests and verifies the responses are received\n+     *\/\n+    @Test\n+    void testBasicRequests() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .sslContext(sslContext).build()) {\n+            final URI reqURI = new URI(requestURI);\n+            final HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(reqURI);\n+\n+            \/\/ GET\n+            final HttpRequest req1 = reqBuilder.copy().GET().build();\n+            System.out.println(\"\\nIssuing request: \" + req1);\n+            final HttpResponse<?> resp1 = client.send(req1, BodyHandlers.ofString());\n+            Assertions.assertEquals(200, resp1.statusCode(), \"unexpected response code for GET request\");\n+            assertSelectorThread(client);\n+\n+            \/\/ POST\n+            final HttpRequest req2 = reqBuilder.copy().POST(BodyPublishers.ofString(\"foo\")).build();\n+            System.out.println(\"\\nIssuing request: \" + req2);\n+            final HttpResponse<?> resp2 = client.send(req2, BodyHandlers.ofString());\n+            Assertions.assertEquals(200, resp2.statusCode(), \"unexpected response code for POST request\");\n+            assertSelectorThread(client);\n+\n+            \/\/ HEAD\n+            final HttpRequest req3 = reqBuilder.copy().HEAD().build();\n+            System.out.println(\"\\nIssuing request: \" + req3);\n+            final HttpResponse<?> resp3 = client.send(req3, BodyHandlers.ofString());\n+            Assertions.assertEquals(200, resp3.statusCode(), \"unexpected response code for HEAD request\");\n+            assertSelectorThread(client);\n+        }\n+    }\n+\n+    \/\/ This method attempts to determine whether the selector thread\n+    \/\/ is a platform thread or a virtual thread, and throws if expectations\n+    \/\/ ar not met.\n+    \/\/ Since we don't have access to the selector thread, the method\n+    \/\/ uses a roundabout way to figure this out: it enumerates all\n+    \/\/ platform threads, and if it finds a thread whose name matches\n+    \/\/ the expected name of the selector thread it concludes that the\n+    \/\/ selector thread is a platform thread. Otherwise, it assumes\n+    \/\/ that the thread is virtual.\n+    private static void assertSelectorThread(HttpClient client) {\n+        String cname = client.toString();\n+        String clientId = cname.substring(cname.indexOf('(') + 1, cname.length() -1);\n+        String name = \"HttpClient-\" + clientId + \"-SelectorManager\";\n+        Set<String> threads = new HashSet<>(Thread.getAllStackTraces().keySet().stream()\n+                .map(Thread::getName)\n+                .toList());\n+        boolean found = threads.contains(name);\n+        String status = found == isTCPSelectorThreadVirtual() ? \"ERROR\" : \"SUCCESS\";\n+        String propval = System.getProperty(PROP_NAME);\n+        if (propval == null) {\n+            System.out.printf(\"%s not defined, virtual=%s, thread found=%s%n\",\n+                    PROP_NAME, isTCPSelectorThreadVirtual(), found);\n+        } else {\n+            System.out.printf(\"%s=%s, virtual=%s, thread found=%s%n\",\n+                    PROP_NAME, propval, isTCPSelectorThreadVirtual(), found);\n+        }\n+        final String msg;\n+        if (found) {\n+            msg = \"%s found in %s\".formatted(name, threads);\n+            System.out.printf(\"%s: %s%n\", status, msg);\n+        } else {\n+            msg = \"%s not found in %s\".formatted(name, threads);\n+            System.out.printf(\"%s: %s%n\", status, msg);\n+        }\n+        Assertions.assertEquals(!isTCPSelectorThreadVirtual(), found, msg);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2SelectorVTTest.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -97,0 +97,25 @@\n+\/*\n+ * @test id=reno-cc\n+ * @bug 8087112\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run testng\/othervm\/timeout=360 -XX:+CrashOnOutOfMemoryError\n+ *                     -Djdk.httpclient.quic.idleTimeout=120\n+ *                     -Djdk.httpclient.keepalive.timeout.h3=120\n+ *                     -Djdk.test.server.quic.idleTimeout=90\n+ *                     -Djdk.httpclient.quic.minPtoBackoffTime=60\n+ *                     -Djdk.httpclient.quic.maxPtoBackoffTime=120\n+ *                     -Djdk.httpclient.quic.maxPtoBackoff=9\n+ *                     -Djdk.httpclient.http3.maxStreamLimitTimeout=0\n+ *                     -Djdk.httpclient.quic.maxEndpoints=1\n+ *                     -Djdk.httpclient.quic.maxBidiStreams=2\n+ *                     -Djdk.httpclient.retryOnStreamlimit=50\n+ *                     -Djdk.httpclient.HttpClient.log=errors,http3,quic:hs:retransmit\n+ *                     -Dsimpleget.requests=100\n+ *                     -Djdk.internal.httpclient.quic.congestionController=reno\n+ *                     H3MultipleConnectionsToSameHost\n+ * @summary Send 100 large concurrent requests, with connections whose max stream\n+ *          limit is artificially low, in order to cause concurrent connections\n+ *          to the same host to be created, with Reno congestion controller\n+ *\/\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3MultipleConnectionsToSameHost.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -199,0 +199,9 @@\n+    \/\/ This method attempts to determine whether the quic selector thread\n+    \/\/ is a platform thread or a virtual thread, and throws if expectations\n+    \/\/ are not met.\n+    \/\/ Since we don't have access to the quic selector thread, the method\n+    \/\/ uses a roundabout way to figure this out: it enumerates all\n+    \/\/ platform threads, and if it finds a thread whose name matches\n+    \/\/ the expected name of the quic selector thread it concludes that the\n+    \/\/ selector thread is a platform thread. Otherwise, it assumes\n+    \/\/ that the thread is virtual.\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3QuicVTTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import static jdk.httpclient.test.lib.common.HttpServerAdapters.createClientBuilderForH3;\n@@ -103,1 +104,1 @@\n-        try (final HttpClient client = HttpClient.newBuilder()\n+        try (final HttpClient client = createClientBuilderForH3()\n@@ -137,1 +138,1 @@\n-        try (final HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n+        try (final HttpClient client = createClientBuilderForH3().sslContext(sslContext)\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3RequestRejectedTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -151,0 +151,12 @@\n+\/*\n+ * @test id=reno-cc\n+ * @bug 8087112\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.TestUtil\n+ *        jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @run testng\/othervm\/timeout=480 -Djdk.internal.httpclient.quic.congestionController=reno\n+ *                     H3SimpleGet\n+ * @summary send multiple GET requests using Reno congestion controller\n+ *\/\n+\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3SimpleGet.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- *          or IPv6\n+ *          or IPv6, using CUBIC or Reno\n@@ -67,0 +67,5 @@\n+ * @run testng\/othervm\n+ *              -Djdk.internal.httpclient.debug=true\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,errors\n+ *              -Djdk.internal.httpclient.quic.congestionController=reno\n+ *              H3SimpleTest\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3SimpleTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+    public volatile boolean closeConnOnIncomingGoAway = true;\n@@ -540,2 +541,6 @@\n-            System.err.println(server.name + \": Closing connection: \"+ f.toString());\n-            close(ErrorFrame.NO_ERROR);\n+            if (closeConnOnIncomingGoAway) {\n+                System.err.println(server.name + \": Closing connection: \"+ f.toString());\n+                close(ErrorFrame.NO_ERROR);\n+            } else {\n+                System.err.println(server.name + \": Will not close connection for incoming GOAWAY: \" + f);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Deadline;\n+import jdk.internal.net.http.common.TimeLine;\n+import jdk.internal.net.http.quic.*;\n+import jdk.internal.net.http.quic.frames.PaddingFrame;\n+import jdk.internal.net.http.quic.frames.QuicFrame;\n+import jdk.internal.net.http.quic.packets.QuicPacket;\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.TemporalUnit;\n+import java.util.List;\n+\n+import static jdk.internal.net.http.quic.QuicCubicCongestionController.ALPHA;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @run junit\/othervm -Djdk.httpclient.HttpClient.log=trace,quic:cc CubicTest\n+ *\/\n+public class CubicTest {\n+    static class TimeSource implements TimeLine {\n+        final Deadline first = jdk.internal.net.http.common.TimeSource.now();\n+        volatile Deadline current = first;\n+        public synchronized Deadline advance(long duration, TemporalUnit unit) {\n+            return current = current.plus(duration, unit);\n+        }\n+        public Deadline advanceMillis(long millis) {\n+            return advance(millis, ChronoUnit.MILLIS);\n+        }\n+        @Override\n+        public Deadline instant() {\n+            return current;\n+        }\n+    }\n+\n+    private final TimeSource timeSource = new TimeSource();\n+\n+    private class TestQuicPacket implements QuicPacket {\n+        private final int size;\n+\n+        public TestQuicPacket(int size) {\n+            this.size = size;\n+        }\n+\n+        @Override\n+        public List<QuicFrame> frames() {\n+            \/\/ fool congestion controller that this packet is in flight\n+            return List.of(new PaddingFrame(1));\n+        }\n+\n+        @Override\n+        public QuicConnectionId destinationId() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public PacketNumberSpace numberSpace() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public int size() {\n+            return size;\n+        }\n+\n+        @Override\n+        public HeadersType headersType() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+\n+        @Override\n+        public PacketType packetType() {\n+            throw new AssertionError(\"Should not come here\");\n+        }\n+    }\n+\n+    @Test\n+    public void testReduction() {\n+        System.err.println(\"***** testReduction *****\");\n+        QuicRttEstimator rtt = new QuicRttEstimator();\n+        rtt.consumeRttSample(1, 0, Deadline.MIN);\n+        QuicCongestionController cc = new QuicCubicCongestionController(timeSource, rtt);\n+        int packetSize = (int) cc.maxDatagramSize();\n+        assertEquals(cc.initialWindow(), cc.congestionWindow(), \"Unexpected starting congestion window\");\n+        do {\n+            cc.packetSent(packetSize);\n+            \/\/ reduce to 70% of the last value, but not below 2*SMSS\n+            long newCongestionWindow = Math.max((long) (QuicCubicCongestionController.BETA * cc.congestionWindow()), 2 * packetSize);\n+            cc.packetLost(List.of(new TestQuicPacket(packetSize)), Deadline.MAX, false);\n+            assertEquals(newCongestionWindow, cc.congestionWindow(), \"Unexpected reduced congestion window\");\n+        } while (cc.congestionWindow() > 2 * packetSize);\n+    }\n+\n+    @Test\n+    public void testAppLimited() {\n+        System.err.println(\"***** testAppLimited *****\");\n+        QuicRttEstimator rtt = new QuicRttEstimator();\n+        rtt.consumeRttSample(1, 0, Deadline.MIN);\n+        QuicCongestionController cc = new QuicCubicCongestionController(timeSource, rtt);\n+        int packetSize = (int) cc.maxDatagramSize();\n+        assertEquals(cc.initialWindow(), cc.congestionWindow(), \"Unexpected starting congestion window\");\n+        cc.packetSent(packetSize);\n+        long newCongestionWindow = (long) (QuicCubicCongestionController.BETA * cc.congestionWindow());\n+        \/\/ lose packet to exit slow start\n+        cc.packetLost(List.of(new TestQuicPacket(packetSize)), Deadline.MAX, false);\n+        assertEquals(newCongestionWindow, cc.congestionWindow(), \"Unexpected reduced congestion window\");\n+        Deadline sentTime = timeSource.instant().plus(1, ChronoUnit.NANOS);\n+        \/\/ congestion window should not increase when sender is app-limited\n+        cc.packetSent(packetSize);\n+        cc.packetAcked(packetSize, sentTime);\n+        assertEquals(newCongestionWindow, cc.congestionWindow(), \"Unexpected congestion window change\");\n+    }\n+\n+    @Test\n+    public void testRenoFriendly() {\n+        System.err.println(\"***** testRenoFriendly *****\");\n+        QuicRttEstimator rtt = new QuicRttEstimator();\n+        rtt.consumeRttSample(1, 0, Deadline.MIN);\n+        QuicCongestionController cc = new QuicCubicCongestionController(timeSource, rtt);\n+        int packetSize = (int) cc.maxDatagramSize();\n+        assertEquals(cc.initialWindow(), cc.congestionWindow(), \"Unexpected starting congestion window\");\n+        int startingWindow = (int) cc.congestionWindow();\n+        \/\/ lose packet to exit slow start\n+        cc.packetSent(packetSize);\n+        long newCongestionWindow = (long) (QuicCubicCongestionController.BETA * cc.congestionWindow());\n+        cc.packetLost(List.of(new TestQuicPacket(packetSize)), timeSource.instant(), false);\n+        assertEquals(newCongestionWindow, cc.congestionWindow(), \"Unexpected reduced congestion window\");\n+        \/\/ exit loss recovery to start increasing cwnd\n+        Deadline sentTime = timeSource.advanceMillis(1);\n+        do {\n+            \/\/ test that the window increases roughly by ALPHA * maxDatagramSize every RTT\n+            int startingCwnd = (int) cc.congestionWindow();\n+            cc.packetSent(startingCwnd);\n+            \/\/ we ack the entire window in one call; in practice the increase will be slower\n+            \/\/ because cwnd increases (and increase rate reduces) after every call to packetAcked\n+            cc.packetAcked(startingCwnd, sentTime);\n+            long expectedCwnd = (long) (startingCwnd + ALPHA * packetSize);\n+            long actualCwnd = cc.congestionWindow();\n+            assertEquals(expectedCwnd, actualCwnd,  1.0,\n+                    \"actual cwnd not within the expected range\");\n+        } while (cc.congestionWindow() < startingWindow);\n+        \/\/ test that the window increases roughly by maxDatagramSize every RTT after passing cwndPrior\n+        int startingCwnd = (int) cc.congestionWindow();\n+        cc.packetSent(startingCwnd);\n+        cc.packetAcked(startingCwnd, sentTime);\n+        int expectedCwnd = startingCwnd + packetSize;\n+        long actualCwnd = cc.congestionWindow();\n+        assertEquals(expectedCwnd, actualCwnd,  1.0,\n+                \"actual cwnd not within the expected range\");\n+    }\n+\n+    @Test\n+    public void testCubic() {\n+        \/*\n+         Manually created test vector:\n+         - ramp up the congestion window to 36 packets\n+         - trigger congestion; window will be reduced to 25.2 packets, K=3 seconds\n+         - set RTT = 1.5 seconds, advance \"t\" to 1.5 seconds,\n+           send and acknowledge a whole cwnd of data\n+         - cwnd should be back to 36 packets, give or take a few bytes.\n+         *\/\n+        System.err.println(\"***** testCubic *****\");\n+        QuicRttEstimator rtt = new QuicRttEstimator();\n+        rtt.consumeRttSample(1_500_000, 0, Deadline.MIN);\n+        QuicCongestionController cc = new QuicCubicCongestionController(timeSource, rtt);\n+        int packetSize = (int) cc.maxDatagramSize();\n+        long cwnd = cc.congestionWindow();\n+        \/\/ ramp up the congestion window to 36 packets\n+        int tmp = (int) (36 * packetSize - cwnd);\n+        cc.packetSent(tmp + packetSize);\n+        cc.packetAcked(tmp, timeSource.instant());\n+        assertEquals(36*packetSize, cc.congestionWindow(), \"Unexpected congestion window\");\n+        long newCongestionWindow = (long) (QuicCubicCongestionController.BETA * cc.congestionWindow());\n+        \/\/ trigger congestion; window will be reduced to 25.2 packets, K=3 seconds\n+        cc.packetLost(List.of(new TestQuicPacket(packetSize)), timeSource.instant(), false);\n+        assertEquals(newCongestionWindow, cc.congestionWindow(), \"Unexpected reduced congestion window\");\n+        \/\/ advance \"t\" to 1.5 seconds,\n+        Deadline sentTime = timeSource.advanceMillis(1500);\n+        \/\/ send and acknowledge a whole cwnd of data\n+        tmp = (int) cc.congestionWindow();\n+        cc.packetSent(tmp);\n+        \/\/ we ack the entire window in one call; in practice the increase will be slower\n+        \/\/ because cwnd increases (and increase rate reduces) after every call to packetAcked\n+        cc.packetAcked(tmp, sentTime);\n+        long expectedCwnd = 36 * packetSize;\n+        long actualCwnd = cc.congestionWindow();\n+        assertEquals(expectedCwnd, actualCwnd,  1.0,\n+                \"actual cwnd not within the expected range\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/quic\/CubicTest.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -504,0 +504,5 @@\n+            this.close(null);\n+        }\n+\n+        @Override\n+        void close(final Throwable cause) {\n@@ -505,1 +510,1 @@\n-            System.out.println(\"closed: \" + this);\n+            System.out.println(\"closed: \" + this + \" cause: \" + cause);\n@@ -507,0 +512,1 @@\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/ConnectionPoolTest.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -166,0 +166,10 @@\n+        System.out.println(\"Check if PEM decode decodes content correctly\");\n+        final String tmpContent = \"1234567\";\n+        final PEM tmpPem = new PEM(\"ONE\", tmpContent);\n+        if (!Arrays.equals(\n+                Base64.getDecoder().decode(tmpContent),\n+                tmpPem.decode())) {\n+            throw new AssertionError(\"PEM decode error\");\n+        }\n+        System.out.println(\"PASS\");\n+\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -31,2 +32,12 @@\n-import java.security.*;\n-import java.util.*;\n+\n+import jtreg.SkippedException;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n@@ -37,1 +48,7 @@\n-        for (Provider p : Security.getProviders()) {\n+\n+        System.out.println(\"Removing SunPCSC provider from the list (A smartcard might not be installed).\");\n+        final List<Provider> providers = Arrays.stream(Security.getProviders())\n+                .filter(provider -> !provider.getName().equals(\"SunPCSC\"))\n+                .collect(Collectors.toList());\n+\n+        for (Provider p : providers) {\n@@ -40,4 +57,0 @@\n-            if (p.getName().equals(\"SunPCSC\")) {\n-                System.out.println(\"A smartcard might not be installed. Skip test.\");\n-                continue;\n-            }\n","filename":"test\/jdk\/java\/security\/Provider\/NewInstance.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -33,0 +34,1 @@\n+import jtreg.SkippedException;\n@@ -39,3 +41,4 @@\n-            System.out.println(\"LDAP is present, test skipped\");\n-            return;\n-        } catch (ClassNotFoundException ignore) { }\n+            throw new SkippedException(\"LDAP is present\");\n+        } catch (ClassNotFoundException ignore) {\n+            System.err.println(\"Expected: class not found exception \" + ignore.getMessage());\n+        }\n","filename":"test\/jdk\/java\/security\/cert\/CertStore\/NoLDAP.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,4 @@\n- * @summary round trip test NumberFormat\n+ * @bug 4266589 8031145 8164791 8316696 8368001\n+ * @summary NumberFormat round trip testing of parsing and formatting.\n+ *      This test checks 4 factory instances per locale against ~20 numeric inputs.\n+ *      Samples ~1\/4 of the available locales provided by NumberFormat.\n@@ -28,0 +31,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -33,2 +38,4 @@\n-import java.text.ParseException;\n-import java.util.Locale;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Stream;\n@@ -36,3 +43,5 @@\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.fail;\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -47,1 +56,0 @@\n- * \/\/bug472\n@@ -50,20 +58,0 @@\n-    static final boolean STRING_COMPARE = true;\n-    static final boolean EXACT_NUMERIC_COMPARE = false;\n-    static final double MAX_ERROR = 1e-14;\n-    static double max_numeric_error = 0;\n-    static double min_numeric_error = 1;\n-\n-    String localeName, formatName;\n-\n-    @Test\n-    public void TestNumberFormatRoundTrip() {\n-        System.out.println(\"Default Locale\");\n-        localeName = \"Default Locale\";\n-        formatName = \"getInstance\";\n-        doTest(NumberFormat.getInstance());\n-        formatName = \"getNumberInstance\";\n-        doTest(NumberFormat.getNumberInstance());\n-        formatName = \"getCurrencyInstance\";\n-        doTest(NumberFormat.getCurrencyInstance());\n-        formatName = \"getPercentInstance\";\n-        doTest(NumberFormat.getPercentInstance());\n@@ -71,13 +59,1 @@\n-        Locale[] loc = NumberFormat.getAvailableLocales();\n-        for (int i=0; i<loc.length; ++i) {\n-            System.out.println(loc[i].getDisplayName());\n-            localeName = loc[i].toString();\n-            formatName = \"getInstance\";\n-            doTest(NumberFormat.getInstance(loc[i]));\n-            formatName = \"getNumberInstance\";\n-            doTest(NumberFormat.getNumberInstance(loc[i]));\n-            formatName = \"getCurrencyInstance\";\n-            doTest(NumberFormat.getCurrencyInstance(loc[i]));\n-            formatName = \"getPercentInstance\";\n-            doTest(NumberFormat.getPercentInstance(loc[i]));\n-        }\n+    private static final Random RND = RandomFactory.getRandom();\n@@ -85,3 +61,6 @@\n-        System.out.println(\"Numeric error \" +\n-              min_numeric_error + \" to \" +\n-              max_numeric_error);\n+    @ParameterizedTest\n+    @MethodSource\n+    void testNumberFormatRoundTrip(NumberFormat fmt) {\n+        fmt.setMaximumFractionDigits(Integer.MAX_VALUE);\n+        Stream.concat(numbers.stream(), randomNumbers())\n+                .forEach(num -> test(fmt, num));\n@@ -90,27 +69,16 @@\n-    public void doTest(NumberFormat fmt) {\n-        doTest(fmt, Double.NaN);\n-        doTest(fmt, Double.POSITIVE_INFINITY);\n-        doTest(fmt, Double.NEGATIVE_INFINITY);\n-\n-        doTest(fmt, 500);\n-        doTest(fmt, 0);\n-        doTest(fmt, 5555555555555555L);\n-        doTest(fmt, 55555555555555555L);\n-        doTest(fmt, 9223372036854775807L);\n-        doTest(fmt, 9223372036854775808.0);\n-        doTest(fmt, -9223372036854775808L);\n-        doTest(fmt, -9223372036854775809.0);\n-\n-        for (int i=0; i<2; ++i) {\n-            doTest(fmt, randomDouble(1));\n-            doTest(fmt, randomDouble(10000));\n-            doTest(fmt, Math.floor(randomDouble(10000)));\n-            doTest(fmt, randomDouble(1e50));\n-            doTest(fmt, randomDouble(1e-50));\n-            doTest(fmt, randomDouble(1e100));\n-            \/\/ The use of double d such that isInfinite(100d) causes the\n-            \/\/ numeric test to fail with percent formats (bug 4266589).\n-            \/\/ Largest double s.t. 100d < Inf: d=1.7976931348623156E306\n-            doTest(fmt, randomDouble(1e306));\n-            doTest(fmt, randomDouble(1e-323));\n-            doTest(fmt, randomDouble(1e-100));\n+    private void test(NumberFormat fmt, Number num) {\n+        String originalFormatted = fmt.format(num);\n+        Number parsedNum = Assertions.assertDoesNotThrow(() -> fmt.parse(originalFormatted),\n+                \"Failed parse(format(%s))\".formatted(num));\n+        String parsedFormatted = fmt.format(parsedNum);\n+        var equal = originalFormatted.equals(parsedFormatted);\n+        \/\/ Try BigDecimal parsing, if not equal\n+        if (!equal) {\n+            var df = Assertions.assertInstanceOf(DecimalFormat.class, fmt);\n+            df.setParseBigDecimal(true);\n+            parsedNum = Assertions.assertDoesNotThrow(() -> fmt.parse(originalFormatted),\n+                    \"Failed BigDecimal parse(format(%s))\".formatted(num));\n+            parsedFormatted = fmt.format(parsedNum);\n+            df.setParseBigDecimal(false);\n+            Assertions.assertEquals(originalFormatted, parsedFormatted,\n+                    \"Failed to round-trip format(parse(format(%s)))\".formatted(num));\n@@ -118,0 +86,4 @@\n+        \/\/ Numeric mismatch to the amount of 1e-14 is tolerable\n+        var error = proportionalError(num, parsedNum);\n+        Assertions.assertFalse(error > 1e-14,\n+                \"Round tripping %s caused numeric error: %s\".formatted(num, error));\n@@ -120,6 +92,20 @@\n-    \/**\n-     * Return a random value from -range..+range.\n-     *\/\n-    public double randomDouble(double range) {\n-        double a = Math.random();\n-        return (2.0 * range * a) - range;\n+    \/\/ Regular, number, currency, and percent instance per locale\n+    private static Stream<Arguments> testNumberFormatRoundTrip() {\n+        return Stream.concat(\n+                \/\/ Default Locale\n+                Stream.of(\n+                        Arguments.of(NumberFormat.getInstance()),\n+                        Arguments.of(NumberFormat.getNumberInstance()),\n+                        Arguments.of(NumberFormat.getCurrencyInstance()),\n+                        Arguments.of(NumberFormat.getPercentInstance())),\n+                \/\/ ~1000 locales returned from provider.\n+                \/\/ Too expensive to test all locales, so sample a reasonable amount\n+                Arrays.stream(NumberFormat.getAvailableLocales())\n+                        .filter(_ -> RND.nextDouble() < .25)\n+                        .flatMap(loc -> Stream.of(\n+                        Arguments.of(NumberFormat.getInstance(loc)),\n+                        Arguments.of(NumberFormat.getNumberInstance(loc)),\n+                        Arguments.of(NumberFormat.getCurrencyInstance(loc)),\n+                        Arguments.of(NumberFormat.getPercentInstance(loc)))\n+                )\n+        );\n@@ -128,2 +114,31 @@\n-    public void doTest(NumberFormat fmt, double value) {\n-        doTest(fmt, Double.valueOf(value));\n+    \/\/ Fixed set of numbers to test each locale against\n+    private static final List<Number> numbers = List.of(\n+            Double.NaN,\n+            Double.POSITIVE_INFINITY,\n+            Double.NEGATIVE_INFINITY,\n+            500,\n+            0,\n+            5555555555555555L,\n+            55555555555555555L,\n+            9223372036854775807L,\n+            9223372036854775808.0,\n+            -9223372036854775808L,\n+            -9223372036854775809.0\n+    );\n+\n+    \/\/ Compute fresh batch of random numbers per locale\n+    private Stream<Number> randomNumbers() {\n+        return Stream.of(\n+                randomDouble(1),\n+                randomDouble(10000),\n+                Math.floor(randomDouble(10000)),\n+                randomDouble(1e50),\n+                randomDouble(1e-50),\n+                randomDouble(1e100),\n+                \/\/ The use of double d such that isInfinite(100d) causes the\n+                \/\/ numeric test to fail with percent formats (bug 4266589).\n+                \/\/ Largest double s.t. 100d < Inf: d=1.7976931348623156E306\n+                randomDouble(1e306),\n+                randomDouble(1e-323),\n+                randomDouble(1e-100)\n+        );\n@@ -132,2 +147,3 @@\n-    public void doTest(NumberFormat fmt, long value) {\n-        doTest(fmt, Long.valueOf(value));\n+    \/\/ Return a random value from -range..+range.\n+    private static double randomDouble(double range) {\n+        return RND.nextDouble(-range, range);\n@@ -136,1 +152,1 @@\n-    static double proportionalError(Number a, Number b) {\n+    private static double proportionalError(Number a, Number b) {\n@@ -142,88 +158,0 @@\n-\n-    public void doTest(NumberFormat fmt, Number value) {\n-        fmt.setMaximumFractionDigits(Integer.MAX_VALUE);\n-        String s = fmt.format(value), s2 = null;\n-        Number n = null;\n-        String err = \"\";\n-        try {\n-            System.out.println(\"  \" + value + \" F> \" + escape(s));\n-            n = fmt.parse(s);\n-            System.out.println(\"  \" + escape(s) + \" P> \" + n);\n-            s2 = fmt.format(n);\n-            System.out.println(\"  \" + n + \" F> \" + escape(s2));\n-\n-            if (STRING_COMPARE) {\n-                if (!s.equals(s2)) {\n-                    if (fmt instanceof DecimalFormat) {\n-                        System.out.println(\"Text mismatch: expected: \" + s + \", got: \" + s2 + \" --- Try BigDecimal parsing.\");\n-                        ((DecimalFormat)fmt).setParseBigDecimal(true);\n-                        n = fmt.parse(s);\n-                        System.out.println(\"  \" + escape(s) + \" P> \" + n);\n-                        s2 = fmt.format(n);\n-                        System.out.println(\"  \" + n + \" F> \" + escape(s2));\n-                        ((DecimalFormat)fmt).setParseBigDecimal(false);\n-\n-                        if (!s.equals(s2)) {\n-                            err = \"STRING ERROR(DecimalFormat): \";\n-                        }\n-                    } else {\n-                        err = \"STRING ERROR(NumberFormat): \";\n-                    }\n-                }\n-            }\n-\n-            if (EXACT_NUMERIC_COMPARE) {\n-                if (value.doubleValue() != n.doubleValue()) {\n-                    err += \"NUMERIC ERROR: \";\n-                }\n-            } else {\n-                \/\/ Compute proportional error\n-                double error = proportionalError(value, n);\n-\n-                if (error > MAX_ERROR) {\n-                    err += \"NUMERIC ERROR \" + error + \": \";\n-                }\n-\n-                if (error > max_numeric_error) max_numeric_error = error;\n-                if (error < min_numeric_error) min_numeric_error = error;\n-            }\n-\n-            String message = value + typeOf(value) + \" F> \" +\n-                escape(s) + \" P> \" +\n-                n + typeOf(n) + \" F> \" +\n-                escape(s2);\n-            if (err.length() > 0) {\n-                fail(\"*** \" + err + \" with \" +\n-                      formatName + \" in \" + localeName +\n-                      \" \" + message);\n-            } else {\n-                System.out.println(message);\n-            }\n-        } catch (ParseException e) {\n-            fail(\"*** \" + e.toString() + \" with \" +\n-                  formatName + \" in \" + localeName);\n-        }\n-    }\n-\n-    static String typeOf(Number n) {\n-        if (n instanceof Long) return \" Long\";\n-        if (n instanceof Double) return \" Double\";\n-        return \" Number\";\n-    }\n-\n-    static String escape(String s) {\n-        StringBuffer buf = new StringBuffer();\n-        for (int i=0; i<s.length(); ++i) {\n-            char c = s.charAt(i);\n-            if (c < (char)0xFF) {\n-                buf.append(c);\n-            } else {\n-                buf.append(\"\\\\U\");\n-                buf.append(Integer.toHexString((c & 0xF000) >> 12));\n-                buf.append(Integer.toHexString((c & 0x0F00) >> 8));\n-                buf.append(Integer.toHexString((c & 0x00F0) >> 4));\n-                buf.append(Integer.toHexString(c & 0x000F));\n-            }\n-        }\n-        return buf.toString();\n-    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberRoundTrip.java","additions":98,"deletions":170,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8370887\n+ * @summary Test that cancelling a delayed task doesn't impact the ordering that other\n+ *     delayed tasks execute\n+ *\/\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedTransferQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class AscendingOrderAfterReplace {\n+\n+    private static final int[] DELAYS_IN_MS = { 3000, 3400, 3900, 3800, 3700, 3600, 3430, 3420, 3310, 3500, 3200 };\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 1; i < DELAYS_IN_MS.length; i++) {\n+            System.out.println(\"=== Test \" + i + \" ===\");\n+            while (!testCancel(DELAYS_IN_MS, i)) { }\n+        }\n+    }\n+\n+    \/**\n+     * Schedule the delayed tasks, cancel one of them, and check that the remaining tasks\n+     * execute in the ascending order of delay.\n+     * @return true if the test passed, false if a retry is needed\n+     * @throws RuntimeException if the test fails\n+     *\/\n+    private static boolean testCancel(int[] delays, int indexToCancel) throws Exception {\n+        log(\"Delayed tasks: \" + toString(delays));\n+\n+        \/\/ delayed tasks add to this queue when they execute\n+        var queue = new LinkedTransferQueue<Integer>();\n+\n+        \/\/ pool with one thread to ensure that delayed tasks don't execute concurrently\n+        try (var pool = new ForkJoinPool(1)) {\n+            long startNanos = System.nanoTime();\n+            Future<?>[] futures = Arrays.stream(delays)\n+                    .mapToObj(d -> pool.schedule(() -> {\n+                        log(\"Triggered \" + d);\n+                        queue.add(d);\n+                    }, d, MILLISECONDS))\n+                    .toArray(Future[]::new);\n+            long endNanos = System.nanoTime();\n+            log(\"Delayed tasks submitted\");\n+\n+            \/\/ check submit took < min diffs between two delays\n+            long submitTime = Duration.ofNanos(endNanos - startNanos).toMillis();\n+            long minDiff = minDifference(delays);\n+            if (submitTime >= minDiff) {\n+                log(\"Submit took >= \" + minDiff + \" ms, need to retry\");\n+                pool.shutdownNow();\n+                return false;\n+            }\n+\n+            \/\/ give a bit of time for -delayScheduler thread to process pending tasks\n+            Thread.sleep(minValue(delays) \/ 2);\n+            log(\"Cancel \" + delays[indexToCancel]);\n+            futures[indexToCancel].cancel(true);\n+        }\n+\n+        \/\/ delayed tasks should have executed in ascending order of their delay\n+        int[] executed = queue.stream().mapToInt(Integer::intValue).toArray();\n+        log(\"Executed: \" + toString(executed));\n+        if (!isAscendingOrder(executed)) {\n+            throw new RuntimeException(\"Not in ascending order!\");\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Return the minimum element.\n+     *\/\n+    private static int minValue(int[] array) {\n+        return IntStream.of(array).min().orElseThrow();\n+    }\n+\n+    \/**\n+     * Return the minimum difference between any two elements.\n+     *\/\n+    private static int minDifference(int[] array) {\n+        int[] sorted = array.clone();\n+        Arrays.sort(sorted);\n+        return IntStream.range(1, sorted.length)\n+                .map(i -> sorted[i] - sorted[i - 1])\n+                .min()\n+                .orElse(0);\n+    }\n+\n+    \/**\n+     * Return true if the array is in ascending order.\n+     *\/\n+    private static boolean isAscendingOrder(int[] array) {\n+        return IntStream.range(1, array.length)\n+                .allMatch(i -> array[i - 1] <= array[i]);\n+    }\n+\n+    \/**\n+     * Returns a String containing the elements of an array in index order.\n+     *\/\n+    private static String toString(int[] array) {\n+        return IntStream.of(array)\n+                .mapToObj(Integer::toString)\n+                .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+    }\n+\n+    private static void log(String message) {\n+        System.out.println(Instant.now() + \" \" + message);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/DelayScheduler\/AscendingOrderAfterReplace.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.HashMap;\n@@ -881,0 +882,18 @@\n+    public void testMapEqualsIfClassCastExceptionOccurs() {\n+        class MonotypeKeyMap extends HashMap<Byte, Object> {\n+            @Override public Object get(Object key) {\n+                return super.get((Byte)key); \/\/ Force cast, allowed by spec\n+            }\n+        }\n+\n+        var mkm = new MonotypeKeyMap();\n+        mkm.put((byte)1, \"value1\");\n+        var similar = new ConcurrentHashMap<Byte, Object>();\n+        similar.put((byte)1, \"value1\");\n+        var different = new ConcurrentHashMap<String, String>();\n+        different.put(\"test1\", \"value1\");\n+\n+        assertTrue(similar.equals(mkm));\n+        assertFalse(different.equals(mkm));\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ConcurrentHashMapTest.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -338,2 +338,2 @@\n-        class SortedEmptySpliterator implements Spliterator<Object> {\n-            final Comparator<Object> c;\n+        class SortedEmptySpliterator<T extends Comparable<? super T>> implements Spliterator<T> {\n+            final Comparator<T> c;\n@@ -341,1 +341,1 @@\n-            SortedEmptySpliterator(Comparator<Object> c) {\n+            SortedEmptySpliterator(Comparator<T> c) {\n@@ -346,1 +346,1 @@\n-            public Spliterator<Object> trySplit() {\n+            public Spliterator<T> trySplit() {\n@@ -351,1 +351,1 @@\n-            public boolean tryAdvance(Consumer<? super Object> action) {\n+            public boolean tryAdvance(Consumer<? super T> action) {\n@@ -366,1 +366,1 @@\n-            public Comparator<? super Object> getComparator() {\n+            public Comparator<? super T> getComparator() {\n@@ -369,1 +369,1 @@\n-        };\n+        }\n@@ -372,1 +372,1 @@\n-            int flags = StreamOpFlag.fromCharacteristics(new SortedEmptySpliterator(null));\n+            int flags = StreamOpFlag.fromCharacteristics(new SortedEmptySpliterator<>(null));\n@@ -377,1 +377,1 @@\n-            int flags = StreamOpFlag.fromCharacteristics(new SortedEmptySpliterator((a, b) -> 0));\n+            int flags = StreamOpFlag.fromCharacteristics(new SortedEmptySpliterator<>((a, b) -> 0));\n@@ -380,0 +380,5 @@\n+\n+        {\n+            int flags = StreamOpFlag.fromCharacteristics(new SortedEmptySpliterator<String>(Comparator.naturalOrder()));\n+            assertEquals(flags, StreamOpFlag.IS_SORTED);\n+        }\n","filename":"test\/jdk\/java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/StreamOpFlagsTest.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Comparator;\n@@ -118,0 +119,1 @@\n+        assertSorted(to10.stream().sorted(Comparator.naturalOrder()).iterator());\n@@ -122,0 +124,3 @@\n+        s = to10.stream().sorted(Comparator.naturalOrder()).spliterator();\n+        assertTrue(s.hasCharacteristics(Spliterator.SORTED));\n+\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SortedOpTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -193,0 +193,1 @@\n+            System.out.println(\"Connection established on port : \" +serverPort);\n@@ -231,0 +232,1 @@\n+            System.out.println(\"Connection closed on port : \" +serverPort);\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8372103\n+ * @summary Verifies Metal JButton show focus even if there's no text or icon\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MetalFocusBug\n+ *\/\n+\n+import java.awt.Color;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.plaf.ColorUIResource;\n+import javax.swing.UIManager;\n+\n+public class MetalFocusBug {\n+\n+    static final String INSTRUCTIONS = \"\"\"\n+        A JFrame is shown with 2 JButtons.\n+        A button \"Top\" at TOP and\n+        another button with empty text and without icon at the bottom.\n+        Initially the focus is at the \"TOP\" button.\n+        Verify that Red color focus rectangle is around the \"TOP\" text.\n+        Press \"Tab\" key and verify the bottom button gets focus via\n+        red color focus rectangle.\n+        If red color focus rectangle is seen at the bottom button,\n+        press Pass else press Fail.\n+    \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Set Metal L&F\n+        UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(40)\n+                .testUI(MetalFocusBug::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    static JFrame createUI() {\n+        \/\/ Make focus rectangle very obvious.\n+        UIManager.put(\"Button.focus\", new ColorUIResource(Color.RED));\n+        JFrame frame = new JFrame(\"MetalFocusBug\");\n+        frame.getContentPane().add(new JButton(\"TOP\"), \"North\");\n+        frame.getContentPane().add(new JButton(\"\"), \"Center\");\n+        frame.setSize(300, 300);\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/metal\/MetalFocusBug.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+ *      8367585\n@@ -55,0 +56,2 @@\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n@@ -59,0 +62,1 @@\n+import java.util.stream.Stream;\n@@ -64,0 +68,1 @@\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -66,0 +71,2 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -450,0 +457,69 @@\n+\n+    static List<String> legalStrings() {\n+        var empty = \"\";\n+        var allAscii = \"e\".repeat(0xFFFF);\n+        \/\/ 3-byte utf8 characters\n+        var largeChars = String.valueOf((char) 0x800).repeat(0xFFFF \/ 3);\n+        return List.of(empty, allAscii, largeChars);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"legalStrings\")\n+    void testStringLengthInLimit(String st) {\n+        TemporaryConstantPool.INSTANCE.utf8Entry(st);\n+        ConstantPoolBuilder.of().utf8Entry(st);\n+    }\n+\n+    static List<String> oversizedStrings() {\n+        var allAscii = \"e\".repeat(0x10000);\n+        \/\/ 3-byte utf8 characters\n+        var largeChars = String.valueOf((char) 0x800).repeat(0xFFFF \/ 3 + 1);\n+        return List.of(allAscii, largeChars);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"oversizedStrings\")\n+    void testStringLengthOverLimit(String st) {\n+        assertThrows(IllegalArgumentException.class, () -> TemporaryConstantPool.INSTANCE.utf8Entry(st));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantPoolBuilder.of().utf8Entry(st));\n+    }\n+\n+    static Stream<ConstantPoolBuilder> pools() {\n+        return Stream.of(ConstantPoolBuilder.of(), TemporaryConstantPool.INSTANCE);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testSingleReferenceNominalDescriptorOverLimit(ConstantPoolBuilder cpb) {\n+        var fittingName = \"A\" + \"a\".repeat(65532); \/\/ fits \"enveloped\" L ;\n+        var borderName = \"B\" + \"b\".repeat(65534); \/\/ fits only \"not enveloped\"\n+        var overflowName = \"C\" + \"b\".repeat(65535); \/\/ nothing fits\n+\n+        var fittingClassDesc = ClassDesc.of(fittingName);\n+        var borderClassDesc = ClassDesc.of(borderName);\n+        var overflowClassDesc = ClassDesc.of(overflowName);\n+        cpb.classEntry(fittingClassDesc);\n+        cpb.utf8Entry(fittingClassDesc);\n+        cpb.classEntry(borderClassDesc);\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(borderClassDesc));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.classEntry(overflowClassDesc));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(overflowClassDesc));\n+\n+        cpb.packageEntry(PackageDesc.of(borderName));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.packageEntry(PackageDesc.of(overflowName)));\n+        cpb.moduleEntry(ModuleDesc.of(borderName));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.moduleEntry(ModuleDesc.of(overflowName)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testMethodTypeDescOverLimit(ConstantPoolBuilder cpb) {\n+        var borderReturnMtd = MethodTypeDesc.of(ClassDesc.of(\"R\" + \"r\".repeat(65530)));\n+        var overflowReturnMtd = MethodTypeDesc.of(ClassDesc.of(\"R\" + \"r\".repeat(65531)));\n+        var borderParamMtd = MethodTypeDesc.of(CD_void, ClassDesc.of(\"P\" + \"p\".repeat(65529)));\n+        var overflowParamMtd = MethodTypeDesc.of(CD_void, ClassDesc.of(\"P\" + \"p\".repeat(65530)));\n+        cpb.utf8Entry(borderParamMtd);\n+        cpb.utf8Entry(borderReturnMtd);\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(overflowReturnMtd));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.utf8Entry(overflowParamMtd));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8321540 8319463 8357955 8368050 8368331\n+ * @bug 8321540 8319463 8357955 8368050 8367585 8368331\n@@ -31,0 +31,1 @@\n+import java.lang.classfile.attribute.SignatureAttribute;\n@@ -38,0 +39,1 @@\n+import java.util.Collections;\n@@ -55,0 +57,1 @@\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -56,2 +59,0 @@\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n@@ -273,41 +274,40 @@\n-    @Test\n-    void testBadTypeSignatures() {\n-        \"\"\"\n-        LObject\n-        LObject;B\n-        LIterable<LFoo>\n-        LIterable<<\n-        TBar\n-        TBar<LFoo;>\n-        B<LFoo;>\n-        B<LFoo;>;V\n-        X\n-        [LObject\n-        [LIterable<LFoo>\n-        [LIterable<<\n-        [TBar\n-        [TBar<LFoo;>\n-        [B<LFoo;>\n-        [X\n-        LSet<+Kind<**>;>;\n-        LSet<?Kind<*>;>;\n-        ()V\n-        Ljava\/util\/Opt<Ljava\/lang\/Integer;>ional;\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>.package\/Inner<[I>;\n-        LSample>;\n-        LSample:Other;\n-        LOuter<[JTT;>.[Inner;\n-        TA:J;\n-        LEmpty<>;\n-        L\n-        Lcom\n-        Lcom\/example\/\n-        Lcom\/example\/Outer<\n-        Lcom\/example\/Outer<Ljava\/\n-        Lcom\/example\/Outer<Ljava\/lang\/String\n-        Lcom\/example\/Outer<Ljava\/lang\/String;\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>.\n-        Lcom\/example\/Outer<Ljava\/lang\/String;>.Inner<[I>\n-        [V\n-        \"\"\".lines().forEach(assertThrows(Signature::parseFrom));\n+    static Stream<String> badTypeSignatures() {\n+        return \"\"\"\n+                LObject\n+                LObject;B\n+                LIterable<LFoo>\n+                LIterable<<\n+                TBar\n+                TBar<LFoo;>\n+                B<LFoo;>\n+                B<LFoo;>;V\n+                X\n+                [LObject\n+                [LIterable<LFoo>\n+                [LIterable<<\n+                [TBar\n+                [TBar<LFoo;>\n+                [B<LFoo;>\n+                [X\n+                LSet<+Kind<**>;>;\n+                LSet<?Kind<*>;>;\n+                ()V\n+                Ljava\/util\/Opt<Ljava\/lang\/Integer;>ional;\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>.package\/Inner<[I>;\n+                LSample>;\n+                LSample:Other;\n+                LOuter<[JTT;>.[Inner;\n+                TA:J;\n+                LEmpty<>;\n+                L\n+                Lcom\n+                Lcom\/example\/\n+                Lcom\/example\/Outer<\n+                Lcom\/example\/Outer<Ljava\/\n+                Lcom\/example\/Outer<Ljava\/lang\/String\n+                Lcom\/example\/Outer<Ljava\/lang\/String;\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>.\n+                Lcom\/example\/Outer<Ljava\/lang\/String;>.Inner<[I>\n+                [V\n+                \"\"\".lines();\n@@ -316,9 +316,4 @@\n-    @Test\n-    void testGoodTypeSignatures() {\n-        \"\"\"\n-        Ljava\/util\/Optional<Ljava\/lang\/Integer;>;\n-        Lcom\/example\/Outer<Ljava\/lang\/Integer;>.Inner<[I>;\n-        LSample;\n-        LOuter<[JTT;>.Inner;\n-        LOuter.Inner;\n-        \"\"\".lines().forEach(Signature::parseFrom);\n+    @ParameterizedTest\n+    @MethodSource(\"badTypeSignatures\")\n+    void testBadTypeSignatures(String s) {\n+        assertThrows(IllegalArgumentException.class, () -> Signature.parseFrom(s));\n@@ -327,27 +322,8 @@\n-    @Test\n-    void testBadClassSignatures() {\n-        \"\"\"\n-        Ljava\/lang\/Object;Ljava\/lang\/Iterable<LFoo;>\n-        LObject\n-        LObject;B\n-        LIterable<LFoo>\n-        LIterable<<\n-        TBar\n-        TBar<LFoo;>\n-        B<LFoo;>\n-        B<LFoo;>;V\n-        X\n-        LFoo<TK;>.It;L\n-        <K+LObject;>LFoo<TK;;>;LFoo<TK;>;LBar;\n-        <K:LObject;>>LFoo<TK;>;\n-        <K:LObject;>LFoo<+>;\n-        ()V\n-        <K:Ljava\/lang\/Object;>Ljava\/lang\/Object;TK;\n-        Ljava\/lang\/Object;[Ljava\/lang\/Object;\n-        [Ljava\/util\/Optional<[I>;\n-        [I\n-        <K:Ljava\/lang\/Object;>TK;\n-        <K;Q:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n-        <:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n-        <>Ljava\/lang\/Object;\n-        \"\"\".lines().forEach(assertThrows(ClassSignature::parseFrom));\n+    static Stream<String> goodTypeSignatures() {\n+        return \"\"\"\n+                Ljava\/util\/Optional<Ljava\/lang\/Integer;>;\n+                Lcom\/example\/Outer<Ljava\/lang\/Integer;>.Inner<[I>;\n+                LSample;\n+                LOuter<[JTT;>.Inner;\n+                LOuter.Inner;\n+                \"\"\".lines();\n@@ -356,25 +332,70 @@\n-    @Test\n-    void testBadMethodSignatures() {\n-        \"\"\"\n-        LObject;\n-        B\n-        ()V^\n-        ()V^B\n-        ()V^X\n-        (LObject;)\n-        (LObject)V\n-        ()LIterable<LFoo>\n-        ()LIterable<<\n-        ()TBar\n-        ()TBar;B\n-        (TBar<LFoo;>)V\n-        (B<LFoo;>)V\n-        (X)\n-        ()X\n-        ()VB\n-        ()LSet<+Kind<**>;>;\n-        (LSet<?Kind<*>;>;)V\n-        <T::LA>()V\n-        (TT;I)VI\n-        (V)V\n-        \"\"\".lines().forEach(assertThrows(MethodSignature::parseFrom));\n+    @ParameterizedTest\n+    @MethodSource(\"goodTypeSignatures\")\n+    void testGoodTypeSignature(String s) {\n+        Signature.parseFrom(s);\n+    }\n+\n+    static Stream<String> badClassSignatures() {\n+        return \"\"\"\n+                Ljava\/lang\/Object;Ljava\/lang\/Iterable<LFoo;>\n+                LObject\n+                LObject;B\n+                LIterable<LFoo>\n+                LIterable<<\n+                TBar\n+                TBar<LFoo;>\n+                B<LFoo;>\n+                B<LFoo;>;V\n+                X\n+                LFoo<TK;>.It;L\n+                <K+LObject;>LFoo<TK;;>;LFoo<TK;>;LBar;\n+                <K:LObject;>>LFoo<TK;>;\n+                <K:LObject;>LFoo<+>;\n+                ()V\n+                <K:Ljava\/lang\/Object;>Ljava\/lang\/Object;TK;\n+                Ljava\/lang\/Object;[Ljava\/lang\/Object;\n+                [Ljava\/util\/Optional<[I>;\n+                [I\n+                <K:Ljava\/lang\/Object;>TK;\n+                <K;Q:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+                <:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+                <>Ljava\/lang\/Object;\n+                \"\"\".lines();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badClassSignatures\")\n+    void testBadClassSignature(String s) {\n+        assertThrows(IllegalArgumentException.class, () -> ClassSignature.parseFrom(s));\n+    }\n+\n+    static Stream<String> badMethodSignatures() {\n+        return \"\"\"\n+                LObject;\n+                B\n+                ()V^\n+                ()V^B\n+                ()V^X\n+                (LObject;)\n+                (LObject)V\n+                ()LIterable\n+                ()LIterable\n+                ()TBar\n+                ()TBar;B\n+                (TBar<LFoo;\n+                (B<LFoo;>)V\n+                (X)\n+                ()X\n+                ()VB\n+                ()LSet<+Kin\n+                (LSet<?Kind\n+                <T::LA>()V\n+                (TT;I)VI\n+                (V)V\n+                \"\"\".lines();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badMethodSignatures\")\n+    void testBadMethodSignature(String s) {\n+        assertThrows(IllegalArgumentException.class, () -> MethodSignature.parseFrom(s));\n@@ -388,1 +409,1 @@\n-            Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, sig));\n+            assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, sig));\n@@ -390,1 +411,1 @@\n-            Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, arrSig));\n+            assertThrows(IllegalArgumentException.class, () -> Signature.ArrayTypeSig.of(dim, arrSig));\n@@ -397,2 +418,62 @@\n-    private Consumer<String> assertThrows(Function<String, ?> parser) {\n-        return s -> Assertions.assertThrows(IllegalArgumentException.class, () -> parser.apply(s), s);\n+    static Stream<Signature> longTypeSignatures() {\n+        var longAsciiName = \"A\" + \"a\".repeat(65536);\n+        var longCharName = \"Â§\".repeat(32768);\n+        var simpleClassSig = ClassTypeSig.of(longAsciiName);\n+        var nestedSig = ClassTypeSig.of(simpleClassSig, longCharName);\n+        var typeVarSig = TypeVarSig.of(longCharName);\n+        var parameterizedSig = ClassTypeSig.of(longCharName, TypeArg.of(nestedSig), TypeArg.unbounded());\n+        var parameterizedNestedSig = ClassTypeSig.of(nestedSig, longAsciiName, TypeArg.superOf(simpleClassSig));\n+        return Stream.of(simpleClassSig, nestedSig, typeVarSig, parameterizedSig, parameterizedNestedSig);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"longTypeSignatures\")\n+    void testLongTypeSignature(Signature sig) {\n+        var st = sig.signatureString();\n+        Signature.parseFrom(st); \/\/ Valid signature\n+        assertThrows(IllegalArgumentException.class, () -> SignatureAttribute.of(sig)); \/\/ Cannot write to class\n+    }\n+\n+    static Stream<ClassSignature> longClassSignatures() {\n+        var longAsciiName = \"A\" + \"a\".repeat(65536);\n+        var longCharName = \"Â§\".repeat(32768);\n+        var simpleClassSig = ClassTypeSig.of(longAsciiName);\n+        var longSuperClass = ClassSignature.of(simpleClassSig);\n+        var longNameParam = TypeParam.of(longCharName, ClassTypeSig.of(CD_String));\n+        var longBoundParam = TypeParam.of(\"T\", simpleClassSig);\n+        var longNameParamClass = ClassSignature.of(List.of(longNameParam), ClassTypeSig.of(CD_Object));\n+        var longBoundParamClass = ClassSignature.of(List.of(longBoundParam), ClassTypeSig.of(CD_Number));\n+        return Stream.of(longSuperClass, longNameParamClass, longBoundParamClass);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"longClassSignatures\")\n+    void testLongClassSignature(ClassSignature sig) {\n+        var st = sig.signatureString();\n+        ClassSignature.parseFrom(st); \/\/ Valid signature\n+        assertThrows(IllegalArgumentException.class, () -> SignatureAttribute.of(sig)); \/\/ Cannot write to class\n+    }\n+\n+    static Stream<MethodSignature> longMethodSignatures() {\n+        var longAsciiName = \"A\" + \"a\".repeat(65536);\n+        var longCharName = \"Â§\".repeat(32768);\n+        var simpleClassSig = ClassTypeSig.of(longAsciiName);\n+        var longNameTypeVar = TypeVarSig.of(longCharName);\n+        var longReturnMethod = MethodSignature.of(simpleClassSig);\n+        var longNameParam = TypeParam.of(longCharName, ClassTypeSig.of(CD_String));\n+        var longNameParamMethod = MethodSignature.of(List.of(longNameParam), List.of(), BaseTypeSig.of(CD_void));\n+        var longThrowMethod = MethodSignature.of(List.of(), List.of(longNameTypeVar), ClassTypeSig.of(CD_Number));\n+        var longParameterMethod = MethodSignature.of(BaseTypeSig.of(CD_int), simpleClassSig);\n+\n+        var eachParameter = ClassTypeSig.of(\"A\" + \"a\".repeat(250));\n+        var parameterArray = Collections.nCopies(300, eachParameter).toArray(Signature[]::new);\n+        var manyParameterMethod = MethodSignature.of(BaseTypeSig.of(CD_void), parameterArray);\n+        return Stream.of(longReturnMethod, longNameParamMethod, longThrowMethod, longParameterMethod, manyParameterMethod);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"longMethodSignatures\")\n+    void testLongMethodSignature(MethodSignature sig) {\n+        var st = sig.signatureString();\n+        MethodSignature.parseFrom(st); \/\/ Valid signature\n+        assertThrows(IllegalArgumentException.class, () -> SignatureAttribute.of(sig)); \/\/ Cannot write to class\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":190,"deletions":109,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8335935 8336588\n+ * @bug 8335935 8336588 8372047\n@@ -32,14 +32,4 @@\n-import java.lang.classfile.ClassBuilder;\n-import java.lang.classfile.ClassElement;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassTransform;\n-import java.lang.classfile.CodeBuilder;\n-import java.lang.classfile.CodeElement;\n-import java.lang.classfile.CodeModel;\n-import java.lang.classfile.CodeTransform;\n-import java.lang.classfile.FieldModel;\n-import java.lang.classfile.FieldTransform;\n-import java.lang.classfile.Label;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.AnnotationDefaultAttribute;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.attribute.SourceDebugExtensionAttribute;\n@@ -58,0 +48,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -60,0 +51,1 @@\n+import jdk.internal.classfile.impl.TransformImpl;\n@@ -338,0 +330,50 @@\n+\n+    @Test\n+    void testFilteringTransformChaining() {\n+        var cf = ClassFile.of();\n+        var clazz = cf.parse(cf.build(ClassDesc.of(\"Test\"), clb -> clb\n+                .withField(\"one\", CD_int, fb -> fb.with(ConstantValueAttribute.of(1)))\n+                .withField(\"two\", CD_int, fb -> fb.with(ConstantValueAttribute.of(2)))\n+                .withMethod(\"one\", MTD_void, 0, mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))).withCode(CodeBuilder::return_))\n+                .withMethod(\"two\", MTD_void, 0, mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(2))).withCode(CodeBuilder::return_))));\n+\n+        AtomicBoolean oneFieldCalled = new AtomicBoolean(false);\n+        var oneFieldTransform = new TransformImpl.ClassFieldTransform((fb, fe) -> {\n+            if (fe instanceof ConstantValueAttribute cv) {\n+                assertEquals(1, ((Integer) cv.constant().constantValue()), \"Should only transform one\");\n+            }\n+            oneFieldCalled.set(true);\n+            fb.with(fe);\n+        }, fm -> fm.fieldName().equalsString(\"one\"));\n+        AtomicBoolean twoFieldCalled = new AtomicBoolean(false);\n+        var twoFieldTransform = new TransformImpl.ClassFieldTransform((fb, fe) -> {\n+            if (fe instanceof ConstantValueAttribute cv) {\n+                assertEquals(2, ((Integer) cv.constant().constantValue()), \"Should only transform two\");\n+            }\n+            twoFieldCalled.set(true);\n+            fb.with(fe);\n+        }, fm -> fm.fieldName().equalsString(\"two\"));\n+        cf.transformClass(clazz, oneFieldTransform.andThen(twoFieldTransform));\n+        assertTrue(oneFieldCalled.get(), \"Field one not transformed\");\n+        assertTrue(twoFieldCalled.get(), \"Field two not transformed\");\n+\n+        AtomicBoolean oneMethodCalled = new AtomicBoolean(false);\n+        var oneMethodTransform = ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(\"one\"), (mb, me) -> {\n+            if (me instanceof AnnotationDefaultAttribute ada) {\n+                assertEquals(1, ((AnnotationValue.OfInt) ada.defaultValue()).intValue(), \"Should only transform one\");\n+            }\n+            oneMethodCalled.set(true);\n+            mb.with(me);\n+        });\n+        AtomicBoolean twoMethodCalled = new AtomicBoolean(false);\n+        var twoMethodTransform = ClassTransform.transformingMethods(mm -> mm.methodName().equalsString(\"two\"), (mb, me) -> {\n+            if (me instanceof AnnotationDefaultAttribute ada) {\n+                assertEquals(2, ((AnnotationValue.OfInt) ada.defaultValue()).intValue(), \"Should only transform two\");\n+            }\n+            twoMethodCalled.set(true);\n+            mb.with(me);\n+        });\n+        cf.transformClass(clazz, oneMethodTransform.andThen(twoMethodTransform));\n+        assertTrue(oneMethodCalled.get(), \"Method one not transformed\");\n+        assertTrue(twoMethodCalled.get(), \"Method two not transformed\");\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":58,"deletions":16,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -107,13 +107,0 @@\n-        BufWriterImpl bufWriter = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n-        Method writeUtfEntry = bufWriter.getClass().getDeclaredMethod(\"writeUtfEntry\", String.class);\n-        writeUtfEntry.setAccessible(true);\n-        try {\n-            writeUtfEntry.invoke(bufWriter, largeString);\n-            throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n-        } catch (InvocationTargetException e) {\n-            Throwable cause = e.getCause();\n-            if (!(cause instanceof IllegalArgumentException)) {\n-                throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n-            }\n-        }\n-\n","filename":"test\/jdk\/jdk\/internal\/util\/ModifiedUtfTest.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.reflect.Field;\n@@ -126,10 +125,2 @@\n-    private static Field valueField;\n-\n-    static {\n-        try {\n-            valueField = String.class.getDeclaredField(\"value\");\n-            valueField.setAccessible(true);\n-        } catch (Exception exception) {\n-            throw new RuntimeException(exception);\n-        }\n-    }\n+    static volatile String string;\n+    static volatile String duplicateString;\n@@ -145,3 +136,2 @@\n-            String base = TestStringDeduplicationEvent.class.getSimpleName();\n-            String duplicate = new StringBuilder(base).toString();\n-            assert(getValue(base) != getValue(duplicate));\n+            string = TestStringDeduplicationEvent.class.getSimpleName();\n+            duplicateString = new StringBuilder(string).toString();\n@@ -160,8 +150,0 @@\n-    private static Object getValue(String string) {\n-        try {\n-            return valueField.get(string);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestStringDeduplicationEvent.java","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @run main\/othervm -XX:CompileCommand=compileonly,jdk.test.lib.jfr.RecurseThread::recurse* -XX:+PreserveFramePointer jdk.jfr.event.profiling.TestFullStackTrace\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestFullStackTrace.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+                        System.out.println(\"Class loader\" + e);\n@@ -90,0 +91,6 @@\n+            \/\/ When jdk.PhysicalMemory is expected to be emitted:\n+            \/\/ Chunk 1: begin, end\n+            \/\/ Chunk 2: begin, end\n+            \/\/ Chunk 3: begin, end\n+            \/\/ Chunk 4: begin, end\n+            assertCount(r1, \"jdk.PhysicalMemory\", physicalMemory, 2 * chunkFiles);\n@@ -96,8 +103,2 @@\n-            assertCount(\"jdk.ThreadDump\", threadDumps, 2 + 2 + (chunkFiles - 2));\n-            assertCount(\"jdk.ClassLoaderStatistics\", classLoaderStatistics, 2 + 2 + (chunkFiles - 2));\n-            \/\/ When jdk.PhysicalMemory is expected to be emitted:\n-            \/\/ Chunk 1: begin, end\n-            \/\/ Chunk 2: begin, end\n-            \/\/ Chunk 3: begin, end\n-            \/\/ Chunk 4: begin, end\n-            assertCount(\"jdk.PhysicalMemory\", physicalMemory, 2 * chunkFiles);\n+            assertCount(r1, \"jdk.ThreadDump\", threadDumps, 2 + 2 + (chunkFiles - 2));\n+            assertCount(r1, \"jdk.ClassLoaderStatistics\", classLoaderStatistics, 2 + 2 + (chunkFiles - 2));\n@@ -112,1 +113,1 @@\n-    private static void assertCount(String eventName, Set<Instant> timestamps, long expected) throws Exception {\n+    private static void assertCount(RecordingStream stream, String eventName, Set<Instant> timestamps, long expected) throws Exception {\n@@ -119,0 +120,2 @@\n+            System.out.println(\"Dumping failure file.\");\n+            stream.dump(Path.of(\"failure.jfr\"));\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestBackToBackSensitive.java","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -82,0 +82,3 @@\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"java.lang.Object\", null),    \"binary name\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"L[a;\", null),                \"bad class or interface\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"Ljava.lang.Object;\", null),  \"bad class or interface\");\n@@ -83,0 +86,3 @@\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"L;\", null),                  \"empty name\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"Lmissing\/;\", null),          \"empty name part\");\n+        assertThrows(IllegalArgumentException.class, () -> BytecodeDescriptor.parseClass(\"L\/Missing;\", null),          \"empty name part\");\n@@ -113,0 +119,15 @@\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(Ljava.lang.Object;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(Ljava\/lang[Object;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(L;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(Ljava\/lang\/;)V\", null),\n+                     \"bad arg\");\n+        assertThrows(IllegalArgumentException.class,\n+                     () -> BytecodeDescriptor.parseMethod(\"(L\/Object;)V\", null),\n+                     \"bad arg\");\n","filename":"test\/jdk\/sun\/invoke\/util\/BytecodeDescriptorTest.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import jtreg.SkippedException;\n+\n@@ -35,2 +37,5 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.util.ArrayList;\n@@ -39,0 +44,1 @@\n+import java.util.List;\n@@ -76,2 +82,5 @@\n-     \/\/ from RFC 5649 sec6\n-     private static String KEK2 = \"5840DF6E29B02AF1AB493B705BF16EA1AE8338F4DCC176A8\";\n+    \/\/ from RFC 5649 sec6\n+    private static String KEK2 =\n+            \"5840DF6E29B02AF1AB493B705BF16EA1AE8338F4DCC176A8\";\n+\n+    private static final List<String> skippedList = new ArrayList <>();\n@@ -94,1 +103,5 @@\n-                System.arraycopy(val, 0, out, outLen - val.length, val.length);\n+                System.arraycopy(val,\n+                        0,\n+                        out,\n+                        outLen - val.length,\n+                        val.length);\n@@ -97,1 +110,5 @@\n-                System.arraycopy(val, val.length - outLen, out, 0, outLen);\n+                System.arraycopy(val,\n+                        val.length - outLen,\n+                        out,\n+                        0,\n+                        outLen);\n@@ -146,1 +163,2 @@\n-              \"138BDEAA9B8FA7FC61F97742E72248EE5AE6AE5360D1AE6A5F54F373FA543B6A\" },\n+              \"138BDEAA9B8FA7FC61F97742E72248EE5AE6AE5360D1AE6A5F54F373FA543B6A\"\n+            },\n@@ -260,0 +278,3 @@\n+            skippedList.add(algo + \" Cipher with wrapping \" +\n+                            dataLen + \"-byte key with \" + 8 * keyLen +\n+                            \"-bit KEK exceeds max allowed size \" + allowed);\n@@ -278,1 +299,2 @@\n-        AlgorithmParameters params = AlgorithmParameters.getInstance(\"AES\");\n+        AlgorithmParameters params =\n+                AlgorithmParameters.getInstance(\"AES\");\n@@ -303,3 +325,6 @@\n-        Key unwrapped = c1.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n-        Key unwrapped2 = c2.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n-        Key unwrapped3 = c3.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n+        Key unwrapped =\n+                c1.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n+        Key unwrapped2 =\n+                c2.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n+        Key unwrapped3 =\n+                c3.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n@@ -323,0 +348,3 @@\n+            skippedList.add(algo + \" Cipher with enc \" +\n+                            dataLen + \"-byte data with \" + 8 * keyLen +\n+                            \"-bit KEK exceeds max allowed size \" + allowed);\n@@ -339,1 +367,2 @@\n-        AlgorithmParameters params = AlgorithmParameters.getInstance(\"AES\");\n+        AlgorithmParameters params =\n+                AlgorithmParameters.getInstance(\"AES\");\n@@ -387,2 +416,1 @@\n-        for (int i = 0; i < testDatum.length; i++) {\n-            Object[] td = testDatum[i];\n+        for (Object[] td : testDatum) {\n@@ -391,2 +419,1 @@\n-                System.out.println(\"Skip, due to no support:  \" + algo);\n-                continue;\n+                skippedList.add(\"No support for \" + algo);\n@@ -394,4 +421,11 @@\n-            testKeyWrap(algo, (String)td[1], (int)td[2], (String)td[3],\n-                    (int)td[4], (String)td[5], p);\n-            testEnc(algo, (String)td[1], (int)td[2], (String)td[3],\n-                    (int)td[4], (String)td[5], p);\n+            testKeyWrap(algo, (String) td[1], (int) td[2], (String) td[3],\n+                    (int) td[4], (String) td[5], p);\n+            testEnc(algo, (String) td[1], (int) td[2], (String) td[3],\n+                    (int) td[4], (String) td[5], p);\n+        }\n+\n+        if (!skippedList.isEmpty()) {\n+            throw new SkippedException(\"One or more tests skipped \"\n+                                       + skippedList);\n+        } else {\n+            System.out.println(\"All Tests Passed\");\n@@ -399,1 +433,0 @@\n-        System.out.println(\"Test Passed\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/NISTWrapKAT.java","additions":55,"deletions":22,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import jtreg.SkippedException;\n+\n@@ -33,0 +35,7 @@\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.Key;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.util.ArrayList;\n@@ -35,3 +44,5 @@\n-import java.security.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import java.util.List;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -43,1 +54,2 @@\n-            Arrays.copyOf(\"1234567890123456789012345678901234\".getBytes(), 32);\n+            Arrays.copyOf(\"1234567890123456789012345678901234\".getBytes(),\n+                    32);\n@@ -52,1 +64,2 @@\n-            IvParameterSpec[] ivs, int maxPadLen) throws Exception {\n+                               IvParameterSpec[] ivs, int maxPadLen)\n+            throws Exception {\n@@ -99,1 +112,1 @@\n-            String expectedStr) throws Exception {\n+                               String expectedStr) throws Exception {\n@@ -248,1 +261,4 @@\n-                (\"RSA\", System.getProperty(\"test.provider.name\",\"SunRsaSign\"))\n+                (\"RSA\",\n+                        System.getProperty(\n+                                \"test.provider.name\",\n+                                \"SunRsaSign\"))\n@@ -254,0 +270,3 @@\n+\n+        final List<String> skippedList  = new ArrayList<>();\n+\n@@ -256,2 +275,1 @@\n-                System.out.println(\"Skip, due to no support:  \" + a);\n-                continue;\n+                skippedList.add(a);\n@@ -332,1 +350,7 @@\n-        System.out.println(\"All Tests Passed\");\n+\n+        if (!skippedList.isEmpty()) {\n+            throw new SkippedException(\"One or more tests skipped \" +\n+                                       \"due to no support \" + skippedList);\n+        } else {\n+            System.out.println(\"All Tests Passed\");\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/TestGeneral.java","additions":35,"deletions":11,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jtreg.SkippedException;\n+\n@@ -33,1 +35,0 @@\n-import java.security.AlgorithmParameters;\n@@ -35,2 +36,4 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -38,1 +41,0 @@\n-import java.io.IOException;\n@@ -108,1 +110,3 @@\n-            key[i] = c.unwrap(wrappedKey, \"AES\", Cipher.SECRET_KEY);\n+            key[i] = c.unwrap(wrappedKey,\n+                    \"AES\",\n+                    Cipher.SECRET_KEY);\n@@ -134,2 +138,1 @@\n-            System.out.println(\"Skip, due to no support:  \" + wrapAlg);\n-            return;\n+            throw new SkippedException(\"No support \" + wrapAlg);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/XMLEncKAT.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,11 @@\n+\/*\n+ * @test\n+ * @bug 8240256 8269034\n+ * @summary\n+ * @library \/test\/lib\/ \/sun\/security\/pkcs11\/\n+ * @modules jdk.crypto.cryptoki\/sun.security.pkcs11\n+ * @run main\/othervm\n+ *        -DCUSTOM_P11_CONFIG=${test.src}\/MultipleLogins-nss.txt\n+ *        -DCUSTOM_DB_DIR=.\/nss\/db\n+ *        MultipleLogins\n+ *\/\n@@ -33,0 +44,1 @@\n+\n@@ -40,2 +52,1 @@\n-public class MultipleLogins {\n-    private static final String KS_TYPE = \"PKCS11\";\n+public class MultipleLogins extends PKCS11Test {\n@@ -46,6 +57,10 @@\n-        String nssConfig = null;\n-        try {\n-            nssConfig = PKCS11Test.getNssConfig();\n-        } catch (SkippedException exc) {\n-            System.out.println(\"Skipping test: \" + exc.getMessage());\n-        }\n+        \/\/ This bypasses the PKCS11Test settings and run the mandatory\n+        \/\/ main method directly. This is needed to keep the custom logic of the test\n+        new MultipleLogins().main((Provider)null);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        copyNssCertKeyToClassesDir();\n+\n+        String nssConfig = getNssConfig();\n@@ -55,2 +70,1 @@\n-            System.out.println(\"No NSS config found. Skipping.\");\n-            return;\n+            throw new SkippedException(\"No NSS config found. Skipping.\");\n@@ -59,1 +73,1 @@\n-        for (int i =0; i < NUM_PROVIDERS; i++) {\n+        for (int i = 0; i < NUM_PROVIDERS; i++) {\n@@ -61,1 +75,1 @@\n-            providers[i] = (SunPKCS11)PKCS11Test.newPKCS11Provider();\n+            providers[i] = (SunPKCS11)newPKCS11Provider();\n@@ -71,1 +85,1 @@\n-        for (int i =0; i < NUM_PROVIDERS; i++) {\n+        for (int i = 0; i < NUM_PROVIDERS; i++) {\n@@ -98,1 +112,1 @@\n-        KeyStore ks = KeyStore.getInstance(KS_TYPE, p);\n+        KeyStore ks = KeyStore.getInstance(PKCS11, p);\n@@ -114,4 +128,3 @@\n-            if (e.getCause() instanceof LoginException &&\n-                    e.getCause().getMessage().contains(\"No token present\")) {\n-                \/\/ expected\n-            } else {\n+            if (!(e.getCause() instanceof LoginException) ||\n+                !(e.getCause().getMessage().contains(\"No token present\"))) {\n+\n@@ -119,1 +132,1 @@\n-            }\n+            } \/\/ else expected\n@@ -126,1 +139,3 @@\n-            if (!(callbacks[0] instanceof PasswordCallback)) {\n+            if (callbacks[0] instanceof PasswordCallback pc) {\n+                pc.setPassword(null);\n+            } else {\n@@ -129,2 +144,1 @@\n-            PasswordCallback pc = (PasswordCallback)callbacks[0];\n-            pc.setPassword(null);\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.java","additions":37,"deletions":23,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1,139 +0,0 @@\n-#\n-# Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 8240256 8269034\n-# @summary\n-# @library \/test\/lib\/\n-# @build jdk.test.lib.util.ForceGC\n-#        jdk.test.lib.Platform\n-#        jdk.test.lib.Utils\n-# @run shell MultipleLogins.sh\n-\n-# set a few environment variables so that the shell-script can run stand-alone\n-# in the source directory\n-\n-# if running by hand on windows, change TESTSRC and TESTCLASSES to \".\"\n-if [ \"${TESTSRC}\" = \"\" ] ; then\n-    TESTSRC=`pwd`\n-fi\n-if [ \"${TESTCLASSES}\" = \"\" ] ; then\n-    TESTCLASSES=`pwd`\n-fi\n-\n-if [ \"${TESTCLASSPATH}\" = \"\" ] ; then\n-    TESTCLASSPATH=`pwd`\n-fi\n-\n-if [ \"${COMPILEJAVA}\" = \"\" ]; then\n-    COMPILEJAVA=\"${TESTJAVA}\"\n-fi\n-echo TESTSRC=${TESTSRC}\n-echo TESTCLASSES=${TESTCLASSES}\n-echo TESTJAVA=${TESTJAVA}\n-echo COMPILEJAVA=${COMPILEJAVA}\n-echo \"\"\n-\n-# let java test exit if platform unsupported\n-\n-OS=`uname -s`\n-case \"$OS\" in\n-  Linux )\n-    FS=\"\/\"\n-    PS=\":\"\n-    CP=\"${FS}bin${FS}cp\"\n-    CHMOD=\"${FS}bin${FS}chmod\"\n-    ;;\n-  Darwin )\n-    FS=\"\/\"\n-    PS=\":\"\n-    CP=\"${FS}bin${FS}cp\"\n-    CHMOD=\"${FS}bin${FS}chmod\"\n-    ;;\n-  AIX )\n-    FS=\"\/\"\n-    PS=\":\"\n-    CP=\"${FS}bin${FS}cp\"\n-    CHMOD=\"${FS}bin${FS}chmod\"\n-    ;;\n-  Windows* )\n-    FS=\"\\\\\"\n-    PS=\";\"\n-    CP=\"cp\"\n-    CHMOD=\"chmod\"\n-    ;;\n-  CYGWIN* )\n-    FS=\"\/\"\n-    PS=\";\"\n-    CP=\"cp\"\n-    CHMOD=\"chmod\"\n-    #\n-    # javac does not like \/cygdrive produced by `pwd`\n-    #\n-    TESTSRC=`cygpath -d ${TESTSRC}`\n-    ;;\n-  * )\n-    echo \"Unrecognized system!\"\n-    exit 1;\n-    ;;\n-esac\n-\n-# first make cert\/key DBs writable\n-\n-${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}cert9.db ${TESTCLASSES}\n-${CHMOD} +w ${TESTCLASSES}${FS}cert9.db\n-\n-${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}key4.db ${TESTCLASSES}\n-${CHMOD} +w ${TESTCLASSES}${FS}key4.db\n-\n-${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}cert8.db ${TESTCLASSES}\n-${CHMOD} +w ${TESTCLASSES}${FS}cert8.db\n-\n-${CP} ${TESTSRC}${FS}..${FS}nss${FS}db${FS}key3.db ${TESTCLASSES}\n-${CHMOD} +w ${TESTCLASSES}${FS}key3.db\n-\n-# compile test\n-${COMPILEJAVA}${FS}bin${FS}javac ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} \\\n-        -classpath ${TESTCLASSPATH} \\\n-        -d ${TESTCLASSES} \\\n-        --add-modules jdk.crypto.cryptoki \\\n-        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n-        ${TESTSRC}${FS}..${FS}..${FS}..${FS}..${FS}..${FS}lib${FS}jdk${FS}test${FS}lib${FS}artifacts${FS}*.java \\\n-        ${TESTSRC}${FS}..${FS}..${FS}..${FS}..${FS}..${FS}lib${FS}jtreg${FS}*.java \\\n-        ${TESTSRC}${FS}MultipleLogins.java \\\n-        ${TESTSRC}${FS}..${FS}PKCS11Test.java\n-\n-TEST_ARGS=\"${TESTVMOPTS} ${TESTJAVAOPTS} -classpath ${TESTCLASSPATH} \\\n-        --add-modules jdk.crypto.cryptoki \\\n-        --add-exports jdk.crypto.cryptoki\/sun.security.pkcs11=ALL-UNNAMED \\\n-        -DCUSTOM_DB_DIR=${TESTCLASSES} \\\n-        -DCUSTOM_P11_CONFIG=${TESTSRC}${FS}MultipleLogins-nss.txt \\\n-        -Dtest.src=${TESTSRC} \\\n-        -Dtest.classes=${TESTCLASSES} \\\n-        -Djava.security.debug=${DEBUG}\"\n-\n-# run test without security manager\n-${TESTJAVA}${FS}bin${FS}java ${TEST_ARGS} MultipleLogins || exit 10\n-\n-echo Done\n-exit 0\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Provider\/MultipleLogins.sh","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8076190 8242151 8153005 8266182\n+ * @bug 8076190 8242151 8153005 8266182 8362894\n@@ -141,0 +141,5 @@\n+\n+        ProcessTools.executeCommand(opensslPath, \"pkcs12\", \"-export\", \"-in\",\n+                        \"kandc\", \"-out\", \"os6\", \"-name\", \"a\", \"-passout\",\n+                        \"pass:changeit\", \"-pbmac1_pbkdf2\", \"-macalg\", \"sha256\")\n+                .shouldHaveExitValue(0);\n@@ -171,0 +176,2 @@\n+        check(\"os6\", \"a\", \"changeit\", \"changeit\", true, true, true);\n+\n","filename":"test\/jdk\/sun\/security\/pkcs12\/KeytoolOpensslInteropTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -17,0 +17,2 @@\n+openssl pkcs12 -export -in kandc -out os6 -name a -passout pass:changeit \\\n+        -pbmac1_pbkdf2  -macalg sha256\n","filename":"test\/jdk\/sun\/security\/pkcs12\/params\/README","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+MIIEOgIBAzCCA7QGCSqGSIb3DQEHAaCCA6UEggOhMIIDnTCCAmoGCSqGSIb3DQEH\n+BqCCAlswggJXAgEAMIICUAYJKoZIhvcNAQcBMF8GCSqGSIb3DQEFDTBSMDEGCSqG\n+SIb3DQEFDDAkBBBEpg+dmjxfnLMTmaHD\/RjPAgIIADAMBggqhkiG9w0CCQUAMB0G\n+CWCGSAFlAwQBKgQQT731bM49PtePx\/S4Xf6UZICCAeBeDpWGfpMn8d+wcAoHjUyg\n++ceG2y75ac4UVsnVSpYCZaPHcOvUDbTAk5ylMGseLvl3x7xHmovIlShW1IBUWpTe\n+LhWNpa2f5yZ7t\/BXB\/oJFT7ol17WznHgmmCi6XbdiGq1YSV3X7SQEBw8WBWeOjGb\n+IURTAZCLMbGLXkSdg+2DRgP+PpM\/Y29vFK2vo72s8bfYS9bGitEreyafP\/jv8GxN\n+6SZx9+FSpTQ92Yj8qyFxvkR4fDyBnYe50KLf\/bZmGMBq\/d19lxNoheLGfuZ2ZM7W\n+Mw+wePBJsyntJfcce8iWjt6M8epVmx8SwarNkLU3UiX5XPDGJnnI\/0QXEvJ2skQW\n+y9kCTP4DRYd2kg0tRvpsrK2DraP6xxBCviixoil1rbiQHmOhj6RKx1grGw94nvZq\n+JM7rZbKN3DvjSwjRn8S2QvycqGYhrQhwoQGqajmCuuBrkM6FCQUKjoWja1XCeQ3Q\n+8aRnQxwypB46Jrvvn4t3GghF3ZJ0X9LuimXQo9GAXf+X7eNOPpjFrIWlgICTgRN+\n+v9elrcUOUKb9C24\/Zws\/B3nq8fvB9WY0Q9qaVZz9KUKfPjK1QwEr++5xJ5sBZgJz\n+kZNV0n4dxe4oCN+pE9ztpEswf4sWER92G+YDZB0IEV4wggErBgkqhkiG9w0BBwGg\n+ggEcBIIBGDCCARQwggEQBgsqhkiG9w0BDAoBAqCBxjCBwzBfBgkqhkiG9w0BBQ0w\n+UjAxBgkqhkiG9w0BBQwwJAQQvMlpTtrcoqg0XEC3z6KFEgICCAAwDAYIKoZIhvcN\n+AgkFADAdBglghkgBZQMEASoEEO7wolHeKZyoyII6h3l+iQ4EYEyg6yJWNUWo8ug2\n+QNsXVUWmUb9nfu0+nIuhnpBwRewveSv+XMZ+C8szRQsefeMdfjzy91M\/ZSHkR73K\n+HcKdUTVI5zNdBd61g9VNL6CvQCPZIj7AW5bsJ2cZg\/GjpsepcDE4MBEGCSqGSIb3\n+DQEJFDEEHgIAYTAjBgkqhkiG9w0BCRUxFgQUxCJpJWSVzAG4ZpwKuIUAgKBtWAkw\n+fTBtMEkGCSqGSIb3DQEFDjA8MCwGCSqGSIb3DQEFDDAfBAgMIRBR5kB3lgICCAAC\n+ASAwDAYIKoZIhvcNAgkFADAMBggqhkiG9w0CCQUABCDM5Ec9Anci3+OswMqEX22f\n+uAUrp9IqJSBF3ZY2g86utgQIDCEQUeZAd5YCAggA\n","filename":"test\/jdk\/sun\/security\/pkcs12\/params\/os6","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,517 @@\n+\/*\n+ * Copyright (c) 2025, Intel Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.util.HexFormat;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @key randomness\n+ * @modules java.base\/sun.security.provider:+open\n+ * @run main\/othervm ML_DSA_Intrinsic_Test -XX:+UnlockDiagnosticVMOptions -XX:-UseDilithiumIntrinsics\n+ *\/\n+\/*\n+ * @test\n+ * @requires os.simpleArch == \"x64\"\n+ * @library \/test\/lib\n+ * @key randomness\n+ * @modules java.base\/sun.security.provider:+open\n+ * @run main\/othervm -XX:UseAVX=2 ML_DSA_Intrinsic_Test\n+ *\/\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @key randomness\n+ * @modules java.base\/sun.security.provider:+open\n+ * @run main ML_DSA_Intrinsic_Test\n+ *\/\n+\n+\/\/ To run manually: java --add-opens java.base\/sun.security.provider=ALL-UNNAMED --add-exports java.base\/sun.security.provider=ALL-UNNAMED\n+\/\/  -XX:+UnlockDiagnosticVMOptions -XX:+UseDilithiumIntrinsics test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Intrinsic_Test.java\n+\n+public class ML_DSA_Intrinsic_Test {\n+    public static void main(String[] args) throws Exception {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Class<?> kClazz = sun.security.provider.ML_DSA.class;\n+\n+        Method m = kClazz.getDeclaredMethod(\"implDilithiumNttMult\",\n+                int[].class, int[].class, int[].class);\n+        m.setAccessible(true);\n+        MethodHandle mult = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumNttMultJava\",\n+                int[].class, int[].class, int[].class);\n+        m.setAccessible(true);\n+        MethodHandle multJava = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumMontMulByConstant\",\n+                int[].class, int.class);\n+        m.setAccessible(true);\n+        MethodHandle multConst = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumMontMulByConstantJava\",\n+                int[].class, int.class);\n+        m.setAccessible(true);\n+        MethodHandle multConstJava = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumDecomposePoly\",\n+                int[].class, int[].class, int[].class, int.class, int.class);\n+        m.setAccessible(true);\n+        MethodHandle decompose = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"decomposePolyJava\",\n+                int[].class, int[].class, int[].class, int.class, int.class);\n+        m.setAccessible(true);\n+        MethodHandle decomposeJava = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumAlmostNtt\",\n+        int[].class, int[].class);\n+        m.setAccessible(true);\n+        MethodHandle almostNtt = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumAlmostNttJava\",\n+                int[].class);\n+        m.setAccessible(true);\n+        MethodHandle almostNttJava = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumAlmostInverseNtt\",\n+        int[].class, int[].class);\n+        m.setAccessible(true);\n+        MethodHandle inverseNtt = lookup.unreflect(m);\n+\n+        m = kClazz.getDeclaredMethod(\"implDilithiumAlmostInverseNttJava\",\n+                int[].class);\n+        m.setAccessible(true);\n+        MethodHandle inverseNttJava = lookup.unreflect(m);\n+\n+        \/\/ Hint: if test fails, you can hardcode the seed to make the test more reproducible\n+        Random rnd = new Random();\n+        long seed = rnd.nextLong();\n+        rnd.setSeed(seed);\n+        \/\/Note: it might be useful to increase this number during development of new intrinsics\n+        final int repeat = 10000000;\n+        int[] coeffs1 = new int[ML_DSA_N];\n+        int[] coeffs2 = new int[ML_DSA_N];\n+        int[] prod1 = new int[ML_DSA_N];\n+        int[] prod2 = new int[ML_DSA_N];\n+        int[] prod3 = new int[ML_DSA_N];\n+        int[] prod4 = new int[ML_DSA_N];\n+        try {\n+            for (int i = 0; i < repeat; i++) {\n+                \/\/ Hint: if test fails, you can hardcode the seed to make the test more reproducible:\n+                \/\/ rnd.setSeed(seed);\n+                testMult(prod1, prod2, coeffs1, coeffs2, mult, multJava, rnd, seed, i);\n+                testMultConst(prod1, prod2, multConst, multConstJava, rnd, seed, i);\n+                testDecompose(prod1, prod2, prod3, prod4, coeffs1, coeffs2, decompose, decomposeJava, rnd, seed, i);\n+                testAlmostNtt(coeffs1, coeffs2, almostNtt, almostNttJava, rnd, seed, i);\n+                testInverseNtt(coeffs1, coeffs2, inverseNtt, inverseNttJava, rnd, seed, i);\n+            }\n+            System.out.println(\"Fuzz Success\");\n+        } catch (Throwable e) {\n+            System.out.println(\"Fuzz Failed: \" + e);\n+        }\n+    }\n+\n+    private static final int ML_DSA_N = 256;\n+    public static void testMult(int[] prod1, int[] prod2, int[] coeffs1, int[] coeffs2,\n+        MethodHandle mult, MethodHandle multJava, Random rnd,\n+        long seed, int i) throws Exception, Throwable {\n+\n+        for (int j = 0; j<ML_DSA_N; j++) {\n+            coeffs1[j] = rnd.nextInt();\n+            coeffs2[j] = rnd.nextInt();\n+        }\n+\n+        mult.invoke(prod1, coeffs1, coeffs2);\n+        multJava.invoke(prod2, coeffs1, coeffs2);\n+\n+        if (!Arrays.equals(prod1, prod2)) {\n+                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result mult mismatch: \" + formatOf(prod1) + \" != \" + formatOf(prod2));\n+        }\n+    }\n+\n+    public static void testMultConst(int[] prod1, int[] prod2,\n+        MethodHandle multConst, MethodHandle multConstJava, Random rnd,\n+        long seed, int i) throws Exception, Throwable {\n+\n+        for (int j = 0; j<ML_DSA_N; j++) {\n+            prod1[j] = prod2[j] = rnd.nextInt();\n+        }\n+        \/\/ Per Algorithm 3 in https:\/\/eprint.iacr.org\/2018\/039.pdf, one of the inputs is bound, which prevents overflows\n+        int dilithium_q = 8380417;\n+        int c = rnd.nextInt(dilithium_q);\n+\n+        multConst.invoke(prod1, c);\n+        multConstJava.invoke(prod2, c);\n+\n+        if (!Arrays.equals(prod1, prod2)) {\n+                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result multConst mismatch: \" + formatOf(prod1) + \" != \" + formatOf(prod2));\n+        }\n+    }\n+\n+    public static void testDecompose(int[] low1, int[] high1, int[] low2, int[] high2, int[] coeffs1, int[] coeffs2,\n+        MethodHandle decompose, MethodHandle decomposeJava, Random rnd,\n+        long seed, int i) throws Exception, Throwable {\n+\n+        for (int j = 0; j<ML_DSA_N; j++) {\n+            coeffs1[j] = coeffs2[j] = rnd.nextInt();\n+        }\n+        int gamma2 = 95232;\n+        if (rnd.nextBoolean()) {\n+            gamma2 = rnd.nextInt();\n+        }\n+        int multiplier = (gamma2 == 95232 ? 22 : 8);\n+\n+        decompose.invoke(coeffs1, low1, high1, 2 * gamma2, multiplier);\n+        decomposeJava.invoke(coeffs2, low2, high2, 2 * gamma2, multiplier);\n+\n+        if (!Arrays.equals(low1, low2)) {\n+                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result low mismatch: \" + formatOf(low1) + \" != \" + formatOf(low2));\n+        }\n+\n+        if (!Arrays.equals(high1, high2)) {\n+                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result high mismatch: \" + formatOf(high1) + \" != \" + formatOf(high2));\n+        }\n+    }\n+\n+    public static void testAlmostNtt(int[] coeffs1, int[] coeffs2,\n+        MethodHandle almostNtt, MethodHandle almostNttJava, Random rnd,\n+        long seed, int i) throws Exception, Throwable {\n+        for (int j = 0; j<ML_DSA_N; j++) {\n+            coeffs1[j] = coeffs2[j] = rnd.nextInt();\n+        }\n+\n+        almostNtt.invoke(coeffs1, MONT_ZETAS_FOR_VECTOR_NTT);\n+        almostNttJava.invoke(coeffs2);\n+\n+        if (!Arrays.equals(coeffs1, coeffs2)) {\n+            throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result AlmostNtt mismatch: \" + formatOf(coeffs1) + \" != \" + formatOf(coeffs2));\n+        }\n+    }\n+\n+    public static void testInverseNtt(int[] coeffs1, int[] coeffs2,\n+        MethodHandle inverseNtt, MethodHandle inverseNttJava, Random rnd,\n+        long seed, int i) throws Exception, Throwable {\n+        for (int j = 0; j<ML_DSA_N; j++) {\n+            coeffs1[j] = coeffs2[j] = rnd.nextInt();\n+        }\n+\n+        inverseNtt.invoke(coeffs1, MONT_ZETAS_FOR_VECTOR_INVERSE_NTT);\n+        inverseNttJava.invoke(coeffs2);\n+\n+        if (!Arrays.equals(coeffs1, coeffs2)) {\n+            throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result InverseNtt mismatch: \" + formatOf(coeffs1) + \" != \" + formatOf(coeffs2));\n+        }\n+    }\n+\n+    private static CharSequence formatOf(int[] arr) {\n+        StringBuilder b = new StringBuilder(arr.length*8);\n+        HexFormat hex = HexFormat.of();\n+        for (int j = 0; j<arr.length; j++) {\n+            b.append(hex.toHexDigits(arr[j]));\n+        }\n+        return b.toString();\n+    }\n+\n+    \/\/ Copied constants from sun.security.provider.ML_DSA\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_INVERSE_NTT = new int[]{\n+            -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+            3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+            3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+            -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+            1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+            1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+            3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+            -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+            1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+            1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+            -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+            -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+            3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+            522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+            3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+            3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+\n+            -3839961, -3839961, 3628969, 3628969, 3881060, 3881060, 3019102, 3019102,\n+            1439742, 1439742, 812732, 812732, 1584928, 1584928, -1285669, -1285669,\n+            -1341330, - 1341330, -1315589, -1315589, 177440, 177440, 2409325, 2409325,\n+            1851402, 1851402, -3159746, -3159746, 3553272, 3553272, -189548, -189548,\n+            1316856, 1316856, -759969, -759969, 210977, 210977, -2389356, -2389356,\n+            3249728, 3249728, -1653064, -1653064, 8578, 8578, 3724342, 3724342,\n+            -3958618, -3958618, -904516, -904516, 1100098, 1100098, -44288, -44288,\n+            -3097992, -3097992, -508951, -508951, -264944, -264944, 3343383, 3343383,\n+            1430430, 1430430, -1852771, -1852771, -1349076, -1349076, 381987, 381987,\n+            1308169, 1308169, 22981, 22981, 1228525, 1228525, 671102, 671102,\n+            2477047, 2477047, 411027, 411027, 3693493, 3693493, 2967645, 2967645,\n+            -2715295, -2715295, -2147896, -2147896, 983419, 983419, -3412210, -3412210,\n+            -126922, -126922, 3632928, 3632928, 3157330, 3157330, 3190144, 3190144,\n+            1000202, 1000202, 4083598, 4083598, -1939314, -1939314, 1257611, 1257611,\n+            1585221, 1585221, -2176455, -2176455, -3475950, -3475950, 1452451, 1452451,\n+            3041255, 3041255, 3677745, 3677745, 1528703, 1528703, 3930395, 3930395,\n+\n+            2797779, 2797779, 2797779, 2797779, -2071892, -2071892, -2071892, -2071892,\n+            2556880, 2556880, 2556880, 2556880, -3900724, -3900724, -3900724, -3900724,\n+            -3881043, -3881043, -3881043, -3881043, -954230, -954230, -954230, -954230,\n+            -531354, -531354, -531354, -531354, -811944, -811944, -811944, -811944,\n+            -3699596, -3699596, -3699596, -3699596, 1600420, 1600420, 1600420, 1600420,\n+            2140649, 2140649, 2140649, 2140649, -3507263, -3507263, -3507263, -3507263,\n+            3821735, 3821735, 3821735, 3821735, -3505694, -3505694, -3505694, -3505694,\n+            1643818, 1643818, 1643818, 1643818, 1699267, 1699267, 1699267, 1699267,\n+            539299, 539299, 539299, 539299, -2348700, -2348700, -2348700, -2348700,\n+            300467, 300467, 300467, 300467, -3539968, -3539968, -3539968, -3539968,\n+            2867647, 2867647, 2867647, 2867647, -3574422, -3574422, -3574422, -3574422,\n+            3043716, 3043716, 3043716, 3043716, 3861115, 3861115, 3861115, 3861115,\n+            -3915439, -3915439, -3915439, -3915439, 2537516, 2537516, 2537516, 2537516,\n+            3592148, 3592148, 3592148, 3592148, 1661693, 1661693, 1661693, 1661693,\n+            -3530437, -3530437, -3530437, -3530437, -3077325, -3077325, -3077325, -3077325,\n+            -95776, -95776, -95776, -95776, -2706023, -2706023, -2706023, -2706023,\n+\n+            -280005, -280005, -280005, -280005, -280005, -280005, -280005, -280005,\n+            -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497,\n+            19422, 19422, 19422, 19422, 19422, 19422, 19422, 19422,\n+            -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237,\n+            3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672,\n+            1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561,\n+            3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737,\n+            2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186,\n+            2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549,\n+            -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752,\n+            1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584,\n+            549488, 549488, 549488, 549488, 549488, 549488, 549488, 549488,\n+            -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928,\n+            1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900,\n+            -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112,\n+            -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464,\n+\n+            -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+            -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+            -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+            -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+            2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+            2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+            -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+            -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+            2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+            2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+            359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+            359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+            -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+            -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+            -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+            -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+            -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+            2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+            -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847\n+    };\n+\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_NTT = new int[]{\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+            25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+            -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+            466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+\n+            1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+            1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+            2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+            2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+            -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+            -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+            -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+            -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+            3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+            3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+            -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+            -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+            3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+            3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+            2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+            2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+\n+            2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464,\n+            1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112,\n+            -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900,\n+            3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928,\n+            -549488, -549488, -549488, -549488, -549488, -549488, -549488, -549488,\n+            -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584,\n+            2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752,\n+            -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549,\n+            -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186,\n+            -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737,\n+            -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561,\n+            -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672,\n+            1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237,\n+            -19422, -19422, -19422, -19422, -19422, -19422, -19422, -19422,\n+            4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497,\n+            280005, 280005, 280005, 280005, 280005, 280005, 280005, 280005,\n+\n+            2706023, 2706023, 2706023, 2706023, 95776, 95776, 95776, 95776,\n+            3077325, 3077325, 3077325, 3077325, 3530437, 3530437, 3530437, 3530437,\n+            -1661693, -1661693, -1661693, -1661693, -3592148, -3592148, -3592148, -3592148,\n+            -2537516, -2537516, -2537516, -2537516, 3915439, 3915439, 3915439, 3915439,\n+            -3861115, -3861115, -3861115, -3861115, -3043716, -3043716, -3043716, -3043716,\n+            3574422, 3574422, 3574422, 3574422, -2867647, -2867647, -2867647, -2867647,\n+            3539968, 3539968, 3539968, 3539968, -300467, -300467, -300467, -300467,\n+            2348700, 2348700, 2348700, 2348700, -539299, -539299, -539299, -539299,\n+            -1699267, -1699267, -1699267, -1699267, -1643818, -1643818, -1643818, -1643818,\n+            3505694, 3505694, 3505694, 3505694, -3821735, -3821735, -3821735, -3821735,\n+            3507263, 3507263, 3507263, 3507263, -2140649, -2140649, -2140649, -2140649,\n+            -1600420, -1600420, -1600420, -1600420, 3699596, 3699596, 3699596, 3699596,\n+            811944, 811944, 811944, 811944, 531354, 531354, 531354, 531354,\n+            954230, 954230, 954230, 954230, 3881043, 3881043, 3881043, 3881043,\n+            3900724, 3900724, 3900724, 3900724, -2556880, -2556880, -2556880, -2556880,\n+            2071892, 2071892, 2071892, 2071892, -2797779, -2797779, -2797779, -2797779,\n+\n+            -3930395, -3930395, -1528703, -1528703, -3677745, -3677745, -3041255, -3041255,\n+            -1452451, -1452451, 3475950, 3475950, 2176455, 2176455, -1585221, -1585221,\n+            -1257611, -1257611, 1939314, 1939314, -4083598, -4083598, -1000202, -1000202,\n+            -3190144, -3190144, -3157330, -3157330, -3632928, -3632928, 126922, 126922,\n+            3412210, 3412210, -983419, -983419, 2147896, 2147896, 2715295, 2715295,\n+            -2967645, -2967645, -3693493, -3693493, -411027, -411027, -2477047, -2477047,\n+            -671102, -671102, -1228525, -1228525, -22981, -22981, -1308169, -1308169,\n+            -381987, -381987, 1349076, 1349076, 1852771, 1852771, -1430430, -1430430,\n+            -3343383, -3343383, 264944, 264944, 508951, 508951, 3097992, 3097992,\n+            44288, 44288, -1100098, -1100098, 904516, 904516, 3958618, 3958618,\n+            -3724342, -3724342, -8578, -8578, 1653064, 1653064, -3249728, -3249728,\n+            2389356, 2389356, -210977, -210977, 759969, 759969, -1316856, -1316856,\n+            189548, 189548, -3553272, -3553272, 3159746, 3159746, -1851402, -1851402,\n+            -2409325, -2409325, -177440, -177440, 1315589, 1315589, 1341330, 1341330,\n+            1285669, 1285669, -1584928, -1584928, -812732, -812732, -1439742, -1439742,\n+            -3019102, -3019102, -3881060, -3881060, -3628969, -3628969, 3839961, 3839961,\n+\n+            2091667, 3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462,\n+            266997, 2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378,\n+            900702, 1859098, 909542, 819034, 495491, -1613174, -43260, -522500,\n+            -655327, -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838,\n+            342297, 286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044,\n+            2842341, 2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974,\n+            -3767016, 1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970,\n+            -1333058, 1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642,\n+            -1279661, 1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031,\n+            -542412, -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993,\n+            -2013608, 2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385,\n+            -3183426, 162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107,\n+            -3038916, 3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078,\n+            -426683, 1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893,\n+            -2939036, -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687,\n+            -554416, 3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Intrinsic_Test.java","additions":517,"deletions":0,"binary":false,"changes":517,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import javax.crypto.spec.HPKEParameterSpec;\n@@ -99,0 +100,5 @@\n+        } else if (alg.equals(\"HPKE\")) {\n+            key = KeyPairGenerator.getInstance(\"x25519\").generateKeyPair().getPublic();\n+            spec = HPKEParameterSpec.of(HPKEParameterSpec.KEM_DHKEM_X25519_HKDF_SHA256,\n+                    HPKEParameterSpec.KDF_HKDF_SHA256,\n+                    HPKEParameterSpec.AEAD_AES_256_GCM);\n@@ -242,0 +248,2 @@\n+        } if (s.equals(\"HPKE\")) {\n+            return generateKeyPair(\"EC\", 3).getPublic();\n","filename":"test\/jdk\/sun\/security\/provider\/all\/Deterministic.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8350582 8340312 8369995\n+ * @bug 8350582 8340312 8369995 8372004\n@@ -94,0 +94,1 @@\n+                        \"sun.security.ssl.SSLSocketImpl close\",\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLLogger\/DebugPropertyValuesTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    private static final int MAX_ATTEMPTS = 3;\n+    private static final int MAX_ATTEMPTS = 15;\n@@ -68,0 +68,1 @@\n+                    Thread.sleep(100*i);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/ReuseAddr.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,4 @@\n-        keytool(\"-alias ca -gencert -infile a.req -outfile a.cert\");\n+\n+        \/\/ The start date is set to -1M to prevent the certificate not yet\n+        \/\/ valid during fast enough execution.\n+        keytool(\"-alias ca -gencert -infile a.req -outfile a.cert -startdate -1M\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/DefaultOptions.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -853,0 +853,3 @@\n+\n+            if (line.contains(Test.OUTDATED_KEYSTORE_WARNING1)) continue;\n+            if (line.contains(Test.OUTDATED_KEYSTORE_WARNING2)) continue;\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/compatibility\/Compatibility.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -154,0 +154,7 @@\n+    static final String OUTDATED_KEYSTORE_WARNING1\n+            = \"uses outdated cryptographic algorithms and will be \"\n+            + \"removed in a future release. Migrate to PKCS12 using:\";\n+\n+    static final String OUTDATED_KEYSTORE_WARNING2\n+            = \"keytool -importkeystore -srckeystore\";\n+\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/warnings\/Test.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8353749\n+ * @summary Validate that keytool and jarsigner emit warnings for\n+ *         JKS and JCEKS keystore with java.security.debug=keystore\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.x509\n+ * @run main\/othervm -Djava.security.debug=keystore OutdatedKeyStoreWarning\n+ *\/\n+\n+import java.io.FileOutputStream;\n+import java.nio.file.Path;\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.security.KeyStore;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.Locale;\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+public class OutdatedKeyStoreWarning {\n+\n+    private static final String KS_WARNING1 =\n+            \"uses outdated cryptographic algorithms and will be removed \" +\n+            \"in a future release. Migrate to PKCS12 using:\";\n+\n+    private static final String KS_WARNING2=\n+            \"keytool -importkeystore -srckeystore <keystore> \" +\n+            \"-destkeystore <keystore> -deststoretype pkcs12\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String[] ksTypes = {\"JKS\", \"JCEKS\"};\n+\n+        for (String type : ksTypes) {\n+            String ksFile = type.toLowerCase() + \".ks\";\n+            String cmdWarning = type + \" \" + KS_WARNING1;\n+\n+            checkWarnings(type, () -> {\n+                SecurityTools.keytool(String.format(\n+                        \"-genkeypair -keystore %s -storetype %s -storepass changeit \" +\n+                        \"-keypass changeit -keyalg ec -alias a1 -dname CN=me \" +\n+                        \"-J-Djava.security.debug=keystore\",\n+                        ksFile, type.toLowerCase()))\n+                        .shouldContain(\"Warning:\")\n+                        .shouldContain(cmdWarning)\n+                        .shouldContain(KS_WARNING2)\n+                        .shouldHaveExitValue(0);\n+            });\n+\n+            JarUtils.createJarFile(Path.of(\"unsigned.jar\"), Path.of(\".\"), Path.of(ksFile));\n+            checkWarnings(type, () -> {\n+                SecurityTools.jarsigner(String.format(\n+                        \"-keystore %s -storetype %s -storepass changeit -signedjar signed.jar \" +\n+                        \"unsigned.jar a1 \" +\n+                        \"-J-Djava.security.debug=keystore\",\n+                        ksFile, type.toLowerCase()))\n+                        .shouldContain(\"Warning:\")\n+                        .shouldContain(cmdWarning)\n+                        .shouldContain(KS_WARNING2)\n+                        .shouldHaveExitValue(0);\n+            });\n+\n+            checkWarnings(type, () -> {\n+                SecurityTools.jarsigner(String.format(\n+                        \"-verify -keystore %s -storetype %s -storepass changeit signed.jar \" +\n+                        \"-J-Djava.security.debug=keystore\",\n+                        ksFile, type.toLowerCase()))\n+                        .shouldContain(\"Warning:\")\n+                        .shouldContain(cmdWarning)\n+                        .shouldContain(KS_WARNING2)\n+                        .shouldHaveExitValue(0);\n+            });\n+        }\n+\n+        for (String type : ksTypes) {\n+            checkStoreAPIWarning(type);\n+        }\n+    }\n+\n+    private static void checkWarnings(String type, RunnableWithException r) throws Exception {\n+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n+        PrintStream origErr = System.err;\n+        PrintStream origOut = System.out;\n+\n+        try {\n+            PrintStream pStream = new PrintStream(bOut);\n+            System.setErr(pStream);\n+            System.setOut(pStream);\n+            r.run();\n+        } finally {\n+            System.setErr(origErr);\n+            System.setOut(origOut);\n+        }\n+\n+        String msg = bOut.toString();\n+        if (!msg.contains(\"WARNING: \" + type.toUpperCase(Locale.ROOT)) ||\n+                !msg.contains(KS_WARNING1) ||\n+                !msg.contains(KS_WARNING2) ||\n+                !msg.contains(\"Warning:\")) {\n+            throw new RuntimeException(\"Expected warning not found for \" + type + \":\\n\" + msg);\n+        }\n+    }\n+\n+    \/\/ Test case for: KeyStore.getInstance(\"JKS\" or \"JCEKS\"), load(null, null), and\n+    \/\/ store it where warning should be emitted.\n+    private static void checkStoreAPIWarning(String type) throws Exception {\n+        ByteArrayOutputStream bOut = new ByteArrayOutputStream();\n+        PrintStream origErr = System.err;\n+        PrintStream origOut = System.out;\n+\n+        try {\n+            PrintStream pStream = new PrintStream(bOut);\n+            System.setErr(pStream);\n+            System.setOut(pStream);\n+\n+            KeyStore ks = KeyStore.getInstance(type);\n+            ks.load(null, null);\n+\n+            CertAndKeyGen cag = new CertAndKeyGen(\"EC\", \"SHA256withECDSA\");\n+            cag.generate(\"secp256r1\");\n+            X509Certificate cert = cag.getSelfCertificate(new X500Name(\"CN=one\"), 3600);\n+            ks.setKeyEntry(\"dummy\", cag.getPrivateKey(), \"changeit\".toCharArray(),\n+                    new Certificate[] {cert});\n+\n+            try (FileOutputStream fos = new FileOutputStream(type.toLowerCase() +\n+                    \"_storeAPI.ks\")) {\n+                ks.store(fos, \"changeit\".toCharArray());\n+            }\n+        } finally {\n+            System.setErr(origErr);\n+            System.setOut(origOut);\n+        }\n+\n+        String msg = bOut.toString();\n+        if (!msg.contains(\"WARNING: \" + type.toUpperCase(Locale.ROOT)) ||\n+                !msg.contains(KS_WARNING1) ||\n+                !msg.contains(KS_WARNING2)) {\n+            throw new RuntimeException(\"Expected warning not found for KeyStore.store() API (\" +\n+                    type + \"):\\n\" + msg);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    interface RunnableWithException {\n+        void run() throws Exception;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/OutdatedKeyStoreWarning.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8171319 8177569 8182879 8172404\n+ * @bug 8171319 8177569 8182879 8172404 8353749\n@@ -229,1 +229,2 @@\n-                .shouldNotContain(\"proprietary format\");\n+                .shouldNotContain(\"outdated cryptographic algorithms\")\n+                .shouldNotContain(\"keytool -importkeystore -srckeystore\");\n@@ -245,1 +246,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\");\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -255,1 +259,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\");\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -257,1 +264,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\");\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -259,1 +269,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\");\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -261,1 +274,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\");\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -263,1 +279,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\");\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -265,1 +284,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\");\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -279,1 +301,4 @@\n-                .shouldContain(\"JCEKS keystore uses a proprietary format\");\n+                .shouldContain(\"JCEKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -281,1 +306,4 @@\n-                .shouldContain(\"JCEKS keystore uses a proprietary format\");\n+                .shouldContain(\"JCEKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -283,1 +311,4 @@\n-                .shouldContain(\"JCEKS keystore uses a proprietary format\");\n+                .shouldContain(\"JCEKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -285,1 +316,4 @@\n-                .shouldContain(\"JCEKS keystore uses a proprietary format\");\n+                .shouldContain(\"JCEKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -287,1 +321,4 @@\n-                .shouldContain(\"JCEKS keystore uses a proprietary format\");\n+                .shouldContain(\"JCEKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -289,1 +326,4 @@\n-                .shouldContain(\"JCEKS keystore uses a proprietary format\");\n+                .shouldContain(\"JCEKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -293,1 +333,4 @@\n-                .shouldContain(\"JCEKS keystore uses a proprietary format\");\n+                .shouldContain(\"JCEKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\");\n@@ -339,1 +382,4 @@\n-                .shouldContain(\"JKS keystore uses a proprietary format\")\n+                .shouldContain(\"JKS uses outdated cryptographic algorithms\" +\n+                        \" and will be removed\")\n+                .shouldMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\")\n@@ -349,1 +395,3 @@\n-                .shouldNotContain(\"proprietary format\")\n+                .shouldNotContain(\"outdated cryptographic algorithms\")\n+                .shouldNotMatch(\"keytool -importkeystore -srckeystore.\" +\n+                        \"*-destkeystore.*-deststoretype pkcs12\")\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/WeakAlg.java","additions":67,"deletions":19,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.util.SliceableSecretKey;\n+\n+import javax.crypto.KDF;\n+import javax.crypto.KDFParameters;\n+import javax.crypto.KDFSpi;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.KeyPairGenerator;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @bug 8325448\n+ * @library \/test\/lib \/test\/jdk\/security\/unsignedjce\n+ * @build java.base\/javax.crypto.ProviderVerifier\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm SoftSliceable\n+ * @summary Showcase how Sliceable can be used in DHKEM\n+ *\/\n+public class SoftSliceable {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Put an HKDF-SHA256 impl that is preferred to the SunJCE one\n+        Security.insertProviderAt(new ProviderImpl(), 1);\n+\n+        \/\/ Just plain KEM calls\n+        var kp = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+        var k = KEM.getInstance(\"DHKEM\");\n+        var e = k.newEncapsulator(kp.getPublic());\n+        var d = k.newDecapsulator(kp.getPrivate());\n+        var enc = e.encapsulate(3, 9, \"Generic\");\n+        var k2 = d.decapsulate(enc.encapsulation(), 3, 9, \"Generic\");\n+        var k2full = d.decapsulate(enc.encapsulation());\n+\n+        if (enc.key() instanceof KeyImpl ki1\n+                && k2 instanceof KeyImpl ki2\n+                && k2full instanceof KeyImpl ki2full) {\n+            \/\/ So the keys do come from the new provider, and\n+            \/\/ 1. It has the correct length\n+            Asserts.assertEquals(6, ki1.bytes.length);\n+            \/\/ 2. encaps and decaps result in same keys\n+            Asserts.assertEqualsByteArray(ki1.bytes, ki2.bytes);\n+            \/\/ 3. The key is the correct slice from the full shared secret\n+            Asserts.assertEqualsByteArray(\n+                    Arrays.copyOfRange(ki2full.bytes, 3, 9), ki2.bytes);\n+        } else {\n+            throw new Exception(\"Unexpected key types\");\n+        }\n+    }\n+\n+    \/\/ A trivial SliceableSecretKey that is non-extractable with getBytes()\n+    public static class KeyImpl implements SecretKey, SliceableSecretKey {\n+\n+        private final byte[] bytes;\n+        private final String algorithm;\n+\n+        public KeyImpl(byte[] bytes, String algorithm) {\n+            this.bytes = bytes.clone();\n+            this.algorithm = algorithm;\n+        }\n+\n+        @Override\n+        public String getAlgorithm() {\n+            return algorithm;\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return null;\n+        }\n+\n+        @Override\n+        public byte[] getEncoded() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SecretKey slice(String alg, int from, int to) {\n+            return new KeyImpl(Arrays.copyOfRange(bytes, from, to), algorithm);\n+        }\n+    }\n+\n+    \/\/ Our new provider\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"A\", \"A\", \"A\");\n+            put(\"KDF.HKDF-SHA256\", KDFImpl.class.getName());\n+        }\n+    }\n+\n+    \/\/ Our new HKDF-SHA256 impl that always returns a KeyImpl object\n+    public static class KDFImpl extends KDFSpi {\n+\n+        public KDFImpl(KDFParameters p)\n+                throws InvalidAlgorithmParameterException {\n+            super(p);\n+        }\n+\n+        @Override\n+        protected KDFParameters engineGetParameters() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected SecretKey engineDeriveKey(String alg, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException {\n+            try {\n+                var kdf = KDF.getInstance(\"HKDF-SHA256\", \"SunJCE\");\n+                var bytes = kdf.deriveData(spec);\n+                return new KeyImpl(bytes, alg);\n+            } catch (NoSuchAlgorithmException | NoSuchProviderException e) {\n+                throw new AssertionError(\"Cannot happen\", e);\n+            }\n+        }\n+\n+        @Override\n+        protected byte[] engineDeriveData(AlgorithmParameterSpec spec) {\n+            throw new UnsupportedOperationException(\"Cannot derive data\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/SliceableSecretKey\/SoftSliceable.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @test\n+ * @test id=0\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -Dcom.sun.security.crl.readtimeout=1\n+ * @run main\/othervm -Djava.security.debug=certpath -Dcom.sun.security.crl.readtimeout=1\n@@ -33,1 +33,10 @@\n- * @run main\/othervm -Dcom.sun.security.crl.readtimeout=1s\n+ *\/\n+\n+\/*\n+ * @test id=1\n+ * @bug 8191808 8179502\n+ * @summary check that CRL download is interrupted if it takes too long\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.debug=certpath -Dcom.sun.security.crl.readtimeout=1s\n@@ -35,1 +44,10 @@\n- * @run main\/othervm -Dcom.sun.security.crl.readtimeout=4\n+ *\/\n+\n+\/*\n+ * @test id=2\n+ * @bug 8191808 8179502\n+ * @summary check that CRL download is interrupted if it takes too long\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.debug=certpath -Dcom.sun.security.crl.readtimeout=200\n@@ -37,1 +55,10 @@\n- * @run main\/othervm -Dcom.sun.security.crl.readtimeout=1500ms\n+ *\/\n+\n+\/*\n+ * @test id=3\n+ * @bug 8191808 8179502\n+ * @summary check that CRL download is interrupted if it takes too long\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.debug=certpath -Dcom.sun.security.crl.readtimeout=1500ms\n@@ -39,2 +66,0 @@\n- * @run main\/othervm -Dcom.sun.security.crl.readtimeout=4500ms\n- *      CRLReadTimeout 1000 true\n@@ -43,1 +68,15 @@\n-import java.io.*;\n+\/*\n+ * @test id=4\n+ * @bug 8191808 8179502\n+ * @summary check that CRL download is interrupted if it takes too long\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.security.debug=certpath -Dcom.sun.security.crl.readtimeout=4500ms\n+ *      CRLReadTimeout 100 true\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n@@ -45,0 +84,1 @@\n+import java.net.InetAddress;\n@@ -50,1 +90,10 @@\n-import java.security.cert.*;\n+import java.security.cert.CRLException;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.CertPathValidatorException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.PKIXRevocationChecker;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509CRL;\n+import java.security.cert.X509Certificate;\n@@ -57,1 +106,3 @@\n-import static java.security.cert.PKIXRevocationChecker.Option.*;\n+import static java.security.cert.PKIXRevocationChecker.Option.NO_FALLBACK;\n+import static java.security.cert.PKIXRevocationChecker.Option.PREFER_CRLS;\n+import static java.security.cert.PKIXRevocationChecker.Option.SOFT_FAIL;\n@@ -63,1 +114,6 @@\n-import sun.security.x509.*;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.CRLExtensions;\n+import sun.security.x509.CRLNumberExtension;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.X500Name;\n+import sun.security.x509.X509CRLImpl;\n@@ -120,1 +176,1 @@\n-            if (softExc.size() > 0) {\n+            if (!softExc.isEmpty()) {\n@@ -122,1 +178,2 @@\n-                        softExc.size() + \" soft fail exceptions\");\n+                                           softExc.size() +\n+                                           \" soft fail exceptions\");\n@@ -185,1 +242,1 @@\n-            server.bind(new InetSocketAddress(0), 0);\n+            server.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n","filename":"test\/jdk\/sun\/security\/x509\/URICertStore\/CRLReadTimeout.java","additions":72,"deletions":15,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.*;\n+import jdk.test.lib.Asserts;\n+\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.util.Properties;\n+\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+\n+import tests.Helper;\n+\n+\/* @test\n+ * @bug 8372155\n+ * @summary Test the --release-info <file> plugin option\n+ * @library ..\/..\/lib\n+ * @library \/test\/lib\n+ * @modules jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jimage\n+ *          java.base\/jdk.internal.jimage\n+ * @build tests.*\n+ * @run main\/othervm ReleaseInfoPluginTest\n+ *\/\n+\n+public class ReleaseInfoPluginTest {\n+\n+    private static final String NON_ASCII = \"Ã¶ÃŸÃ¤akl vendor oy\";\n+    private static final String IMPL = \"IMPLEMENTOR\";\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        Helper helper = Helper.newHelper(LINKABLE_RUNTIME);\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+        var utf8File = Path.of(\"release-info-utf-8.txt\");\n+        Files.writeString(utf8File, IMPL + \"=\\\"\" + NON_ASCII + \"\\\"\", StandardCharsets.UTF_8);\n+        Path image = helper.generateDefaultImage(\n+                             new String[] {\n+                               \"--release-info\", utf8File.toString()\n+                             }, \"java.base\").assertSuccess();\n+\n+        \/\/ release file produced should have IMPLEMENTOR in\n+        \/\/ UTF-8 encoding\n+        Path release = image.resolve(\"release\");\n+        Properties props = new Properties();\n+        try (Reader reader= Files.newBufferedReader(release)) {\n+            props.load(reader); \/\/ Load as UTF-8\n+        }\n+        String noQuotesMods = ((String)props.get(\"MODULES\")).replace(\"\\\"\", \"\");\n+        Asserts.assertEquals(\"java.base\", noQuotesMods);\n+        String noQuotesActual = ((String)props.get(IMPL)).replace(\"\\\"\", \"\");\n+        Asserts.assertEquals(NON_ASCII, noQuotesActual);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jlink\/plugins\/ReleaseInfoPluginTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -26,0 +26,2 @@\n+    jdk.jpackage\/jdk.jpackage.internal.cli \\\n+    jdk.jpackage\/jdk.jpackage.internal.model \\\n","filename":"test\/jdk\/tools\/jpackage\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  derandomizeServiceTestCfgFiles\n@@ -97,0 +98,7 @@\n+derandomizeServiceTestCfgFiles() {\n+  # Convert variable part of 'java-options=-Djpackage.test.appOutput=\/tmp\/AddLServiceTest-0000019a5a3fac9c-launcher-as-service.txt'\n+  # in '*.cfg' files of the ServiceTest test.\n+  find \"$stash_dir\" -path '*\/ServiceTest\/*.cfg' -type f | xargs -I {} sed $sed_inplace_option \\\n+      -e 's|ServiceTest-[[:xdigit:]]\\{1,\\}-\\([^ ]*\\.txt\\)|ServiceTest-<SEED>-\\1|g' \\\n+      '{}'\n+}\n@@ -123,1 +131,1 @@\n-      -e 's|\/jdk.jpackage[0-9]\\{1,\\}\/|\/jdk.jpackage\/|' \\\n+      -e 's|\/jdk\\.jpackage[0-9]\\{1,\\}\/|\/jdk.jpackage\/|' \\\n","filename":"test\/jdk\/tools\/jpackage\/clean_stashed_files.sh","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -117,0 +117,3 @@\n+\n+      # Convert variable part of 'ServiceTest-0000019a5516cf7a-A2-launcher-as-service.txt' path\n+      -e 's|ServiceTest-[[:xdigit:]]\\{1,\\}-\\([^ ]*\\.txt\\)|ServiceTest-<SEED>-\\1|g'\n","filename":"test\/jdk\/tools\/jpackage\/clean_test_output.sh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -31,1 +30,0 @@\n-import java.nio.file.Files;\n@@ -42,1 +40,0 @@\n-import java.util.Properties;\n@@ -45,0 +42,1 @@\n+import jdk.jpackage.internal.util.Slot;\n@@ -208,1 +206,1 @@\n-        PropertyFile shell[] = new PropertyFile[1];\n+        var result = Slot.<PropertyFile>createEmpty();\n@@ -211,3 +209,1 @@\n-                shell[0] = toSupplier(() -> {\n-                    return new PropertyFile(propertiesFilePath);\n-                }).get();\n+                result.set(new PropertyFile(propertiesFilePath));\n@@ -216,1 +212,1 @@\n-        return Objects.requireNonNull(shell[0]);\n+        return result.get();\n@@ -248,26 +244,0 @@\n-    public static final class PropertyFile {\n-\n-        PropertyFile(Map<String, String> data) {\n-            this.data = new Properties();\n-            this.data.putAll(data);\n-        }\n-\n-        PropertyFile(Path path) throws IOException {\n-            data = new Properties();\n-            try (var reader = Files.newBufferedReader(path)) {\n-                data.load(reader);\n-            }\n-        }\n-\n-        public Optional<String> findProperty(String name) {\n-            Objects.requireNonNull(name);\n-            return Optional.ofNullable(data.getProperty(name));\n-        }\n-\n-        public Optional<Boolean> findBooleanProperty(String name) {\n-            return findProperty(name).map(Boolean::parseBoolean);\n-        }\n-\n-        private final Properties data;\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":4,"deletions":34,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -32,0 +33,1 @@\n+import java.util.Collections;\n@@ -33,0 +35,1 @@\n+import java.util.LinkedHashMap;\n@@ -37,0 +40,2 @@\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n@@ -38,0 +43,1 @@\n+import javax.xml.xpath.XPathExpressionException;\n@@ -43,1 +49,0 @@\n-import org.w3c.dom.Node;\n@@ -45,1 +50,1 @@\n-public record AppImageFile(String mainLauncherName, String mainLauncherClassName,\n+public record AppImageFile(String mainLauncherName, Optional<String> mainLauncherClassName,\n@@ -64,1 +69,1 @@\n-    public AppImageFile(String mainLauncherName, String mainLauncherClassName) {\n+    public AppImageFile(String mainLauncherName, Optional<String> mainLauncherClassName) {\n@@ -68,0 +73,4 @@\n+    public AppImageFile(String mainLauncherName, String mainLauncherClassName) {\n+        this(mainLauncherName, Optional.of(mainLauncherClassName));\n+    }\n+\n@@ -69,1 +78,1 @@\n-        return launchers.entrySet().stream().filter(e -> {\n+        var map = launchers.entrySet().stream().filter(e -> {\n@@ -71,1 +80,4 @@\n-        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue, (v, _) -> {\n+            throw new IllegalStateException(String.format(\"Duplicate value [%s]\", v));\n+        }, LinkedHashMap::new));\n+        return Collections.unmodifiableMap(map);\n@@ -85,1 +97,2 @@\n-            xml.writeCharacters(mainLauncherName);\n+            xml.writeAttribute(\"name\", mainLauncherName);\n+            writeLauncherDescription(xml, mainLauncherName);\n@@ -88,3 +101,5 @@\n-            xml.writeStartElement(\"main-class\");\n-            xml.writeCharacters(mainLauncherClassName);\n-            xml.writeEndElement();\n+            mainLauncherClassName.ifPresent(toConsumer(v -> {\n+                xml.writeStartElement(\"main-class\");\n+                xml.writeCharacters(v);\n+                xml.writeEndElement();\n+            }));\n@@ -104,0 +119,3 @@\n+                if (!props.containsKey(\"description\")) {\n+                    writeLauncherDescription(xml, al);\n+                }\n@@ -123,5 +141,2 @@\n-            var mainLauncherName = xPath.evaluate(\n-                    \"\/jpackage-state\/main-launcher\/text()\", doc);\n-\n-            var mainLauncherClassName = xPath.evaluate(\n-                    \"\/jpackage-state\/main-class\/text()\", doc);\n+            var mainLauncherClassName = Optional.ofNullable(xPath.evaluate(\n+                    \"\/jpackage-state\/main-class\/text()\", doc));\n@@ -137,2 +152,3 @@\n-            var addLaunchers = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/add-launcher\").map(Element.class::cast).map(toFunction(addLauncher -> {\n-                Map<String, String> launcherProps = new HashMap<>();\n+            var addLaunchers = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/add-launcher\").map(Element.class::cast).map(toFunction(launcher -> {\n+                return readLauncherProperties(xPath, launcher);\n+            }));\n@@ -140,4 +156,22 @@\n-                \/\/ @name and @service attributes.\n-                XmlUtils.toStream(addLauncher.getAttributes()).forEach(attr -> {\n-                    launcherProps.put(attr.getNodeName(), attr.getNodeValue());\n-                });\n+            var mainLauncher = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/main-launcher[last()]\").map(Element.class::cast).map(toFunction(launcher -> {\n+                return readLauncherProperties(xPath, launcher);\n+            })).findFirst().orElseThrow();\n+\n+            var mainLauncherName = mainLauncher.get(\"name\");\n+\n+            var launchers = Stream.concat(Stream.of(mainLauncher), addLaunchers).collect(toMap(launcherProps -> {\n+                return Objects.requireNonNull(launcherProps.get(\"name\"));\n+            }, launcherProps -> {\n+                launcherProps.remove(\"name\");\n+                return Collections.unmodifiableMap(launcherProps);\n+            }, (v, _) -> {\n+                throw new IllegalStateException(String.format(\"Duplicate value [%s]\", v));\n+            }, LinkedHashMap::new));\n+\n+            return new AppImageFile(\n+                    mainLauncherName,\n+                    mainLauncherClassName,\n+                    version,\n+                    macSigned,\n+                    macAppStore,\n+                    Collections.unmodifiableMap(launchers));\n@@ -145,4 +179,2 @@\n-                \/\/ Extra properties.\n-                XmlUtils.queryNodes(addLauncher, xPath, \"*[count(*) = 0]\").map(Element.class::cast).forEach(e -> {\n-                    launcherProps.put(e.getNodeName(), e.getTextContent());\n-                });\n+        }).get();\n+    }\n@@ -150,2 +182,5 @@\n-                return launcherProps;\n-            }));\n+    private static void writeLauncherDescription(XMLStreamWriter xml, String description) throws XMLStreamException {\n+        xml.writeStartElement(\"description\");\n+        xml.writeCharacters(Objects.requireNonNull(description));\n+        xml.writeEndElement();\n+    }\n@@ -153,1 +188,2 @@\n-            var mainLauncherProperties = Map.of(\"name\", mainLauncherName);\n+    private static HashMap<String, String> readLauncherProperties(XPath xPath, Element launcherElement) throws XPathExpressionException {\n+        HashMap<String, String> launcherProps = new HashMap<>();\n@@ -155,7 +191,1 @@\n-            var launchers = Stream.concat(Stream.of(mainLauncherProperties), addLaunchers).collect(toMap(attrs -> {\n-                return Objects.requireNonNull(attrs.get(\"name\"));\n-            }, attrs -> {\n-                Map<String, String> copy = new HashMap<>(attrs);\n-                copy.remove(\"name\");\n-                return Map.copyOf(copy);\n-            }));\n+        var name = Objects.requireNonNull(xPath.evaluate(\"@name\", launcherElement));\n@@ -163,2 +193,1 @@\n-            return new AppImageFile(mainLauncherName, mainLauncherClassName,\n-                    version, macSigned, macAppStore, launchers);\n+        launcherProps.put(\"name\", name);\n@@ -166,1 +195,6 @@\n-        }).get();\n+        \/\/ Extra properties.\n+        XmlUtils.queryNodes(launcherElement, xPath, \"*[count(*) = 0]\").map(Element.class::cast).forEach(e -> {\n+            launcherProps.put(e.getNodeName(), e.getTextContent());\n+        });\n+\n+        return launcherProps;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AppImageFile.java","additions":71,"deletions":37,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+package jdk.jpackage.test;\n@@ -24,3 +25,4 @@\n-package compiler.lib.template_framework;\n-\n-record NothingToken() implements Token {}\n+@FunctionalInterface\n+public interface CannedArgument {\n+    public String getValue();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CannedArgument.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/compiler\/lib\/template_framework\/NothingToken.java","status":"renamed"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.Arrays;\n@@ -30,0 +31,1 @@\n+import java.util.function.UnaryOperator;\n@@ -32,1 +34,1 @@\n-public record CannedFormattedString(BiFunction<String, Object[], String> formatter, String key, Object[] args) {\n+public record CannedFormattedString(BiFunction<String, Object[], String> formatter, String key, Object[] args) implements CannedArgument {\n@@ -34,6 +36,1 @@\n-    @FunctionalInterface\n-    public interface CannedArgument {\n-        public String value();\n-    }\n-\n-    public static Object cannedArgument(Supplier<Object> supplier, String label) {\n+    public static CannedArgument cannedArgument(Supplier<Object> supplier, String label) {\n@@ -45,1 +42,1 @@\n-            public String value() {\n+            public String getValue() {\n@@ -64,0 +61,4 @@\n+    public CannedFormattedString mapArgs(UnaryOperator<Object> mapper) {\n+        return new CannedFormattedString(formatter, key, Stream.of(args).map(mapper).toArray());\n+    }\n+\n@@ -74,1 +75,1 @@\n-                return cannedArg.value();\n+                return cannedArg.getValue();\n@@ -81,0 +82,8 @@\n+    public CannedFormattedString addPrefix(String prefixKey) {\n+        Objects.requireNonNull(prefixKey);\n+        return new CannedFormattedString((theKey, theArgs) -> {\n+            var str = formatter.apply((String)theArgs[0], Arrays.copyOfRange(theArgs, 1, theArgs.length));\n+            return formatter.apply(theKey, new Object[] {str});\n+        }, prefixKey, Stream.concat(Stream.of(key), Stream.of(args)).toArray());\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CannedFormattedString.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-        return cmd.launcherNames(true).stream().anyMatch(launcherName -> {\n+        return !cmd.isImagePackageType() && cmd.launcherNames(true).stream().anyMatch(launcherName -> {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static java.util.stream.Collectors.toCollection;\n@@ -31,1 +32,0 @@\n-import static java.util.stream.Collectors.toCollection;\n@@ -867,0 +867,8 @@\n+    public static CannedFormattedString makeError(CannedFormattedString v) {\n+        return v.addPrefix(\"message.error-header\");\n+    }\n+\n+    public static CannedFormattedString makeAdvice(CannedFormattedString v) {\n+        return v.addPrefix(\"message.advice-header\");\n+    }\n+\n@@ -1243,0 +1251,3 @@\n+            }).filter(_ -> {\n+                \/\/ Don't examine the contents of the output app image if this is Linux package installing in the \"\/usr\" subtree.\n+                return Optional.<Boolean>ofNullable(cmd.onLinuxPackageInstallDir(null, _ -> false)).orElse(true);\n@@ -1285,1 +1296,6 @@\n-        })\n+        }),\n+        LINUX_APPLAUNCHER_LIB(cmd -> {\n+            if (TKit.isLinux() && !cmd.isRuntime()) {\n+                TKit.assertFileExists(cmd.appLayout().libapplauncher());\n+            }\n+        }),\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -249,7 +249,1 @@\n-            var mainLauncherValue = PropertyFinder.findLauncherProperty(cmd, null,\n-                    PropertyFinder.cmdlineBooleanOption(\"--launcher-as-service\"),\n-                    PropertyFinder.nop(),\n-                    PropertyFinder.nop()\n-            ).map(Boolean::parseBoolean).orElse(false);\n-\n-            var value = PropertyFinder.findLauncherProperty(cmd, launcherName,\n+            return PropertyFinder.findLauncherProperty(cmd, launcherName,\n@@ -259,3 +253,3 @@\n-            ).map(Boolean::parseBoolean);\n-\n-            return value.orElse(mainLauncherValue);\n+            ).map(Boolean::parseBoolean).orElseGet(() -> {\n+                return launcherAsService(cmd, null);\n+            });\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n@@ -447,1 +446,1 @@\n-                PropertyFinder.nop()\n+                PropertyFinder.appImageFileLauncher(cmd, launcherName, \"description\")\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -796,1 +796,1 @@\n-                PropertyFinder.appImageFile(AppImageFile::mainLauncherClassName).map(getPackageIdFromClassName)\n+                PropertyFinder.appImageFileOptional(AppImageFile::mainLauncherClassName).map(getPackageIdFromClassName)\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,5 +25,1 @@\n-import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n-\n-import java.io.PrintWriter;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n+import java.util.Collection;\n@@ -33,0 +29,1 @@\n+import java.util.NoSuchElementException;\n@@ -35,0 +32,1 @@\n+import java.util.ServiceLoader;\n@@ -36,1 +34,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -39,1 +36,4 @@\n-import jdk.jpackage.internal.Log;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.util.function.ThrowingSupplier;\n@@ -45,10 +45,6 @@\n-    WIN_MSI(\".msi\",\n-            TKit.isWindows() ? \"jdk.jpackage.internal.WinMsiBundler\" : null),\n-    WIN_EXE(\".exe\",\n-            TKit.isWindows() ? \"jdk.jpackage.internal.WinMsiBundler\" : null),\n-    LINUX_DEB(\".deb\",\n-            TKit.isLinux() ? \"jdk.jpackage.internal.LinuxDebBundler\" : null),\n-    LINUX_RPM(\".rpm\",\n-            TKit.isLinux() ? \"jdk.jpackage.internal.LinuxRpmBundler\" : null),\n-    MAC_DMG(\".dmg\", TKit.isOSX() ? \"jdk.jpackage.internal.MacDmgBundler\" : null),\n-    MAC_PKG(\".pkg\", TKit.isOSX() ? \"jdk.jpackage.internal.MacPkgBundler\" : null),\n+    WIN_MSI(\".msi\", OperatingSystem.WINDOWS),\n+    WIN_EXE(\".exe\", OperatingSystem.WINDOWS),\n+    LINUX_DEB(\".deb\", OperatingSystem.LINUX),\n+    LINUX_RPM(\".rpm\", OperatingSystem.LINUX),\n+    MAC_DMG(\".dmg\", OperatingSystem.MACOS),\n+    MAC_PKG(\".pkg\", OperatingSystem.MACOS),\n@@ -64,1 +60,1 @@\n-    PackageType(String packageName, String bundleSuffix, String bundlerClass) {\n+    PackageType(String packageName, String bundleSuffix, OperatingSystem os) {\n@@ -67,1 +63,1 @@\n-        supported = Optional.ofNullable(bundlerClass).map(PackageType::isBundlerSupported).orElse(false);\n+        supported = isSupported(new BundlingOperationDescriptor(os, type, \"create\"));\n@@ -75,2 +71,2 @@\n-    PackageType(String bundleSuffix, String bundlerClass) {\n-        this(bundleSuffix.substring(1), bundleSuffix, bundlerClass);\n+    PackageType(String bundleSuffix, OperatingSystem os) {\n+        this(bundleSuffix.substring(1), bundleSuffix, os);\n@@ -108,16 +104,1 @@\n-    private static boolean isBundlerSupportedImpl(String bundlerClass) {\n-        try {\n-            Class<?> clazz = Class.forName(bundlerClass);\n-            Method supported = clazz.getMethod(\"supported\", boolean.class);\n-            return ((Boolean) supported.invoke(\n-                    clazz.getConstructor().newInstance(), true));\n-        } catch (ClassNotFoundException | IllegalAccessException ex) {\n-        } catch (InstantiationException | NoSuchMethodException\n-                | InvocationTargetException ex) {\n-            rethrowUnchecked(ex);\n-        }\n-        return false;\n-    }\n-\n-    private static boolean isBundlerSupported(String bundlerClass) {\n-        AtomicBoolean reply = new AtomicBoolean();\n+    private static boolean isSupported(BundlingOperationDescriptor op) {\n@@ -125,17 +106,3 @@\n-            \/\/ Capture jpackage's activity on configuring bundlers.\n-            \/\/ Log configuration is thread-local.\n-            \/\/ Call Log.setPrintWriter and Log.setVerbose in a separate\n-            \/\/ thread to keep the main log configuration intact.\n-            var thread = new Thread(() -> {\n-                Log.setPrintWriter(new PrintWriter(System.out), new PrintWriter(System.err));\n-                Log.setVerbose();\n-                try {\n-                    reply.set(isBundlerSupportedImpl(bundlerClass));\n-                } finally {\n-                    Log.flush();\n-                }\n-            });\n-            thread.run();\n-            thread.join();\n-        } catch (InterruptedException ex) {\n-            rethrowUnchecked(ex);\n+            return Inner.BUNDLING_ENV.configurationErrors(op).isEmpty();\n+        } catch (NoSuchElementException ex) {\n+            return false;\n@@ -143,1 +110,0 @@\n-        return reply.get();\n@@ -158,3 +124,2 @@\n-    public static final Set<PackageType> NATIVE = Stream.concat(\n-            Stream.concat(LINUX.stream(), WINDOWS.stream()),\n-            MAC.stream()).collect(Collectors.toUnmodifiableSet());\n+    public static final Set<PackageType> NATIVE = Stream.of(LINUX, WINDOWS, MAC)\n+            .flatMap(Collection::stream).collect(Collectors.toUnmodifiableSet());\n@@ -166,0 +131,9 @@\n+\n+        private static final BundlingEnvironment BUNDLING_ENV = ServiceLoader.load(\n+                ThrowingSupplier.toSupplier(() -> {\n+                    @SuppressWarnings(\"unchecked\")\n+                    var reply = (Class<BundlingEnvironment>)Class.forName(\"jdk.jpackage.internal.cli.CliBundlingEnvironment\");\n+                    return reply;\n+                }).get(),\n+                BundlingEnvironment.class.getClassLoader()\n+        ).findFirst().orElseThrow();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageType.java","additions":32,"deletions":58,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+public final class PropertyFile {\n+\n+    PropertyFile(Map<String, String> data) {\n+        this.data = new Properties();\n+        this.data.putAll(data);\n+        path = Optional.empty();\n+    }\n+\n+    PropertyFile(Path path) {\n+        data = new Properties();\n+        try (var reader = Files.newBufferedReader(path)) {\n+            data.load(reader);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+        this.path = Optional.of(path);\n+    }\n+\n+    public Optional<String> findProperty(String name) {\n+        Objects.requireNonNull(name);\n+        return Optional.ofNullable(data.getProperty(name));\n+    }\n+\n+    public Optional<Boolean> findBooleanProperty(String name) {\n+        return findProperty(name).map(Boolean::parseBoolean);\n+    }\n+\n+    public Optional<Path> path() {\n+        return path;\n+    }\n+\n+    public Path getPath() {\n+        return path().orElseThrow();\n+    }\n+\n+    public Map<String, String> toMap() {\n+        return data.entrySet().stream().collect(Collectors.toUnmodifiableMap(e -> {\n+            return (String)e.getKey();\n+        }, e -> {\n+            return (String)e.getValue();\n+        }));\n+    }\n+\n+    private final Properties data;\n+    private final Optional<Path> path;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PropertyFile.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PropertyFinder.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,6 @@\n-lib.dirs = \/test\/jdk\/tools\/jpackage\/helpers \/test\/jdk\/tools\/jpackage\/junit\/tools\n+# \/test\/jdk\/tools\/jpackage\/share is needed to load ErrorTest class used in\n+# jdk.jpackage.internal.cli.StandardValueConverterTest unit test.\n+lib.dirs = \\\n+        \/test\/jdk\/tools\/jpackage\/helpers \\\n+        \/test\/jdk\/tools\/jpackage\/share \\\n+        \/test\/jdk\/tools\/jpackage\/junit\/tools\n@@ -6,0 +11,1 @@\n+        jdk.jpackage\/jdk.jpackage.internal.cli:+open \\\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,12 @@\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.DESCRIPTION;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LAUNCHER_NAME;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.LINUX_LAUNCHER_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_APP_STORE;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_DESKTOP_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardAppImageFileOption.WIN_LAUNCHER_MENU_SHORTCUT;\n+import static jdk.jpackage.internal.cli.StandardOption.APPCLASS;\n+import static jdk.jpackage.internal.cli.StandardOption.APP_VERSION;\n+import static jdk.jpackage.internal.cli.StandardOption.NAME;\n@@ -27,0 +39,2 @@\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -29,0 +43,1 @@\n+import java.io.FileOutputStream;\n@@ -34,0 +49,1 @@\n+import java.util.Collection;\n@@ -39,2 +55,1 @@\n-import java.util.function.Function;\n-import java.util.stream.Collectors;\n+import java.util.function.Supplier;\n@@ -42,0 +57,6 @@\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.OptionIdentifier;\n+import jdk.jpackage.internal.cli.OptionValue;\n+import jdk.jpackage.internal.cli.Options;\n+import jdk.jpackage.internal.cli.StandardAppImageFileOption.AppImageFileOptionScope;\n+import jdk.jpackage.internal.cli.WithOptionIdentifier;\n@@ -45,1 +66,1 @@\n-import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.ExternalApplication;\n@@ -47,0 +68,1 @@\n+import jdk.jpackage.internal.model.JPackageException;\n@@ -48,1 +70,3 @@\n-import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import jdk.jpackage.test.ObjectMapper;\n@@ -51,0 +75,2 @@\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n@@ -53,1 +79,0 @@\n-import org.junit.jupiter.params.provider.Arguments;\n@@ -59,2 +84,55 @@\n-    static AppImageBuilder build() {\n-        return new AppImageBuilder();\n+    @Test\n+    public void testSimple() {\n+        build().createInDir(tempFolder);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testArbitraryExtra(Map<String, String> extra) {\n+        build().addExtra(extra).createInDir(tempFolder);\n+    }\n+\n+    @Test\n+    public void testAdditionalLaunchers() {\n+        build().addlauncher(\"T\").commit()\n+                .addlauncher(\"U\").service(true).commit()\n+                .addlauncher(\"F\").addExtra(Map.of(\"prop\", \"one\", \"prop2\", \"two\", \"prop3\", \"\")).commit()\n+                .createInDir(tempFolder);\n+    }\n+\n+    @Test\n+    public void testMalformedXml() throws IOException {\n+        var ex = assertThrowsExactly(JPackageException.class, () -> createFromXml(List.of(\"<a>\"), OperatingSystem.current(), tempFolder));\n+        Assertions.assertEquals(I18N.format(\"error.malformed-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNotNull(ex.getCause());\n+    }\n+\n+    @Test\n+    public void testNoSuchFile() throws IOException {\n+        var ex = assertThrowsExactly(JPackageException.class, () -> AppImageFile.load(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+        Assertions.assertEquals(I18N.format(\"error.missing-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNull(ex.getCause());\n+    }\n+\n+    @Test\n+    public void testDirectory() throws IOException {\n+        Files.createDirectory(AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+\n+        var ex = assertThrowsExactly(JPackageException.class, () -> AppImageFile.load(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+        Assertions.assertEquals(I18N.format(\"error.reading-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNotNull(ex.getCause());\n+    }\n+\n+    @Test\n+    @EnabledOnOs(value = OS.WINDOWS, disabledReason = \"Can reliably lock a file using FileLock to cuase an IOException on Windows only\")\n+    @SuppressWarnings(\"try\")\n+    public void testGenericIOException() throws IOException {\n+\n+        final var appImageFile = AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(tempFolder));\n+        Files.writeString(appImageFile, \"\");\n+\n+        try (var out = new FileOutputStream(appImageFile.toFile()); var lock = out.getChannel().lock()) {\n+            var ex = assertThrowsExactly(JPackageException.class, () -> AppImageFile.load(DUMMY_LAYOUT.resolveAt(tempFolder)));\n+            Assertions.assertEquals(I18N.format(\"error.reading-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+            assertNotNull(ex.getCause());\n+        }\n@@ -63,1 +141,13 @@\n-    static class AppImageBuilder {\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testInavlidXml(List<String> xmlData) throws IOException {\n+        var ex = assertThrowsExactly(JPackageException.class, () -> createFromXml(xmlData, OperatingSystem.current(), tempFolder));\n+        Assertions.assertEquals(I18N.format(\"error.invalid-app-image-file\", \".jpackage.xml\", tempFolder), ex.getMessage());\n+        assertNotNull(ex.getCause());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testValidXml(ReadTestSpec testSpec) throws IOException {\n+        testSpec.test(tempFolder);\n+    }\n@@ -65,1 +155,4 @@\n-        AppImageBuilder version(String v) {\n+\n+    private static final class AppBuilder {\n+\n+        AppBuilder version(String v) {\n@@ -70,2 +163,2 @@\n-        AppImageBuilder launcherName(String v) {\n-            launcherName = Objects.requireNonNull(v);\n+        AppBuilder appName(String v) {\n+            appName = Objects.requireNonNull(v);\n@@ -75,1 +168,1 @@\n-        AppImageBuilder mainClass(String v) {\n+        AppBuilder mainClass(String v) {\n@@ -80,2 +173,2 @@\n-        AppImageBuilder addExtra(Map<String, String> v) {\n-            extra.putAll(v);\n+        AppBuilder addExtra(Map<String, String> v) {\n+            extra.add(v);\n@@ -85,2 +178,2 @@\n-        AppImageBuilder addExtra(String key, String value) {\n-            extra.putAll(Map.of(key, value));\n+        <T> AppBuilder addExtra(WithOptionIdentifier option, T value) {\n+            extra.add(option, value);\n@@ -90,2 +183,2 @@\n-        AppImageBuilder addlauncher(String name) {\n-            return addlauncher(name, false);\n+        LauncherBuilder addlauncher(String name) {\n+            return new LauncherBuilder(name);\n@@ -94,2 +187,2 @@\n-        AppImageBuilder addlauncher(String name, boolean isService) {\n-            return addlauncher(name, isService, Map.of());\n+        LauncherBuilder mainlauncher() {\n+            return mainLauncherBuilder;\n@@ -98,5 +191,18 @@\n-        AppImageBuilder addlauncher(String name, boolean isService, Map<String, String> extra) {\n-            Objects.requireNonNull(name);\n-            Objects.requireNonNull(extra);\n-            addLauncherInfos.add(new LauncherInfo(name, isService, extra));\n-            return this;\n+        ExternalApplication createExternalApplication(OperatingSystem os) {\n+            var mainLauncherInfo = mainLauncherBuilder.createLauncherInfo();\n+\n+            var appOptions = Options.concat(\n+                    Options.of(Map.of(\n+                            APP_VERSION, version,\n+                            NAME, appName,\n+                            APPCLASS, mainClass)\n+                    ),\n+                    extra.asObjectValues(),\n+                    mainLauncherInfo.asOptions());\n+\n+            return ExternalApplication.create(\n+                    appOptions,\n+                    addLauncherBuilders.stream()\n+                            .map(LauncherBuilder::createLauncherInfo)\n+                            .map(LauncherInfo::asOptions).toList(),\n+                    os);\n@@ -105,2 +211,23 @@\n-        AppImageBuilder addlauncher(String name, Map<String, String> extra) {\n-            return addlauncher(name, false, extra);\n+        private Application createApplication() {\n+            var mainLauncher = mainLauncherBuilder.createLauncher();\n+\n+            var fullExtra = extra.asStringValues();\n+            if (OperatingSystem.isMacOS() && !fullExtra.containsKey(APPCLASS.getName())) {\n+                fullExtra = new HashMap<>(fullExtra);\n+                fullExtra.put(APPCLASS.getName(), mainClass);\n+            }\n+\n+            return new Application.Stub(\n+                    null,\n+                    null,\n+                    version,\n+                    null,\n+                    null,\n+                    Optional.empty(),\n+                    List.of(),\n+                    null,\n+                    Optional.empty(),\n+                    new ApplicationLaunchers(\n+                            mainLauncher,\n+                            addLauncherBuilders.stream().map(LauncherBuilder::createLauncher).toList()).asList(),\n+                    fullExtra);\n@@ -109,5 +236,7 @@\n-        AppImageFile create() {\n-            final var additionalLaunchers = addLauncherInfos.stream().map(li -> {\n-                return (Launcher)new Launcher.Stub(li.name(), Optional.empty(),\n-                        List.of(), li.service(), null, Optional.empty(), null, li.extra());\n-            }).toList();\n+        void createInDir(Path dir) {\n+            final var app = createApplication();\n+            final var copy = toSupplier(() -> {\n+                var layout = DUMMY_LAYOUT.resolveAt(dir);\n+                new AppImageFile(app).save(layout);\n+                return AppImageFile.load(layout);\n+            }).get();\n@@ -115,3 +244,2 @@\n-            final var startupInfo = new LauncherStartupInfo.Stub(mainClass, List.of(), List.of(), List.of());\n-            final var mainLauncher = new Launcher.Stub(launcherName, Optional.of(startupInfo),\n-                    List.of(), false, null, Optional.empty(), null, Map.of());\n+            assertEquals(createExternalApplication(OperatingSystem.current()), copy);\n+        }\n@@ -119,3 +247,0 @@\n-            final var app = new Application.Stub(null, null, version, null, null,\n-                    Optional.empty(), List.of(), null, Optional.empty(),\n-                    new ApplicationLaunchers(mainLauncher, additionalLaunchers).asList(), extra);\n@@ -123,1 +248,78 @@\n-            return new AppImageFile(app);\n+        final class LauncherBuilder {\n+            private LauncherBuilder(String name) {\n+                this.name = Optional.of(name);\n+            }\n+\n+            private LauncherBuilder() {\n+                this.name = Optional.empty();\n+            }\n+\n+            LauncherBuilder service(boolean v) {\n+                service = v;\n+                return this;\n+            }\n+\n+            LauncherBuilder description(String v) {\n+                description = v;\n+                return this;\n+            }\n+\n+            LauncherBuilder addExtra(Map<String, String> v) {\n+                extra.add(v);\n+                return this;\n+            }\n+\n+            <T> LauncherBuilder addExtra(WithOptionIdentifier option, T value) {\n+                extra.add(option, value);\n+                return this;\n+            }\n+\n+            AppBuilder commit() {\n+                if (!isMainLauncher()) {\n+                    addLauncherBuilders.add(this);\n+                }\n+                return AppBuilder.this;\n+            }\n+\n+            private Launcher createLauncher() {\n+                return new Launcher.Stub(\n+                        name(),\n+                        Optional.empty(),\n+                        List.of(),\n+                        service,\n+                        description(),\n+                        Optional.empty(),\n+                        null,\n+                        extra.asStringValues());\n+            }\n+\n+            private String name() {\n+                if (isMainLauncher()) {\n+                    return Objects.requireNonNull(appName);\n+                } else {\n+                    return name.orElseThrow();\n+                }\n+            }\n+\n+            private String description() {\n+                return Optional.ofNullable(description).orElseGet(this::name);\n+            }\n+\n+            private boolean isMainLauncher() {\n+                return name.isEmpty();\n+            }\n+\n+            private LauncherInfo createLauncherInfo() {\n+                var allProps = new ExtraPropertyBuilder(extra);\n+                if (service) {\n+                    allProps.add(LAUNCHER_AS_SERVICE, Boolean.valueOf(service));\n+                }\n+                allProps.add(LAUNCHER_NAME, name());\n+                allProps.add(DESCRIPTION, description());\n+                return LauncherInfo.create(allProps.asObjectValues());\n+            }\n+\n+            private final Optional<String> name;\n+            private boolean service;\n+            private String description;\n+            private final ExtraPropertyBuilder extra = new ExtraPropertyBuilder();\n@@ -126,6 +328,0 @@\n-        void createInDir(Path dir) {\n-            final var file = create();\n-            final var copy = toSupplier(() -> {\n-                file.save(DUMMY_LAYOUT.resolveAt(dir));\n-                return AppImageFile.load(dir, DUMMY_LAYOUT);\n-            }).get();\n@@ -133,1 +329,30 @@\n-            assertEquals(file, copy);\n+        private static final class ExtraPropertyBuilder {\n+\n+            ExtraPropertyBuilder() {\n+            }\n+\n+            ExtraPropertyBuilder(ExtraPropertyBuilder other) {\n+                stringValues.putAll(other.stringValues);\n+                objValues.putAll(other.objValues);\n+            }\n+\n+            ExtraPropertyBuilder add(Map<String, String> v) {\n+                stringValues.putAll(v);\n+                return this;\n+            }\n+\n+            <T> ExtraPropertyBuilder add(WithOptionIdentifier option, T value) {\n+                objValues.put(option, Objects.requireNonNull(value));\n+                return this;\n+            }\n+\n+            Map<String, String> asStringValues() {\n+                return Map.copyOf(stringValues);\n+            }\n+\n+            Options asObjectValues() {\n+                return Options.of(objValues);\n+            }\n+\n+            private final Map<String, String> stringValues = new HashMap<>();\n+            private final Map<WithOptionIdentifier, Object> objValues = new HashMap<>();\n@@ -136,0 +361,1 @@\n+\n@@ -137,1 +363,1 @@\n-        private String launcherName = \"Foo\";\n+        private String appName = \"Foo\";\n@@ -139,2 +365,3 @@\n-        private Map<String, String> extra = new HashMap<>();\n-        private List<LauncherInfo> addLauncherInfos = new ArrayList<>();\n+        private final ExtraPropertyBuilder extra = new ExtraPropertyBuilder();\n+        private final LauncherBuilder mainLauncherBuilder = new LauncherBuilder();\n+        private final List<LauncherBuilder> addLauncherBuilders = new ArrayList<>();\n@@ -143,3 +370,47 @@\n-    @Test\n-    public void testSimple() {\n-        build().createInDir(tempFolder);\n+\n+    private record ReadTestSpec(ExternalApplication expected, List<String> xmlData, OperatingSystem os) {\n+\n+        ReadTestSpec {\n+            Objects.requireNonNull(expected);\n+            Objects.requireNonNull(xmlData);\n+            Objects.requireNonNull(os);\n+        }\n+\n+        void test(Path appImageDir) throws IOException {\n+            var actual = createFromXml(xmlData, os, appImageDir);\n+            assertEquals(expected, actual);\n+        }\n+\n+        static Builder build() {\n+            return new Builder();\n+        }\n+\n+        static final class Builder {\n+\n+            Builder expect(AppBuilder builder) {\n+                return expect(builder.createExternalApplication(os));\n+            }\n+\n+            Builder expect(ExternalApplication v) {\n+                expected = v;\n+                return this;\n+            }\n+\n+            Builder xml(String... xml) {\n+                xmlData = List.of(xml);\n+                return this;\n+            }\n+\n+            Builder os(OperatingSystem v) {\n+                os = v;\n+                return this;\n+            }\n+\n+            ReadTestSpec create() {\n+                return new ReadTestSpec(expected, createXml(os, xmlData.toArray(String[]::new)), os);\n+            }\n+\n+            private ExternalApplication expected;\n+            private List<String> xmlData;\n+            private OperatingSystem os = OperatingSystem.LINUX;\n+        }\n@@ -148,4 +419,3 @@\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testExtra(Map<String, String> extra) {\n-        build().addExtra(extra).createInDir(tempFolder);\n+\n+    private static AppBuilder build() {\n+        return new AppBuilder();\n@@ -154,1 +424,1 @@\n-    private static Stream<Map<String, String>> testExtra() {\n+    private static Stream<Map<String, String>> testArbitraryExtra() {\n@@ -158,6 +428,53 @@\n-    @Test\n-    public void testAdditionalLaunchers() {\n-        build().addlauncher(\"T\")\n-                .addlauncher(\"U\", true)\n-                .addlauncher(\"F\", Map.of(\"prop\", \"one\", \"prop2\", \"two\", \"prop3\", \"\"))\n-                .createInDir(tempFolder);\n+    private static List<List<String>> testInavlidXml() {\n+        List<List<String>> data = new ArrayList<>();\n+\n+        var os = OperatingSystem.current();\n+\n+        data.addAll(List.of\n+                (List.of(\"<foo\/>\"),\n+                createValidBodyWithHeader(null, null),\n+                createValidBodyWithHeader(\"foo\", \"foo\"),\n+                createValidBodyWithHeader(null, \"foo\"),\n+                createValidBodyWithHeader(\"foo\", null),\n+                createValidBodyWithHeader(AppImageFile.getPlatform(os), null),\n+                createValidBodyWithHeader(AppImageFile.getPlatform(os), \"foo\"),\n+                createValidBodyWithHeader(null, AppImageFile.getVersion()),\n+                createValidBodyWithHeader(\"foo\", AppImageFile.getVersion()),\n+                createXml(os, \"<main-launcher><\/main-launcher>\"),\n+                createXml(os, \"<main-launcher>A<\/main-launcher>\"),\n+                createXml(os, \"<add-launcher>A<\/add-launcher>\"),\n+                createXml(os, createValidBodyWithHeader(AppImageFile.getPlatform(os), AppImageFile.getVersion()).toArray(String[]::new)),\n+                createWithHeader(AppImageFile.getPlatform(os), AppImageFile.getVersion(), () -> {\n+                    \/\/ Missing 'app-version' element.\n+                    return List.of(\n+                            \"<main-launcher name='D'>\",\n+                            \"  <description>Foo<\/description>\",\n+                            \"<\/main-launcher>\",\n+                            \"<main-class>Hello<\/main-class>\"\n+                    );\n+                }),\n+                createWithHeader(AppImageFile.getPlatform(os), AppImageFile.getVersion(), () -> {\n+                    \/\/ Missing 'description' element in the main launcher.\n+                    return List.of(\n+                            \"<app-version>321<\/app-version>\",\n+                            \"<main-launcher name='B'\/>\"\n+                    );\n+                }),\n+                createWithHeader(AppImageFile.getPlatform(os), AppImageFile.getVersion(), () -> {\n+                    \/\/ Missing 'description' element in the additional launcher.\n+                    return List.of(\n+                            \"<app-version>123<\/app-version>\",\n+                            \"<main-launcher name='B'>\",\n+                            \"  <description>Foo<\/description>\",\n+                            \"<\/main-launcher>\",\n+                            \"<main-class>Hello<\/main-class>\",\n+                            \"<add-launcher name='C'\/>\"\n+                    );\n+                })\n+        ));\n+\n+        if (OperatingSystem.isMacOS()) {\n+            data.add(createXml(os, \"<main-launcher name='Foo'\/>\", \"<main-class><\/main-class>\"));\n+        }\n+\n+        return data;\n@@ -166,5 +483,9 @@\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testInavlidXml(List<String> xmlData) throws IOException {\n-        assertThrowsExactly(ConfigException.class, () -> createFromXml(xmlData), () -> {\n-            return I18N.format(\"error.invalid-app-image\", tempFolder, \".jpackage.xml\");\n+    private static List<String> createValidBodyWithHeader(String platform, String version) {\n+        return createWithHeader(platform, version, () -> {\n+            return List.of(\n+                    \"<main-launcher name='D'>\",\n+                    \"  <description>Blah-Blah-Blah<\/description>\",\n+                    \"<\/main-launcher>\",\n+                    \"<app-version>100<\/app-version>\",\n+                    \"<main-class>Hello<\/main-class>\"\n+            );\n@@ -174,8 +495,13 @@\n-    private static Stream<List<String>> testInavlidXml() {\n-        return Stream.of(List.of(\"<foo\/>\"),\n-                List.of(\"<jpackage-state\/>\"),\n-                createXml(),\n-                createXml(\"<main-launcher><\/main-launcher>\"),\n-                createXml(\"<main-launcher>Foo<\/main-launcher>\", \"<main-class><\/main-class>\"),\n-                createXml(\"<add-launcher>A<\/add-launcher>\")\n-        );\n+    private static List<String> createWithHeader(String platform, String version, Supplier<List<String>> body) {\n+\n+        var sb = new StringBuilder();\n+        sb.append(\"<jpackage-state\");\n+        Optional.ofNullable(platform).ifPresent(v -> {\n+            sb.append(String.format(\" platform=\\\"%s\\\"\", v));\n+        });\n+        Optional.ofNullable(version).ifPresent(v -> {\n+            sb.append(String.format(\" version=\\\"%s\\\"\", v));\n+        });\n+        sb.append(\">\");\n+\n+        return Stream.of(List.of(sb.toString()), body.get(), List.of(\"<\/jpackage-state>\")).flatMap(Collection::stream).toList();\n@@ -184,5 +510,43 @@\n-    @ParameterizedTest\n-    @MethodSource\n-    public void testValidXml(AppImageFile expected, List<String> xmlData) throws IOException, ConfigException {\n-        final var actual = createFromXml(xmlData);\n-        assertEquals(expected, actual);\n+\n+    private static Collection<ReadTestSpec> platformSpecificProperties() {\n+        var builder = ReadTestSpec.build().xml(\n+                \"<app-version>1.34<\/app-version>\",\n+                \"<main-class>Foo<\/main-class>\",\n+                \"<y\/>\",\n+                \"<x>property-x<\/x>\",\n+                \"<signed>true<\/signed>\",\n+                \"<app-store>False<\/app-store>\",\n+                \"<add-launcher name='add-launcher'>\",\n+                \"  <description>Quick brown fox<\/description>\",\n+                \"  <service>true<\/service>\",\n+                \"  <linux-shortcut>true<\/linux-shortcut>\",\n+                \"  <win-shortcut>false<\/win-shortcut>\",\n+                \"  <win-menu>app-dir<\/win-menu>\",\n+                \"<\/add-launcher>\",\n+                \"<main-launcher name='Bar'>\",\n+                \"  <description>Bar launcher description<\/description>\",\n+                \"<\/main-launcher>\"\n+        );\n+\n+        Supplier<AppBuilder.LauncherBuilder> appBuilder = () -> {\n+            return build()\n+                    .mainClass(\"Foo\")\n+                    .version(\"1.34\")\n+                    .appName(\"Bar\")\n+                    .mainlauncher().description(\"Bar launcher description\").commit()\n+                    .addlauncher(\"add-launcher\").service(true).description(\"Quick brown fox\");\n+        };\n+\n+        List<ReadTestSpec> testCases = new ArrayList<>();\n+        testCases.add(builder.os(OperatingSystem.LINUX).expect(appBuilder.get()\n+                .addExtra(LINUX_LAUNCHER_SHORTCUT, new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT)).commit()).create());\n+\n+        testCases.add(builder.os(OperatingSystem.WINDOWS).expect(appBuilder.get()\n+                .addExtra(WIN_LAUNCHER_DESKTOP_SHORTCUT, new LauncherShortcut())\n+                .addExtra(WIN_LAUNCHER_MENU_SHORTCUT, new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR)).commit()).create());\n+\n+        testCases.add(builder.os(OperatingSystem.MACOS).expect(appBuilder.get().commit()\n+                .addExtra(MAC_APP_STORE, false)\n+                .addExtra(MAC_SIGNED, true)).create());\n+\n+        return testCases;\n@@ -191,4 +555,8 @@\n-    private static Stream<Arguments> testValidXml() {\n-        return Stream.of(\n-                Arguments.of(build().version(\"72\").launcherName(\"Y\").mainClass(\"main.Class\").create(), createXml(\n-                        \"<main-launcher>Y<\/main-launcher>\",\n+    private static Stream<ReadTestSpec> testValidXml() {\n+        return Stream.concat(platformSpecificProperties().stream(), Stream.of(\n+                ReadTestSpec.build().expect(\n+                        build().version(\"72\").mainlauncher().description(\"Blah-Blah-Blah\").commit().appName(\"Y\").mainClass(\"main.Class\")\n+                ).xml(\n+                        \"<main-launcher name='Y'>\",\n+                        \"  <description>Blah-Blah-Blah<\/description>\",\n+                        \"<\/main-launcher>\",\n@@ -196,16 +564,1 @@\n-                        \"<main-class>main.Class<\/main-class>\")\n-                ),\n-                Arguments.of(build().addExtra(\"x\", \"property-x\").addExtra(\"signed\", \"false\")\n-                        .addExtra(\"y\", \"\").addlauncher(\"another-launcher\").addlauncher(\"service-launcher\", true)\n-                        .addlauncher(\"launcher-with-extra\", Map.of(\"a\", \"\", \"b\", \"\", \"c\", \"Q\"))\n-                        .addlauncher(\"service-launcher-with-extra\", true, Map.of(\"h\", \"F\")).create(), createXml(\n-                        \"<app-version>1.0<\/app-version>\",\n-                        \"<main-class>Main<\/main-class>\",\n-                        \"<y\/>\",\n-                        \"<x>property-x<\/x>\",\n-                        \"<signed>false<\/signed>\",\n-                        \"<add-launcher name='service-launcher' service='true'\/>\",\n-                        \"<add-launcher name='another-launcher'><\/add-launcher>\",\n-                        \"<add-launcher name='launcher-with-extra'><a><\/a><b\/><c>Q<\/c><\/add-launcher>\",\n-                        \"<add-launcher name='service-launcher-with-extra' service='true'><h>F<\/h><\/add-launcher>\",\n-                        \"<main-launcher>Foo<\/main-launcher>\")\n+                        \"<main-class>main.Class<\/main-class>\"\n@@ -213,1 +566,12 @@\n-                Arguments.of(build().addExtra(\"signed\", \"FalsE\").create(), createXml(\n+                ReadTestSpec.build().os(OperatingSystem.LINUX).expect(\n+                        build()\n+                        .mainlauncher().description(\"Main launcher description\").commit()\n+                        .addlauncher(\"another-launcher\")\n+                                .addExtra(LINUX_LAUNCHER_SHORTCUT, new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR))\n+                                .description(\"another-launcher description\")\n+                                .commit()\n+                        .addlauncher(\"service-launcher\")\n+                                .service(true)\n+                                .description(\"service-launcher description\")\n+                                .commit()\n+                ).xml(\n@@ -218,10 +582,1 @@\n-                        \"<main-launcher>Bar<\/main-launcher>\",\n-                        \"<main-launcher>Foo<\/main-launcher>\",\n-                        \"<signed>false<\/signed>\",\n-                        \"<signed>FalsE<\/signed>\")\n-                ),\n-                Arguments.of(build().addExtra(\"signed\", \"true\").addExtra(\"with-comment\", \"ab\")\n-                        .addlauncher(\"a\", Map.of(\"bar\", \"foo\")).create(), createXml(\n-                        \"<app-version>1.0<\/app-version>\",\n-                        \"<main-class>Main<\/main-class>\",\n-                        \"<main-launcher>Foo<\/main-launcher>\",\n+                        \"<x>property-x<\/x>\",\n@@ -229,4 +584,13 @@\n-                        \"<with-comment>a<!-- This is a comment -->b<\/with-comment>\",\n-                        \"<add-launcher name='a'><name>foo<\/name><bar>foo<\/bar><service>true<\/service><\/add-launcher>\",\n-                        \"<other><nested>false<\/nested><\/other>\",\n-                        \"<another-other>A<child\/>B<\/another-other>\")\n+                        \"<add-launcher name='service-launcher' service='true'>\",\n+                        \"  <linux-shortcut><nested>foo<\/nested><\/linux-shortcut>\",\n+                        \"  <description>service-launcher description<\/description>\",\n+                        \"<\/add-launcher>\",\n+                        \"<add-launcher name='another-launcher'>\",\n+                        \"  <linux-shortcut>true<\/linux-shortcut>\",\n+                        \"  <linux-shortcut>app-<!-- This is a comment -->dir<\/linux-shortcut>\",\n+                        \"  <description>another-launcher description<\/description>\",\n+                        \"<\/add-launcher>\",\n+                        \"<main-launcher name='Bar'\/>\",\n+                        \"<main-launcher name='Foo'>\",\n+                        \"  <description>Main launcher description<\/description>\",\n+                        \"<\/main-launcher>\"\n@@ -234,1 +598,1 @@\n-        );\n+        ).map(ReadTestSpec.Builder::create));\n@@ -237,4 +601,2 @@\n-    private AppImageFile createFromXml(List<String> xmlData) throws IOException, ConfigException {\n-        Path path = AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(tempFolder));\n-        path.toFile().mkdirs();\n-        Files.delete(path);\n+    private static ExternalApplication createFromXml(List<String> xmlData, OperatingSystem os, Path appImageDir) throws IOException {\n+        Path path = AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(appImageDir));\n@@ -246,2 +608,1 @@\n-        Files.write(path, data, StandardOpenOption.CREATE,\n-                    StandardOpenOption.TRUNCATE_EXISTING);\n+        Files.write(path, data, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);\n@@ -249,1 +610,1 @@\n-        AppImageFile image = AppImageFile.load(tempFolder, DUMMY_LAYOUT);\n+        ExternalApplication image = AppImageFile.load(DUMMY_LAYOUT.resolveAt(appImageDir), os);\n@@ -253,6 +614,2 @@\n-    private static void assertEquals(AppImageFile expected, AppImageFile actual) {\n-        assertPropertyEquals(expected, actual, AppImageFile::getAppVersion);\n-        assertPropertyEquals(expected, actual, AppImageFile::getLauncherName);\n-        assertPropertyEquals(expected, actual, AppImageFile::getMainClass);\n-        assertPropertyEquals(expected, actual, AppImageFile::getExtra);\n-        Assertions.assertEquals(additionaLaunchersAsMap(expected), additionaLaunchersAsMap(actual));\n+    private static void assertEquals(ExternalApplication expected, ExternalApplication actual) {\n+        Assertions.assertEquals(OM.map(expected), OM.map(actual));\n@@ -261,2 +618,4 @@\n-    private static Map<String, AppImageFile.LauncherInfo> additionaLaunchersAsMap(AppImageFile file) {\n-        return file.getAddLaunchers().stream().collect(Collectors.toMap(AppImageFile.LauncherInfo::name, x -> x));\n+    private static Map<String, Map<String, Object>> additionaLaunchersAsMap(ExternalApplication file) {\n+        return file.addLaunchers().stream().collect(toMap(LauncherInfo::name, li -> {\n+            return toPropertyMap(li.asOptions());\n+        }));\n@@ -265,5 +624,1 @@\n-    private static <T, U> void assertPropertyEquals(T expected, T actual, Function<T, U> getProperty) {\n-        Assertions.assertEquals(getProperty.apply(expected), getProperty.apply(actual));\n-    }\n-\n-    private static final List<String> createXml(String ...xml) {\n+    private static final List<String> createXml(OperatingSystem os, String ...xml) {\n@@ -271,1 +626,1 @@\n-        content.add(String.format(\"<jpackage-state platform=\\\"%s\\\" version=\\\"%s\\\">\", AppImageFile.getPlatform(), AppImageFile.getVersion()));\n+        content.add(String.format(\"<jpackage-state platform=\\\"%s\\\" version=\\\"%s\\\">\", AppImageFile.getPlatform(os), AppImageFile.getVersion()));\n@@ -277,0 +632,6 @@\n+    private static Map<String, Object> toPropertyMap(Options options) {\n+        return options.toMap().entrySet().stream().collect(toMap(e -> {\n+            return Objects.requireNonNull(OPTIONS.get(e.getKey()));\n+        }, Map.Entry::getValue));\n+    }\n+\n@@ -280,0 +641,2 @@\n+    private static final ObjectMapper OM;\n+\n@@ -281,0 +644,26 @@\n+\n+    private final static Map<OptionIdentifier, String> OPTIONS = Stream.of(AppImageFileOptionScope.values())\n+            .flatMap(AppImageFileOptionScope::options)\n+            .collect(toMap(OptionValue::id, OptionValue::getName));\n+\n+    static {\n+        var app = build().addlauncher(\"foo\").commit().createExternalApplication(OperatingSystem.current());\n+\n+        OM = ObjectMapper.standard()\n+                .subst(ExternalApplication.class, \"addLaunchers\", obj -> {\n+                    return additionaLaunchersAsMap(obj);\n+                })\n+                .subst(ExternalApplication.class, \"extra\", obj -> {\n+                    return toPropertyMap(obj.extra());\n+                })\n+                .subst(LauncherInfo.class, \"extra\", obj -> {\n+                    return toPropertyMap(obj.extra());\n+                })\n+                .subst(LauncherInfo.class, \"asOptions\", obj -> {\n+                    return toPropertyMap(obj.asOptions());\n+                })\n+                .exceptLeafClasses().add(NAME.id().getClass().getName()).apply()\n+                .exceptSomeMethods(app.getClass()).add(\"options\").apply()\n+                .exceptSomeMethods(app.mainLauncher().getClass()).add(\"options\").apply()\n+                .create();\n+    }\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":527,"deletions":138,"binary":false,"changes":665,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.Optional;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class DefaultBundlingEnvironmentTest {\n+\n+    @Test\n+    void testDefaultBundlingOperation() {\n+\n+        var executed = new int[1];\n+\n+        var descriptor = new BundlingOperationDescriptor(OperatingSystem.current(), \"foo\", \"build\");\n+\n+        var env = new DefaultBundlingEnvironment(DefaultBundlingEnvironment.build().defaultOperation(() -> {\n+            executed[0] = executed[0] + 1;\n+            return Optional.of(descriptor);\n+        }));\n+\n+        \/\/ Assert the default bundling operation supplier is not called in the ctor.\n+        assertEquals(0, executed[0]);\n+\n+        \/\/ Assert the default bundling operation is as expected.\n+        assertEquals(descriptor, env.defaultOperation().orElseThrow());\n+        assertEquals(1, executed[0]);\n+\n+        \/\/ Assert the default bundling operation supplier is called only once.\n+        assertEquals(descriptor, env.defaultOperation().orElseThrow());\n+        assertEquals(1, executed[0]);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DefaultBundlingEnvironmentTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-import jdk.jpackage.internal.model.PackagerException;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.ValueSource;\n-\n-\n-public class DeployParamsTest {\n-\n-    @Test\n-    public void testValidAppName() throws PackagerException {\n-        initParamsAppName();\n-\n-        setAppNameAndValidate(\"Test\");\n-\n-        setAppNameAndValidate(\"Test Name\");\n-\n-        setAppNameAndValidate(\"Test - Name !!!\");\n-    }\n-\n-    @ParameterizedTest\n-    @ValueSource(strings = {\"Test\\nName\", \"Test\\rName\", \"TestName\\\\\", \"Test \\\" Name\"})\n-    public void testInvalidAppName(String appName) throws PackagerException {\n-        initParamsAppName();\n-        var ex = assertThrowsExactly(PackagerException.class, () -> setAppNameAndValidate(appName));\n-\n-        assertTrue(ex.getMessage().startsWith(\"Error: Invalid Application name\"));\n-    }\n-\n-    \/\/ Returns deploy params initialized to pass all validation, except for\n-    \/\/ app name\n-    private void initParamsAppName() {\n-        params = new DeployParams();\n-\n-        params.addBundleArgument(Arguments.CLIOptions.APPCLASS.getId(),\n-                \"TestClass\");\n-        params.addBundleArgument(Arguments.CLIOptions.MAIN_JAR.getId(),\n-                \"test.jar\");\n-        params.addBundleArgument(Arguments.CLIOptions.INPUT.getId(), \"input\");\n-    }\n-\n-    private void setAppNameAndValidate(String appName) throws PackagerException {\n-        params.addBundleArgument(Arguments.CLIOptions.NAME.getId(), appName);\n-        params.validate();\n-    }\n-\n-    private DeployParams params;\n-}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/DeployParamsTest.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LauncherJarStartupInfo;\n+import jdk.jpackage.internal.model.LauncherJarStartupInfoMixin;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfo;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfoMixin;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.JavaAppDesc;\n+import jdk.jpackage.test.ObjectMapper;\n+import jdk.jpackage.test.TKit;\n+\n+public class LauncherStartupInfoBuilderTest extends JUnitAdapter {\n+\n+    public record TestSpec(JavaAppDesc javaAppDesc, boolean withMainClass, Object expectedInfo) {\n+        public TestSpec {\n+            Objects.requireNonNull(javaAppDesc);\n+            Objects.requireNonNull(expectedInfo);\n+        }\n+\n+        void test() throws ConfigException {\n+            final var workDir = TKit.createTempDirectory(\"input\");\n+\n+            HelloApp.createBundle(javaAppDesc, workDir);\n+\n+            final var builder = new LauncherStartupInfoBuilder();\n+\n+            builder.inputDir(workDir);\n+\n+            if (withMainClass) {\n+                builder.mainClassName(javaAppDesc.className());\n+            }\n+\n+            Optional.ofNullable(javaAppDesc.moduleName()).ifPresentOrElse(moduleName -> {\n+                if (javaAppDesc.isWithMainClass()) {\n+                    builder.moduleName(moduleName + \"\/\" + javaAppDesc.className());\n+                } else {\n+                    builder.moduleName(moduleName);\n+                }\n+                builder.modulePath(List.of(workDir));\n+            }, () -> {\n+                builder.mainJar(Path.of(javaAppDesc.jarFileName()));\n+            });\n+\n+            final var actualInfo = builder.create();\n+\n+            assertEquals(expectedInfo, OM.map(actualInfo));\n+        }\n+\n+        static final class Builder {\n+            TestSpec create() {\n+                return new TestSpec(javaAppDesc, withMainClass, OM.map(createInfo()));\n+            }\n+\n+            Builder javaAppDesc(String v) {\n+                javaAppDesc = JavaAppDesc.parse(v);\n+                return this;\n+            }\n+\n+            Builder withMainClass(boolean v) {\n+                withMainClass = v;\n+                return this;\n+            }\n+\n+            private LauncherStartupInfo createInfo() {\n+                final var base = createBaseInfo();\n+                if (javaAppDesc.moduleName() != null) {\n+                    return LauncherModularStartupInfo.create(base, createModularMixin());\n+                } else {\n+                    return LauncherJarStartupInfo.create(base, createJarMixin());\n+                }\n+            }\n+\n+            private LauncherStartupInfo createBaseInfo() {\n+                return new LauncherStartupInfo.Stub(javaAppDesc.className(), List.of(), List.of(), classPath);\n+            }\n+\n+            private LauncherJarStartupInfoMixin createJarMixin() {\n+                return new LauncherJarStartupInfoMixin.Stub(Path.of(javaAppDesc.jarFileName()),\n+                        !withMainClass && javaAppDesc.isWithMainClass());\n+            }\n+\n+            private LauncherModularStartupInfoMixin createModularMixin() {\n+                return new LauncherModularStartupInfoMixin.Stub(javaAppDesc.moduleName(),\n+                        Optional.ofNullable(javaAppDesc.moduleVersion()));\n+            }\n+\n+            private JavaAppDesc javaAppDesc;\n+            private boolean withMainClass = true;\n+            private List<Path> classPath = new ArrayList<>();\n+        }\n+    }\n+\n+    @Test\n+    @ParameterSupplier\n+    public static void test(TestSpec spec) throws ConfigException {\n+        spec.test();\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+                build(\"\"),\n+                build(\"foo.jar:foo.bar.U\"),\n+                build(\"foo.jar:foo.bar.U!\"),\n+                build(\"foo.jar:foo.bar.U!\").withMainClass(false),\n+                build(\"a.b\/d.c.O\").withMainClass(true),\n+                build(\"a.b\/d.c.O@3.5.7-beta\").withMainClass(true),\n+                build(\"a.b\/d.c.O!\"),\n+                build(\"a.b\/d.c.O!\").withMainClass(false)\n+        ).map(TestSpec.Builder::create).map(v -> {\n+            return new Object[] {v};\n+        }).toList();\n+    }\n+\n+    private static TestSpec.Builder build(String javaAppDesc) {\n+        return new TestSpec.Builder().javaAppDesc(javaAppDesc);\n+    }\n+\n+    private static final ObjectMapper OM = ObjectMapper.standard().create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/LauncherStartupInfoBuilderTest.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -60,1 +60,0 @@\n-import jdk.jpackage.internal.model.ConfigException;\n@@ -63,1 +62,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n@@ -66,0 +64,1 @@\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -77,1 +76,1 @@\n-    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testBuildApplication(boolean withRuntimeBuilder, @TempDir Path workDir) throws IOException {\n@@ -118,1 +117,1 @@\n-    void testCopyApplication(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCopyApplication(@TempDir Path workDir) throws IOException {\n@@ -173,1 +172,1 @@\n-    void testCreatePackage(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackage(@TempDir Path workDir) throws IOException {\n@@ -212,1 +211,1 @@\n-    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreateRuntimeInstaller(boolean transformLayout, @TempDir Path workDir) throws IOException {\n@@ -276,1 +275,1 @@\n-    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackageFromExternalAppImage(ExternalAppImageMode mode, @TempDir Path workDir) throws IOException {\n@@ -325,1 +324,1 @@\n-    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackageFromExternalAppImageNoCopyAction(ExternalAppImageMode mode, @TempDir Path workDir) throws IOException {\n@@ -382,1 +381,1 @@\n-    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws ConfigException, PackagerException, IOException {\n+    void testCreatePackageFromExternalAppImageWithoutExternalAppImageError(@TempDir Path workDir) throws IOException {\n@@ -392,1 +391,1 @@\n-    void testExceptionRethrow_RuntimeException() throws ConfigException, PackagerException, IOException {\n+    void testExceptionRethrow_RuntimeException() throws IOException {\n@@ -402,1 +401,1 @@\n-    void testExceptionRethrow_PackagerException() throws ConfigException, PackagerException, IOException {\n+    void testExceptionRethrow_PackagerException() throws IOException {\n@@ -404,1 +403,1 @@\n-        final var expectedException = new PackagerException(\"param.vendor.default\");\n+        final var expectedException = new RuntimeException(\"param.vendor.default\");\n@@ -412,1 +411,1 @@\n-    void testExceptionRethrow_Exception() throws ConfigException, PackagerException, IOException {\n+    void testExceptionRethrow_Exception() throws IOException {\n@@ -415,1 +414,1 @@\n-        final var ex = testExceptionRethrow(expectedException, PackagerException.class, () -> {\n+        final var ex = testExceptionRethrow(expectedException, ExceptionBox.class, () -> {\n@@ -422,1 +421,1 @@\n-    void testAppImageAction() throws PackagerException, IOException {\n+    void testAppImageAction() throws IOException {\n@@ -442,1 +441,1 @@\n-    void testAppImageActionWithPackage() throws PackagerException, IOException {\n+    void testAppImageActionWithPackage() throws IOException {\n@@ -465,1 +464,1 @@\n-    void testPackageActionWithApplication() throws PackagerException, IOException {\n+    void testPackageActionWithApplication() throws IOException {\n@@ -483,1 +482,1 @@\n-    void testContextMapper(boolean allowAll) throws PackagerException, IOException {\n+    void testContextMapper(boolean allowAll) throws IOException {\n@@ -493,1 +492,1 @@\n-                public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+                public void execute(TaskAction taskAction) throws IOException {\n@@ -541,1 +540,1 @@\n-            NoArgTaskAction throwAction) throws PackagerException, IOException {\n+            NoArgTaskAction throwAction) throws IOException {\n@@ -554,1 +553,1 @@\n-    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) throws ConfigException {\n+    private static BuildEnv setupBuildEnvForExternalAppImage(Path workDir) {\n@@ -568,1 +567,1 @@\n-            TaskID... expectedExecutedTaskActions) throws PackagerException, IOException {\n+            TaskID... expectedExecutedTaskActions) throws IOException {\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/PackagingPipelineTest.java","additions":21,"deletions":22,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.OptionIdentifier.createIdentifier;\n+import static jdk.jpackage.internal.cli.WithOptionIdentifier.stub;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import jdk.jpackage.internal.cli.DefaultOptions.OptionIdentifierWithValue;\n+import jdk.jpackage.internal.cli.DefaultOptions.Snapshot;\n+import org.junit.jupiter.api.Test;\n+\n+public class DefaultOptionsTest {\n+\n+    @Test\n+    public void test_ctor_Snapshot_bad_option_names() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            DefaultOptions.create(new Snapshot(Map.of(), Set.of(OptionName.of(\"foo\"))));\n+        });\n+\n+        assertEquals(\"Unexpected option names\", ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_ctor_Snapshot_bad_option_map() {\n+        var ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            DefaultOptions.create(new Snapshot(\n+                    Map.of(createIdentifier(), new OptionIdentifierWithValue(stub(createIdentifier()), \"foo\")),\n+                    Set.of()));\n+        });\n+\n+        assertEquals(\"Corrupted options map\", ex.getMessage());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/DefaultOptionsTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.test.JUnitUtils.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+final class ExpectedOptions {\n+\n+    static ExpectedOptions expectOptions() {\n+        return new ExpectedOptions();\n+    }\n+\n+    ExpectedOptions add(OptionIdentifier id, Object expectedValue) {\n+        expected.put(Objects.requireNonNull(id), Objects.requireNonNull(expectedValue));\n+        return this;\n+    }\n+\n+    ExpectedOptions add(OptionValue<?> ov, Object expectedValue) {\n+        ov.asOption().map(Option::spec).map(OptionSpec::names).ifPresent(names -> {\n+            expectedOptionNames.put(ov.id(), names);\n+        });\n+        return add(ov.id(), expectedValue);\n+    }\n+\n+    ExpectedOptions add(Option o, Object expectedValue) {\n+        expectedOptionNames.put(o.id(), o.spec().names());\n+        return add(o.id(), expectedValue);\n+    }\n+\n+    void apply(Options options) {\n+        for (var e : expected.entrySet()) {\n+            var actualValue = options.find(e.getKey()).orElseThrow();\n+            var expectedValue = e.getValue();\n+            if (expectedValue.getClass().isArray()) {\n+                assertArrayEquals(expectedValue, actualValue);\n+            } else {\n+                assertEquals(expectedValue, actualValue);\n+            }\n+        }\n+\n+        expectedOptionNames.values().stream().flatMap(Collection::stream).forEach(optionName -> {\n+            assertTrue(options.contains(optionName));\n+        });\n+\n+        assertEquals(convertArrayValuesToLists(expected), convertArrayValuesToLists(options.toMap()));\n+        assertEquals(expected.keySet(), options.ids());\n+    }\n+\n+    private Map<OptionIdentifier, Object> convertArrayValuesToLists(Map<OptionIdentifier, Object> map) {\n+        return map.entrySet().stream().map(e -> {\n+            var value = e.getValue();\n+            if (value.getClass().isArray()) {\n+                var objArray = new Object[Array.getLength(value)];\n+                System.arraycopy(value, 0, objArray, 0, objArray.length);\n+                return Map.<OptionIdentifier, Object>entry(e.getKey(), List.of(objArray));\n+            } else {\n+                return e;\n+            }\n+        }).collect(Collectors.toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private final Map<OptionIdentifier, Object> expected = new HashMap<>();\n+    private final Map<OptionIdentifier, Collection<OptionName>> expectedOptionNames = new HashMap<>();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/ExpectedOptions.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class HelpTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @Test\n+    public void testHelpOption() {\n+        final var cmdline = new JOptSimpleOptionsBuilder()\n+                .options(StandardOption.options())\n+                .create().apply(new String[] { \"-h\" }).orElseThrow().create();\n+\n+        assertTrue(StandardOption.HELP.containsIn(cmdline));\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void printHelp(OperatingSystem os) {\n+        new StandardHelpFormatter(os).format(System.out::print);\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void updateGoldenHelpFiles(OperatingSystem os) throws IOException {\n+        try (var sink = Files.newBufferedWriter(goldenHelpOutputFile(os)); var pw = new PrintWriter(sink)) {\n+            new StandardHelpFormatter(os).format(pw::append);\n+        }\n+    }\n+\n+    @Test\n+    public void printHelp() {\n+        StandardHelpFormatter.INSTANCE.format(System.out::print);\n+    }\n+\n+    @Test\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void verifyHelp() throws IOException {\n+        verifyHelp(StandardHelpFormatter.INSTANCE, OperatingSystem.current());\n+    }\n+\n+    @Test\n+    public void testOptionGroupNamesUnique() {\n+        \/\/ Test group names are unique.\n+        Stream.of(StandardHelpFormatter.OptionGroupID.values())\n+                .map(StandardHelpFormatter.OptionGroupID::groupName)\n+                .collect(Collectors.toMap(x -> x, x -> x));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void testOptionGroups(OperatingSystem os) {\n+\n+        final var groups = Stream.of(StandardHelpFormatter.OptionGroupID.values())\n+                .filter(Predicate.isEqual(StandardHelpFormatter.OptionGroupID.SAMPLES).negate())\n+                .map(optionGroupID -> {\n+                    return optionGroupID.createNonEmptyOptionGroup(os);\n+                })\n+                .filter(Optional::isPresent).map(Optional::orElseThrow)\n+                .collect(Collectors.toMap(HelpFormatter.OptionGroup::name, HelpFormatter.OptionGroup::options));\n+\n+        \/\/ Names of all options supported on the given platform.\n+        final var allOptionNames = StandardOption.options().stream().map(Option::spec)\n+                .filter(StandardOption.platformOption(os))\n+                .map(OptionSpec::names).flatMap(Collection::stream)\n+                .sorted().toList();\n+\n+        \/\/ Names of all options in the help groups.\n+        final var groupOptions = groups.values().stream().flatMap(Collection::stream)\n+                .map(OptionSpec::names).flatMap(Collection::stream)\n+                .sorted().toList();\n+\n+        \/\/ Test that each option belongs to only one group except of `--runtime-image`\n+        groupOptions.stream().collect(Collectors.toMap(x -> x, x -> x, (a, b) -> {\n+            if (a.equals(StandardOption.PREDEFINED_RUNTIME_IMAGE.getSpec().name())) {\n+                return a;\n+            } else {\n+                throw new AssertionError(String.format(\"Option [%s] is included in multiple groups\", a.name()));\n+            }\n+        }));\n+\n+        \/\/ Test that each option is added to some group.\n+        assertEquals(allOptionNames, groupOptions.stream().distinct().toList());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOptionSpecSorter(List<String> unsortedNames, List<String> expectedNames) {\n+        var sortedNames = unsortedNames.stream()\n+                .map(HelpTest::dummyOptionSpec)\n+                .sorted(StandardHelpFormatter.optionSpecSorter())\n+                .map(OptionSpec::name)\n+                .map(OptionName::name).toList();\n+        assertEquals(expectedNames, sortedNames);\n+    }\n+\n+    private static Iterable<Arguments> testOptionSpecSorter() {\n+        return List.of(\n+                Arguments.of(List.of(\"a\", \"type\", \"w\"), List.of(\"type\", \"a\", \"w\")),\n+                Arguments.of(List.of(\"type\", \"type\", \"w\"), List.of(\"type\", \"type\", \"w\")),\n+                Arguments.of(List.of(\"a\", \"type\", \"type\"), List.of(\"type\", \"type\", \"a\")),\n+                Arguments.of(List.of(\"type\", \"w\", \"type\"), List.of(\"type\", \"type\", \"w\"))\n+        );\n+    }\n+\n+    private static OptionSpec<?> dummyOptionSpec(String name) {\n+        return new OptionSpec<>(\n+                List.of(OptionName.of(name)),\n+                Optional.empty(),\n+                Set.of(new OptionScope() {}),\n+                OptionSpec.MergePolicy.USE_FIRST,\n+                Optional.empty(),\n+                Optional.empty(),\n+                \"\");\n+    }\n+\n+    private static void verifyHelp(StandardHelpFormatter helpFormatter, OperatingSystem os) throws IOException {\n+\n+        var sb = new StringBuilder();\n+        helpFormatter.format(sb::append);\n+\n+        var help = new BufferedReader(new StringReader(sb.toString())).lines().toList();\n+\n+        var expectedHelp = Files.readAllLines(goldenHelpOutputFile(os));\n+\n+        assertEquals(expectedHelp, help);\n+    }\n+\n+    private static Path goldenHelpOutputFile(OperatingSystem os) {\n+        String fname = String.format(\"help-%s.txt\", os.name().toLowerCase());\n+        return TKit.TEST_SRC_ROOT.resolve(\"junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\", fname);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/HelpTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,1428 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.ExpectedOptions.expectOptions;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.pathSeparator;\n+import static jdk.jpackage.internal.cli.OptionSpecBuilder.toList;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.identityConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.pathConv;\n+import static jdk.jpackage.internal.cli.TestUtils.arrayElements;\n+import static jdk.jpackage.test.JUnitUtils.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.JOptSimpleErrorType;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+import jdk.jpackage.internal.cli.OptionValueConverter.ConverterException;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.StandardArgumentsMapper;\n+import jdk.jpackage.internal.cli.TestUtils.OptionFailure;\n+import jdk.jpackage.internal.cli.TestUtils.TestException;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.JUnitUtils.ExceptionPattern;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class JOptSimpleOptionsBuilderTest {\n+\n+    enum ParserMode {\n+        PARSE,\n+        CONVERT\n+    }\n+\n+    public record TestSpec(Map<OptionValue<?>, ExpectedValue<?>> options, List<String> args) {\n+        public TestSpec {\n+            Objects.requireNonNull(options);\n+            Objects.requireNonNull(args);\n+        }\n+\n+        void test(ParserMode parserMode) {\n+            final var parser = createParser(parserMode, options.keySet());\n+\n+            final var cmdline = parser.apply(args);\n+\n+            for (final var e : options.entrySet()) {\n+                final var optionValue = e.getKey();\n+                final var expectedValue = e.getValue();\n+                final Object actualValue;\n+                if (parserMode.equals(ParserMode.PARSE)) {\n+                    actualValue = cmdline.find(optionValue.getOption()).orElseThrow();\n+                } else {\n+                    actualValue = optionValue.getFrom(cmdline);\n+                }\n+                expectedValue.assertIt(actualValue);\n+            }\n+        }\n+\n+\n+        static final class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(options, args);\n+            }\n+\n+            final class OptionValueBuilder<T> {\n+\n+                OptionValueBuilder<T> expectParse(String... expectedValue) {\n+                    expectedValues.put(ParserMode.PARSE, new ExpectedValue<>(expectedValue, Assertions::assertArrayEquals));\n+                    return this;\n+                 }\n+\n+                OptionValueBuilder<T> expect(T expectedValue) {\n+                   return expect(expectedValue, defaultAsserter());\n+                }\n+\n+                OptionValueBuilder<T> expect(T expectedValue, BiConsumer<T, T> asserter) {\n+                    expectedValues.put(ParserMode.CONVERT, new ExpectedValue<>(expectedValue, asserter));\n+                    return this;\n+                }\n+\n+                Builder commit() {\n+                    if (expectedValues.isEmpty()) {\n+                        throw new UnsupportedOperationException(\"Missing expected value\");\n+                    }\n+\n+                    if (parserMode == null) {\n+                        if (expectedValues.size() > 1) {\n+                            throw new UnsupportedOperationException(\"Ambigous expected value\");\n+                        }\n+                        options.put(option, expectedValues.values().iterator().next());\n+                    } else {\n+                        options.put(option, Optional.ofNullable(expectedValues.get(parserMode)).orElseThrow(() -> {\n+                            return new UnsupportedOperationException(\"Mismatched expected value\");\n+                        }));\n+                    }\n+\n+                    return Builder.this;\n+                }\n+\n+                private OptionValueBuilder(OptionValue<T> option) {\n+                    this.option = Objects.requireNonNull(option);\n+                }\n+\n+                private final OptionValue<T> option;\n+                private final Map<ParserMode, ExpectedValue<?>> expectedValues = new HashMap<>();\n+            }\n+\n+            <T> OptionValueBuilder<T> optionValue(OptionValue<T> option) {\n+                return new OptionValueBuilder<>(option);\n+            }\n+\n+            Builder optionUntypedValue(OptionValue<?> option, String... expectedValue) {\n+                return new OptionValueBuilder<>(option).expectParse(expectedValue).commit();\n+             }\n+\n+            <T> Builder optionValue(OptionValue<T> option, T expectedValue) {\n+               return optionValue(option, expectedValue, defaultAsserter());\n+            }\n+\n+            <T> Builder optionValue(OptionValue<T> option, T expectedValue, BiConsumer<T, T> asserter) {\n+                return new OptionValueBuilder<>(option).expect(expectedValue, asserter).commit();\n+            }\n+\n+            Builder args(String...v) {\n+                return args(List.of(v));\n+            }\n+\n+            Builder args(Collection<String> v) {\n+                args.addAll(v);\n+                return this;\n+            }\n+\n+            Builder mode(ParserMode v) {\n+                parserMode = v;\n+                return this;\n+            }\n+\n+            private static <T> BiConsumer<T, T> defaultAsserter() {\n+                return (expected, actual) -> {\n+                    if (expected.getClass().isArray()) {\n+                        assertArrayEquals(expected, actual);\n+                    } else {\n+                        assertEquals(expected, actual);\n+                    }\n+                };\n+            }\n+\n+            private ParserMode parserMode;\n+            private final Map<OptionValue<?>, ExpectedValue<?>> options = new HashMap<>();\n+            private final List<String> args = new ArrayList<>();\n+        }\n+\n+\n+        private record ExpectedValue<T>(T value, BiConsumer<T, T> asserter) {\n+            ExpectedValue {\n+                Objects.requireNonNull(value);\n+                Objects.requireNonNull(asserter);\n+            }\n+\n+            @SuppressWarnings(\"unchecked\")\n+            void assertIt(Object actual) {\n+                asserter.accept(value, (T)actual);\n+            }\n+        }\n+    }\n+\n+    enum ShortNameTestCase {\n+        LONG(hasLongOption().and(hasShortOption().negate()), addLongOption()),\n+        SHORT(hasLongOption().negate().and(hasShortOption()), addShortOption()),\n+        LONG_AND_SHORT(hasLongOption().and(hasShortOption()), addLongOption(), addShortOption()),\n+        SHORT_AND_LONG(hasLongOption().and(hasShortOption()), addShortOption(), addLongOption()),\n+        NONE(hasLongOption().negate().and(hasShortOption().negate()))\n+        ;\n+\n+        @SafeVarargs\n+        ShortNameTestCase(Predicate<Options> validator, BiConsumer<Type, List<String>>... optionInitializers) {\n+            this.optionInitializer = (type, args) -> {\n+                for (final var optionInitializer : optionInitializers) {\n+                    optionInitializer.accept(type, args);\n+                }\n+            };\n+            this.validator = validator;\n+        }\n+\n+        void run(Type type, ParserMode parserMode) {\n+            final var parser = createParser(parserMode, type.optionValue);\n+            final List<String> args = new ArrayList<>();\n+            optionInitializer.accept(type, args);\n+            assertTrue(validator.test(parser.apply(args)));\n+        }\n+\n+        private static Predicate<Options> hasLongOption() {\n+            return cmdline -> {\n+                return cmdline.contains(LONG_NAME);\n+            };\n+        }\n+\n+        private static Predicate<Options> hasShortOption() {\n+            return cmdline -> {\n+                return cmdline.contains(SHORT_NAME);\n+            };\n+        }\n+\n+        private static BiConsumer<Type, List<String>> addLongOption() {\n+            return (type, args) -> {\n+                args.add(LONG_NAME.formatForCommandLine());\n+                type.valueInitializer.accept(FOO, args);\n+            };\n+        }\n+\n+        private static BiConsumer<Type, List<String>> addShortOption() {\n+            return (type, args) -> {\n+                args.add(SHORT_NAME.formatForCommandLine());\n+                type.valueInitializer.accept(BAR, args);\n+            };\n+        }\n+\n+        private enum Type {\n+            STRING(stringOption(LONG_NAME.name()).addAliases(SHORT_NAME.name()).create(), (optionValue, args) -> {\n+                args.add(optionValue);\n+            }),\n+            BOOLEAN(booleanOption(LONG_NAME.name()).addAliases(SHORT_NAME.name()).create(), (optionValue, args) -> {}),\n+            ;\n+\n+            Type(OptionValue<?> optionValue, BiConsumer<String, List<String>> valueInitializer) {\n+                this.optionValue = Objects.requireNonNull(optionValue);\n+                this.valueInitializer = Objects.requireNonNull(valueInitializer);\n+            }\n+\n+            final OptionValue<?> optionValue;\n+            final BiConsumer<String, List<String>> valueInitializer;\n+        }\n+\n+        private final BiConsumer<Type, List<String>> optionInitializer;\n+        private final Predicate<Options> validator;\n+\n+        private static final OptionName LONG_NAME = OptionName.of(\"input\");\n+        private static final OptionName SHORT_NAME = OptionName.of(\"i\");\n+\n+        private static final String FOO = \"foo\";\n+        private static final String BAR = \"bar\";\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ShortNameTestCase.class)\n+    public void testShortNameString(ShortNameTestCase testCase) {\n+        for (final var parserMode : ParserMode.values()) {\n+            testCase.run(ShortNameTestCase.Type.STRING, parserMode);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ShortNameTestCase.class)\n+    public void testShortNameBoolean(ShortNameTestCase testCase) {\n+        for (final var parserMode : List.of(ParserMode.CONVERT)) {\n+            testCase.run(ShortNameTestCase.Type.BOOLEAN, parserMode);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(TestSpec spec) {\n+        spec.test(ParserMode.CONVERT);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testStringVector(TestSpec spec) {\n+        spec.test(ParserMode.CONVERT);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOptionalValueParse(TestSpec spec) {\n+        spec.test(ParserMode.PARSE);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOptionalValueConvert(TestSpec spec) {\n+        spec.test(ParserMode.CONVERT);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void testOptionalValueNoDefault(ParserMode parserMode) {\n+        var option = option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create();\n+        var option2 = option(\"y\", Integer.class).converter(Integer::valueOf).create();\n+\n+        var cmdline = createParser(parserMode, option, option2).apply(List.of(\"-y\", \"77\"));\n+\n+        assertTrue(option.findIn(cmdline).isEmpty());\n+        assertTrue(option2.findIn(cmdline).isPresent());\n+    }\n+\n+    @Test\n+    public void testConversionErrors(@TempDir Path tmpDir) {\n+\n+        final var dirOption = pathOption(\"dir\").addAliases(\"r\").tokenizer(\",\");\n+\n+        final var urlOption = stringOption(\"url\").converter(str -> {\n+            try {\n+                new URI(str);\n+                return str;\n+            } catch (URISyntaxException ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n+        });\n+\n+        final var lruOption = option(\"lru\", URI.class).converter(str -> {\n+            try {\n+                return new URI(str);\n+            } catch (URISyntaxException ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n+        }).mergePolicy(MergePolicy.USE_FIRST);\n+\n+        new FaultyParserArgsConfig()\n+                .options(urlOption, lruOption)\n+                .arrayOptions(dirOption)\n+                .args(\"--dir=*,foo,,bar\", \"-r\", \"file\", \"-r\", \"file,*\")\n+                .args(\"--url=http:\/\/foo\", \"--url=:foo\")\n+                .args(\"--lru=:bar\", \"--lru=http:\/\/bar\")\n+                .expectError(\"dir\", StringToken.of(\"*,foo,,bar\", \"*\"))\n+                .expectError(\"r\", StringToken.of(\"file,*\", \"*\"))\n+                .expectError(\"url\", \":foo\")\n+                .expectError(\"lru\", \":bar\")\n+                .test();\n+\n+        \/\/ Test errors are recorded in the order they appear on the command line.\n+        new FaultyParserArgsConfig()\n+                .options(urlOption, lruOption)\n+                .arrayOptions(dirOption)\n+                .args(\"--lru=:bar\", \"--lru=http:\/\/bar\")\n+                .args(\"--dir=*,foo,,bar\", \"-r\", \"file\")\n+                .args(\"--url=http:\/\/foo\", \"--url=:foo\")\n+                .args(\"-r\", \"file,*\")\n+                .expectError(\"lru\", \":bar\")\n+                .expectError(\"dir\", StringToken.of(\"*,foo,,bar\", \"*\"))\n+                .expectError(\"url\", \":foo\")\n+                .expectError(\"r\", StringToken.of(\"file,*\", \"*\"))\n+                .test();\n+    }\n+\n+    @Test\n+    public void testValidationErrors() {\n+\n+        final var numberArrayOption = option(\"number\", Integer.class)\n+                .addAliases(\"n\")\n+                .validator((Predicate<Integer>)(v -> v > 0))\n+                .tokenizer(\",\")\n+                .converter(Integer::valueOf);\n+\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(numberArrayOption)\n+                .args(\"--number=56,23\", \"--number=2,-34,-45\", \"-n\", \"2,-17,0,56\")\n+                .expectError(\"number\", StringToken.of(\"2,-34,-45\", \"-34\"))\n+                .expectError(\"number\", StringToken.of(\"2,-34,-45\", \"-45\"))\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"-17\"))\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"0\"))\n+                .test();\n+\n+        \/\/ Test errors are recorded in the order they appear on the command line.\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(numberArrayOption)\n+                .args(\"--number=56,23\", \"-n\", \"2,-17,0,56\", \"--number=2,-45,-34\")\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"-17\"))\n+                .expectError(\"n\", StringToken.of(\"2,-17,0,56\", \"0\"))\n+                .expectError(\"number\", StringToken.of(\"2,-45,-34\", \"-45\"))\n+                .expectError(\"number\", StringToken.of(\"2,-45,-34\", \"-34\"))\n+                .test();\n+    }\n+\n+    enum ConverterErrorOrigin {\n+        CONVERTER,\n+        VALIDATOR\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ConverterErrorOrigin.class)\n+    public void testConverterError(ConverterErrorOrigin exceptionOrigin) {\n+\n+        final var scalarException = new RuntimeException(\"Scalar error\");\n+        final var arrayException = new RuntimeException(\"Array error\");\n+\n+        final Function<RuntimeException, Consumer<OptionSpecBuilder<String>>> mutatorCreator = ex -> {\n+            return builder -> {\n+                switch (exceptionOrigin) {\n+                    case CONVERTER -> {\n+                        builder.converter(_ -> {\n+                            throw ex;\n+                        });\n+                    }\n+\n+                    case VALIDATOR -> {\n+                        builder.validator(new Consumer<>() {\n+\n+                            @Override\n+                            public void accept(String t) {\n+                                throw ex;\n+                            }\n+\n+                        });\n+                    }\n+                }\n+            };\n+        };\n+\n+        final var scalarOption = stringOption(\"val\").mutate(mutatorCreator.apply(scalarException));\n+\n+        final var arrayOption = stringOption(\"arr\").mutate(mutatorCreator.apply(arrayException));\n+\n+        final var cfg = new FaultyParserArgsConfig()\n+                .options(scalarOption, stringOption(\"good\"))\n+                .arrayOptions(arrayOption);\n+\n+        cfg.clearArgs()\n+                .args(\"--val=10\")\n+                .expectConverterException(scalarException)\n+                .test();\n+\n+        cfg.clearArgs()\n+                .args(\"--arr=foo\")\n+                .expectConverterException(arrayException)\n+                .test();\n+\n+        cfg.clearArgs()\n+                .args(\"--arr=bar\", \"--val=57\")\n+                .expectConverterException(arrayException)\n+                .test();\n+\n+        cfg.clearArgs()\n+                .args(\"--val=57\", \"--arr=bar\")\n+                .expectConverterException(scalarException)\n+                .test();\n+    }\n+\n+    @Test\n+    public void testArrayUnrecoverableMergeFailure() {\n+\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(pathOption(\"path\").tokenizer(\",\").mergePolicy(MergePolicy.USE_FIRST))\n+                .args(\"--path=*,foo\", \"--path=bar\")\n+                .expectError(\"path\", StringToken.of(\"*,foo\", \"*\"))\n+                .test();\n+\n+        new FaultyParserArgsConfig()\n+                .arrayOptions(pathOption(\"path\").tokenizer(\",\").mergePolicy(MergePolicy.USE_LAST))\n+                .args(\"--path=bar\", \"--path=foo,*\")\n+                .expectError(\"path\", StringToken.of(\"foo,*\", \"*\"))\n+                .test();\n+    }\n+\n+    @Test\n+    public void testScalarUnrecoverableMergeFailure() {\n+\n+        new FaultyParserArgsConfig()\n+                .options(pathOption(\"path\").mergePolicy(MergePolicy.USE_FIRST))\n+                .args(\"--path=*\", \"--path=bar\")\n+                .expectError(\"path\", StringToken.of(\"*\", \"*\"))\n+                .test();\n+\n+        new FaultyParserArgsConfig()\n+                .options(pathOption(\"path\").mergePolicy(MergePolicy.USE_LAST))\n+                .args(\"--path=bar\", \"--path=*\")\n+                .expectError(\"path\", StringToken.of(\"*\", \"*\"))\n+                .test();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testMergePolicy\")\n+    public void testMergePolicyScalar(MergePolicy mergePolicy, ParserMode parserMode) {\n+\n+        if (mergePolicy == MergePolicy.CONCATENATE) {\n+            assertThrowsExactly(IllegalArgumentException.class,\n+                    option(\"foo\", Object.class).mergePolicy(mergePolicy)::create);\n+            return;\n+        }\n+\n+        final var strOption = stringOption(\"str\").mergePolicy(mergePolicy).create();\n+\n+        final var monthOption = stringOption(\"month\").addAliases(\"m\")\n+                .mergePolicy(mergePolicy).create();\n+\n+        final var intOption = option(\"int\", Integer.class).addAliases(\"i\")\n+                .converter(Integer::valueOf).mergePolicy(mergePolicy).create();\n+\n+        final var floatOption = option(\"d\", Double.class)\n+                .converter(Double::valueOf).mergePolicy(mergePolicy).create();\n+\n+        final var builder = build()\n+                .args(\"-d\", \"1000\", \"--month=June\", \"--int=10\", \"-m\", \"July\", \"-i\", \"45\", \"-m\", \"August\")\n+                .args(\"--str=\", \"--str=A\");\n+\n+        if (parserMode.equals(ParserMode.PARSE)) {\n+            builder.optionUntypedValue(strOption, mergeUntypedValues(List.of(\"\", \"A\"), mergePolicy));\n+            builder.optionUntypedValue(monthOption, mergeUntypedValues(List.of(\"June\", \"July\", \"August\"), mergePolicy));\n+            builder.optionUntypedValue(intOption, mergeUntypedValues(List.of(\"10\", \"45\"), mergePolicy));\n+            builder.optionUntypedValue(floatOption, new String[] {\"1000\"});\n+        } else {\n+            builder.optionValue(strOption, mergeScalarValues(List.of(\"\", \"A\"), mergePolicy));\n+            builder.optionValue(monthOption, mergeScalarValues(List.of(\"June\", \"July\", \"August\"), mergePolicy));\n+            builder.optionValue(intOption, mergeScalarValues(List.of(10, 45), mergePolicy));\n+            builder.optionValue(floatOption, Double.valueOf(1000));\n+        }\n+\n+        builder.create().test(parserMode);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testMergePolicy\")\n+    public void testMergePolicyArray(MergePolicy mergePolicy, ParserMode parserMode) {\n+\n+        final var monthOption = stringOption(\"month\").addAliases(\"m\")\n+                .mergePolicy(mergePolicy)\n+                .tokenizer(Pattern.quote(\"+\"))\n+                .createArray();\n+\n+        final var intOption = option(\"int\", Integer.class).addAliases(\"i\")\n+                .converter(Integer::valueOf)\n+                .mergePolicy(mergePolicy)\n+                .tokenizer(TestUtils.splitOrEmpty(\":\"))\n+                .createArray();\n+\n+        final var floatOption = option(\"d\", Double.class)\n+                .converter(Double::valueOf)\n+                .mergePolicy(mergePolicy)\n+                .tokenizer(Pattern.quote(\"|\"))\n+                .createArray();\n+\n+        final var builder = build().args(\"-d\", \"1000\", \"--int=\", \"--month=June\", \"--int=10:333\", \"-m\", \"July+July\", \"-i\", \"45\", \"-m\", \"August\", \"--int=\");\n+\n+        if (parserMode.equals(ParserMode.PARSE)) {\n+            builder.optionUntypedValue(monthOption,\n+                    mergeUntypedValues(List.of(\"June\", \"July+July\", \"August\"), mergePolicy));\n+            builder.optionUntypedValue(intOption,\n+                    mergeUntypedValues(List.of(\"\", \"10:333\", \"45\", \"\"), mergePolicy));\n+            builder.optionUntypedValue(floatOption, new String[] {\"1000\"});\n+        } else {\n+            builder.optionValue(monthOption,\n+                    mergeArrayValues(arrayElements(String.class, List.of(\"June\", \"July\", \"July\", \"August\")), mergePolicy));\n+            builder.optionValue(intOption,\n+                    mergeArrayValues(arrayElements(Integer.class, Arrays.asList(null, 10, 333, 45, null)), mergePolicy));\n+            builder.optionValue(floatOption, new Double[] {Double.valueOf(1000)});\n+        }\n+\n+        builder.create().test(parserMode);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testMergePolicy\")\n+    public void testMergePolicyNoValue(MergePolicy mergePolicy, ParserMode parserMode) {\n+\n+        if (mergePolicy == MergePolicy.CONCATENATE) {\n+            assertThrowsExactly(IllegalArgumentException.class, booleanOption(\"foo\").mergePolicy(mergePolicy)::create);\n+            return;\n+        }\n+\n+        final var aOption = booleanOption(\"a\").mergePolicy(mergePolicy).create();\n+        final var bOption = booleanOption(\"boo\").addAliases(\"b\").mergePolicy(mergePolicy).create();\n+\n+        final var builder = build().args(\"-a\", \"-boo\", \"-b\");\n+\n+        if (parserMode.equals(ParserMode.PARSE)) {\n+            builder.optionUntypedValue(aOption, new String[0]);\n+            builder.optionUntypedValue(bOption, new String[0]);\n+        } else {\n+            builder.optionValue(aOption, mergeScalarValues(List.of(true), mergePolicy));\n+            builder.optionValue(bOption, mergeScalarValues(List.of(true, true), mergePolicy));\n+        }\n+\n+        builder.create().test(parserMode);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testUnrecognizedOptionMapping(boolean onlyUnrecognizedOption) {\n+\n+        final var option = option(\"x\", Object.class).converter(_ -> {\n+            throw new RuntimeException();\n+        }).create();\n+\n+        final List<String> args = new ArrayList<>();\n+\n+        if (!onlyUnrecognizedOption) {\n+            args.addAll(List.of(\"-x\", \"foo\"));\n+        }\n+        args.add(\"--unrecognized\");\n+\n+        final var result = new JOptSimpleOptionsBuilder().options(option).create().apply(args.toArray(String[]::new));\n+\n+        assertFalse(result.hasValue());\n+        assertEquals(1, result.errors().size());\n+\n+        assertTrue(new ExceptionPattern()\n+                .isInstanceOf(jdk.internal.joptsimple.OptionException.class)\n+                .match(result.errors().iterator().next()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testErrorMapping(String expectedErrorMessage, String[] args) {\n+\n+        var booleanOption = booleanOption(\"bool\").addAliases(\"b\").create();\n+        var stringOption = stringOption(\"str\").addAliases(\"s\").create();\n+\n+        final var parse = new JOptSimpleOptionsBuilder()\n+                .options(booleanOption, stringOption)\n+                .jOptSimpleParserErrorHandler(err -> {\n+                    return new TestException(String.format(\"%s:%s\", err.type(), err.optionName().formatForCommandLine()));\n+                })\n+                .create();\n+\n+        final var expectedExceptions = List.of(new TestException(expectedErrorMessage));\n+        final var actualExceptions = parse.apply(args).errors();\n+\n+        assertEquals(\n+                expectedExceptions.stream().map(Exception::getMessage).toList(),\n+                actualExceptions.stream().map(Exception::getMessage).toList());\n+    }\n+\n+    @Test\n+    public void testNullErrorMapping() {\n+        final var parse = new JOptSimpleOptionsBuilder().jOptSimpleParserErrorHandler(_ -> {\n+            return null;\n+        }).create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> parse.apply(new String[] {\"--foo\"}));\n+    }\n+\n+    @Test\n+    public void testNoErrorMapping() {\n+        var errors = new JOptSimpleOptionsBuilder()\n+                .options(stringOption(\"str\").create())\n+                .create()\n+                .apply(new String[] {\"--str\"}).errors();\n+\n+        assertEquals(1, errors.size());\n+        assertTrue(errors.iterator().next() instanceof jdk.internal.joptsimple.OptionException);\n+    }\n+\n+    @Test\n+    public void test_optionSpecMapper() {\n+        var mappedOption = stringOption(\"foo\").create();\n+        var unmappedOption = stringOption(\"bar\").create();\n+        var unusedOption = stringOption(\"baz\").create();\n+\n+        final var parse = new JOptSimpleOptionsBuilder().optionSpecMapper(optionSpec -> {\n+            if (optionSpec.name().equals(mappedOption.getSpec().name())) {\n+                return optionSpec.copyWithConverter(OptionValueConverter.<String>build()\n+                        .converter(ValueConverter.create(str -> {\n+                            return str.toUpperCase();\n+                        }, String.class)).create());\n+            } else {\n+                return optionSpec;\n+            }\n+        }).options(mappedOption, unmappedOption, unusedOption).create();\n+\n+        var optionValues = parse.apply(new String[] {\"--foo=Value\", \"--bar\", \"Value\"})\n+                .orElseThrow().convertedOptions().orElseThrow().create();\n+\n+        assertEquals(\"VALUE\", mappedOption.getFrom(optionValues));\n+        assertEquals(\"Value\", unmappedOption.getFrom(optionValues));\n+        assertFalse(unusedOption.containsIn(optionValues));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void test_Options_find_negative(ParserMode mode) {\n+        final var booleanOption = booleanOption(\"b\").create();\n+        final var booleanOption2 = booleanOption(\"b2\").create();\n+\n+        final var stringOption = stringOption(\"str\").create();\n+        final var stringOption2 = stringOption(\"str2\").create();\n+\n+        final List<OptionValue<?>> allOptions = List.of(booleanOption, booleanOption2, stringOption, stringOption2);\n+\n+        final BiFunction<Collection<OptionValue<?>>, List<String>, Options> parse = (options, args) -> {\n+            var theParse = new JOptSimpleOptionsBuilder().options(options).create();\n+            var builder = theParse.apply(args.toArray(String[]::new)).orElseThrow();\n+\n+            switch (mode) {\n+                case PARSE -> {\n+                    return builder.create();\n+                }\n+                case CONVERT -> {\n+                    return builder.convertedOptions().orElseThrow().create();\n+                }\n+                default -> {\n+                    throw new AssertionError();\n+                }\n+            }\n+        };\n+\n+        var optionValues = parse.apply(List.of(booleanOption, stringOption), List.of());\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+\n+        optionValues = parse.apply(allOptions, List.of());\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+\n+        optionValues = parse.apply(allOptions, List.of(\"--b2\"));\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isPresent());\n+        assertTrue(optionValues.find(stringOption.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+\n+        optionValues = parse.apply(allOptions, List.of(\"--str=\"));\n+\n+        assertTrue(optionValues.find(booleanOption.id()).isEmpty());\n+        assertTrue(optionValues.find(booleanOption2.id()).isEmpty());\n+        assertTrue(optionValues.find(stringOption.id()).isPresent());\n+        assertTrue(optionValues.find(stringOption2.id()).isEmpty());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_copyWithExcludes(boolean withRedirects) {\n+        final var aOption = stringOption(\"astr\").createArray();\n+        final var bOption = stringOption(\"bstr\").tokenizeOne().createArray();\n+        final var cOption = stringOption(\"cstr\").tokenizeOne().converter(str -> {\n+            throw new RuntimeException();\n+        }).createArray();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(aOption, bOption, cOption);\n+        if (withRedirects) {\n+            builder.optionSpecMapper(spec -> {\n+                return spec.copyWithDescription(\"Foo\");\n+            });\n+        }\n+\n+        var vanillaParsedOptionBuilder = builder.create().apply(new String[] {\n+                \"--astr\", \"1\", \"--bstr\", \"2\", \"--astr\", \"3\", \"--bstr\", \"4\", \"--cstr\", \"foo\"\n+        }).orElseThrow();\n+\n+        var parsedOptionBuilder = vanillaParsedOptionBuilder;\n+        var options = parsedOptionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id(), bOption.id(), cOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertEquals(List.of(\"foo\"), List.of(cOption.getFrom(options)));\n+\n+        parsedOptionBuilder = parsedOptionBuilder.copyWithExcludes(List.of(cOption.id()));\n+        options = parsedOptionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id(), bOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertFalse(cOption.containsIn(options));\n+\n+        parsedOptionBuilder = parsedOptionBuilder.copyWithExcludes(List.of(bOption.id()));\n+        options = parsedOptionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertFalse(bOption.containsIn(options));\n+        assertFalse(cOption.containsIn(options));\n+\n+        var optionBuilder = vanillaParsedOptionBuilder.copyWithExcludes(List.of(cOption.id())).convertedOptions().orElseThrow();\n+        options = optionBuilder.create();\n+\n+        assertEquals(Set.of(aOption.id(), bOption.id()), options.ids());\n+        assertEquals(List.of(\"1\", \"3\"), List.of(aOption.getFrom(options)));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertFalse(cOption.containsIn(options));\n+\n+        optionBuilder = optionBuilder.copyWithExcludes(List.of(aOption.id()));\n+        options = optionBuilder.create();\n+\n+        assertEquals(Set.of(bOption.id()), options.ids());\n+        assertFalse(aOption.containsIn(options));\n+        assertEquals(List.of(\"2\", \"4\"), List.of(bOption.getFrom(options)));\n+        assertFalse(cOption.containsIn(options));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void test_Options_concat(ParserMode mode) {\n+        final var a = stringOption(\"a\").create();\n+        final var b = stringOption(\"b\").create();\n+        final var c = stringOption(\"c\").create();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(a, b, c);\n+\n+        var parsedOptionBuilder = builder.create().apply(new String[] {\n+                \"-a\", \"foo\", \"-b\", \"bar\"\n+        }).orElseThrow();\n+\n+        Options optionsFromJoptSimple;\n+        var expectedOptions = expectOptions();\n+        switch (mode) {\n+            case PARSE -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.create();\n+                expectedOptions.add(a, new String[] {\"foo\"});\n+            }\n+            case CONVERT -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.convertedOptions().orElseThrow().create();\n+                expectedOptions.add(a, \"foo\");\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        var options = Options.concat(Options.of(Map.of(b, \"buz\")), optionsFromJoptSimple, Options.of(Map.of(c, 100)));\n+\n+        expectedOptions.add(c, 100).add(b, \"buz\").apply(options);\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ParserMode.class)\n+    public void test_Options_copyWith(ParserMode mode) {\n+        final var a = stringOption(\"a\").create();\n+        final var b = stringOption(\"b\").create();\n+        final var c = stringOption(\"c\").create();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(a, b, c);\n+\n+        var parsedOptionBuilder = builder.create().apply(new String[] {\n+                \"-a\", \"foo\", \"-b\", \"bar\"\n+        }).orElseThrow();\n+\n+        Options optionsFromJoptSimple;\n+        var expectedOptions = expectOptions();\n+        switch (mode) {\n+            case PARSE -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.create();\n+                expectedOptions.add(a, new String[] {\"foo\"});\n+            }\n+            case CONVERT -> {\n+                optionsFromJoptSimple = parsedOptionBuilder.convertedOptions().orElseThrow().create();\n+                expectedOptions.add(a, \"foo\");\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+\n+        var options = optionsFromJoptSimple.copyWith(a.id(), c.id());\n+\n+        expectedOptions.apply(options);\n+\n+        options = Options.concat(optionsFromJoptSimple.copyWith(a.id(), c.id()), Options.of(Map.of(c, 100)), Options.of(Map.of(b, \"buz\")));\n+\n+        expectedOptions.add(c, 100).add(b, \"buz\").apply(options);\n+    }\n+\n+    @Test\n+    public void test_detectedOptions() {\n+        final var aOption = stringOption(\"astr\").addAliases(\"a\").createArray();\n+        final var bOption = stringOption(\"bstr\").addAliases(\"b\").defaultOptionalValue(\"empty\").create();\n+        final var cOption = stringOption(\"cstr\").addAliases(\"c\").create();\n+        final var dOption = booleanOption(\"dbool\").addAliases(\"d\").create();\n+        final var eOption = booleanOption(\"ebool\").addAliases(\"e\").create();\n+\n+        var builder = new JOptSimpleOptionsBuilder().options(aOption, bOption, cOption, dOption, eOption);\n+\n+        assertEquals(List.of(), builder.create().apply(new String[] {}).orElseThrow().detectedOptions());\n+\n+        var vanillaParsedOptionBuilder = builder.create().apply(new String[] {\n+                \"-ddededa\", \"1\", \"--bstr\", \"--astr\", \"3\", \"--bstr\", \"4\", \"--ebool\", \"--cstr\", \"foo\", \"-b\"\n+        }).orElseThrow();\n+\n+        var parsedOptionBuilder = vanillaParsedOptionBuilder;\n+        var detectedOptions = parsedOptionBuilder.detectedOptions();\n+\n+        assertEquals(\n+                List.of(\"d\", \"d\", \"e\", \"d\", \"e\", \"d\", \"a\", \"bstr\", \"astr\", \"bstr\", \"ebool\", \"cstr\", \"b\"),\n+                detectedOptions.stream().map(OptionName::name).toList());\n+\n+        var convertedDetectedOptions = parsedOptionBuilder.convertedOptions().orElseThrow().detectedOptions();\n+        assertEquals(detectedOptions, convertedDetectedOptions);\n+\n+        parsedOptionBuilder = vanillaParsedOptionBuilder.copyWithExcludes(List.of(eOption.id()));\n+        detectedOptions = parsedOptionBuilder.detectedOptions();\n+\n+        assertEquals(\n+                List.of(\"d\", \"d\", \"d\", \"d\", \"a\", \"bstr\", \"astr\", \"bstr\", \"cstr\", \"b\"),\n+                detectedOptions.stream().map(OptionName::name).toList());\n+\n+        convertedDetectedOptions = parsedOptionBuilder.convertedOptions().orElseThrow().detectedOptions();\n+        assertEquals(detectedOptions, convertedDetectedOptions);\n+\n+        convertedDetectedOptions = parsedOptionBuilder.convertedOptions().orElseThrow().copyWithExcludes(List.of(aOption.id())).detectedOptions();\n+        assertEquals(\n+                List.of(\"d\", \"d\", \"d\", \"d\", \"bstr\", \"bstr\", \"cstr\", \"b\"),\n+                convertedDetectedOptions.stream().map(OptionName::name).toList());\n+    }\n+\n+    private static <T> T mergeScalarValues(List<T> values, MergePolicy mergePolicy) {\n+        switch (mergePolicy) {\n+            case USE_FIRST -> {\n+                return values.getFirst();\n+            }\n+            case USE_LAST -> {\n+                return values.getLast();\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static <T> T[] mergeArrayValues(List<T[]> values, MergePolicy mergePolicy) {\n+        switch (mergePolicy) {\n+            case USE_FIRST -> {\n+                return values.getFirst();\n+            }\n+            case USE_LAST -> {\n+                return values.getLast();\n+            }\n+            case CONCATENATE -> {\n+                return values.stream().map(Stream::of).flatMap(x -> x).toList().toArray(values.getFirst());\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static String[] mergeUntypedValues(List<String> values, MergePolicy mergePolicy) {\n+        switch (mergePolicy) {\n+            case USE_FIRST -> {\n+                return values.subList(0, 1).toArray(String[]::new);\n+            }\n+            case USE_LAST -> {\n+                return values.subList(values.size() - 1, values.size()).toArray(String[]::new);\n+            }\n+            case CONCATENATE -> {\n+                return values.toArray(String[]::new);\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static List<Object[]> testMergePolicy() {\n+        final List<Object[]> data = new ArrayList<>();\n+        for (var mergePolicy : MergePolicy.values()) {\n+            for (var parserMode : ParserMode.values()) {\n+                data.add(new Object[] { mergePolicy, parserMode });\n+            }\n+        }\n+        return data;\n+    }\n+\n+    private static Collection<Object[]> testErrorMapping() {\n+        return List.<Object[]>of(\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-a\", \"-a\"),\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-a\", \"--a\"),\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-f\", \"-foo\"),\n+                \/\/ Two unrecognizable options, only the first one will be reported\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"--foo\", \"--foo\", \"-z\"),\n+                testErrorMappingTestCase(JOptSimpleErrorType.UNRECOGNIZED_OPTION, \"-z\", \"-z\", \"--foo\"),\n+\n+                testErrorMappingTestCase(JOptSimpleErrorType.OPTION_MISSING_REQUIRED_ARGUMENT, \"--str\", \"--str\")\n+        );\n+    }\n+\n+    private static Object[] testErrorMappingTestCase(JOptSimpleErrorType type, String optionName, String... args) {\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(optionName);\n+        return new Object[] { String.format(\"%s:%s\", type, optionName), args };\n+    }\n+\n+    private static Collection<TestSpec> testOptionalValueParse() {\n+        return testOptionalValue(ParserMode.PARSE);\n+    }\n+\n+    private static Collection<TestSpec> testOptionalValueConvert() {\n+        return testOptionalValue(ParserMode.CONVERT);\n+    }\n+\n+    private static Collection<TestSpec> testOptionalValue(ParserMode parserMode) {\n+        return Stream.of(\n+                build().mode(parserMode).args(\"-x\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"-x\").expect(17).commit(),\n+\n+                build().mode(parserMode).args(\"-x\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"--yy\").expect(17).commit(),\n+\n+                build().mode(parserMode).args(\"--yy\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"--yy\").expect(17).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"23\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"23\").expect(23).commit(),\n+\n+                \/\/\n+                \/\/ joptsimple discards instances of an option without values if there is an instance of the option with a value\n+                \/\/\n+\n+                build().mode(parserMode).args(\"-x\", \"-x\", \"23\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"23\").expect(23).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"-x\", \"23:17\", \"-x\", \"56\", \"-x\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"23:17\", \"56\").expect(new Integer[] {23, 17, 56}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"-x\", \"-x\")\n+                .optionValue(option(\"x\", Integer.class).converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"-x\").expect(new Integer[] {17}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"--yy\").expect(new Integer[] {17}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\", \"-x\", \"--yy\", \"-x\", \"--yy\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"--yy\").expect(new Integer[] {17}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\", \"23:17\", \"-x\", \"56\", \"-x\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).tokenizer(\":\").createArray())\n+                .expectParse(\"23:17\", \"56\").expect(new Integer[] {23, 17, 56}).commit(),\n+\n+                build().mode(parserMode).args(\"-x\", \"--yy\", \"23\", \"-x\", \"56\", \"-x\")\n+                .optionValue(option(\"yy\", Integer.class).addAliases(\"x\").converter(Integer::valueOf).defaultOptionalValue(17).create())\n+                .expectParse(\"56\").expect(56).commit()\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static Collection<TestSpec> test() {\n+        final var pwd = Path.of(\"\").toAbsolutePath();\n+        return Stream.of(\n+                build().optionValue(\n+                        directoryOption(\"input\").addAliases(\"i\").create(),\n+                        pwd\n+                ).args(\"--input\", \"\", \"-i\", pwd.toString()),\n+\n+                build().optionValue(\n+                        directoryOption(\"dir\").tokenizer(pathSeparator()).createArray(),\n+                        new Path[] { pwd, Path.of(\".\") }\n+                ).args(\"--dir=\" + pwd.toString() + pathSeparator() + \".\"),\n+\n+                build().optionValue(\n+                        stringOption(\"arguments\").tokenizer(\"\\\\s+\").createArray(toList()),\n+                        List.of(\"\", \"a\", \"b\", \"c\", \"\", \"de\")\n+                ).args(\"--arguments\", \" a b  c\", \"--arguments\", \" de\"),\n+\n+                build().optionValue(\n+                        stringOption(\"arguments\").tokenizer(\";+\").createArray(toList()),\n+                        List.of(\"a b\", \"c\", \"de\")\n+                ).args(\"--arguments\", \"a b;;c\", \"--arguments\", \"de;\"),\n+\n+                build().optionValue(stringOption(\"foo\").create(), \"--foo\").args(\"--foo\", \"--foo\"),\n+\n+                build().args(\"--foo\")\n+                        .optionValue(booleanOption(\"foo\").create(), true)\n+                        .optionValue(booleanOption(\"bar\").create(), false),\n+\n+                build().args(\"-x\", \"\").optionValue(stringOption(\"x\").create(), \"\"),\n+                build().args(\"-x\", \"\").optionValue(stringOption(\"x\").createArray(), new String[] {\"\"}),\n+                build().args(\"-x\", \"\", \"-x\", \"\").optionValue(stringOption(\"x\").createArray(), new String[] {\"\", \"\"}),\n+\n+                \/\/ Test merging order.\n+                build().optionValue(\n+                        stringOption(\"x\").addAliases(\"y\").tokenizeOne().createArray(toList()),\n+                        List.of(\"10\", \"RR\", \"P\", \"Z\")\n+                ).args(\"-x\", \"10\", \"-y\", \"RR\", \"-x\", \"P\", \"-y\", \"Z\"),\n+\n+                \/\/ Test converters are not executed on discarded invalid values (recoverable conversion errors).\n+                build().optionValue(\n+                        option(\"x\", Integer.class).converter(Integer::valueOf).create(),\n+                        100\n+                ).args(\"-x\", \"a\", \"-x\", \"100\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .exceptionFormatString(\"\")\n+                                .exceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(),\n+                        new Integer[] {34}\n+                ).args(\"-x\", \"34,A\", \"-x\", \"f\"),\n+\n+                \/\/ Test the last array element (recoverable conversion errors).\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(78)\n+                ).args(\"-x\", \"1,3,78\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .exceptionFormatString(\"\")\n+                                .exceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(78)\n+                ).args(\"-x\", \"1,ZZZ,78\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(35)\n+                ).args(\"-x\", \"1,3,78\", \"-x\", \"a\", \"-x\", \"35\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_LAST)\n+                                .converter(Integer::valueOf).tokenizer(TestUtils.splitOrEmpty(\",\")).createArray(toList()),\n+                        List.of()\n+                ).args(\"-x\", \"1,3,78\", \"-x\", \"\"),\n+\n+                \/\/ Test the first array element (recoverable conversion errors).\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .exceptionFormatString(\"\")\n+                                .exceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(1)\n+                ).args(\"-x\", \"1,ZZZ,78\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .converter(Integer::valueOf).tokenizer(\",\").createArray(toList()),\n+                        List.of(1)\n+                ).args(\"-x\", \"1,3,78\", \"-x\", \"a\", \"-x\", \"35\"),\n+                build().optionValue(\n+                        option(\"x\", Integer.class).mergePolicy(MergePolicy.USE_FIRST)\n+                                .converter(Integer::valueOf).tokenizer(TestUtils.splitOrEmpty(\",\")).createArray(toList()),\n+                        List.of()\n+                ).args(\"-x\", \"\", \"-x\", \"1,23,78\"),\n+\n+                \/\/ Test array value is a scalar for parser.\n+                build().optionValue(\n+                        option(\"arr\", int[].class).converter(str -> {\n+                            return Stream.of(str.split(\",\")).map(Integer::valueOf).mapToInt(Integer::intValue).toArray();\n+                        }).create(),\n+                        new int[] {1, 45, 67}\n+                ).args(\"--arr=1,45,67\"),\n+\n+                \/\/ Test that parser can handle multi-dimensional arrays.\n+                build().optionValue(\n+                        option(\"arr\", int[].class).converter(str -> {\n+                            if (str.isEmpty()) {\n+                                return new int[0];\n+                            } else {\n+                                return Stream.of(str.split(\",\")).map(Integer::valueOf).mapToInt(Integer::intValue).toArray();\n+                            }\n+                        }).tokenizer(\":\").createArray(toList()),\n+                        List.of(new int[] {1, 45, 67}, new int[0], new int[] {3}, new int[] {56}, new int[] {77, 82}),\n+                        (expected, actual) -> {\n+                            assertEquals(expected.size(), actual.size());\n+                            for (int i = 0; i != expected.size(); i++) {\n+                                assertArrayEquals(expected.get(i), actual.get(i));\n+                            }\n+                        }\n+                ).args(\"--arr=1,45,67::3:56\", \"--arr=77,82\")\n+\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static Collection<TestSpec> testStringVector() {\n+        final var args = List.of(\"--foo\", \"1 22 333\", \"--foo\", \"44 44\");\n+        return Stream.of(\n+                build().optionValue(\n+                        stringOption(\"foo\").createArray(),\n+                        new String[] { \"1 22 333\", \"44 44\" }\n+                ).args(args),\n+\n+                build().optionValue(\n+                        stringOption(\"foo\").tokenizeOne().createArray(toList()),\n+                        List.of(\"1 22 333\", \"44 44\")\n+                ).args(args),\n+\n+                build().optionValue(\n+                        stringOption(\"foo\").tokenizer(\"\\\\s+\").createArray(),\n+                        new String[] { \"1\", \"22\", \"333\", \"44\", \"44\" }\n+                ).args(args),\n+\n+                build().optionValue(\n+                        stringOption(\"foo\").tokenizer(\"\\\\s+\").createArray(toList()),\n+                        List.of(\"1\", \"22\", \"333\", \"44\", \"44\")\n+                ).args(args)\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> option(String name, Class<? extends T> valueType) {\n+        return OptionSpecBuilder.<T>create(valueType)\n+                .name(Objects.requireNonNull(name))\n+                .scope(new BundlingOperationOptionScope() {\n+                    @Override\n+                    public BundlingOperationDescriptor descriptor() {\n+                        throw new AssertionError();\n+                    }});\n+    }\n+\n+    private static OptionSpecBuilder<String> stringOption(String name) {\n+        return option(name, String.class).converter(identityConv());\n+    }\n+\n+    private static OptionSpecBuilder<Path> pathOption(String name) {\n+        return option(name, Path.class)\n+                .converter(pathConv())\n+                \/\/ \"*\" is an invalid symbol in Windows paths and valid in Linux paths.\n+                \/\/ Add a validator to make it invalid on all platforms to simplify testing.\n+                .validator(new Predicate<Path>() {\n+                    @Override\n+                    public boolean test(Path path) {\n+                        return path.toString().indexOf(\"*\") == -1;\n+                    }\n+                })\n+                .converterExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .converterExceptionFormatString(FORMAT_STRING_ILLEGAL_PATH);\n+    }\n+\n+    private static OptionSpecBuilder<Path> directoryOption(String name) {\n+        return pathOption(name)\n+                .validator(StandardValidator.IS_DIRECTORY)\n+                .validatorExceptionFactory(ERROR_WITH_VALUE_AND_OPTION_NAME)\n+                .validatorExceptionFormatString(FORMAT_STRING_NOT_DIRECTORY);\n+    }\n+\n+    private static OptionSpecBuilder<Boolean> booleanOption(String name) {\n+        return option(name, Boolean.class).defaultValue(Boolean.FALSE);\n+    }\n+\n+    private static Function<List<String>, Options> createParser(ParserMode mode, OptionValue<?>... options) {\n+        return createParser(mode, List.of(options));\n+    }\n+\n+    private static Function<List<String>, Options> createParser(ParserMode mode, Iterable<OptionValue<?>> options) {\n+        Objects.requireNonNull(mode);\n+        final var parse = new JOptSimpleOptionsBuilder().options(StreamSupport.stream(options.spliterator(), false)\n+                .map(OptionValue::getOption).toList()).create();\n+        return args -> {\n+            final var builder = parse.apply(args.toArray(String[]::new)).orElseThrow();\n+            switch (mode) {\n+                case PARSE -> {\n+                    return builder.create();\n+                }\n+                case CONVERT -> {\n+                    return builder.convertedOptions().orElseThrow().create();\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        };\n+    }\n+\n+    private static TestSpec.Builder build() {\n+        return new TestSpec.Builder();\n+    }\n+\n+\n+    private static final class FaultyParserArgsConfig {\n+\n+        void test() {\n+\n+            final Collection<OptionFailure> recordedErrors = new ArrayList<>();\n+\n+            final List<OptionValue<?>> optionValues = new ArrayList<>();\n+\n+            optionSpecBuilders.stream().map(builder -> {\n+                configureExceptions(builder);\n+                return builder.exceptionFactory(TestUtils.recordExceptions(recordedErrors));\n+            }).map(OptionSpecBuilder::create).forEach(optionValues::add);\n+\n+            arrayOptionSpecBuilders.stream().map(builder -> {\n+                configureExceptions(builder);\n+                return builder.exceptionFactory(TestUtils.recordExceptions(recordedErrors));\n+            }).map(OptionSpecBuilder::createArray).forEach(optionValues::add);\n+\n+            final var parser = new JOptSimpleOptionsBuilder().options(optionValues).create();\n+\n+            final Supplier<Result<?>> createCmdline = parser.apply(args.toArray(String[]::new)).orElseThrow()::convertedOptions;\n+\n+            if (expectedConverterException == null) {\n+                final var result = createCmdline.get();\n+\n+                assertFalse(result.hasValue());\n+\n+                \/\/ Not all exceptions recorded by TestUtils.recordExceptions() facility\n+                \/\/ will be returned by JOptSimpleOptionsBuilder.OptionsBuilder.convertedOptions()\n+                \/\/ because it may run a converter multiple times on the same option value,\n+                \/\/ attempting to recover from a previous error.\n+                var actualErrors = result.errors().stream().map(exception -> {\n+                    return recordedErrors.stream().filter(recorderdFailure -> {\n+                        return (recorderdFailure.exception().orElseThrow() == exception);\n+                    }).findFirst().map(OptionFailure::withoutException).orElseThrow();\n+                }).toList();\n+\n+                assertEquals(expectedErrors, actualErrors);\n+\n+            } else {\n+                final var ex = assertThrowsExactly(ConverterException.class, () -> createCmdline.get());\n+                assertSame(expectedConverterException, ex.getCause());\n+            }\n+        }\n+\n+        FaultyParserArgsConfig args(Collection<String> v) {\n+            args.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig args(String... v) {\n+            return args(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig clearArgs() {\n+            args.clear();\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig options(Collection<OptionSpecBuilder<?>> v) {\n+            optionSpecBuilders.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig options(OptionSpecBuilder<?>... v) {\n+            return options(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig arrayOptions(Collection<OptionSpecBuilder<?>> v) {\n+            arrayOptionSpecBuilders.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig arrayOptions(OptionSpecBuilder<?>... v) {\n+            return arrayOptions(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig expectErrors(Collection<OptionFailure> v) {\n+            expectedErrors.addAll(v);\n+            return this;\n+        }\n+\n+        FaultyParserArgsConfig expectErrors(OptionFailure... v) {\n+            return expectErrors(List.of(v));\n+        }\n+\n+        FaultyParserArgsConfig expectError(String optionName, String optionValue) {\n+            return expectError(optionName, StringToken.of(optionValue));\n+        }\n+\n+        FaultyParserArgsConfig expectError(String optionName, StringToken optionValue) {\n+            return expectErrors(new OptionFailure(optionName, optionValue));\n+        }\n+\n+        FaultyParserArgsConfig expectConverterException(Exception v) {\n+            expectedConverterException = v;\n+            return this;\n+        }\n+\n+        private static void configureExceptions(OptionSpecBuilder<?> builder) {\n+            builder.exceptionFactory(factory -> {\n+                if (factory == null) {\n+                    builder.exceptionFormatString(\"Option value [%s] of option %s\");\n+                    factory = ERROR_WITH_VALUE_AND_OPTION_NAME;\n+                }\n+                return factory;\n+            });\n+        }\n+\n+        private final List<String> args = new ArrayList<>();\n+        private final Collection<OptionSpecBuilder<?>> optionSpecBuilders = new ArrayList<>();\n+        private final Collection<OptionSpecBuilder<?>> arrayOptionSpecBuilders = new ArrayList<>();\n+        private final List<OptionFailure> expectedErrors = new ArrayList<>();\n+        private Exception expectedConverterException;\n+    }\n+\n+\n+    private static final String FORMAT_STRING_ILLEGAL_PATH = \"The value '%s' provided for parameter %s is not a valid path\";\n+\n+    private static final String FORMAT_STRING_NOT_DIRECTORY = \"The value '%s' provided for parameter %s is not a directory path\";\n+\n+    private static final OptionValueExceptionFactory<? extends RuntimeException> ERROR_WITH_VALUE_AND_OPTION_NAME = OptionValueExceptionFactory.build(TestException::new)\n+            .formatArgumentsTransformer(StandardArgumentsMapper.VALUE_AND_NAME)\n+            .messageFormatter(String::format)\n+            .create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/JOptSimpleOptionsBuilderTest.java","additions":1428,"deletions":0,"binary":false,"changes":1428,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class MainTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testOutput(TestSpec test) throws IOException {\n+        test.run();\n+    }\n+\n+    private static Collection<TestSpec> testOutput() {\n+        return Stream.of(\n+                \/\/ Print the tool version\n+                build().expectShortHelp(),\n+                \/\/ Print the tool version\n+                build().args(\"--version\").expectVersion(),\n+                \/\/ Print the tool version\n+                build().args(\"foo\", \"bar\").expectErrors(I18N.format(\"error.non-option-arguments\", 2)),\n+                \/\/ Valid command line requesting to print the full help.\n+                build().args(\"-h\").expectFullHelp(),\n+                \/\/ Valid command line requesting to build a package and print the full help.\n+                build().args(\"--main-jar\", \"hello.jar\", \"-?\", \"--main-class\", \"foo\").expectFullHelp(),\n+                \/\/ Valid command line requesting to build a package and print the full help and the version of the tool.\n+                build().args(\"--main-jar\", \"hello.jar\", \"-?\", \"--main-class\", \"foo\", \"--version\").expectVersionWithHelp(),\n+                \/\/ Valid command line requesting to print the full help and the version of the tool.\n+                build().args(\"--help\", \"--version\").expectVersionWithHelp(),\n+                \/\/ Invalid command line requesting to print the version of the tool.\n+                build().args(\"foo\", \"--version\").expectErrors(I18N.format(\"error.non-option-arguments\", 1))\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+\n+    record TestSpec(List<String> args, int expectedExitCode, List<String> expectedStdout, List<String> expectedStderr) {\n+\n+        TestSpec {\n+            Objects.requireNonNull(args);\n+            Objects.requireNonNull(expectedStdout);\n+            Objects.requireNonNull(expectedStderr);\n+        }\n+\n+        void run() {\n+            var result = ExecutionResult.create(args.toArray(String[]::new));\n+            assertEquals(expectedExitCode, result.exitCode());\n+            assertEquals(expectedStdout, result.stdout());\n+            assertEquals(expectedStderr, result.stderr());\n+        }\n+\n+\n+        static final class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(args, expectedExitCode, expectedStdout, expectedStderr);\n+            }\n+\n+            Builder args(String... v) {\n+                return args(List.of(v));\n+            }\n+\n+            Builder args(Collection<String> v) {\n+                args.addAll(v);\n+                return this;\n+            }\n+\n+            Builder expectStdout(String... lines) {\n+                return expectStdout(List.of(lines));\n+            }\n+\n+            Builder expectStdout(Collection<String> lines) {\n+                return append(expectedStdout, lines);\n+            }\n+\n+            Builder expectStderr(String... lines) {\n+                return expectStderr(List.of(lines));\n+            }\n+\n+            Builder expectStderr(Collection<String> lines) {\n+                return append(expectedStderr, lines);\n+            }\n+\n+            Builder expectShortHelp() {\n+                var sb = new StringBuilder();\n+                new StandardHelpFormatter(OperatingSystem.current()).formatNoArgsHelp(sb::append);\n+                return expectStdout(lines(sb.toString()));\n+            }\n+\n+            Builder expectFullHelp() {\n+                try {\n+                    return expectStdout(Files.readAllLines(goldenHelpOutputFile(OperatingSystem.current())));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            }\n+\n+            Builder expectVersion() {\n+                return expectStdout(System.getProperty(\"java.version\"));\n+            }\n+\n+            Builder expectVersionWithHelp() {\n+                return expectVersion().expectStdout(\"\").expectFullHelp();\n+            }\n+\n+            Builder expectErrors(String... msg) {\n+                return expectErrorExitCode().expectStderr(Stream.of(msg).map(v -> {\n+                    return I18N.format(\"message.error-header\", v);\n+                }).toList());\n+            }\n+\n+            Builder expectExitCode(int v) {\n+                expectedExitCode = v;\n+                return this;\n+            }\n+\n+            Builder expectErrorExitCode() {\n+                return expectExitCode(1);\n+            }\n+\n+            private Builder append(List<String> sink, Collection<String> lines) {\n+                lines.forEach(sink::add);\n+                return this;\n+            }\n+\n+            private List<String> args = new ArrayList<>();\n+            private int expectedExitCode;\n+            private List<String> expectedStdout = new ArrayList<>();\n+            private List<String> expectedStderr = new ArrayList<>();\n+        }\n+    }\n+\n+\n+    private record ExecutionResult(List<String> stdout, List<String> stderr, int exitCode) {\n+\n+        ExecutionResult {\n+            Objects.requireNonNull(stdout);\n+            Objects.requireNonNull(stderr);\n+        }\n+\n+        static ExecutionResult create(String... args) {\n+            var stdout = new StringWriter();\n+            var stderr = new StringWriter();\n+\n+            var exitCode = Main.run(new PrintWriter(stdout), new PrintWriter(stderr), args);\n+\n+            return new ExecutionResult(lines(stdout.toString()), lines(stderr.toString()), exitCode);\n+        }\n+    }\n+\n+\n+    private static TestSpec.Builder build() {\n+        return new TestSpec.Builder();\n+    }\n+\n+    private static List<String> lines(String str) {\n+        return new BufferedReader(new StringReader(str)).lines().toList();\n+    }\n+\n+    private static Path goldenHelpOutputFile(OperatingSystem os) {\n+        String fname = String.format(\"help-%s.txt\", os.name().toLowerCase());\n+        return TKit.TEST_SRC_ROOT.resolve(\"junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\", fname);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/MainTest.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+\n+final class MockupCliBundlingEnvironment implements CliBundlingEnvironment {\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    private MockupCliBundlingEnvironment(\n+            Optional<BundlingOperationDescriptor> defaultOperation,\n+            BiConsumer<BundlingOperationDescriptor, Options> createBundleCallback,\n+            Map<BundlingOperationDescriptor, List<Exception>> knownOperations) {\n+\n+        this.defaultOperation = Objects.requireNonNull(defaultOperation);\n+        this.createBundleCallback = Objects.requireNonNull(createBundleCallback);\n+        this.knownOperations = Map.copyOf(knownOperations);\n+    }\n+\n+    @Override\n+    public Optional<BundlingOperationDescriptor> defaultOperation() {\n+        return defaultOperation;\n+    }\n+\n+    @Override\n+    public void createBundle(BundlingOperationDescriptor op, Options cmdline) {\n+        createBundleCallback.accept(throwIfUnknownBundlingOperation(op), cmdline);\n+    }\n+\n+    @Override\n+    public Collection<? extends Exception> configurationErrors(BundlingOperationDescriptor op) {\n+        throwIfUnknownBundlingOperation(op);\n+        return Optional.ofNullable(knownOperations.get(op)).orElseGet(List::of);\n+    }\n+\n+    private BundlingOperationDescriptor throwIfUnknownBundlingOperation(BundlingOperationDescriptor op) {\n+        if (!knownOperations.containsKey(Objects.requireNonNull(op))) {\n+            throw new NoSuchElementException(String.format(\"Unknown bunbdling operation: [%s]\", op));\n+        }\n+        return op;\n+    }\n+\n+    static StandardBundlingOperation createAppImageBundlingOperation(OperatingSystem os) {\n+        Objects.requireNonNull(os);\n+        return StandardBundlingOperation.CREATE_APP_IMAGE.stream()\n+                .map(StandardBundlingOperation.class::cast)\n+                .filter(StandardBundlingOperation.platform(os))\n+                .findFirst().orElseThrow();\n+    }\n+\n+\n+    static final class Builder {\n+\n+        CliBundlingEnvironment create() {\n+            return new MockupCliBundlingEnvironment(\n+                    defaultOperation(),\n+                    createBundleCallback().orElse((_, _) -> {}),\n+                    knownOperations);\n+        }\n+\n+        Builder defaultOperation(BundlingOperationDescriptor v) {\n+            defaultOperation = v;\n+            return this;\n+        }\n+\n+        Builder knownOperation(BundlingOperationDescriptor v) {\n+            knownOperations.putIfAbsent(Objects.requireNonNull(v), List.of());\n+            return this;\n+        }\n+\n+        Builder createAppImageByDefault(OperatingSystem os) {\n+            return defaultOperation(createAppImageBundlingOperation(os).descriptor());\n+        }\n+\n+        Builder createAppImageByDefault() {\n+            return createAppImageByDefault(OperatingSystem.current());\n+        }\n+\n+        Builder createBundleCallback(Consumer<Options> v) {\n+            return createBundleCallback((_, options) -> v.accept(options));\n+        }\n+\n+        Builder createBundleCallback(BiConsumer<BundlingOperationDescriptor, Options> v) {\n+            createBundleCallback = v;\n+            return this;\n+        }\n+\n+        Builder configurationErrors(BundlingOperationDescriptor targetOperation, List<Exception> v) {\n+            if (targetOperation != null) {\n+                knownOperations.merge(targetOperation, v, (x, y) -> {\n+                    List<Exception> errors = new ArrayList<>(x);\n+                    errors.addAll(y);\n+                    return errors;\n+                });\n+            } else if (!knownOperations.isEmpty()) {\n+                knownOperations.keySet().forEach(op -> {\n+                    configurationErrors(op, v);\n+                });\n+            } else {\n+                throw new UnsupportedOperationException(\"Can not set errors for unknown bundling operations\");\n+            }\n+            return this;\n+        }\n+\n+        Builder configurationErrors(BundlingOperationDescriptor targetOperation, Exception... errors) {\n+            return configurationErrors(targetOperation, List.of(errors));\n+        }\n+\n+        private Optional<BiConsumer<BundlingOperationDescriptor, Options>> createBundleCallback() {\n+            return Optional.ofNullable(createBundleCallback);\n+        }\n+\n+        private Optional<BundlingOperationDescriptor> defaultOperation() {\n+            return Optional.ofNullable(defaultOperation);\n+        }\n+\n+        private BundlingOperationDescriptor defaultOperation;\n+        private BiConsumer<BundlingOperationDescriptor, Options> createBundleCallback;\n+        private final Map<BundlingOperationDescriptor, List<Exception>> knownOperations = new HashMap<>();\n+    }\n+\n+\n+    private final Optional<BundlingOperationDescriptor> defaultOperation;\n+    private final BiConsumer<BundlingOperationDescriptor, Options> createBundleCallback;\n+    private final Map<BundlingOperationDescriptor, List<Exception>> knownOperations;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/MockupCliBundlingEnvironment.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.OptionIdentifier.createIdentifier;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class OptionIdentifierTest {\n+\n+    @Test\n+    public void test_createUnique() {\n+\n+        var a = createIdentifier();\n+        var b = createIdentifier();\n+\n+        assertNotNull(a);\n+        assertNotNull(b);\n+\n+        assertNotSame(a, b);\n+        assertNotEquals(a, b);\n+    }\n+\n+    @Test\n+    public void test_of() {\n+\n+        assertThrowsExactly(NullPointerException.class, () -> OptionIdentifier.of(null));\n+\n+        var a = OptionIdentifier.of(\"a\");\n+\n+        assertNotNull(a);\n+\n+        assertNotEquals(\"a\", a);\n+        assertNotEquals(createIdentifier(), a);\n+        assertEquals(OptionIdentifier.of(\"a\"), a);\n+        assertNotEquals(OptionIdentifier.of(\"A\"), a);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionIdentifierTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class OptionNameTest {\n+\n+    record TestSpec(String value, String expectedName, String expectedOnCmdLine, boolean expectedIsShort) {\n+        TestSpec {\n+            Objects.requireNonNull(value);\n+            Objects.requireNonNull(expectedName);\n+            Objects.requireNonNull(expectedOnCmdLine);\n+        }\n+\n+        void run() {\n+            final var optionName = OptionName.of(value);\n+\n+            assertEquals(expectedName, optionName.name());\n+            assertEquals(expectedOnCmdLine, optionName.formatForCommandLine());\n+            assertEquals(expectedIsShort, optionName.isShort());\n+        }\n+\n+        static final class Builder {\n+\n+            TestSpec create() {\n+                return new TestSpec(value, validatedExpectedName(), validatedExpectedOnCmdLine(), validatedExpectedIsShort());\n+            }\n+\n+            Builder value(String v) {\n+                value = v;\n+                return this;\n+            }\n+\n+            Builder expectedName(String v) {\n+                expectedName = v;\n+                return this;\n+            }\n+\n+            Builder expectedOnCmdLine(String v) {\n+                expectedOnCmdLine = v;\n+                return this;\n+            }\n+\n+            Builder isShort() {\n+                expectedIsShort = true;\n+                return this;\n+            }\n+\n+            private String validatedExpectedName() {\n+                return Optional.ofNullable(expectedName).orElse(value);\n+            }\n+\n+            private String validatedExpectedOnCmdLine() {\n+                return Optional.ofNullable(expectedOnCmdLine).orElseGet(() -> {\n+                    if (validatedExpectedIsShort()) {\n+                        return \"-\" + validatedExpectedName();\n+                    } else {\n+                        return \"--\" + validatedExpectedName();\n+                    }\n+                });\n+            }\n+\n+            private boolean validatedExpectedIsShort() {\n+                return Optional.ofNullable(expectedIsShort).orElseGet(() -> {\n+                    return validatedExpectedName().length() == 1;\n+                });\n+            }\n+\n+            private String value;\n+            private String expectedName;\n+            private String expectedOnCmdLine;\n+            private Boolean expectedIsShort;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test(TestSpec testSpec) {\n+        testSpec.run();\n+    }\n+\n+    private static List<TestSpec> test() {\n+        return Stream.of(\n+                build(\"foo\"),\n+                build(\"x\"),\n+                build(\"--foo\").expectedName(\"foo\"),\n+                build(\"--f\").expectedName(\"f\").isShort(),\n+                build(\"-foo\").expectedName(\"f\").isShort(),\n+                build(\"-x\").expectedName(\"x\").isShort(),\n+                build(\"---\").expectedName(\"-\")\n+        ).map(TestSpec.Builder::create).toList();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void negativeTest(Map.Entry<String, String> testSpec) {\n+        final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> OptionName.of(testSpec.getKey()));\n+        assertEquals(testSpec.getValue(), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void compareTest() {\n+        assertTrue(0 == OptionName.of(\"a\").compareTo(OptionName.of(\"a\")));\n+        assertTrue(OptionName.of(\"a\").compareTo(OptionName.of(\"b\")) < 0);\n+        assertTrue(OptionName.of(\"b\").compareTo(OptionName.of(\"a\")) > 0);\n+    }\n+\n+    private static Collection<Map.Entry<String, String>> negativeTest() {\n+        return Map.of(\n+                \"\", \"Name should not be empty\",\n+                \"-\", \"Short option without a name\",\n+                \"--\", \"Long option without a name\"\n+        ).entrySet();\n+    }\n+\n+    private static TestSpec.Builder build(String value) {\n+        return new TestSpec.Builder().value(value);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionNameTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionSpecMutatorOptionScopeTest {\n+\n+    record DummyContext(int value) {\n+        <T> OptionSpec<T> mapOptionSpec(OptionSpec<T> optionSpec) {\n+            return OptionSpecMapperOptionScope.mapOptionSpec(optionSpec, this);\n+        }\n+\n+        static <T> Consumer<OptionSpecBuilder<T>> createOptionSpecBuilderMutator(\n+                BiConsumer<OptionSpecBuilder<T>, DummyContext> mutator) {\n+            return OptionSpecMapperOptionScope.createOptionSpecBuilderMutator(DummyContext.class, mutator);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_mapOptionSpec_scalar(boolean multipleMutators) {\n+\n+        var theSpecBuilder = OptionSpecBuilder.<String>create(String.class).converter(str -> {\n+            return \"123\";\n+        }).name(\"foo\");\n+\n+        DummyContext.<String>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.converter(str -> {\n+                return Integer.toString(context.value());\n+            });\n+        }).accept(theSpecBuilder);\n+\n+        if (multipleMutators) {\n+            DummyContext.<String>createOptionSpecBuilderMutator((specBuilder, _) -> {\n+                specBuilder.name(\"Foo\");\n+            }).accept(theSpecBuilder);\n+        }\n+\n+        var spec = theSpecBuilder.createOptionSpec();\n+\n+        var mappedSpec = new DummyContext(731).mapOptionSpec(spec);\n+\n+        if (multipleMutators) {\n+            assertEquals(OptionName.of(\"Foo\"), mappedSpec.name());\n+        } else {\n+            assertEquals(OptionName.of(\"foo\"), mappedSpec.name());\n+        }\n+\n+        assertEquals(\"731\", mappedSpec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+\n+        assertEquals(OptionName.of(\"foo\"), spec.name());\n+\n+        assertEquals(\"123\", spec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+    }\n+\n+    @Test\n+    public void test_mapOptionSpec_array() {\n+\n+        var theSpecBuilder = OptionSpecBuilder.<String>create(String.class).converter(str -> {\n+            return \"123\";\n+        }).name(\"foo\");\n+\n+        DummyContext.<String>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.converter(str -> {\n+                return Integer.toString(context.value());\n+            });\n+        }).accept(theSpecBuilder);\n+\n+        var spec = theSpecBuilder.createArrayOptionSpec();\n+\n+        var mappedSpec = new DummyContext(731).mapOptionSpec(spec);\n+\n+        assertArrayEquals(new String[] {\"731\"}, mappedSpec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+\n+        assertEquals(OptionName.of(\"foo\"), spec.name());\n+\n+        assertArrayEquals(new String[] {\"123\"}, spec.converter().orElseThrow().convert(spec.name(), StringToken.of(\"str\")).orElseThrow());\n+\n+    }\n+\n+    @Test\n+    public void test_createOptionSpecBuilderMutator_multiple() {\n+\n+        var theSpecBuilder = OptionSpecBuilder.<Integer>create(Integer.class).converter(Integer::parseInt);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.description(\"Foo\");\n+        }).accept(theSpecBuilder);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.name(\"animal\");\n+        }).accept(theSpecBuilder);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.addAliases(\"fox\");\n+        }).accept(theSpecBuilder);\n+\n+        DummyContext.<Integer>createOptionSpecBuilderMutator((specBuilder, context) -> {\n+            specBuilder.addAliases(\"dog\");\n+        }).accept(theSpecBuilder);\n+\n+        var spec = theSpecBuilder.name(\"cat\").createArrayOptionSpec();\n+\n+        var mappedSpec = new DummyContext(0).mapOptionSpec(spec);\n+\n+        assertEquals(Stream.of(\"cat\").map(OptionName::of).toList(), spec.names());\n+        assertEquals(\"\", spec.description());\n+\n+        assertEquals(Stream.of(\"animal\", \"fox\", \"dog\").map(OptionName::of).toList(), mappedSpec.names());\n+        assertEquals(\"Foo\", mappedSpec.description());\n+\n+        assertEquals(spec.converter(), mappedSpec.converter());\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionSpecMutatorOptionScopeTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.StandardValueConverter.identityConv;\n+import static jdk.jpackage.internal.cli.StandardValueConverter.pathConv;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.IntStream;\n+import jdk.jpackage.internal.cli.OptionSpec.MergePolicy;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionSpecTest {\n+\n+    @Test\n+    public void test_otherNames() {\n+        assertEquals(toOptionNames(\"b\", \"foo\"), buildSpec().names(\"a\", \"b\", \"foo\").create().otherNames());\n+        assertEquals(toOptionNames(), buildSpec().names(\"a\").create().otherNames());\n+        assertEquals(toOptionNames(\"b\", \"a\"), buildSpec().names(\"a\", \"b\", \"a\").create().otherNames());\n+    }\n+\n+    @Test\n+    public void test_names() {\n+        assertEquals(toOptionNames(\"a\", \"b\", \"foo\"), buildSpec().names(\"a\", \"b\", \"foo\").create().names());\n+        assertEquals(toOptionNames(\"a\"), buildSpec().names(\"a\").create().names());\n+        assertEquals(toOptionNames(\"a\", \"b\", \"a\"), buildSpec().names(\"a\", \"b\", \"a\").create().names());\n+    }\n+\n+    @Test\n+    public void test_name() {\n+        assertEquals(OptionName.of(\"a\"), buildSpec().names(\"a\", \"b\", \"foo\").create().name());\n+        assertEquals(OptionName.of(\"a\"), buildSpec().names(\"a\").create().name());\n+    }\n+\n+    @Test\n+    public void test_valueType() {\n+        assertThrows(RuntimeException.class, buildSpec().names(\"foo\").create()::valueType);\n+        assertEquals(String.class, OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create().valueType());\n+        assertEquals(Path.class, OptionSpecTest.<Path>buildSpec().names(\"foo\").converter(converter(pathConv())).create().valueType());\n+    }\n+\n+    @Test\n+    public void test_hasValue() {\n+        assertFalse(buildSpec().names(\"foo\").create().hasValue());\n+        assertTrue(OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create().hasValue());\n+        assertTrue(OptionSpecTest.<Path>buildSpec().names(\"foo\").converter(converter(pathConv())).create().hasValue());\n+    }\n+\n+    @Test\n+    public void test_isValueOptional() {\n+        assertFalse(buildSpec().names(\"foo\").create().isValueOptional());\n+        assertFalse(OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create().isValueOptional());\n+        assertTrue(OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).defaultOptionalValue(\"str\").create().isValueOptional());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_copyWithConverter(boolean hasInitialConverter) {\n+\n+        final var scope = Set.of((OptionScope)new OptionScope() {});\n+\n+        final OptionSpecBuilder<?> builder;\n+        if (hasInitialConverter) {\n+            builder = OptionSpecTest.<String>buildSpec().converter(converter(identityConv()));\n+        } else {\n+            builder = buildSpec();\n+        }\n+\n+        UnaryOperator<OptionSpecBuilder<?>> builderMutator = v -> {\n+            v.names(\"foo\", \"bar\").description(\"description\").scope(scope);\n+            if (hasInitialConverter) {\n+                v.valuePattern(\"<value>\");\n+            }\n+            return v;\n+        };\n+\n+        final var converter = converter(pathConv());\n+\n+        final var spec = builderMutator.apply(builder).create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> spec.copyWithConverter(null));\n+\n+        final var actualConvSpec = spec.copyWithConverter(converter);\n+\n+        final var expectedConvSpec = builderMutator.apply(OptionSpecTest.<Path>buildSpec().converter(converter)).create();\n+\n+        assertEquals(expectedConvSpec, actualConvSpec);\n+    }\n+\n+    @Test\n+    public void test_copyWithConverter_fail() {\n+        var spec = OptionSpecTest.<String>buildSpec()\n+                .names(\"foo\")\n+                .valuePattern(\"<value>\")\n+                .defaultOptionalValue(\"str\")\n+                .converter(converter(identityConv()))\n+                .description(\"Hello!\").create();\n+\n+        final var pathConverter = converter(pathConv());\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> spec.copyWithConverter(pathConverter));\n+    }\n+\n+    @Test\n+    public void test_copyWithDescription() {\n+\n+        final var builder = OptionSpecTest.<String>buildSpec()\n+                .names(\"foo\", \"bar\")\n+                .valuePattern(\"<value>\")\n+                .converter(converter(identityConv()))\n+                .description(\"Hello!\");\n+\n+        final var spec = builder.create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> spec.copyWithDescription(null));\n+\n+        final var actualConvSpec = spec.copyWithDescription(\"Bye!\");\n+\n+        final var expectedConvSpec = builder.description(\"Bye!\").create();\n+\n+        assertEquals(expectedConvSpec, actualConvSpec);\n+    }\n+\n+    @Test\n+    public void test_copyWithName() {\n+\n+        final var builder = OptionSpecTest.<String>buildSpec()\n+                .names(\"foo\", \"bar\")\n+                .valuePattern(\"<value>\")\n+                .converter(converter(identityConv()))\n+                .description(\"Hello!\");\n+\n+        final var spec = builder.create();\n+\n+        assertThrowsExactly(NullPointerException.class, () -> spec.copyWithName(null));\n+\n+        final var actualConvSpec = spec.copyWithName(OptionName.of(\"buz\"));\n+\n+        final var expectedConvSpec = builder.names(\"buz\").create();\n+\n+        assertEquals(expectedConvSpec, actualConvSpec);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_findNamesIn_and_getFirstNameIn(boolean found) {\n+\n+        var spec = OptionSpecTest.<String>buildSpec().names(\"z\", \"a\", \"b\").converter(converter(identityConv())).create();\n+\n+        final Options options;\n+        if (found) {\n+            options = Options.of(Map.of(OptionValue.<String>build().spec(spec).create(), 100));\n+        } else {\n+            options = Options.of(Map.of());\n+        }\n+\n+        final List<OptionName> expectedNames;\n+        if (found) {\n+            expectedNames = toOptionNames(\"z\", \"a\", \"b\");\n+        } else {\n+            expectedNames = List.of();\n+        }\n+\n+        assertEquals(expectedNames, spec.findNamesIn(options));\n+\n+        if (found) {\n+            assertEquals(expectedNames.getFirst(), spec.getFirstNameIn(options));\n+        } else {\n+            assertThrowsExactly(NoSuchElementException.class, () -> spec.getFirstNameIn(options));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_arrayValueConverter(boolean empty) {\n+\n+        final Optional<OptionArrayValueConverter<String>> arrayConverter;\n+        final OptionSpec<?> spec;\n+        if (empty) {\n+            arrayConverter = Optional.empty();\n+            spec = OptionSpecTest.<String>buildSpec().names(\"foo\").converter(converter(identityConv())).create();\n+        } else {\n+            arrayConverter = Optional.of(buildConverter(identityConv()).tokenizer(str -> new String[] {str}).createArray());\n+            spec = OptionSpecTest.<String[]>buildSpec().names(\"foo\").converter(arrayConverter.get()).create();\n+        }\n+\n+        assertEquals(arrayConverter, spec.arrayValueConverter());\n+    }\n+\n+    @Test\n+    public void testInvalid() {\n+        IllegalArgumentException ex;\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names().create();\n+        });\n+        assertEquals(\"Empty name list\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").scope(Set.of()).create();\n+        });\n+        assertEquals(\"Empty scope\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").mergePolicy(MergePolicy.CONCATENATE).create();\n+        });\n+        assertEquals(\"Invalid merge policy [\" + MergePolicy.CONCATENATE + \"] for type []\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            OptionSpecTest.<String>buildSpec().names(\"foo\")\n+                    .converter(converter(identityConv()))\n+                    .mergePolicy(MergePolicy.CONCATENATE)\n+                    .create();\n+        });\n+        assertEquals(\"Invalid merge policy [\" + MergePolicy.CONCATENATE + \"] for type [\" + String.class.getName() + \"]\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").valuePattern(\"<int>\").create();\n+        });\n+        assertEquals(\"Option without a value can not have a value pattern\", ex.getMessage());\n+\n+        ex = assertThrowsExactly(IllegalArgumentException.class, () -> {\n+            buildSpec().names(\"foo\").defaultOptionalValue(new Object()).create();\n+        });\n+        assertEquals(\"Option with optional value should have a converter\", ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_generateForEveryName(boolean hasValue) {\n+\n+        final var names = List.of(\"a\", \"b\", \"foo\");\n+\n+        final OptionSpecBuilder<?> builder;\n+        if (hasValue) {\n+            builder = OptionSpecTest.<String>buildSpec().names(names).converter(converter(identityConv()));\n+        } else {\n+            builder = buildSpec().names(names);\n+        }\n+\n+        final var optionSpecs = builder.create().copyForEveryName().toList();\n+\n+        assertEquals(names.size(), optionSpecs.size());\n+\n+        IntStream.range(0, names.size()).forEach(i -> {\n+            assertEquals(builder.names(names.get(i)).create(), optionSpecs.get(i));\n+        });\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> buildSpec() {\n+        return new OptionSpecBuilder<>();\n+    }\n+\n+    private static List<OptionName> toOptionNames(Collection<String> names) {\n+        return names.stream().map(OptionName::of).toList();\n+    }\n+\n+    private static List<OptionName> toOptionNames(String... names) {\n+        return toOptionNames(List.of(names));\n+    }\n+\n+    private static <T> OptionValueConverter<T> converter(ValueConverter<T> conv) {\n+        return buildConverter(conv).create();\n+    }\n+\n+    private static <T> OptionValueConverter.Builder<T> buildConverter(ValueConverter<T> conv) {\n+        return OptionValueConverter.<T>build().converter(conv);\n+    }\n+\n+\n+    private static final class OptionSpecBuilder<T> {\n+\n+        OptionSpec<T> create() {\n+            return new OptionSpec<>(\n+                    Optional.ofNullable(names).orElseGet(List::of),\n+                    Optional.ofNullable(converter),\n+                    Optional.ofNullable(scope).orElseGet(Set::of),\n+                    mergePolicy,\n+                    Optional.ofNullable(defaultOptionalValue),\n+                    Optional.ofNullable(valuePattern),\n+                    description);\n+        }\n+\n+        OptionSpecBuilder<T> names(String... v) {\n+            return names(List.of(v));\n+        }\n+\n+        OptionSpecBuilder<T> description(String v) {\n+            description = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> names(List<String> v) {\n+            names = Optional.ofNullable(v).map(OptionSpecTest::toOptionNames).orElse(null);\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> converter(OptionValueConverter<T> v) {\n+            converter = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> defaultOptionalValue(T v) {\n+            defaultOptionalValue = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> scope(Set<OptionScope> v) {\n+            scope = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> mergePolicy(MergePolicy v) {\n+            mergePolicy = v;\n+            return this;\n+        }\n+\n+        OptionSpecBuilder<T> valuePattern(String v) {\n+            valuePattern = v;\n+            return this;\n+        }\n+\n+        private List<OptionName> names;\n+        private OptionValueConverter<T> converter;\n+        private T defaultOptionalValue;\n+        private Set<OptionScope> scope = Set.of(new OptionScope() {});\n+        private MergePolicy mergePolicy = MergePolicy.USE_LAST;\n+        private String valuePattern;\n+        private String description = \"\";\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionSpecTest.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionListEquals;\n+import static jdk.jpackage.internal.cli.TestUtils.configureConverter;\n+import static jdk.jpackage.internal.cli.TestUtils.configureValidator;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.cli.OptionValueConverter.ConverterException;\n+import jdk.jpackage.internal.cli.TestUtils.TestException;\n+import jdk.jpackage.internal.util.Result;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionValueConverterTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test(boolean positive) {\n+\n+        final var converter = OptionValueConverter.build().converter(ValueConverter.create(str -> {\n+            return Integer.valueOf(str);\n+        }, Integer.class)).mutate(configureConverter()).create();\n+\n+        if (positive) {\n+            final var token = StringToken.of(\"758\");\n+            assertEquals(758, converter.convert(OptionName.of(\"number\"), token).orElseThrow());\n+        } else {\n+            final var token = StringToken.of(\"foo\");\n+            final var result = converter.convert(OptionName.of(\"number\"), token);\n+\n+            assertEquals(1, result.errors().size());\n+\n+            final var ex = result.firstError().orElseThrow();\n+\n+            assertNotNull(ex.getCause());\n+            assertTrue(ex.getCause() instanceof NumberFormatException);\n+            assertEquals(\"Option --number: bad substring [foo] in string [foo]\", ex.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void test_Builder_defaults() {\n+\n+        var converter = OptionValueConverter.<Integer>build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class)).create();\n+\n+        Function<String, Result<Integer>> convertString = (v) -> {\n+            return converter.convert(OptionName.of(\"foo\"), StringToken.of(v));\n+        };\n+\n+        assertEquals(10, convertString.apply(\"10\").orElseThrow());\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> convertString.apply(\"\"));\n+    }\n+\n+    @Test\n+    public void test_Builder_invalid() {\n+\n+        assertThrowsExactly(NullPointerException.class, OptionValueConverter.build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .mutate(configureConverter())\n+                .formatString(null)::create);\n+\n+        assertThrowsExactly(NullPointerException.class, OptionValueConverter.build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .mutate(configureConverter())\n+                .exceptionFactory(null)::create);\n+    }\n+\n+    @Test\n+    public void test_Builder_copy() {\n+\n+        Function<String, String[]> tokenizer = _ -> { throw new UnsupportedOperationException(); };\n+\n+        var builder = OptionValueConverter.<Integer>build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .validator(Validator.<Integer, RuntimeException>build().predicate(_ -> true).create())\n+                .mutate(configureConverter())\n+                .tokenizer(tokenizer);\n+\n+        var copy = builder.copy();\n+\n+        assertNotSame(copy,  builder);\n+\n+        assertSame(builder.converter().orElse(null), copy.converter().orElse(null));\n+        assertSame(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+        assertSame(builder.exceptionFactory().orElse(null), copy.exceptionFactory().orElse(null));\n+        assertSame(builder.tokenizer().orElse(null), copy.tokenizer().orElse(null));\n+        assertSame(builder.validator().orElse(null), copy.validator().orElse(null));\n+\n+        copy.formatString(\"foo\");\n+\n+        assertNotEquals(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+    }\n+\n+    @Test\n+    public void test_Builder_createArray() {\n+\n+        var converter = OptionValueConverter.<Integer>build()\n+                .converter(ValueConverter.create(Integer::valueOf, Integer.class))\n+                .mutate(configureConverter())\n+                .tokenizer(str -> str.split(\":\"))\n+                .createArray();\n+\n+        assertNotEquals(List.of(100, 67, 145), List.of(converter.convert(OptionName.of(\"foo\"), StringToken.of(\"110:67:145\")).orElseThrow()));\n+\n+        assertEquals(Integer[].class, converter.valueType());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Builder_createArray_exceptions(boolean validateInConveter) {\n+\n+        var numberFormatException = assertThrowsExactly(NumberFormatException.class, () -> Integer.valueOf(\"str\"));\n+\n+        var builder = OptionValueConverter.<Integer>build()\n+                .mutate(configureConverter())\n+                .formatString(\"Ops\")\n+                .tokenizer(str -> str.split(\":\"));\n+\n+        if (validateInConveter) {\n+            builder.converter(ValueConverter.create(str -> {\n+                var i = Integer.valueOf(str);\n+                if (i < 0) {\n+                    throw new IllegalArgumentException(str);\n+                } else {\n+                    return i;\n+                }\n+            }, Integer.class));\n+        } else {\n+            builder.converter(ValueConverter.create(Integer::valueOf, Integer.class));\n+            builder.validator(Validator.<Integer, RuntimeException>build().consumer(i -> {\n+                if (i < 0) {\n+                    throw new IllegalArgumentException(i.toString());\n+                }\n+            }).mutate(configureValidator()).formatString(\"Ops\").create());\n+        }\n+\n+        var converter = builder.createArray();\n+\n+        var result = converter.convert(OptionName.of(\"foo\"), StringToken.of(\"100:-10:-10:67:str:145:-7\"));\n+\n+        assertExceptionListEquals(Stream.of(\n+                new IllegalArgumentException(\"-10\"),\n+                new IllegalArgumentException(\"-10\"),\n+                numberFormatException,\n+                new IllegalArgumentException(\"-7\")\n+        ).map(ex -> {\n+            return new TestException(\"Ops\", ex);\n+        }).toList(), result.errors());\n+    }\n+\n+    @Test\n+    public void testConverterException() {\n+\n+        final var exception = new RuntimeException(\"Always fail\");\n+\n+        final var converter = OptionValueConverter.build().converter(ValueConverter.create(str -> {\n+            throw exception;\n+        }, Integer.class)).mutate(configureConverter()).create();\n+\n+        final var token = StringToken.of(\"foo\");\n+        final var ex = assertThrowsExactly(ConverterException.class, () -> converter.convert(OptionName.of(\"number\"), token));\n+\n+        assertSame(exception, ex.getCause());\n+    }\n+\n+    @Test\n+    public void testValidatorExceptionTunneling() {\n+\n+        final var exception = new RuntimeException(\"Always fail\");\n+\n+        final var converter = OptionValueConverter.build().converter(ValueConverter.create(str -> {\n+            return Integer.valueOf(str);\n+        }, Object.class)).mutate(configureConverter()).validator(Validator.<Object, RuntimeException>build().predicate(_ -> {\n+            throw exception;\n+        }).mutate(configureValidator()).create()).create();\n+\n+        final var token = StringToken.of(\"100\");\n+        final var ex = assertThrowsExactly(ConverterException.class, () -> converter.convert(OptionName.of(\"number\"), token));\n+\n+        assertSame(exception, ex.getCause());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionValueConverterTest.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.cli.OptionValueExceptionFactory.StandardArgumentsMapper;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionValueExceptionFactoryTest {\n+\n+    @Test\n+    public void test_unreachable() {\n+\n+        var factory = OptionValueExceptionFactory.unreachable();\n+\n+        assertThrowsExactly(UnsupportedOperationException.class, () -> {\n+            factory.create(OptionName.of(\"foo\"), StringToken.of(\"str\"), \"\", Optional.empty());\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(StandardArgumentsMapper.class)\n+    public void testStandardArgumentsMapper(StandardArgumentsMapper mapper) {\n+\n+        final Supplier<List<String>> arguments = () -> {\n+            return List.of(mapper.apply(TEST_OPTION_NAME.name(), TEST_OPTION_VALUE));\n+        };\n+\n+        switch (mapper) {\n+            case NAME_AND_VALUE -> {\n+                assertEquals(List.of(\"foo\", \"str\"), arguments.get());\n+            }\n+            case VALUE_AND_NAME -> {\n+                assertEquals(List.of(\"str\", \"foo\"), arguments.get());\n+            }\n+            case NONE -> {\n+                assertEquals(List.of(), arguments.get());\n+            }\n+            case VALUE -> {\n+                assertEquals(List.of(\"str\"), arguments.get());\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_Builder_defaults() {\n+\n+        var factory = buildTestFactory().create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"error.parameter-not-file\", Optional.empty());\n+\n+        assertExceptionEquals(new Exception(I18N.format(\"error.parameter-not-file\", \"--foo\", \"str\")), ex);\n+    }\n+\n+    @Test\n+    public void test_Builder_formatArgumentsTransformer() {\n+\n+        var factory = buildTestFactory().formatArgumentsTransformer(StandardArgumentsMapper.VALUE_AND_NAME).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"error.parameter-not-file\", Optional.empty());\n+\n+        assertExceptionEquals(new Exception(I18N.format(\"error.parameter-not-file\", \"str\", \"--foo\")), ex);\n+    }\n+\n+    @Test\n+    public void test_Builder_messageFormatter() {\n+\n+        var factory = buildTestFactory().messageFormatter(String::format).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"The value of option %s is [%s]\", Optional.empty());\n+\n+        assertExceptionEquals(new Exception(\"The value of option --foo is [str]\"), ex);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_Builder_printOptionPrefix(boolean printOptionPrefix) {\n+\n+        var factory = buildTestFactory().printOptionPrefix(printOptionPrefix).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"error.parameter-not-file\", Optional.empty());\n+\n+        String formattedOptionName;\n+        if (printOptionPrefix) {\n+            formattedOptionName = \"--foo\";\n+        } else {\n+            formattedOptionName = \"foo\";\n+        }\n+        assertExceptionEquals(new Exception(I18N.format(\"error.parameter-not-file\", formattedOptionName, \"str\")), ex);\n+    }\n+\n+    @Test\n+    public void testWithCause() {\n+\n+        var factory = buildTestFactory().messageFormatter(String::format).create();\n+\n+        var ex = factory.create(TEST_OPTION_NAME, TEST_OPTION_VALUE, \"The value of option %s is [%s]\", Optional.of(new IllegalArgumentException(\"Ops\")));\n+\n+        assertExceptionEquals(new Exception(\"The value of option --foo is [str]\", new IllegalArgumentException(\"Ops\")), ex);\n+    }\n+\n+    @Test\n+    public void test_ArgumentsMapper_appendArguments() {\n+\n+        var maper = OptionValueExceptionFactory.ArgumentsMapper.appendArguments((formattedOptionName, optionValue) -> {\n+            return new String[] { optionValue.value(), formattedOptionName, optionValue.tokenizedString() };\n+        }, 100, \"foo\");\n+\n+        List<String> args = List.of(maper.apply(\"--bar\", StringToken.of(\"strrr\", \"tr\")));\n+\n+        assertEquals(List.of(\"tr\", \"--bar\", \"strrr\", \"100\", \"foo\"), args);\n+    }\n+\n+    private static OptionValueExceptionFactory.Builder<Exception> buildTestFactory() {\n+        return OptionValueExceptionFactory.build(Exception::new);\n+    }\n+\n+    private static final OptionName TEST_OPTION_NAME = OptionName.of(\"foo\");\n+    private static final StringToken TEST_OPTION_VALUE = StringToken.of(\"str\", \"s\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionValueExceptionFactoryTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import org.junit.jupiter.api.Test;\n+\n+public class OptionValueTest {\n+\n+    @Test\n+    public void test_asOption() {\n+\n+        assertFalse(OptionValue.create().asOption().isPresent());\n+\n+        assertTrue(build(String.class, \"foo\").create().asOption().isPresent());\n+    }\n+\n+    @Test\n+    public void test_getOption() {\n+\n+        assertThrowsExactly(NoSuchElementException.class, OptionValue.create()::getOption);\n+\n+        assertNotNull(build(String.class, \"foo\").create().getOption());\n+    }\n+\n+    @Test\n+    public void test_getSpec() {\n+\n+        assertThrowsExactly(NoSuchElementException.class, OptionValue.create()::getSpec);\n+\n+        assertNotNull(build(String.class, \"foo\").create().getSpec());\n+    }\n+\n+    @Test\n+    public void test_getName() {\n+\n+        assertThrowsExactly(NoSuchElementException.class, OptionValue.create()::getName);\n+\n+        assertEquals(\"foo\", build(String.class, \"foo\").create().getName());\n+    }\n+\n+    @Test\n+    public void test_ifPresentIn() {\n+\n+        var option = build(String.class, \"foo\").create();\n+\n+        String value[] = new String[1];\n+\n+        option.ifPresentIn(EMPTY_OPTIONS, _ -> {\n+            throw new AssertionError();\n+        });\n+\n+        assertNull(value[0]);\n+\n+        option.ifPresentIn(Options.of(Map.of(option, \"bar\")), v -> {\n+            value[0] = v;\n+        });\n+\n+        assertEquals(\"bar\", value[0]);\n+    }\n+\n+    @Test\n+    public void test_containsIn() {\n+        test_containsIn(OptionValue.create());\n+        test_containsIn(OptionValue.<Integer>build().defaultValue(45).create());\n+        test_containsIn(build(Path[].class, \"foo\").create());\n+    }\n+\n+    @Test\n+    public void test_Builder_build() {\n+\n+        var builder = OptionValue.<Integer>build();\n+\n+        var a = builder.create();\n+        var b = builder.create();\n+\n+        assertNotNull(a.id());\n+        assertTrue(a.asOption().isEmpty());\n+\n+        assertNotNull(b.id());\n+        assertTrue(b.asOption().isEmpty());\n+\n+        assertNotEquals(a.id(), b.id());\n+        assertEquals(a.id().getClass(), b.id().getClass());\n+    }\n+\n+    @Test\n+    public void test_Builder_defaultValue() {\n+\n+        var option = OptionValue.<Integer>build().defaultValue(100).create();\n+\n+        assertEquals(100, option.getFrom(EMPTY_OPTIONS));\n+\n+        assertEquals(300, option.getFrom(Options.of(Map.of(option, 300))));\n+    }\n+\n+    @Test\n+    public void test_Builder_defaultValue_withSpec() {\n+\n+        var option = OptionValue.<Integer>build().defaultValue(100)\n+                .spec(build(Integer.class, \"foo\").createOptionSpec())\n+                .create();\n+\n+        assertEquals(100, option.getFrom(EMPTY_OPTIONS));\n+\n+        assertEquals(300, option.getFrom(Options.of(Map.of(option, 300))));\n+    }\n+\n+    @Test\n+    public void test_Builder_from() {\n+\n+        var option = OptionValue.<Integer>build().from(OptionValue.<String>create(), Integer::valueOf).create();\n+\n+        assertFalse(option.containsIn(EMPTY_OPTIONS));\n+\n+        assertEquals(300, option.getFrom(Options.of(Map.of(option, \"300\"))));\n+    }\n+\n+    @Test\n+    public void test_Builder_to() {\n+\n+        var listOption = OptionValue.build().to(List::of).create();\n+\n+        assertFalse(listOption.containsIn(EMPTY_OPTIONS));\n+\n+        assertEquals(List.of(300), listOption.getFrom(Options.of(Map.of(listOption, 300))));\n+    }\n+\n+    @Test\n+    public void test_Builder_to_fromAnotherOption() {\n+\n+        var option = OptionValue.<String>build().from(OptionValue.<String>create(), x -> x).defaultValue(\"abc\").create();\n+\n+        OptionValue<List<String>> listOption = OptionValue.<String>build().from(option, x -> x).to(List::of).create();\n+\n+        assertSame(option.id(), listOption.id());\n+        assertFalse(listOption.containsIn(EMPTY_OPTIONS));\n+\n+        assertEquals(List.of(\"abc\"), listOption.getFrom(EMPTY_OPTIONS));\n+        assertEquals(\"abc\", option.getFrom(EMPTY_OPTIONS));\n+\n+        var options = Options.of(Map.of(option, \"Hello\"));\n+\n+        assertEquals(List.of(\"Hello\"), listOption.getFrom(options));\n+        assertEquals(\"Hello\", option.getFrom(options));\n+    }\n+\n+    @Test\n+    public void testContainsPathArray() {\n+\n+        OptionValue<String> option = build(String.class, \"foo\").create();\n+\n+        var options = Options.of(Map.of(option, new Object()));\n+\n+        \/\/ OptionValue.contains() should work regardless the type of its value stored in Options object.\n+        assertTrue(option.containsIn(options));\n+\n+        \/\/ Attempt to find a value will fail if the value is of incompatible type.\n+        assertThrowsExactly(ClassCastException.class, () -> option.getFrom(options).length());\n+    }\n+\n+    private static void test_containsIn(OptionValue<?> option) {\n+        Objects.requireNonNull(option);\n+\n+        var anotherOption = OptionValue.create();\n+\n+        assertFalse(option.containsIn(EMPTY_OPTIONS));\n+        assertFalse(option.containsIn(Options.of(Map.of(anotherOption, \"\"))));\n+\n+        assertTrue(option.containsIn(Options.of(Map.of(option, new int[10]))));\n+        assertTrue(option.containsIn(Options.of(Map.of(option, new Object()))));\n+    }\n+\n+    private static <T> OptionSpecBuilder<T> build(Class<? extends T> type, String name) {\n+        return OptionSpecBuilder.<T>create(type).name(Objects.requireNonNull(name)).scope(new OptionScope() {});\n+    }\n+\n+    private static final Options EMPTY_OPTIONS = Options.of(Map.of());\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionValueTest.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,786 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionListEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.StandardOption.AddLauncherInvalidPropertyFileException;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.JUnitUtils;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionsProcessorTest {\n+\n+    @Test\n+    public void test_processPropertyFile(@TempDir Path workDir) throws IOException {\n+        final var propFile = workDir.resolve(\"launcher.properties\");\n+        Files.write(propFile, List.of(\"description=bar\", \"type=msi\"));\n+\n+        final var result = processPropertyFile(propFile,\n+                StandardOption.TYPE, StandardOption.DESCRIPTION);\n+\n+        assertTrue(result.hasValue());\n+\n+        assertEquals(StandardPackageType.WIN_MSI, StandardOption.TYPE.getFrom(result.orElseThrow()));\n+        assertEquals(\"bar\", StandardOption.DESCRIPTION.getFrom(result.orElseThrow()));\n+\n+        assertFalse(StandardOption.INPUT.containsIn(result.orElseThrow()));\n+\n+        assertEquals(propFile, StandardOption.SOURCE_PROPERY_FILE.getFrom(result.orElseThrow()));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(BooleanProperty.class)\n+    public void test_processPropertyFile_Boolean(BooleanProperty value, @TempDir Path workDir) throws IOException {\n+        final var propFile = workDir.resolve(\"launcher.properties\");\n+        Files.write(propFile, List.of(\"launcher-as-service=\" + value.propertyValue()));\n+\n+        final var props = processPropertyFile(propFile,\n+                StandardOption.LAUNCHER_AS_SERVICE).orElseThrow();\n+\n+        assertEquals(value.expectedValue(), StandardOption.LAUNCHER_AS_SERVICE.getFrom(props));\n+    }\n+\n+    @Test\n+    public void testMandatoryOptionsPresent(@TempDir Path workDir) {\n+        build().createAppImageByDefault().withMockupMainJar(workDir).createBundleCallback(cmdline -> {\n+            assertEquals(List.of(), StandardOption.ADDITIONAL_LAUNCHERS.getFrom(cmdline));\n+            assertEquals(List.of(), StandardOption.FILE_ASSOCIATIONS.getFrom(cmdline));\n+        }).create().execute();\n+    }\n+\n+    @Test\n+    public void testAdditionLauncher(@TempDir Path workDir) throws IOException {\n+\n+        final var propFile = workDir.resolve(\"launcher.properties\");\n+        Files.write(propFile, List.of(\"arguments=a b c\"));\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).createBundleCallback(cmdline -> {\n+            assertFalse(StandardOption.ADD_LAUNCHER_INTERNAL.containsIn(cmdline));\n+\n+            var addLaunchers = StandardOption.ADDITIONAL_LAUNCHERS.getFrom(cmdline);\n+            assertEquals(1, addLaunchers.size());\n+\n+            var addLauncher = addLaunchers.getFirst();\n+\n+            assertEquals(\"foo\", StandardOption.NAME.getFrom(addLauncher));\n+            assertEquals(propFile, StandardOption.SOURCE_PROPERY_FILE.getFrom(addLauncher));\n+            assertEquals(List.of(\"a\", \"b\", \"c\"), StandardOption.ARGUMENTS.getFrom(addLauncher));\n+\n+        }).create(\"--add-launcher\", \"foo=\" + propFile).execute();\n+    }\n+\n+    @Test\n+    public void testFa(@TempDir Path workDir) throws IOException {\n+\n+        final var propFile = workDir.resolve(\"fa.properties\");\n+        Files.write(propFile, List.of(\"description=Hello\"));\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).createBundleCallback(cmdline -> {\n+            assertFalse(StandardOption.FILE_ASSOCIATIONS_INTERNAL.containsIn(cmdline));\n+\n+            var fas = StandardOption.FILE_ASSOCIATIONS.getFrom(cmdline);\n+            assertEquals(1, fas.size());\n+\n+            var fa = fas.getFirst();\n+\n+            assertEquals(\"Hello\", StandardFaOption.DESCRIPTION.getFrom(fa));\n+            assertEquals(propFile, StandardOption.SOURCE_PROPERY_FILE.getFrom(fa));\n+\n+        }).create(\"--file-associations=\" + propFile).execute();\n+    }\n+\n+    \/**\n+     * Test that it fails if there are \"non-option\" arguments on the command line.\n+     *\/\n+    @Test\n+    public void testNonOptionArgumntsError(@TempDir Path workDir) {\n+\n+        build()\n+        .withDefaultBundlingOperation(true)\n+        .createAppImageBundlingOperation()\n+        .expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.non-option-arguments\", 1)),\n+                new JPackageException(I18N.format(\"ERR_NoEntryPoint\"))\n+        ).create(\"foo\").validate();\n+\n+        build()\n+        .createAppImageBundlingOperation()\n+        .expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.non-option-arguments\", 3)),\n+                new JPackageException(I18N.format(\"ERR_NoEntryPoint\"))\n+        ).create(\"some\", \"-t\", \"app-image\", \"foo\", \"bar\", \"--dest\", \"dir\").validate();\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when `--type` option is missing and the\n+     * bundling environment doesn't have the default bundling operation.\n+     *\/\n+    @Test\n+    public void testNoDefaultBundlingOperation() {\n+        build().expectValidationErrors(\n+                new ConfigException(\n+                        I18N.format(\"error.undefined-default-bundling-operation\"),\n+                        I18N.format(\"error.undefined-default-bundling-operation.advice\", \"--type\")\n+                )\n+        ).create().validate();\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when `--type` option is missing and the\n+     * default bundling operation of the bundling environment is unrecognizable.\n+     *\/\n+    @Test\n+    public void testUnknownDefaultBundlingOperation() {\n+        var descriptor = new BundlingOperationDescriptor(OperatingSystem.current(), \"foo\", \"create\");\n+\n+        var err = assertThrowsExactly(AssertionError.class, build().withDefaultBundlingOperation(true)\n+                .bundlingOperation(descriptor)\n+                .create()::validate);\n+\n+        assertEquals(String.format(\"None of the standard bundling operations match bundling operation descriptor [%s]\", descriptor), err.getMessage());\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when the value of `--type` option is a valid\n+     * bundle type but unsupported by the bundling environment.\n+     *\/\n+    @Test\n+    public void testUnsupportedBundlingOperation() {\n+        var err = new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", \"msi\"));\n+        build().createAppImageByDefault().expectBundlingEnvironmentConfigurationErrors(err)\n+                .expectValidationErrors(err)\n+                .create(\"-t\", \"msi\").validate();\n+    }\n+\n+    \/**\n+     * Test that it fails as expected when the value of `--type` option is unrecognizable.\n+     *\/\n+    @Test\n+    public void testUnknownBundlingOperation() {\n+        var err = new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", \"foo\"), new IllegalArgumentException());\n+        build().createAppImageByDefault().expectBundlingEnvironmentConfigurationErrors(err)\n+                .expectValidationErrors(err)\n+                .create(\"-t\", \"foo\").validate();\n+    }\n+\n+    \/**\n+     * Test that the error occurred at the bundling phase is propagated as expected.\n+     *\/\n+    @Test\n+    public void testBundlingOperationError(@TempDir Path workDir) {\n+        var validator = build().createAppImageByDefault().createBundleCallback(_ -> {\n+            throw new RuntimeException(\"No bundling for you\");\n+        }).withMockupMainJar(workDir).create();\n+\n+        var validatedOptions = validator.validate().orElseThrow();\n+\n+        assertExceptionListEquals(List.of(new RuntimeException(\"No bundling for you\")), validator.runBundling(validatedOptions));\n+    }\n+\n+    \/**\n+     * Test that internal errors that occur when configuring bundlers in the\n+     * bundling environment are reported as expected.\n+     *\/\n+    @Test\n+    public void testBundlingOperationConfigurationErrors(@TempDir Path workDir) {\n+        build().createAppImageByDefault()\n+                .expectBundlingEnvironmentConfigurationErrors(\n+                        new UnsupportedOperationException(\"Ops\"),\n+                        new Exception(\"Yikes\"),\n+                        new NoSuchElementException(\"Goofy\")\n+                )\n+                .expectValidationErrors(\n+                        new UnsupportedOperationException(\"Ops\"),\n+                        new Exception(\"Yikes\"),\n+                        new NoSuchElementException(\"Goofy\")\n+                )\n+                .withMockupMainJar(workDir).create().validate();\n+    }\n+\n+    \/**\n+     * Test that the options analyzer can detect and report multiple errors in\n+     * untyped command line values.\n+     * <p>\n+     * Options analyzer examines command line options without accessing their values\n+     * as converters have not been run on them yet. At this phase the analyzer can\n+     * detect the type of a bundling operation, test if specific option is on the\n+     * command line or not and analyze if specific combinations of options are\n+     * valid.\n+     *\/\n+    @Test\n+    public void testMultipleCommandLineStructureAnalyzerErrors() {\n+        build().createAppImageByDefault().expectValidationErrors(\n+                new JPackageException(I18N.format(\"ERR_MutuallyExclusiveOptions\", \"-m\", \"--main-jar\")),\n+                new JPackageException(I18N.format(\"ERR_MissingArgument2\", \"--runtime-image\", \"--module-path\")),\n+                new JPackageException(I18N.format(\"error.no-input-parameter\"))\n+        ).validationErrorsOrdered(false).create(\"-m\", \"com.foo\", \"--main-jar\", \"main.jar\").validate();\n+    }\n+\n+    \/**\n+     * Test that options analyzer can detect and report multiple errors in typed\n+     * command line values.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testTypedOptionValuesAnalyzerErrors(boolean expectError, @TempDir Path workDir) {\n+        var builder = build().platform(OperatingSystem.MACOS).withMockupMainJar(workDir).createAppImageByDefault();\n+\n+        if (expectError) {\n+            builder.expectValidationErrors(\n+                    new JPackageException(I18N.format(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"))\n+            )\n+            .create(\"--mac-app-store\", \"--jlink-options=\").validate();\n+        } else {\n+            builder.create(\"--mac-app-store\", \"--jlink-options\", \"--strip-debug --strip-native-commands\").validate();\n+        }\n+    }\n+\n+    \/**\n+     * Test that multiple converter\/validator errors are in the same order as\n+     * erroneous options on the command line.\n+     *\/\n+    @Test\n+    public void testMultipleOptionValueConverterErrors(@TempDir Path workDir) {\n+        build().createAppImageByDefault().expectValidationErrors(\n+                \/\/ --i\n+                new JPackageException(I18N.format(\"error.parameter-not-directory\", workDir.resolve(\"non-existent\"), \"-i\")),\n+                \/\/ --name\n+                new JPackageException(I18N.format(\"ERR_InvalidAppName\", \"He\/llo\"))\n+        )\n+        .create(\"--main-jar=foo.jar\", \"-i\", workDir.resolve(\"non-existent\"), \"--name=He\/llo\").validate();\n+\n+        build().createAppImageByDefault().expectValidationErrors(\n+                \/\/ --name\n+                new JPackageException(I18N.format(\"ERR_InvalidAppName\", \"He\/llo\")),\n+                \/\/ --i\n+                new JPackageException(I18N.format(\"error.parameter-not-directory\", workDir.resolve(\"non-existent\"), \"-i\"))\n+        )\n+        .create(\"--main-jar=foo.jar\", \"--name=He\/llo\", \"-i\", workDir.resolve(\"non-existent\")).validate();\n+    }\n+\n+    @Test\n+    public void testMultipleErrors(@TempDir Path workDir) throws IOException {\n+\n+        final var invalidPropertyFile = workDir.resolve(\"invalid.properties\");\n+\n+        try (var writer = Files.newBufferedWriter(invalidPropertyFile)) {\n+            var props = new Properties();\n+            props.setProperty(\"icon\", workDir.toString());\n+            props.store(writer, null);\n+        }\n+\n+        build().createAppImageByDefault()\n+        .expectBundlingEnvironmentConfigurationErrors(\n+                new UnsupportedOperationException(\"Ops\"),\n+                new Exception(\"Yikes\"),\n+                new NoSuchElementException(\"Goofy\")\n+        )\n+        .expectValidationErrors(\n+                new UnsupportedOperationException(\"Ops\"),\n+                new Exception(\"Yikes\"),\n+                new NoSuchElementException(\"Goofy\"),\n+                new JPackageException(I18N.format(\"error.properties-parameter-not-file\", workDir, \"icon\", invalidPropertyFile)),\n+                new JPackageException(I18N.format(\"error.parameter-not-directory\", workDir.resolve(\"non-existent\"), \"-i\")),\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\"))\n+        )\n+        .withMockupMainJar(workDir).create(\"--add-launcher=a=\" + invalidPropertyFile, \"--name=a\", \"-i\", workDir.resolve(\"non-existent\")).validate();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1})\n+    public void testMultipleErrors2(int testType, @TempDir Path workDir) throws IOException {\n+\n+        List<String> badOptions;\n+        switch (testType) {\n+            case 0 -> {\n+                badOptions = List.of(\"--linux-shortcut\", \"--win-console\");\n+            }\n+            case 1 -> {\n+                badOptions = List.of(\"--win-console\", \"--linux-shortcut\");\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        var builder = build().os(OperatingSystem.WINDOWS)\n+                .bundlingOperation(StandardBundlingOperation.CREATE_WIN_MSI.descriptor())\n+                .expectValidationErrors(new JPackageException(I18N.format(\"ERR_InvalidInstallerType\", \"dmg\")));\n+\n+        for (var badOption : badOptions) {\n+            builder.expectValidationErrors(new JPackageException(I18N.format(\"ERR_UnsupportedOption\", badOption)));\n+        }\n+\n+        List<Object> args = new ArrayList<>(List.of(\"-t\", \"dmg\", \"-i\", workDir.resolve(\"non-existent\")));\n+        args.addAll(badOptions);\n+        args.addAll(List.of(\"--mac-package-name\", \"foo\"));\n+        builder.create(args).validate();\n+    }\n+\n+    @Test\n+    public void testMultipleErrors3(@TempDir Path workDir) throws IOException {\n+\n+        build().os(OperatingSystem.WINDOWS)\n+                .bundlingOperation(StandardBundlingOperation.CREATE_WIN_MSI.descriptor())\n+                .withDefaultBundlingOperation(true)\n+                .expectValidationErrors(\n+                        new JPackageException(I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\")),\n+                        new JPackageException(I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\")),\n+                        new JPackageException(I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\"))\n+                )\n+                .create(\"-i\", workDir.resolve(\"non-existent\"), \"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"--linux-menu-group\", \"grp\").validate();\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2})\n+    public void testMultipleErrors4(int testType, @TempDir Path workDir) throws IOException {\n+\n+        List<String> args;\n+        List<String> expectedErrors = null;\n+\n+        switch (testType) {\n+            case 0 -> {\n+                args = List.of(\"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"-p\", \"m1\", \"--linux-menu-group\", \"grp\", \"-p\", \"m2\", \"--app-image\", \"foo\");\n+                expectedErrors = List.of(\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\"),\n+                        I18N.format(\"ERR_InvalidTypeOption\", \"-p\", \"msi\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\")\n+                );\n+            }\n+            case 1 -> {\n+                args = List.of(\"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"--module-path\", \"m1\", \"--linux-menu-group\", \"grp\", \"-p\", \"m2\", \"--app-image\", \"foo\");\n+                expectedErrors = List.of(\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\"),\n+                        I18N.format(\"ERR_InvalidTypeOption\", \"--module-path\", \"msi\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\")\n+                );\n+            }\n+            case 2 -> {\n+                args = List.of(\"--linux-shortcut\", \"--mac-package-name\", \"foo\", \"-p\", \"m1\", \"--linux-menu-group\", \"grp\", \"--module-path\", \"m2\", \"--app-image\", \"foo\");\n+                expectedErrors = List.of(\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-shortcut\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--mac-package-name\"),\n+                        I18N.format(\"ERR_InvalidTypeOption\", \"--module-path\", \"msi\"),\n+                        I18N.format(\"ERR_UnsupportedOption\", \"--linux-menu-group\")\n+                );\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        build().os(OperatingSystem.WINDOWS)\n+                .withDefaultBundlingOperation(true)\n+                .bundlingOperation(StandardBundlingOperation.CREATE_WIN_MSI.descriptor())\n+                .expectValidationErrors(expectedErrors.stream().map(JPackageException::new).toList())\n+                .create(args.toArray()).validate();\n+    }\n+\n+\n+    \/**\n+     * Test that it will collect all errors when processing multiple property files\n+     * for additional launchers.\n+     *\/\n+    @Test\n+    @EnabledOnOs(value = OS.WINDOWS, disabledReason = \"Can reliably lock a file using FileLock to cuase an IOException on Windows only\")\n+    @SuppressWarnings(\"try\")\n+    public void testMultipleAddLauncherErrors(@TempDir Path workDir) throws IOException {\n+\n+        final var lockedPropertyFile = workDir.resolve(\"locked.properties\");\n+        Files.write(lockedPropertyFile, List.of(\"\"));\n+\n+        final var invalidPropertyFile = workDir.resolve(\"invalid.properties\");\n+        Files.write(invalidPropertyFile, List.of(\"icon=*.png\"));\n+\n+        final var nonExistentPropertyFile = workDir.resolve(\"non-existent.properties\");\n+\n+        try (var out = new FileOutputStream(lockedPropertyFile.toFile()); var lock = out.getChannel().lock()) {\n+\n+            final IOException lockedException = assertThrowsExactly(IOException.class, () -> {\n+                Files.readAllBytes(lockedPropertyFile);\n+            });\n+\n+            build().createAppImageByDefault().expectValidationErrors(\n+                    \/\/ --name=Hello*\n+                    new JPackageException(I18N.format(\"ERR_InvalidAppName\", \"Hello*\")),\n+\n+                    \/\/ --i \"non-existent\"\n+                    new JPackageException(I18N.format(\"error.parameter-not-directory\", workDir.resolve(\"non-existent\"), \"-i\")),\n+\n+                    \/\/ --main-jar=?.jar\n+                    new JPackageException(I18N.format(\"error.parameter-not-path\", \"?.jar\", \"--main-jar\"), new IllegalArgumentException()),\n+\n+                    \/\/ icon=*.png in \"invalid.properties\"\n+                    new JPackageException(I18N.format(\"error.properties-parameter-not-path\", \"*.png\", \"icon\", invalidPropertyFile), new IllegalArgumentException()),\n+\n+                    \/\/ \"locked.properties\"\n+                    lockedException,\n+\n+                    \/\/ \"non-existent.properties\"\n+                    new AddLauncherInvalidPropertyFileException(I18N.format(\"error.parameter-add-launcher-not-file\", nonExistentPropertyFile, \"b\")),\n+\n+                    new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"b\"))\n+            )\n+            .create(\"--name=Hello*\", \"-i\", workDir.resolve(\"non-existent\"), \"--main-jar=?.jar\",\n+                    \"--add-launcher\", \"a=\" + invalidPropertyFile,\n+                    \"--add-launcher\", \"b=\" + lockedPropertyFile,\n+                    \"--add-launcher\", \"b=\" + nonExistentPropertyFile).validate();\n+        }\n+    }\n+\n+    @Test\n+    public void testDuplicateAddLauncherErrors(@TempDir Path workDir) throws IOException {\n+\n+        final var propertyFile = workDir.resolve(\"foo.properties\");\n+        Files.write(propertyFile, List.of(\"\"));\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\"))\n+        )\n+        .create(\"--name=a\", \"--add-launcher=a=\" + propertyFile).validate();\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\"))\n+        )\n+        .create(\"--name=a\", \"--add-launcher=a=\" + propertyFile, \"--add-launcher=a=\" + propertyFile, \"--add-launcher=a=\" + propertyFile).validate();\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\")),\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"b\"))\n+        )\n+        .create(\"-name=c\",\n+                \"--add-launcher=a=\" + propertyFile,\n+                \"--add-launcher=b=\" + propertyFile,\n+                \"--add-launcher=a=\" + propertyFile,\n+                \"--add-launcher=b=\" + propertyFile).validate();\n+\n+        build().createAppImageByDefault().withMockupMainJar(workDir).expectValidationErrors(\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"a\")),\n+                new JPackageException(I18N.format(\"error.launcher-duplicate-name\", \"b\"))\n+        )\n+        .create(\"-name=c\",\n+                \"--add-launcher=b=\" + propertyFile,\n+                \"--add-launcher=a=\" + propertyFile,\n+                \"--add-launcher=b=\" + propertyFile,\n+                \"--add-launcher=a=\" + propertyFile).validate();\n+    }\n+\n+    enum BooleanProperty {\n+\n+        TRUE(\"true\", true),\n+        TRUE_UPPERCASE_FIRST(\"True\", true),\n+        TRUE_UPPERCASE_ALL(\"TRUE\", true),\n+        TRUE_UPPERCASE_LAST(\"truE\", true),\n+        TRUE_UPPERCASE_MIDDLE(\"tRUe\", true),\n+        FALSE(\"false\", false),\n+        FALSE_UPPERCASE(\"FALSE\", false),\n+        EMPTY(\"\", false),\n+        RANDOM(\"foo\", false),\n+        TRUELISH(\"truee\", false),\n+        FALSEISH(\"fals\", false),\n+        ;\n+\n+        BooleanProperty(String propertyValue, boolean expectedValue) {\n+            this.propertyValue = Objects.requireNonNull(propertyValue);\n+            this.expectedValue = Objects.requireNonNull(expectedValue);\n+        }\n+\n+        String propertyValue() {\n+            return propertyValue;\n+        }\n+\n+        boolean expectedValue() {\n+            return expectedValue;\n+        }\n+\n+        private final String propertyValue;\n+        private final boolean expectedValue;\n+    }\n+\n+    private static Result<Options> processPropertyFile(Path propFile, OptionValue<?>... options) {\n+        return OptionsProcessor.processPropertyFile(propFile,\n+                Stream.of(options).map(OptionValue::getOption).toList(),\n+                Optional.of(spec -> {\n+                    return new StandardOptionContext(OperatingSystem.current()).forFile(propFile).mapOptionSpec(spec);\n+                }));\n+    }\n+\n+    private static OptionsProcessorValidatorBuilder build() {\n+        return new OptionsProcessorValidatorBuilder();\n+    }\n+\n+\n+    private record OptionsProcessorValidator(\n+            OptionsProcessor optionsProcessor,\n+            CreateBundleCallbackRecorder recorder,\n+            Collection<Map<String, Object>> expectedValidationErrors) {\n+\n+        OptionsProcessorValidator {\n+            Objects.requireNonNull(optionsProcessor);\n+            Objects.requireNonNull(recorder);\n+            Objects.requireNonNull(expectedValidationErrors);\n+        }\n+\n+        Result<OptionsProcessor.ValidatedOptions> validate() {\n+            var curExecutedCounter = recorder.executedCounter();\n+\n+            var result = optionsProcessor.validate();\n+\n+            \/\/ Assert validation doesn't trigger bundling.\n+            assertEquals(curExecutedCounter, recorder.executedCounter());\n+\n+            var errors = result.errors().stream().map(JUnitUtils::exceptionAsPropertyMap).map(propertyMap -> {\n+                \/\/ Don't dive into the cause chain, stop at the first one.\n+                Optional.ofNullable(propertyMap.get(\"getCause\")).ifPresent(causePropertyMap -> {\n+                    ((Map<?, ?>)causePropertyMap).remove(\"getCause\");\n+                    ((Map<?, ?>)causePropertyMap).remove(\"getMessage\");\n+                });\n+                return propertyMap;\n+            }).toList();\n+            if (expectedValidationErrors instanceof Set<?>) {\n+                assertEquals(expectedValidationErrors, Set.copyOf(errors));\n+            } else {\n+                assertEquals(expectedValidationErrors, errors);\n+            }\n+\n+            return result;\n+        }\n+\n+        Collection<? extends Exception> runBundling(OptionsProcessor.ValidatedOptions validatedOptions) {\n+            var curExecutedCounter = recorder.executedCounter();\n+\n+            var result = optionsProcessor.runBundling(validatedOptions);\n+\n+            assertEquals(curExecutedCounter + 1, recorder.executedCounter());\n+\n+            return result;\n+        }\n+\n+        void execute() {\n+            var exceptions = runBundling(validate().orElseThrow());\n+\n+            for (var ex : exceptions) {\n+                ex.printStackTrace();\n+            }\n+\n+            assertEquals(List.of(), exceptions);\n+        }\n+    }\n+\n+\n+    private static final class CreateBundleCallbackRecorder implements Consumer<Options> {\n+\n+        CreateBundleCallbackRecorder(Optional<Consumer<Options>> callback) {\n+            this.callback = Objects.requireNonNull(callback);\n+        }\n+\n+        @Override\n+        public void accept(Options cmdline) {\n+            executedCounter++;\n+            callback.ifPresent(c -> c.accept(cmdline));\n+        }\n+\n+        int executedCounter() {\n+            return executedCounter;\n+        }\n+\n+        private final Optional<Consumer<Options>> callback;\n+        private int executedCounter;\n+    }\n+\n+\n+    private static final class OptionsProcessorValidatorBuilder {\n+\n+        OptionsProcessorValidator create(Object... args) {\n+            return create(List.of(args));\n+        }\n+\n+        OptionsProcessorValidator create(Iterable<Object> args) {\n+\n+            var stringArgs = Stream.concat(\n+                    baseArgs.stream(),\n+                    StreamSupport.stream(args.spliterator(), false).map(Object::toString)\n+            ).toArray(String[]::new);\n+\n+            var recorder = new CreateBundleCallbackRecorder(createBundleCallback());\n+\n+            CliBundlingEnvironment bundlingEnv = bundlingEnvironmentBuilder.createBundleCallback(recorder).create();\n+\n+            var optionsBuilder = Utils.buildParser(os, bundlingEnv).create().apply(stringArgs).orElseThrow();\n+\n+            var op = new OptionsProcessor(optionsBuilder, bundlingEnv);\n+\n+            Collection<Map<String, Object>> errors;\n+            if (expectedValidationErrorsOrdered) {\n+                errors = expectedValidationErrors.stream().map(JUnitUtils::exceptionAsPropertyMap).toList();\n+            } else {\n+                errors = expectedValidationErrors.stream().map(JUnitUtils::exceptionAsPropertyMap).collect(Collectors.toSet());\n+            }\n+\n+            return new OptionsProcessorValidator(op, recorder, errors);\n+        }\n+\n+        OptionsProcessorValidatorBuilder args(Iterable<Object> v) {\n+            StreamSupport.stream(v.spliterator(), false).map(Object::toString).forEach(baseArgs::add);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder args(Object... args) {\n+            return args(List.of(args));\n+        }\n+\n+        OptionsProcessorValidatorBuilder os(OperatingSystem v) {\n+            os = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder withMockupMainJar(Path inputDir) {\n+\n+            try {\n+                Files.write(inputDir.resolve(\"mockup.jar\"), new byte[] {});\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+\n+            return args(\"--input\", inputDir, \"--main-jar\", \"mockup.jar\");\n+        }\n+\n+        OptionsProcessorValidatorBuilder withDefaultBundlingOperation(boolean v) {\n+            withDefaultBundlingOperation = v;\n+            if (withDefaultBundlingOperation) {\n+                bundlingEnvironmentBuilder.defaultOperation(bundlingOperation);\n+            } else {\n+                bundlingEnvironmentBuilder.defaultOperation(null);\n+            }\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder bundlingOperation(BundlingOperationDescriptor v) {\n+            bundlingOperation = Objects.requireNonNull(v);\n+            bundlingEnvironmentBuilder.knownOperation(bundlingOperation);\n+            withDefaultBundlingOperation(withDefaultBundlingOperation);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder createAppImageBundlingOperation() {\n+            return bundlingOperation(MockupCliBundlingEnvironment.createAppImageBundlingOperation(os).descriptor());\n+        }\n+\n+        OptionsProcessorValidatorBuilder createAppImageByDefault() {\n+            return createAppImageBundlingOperation().withDefaultBundlingOperation(true);\n+        }\n+\n+        OptionsProcessorValidatorBuilder platform(OperatingSystem v) {\n+            os = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder createBundleCallback(Consumer<Options> v) {\n+            createBundleCallback = v;\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectValidationErrors(Iterable<? extends Exception> v) {\n+            v.forEach(this::expectValidationError);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectValidationError(Exception v) {\n+\n+            if (expectedValidationErrors.stream().anyMatch(err -> {\n+                return err.getMessage().equals(v.getMessage());\n+            })) {\n+                throw new IllegalArgumentException(String.format(\"Error message [%s] already expected\", v.getMessage()));\n+            }\n+            expectedValidationErrors.add(v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectValidationErrors(Exception... errors) {\n+            return expectValidationErrors(List.of(errors));\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectBundlingEnvironmentConfigurationErrors(List<Exception> v) {\n+            bundlingEnvironmentBuilder.configurationErrors(bundlingOperation, v);\n+            return this;\n+        }\n+\n+        OptionsProcessorValidatorBuilder expectBundlingEnvironmentConfigurationErrors(Exception... errors) {\n+            return expectBundlingEnvironmentConfigurationErrors(List.of(errors));\n+        }\n+\n+        OptionsProcessorValidatorBuilder validationErrorsOrdered(boolean v) {\n+            expectedValidationErrorsOrdered = v;\n+            return this;\n+        }\n+\n+        private Optional<Consumer<Options>> createBundleCallback() {\n+            return Optional.ofNullable(createBundleCallback);\n+        }\n+\n+        private final List<String> baseArgs = new ArrayList<>();\n+        private BundlingOperationDescriptor bundlingOperation;\n+        private OperatingSystem os = OperatingSystem.current();\n+        private boolean withDefaultBundlingOperation;\n+        private final List<Exception> expectedValidationErrors = new ArrayList<>();\n+        private Consumer<Options> createBundleCallback;\n+        private boolean expectedValidationErrorsOrdered = true;\n+        private final MockupCliBundlingEnvironment.Builder bundlingEnvironmentBuilder = MockupCliBundlingEnvironment.build();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsProcessorTest.java","additions":786,"deletions":0,"binary":false,"changes":786,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.ExpectedOptions.expectOptions;\n+import static jdk.jpackage.internal.cli.OptionIdentifier.createIdentifier;\n+import static jdk.jpackage.internal.cli.WithOptionIdentifier.stub;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class OptionsTest {\n+\n+    @Test\n+    public void test_ofIDs() {\n+        var fooID = createIdentifier();\n+        var barID = createIdentifier();\n+        var buzID = createIdentifier();\n+\n+        var options = Options.ofIDs(Map.of(fooID, \"Hello\", barID, 100));\n+\n+        expectOptions().add(fooID, \"Hello\").add(barID, 100).apply(options);\n+        assertFalse(options.find(buzID).isPresent());\n+    }\n+\n+    @Test\n+    public void test_of_duplicate_id() {\n+        var withId = stub(createIdentifier());\n+        var barO = dummyOption(\"bar\");\n+        var barOV = OptionValue.build().spec(dummyOptionSpec(\"another-bar\")).id(barO.id()).create();\n+\n+        assertThrowsExactly(IllegalStateException.class, () -> {\n+            Options.of(Map.of(withId, \"Hello\", barO, 100, barOV, \"Bye\"));\n+        });\n+    }\n+\n+    @Test\n+    public void test_of() {\n+        var withId = stub(createIdentifier());\n+        var bar = dummyOption(\"bar\");\n+        var buz = OptionValue.build().spec(dummyOptionSpec(\"another-bar\")).create();\n+\n+        var options = Options.of(Map.of(withId, \"Hello\", bar, 100, buz, \"Bye\"));\n+\n+        expectOptions().add(withId.id(), \"Hello\").add(bar, 100).add(buz, \"Bye\").apply(options);\n+    }\n+\n+    @Test\n+    public void test_of_empty() {\n+        var options = Options.of(Map.of());\n+\n+        assertFalse(options.contains(createIdentifier()));\n+\n+        var barID = dummyOption(\"bar\");\n+        assertFalse(options.contains(barID));\n+        assertFalse(options.contains(barID.spec().name()));\n+    }\n+\n+    @Test\n+    public void test_of_Option() {\n+        var fooID = createIdentifier();\n+        var barID = dummyOption(\"bar\");\n+        var buzID = createIdentifier();\n+\n+        var options = Options.of(Map.of(stub(fooID), \"Hello\", barID, 100));\n+\n+        expectOptions().add(fooID, \"Hello\").add(barID, 100).apply(options);\n+        assertFalse(options.find(buzID).isPresent());\n+        assertFalse(options.contains(OptionName.of(\"foo\")));\n+    }\n+\n+    @Test\n+    public void test_toMap() {\n+        var idA = createIdentifier();\n+        var idB = createIdentifier();\n+\n+        var a = Options.ofIDs(Map.of(idA, \"Foo\", idB, true));\n+        var b = Options.concat(Options.ofIDs(Map.of(idA, \"Foo\")), Options.ofIDs(Map.of(idB, true)));\n+\n+        assertEquals(a.toMap(), b.toMap());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_copyWithDefaultValue(boolean supplier) {\n+        var fooID = createIdentifier();\n+        var barOV = OptionValue.build().spec(dummyOptionSpec(\"bar\")).create();\n+\n+        var options = Options.ofIDs(Map.of(fooID, \"Hello\"));\n+        var expected = expectOptions().add(fooID, \"Hello\");\n+\n+        expected.apply(options);\n+        assertFalse(options.contains(barOV.getSpec().name()));\n+\n+        if (supplier) {\n+            options = options.copyWithDefaultValue(barOV, () -> 89);\n+        } else {\n+            options = options.copyWithDefaultValue(barOV, 89);\n+        }\n+        expected.add(barOV, 89).apply(options);\n+\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_copyWithDefaultValue_nop(boolean supplier) {\n+        var fooID = createIdentifier();\n+        var barOV = OptionValue.build().spec(dummyOptionSpec(\"bar\")).create();\n+\n+        var options = Options.of(Map.of(stub(fooID), \"Hello\", barOV, 89));\n+        var expected = expectOptions().add(fooID, \"Hello\").add(barOV, 89);\n+\n+        expected.apply(options);\n+        if (supplier) {\n+            options = options.copyWithDefaultValue(barOV, () -> {\n+                Assertions.fail(\"Should not be called\");\n+                return null;\n+            });\n+        } else {\n+            options = options.copyWithDefaultValue(barOV, 75);\n+        }\n+        expected.apply(options);\n+    }\n+\n+    @Test\n+    public void test_copyWithParent() {\n+        var fooID = createIdentifier();\n+        var barID = dummyOption(\"bar\");\n+\n+        var options = Options.ofIDs(Map.of(fooID, \"Hello\"));\n+        expectOptions().add(fooID, \"Hello\").apply(options);\n+        assertFalse(options.contains(barID.spec().name()));\n+\n+        var parentOptions = Options.of(Map.of(barID, 89));\n+        expectOptions().add(barID, 89).apply(parentOptions);\n+\n+        expectOptions().add(fooID, \"Hello\").add(barID, 89).apply(options.copyWithParent(parentOptions));\n+    }\n+\n+    @Test\n+    public void test_copyWithout() {\n+        var a = createIdentifier();\n+        var b = OptionIdentifier.of(\"foo\");\n+        var c = dummyOption(\"bar\", \"b\");\n+        var d = dummyOption(\"str\", \"s\", \"q\");\n+\n+        var options = Options.concat(\n+                Options.ofIDs(Map.of(a, \"Hello\", b, 189)),\n+                Options.of(Map.of(c, Set.of(78, \"56\"), d, List.of(100)))\n+        );\n+\n+        expectOptions().add(a, \"Hello\").add(b, 189).add(c, Set.of(78, \"56\")).add(d, List.of(100)).apply(options);\n+\n+        var without = options.copyWithout(a, d.id());\n+\n+        expectOptions().add(b, 189).add(c, Set.of(78, \"56\")).apply(without);\n+\n+        assertFalse(without.contains(a));\n+        assertFalse(without.contains(d));\n+        for (var name : d.spec().names()) {\n+            assertFalse(without.contains(name));\n+        }\n+    }\n+\n+    @Test\n+    public void test_copyWithout_duplicate_option_name() {\n+        var x = dummyOption(\"b\", \"c\", \"d\");\n+        var y = dummyOption(\"a\", \"b\", \"d\");\n+\n+        var options = Options.of(Map.of(x, \"Hello\", y, 189));\n+\n+        assertTrue(options.contains(OptionName.of(\"a\")));\n+        assertTrue(options.contains(OptionName.of(\"b\")));\n+        assertTrue(options.contains(OptionName.of(\"c\")));\n+        assertTrue(options.contains(OptionName.of(\"d\")));\n+\n+        var without = options.copyWithout(x.id());\n+\n+        assertTrue(without.contains(OptionName.of(\"a\")));\n+        assertTrue(without.contains(OptionName.of(\"b\")));\n+        assertFalse(without.contains(OptionName.of(\"c\")));\n+        assertTrue(without.contains(OptionName.of(\"d\")));\n+    }\n+\n+    @Test\n+    public void test_copyWith() {\n+        var a = createIdentifier();\n+        var b = OptionIdentifier.of(\"foo\");\n+        var c = dummyOption(\"bar\", \"b\");\n+        var d = dummyOption(\"str\", \"s\", \"q\");\n+        var unused = createIdentifier();\n+\n+        var options = Options.of(Map.of(stub(a), \"Hello\", stub(b), 189, c, Set.of(78, \"56\"), d, List.of(100)));\n+\n+        expectOptions().add(a, \"Hello\").add(b, 189).add(c, Set.of(78, \"56\")).add(d, List.of(100)).apply(options);\n+\n+        var with = options.copyWith(a, c.id(), unused);\n+\n+        expectOptions().add(a, \"Hello\").add(c, Set.of(78, \"56\")).apply(with);\n+\n+        assertFalse(with.contains(b));\n+        assertFalse(with.contains(d));\n+        assertFalse(with.contains(unused));\n+        for (var name : d.spec().names()) {\n+            assertFalse(with.contains(name));\n+        }\n+    }\n+\n+    @Test\n+    public void test_copyWithParent_override() {\n+        var fooID = createIdentifier();\n+        var barID = dummyOption(\"bar\");\n+\n+        var options = Options.concat(\n+                Options.ofIDs(Map.of(fooID, \"Hello\")),\n+                Options.of(Map.of(barID, 137))\n+        );\n+        var expected = expectOptions().add(fooID, \"Hello\").add(barID, 137);\n+        expected.apply(options);\n+\n+        var parentOptions = Options.of(Map.of(barID, 89));\n+        expectOptions().add(barID, 89).apply(parentOptions);\n+\n+        expected.apply(options.copyWithParent(parentOptions));\n+    }\n+\n+    private static Option dummyOption(String... names) {\n+        return new Option(dummyOptionSpec(names));\n+    }\n+\n+    private static OptionSpec<String> dummyOptionSpec(String... names) {\n+        return new OptionSpec<>(\n+                Stream.of(names).map(OptionName::of).toList(),\n+                Optional.empty(),\n+                Set.of(new OptionScope() {}),\n+                OptionSpec.MergePolicy.USE_FIRST,\n+                Optional.empty(),\n+                Optional.empty(),\n+                \"\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 0.2]; errors=[message.error-header+[message.version-string-first-number-not-zero], message.advice-header+[error.invalid-cfbundle-version.advice]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 1.2.3.4]; errors=[message.error-header+[message.version-string-too-many-components], message.advice-header+[error.invalid-cfbundle-version.advice]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 1.]; errors=[message.error-header+[error.version-string-zero-length-component, 1.]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, 1.b.3]; errors=[message.error-header+[error.version-string-invalid-component, 1.b.3, b.3]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--app-version, ]; errors=[message.error-header+[error.version-string-empty]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --add-modules]; errors=[message.error-header+[error.blocked.option, --add-modules]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --foo]; errors=[message.error-header+[error.jlink.failed, Error: unknown option: --foo]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --module-path]; errors=[message.error-header+[error.blocked.option, --module-path]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--jlink-options, --output]; errors=[message.error-header+[error.blocked.option, --output]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--main-jar, non-existent.jar]; errors=[message.error-header+[error.main-jar-does-not-exist, non-existent.jar]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--runtime-image, @@EMPTY_DIR@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@EMPTY_DIR@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_BUNDLE@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@INVALID_MAC_RUNTIME_BUNDLE@@, Contents\/Home\/lib\/**\/libjli.dylib]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_IMAGE@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@INVALID_MAC_RUNTIME_IMAGE@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(IMAGE; app-desc=Hello; args-del=[--main-class]; errors=[message.error-header+[error.no-main-class-with-main-jar, hello.jar], message.advice-header+[error.no-main-class-with-main-jar.advice, hello.jar]])\n+ErrorTest.test(IMAGE; args-add=[--module, com.foo.bar, --runtime-image, @@JAVA_HOME@@]; errors=[message.error-header+[error.no-module-in-path, com.foo.bar]])\n+ErrorTest.test(IMAGE; args-add=[--module, java.base, --runtime-image, @@JAVA_HOME@@]; errors=[message.error-header+[ERR_NoMainClass]])\n+ErrorTest.test(LINUX_DEB; app-desc=Hello; args-add=[--linux-package-name, #]; errors=[message.error-header+[error.deb-invalid-value-for-package-name, #], message.advice-header+[error.deb-invalid-value-for-package-name.advice]])\n+ErrorTest.test(LINUX_RPM; app-desc=Hello; args-add=[--linux-package-name, #]; errors=[message.error-header+[error.rpm-invalid-value-for-package-name, #], message.advice-header+[error.rpm-invalid-value-for-package-name.advice]])\n+ErrorTest.test(MAC_PKG; app-desc=Hello; args-add=[--mac-package-identifier, #1]; errors=[message.error-header+[message.invalid-identifier, #1]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--mac-app-store, --runtime-image, @@JAVA_HOME@@]; errors=[message.error-header+[error.invalid-runtime-image-bin-dir, @@JAVA_HOME@@], message.advice-header+[error.invalid-runtime-image-bin-dir.advice, --mac-app-store]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--runtime-image, @@EMPTY_DIR@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@EMPTY_DIR@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_BUNDLE@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@INVALID_MAC_RUNTIME_BUNDLE@@, Contents\/Home\/lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; app-desc=Hello; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_IMAGE@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@INVALID_MAC_RUNTIME_IMAGE@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; args-add=[--runtime-image, @@EMPTY_DIR@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@EMPTY_DIR@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_BUNDLE@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@INVALID_MAC_RUNTIME_BUNDLE@@, Contents\/Home\/lib\/**\/libjli.dylib]])\n+ErrorTest.test(NATIVE; args-add=[--runtime-image, @@INVALID_MAC_RUNTIME_IMAGE@@]; errors=[message.error-header+[error.invalid-runtime-image-missing-file, @@INVALID_MAC_RUNTIME_IMAGE@@, lib\/**\/libjli.dylib]])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1.2.3.4.5]; errors=[message.error-header+[error.msi-product-version-components, 1.2.3.4.5], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1.2.65536]; errors=[message.error-header+[error.msi-product-version-build-out-of-range, 1.2.65536], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1.256]; errors=[message.error-header+[error.msi-product-version-minor-out-of-range, 1.256], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 1234]; errors=[message.error-header+[error.msi-product-version-components, 1234], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--app-version, 256.1]; errors=[message.error-header+[error.msi-product-version-major-out-of-range, 256.1], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_EXE; app-desc=Hello; args-add=[--launcher-as-service]; errors=[message.error-header+[error.missing-service-installer], message.advice-header+[error.missing-service-installer.advice]])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1.2.3.4.5]; errors=[message.error-header+[error.msi-product-version-components, 1.2.3.4.5], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1.2.65536]; errors=[message.error-header+[error.msi-product-version-build-out-of-range, 1.2.65536], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1.256]; errors=[message.error-header+[error.msi-product-version-minor-out-of-range, 1.256], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 1234]; errors=[message.error-header+[error.msi-product-version-components, 1234], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--app-version, 256.1]; errors=[message.error-header+[error.msi-product-version-major-out-of-range, 256.1], message.advice-header+[error.version-string-wrong-format.advice]])\n+ErrorTest.test(WIN_MSI; app-desc=Hello; args-add=[--launcher-as-service]; errors=[message.error-header+[error.missing-service-installer], message.advice-header+[error.missing-service-installer.advice]])\n+ErrorTest.test(args-add=[@foo]; errors=[message.error-header+[ERR_CannotParseOptions, foo]])\n+ErrorTest.testMacSigningIdentityValidation(IMAGE, --mac-app-image-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(IMAGE, --mac-signing-key-user-name, false)\n+ErrorTest.testMacSigningIdentityValidation(MAC_DMG, --mac-app-image-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(MAC_DMG, --mac-signing-key-user-name, false)\n+ErrorTest.testMacSigningIdentityValidation(MAC_PKG, --mac-app-image-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(MAC_PKG, --mac-installer-sign-identity, true)\n+ErrorTest.testMacSigningIdentityValidation(MAC_PKG, --mac-signing-key-user-name, false)\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.excludes","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.file.Files;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.internal.util.Result;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.JavaTool;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.DynamicTest;\n+import org.junit.jupiter.api.TestFactory;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+\n+\/**\n+ * Runs some ErrorTest test cases from an IDE on a mockup jpackage tool\n+ * provider.\n+ * <p>\n+ * ErrorTest is comprised of test cases that pass faulty command line arguments\n+ * to jpackage and expect it to fail. It is natural to reuse these test cases to\n+ * test jpackage command line validation.\n+ * <p>\n+ * ErrorTest provides better test coverage, but it is a jtreg test, it runs\n+ * slowly and there is no integration of jtreg tests in IDEs. This JUnit test\n+ * class leverages ErrorTest test cases to test jpackage command line validation\n+ * from an IDE.\n+ *\n+ * <p>\n+ * The scenario breaks down into two components:\n+ * <ol>\n+ * <li>Load ErrorTest jtreg test\n+ * <li>Setup custom jpackage tool provider\n+ * <\/ol>\n+ *\n+ * <h1>1. Load ErrorTest jtreg test<\/h1>\n+ * <p>\n+ * Build OptionsValidationFailTest, ErrorTest and its nested classes such that\n+ * they reside in the unnamed module together with the classes from the\n+ * \"jdk.jpackage.test\" package.\n+ * <p>\n+ * There is no straightforward way to access classes in the unnamed package\n+ * outside their module. However, these classes (class files) can be accessed as\n+ * resources. So the workaround is to read class files of classes in the unnamed\n+ * package and load them using a custom class loader.\n+ * <p>\n+ * jpackage jtreg tests are in the unnamed package according to jtreg\n+ * recommendations, see\n+ * <a href=\"https:\/\/openjdk.org\/jtreg\/faq.html#how-should-i-organize-tests-libraries-and-other-test-related-files\">jtreg FAQ<\/a>\n+ *\/\n+@EnabledIf(\"jtregErrorTestAvailable\")\n+public class OptionsValidationFailTest {\n+\n+    @BeforeAll\n+    public static void setCustomJPackageToolProvider() {\n+        JPackageCommand.useToolProviderByDefault(new ToolProvider() {\n+\n+            @Override\n+            public String name() {\n+                return \"jpackage-mockup\";\n+            }\n+\n+            @Override\n+            public int run(PrintWriter out, PrintWriter err, String... args) {\n+\n+                var errorReporter = new Main.ErrorReporter(ex -> {\n+                    ex.printStackTrace(err);\n+                }, out::append);\n+\n+                return parse(args).peekErrors(errors -> {\n+                    final var firstErr = errors.stream().findFirst().orElseThrow();\n+                    errorReporter.reportError(firstErr);\n+                }).map(builder -> {\n+                    var result = new OptionsProcessor(builder, bundlingEnv).validate();\n+                    if (result.hasValue()) {\n+                        return 0;\n+                    } else {\n+                        result.peekErrors(errors -> {\n+                            errors.forEach(errorReporter::reportError);\n+                        });\n+                        return 1;\n+                    }\n+                }).value().orElse(1);\n+            }\n+\n+            private Result<JOptSimpleOptionsBuilder.OptionsBuilder> parse(String... args) {\n+                return Utils.buildParser(OperatingSystem.current(), bundlingEnv).create().apply(args);\n+            }\n+\n+            private final CliBundlingEnvironment bundlingEnv = new CliBundlingEnvironment() {\n+\n+                @Override\n+                public Optional<BundlingOperationDescriptor> defaultOperation() {\n+                    switch (OperatingSystem.current()) {\n+                        case WINDOWS -> {\n+                            return Optional.of(StandardBundlingOperation.CREATE_WIN_EXE.descriptor());\n+                        }\n+                        case LINUX -> {\n+                            return Optional.of(StandardBundlingOperation.CREATE_LINUX_RPM.descriptor());\n+                        }\n+                        case MACOS -> {\n+                            return Optional.of(StandardBundlingOperation.CREATE_MAC_PKG.descriptor());\n+                        }\n+                        default -> {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void createBundle(BundlingOperationDescriptor op, Options cmdline) {\n+                    throw new AssertionError();\n+                }\n+\n+            };\n+        });\n+    }\n+\n+    @AfterAll\n+    public static void resetJPackageToolProvider() {\n+        Optional.ofNullable(JavaTool.JPACKAGE.asToolProvider()).ifPresentOrElse(\n+                JPackageCommand::useToolProviderByDefault, JPackageCommand::useExecutableByDefault);\n+    }\n+\n+    @TestFactory\n+    Stream<DynamicTest> getTestCasesFromErrorTest() throws Throwable {\n+        final var jpackageTestsUnnamedModule = JUnitAdapter.class.getModule();\n+\n+        final var testClassloader = new InMemoryClassLoader(Stream.of(\n+                \"ErrorTest\",\n+                \"ErrorTest$ArgumentGroup\",\n+                \"ErrorTest$PackageTypeSpec\",\n+                \"ErrorTest$TestSpec$Builder\",\n+                \"ErrorTest$TestSpec\",\n+                \"ErrorTest$Token\",\n+                \"ErrorTest$UnsupportedPlatformOption\"\n+        ).collect(Collectors.toMap(x -> x, className -> {\n+            try (final var in = Objects.requireNonNull(jpackageTestsUnnamedModule.getResourceAsStream(className + \".class\"))) {\n+                final var buffer= new ByteArrayOutputStream();\n+                in.transferTo(buffer);\n+                return buffer.toByteArray();\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        })));\n+\n+        final var thisModule = getClass().getModule();\n+        if (thisModule.isNamed()) {\n+            for (final var m : List.of(testClassloader.getUnnamedModule(), jpackageTestsUnnamedModule)) {\n+                thisModule.addOpens(\"jdk.jpackage.internal\", m);\n+            }\n+        }\n+\n+        final var defaultExcludesFile = TKit.TEST_SRC_ROOT.resolve(String.format(\n+                \"junit\/share\/jdk.jpackage\/%s.excludes\", OptionsValidationFailTest.class.getName().replace(\".\", \"\/\")));\n+\n+        final var defaultExcludes = Files.readAllLines(defaultExcludesFile).stream().map(testDesc -> {\n+            return \"--jpt-exclude=\" + testDesc;\n+        });\n+\n+        final var defaultIncludes = Stream.of(\n+\/\/              \"ErrorTest.test(NATIVE; args-add=[--runtime-image, @@JAVA_HOME@@, --app-image, app-image]; errors=[ERR_MutuallyExclusiveOptions+[--runtime-image, --app-image]])\"\n+        ).map(testDesc -> {\n+            return \"--jpt-include=\" + testDesc;\n+        });\n+\n+        return JUnitAdapter.createJPackageTests(testClassloader, Stream.of(\n+                defaultExcludes,\n+                defaultIncludes,\n+                Stream.of(\"--jpt-run=ErrorTest\")\n+        ).flatMap(x -> x).toArray(String[]::new));\n+    }\n+\n+    private static boolean jtregErrorTestAvailable() {\n+        final var jpackageTestsUnnamedModule = JUnitAdapter.class.getModule();\n+\n+        try (final var in = jpackageTestsUnnamedModule.getResourceAsStream(\"ErrorTest.class\")) {\n+            return in != null;\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static final class InMemoryClassLoader extends ClassLoader {\n+        InMemoryClassLoader(Map<String, byte[]> classes) {\n+            super(InMemoryClassLoader.class.getClassLoader());\n+            this.classes = Objects.requireNonNull(classes);\n+        }\n+\n+        @Override\n+        protected Class<?> findClass(String name) throws ClassNotFoundException {\n+            final var classBytes = classes.get(name);\n+            if (classBytes != null) {\n+                return defineClass(name, classBytes, 0, classBytes.length);\n+            } else {\n+                return getParent().loadClass(name);\n+            }\n+        }\n+\n+        private final Map<String, byte[]> classes;\n+    }\n+\n+    static {\n+        \/\/ Ensure JUnitAdapter class is initialized to get the value of the \"test.src\"\n+        \/\/ property set when the test is executed by a test runner other than jtreg.\n+        toRunnable(() -> MethodHandles.lookup().ensureInitialized(JUnitAdapter.class)).run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/OptionsValidationFailTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class StandardBundlingOperationTest {\n+\n+    @Test\n+    public void testUniqueDescriptors() {\n+        Stream.of(StandardBundlingOperation.values()).collect(toMap(StandardBundlingOperation::descriptor, x -> x));\n+    }\n+\n+    @Test\n+    public void test_valueOf() {\n+        for (var op : StandardBundlingOperation.values()) {\n+            assertSame(op, StandardBundlingOperation.valueOf(op.descriptor()).orElseThrow());\n+        }\n+\n+        assertFalse(StandardBundlingOperation.valueOf(BundlingOperationDescriptor.valueOf(\"WINDOWS:create:foo\")).isPresent());\n+    }\n+\n+    @Test\n+    public void test_ofPlatform() {\n+        var combined = Stream.of(OperatingSystem.WINDOWS, OperatingSystem.MACOS, OperatingSystem.LINUX)\n+                .map(StandardBundlingOperation::ofPlatform)\n+                .flatMap(x -> x).sorted().toList();\n+\n+        var whole = Stream.of(StandardBundlingOperation.values()).sorted().toList();\n+\n+        assertEquals(whole, combined);\n+    }\n+\n+    @Test\n+    public void test_narrow() {\n+        assertEquals(\n+                List.of(StandardBundlingOperation.CREATE_LINUX_APP_IMAGE),\n+                StandardBundlingOperation.narrow(Stream.of(StandardBundlingOperation.CREATE_LINUX_APP_IMAGE, new OptionScope() {})).toList());\n+\n+        assertEquals(List.of(), StandardBundlingOperation.narrow(Stream.of(new OptionScope() {})).toList());\n+        assertEquals(List.of(), StandardBundlingOperation.narrow(Stream.of()).toList());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testFromOptionName(Map.Entry<String, Set<BundlingOperationOptionScope>> testSpec) {\n+        final var actualScope = StandardBundlingOperation.fromOptionName(testSpec.getKey());\n+        assertEquals(testSpec.getValue(), actualScope);\n+    }\n+\n+    private static List<Map.Entry<String, Set<BundlingOperationOptionScope>>> testFromOptionName() {\n+        return List.of(\n+                Map.entry(\"foo\", StandardBundlingOperation.CREATE_BUNDLE),\n+                Map.entry(\"win-foo\", StandardBundlingOperation.WINDOWS),\n+                Map.entry(\"linux-foo\", StandardBundlingOperation.LINUX),\n+                Map.entry(\"mac-foo\", MAC_CREATE_BUNDLE),\n+                Map.entry(\"win-exe-foo\", Set.of(StandardBundlingOperation.CREATE_WIN_EXE)),\n+                Map.entry(\"win-msi-foo\", Set.of(StandardBundlingOperation.CREATE_WIN_MSI)),\n+                Map.entry(\"linux-rpm-foo\", Set.of(StandardBundlingOperation.CREATE_LINUX_RPM)),\n+                Map.entry(\"linux-deb-foo\", Set.of(StandardBundlingOperation.CREATE_LINUX_DEB)),\n+                Map.entry(\"mac-dmg-foo\", Set.of(StandardBundlingOperation.CREATE_MAC_DMG)),\n+                Map.entry(\"mac-pkg-foo\", Set.of(StandardBundlingOperation.CREATE_MAC_PKG))\n+        );\n+    }\n+\n+    private static final Set<BundlingOperationOptionScope> MAC_CREATE_BUNDLE = Set.of(\n+            StandardBundlingOperation.CREATE_MAC_APP_IMAGE,\n+            StandardBundlingOperation.CREATE_MAC_DMG,\n+            StandardBundlingOperation.CREATE_MAC_PKG);\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardBundlingOperationTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,640 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.Files;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.ConvertedOptionsBuilder;\n+import jdk.jpackage.internal.cli.JOptSimpleOptionsBuilder.OptionsBuilder;\n+import jdk.jpackage.internal.cli.StandardOption.LauncherProperty;\n+import jdk.jpackage.internal.model.JPackageException;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import jdk.jpackage.internal.util.StringBundle;\n+import jdk.jpackage.test.Comm;\n+import jdk.jpackage.test.JUnitAdapter;\n+import jdk.jpackage.test.TKit;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class StandardOptionTest extends JUnitAdapter.TestSrcInitializer {\n+\n+    @Test\n+    public void testNamesUnique() {\n+\n+        final var options = StandardOption.options();\n+\n+        \/\/ Test option names are unique. Let Collectors.toMap() do it.\n+        options.stream()\n+                .map(Option::spec)\n+                .map(OptionSpec::names)\n+                .flatMap(Collection::stream)\n+                .map(OptionName::name)\n+                .collect(toMap(x -> x, x -> x));\n+    }\n+\n+    @Test\n+    public void testDescription() {\n+\n+        final var options = StandardOption.options();\n+\n+        var i18n = StringBundle.fromResourceBundle(ResourceBundle.getBundle(\"jdk.jpackage.internal.resources.HelpResources\"));\n+\n+        options.stream().map(Option::spec).map(OptionSpec::description).forEach(i18n::getString);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"icon\"})\n+    public void test_ICON(String name, @TempDir Path workDir) throws IOException {\n+\n+        if (!name.isEmpty()) {\n+            var file = workDir.resolve(name);\n+\n+            Files.write(file, new byte[0]);\n+\n+            name = file.toString();\n+        }\n+\n+        var spec = StandardOption.ICON.getSpec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(name));\n+\n+        assertEquals(Path.of(name), result.orElseThrow());\n+    }\n+\n+    @Test\n+    public void test_ICON_validator_fail(@TempDir Path workDir) {\n+\n+        var spec = StandardOption.ICON.getSpec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(workDir.toString()));\n+\n+        var ex = assertThrows(JPackageException.class, result::orElseThrow);\n+\n+        assertEquals(I18N.format(\"error.parameter-not-file\", workDir, \"--icon\"), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_ICON_validator_fail_in_property_file(@TempDir Path workDir) {\n+\n+        var propertyFile = Path.of(\"foo.properties\");\n+\n+        var spec = new StandardOptionContext().forFile(propertyFile).mapOptionSpec(StandardOption.ICON.getSpec());\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(workDir.toString()));\n+\n+        var ex = assertThrows(JPackageException.class, result::orElseThrow);\n+\n+        assertEquals(I18N.format(\"error.properties-parameter-not-file\", workDir, \"icon\", propertyFile), ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"non-existent\"})\n+    public void test_TEMP_ROOT_valid(String dir, @TempDir Path workDir) {\n+\n+        var spec = StandardOption.TEMP_ROOT.getSpec();\n+\n+        var tempRoot = workDir.resolve(dir);\n+\n+        var value = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString())).orElseThrow();\n+\n+        assertEquals(tempRoot, value);\n+    }\n+\n+    @Test\n+    public void test_TEMP_ROOT_invalid(@TempDir Path workDir) throws IOException {\n+\n+        var spec = StandardOption.TEMP_ROOT.getSpec();\n+\n+        var tempRoot = workDir.resolve(\"file\");\n+\n+        Files.writeString(tempRoot, \"foo\");\n+\n+        var ex = assertThrowsExactly(JPackageException.class,\n+                spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n+        assertEquals(I18N.format(\"error.parameter-not-empty-directory\", tempRoot, \"--temp\"), ex.getMessage());\n+        assertEquals(NotDirectoryException.class, ex.getCause().getClass());\n+\n+        tempRoot = workDir;\n+\n+        ex = assertThrowsExactly(JPackageException.class,\n+                spec.converter().orElseThrow().convert(spec.name(), StringToken.of(tempRoot.toString()))::orElseThrow);\n+        assertEquals(I18N.format(\"error.parameter-not-empty-directory\", tempRoot, \"--temp\"), ex.getMessage());\n+        assertEquals(DirectoryNotEmptyException.class, ex.getCause().getClass());\n+    }\n+\n+    @Test\n+    public void test_TYPE_valid() {\n+\n+        var spec = StandardOption.TYPE.getSpec();\n+\n+        Stream.of(StandardBundlingOperation.values()).forEach(bundlingOperation -> {\n+            var pkgTypeStr = bundlingOperation.packageTypeValue();\n+            var pkgType = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(pkgTypeStr)).orElseThrow();\n+            assertSame(bundlingOperation.packageType(), pkgType);\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"msii\", \"RPM\", \"App-image\"})\n+    public void test_TYPE_invalid(String name) {\n+\n+        var spec = StandardOption.TYPE.getSpec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(name));\n+\n+        var ex = assertThrows(JPackageException.class, result::orElseThrow);\n+\n+        assertEquals(I18N.format(\"ERR_InvalidInstallerType\", name), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void test_booleanOptionMutator() {\n+\n+        var option = OptionSpecBuilder.create(Boolean.class).name(\"foo\").mutate(StandardOption.booleanOptionMutator()).create();\n+\n+        var empty = Options.of(Map.of());\n+\n+        \/\/ Expect the default value.\n+        assertTrue(option.findIn(empty).isPresent());\n+\n+        \/\/ Expect the option is not found.\n+        assertFalse(option.containsIn(empty));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testLauncherShortcutOptions(LauncherShortcutTestSpec testSpec) {\n+        testSpec.test();\n+    }\n+\n+    @Test\n+    public void test_launcherOptions() {\n+        var options = StandardOption.launcherOptions().stream().map(Option::id).toList();\n+\n+        \/\/ Test some that should be in the set\n+        assertTrue(options.contains(StandardOption.ARGUMENTS.id()));\n+        assertTrue(options.contains(StandardOption.MODULE.id()));\n+        assertTrue(options.contains(StandardOption.APPCLASS.id()));\n+        assertTrue(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+\n+        \/\/ Test some that should NOT be in the set\n+        assertFalse(options.contains(StandardOption.NAME.id()));\n+        assertFalse(options.contains(StandardOption.INSTALL_DIR.id()));\n+    }\n+\n+    @Test\n+    public void test_sharedOption() {\n+\n+        var pred = StandardOption.sharedOption();\n+\n+        var options = StandardOption.options().stream().filter(option -> {\n+            return pred.test(option.spec());\n+        }).map(Option::id).toList();\n+\n+        \/\/ Test some that should be in the set\n+        assertTrue(options.contains(StandardOption.NAME.id()));\n+        assertTrue(options.contains(StandardOption.INSTALL_DIR.id()));\n+\n+        \/\/ Test some that should NOT be in the set\n+        assertFalse(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+        assertFalse(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+        assertFalse(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(names = {\"WINDOWS\", \"LINUX\", \"MACOS\"})\n+    public void test_platformOption(OperatingSystem os) {\n+\n+        var pred = StandardOption.platformOption(os);\n+\n+        var options = StandardOption.options().stream().filter(option -> {\n+            return pred.test(option.spec());\n+        }).map(Option::id).toList();\n+\n+        \/\/ Test some that should be in the set\n+        assertTrue(options.contains(StandardOption.NAME.id()));\n+        assertTrue(options.contains(StandardOption.INSTALL_DIR.id()));\n+\n+        switch (os) {\n+            case WINDOWS -> {\n+                assertTrue(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+                assertFalse(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+                assertFalse(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+            }\n+            case LINUX -> {\n+                assertFalse(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+                assertTrue(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+                assertFalse(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+            }\n+            case MACOS -> {\n+                assertFalse(options.contains(StandardOption.WIN_CONSOLE_HINT.id()));\n+                assertFalse(options.contains(StandardOption.LINUX_MENU_GROUP.id()));\n+                assertTrue(options.contains(StandardOption.MAC_APP_CATEGORY.id()));\n+            }\n+            default -> {\n+                throw new AssertionError();\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_ARGUMENTS(String value, List<String> expectedTokens) {\n+\n+        var spec = StandardOption.ARGUMENTS.getOption().spec();\n+\n+        var result = spec.converter().orElseThrow().convert(spec.name(), StringToken.of(value));\n+\n+        assertEquals(expectedTokens, List.of(result.map(String[].class::cast).orElseThrow()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testAddLauncherOption(AddLauncherTestSpec testSpec, @TempDir Path workDir) throws IOException {\n+        testSpec.test(workDir);\n+    }\n+\n+    @Disabled\n+    @Test\n+    public void printMarkdownOptionTable() {\n+        OptionSpecFormatter.groupByOption(System.out::println,\n+                StandardOption.options().stream().map(Option::spec).toList());\n+    }\n+\n+    @Disabled\n+    @Test\n+    public void updateMarkdownOptionTable() throws IOException {\n+        try (var sink = Files.newBufferedWriter(GOLDEN_JPACKAGE_OPTIONS_MD); var pw = new PrintWriter(sink)) {\n+            OptionSpecFormatter.groupByOption(pw::println,\n+                    StandardOption.options().stream().map(Option::spec).toList());\n+        }\n+    }\n+\n+    @Test\n+    public void verifyOptions() throws IOException {\n+\n+        List<String> optionTable = new ArrayList<>();\n+\n+        OptionSpecFormatter.groupByOption(optionTable::add,\n+                StandardOption.options().stream().map(Option::spec).toList());\n+\n+        var expectedOptionTable = Files.readAllLines(GOLDEN_JPACKAGE_OPTIONS_MD);\n+\n+        assertEquals(expectedOptionTable, optionTable);\n+    }\n+\n+    private static Collection<Arguments> test_ARGUMENTS() {\n+        return List.of(\n+                Arguments.of(\"abc\", List.of(\"abc\")),\n+                Arguments.of(\"a b c\", List.of(\"a\", \"b\", \"c\")),\n+                Arguments.of(\"a=10 -Dorg.acme.name='John Smith' c=\\\\\\\"foo\\\\\\\"\", List.of(\"a=10\", \"-Dorg.acme.name=John Smith\", \"c=\\\"foo\\\"\")),\n+                Arguments.of(\"\\\"\\\"\", List.of(\"\")),\n+                Arguments.of(\" \", List.of()),\n+                Arguments.of(\"\", List.of())\n+        );\n+    }\n+\n+\n+    record AddLauncherTestSpec(Optional<AdditionalLauncher> expected, List<String> expectedErrors, Optional<String> optionValue) {\n+        AddLauncherTestSpec {\n+            if (expected.isEmpty() == expectedErrors.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        void test(Path workDir) throws IOException {\n+            final List<String> args = new ArrayList<>();\n+            args.add(StandardOption.ADD_LAUNCHER_INTERNAL.getSpec().name().formatForCommandLine());\n+            optionValue.ifPresent(args::add);\n+            if (optionValue.isEmpty()) {\n+                var path = workDir.resolve(expected.orElseThrow().propertyFile());\n+                Files.createDirectories(path.getParent());\n+                Files.createFile(path);\n+                expected.map(v -> v.name() + \"=\" + path).ifPresent(args::add);\n+            }\n+\n+            final var result = new JOptSimpleOptionsBuilder().options(StandardOption.ADD_LAUNCHER_INTERNAL).create()\n+                    .apply(args.toArray(String[]::new))\n+                    .flatMap(OptionsBuilder::convertedOptions).map(ConvertedOptionsBuilder::create);\n+\n+            if (expectedErrors.isEmpty()) {\n+                final var cmdline = result.orElseThrow();\n+                assertEquals(expected.map(List::of).orElseGet(List::of), Stream.of(StandardOption.ADD_LAUNCHER_INTERNAL.getFrom(cmdline)).map(v -> {\n+                    if (optionValue.isEmpty()) {\n+                        return new AdditionalLauncher(v.name(), workDir.relativize(v.propertyFile()));\n+                    } else {\n+                        return v;\n+                    }\n+                }).toList());\n+            } else {\n+                assertEquals(expectedErrors.stream().toList(), result.errors().stream().map(Exception::getMessage).toList());\n+            }\n+        }\n+\n+        static final class Builder {\n+\n+            AddLauncherTestSpec create() {\n+                return new AddLauncherTestSpec(Optional.ofNullable(expected), expectedErrors, Optional.ofNullable(optionValue));\n+            }\n+\n+            Builder expect(String name, String path) {\n+                expected = new AdditionalLauncher(name, Path.of(path));\n+                return this;\n+            }\n+\n+            Builder expectErrors(String... v) {\n+                expectedErrors.addAll(List.of(v));\n+                return this;\n+            }\n+\n+            Builder optionValue(String v) {\n+                optionValue = v;\n+                return this;\n+            }\n+\n+            private AdditionalLauncher expected;\n+            private List<String> expectedErrors = new ArrayList<>();\n+            private String optionValue;\n+        }\n+    }\n+\n+\n+    private static Collection<AddLauncherTestSpec> testAddLauncherOption() {\n+        return Stream.of(\n+                buildAddLauncherTest().expect(\"foo\", \"some.properties\"),\n+                buildAddLauncherTest().expect(\"foo\", \"a\/b\/some.properties\").expect(\"bar\", \"=\"),\n+                buildAddLauncherTest().expect(\"a\", \"a.properties\").expect(\"a\", \"b.properties\"),\n+                buildAddLauncherTest().optionValue(\"some\").expectErrors(I18N.format(\"error.parameter-add-launcher-malformed\", \"some\", \"--add-launcher\")),\n+                buildAddLauncherTest().optionValue(\"\").expectErrors(I18N.format(\"error.parameter-add-launcher-malformed\", \"\", \"--add-launcher\")),\n+                buildAddLauncherTest().optionValue(\"=\").expectErrors(I18N.format(\"ERR_InvalidSLName\", \"\")),\n+                buildAddLauncherTest().optionValue(\"a=\").expectErrors(I18N.format(\"error.parameter-add-launcher-not-file\", \"\", \"a\")),\n+                buildAddLauncherTest().optionValue(\"=a\").expectErrors(I18N.format(\"ERR_InvalidSLName\", \"\")),\n+                \/\/ Not a path\n+                buildAddLauncherTest().optionValue(\"foo=*\").expectErrors(I18N.format(\"error.parameter-add-launcher-not-file\", \"*\", \"foo\")),\n+                \/\/ The path is a directory\n+                buildAddLauncherTest().optionValue(\"foo=.\").expectErrors(I18N.format(\"error.parameter-add-launcher-not-file\", \".\", \"foo\")),\n+                \/\/ The path doesn't exist\n+                buildAddLauncherTest().optionValue(\"Foo=foo\/bar\/buz\/111.z\").expectErrors(I18N.format(\"error.parameter-add-launcher-not-file\", \"foo\/bar\/buz\/111.z\", \"Foo\"))\n+        ).map(AddLauncherTestSpec.Builder::create).toList();\n+    }\n+\n+    private static AddLauncherTestSpec.Builder buildAddLauncherTest() {\n+        return new AddLauncherTestSpec.Builder();\n+    }\n+\n+\n+    record LauncherShortcutTestSpec(OptionValue<LauncherShortcut> option, Optional<LauncherShortcut> expected, List<String> expectedErrors, boolean propertyFile, Optional<String> optionValue) {\n+        LauncherShortcutTestSpec {\n+            Objects.requireNonNull(option);\n+            if (expected.isEmpty() == expectedErrors.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        void test() {\n+            final List<String> args = new ArrayList<>();\n+            args.add(option.getSpec().name().formatForCommandLine());\n+            optionValue.ifPresent(args::add);\n+\n+            final var builder = new JOptSimpleOptionsBuilder().options(option);\n+            if (propertyFile) {\n+                builder.optionSpecMapper(spec -> {\n+                    return new StandardOptionContext().forFile(DUMMY_PROPERTY_FILE).mapOptionSpec(spec);\n+                });\n+            }\n+\n+            final var result = builder.create()\n+                    .apply(args.toArray(String[]::new))\n+                    .flatMap(OptionsBuilder::convertedOptions).map(ConvertedOptionsBuilder::create);\n+\n+            if (expectedErrors.isEmpty()) {\n+                assertEquals(expected.orElseThrow(), option.getFrom(result.orElseThrow()));\n+            } else {\n+                assertEquals(expectedErrors.stream().toList(), result.errors().stream().map(Exception::getMessage).toList());\n+            }\n+        }\n+\n+        static final class Builder {\n+\n+            LauncherShortcutTestSpec create() {\n+                var theExpected = Optional.ofNullable(expected);\n+                return new LauncherShortcutTestSpec(\n+                        option,\n+                        theExpected,\n+                        theExpected.map(v -> {\n+                            return List.<String>of();\n+                        }).orElseGet(() -> {\n+                            if (propertyFile) {\n+                                return List.of(I18N.format(\"error.properties-parameter-not-launcher-shortcut-dir\",\n+                                        optionValue, option.getSpec().name().name(), DUMMY_PROPERTY_FILE));\n+                            } else {\n+                                return List.of(I18N.format(\"error.parameter-not-launcher-shortcut-dir\",\n+                                        optionValue, option.getSpec().name().formatForCommandLine()));\n+                            }\n+                        }), propertyFile, Optional.ofNullable(optionValue));\n+            }\n+\n+            Builder option(OptionValue<LauncherShortcut> v) {\n+                option = v;\n+                return this;\n+            }\n+\n+            Builder expect(LauncherShortcut v) {\n+                expected = v;\n+                if (expected != null) {\n+                    optionValue(v.startupDirectory().map(LauncherShortcutStartupDirectory::asStringValue).orElse(null));\n+                } else {\n+                    optionValue(null);\n+                }\n+                return this;\n+            }\n+\n+            Builder expect(LauncherShortcutStartupDirectory v) {\n+                return expect(new LauncherShortcut(v));\n+            }\n+\n+            Builder propertyFile(boolean v) {\n+                propertyFile = v;\n+                return this;\n+            }\n+\n+            Builder optionValue(String v) {\n+                optionValue = v;\n+                return this;\n+            }\n+\n+\n+            OptionValue<LauncherShortcut> option;\n+            private boolean propertyFile;\n+            private LauncherShortcut expected;\n+            private String optionValue;\n+        }\n+\n+        private static final Path DUMMY_PROPERTY_FILE = Path.of(\"foo.properties\");\n+    }\n+\n+\n+    private static Collection<LauncherShortcutTestSpec> testLauncherShortcutOptions() {\n+        return Stream.of(\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.DEFAULT).optionValue(null),\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.APP_DIR),\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.DEFAULT).propertyFile(true),\n+                buildLauncherShortcutTest().expect(LauncherShortcutStartupDirectory.APP_DIR).propertyFile(true),\n+                buildLauncherShortcutTest().expect(new LauncherShortcut()).optionValue(\"false\").propertyFile(true),\n+                buildLauncherShortcutTest().optionValue(LauncherShortcutStartupDirectory.DEFAULT.asStringValue()),\n+                buildLauncherShortcutTest().optionValue(\"false\"),\n+                buildLauncherShortcutTest().optionValue(\"\"),\n+                buildLauncherShortcutTest().expect(new LauncherShortcut()).optionValue(\"\").propertyFile(true),\n+                buildLauncherShortcutTest().optionValue(\"bar\"),\n+                buildLauncherShortcutTest().expect(new LauncherShortcut()).optionValue(\"bar\").propertyFile(true)\n+        ).map(builder -> {\n+            return Stream.of(\n+                    StandardOption.LINUX_SHORTCUT_HINT,\n+                    StandardOption.WIN_MENU_HINT,\n+                    StandardOption.WIN_SHORTCUT_HINT\n+            ).map(builder::option).map(LauncherShortcutTestSpec.Builder::create);\n+        }).flatMap(x -> x).toList();\n+    }\n+\n+    private static LauncherShortcutTestSpec.Builder buildLauncherShortcutTest() {\n+        return new LauncherShortcutTestSpec.Builder();\n+    }\n+\n+    private static final class OptionSpecFormatter {\n+        static void groupByOption(Consumer<String>sink, Collection<? extends OptionSpec<?>> specs) {\n+            sink.accept(\"| Option | Scope | With runtime installer | With predefined app image | Recognized in add launcher .property file | Merge\");\n+            sink.accept(\"| --- | --- | :---: | :---: | :---: | :---: |\");\n+            for (final var spec : specs.stream().sorted(Comparator.comparing(v -> { return v.name().name(); })).toList()) {\n+                final var mods = filterByType(spec.scope(), BundlingOperationModifier.class);\n+                sink.accept(String.format(\"| %s | %s | %s | %s | %s | %s |\",\n+                        formatOptionNames(spec),\n+                        format(filterByType(spec.scope(), BundlingOperationOptionScope.class)),\n+                        (mods.contains(BundlingOperationModifier.BUNDLE_RUNTIME) ? \"x\" : \"\"),\n+                        (mods.contains(BundlingOperationModifier.BUNDLE_PREDEFINED_APP_IMAGE) ? \"x\" : \"\"),\n+                        (!filterByType(spec.scope(), LauncherProperty.class).isEmpty() ? \"x\" : \"\"),\n+                        spec.mergePolicy()\n+                ));\n+            }\n+        }\n+\n+        private static String formatOptionNames(OptionSpec<?> spec) {\n+            return spec.names().stream().map(OptionName::formatForCommandLine).collect(joining(\", \"));\n+        }\n+\n+        private static String format(OptionScope op) {\n+            return Optional.ofNullable(KNOWN_BUNDLING_OPERATIONS.get(op)).orElseGet(op::toString);\n+        }\n+\n+        private static String format(Set<OptionScope> ops) {\n+            final List<String> knownScopeLabels = new ArrayList<>();\n+\n+            for (;;) {\n+                final var theOps = ops;\n+                final var bestMatchedKnownScope = KNOWN_SCOPES.keySet().stream().map(knownGroup -> {\n+                    return Comm.compare(theOps, knownGroup);\n+                }).filter(comm -> {\n+                    return comm.unique2().isEmpty();\n+                }).max(Comparator.comparing(comm -> {\n+                    return comm.common().size();\n+                }));\n+\n+                if (bestMatchedKnownScope.isEmpty()) {\n+                    break;\n+                } else {\n+                    knownScopeLabels.add(KNOWN_SCOPES.get(bestMatchedKnownScope.orElseThrow().common()));\n+                    ops = bestMatchedKnownScope.orElseThrow().unique1();\n+                }\n+            }\n+\n+            return Stream.concat(\n+                    knownScopeLabels.stream(),\n+                    ops.stream().map(OptionSpecFormatter::format)\n+            ).sorted().collect(joining(\", \"));\n+        }\n+\n+        private static Set<OptionScope> filterByType(Collection<OptionScope> ops, Class<? extends OptionScope> filterType) {\n+            return ops.stream().filter(filterType::isInstance).collect(Collectors.toSet());\n+        }\n+\n+        private static final Map<OptionScope, String> KNOWN_BUNDLING_OPERATIONS = Map.of(\n+                StandardBundlingOperation.CREATE_WIN_APP_IMAGE, \"app-image-win\",\n+                StandardBundlingOperation.CREATE_LINUX_APP_IMAGE, \"app-image-linux\",\n+                StandardBundlingOperation.CREATE_MAC_APP_IMAGE, \"app-image-mac\",\n+                StandardBundlingOperation.CREATE_WIN_EXE, \"win-exe\",\n+                StandardBundlingOperation.CREATE_WIN_MSI, \"win-msi\",\n+                StandardBundlingOperation.CREATE_LINUX_RPM, \"linux-rpm\",\n+                StandardBundlingOperation.CREATE_LINUX_DEB, \"linux-deb\",\n+                StandardBundlingOperation.CREATE_MAC_PKG, \"mac-pkg\",\n+                StandardBundlingOperation.CREATE_MAC_DMG, \"mac-dmg\",\n+                StandardBundlingOperation.SIGN_MAC_APP_IMAGE, \"mac-sign\"\n+        );\n+\n+        private static final Map<Set<OptionScope>, String> KNOWN_SCOPES = Map.of(\n+                Set.copyOf(StandardBundlingOperation.CREATE_APP_IMAGE), \"app-image\",\n+                Set.copyOf(StandardBundlingOperation.WINDOWS), \"win\",\n+                Set.copyOf(StandardBundlingOperation.MACOS), \"mac\",\n+                Set.of(StandardBundlingOperation.CREATE_MAC_APP_IMAGE, StandardBundlingOperation.CREATE_MAC_DMG, StandardBundlingOperation.CREATE_MAC_PKG), \"mac-bundle\",\n+                Set.copyOf(StandardBundlingOperation.LINUX), \"linux\",\n+                Set.copyOf(StandardBundlingOperation.CREATE_NATIVE), \"native-bundle\",\n+                Set.copyOf(StandardBundlingOperation.CREATE_BUNDLE), \"bundle\",\n+                Set.of(StandardBundlingOperation.values()), \"all\"\n+        );\n+    }\n+\n+    private static final Path GOLDEN_JPACKAGE_OPTIONS_MD = TKit.TEST_SRC_ROOT.resolve(\n+            \"junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/jpackage-options.md\");\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardOptionTest.java","additions":640,"deletions":0,"binary":false,"changes":640,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.Files;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.jpackage.test.JUnitUtils.ExceptionPattern;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.cli.Validator.ValidatingConsumerException;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.DisabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class StandardValidatorTest {\n+\n+    @Test\n+    public void test_IS_DIRECTORY(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_DIRECTORY;\n+\n+        assertTrue(testee.test(tempDir));\n+        assertFalse(testee.test(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        assertFalse(testee.test(file));\n+        assertTrue(testee.test(tempDir));\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @Test\n+    public void test_IS_FILE_OR_SYMLINK(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_FILE_OR_SYMLINK;\n+\n+        assertFalse(testee.test(tempDir));\n+        assertFalse(testee.test(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        assertTrue(testee.test(file));\n+        assertFalse(testee.test(tempDir));\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    public void test_IS_FILE_OR_SYMLINK_symlink_file(@TempDir Path tempDir) throws IOException {\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        final var symlink = Files.createSymbolicLink(tempDir.resolve(\"foo-symlink\"), file);\n+\n+        assertTrue(StandardValidator.IS_FILE_OR_SYMLINK.test(symlink));\n+    }\n+\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    public void test_IS_FILE_OR_SYMLINK_symlink_dir(@TempDir Path tempDir) throws IOException {\n+\n+        final var symlink = Files.createSymbolicLink(tempDir.resolve(\"foo-symlink\"), tempDir);\n+\n+        assertFalse(StandardValidator.IS_FILE_OR_SYMLINK.test(symlink));\n+    }\n+\n+    @Test\n+    @DisabledOnOs(OS.WINDOWS)\n+    public void test_IS_FILE_OR_SYMLINK_symlink_invalid(@TempDir Path tempDir) throws IOException {\n+\n+        final var symlink = Files.createSymbolicLink(tempDir.resolve(\"foo-symlink\"), tempDir.resolve(\"foo\"));\n+\n+        assertFalse(StandardValidator.IS_FILE_OR_SYMLINK.test(symlink));\n+    }\n+\n+    @Test\n+    public void test_IS_DIRECTORY_OR_NON_EXISTENT(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_DIRECTORY_OR_NON_EXISTENT;\n+\n+        assertTrue(testee.test(tempDir));\n+        assertTrue(testee.test(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        assertFalse(testee.test(file));\n+        assertTrue(testee.test(tempDir));\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @Test\n+    public void test_IS_DIRECTORY_EMPTY_OR_NON_EXISTENT(@TempDir Path tempDir) throws IOException {\n+\n+        final var testee = StandardValidator.IS_DIRECTORY_EMPTY_OR_NON_EXISTENT;\n+\n+        assertDoesNotThrow(() -> testee.accept(tempDir));\n+        assertDoesNotThrow(() -> testee.accept(tempDir.resolve(\"foo\")));\n+\n+        final var file = tempDir.resolve(\"foo\");\n+        Files.writeString(file, \"foo\");\n+\n+        var cause = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(file)).getCause();\n+        assertEquals(NotDirectoryException.class, cause.getClass());\n+\n+        cause = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(tempDir)).getCause();\n+        assertEquals(DirectoryNotEmptyException.class, cause.getClass());\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.accept(null));\n+    }\n+\n+    @Test\n+    public void test_IS_URL() {\n+\n+        final var testee = StandardValidator.IS_URL;\n+\n+        assertDoesNotThrow(() -> testee.accept(\"http:\/\/foo\"));\n+\n+        final var ex = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(\":\"));\n+\n+        assertNotNull(ex.getCause());\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.accept(null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_IS_NAME_VALID_valid(String name) {\n+\n+        final var testee = StandardValidator.IS_NAME_VALID;\n+\n+        assertTrue(testee.test(name));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_IS_NAME_VALID_invalid(String name) {\n+\n+        final var testee = StandardValidator.IS_NAME_VALID;\n+\n+        assertFalse(testee.test(name));\n+    }\n+\n+    @Test\n+    public void test_IS_NAME_VALID_null() {\n+\n+        final var testee = StandardValidator.IS_NAME_VALID;\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.test(null));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"Foo\", \"1\", \"public\"})\n+    public void test_IS_CLASSNAME_valid(String classname) {\n+\n+        final var testee = StandardValidator.IS_CLASSNAME;\n+\n+        testee.accept(classname);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"\", \"a\/b\"})\n+    public void test_IS_CLASSNAME_invalid(String classname) {\n+\n+        final var testee = StandardValidator.IS_CLASSNAME;\n+\n+        final var ex = assertThrowsExactly(ValidatingConsumerException.class, () -> testee.accept(classname));\n+\n+        assertTrue(new ExceptionPattern().isCauseInstanceOf(IllegalArgumentException.class).match(ex));\n+    }\n+\n+    @Test\n+    public void test_IS_CLASSNAME_null() {\n+\n+        final var testee = StandardValidator.IS_CLASSNAME;\n+\n+        assertThrowsExactly(NullPointerException.class, () -> testee.accept(null));\n+    }\n+\n+    private static Stream<Arguments> test_IS_NAME_VALID_valid() {\n+        List<String> data = new ArrayList<>();\n+        data.addAll(List.of(\n+                \"a\",\n+                \"a!\",\n+                \"name with space\"\n+        ));\n+\n+        if (!OperatingSystem.isWindows()) {\n+            data.addAll(List.of(\"a?\", \"*foo*\"));\n+        }\n+\n+        return data.stream().map(Arguments::of);\n+    }\n+\n+    private static Stream<Arguments> test_IS_NAME_VALID_invalid() {\n+        List<String> data = new ArrayList<>();\n+        data.addAll(List.of(\n+                \" \",\n+                \"a\\0b\",\n+                \"foo \",\n+                \"\",\n+                \"a\/b\",\n+                \"a\\\\b\",\n+                \"ab\\\\\",\n+                \"ab\/\",\n+                \"a%b\",\n+                \"a\\\"b\"\n+        ));\n+\n+        if (OperatingSystem.isWindows()) {\n+            data.addAll(List.of(\"a?\", \"*foo*\"));\n+        }\n+\n+        return data.stream().map(Arguments::of);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardValidatorTest.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+import jdk.jpackage.internal.model.LauncherShortcut;\n+import jdk.jpackage.internal.model.LauncherShortcutStartupDirectory;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+public class StandardValueConverterTest {\n+\n+    @Test\n+    public void test_identityConv() {\n+\n+        final var testee = StandardValueConverter.identityConv();\n+\n+        assertEquals(\"foo\", testee.convert(\"foo\"));\n+    }\n+\n+    @Test\n+    public void testNullValue() {\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.identityConv().convert(null));\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.pathConv().convert(null));\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.uuidConv().convert(null));\n+        assertThrowsExactly(NullPointerException.class, () -> StandardValueConverter.booleanConv().convert(null));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test_pathConv(boolean positive) {\n+\n+        final var testee = StandardValueConverter.pathConv();\n+\n+        if (positive) {\n+            assertEquals(Path.of(\"foo\"), testee.convert(\"foo\"));\n+        } else {\n+            final var ex = assertThrowsExactly(IllegalArgumentException.class, () -> testee.convert(\"\\0\"));\n+            assertNotNull(ex.getCause());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_booleanConv(String value, Boolean expected) {\n+\n+        assertEquals(expected, StandardValueConverter.booleanConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_mainLauncherShortcutConv(String value, LauncherShortcut expected) {\n+\n+        assertEquals(expected, StandardValueConverter.mainLauncherShortcutConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_mainLauncherShortcutConv_invalid(String value) {\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StandardValueConverter.mainLauncherShortcutConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_addLauncherShortcutConv(String value, LauncherShortcut expected) {\n+\n+        assertEquals(expected, StandardValueConverter.addLauncherShortcutConv().convert(value));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    @Disabled(\"There is no invalid string value!\")\n+    public void test_addLauncherShortcutConv_invalid(String value) {\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StandardValueConverter.addLauncherShortcutConv().convert(value));\n+    }\n+\n+    private static List<Object[]> test_booleanConv() {\n+        return List.<Object[]>of(\n+                booleanConvTestCase(\"\", false),\n+                booleanConvTestCase(\"true\", true),\n+                booleanConvTestCase(\"True\", true),\n+                booleanConvTestCase(\"TRUE\", true),\n+                booleanConvTestCase(\"true2\", false),\n+                booleanConvTestCase(\"false\", false),\n+                booleanConvTestCase(\"false2\", false)\n+        );\n+    }\n+\n+    private static Object[] booleanConvTestCase(String value, boolean expected) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(expected);\n+        return new Object[] { value, expected };\n+    }\n+\n+    private static List<Object[]> test_mainLauncherShortcutConv() {\n+        return List.<Object[]>of(\n+                launcherShortcutConvTestCase(\"app-dir\", new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR))\n+        );\n+    }\n+\n+    private static List<Arguments> test_mainLauncherShortcutConv_invalid() {\n+        return List.of(\n+                Arguments.of(\"true\"),\n+                Arguments.of(\"false\"),\n+                Arguments.of(\"App-dir\"),\n+                Arguments.of(\"APP-DIR\")\n+        );\n+    }\n+\n+    private static List<Object[]> test_addLauncherShortcutConv() {\n+        return List.<Object[]>of(\n+                launcherShortcutConvTestCase(\"app-dir\", new LauncherShortcut(LauncherShortcutStartupDirectory.APP_DIR)),\n+                launcherShortcutConvTestCase(\"true\", new LauncherShortcut(LauncherShortcutStartupDirectory.DEFAULT)),\n+                launcherShortcutConvTestCase(\"false\", new LauncherShortcut()),\n+                launcherShortcutConvTestCase(\"APP-DIR\", new LauncherShortcut())\n+        );\n+    }\n+\n+    private static List<Arguments> test_addLauncherShortcutConv_invalid() {\n+        return List.of(\n+        );\n+    }\n+\n+    private static Object[] launcherShortcutConvTestCase(String value, LauncherShortcut expected) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(expected);\n+        return new Object[] { value, expected };\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StandardValueConverterTest.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import org.junit.jupiter.api.Test;\n+\n+public class StringTokenTest {\n+\n+    @Test\n+    public void test() {\n+        assertToken(\"abc\", \"a\", StringToken.of(\"abc\", \"a\"));\n+        assertToken(\"abc\", \"\", StringToken.of(\"abc\", \"\"));\n+        assertToken(\"abc\", \"abc\", StringToken.of(\"abc\"));\n+        assertToken(\"\", \"\", StringToken.of(\"\"));\n+        assertToken(\"abc\", \"bc\", StringToken.of(\"abc\", \"bc\"));\n+\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StringToken.of(\"abc\", \"d\"));\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StringToken.of(\"abc\", \"cb\"));\n+        assertThrowsExactly(IllegalArgumentException.class, () -> StringToken.of(\"abc\", \"abcd\"));\n+    }\n+\n+    private static void assertToken(String expectedTokenizedString, String expectedValue, StringToken token) {\n+        assertEquals(expectedTokenizedString, token.tokenizedString());\n+        assertEquals(expectedValue, token.value());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/StringTokenTest.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.StreamSupport;\n+import jdk.jpackage.test.JUnitUtils;\n+\n+final class TestUtils {\n+\n+    private TestUtils() {\n+    }\n+\n+    static UnaryOperator<OptionValueExceptionFactory<? extends RuntimeException>> recordExceptions(Collection<OptionFailure> sink) {\n+        return exceptionFactory -> {\n+            return new RecordingExceptionFactory(exceptionFactory, sink::add);\n+        };\n+    }\n+\n+    static <T> Consumer<Validator.Builder<T, RuntimeException>> configureValidator() {\n+        return builder -> {\n+            builder.exceptionFactory(DEFAULT_EXCEPTION_FACTORY).formatString(DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING);\n+        };\n+    }\n+\n+    static <T> Consumer<Validator.Builder<T, Exception>> configureCheckedValidator() {\n+        return builder -> {\n+            builder.exceptionFactory(DEFAULT_EXCEPTION_FACTORY).formatString(DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING);\n+        };\n+    }\n+\n+    static <T> Consumer<OptionValueConverter.Builder<T>> configureConverter() {\n+        return builder -> {\n+            builder.exceptionFactory(DEFAULT_EXCEPTION_FACTORY).formatString(DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING);\n+        };\n+    }\n+\n+    static void assertExceptionEquals(Exception expected, Exception actual) {\n+        assertEquals(JUnitUtils.exceptionAsPropertyMap(expected), JUnitUtils.exceptionAsPropertyMap(actual));\n+    }\n+\n+    static void assertExceptionListEquals(Collection<? extends Exception> expected, Collection<? extends Exception> actual) {\n+        assertEquals(\n+                expected.stream().map(JUnitUtils::exceptionAsPropertyMap).toList(),\n+                actual.stream().map(JUnitUtils::exceptionAsPropertyMap).toList()\n+        );\n+    }\n+\n+\n+    static Function<String, String[]> splitOrEmpty(String splitRegexp) {\n+        Objects.requireNonNull(splitRegexp);\n+        return str -> {\n+            if (str.isEmpty()) {\n+                return new String[0];\n+            } else {\n+                return str.split(splitRegexp);\n+            }\n+        };\n+    }\n+\n+    static <T> List<T[]> arrayElements(Class<? extends T> elementType, Iterable<T> elements) {\n+        Objects.requireNonNull(elementType);\n+        return StreamSupport.stream(elements.spliterator(), false).map(e -> {\n+            @SuppressWarnings(\"unchecked\")\n+            final var arr = (T[])Array.newInstance(elementType, e == null ? 0 : 1);\n+            if (e != null) {\n+                Array.set(arr, 0, e);\n+            }\n+            return arr;\n+        }).toList();\n+    }\n+\n+\n+    record OptionFailure(OptionName optionName, StringToken optionValue, Optional<Exception> exception) {\n+        OptionFailure {\n+            Objects.requireNonNull(optionName);\n+            Objects.requireNonNull(optionValue);\n+            Objects.requireNonNull(exception);\n+        }\n+\n+        OptionFailure(OptionName optionName, StringToken optionValue) {\n+            this(optionName, optionValue, Optional.empty());\n+        }\n+\n+        OptionFailure(String optionName, StringToken optionValue) {\n+            this(OptionName. of(optionName), optionValue);\n+        }\n+\n+        OptionFailure(OptionName optionName, String optionValue) {\n+            this(optionName, StringToken.of(optionValue));\n+        }\n+\n+        OptionFailure(String optionName, String optionValue) {\n+            this(OptionName. of(optionName), optionValue);\n+        }\n+\n+        OptionFailure withoutException() {\n+            return exception.map(_ -> new OptionFailure(optionName, optionValue, Optional.empty())).orElse(this);\n+        }\n+\n+        static Comparator<OptionFailure> compareNameAndValue() {\n+            return Comparator.comparing(OptionFailure::optionName).thenComparing(v -> {\n+                return v.optionValue().value();\n+            }).thenComparing(v -> {\n+                return v.optionValue().tokenizedString();\n+            });\n+        }\n+    }\n+\n+\n+    static final class TestException extends RuntimeException {\n+\n+        TestException(String msg) {\n+            super(msg);\n+        }\n+\n+        TestException(String msg, Throwable cause) {\n+            super(msg, cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    private record RecordingExceptionFactory(OptionValueExceptionFactory<? extends RuntimeException> factory,\n+            Consumer<OptionFailure> sink) implements OptionValueExceptionFactory<RuntimeException> {\n+\n+        RecordingExceptionFactory {\n+            Objects.requireNonNull(factory);\n+            Objects.requireNonNull(sink);\n+        }\n+\n+        @Override\n+        public RuntimeException create(OptionName optionName, StringToken optionValue, String formatString, Optional<Exception> cause) {\n+            final var ex = factory.create(optionName, optionValue, formatString, cause);\n+            sink.accept(new OptionFailure(optionName, optionValue, Optional.of(ex)));\n+            return ex;\n+        }\n+    }\n+\n+    private static final String DEFAULT_EXCEPTION_MESSAGE_FORMAT_STRING = \"Option %s: bad substring [%s] in string [%s]\";\n+\n+    private static final OptionValueExceptionFactory<? extends RuntimeException> DEFAULT_EXCEPTION_FACTORY = OptionValueExceptionFactory.build(TestException::new)\n+            .formatArgumentsTransformer((String formattedOptionName, StringToken optionValue) -> {\n+                return new String[] { formattedOptionName, optionValue.value(), optionValue.tokenizedString() };\n+            })\n+            .messageFormatter(String::format)\n+            .create();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/TestUtils.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static java.util.stream.Collectors.toUnmodifiableSet;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Optional;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.BundlingEnvironment;\n+import jdk.jpackage.internal.model.BundlingOperationDescriptor;\n+import jdk.jpackage.test.JUnitUtils.ExceptionPattern;\n+import org.junit.jupiter.api.Test;\n+\n+public class UtilsTest {\n+\n+    @Test\n+    public void testInvalidOption() {\n+        var errors = buildParser().create().apply(new String[] {\"--foo\"}).errors();\n+        assertEquals(1, errors.size());\n+\n+        assertTrue(new ExceptionPattern()\n+                .isInstanceOf(Utils.ParseException.class)\n+                .hasMessage(I18N.format(\"ERR_InvalidOption\", \"--foo\"))\n+                .match(errors.iterator().next()));\n+    }\n+\n+    @Test\n+    public void testMissingValueOption() {\n+        var errors = buildParser().create().apply(new String[] {\"--name\"}).errors();\n+        assertEquals(1, errors.size());\n+\n+        assertTrue(new ExceptionPattern()\n+                .isInstanceOf(Utils.ParseException.class)\n+                .hasMessage(I18N.format(\"ERR_InvalidOption\", \"--name\"))\n+                .match(errors.iterator().next()));\n+    }\n+\n+    @Test\n+    public void test_getOptionsWithSpecs() {\n+\n+        var options = Utils.getOptionsWithSpecs(UtilsTest.class).map(OptionValue::getOption).collect(toUnmodifiableSet());\n+\n+        assertEquals(2, options.size());\n+\n+        assertFalse(options.contains(A.getOption()));\n+        assertTrue(options.contains(B.getOption()));\n+        assertTrue(options.contains(C.getOption()));\n+    }\n+\n+    private static final OptionValue<String> A = dummyOptionValue(\"a\");\n+\n+    static final OptionValue<String> B = dummyOptionValue(\"b\");\n+\n+    public static final OptionValue<String> C = dummyOptionValue(\"c\");\n+\n+    private static OptionValue<String> dummyOptionValue(String name) {\n+        return OptionSpecBuilder.create(String.class).name(name).scope(new OptionScope() {}).create();\n+    }\n+\n+    private static JOptSimpleOptionsBuilder buildParser() {\n+        return Utils.buildParser(OperatingSystem.LINUX, new BundlingEnvironment() {\n+            @Override\n+            public Optional<BundlingOperationDescriptor> defaultOperation() {\n+                return Optional.empty();\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/UtilsTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.cli;\n+\n+import static jdk.jpackage.internal.cli.TestUtils.assertExceptionListEquals;\n+import static jdk.jpackage.internal.cli.TestUtils.configureCheckedValidator;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.cli.TestUtils.TestException;\n+import jdk.jpackage.internal.cli.Validator.ParsedValue;\n+import jdk.jpackage.internal.cli.Validator.ValidatingConsumerException;\n+import jdk.jpackage.internal.cli.Validator.ValidatorException;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class ValidatorTest {\n+\n+    enum ValidatorType {\n+        PREDICATE,\n+        CONSUMER\n+    }\n+\n+\n+    @ParameterizedTest\n+    @EnumSource(ValidatorType.class)\n+    public void test(ValidatorType type) {\n+\n+        final Validator.Builder<Object, Exception> builder = Validator.build();\n+\n+        switch (type) {\n+            case CONSUMER -> builder.consumer(_ -> {});\n+            case PREDICATE -> builder.predicate(_ -> true);\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        final var validator = builder.mutate(configureCheckedValidator()).create();\n+\n+        final var optionName = OptionName.of(\"obj\");\n+        final var optionValue = ParsedValue.create(new Object(), StringToken.of(\"foo\"));\n+        assertEquals(List.of(), validator.validate(optionName, optionValue));\n+    }\n+\n+    @Test\n+    public void test_predicate_negative() {\n+\n+        final var validator =  Validator.build().predicate(_ -> false).mutate(configureCheckedValidator()).create();\n+\n+        final var optionName = OptionName.of(\"obj\");\n+        final var optionValue = ParsedValue.create(new Object(), StringToken.of(\"foo\"));\n+\n+        final var exceptions = validator.validate(optionName, optionValue);\n+        assertExceptionListEquals(List.of(new TestException(\"Option --obj: bad substring [foo] in string [foo]\")), exceptions);\n+    }\n+\n+\n+    enum ValidatorConsumerType {\n+        CONSUMER_IllegalArgumentException,\n+        CONSUMER_ValidatingConsumerException\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void test_consumer_negative(ValidatorConsumerType type, boolean withCause) {\n+\n+        final Validator.Builder<Object, Exception> builder = Validator.build();\n+\n+        final Exception cause;\n+        if (withCause) {\n+            cause = new FooException(\"foo cause\");\n+        } else {\n+            cause = null;\n+        }\n+\n+        final RuntimeException validatorException;\n+        final Exception expectedCause;\n+\n+        switch (type) {\n+            case CONSUMER_IllegalArgumentException -> {\n+                validatorException = new IllegalArgumentException(\"Invalid value\", cause);\n+                expectedCause = validatorException;\n+            }\n+\n+            case CONSUMER_ValidatingConsumerException -> {\n+                if (cause != null) {\n+                    validatorException = new ValidatingConsumerException(\"Invalid value\", cause);\n+                    expectedCause = cause;\n+                } else {\n+                    assertThrows(NullPointerException.class, () -> {\n+                        new ValidatingConsumerException(\"Invalid value\", cause);\n+                    });\n+                    return;\n+                }\n+            }\n+\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        final var validator = builder.consumer(_ -> {\n+            throw validatorException;\n+        }).mutate(configureCheckedValidator()).create();\n+\n+        final var optionName = OptionName.of(\"obj\");\n+        final var optionValue = ParsedValue.create(new Object(), StringToken.of(\"foo\"));\n+\n+        final var exceptions = validator.validate(optionName, optionValue);\n+        assertExceptionListEquals(List.of(new TestException(\"Option --obj: bad substring [foo] in string [foo]\", expectedCause)), exceptions);\n+    }\n+\n+    @Test\n+    public void testBuilderWithoutExceptionOrFormatStringFactory() {\n+\n+        Supplier<Validator.Builder<String, RuntimeException>> build = () -> {\n+            return Validator.<String, RuntimeException>build().predicate(_ -> true);\n+        };\n+\n+        build.get().create();\n+        build.get().formatString(null).create();\n+        assertThrowsExactly(NullPointerException.class, build.get().formatString(\"foo\")::create);\n+        assertThrowsExactly(NullPointerException.class, build.get().formatString(\"\")::create);\n+        assertThrowsExactly(NullPointerException.class, build.get().formatString(null).exceptionFactory(OptionValueExceptionFactory.unreachable())::create);\n+    }\n+\n+    @Test\n+    public void testBuilderCopy() {\n+\n+        var builder = Validator.<String, RuntimeException>build()\n+                .predicate(_ -> true)\n+                .formatString(\"foo\")\n+                .exceptionFactory(OptionValueExceptionFactory.unreachable());\n+\n+        var copy = builder.copy();\n+\n+        assertSame(builder.consumer().orElse(null), copy.consumer().orElse(null));\n+        assertSame(builder.predicate().orElse(null), copy.predicate().orElse(null));\n+        assertSame(builder.exceptionFactory().orElse(null), copy.exceptionFactory().orElse(null));\n+        assertSame(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+\n+        builder.consumer(_ -> {});\n+\n+        copy = builder.copy();\n+\n+        assertSame(builder.consumer().orElse(null), copy.consumer().orElse(null));\n+        assertSame(builder.predicate(), copy.predicate());\n+        assertSame(builder.exceptionFactory().orElse(null), copy.exceptionFactory().orElse(null));\n+        assertSame(builder.formatString().orElse(null), copy.formatString().orElse(null));\n+\n+        copy.predicate(_ -> false);\n+\n+        assertNotSame(builder.consumer(), copy.consumer());\n+        assertNotSame(builder.predicate(), copy.predicate());\n+    }\n+\n+    @Test\n+    public void test_andThen() {\n+\n+        Function<String, Validator<String, Exception>> createFailingValidator = exceptionMessage -> {\n+            Objects.requireNonNull(exceptionMessage);\n+            var exceptionFactory = OptionValueExceptionFactory.build().ctor(TestException::new).messageFormatter((_, _) -> {\n+                return exceptionMessage;\n+            }).create();\n+\n+            return Validator.<String, Exception>build()\n+                    .predicate(_ -> false)\n+                    .formatString(\"\")\n+                    .exceptionFactory(exceptionFactory).create();\n+        };\n+\n+        Function<Validator<String, ? extends Exception>, List<? extends Exception>> validate = validator -> {\n+            return validator.validate(OptionName.of(\"a\"), ParsedValue.create(\"str\", StringToken.of(\"str\")));\n+        };\n+\n+        var pass = Validator.<String, RuntimeException>build().predicate(_ -> true).create();\n+\n+        var foo = createFailingValidator.apply(\"foo\");\n+        var bar = createFailingValidator.apply(\"bar\");\n+        var buz = createFailingValidator.apply(\"buz\");\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"bar\"),\n+                new TestException(\"buz\")\n+        ),  validate.apply(foo.andThen(bar).andThen(pass).andThen(buz)));\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"bar\"),\n+                new TestException(\"buz\"),\n+                new TestException(\"foo\")\n+        ),  validate.apply(pass.andThen(bar).andThen(buz).andThen(foo)));\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"foo\")\n+        ),  validate.apply(foo.andThen(foo)));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(ValidatorType.class)\n+    public void testValidatorException(ValidatorType type) {\n+\n+        final Validator.Builder<String, Exception> builder = Validator.build();\n+\n+        switch (type) {\n+            case CONSUMER -> builder.consumer(_ -> {\n+                throw VALITDATOR_EXCEPTION;\n+            });\n+\n+            case PREDICATE -> builder.predicate(_ -> {\n+                throw VALITDATOR_EXCEPTION;\n+            });\n+\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+\n+        final var validator = builder.mutate(configureCheckedValidator()).create();\n+\n+        final var token = StringToken.of(\"foo\");\n+        final var ex = assertThrowsExactly(ValidatorException.class, () -> {\n+            validator.validate(OptionName.of(\"foo\"), ParsedValue.create(token.value(), token));\n+        });\n+\n+        assertSame(VALITDATOR_EXCEPTION, ex.getCause());\n+    }\n+\n+    private static List<Object[]> test_consumer_negative() {\n+        final List<Object[]> data = new ArrayList<>();\n+        for (var type : ValidatorConsumerType.values()) {\n+            for (var withCause : List.of(true, false)) {\n+                data.add(new Object[] { type, withCause });\n+            }\n+        }\n+        return data;\n+    }\n+\n+\n+    static final class FooException extends Exception {\n+\n+        FooException(String msg) {\n+            super(msg);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+\n+    static final RuntimeException VALITDATOR_EXCEPTION = new RuntimeException(\"Always fail\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/ValidatorTest.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+Usage: jpackage <options>\n+\n+Sample usages:\n+--------------\n+    Generate an application package suitable for the host system:\n+        For a modular application:\n+            jpackage -n name -p modulePath -m moduleName\/className\n+        For a non-modular application:\n+            jpackage -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        From a pre-built application image:\n+            jpackage -n name --app-image appImageDir\n+\n+    Generate an application image:\n+        For a modular application:\n+            jpackage --type app-image -n name -p modulePath \\\n+                -m moduleName\/className\n+        For a non-modular application:\n+            jpackage --type app-image -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        To provide your own options to jlink, run jlink separately:\n+            jlink --output appRuntimeImage -p modulePath \\\n+                --add-modules moduleName \\\n+                --no-header-files [<additional jlink options>...]\n+            jpackage --type app-image -n name \\\n+                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+    Generate a Java runtime package:\n+        jpackage -n name --runtime-image <runtime-image>\n+\n+Generic Options:\n+  @<filename>\n+          Read options and\/or mode from a file\n+          This option can be used multiple times.\n+  --type -t <type>\n+          The type of package to create\n+          Valid values are: {\"app-image\", \"deb\", \"rpm\"}\n+          If this option is not specified a platform dependent\n+          default type will be created.\n+  --app-version <version>\n+          Version of the application and\/or package\n+  --copyright <copyright string>\n+          Copyright for the application\n+  --description <description string>\n+          Description of the application\n+  --dest -d <destination path>\n+          Path where generated output file is placed\n+          (absolute path or relative to the current directory)\n+          Defaults to the current working directory.\n+  --help -h -?\n+          Print the usage text with a list and description of each valid\n+          option for the current platform to the output stream, and exit\n+  --icon <file path>\n+          Path of the icon of the application package\n+          (absolute path or relative to the current directory)\n+  --name -n <name>\n+          Name of the application and\/or package\n+  --temp <directory path>\n+          Path of a new or empty directory used to create temporary files\n+          (absolute path or relative to the current directory)\n+          If specified, the temp dir will not be removed upon the task\n+          completion and must be removed manually.\n+          If not specified, a temporary directory will be created and\n+          removed upon the task completion.\n+  --vendor <vendor string>\n+          Vendor of the application\n+  --verbose\n+          Enables verbose output\n+  --version\n+          Print the product version to the output stream and exit.\n+\n+Options for creating the runtime image:\n+  --add-modules <module name>[,<module name>...]\n+          A comma (\",\") separated list of modules to add\n+          This module list, along with the main module (if specified)\n+          will be passed to jlink as the --add-module argument.\n+          If not specified, either just the main module (if --module is\n+          specified), or the default set of modules (if --main-jar is\n+          specified) are used.\n+          This option can be used multiple times.\n+  --jlink-options <jlink options>\n+          A space separated list of options to pass to jlink\n+          If not specified, defaults to \"--strip-native-commands\n+          --strip-debug --no-man-pages --no-header-files\".\n+          This option can be used multiple times.\n+  --module-path -p <module path>[:<module path>...]\n+          A : separated list of paths\n+          Each path is either a directory of modules or the path to a\n+          modular jar.\n+          (Each path is absolute or relative to the current directory.)\n+          This option can be used multiple times.\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image that will be copied into\n+          the application image\n+          (absolute path or relative to the current directory)\n+          If --runtime-image is not specified, jpackage will run jlink to\n+          create the runtime image using options:\n+          --strip-debug, --no-header-files, --no-man-pages, and\n+          --strip-native-commands.\n+\n+Options for creating the application image:\n+  --app-content <additional content>[,<additional content>...]\n+          A comma separated list of paths to files and\/or directories\n+          to add to the application payload.\n+          This option can be used more than once.\n+  --input -i <directory path>\n+          Path of the input directory that contains the files to be packaged\n+          (absolute path or relative to the current directory)\n+          All files in the input directory will be packaged into the\n+          application image.\n+\n+Options for creating the application launcher(s):\n+  --add-launcher <launcher name>=<file path>\n+          Name of launcher, and a path to a Properties file that contains\n+          a list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\n+          \"launcher-as-service\", \"linux-shortcut\", \"main-class\", \"main-jar\",\n+          and \"module\" can be used.\n+          These options are added to, or used to overwrite, the original\n+          command line options to build an additional alternative launcher.\n+          The main application launcher will be built from the command line\n+          options. Additional alternative launchers can be built using\n+          this option, and this option can be used multiple times to\n+          build multiple additional launchers.\n+  --arguments <main class arguments>\n+          Command line arguments to pass to the main class if no command\n+          line arguments are given to the launcher\n+          This option can be used multiple times.\n+  --java-options <java options>\n+          Options to pass to the Java runtime\n+          This option can be used multiple times.\n+  --main-class <class name>\n+          Qualified name of the application main class to execute\n+          This option can only be used if --main-jar is specified.\n+  --main-jar <main jar file>\n+          The main JAR of the application; containing the main class\n+          (specified as a path relative to the input path)\n+          Either --module or --main-jar option can be specified but not\n+          both.\n+  --module -m <module name>[\/<main class>]\n+          The main module (and optionally main class) of the application\n+          This module must be located on the module path.\n+          When this option is specified, the main module will be linked\n+          in the Java runtime image.  Either --module or --main-jar\n+          option can be specified but not both.\n+\n+Options for creating the application package:\n+  --about-url <url>\n+          URL of the application's home page\n+  --app-image <directory path>\n+          Location of the predefined application image that is used\n+          to build an installable package\n+          (absolute path or relative to the current directory)\n+  --file-associations <file path>[:<file path>...]\n+          Path to a Properties file that contains list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\n+          can be used to describe the association.\n+          This option can be used multiple times.\n+  --install-dir <directory path>\n+          Absolute path of the installation directory of the application\n+  --launcher-as-service\n+          Request to create an installer that will register the main\n+          application launcher as a background service-type application.\n+  --license-file <file path>\n+          Path to the license file\n+          (absolute path or relative to the current directory)\n+  --resource-dir <directory path>\n+          Path to override jpackage resources\n+          Icons, template files, and other resources of jpackage can be\n+          over-ridden by adding replacement resources to this directory.\n+          (absolute path or relative to the current directory)\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image to install\n+          (absolute path or relative to the current directory)\n+          Option is required when creating a runtime package.\n+\n+Platform dependent options for creating the application package:\n+  --linux-app-category <category>\n+          Group value of the RPM <name>.spec file or\n+          Section value of DEB control file\n+  --linux-app-release <release>\n+          Release value of the RPM <name>.spec file or\n+          Debian revision value of the DEB control file\n+  --linux-deb-maintainer <email address>\n+          Maintainer for .deb package\n+  --linux-menu-group <menu-group-name>\n+          Menu group this application is placed in\n+  --linux-package-deps <package-dep-string>\n+          Required packages or capabilities for the application\n+  --linux-package-name <package name>\n+          Name for Linux package, defaults to the application name\n+  --linux-rpm-license-type <license type>\n+          Type of the license (\"License: <value>\" of the RPM .spec)\n+  --linux-shortcut [<shortcut startup directory>]\n+          Creates a shortcut for the application.\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/help-linux.txt","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+Usage: jpackage <options>\n+\n+Sample usages:\n+--------------\n+    Generate an application package suitable for the host system:\n+        For a modular application:\n+            jpackage -n name -p modulePath -m moduleName\/className\n+        For a non-modular application:\n+            jpackage -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        From a pre-built application image:\n+            jpackage -n name --app-image appImageDir\n+\n+    Generate an application image:\n+        For a modular application:\n+            jpackage --type app-image -n name -p modulePath \\\n+                -m moduleName\/className\n+        For a non-modular application:\n+            jpackage --type app-image -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        To provide your own options to jlink, run jlink separately:\n+            jlink --output appRuntimeImage -p modulePath \\\n+                --add-modules moduleName \\\n+                --no-header-files [<additional jlink options>...]\n+            jpackage --type app-image -n name \\\n+                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+    Generate a Java runtime package:\n+        jpackage -n name --runtime-image <runtime-image>\n+\n+    Sign the predefined application image:\n+        jpackage --type app-image --app-image <app-image> \\\n+            --mac-sign [<additional signing options>...]\n+        Note: the only additional options that are permitted in this mode are:\n+              the set of additional mac signing options and --verbose\n+\n+Generic Options:\n+  @<filename>\n+          Read options and\/or mode from a file\n+          This option can be used multiple times.\n+  --type -t <type>\n+          The type of package to create\n+          Valid values are: {\"app-image\", \"dmg\", \"pkg\"}\n+          If this option is not specified a platform dependent\n+          default type will be created.\n+  --app-version <version>\n+          Version of the application and\/or package\n+  --copyright <copyright string>\n+          Copyright for the application\n+  --description <description string>\n+          Description of the application\n+  --dest -d <destination path>\n+          Path where generated output file is placed\n+          (absolute path or relative to the current directory)\n+          Defaults to the current working directory.\n+  --help -h -?\n+          Print the usage text with a list and description of each valid\n+          option for the current platform to the output stream, and exit\n+  --icon <file path>\n+          Path of the icon of the application package\n+          (absolute path or relative to the current directory)\n+  --name -n <name>\n+          Name of the application and\/or package\n+  --temp <directory path>\n+          Path of a new or empty directory used to create temporary files\n+          (absolute path or relative to the current directory)\n+          If specified, the temp dir will not be removed upon the task\n+          completion and must be removed manually.\n+          If not specified, a temporary directory will be created and\n+          removed upon the task completion.\n+  --vendor <vendor string>\n+          Vendor of the application\n+  --verbose\n+          Enables verbose output\n+  --version\n+          Print the product version to the output stream and exit.\n+\n+Options for creating the runtime image:\n+  --add-modules <module name>[,<module name>...]\n+          A comma (\",\") separated list of modules to add\n+          This module list, along with the main module (if specified)\n+          will be passed to jlink as the --add-module argument.\n+          If not specified, either just the main module (if --module is\n+          specified), or the default set of modules (if --main-jar is\n+          specified) are used.\n+          This option can be used multiple times.\n+  --jlink-options <jlink options>\n+          A space separated list of options to pass to jlink\n+          If not specified, defaults to \"--strip-native-commands\n+          --strip-debug --no-man-pages --no-header-files\".\n+          This option can be used multiple times.\n+  --module-path -p <module path>[:<module path>...]\n+          A : separated list of paths\n+          Each path is either a directory of modules or the path to a\n+          modular jar.\n+          (Each path is absolute or relative to the current directory.)\n+          This option can be used multiple times.\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image that will be copied into\n+          the application image\n+          (absolute path or relative to the current directory)\n+          If --runtime-image is not specified, jpackage will run jlink to\n+          create the runtime image using options:\n+          --strip-debug, --no-header-files, --no-man-pages, and\n+          --strip-native-commands.\n+\n+Options for creating the application image:\n+  --app-content <additional content>[,<additional content>...]\n+          A comma separated list of paths to files and\/or directories\n+          to add to the application payload.\n+          This option can be used more than once.\n+          Note: The value should be a directory with the \"Resources\"\n+          subdirectory (or any other directory that is valid in the \"Contents\"\n+          directory of the application bundle). Otherwise, jpackage may produce\n+          invalid application bundle which may fail code signing and\/or\n+          notarization.\n+  --input -i <directory path>\n+          Path of the input directory that contains the files to be packaged\n+          (absolute path or relative to the current directory)\n+          All files in the input directory will be packaged into the\n+          application image.\n+\n+Options for creating the application launcher(s):\n+  --add-launcher <launcher name>=<file path>\n+          Name of launcher, and a path to a Properties file that contains\n+          a list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\n+          \"launcher-as-service\", \"main-class\", \"main-jar\", and \"module\"\n+          can be used.\n+          These options are added to, or used to overwrite, the original\n+          command line options to build an additional alternative launcher.\n+          The main application launcher will be built from the command line\n+          options. Additional alternative launchers can be built using\n+          this option, and this option can be used multiple times to\n+          build multiple additional launchers.\n+  --arguments <main class arguments>\n+          Command line arguments to pass to the main class if no command\n+          line arguments are given to the launcher\n+          This option can be used multiple times.\n+  --java-options <java options>\n+          Options to pass to the Java runtime\n+          This option can be used multiple times.\n+  --main-class <class name>\n+          Qualified name of the application main class to execute\n+          This option can only be used if --main-jar is specified.\n+  --main-jar <main jar file>\n+          The main JAR of the application; containing the main class\n+          (specified as a path relative to the input path)\n+          Either --module or --main-jar option can be specified but not\n+          both.\n+  --module -m <module name>[\/<main class>]\n+          The main module (and optionally main class) of the application\n+          This module must be located on the module path.\n+          When this option is specified, the main module will be linked\n+          in the Java runtime image.  Either --module or --main-jar\n+          option can be specified but not both.\n+\n+Options for creating the application package:\n+  --about-url <url>\n+          URL of the application's home page\n+  --app-image <directory path>\n+          Location of the predefined application image that is used\n+          to build an installable package or to sign the predefined\n+          application image\n+          (absolute path or relative to the current directory)\n+  --file-associations <file path>[:<file path>...]\n+          Path to a Properties file that contains list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\n+          can be used to describe the association.\n+          This option can be used multiple times.\n+  --install-dir <directory path>\n+          Absolute path of the installation directory of the application\n+  --launcher-as-service\n+          Request to create an installer that will register the main\n+          application launcher as a background service-type application.\n+  --license-file <file path>\n+          Path to the license file\n+          (absolute path or relative to the current directory)\n+  --resource-dir <directory path>\n+          Path to override jpackage resources\n+          Icons, template files, and other resources of jpackage can be\n+          over-ridden by adding replacement resources to this directory.\n+          (absolute path or relative to the current directory)\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image to install\n+          (absolute path or relative to the current directory)\n+          Option is required when creating a runtime package.\n+\n+Platform dependent options for creating the application package:\n+  --mac-app-category <category>\n+          String used to construct LSApplicationCategoryType in\n+          application plist.  The default value is \"utilities\".\n+  --mac-app-image-sign-identity <identity>\n+          Identity used to sign application image. This value will be passed\n+          directly to --sign option of \"codesign\" tool. This option cannot\n+          be combined with --mac-signing-key-user-name.\n+  --mac-app-store\n+          Indicates that the jpackage output is intended for the\n+          Mac App Store.\n+  --mac-dmg-content <additional content path>[,<additional content path>...]\n+          Include all the referenced content in the dmg.\n+          This option can be used multiple times.\n+  --mac-entitlements <file path>\n+          Path to file containing entitlements to use when signing\n+          executables and libraries in the bundle.\n+  --mac-installer-sign-identity <identity>\n+          Identity used to sign \"pkg\" installer. This value will be passed\n+          directly to --sign option of \"productbuild\" tool. This option\n+          cannot be combined with --mac-signing-key-user-name.\n+  --mac-package-identifier <package identifier>\n+          An identifier that uniquely identifies the application for macOS\n+          Defaults to the main class name.\n+          May only use alphanumeric (A-Z,a-z,0-9), hyphen (-),\n+          and period (.) characters.\n+  --mac-package-name <package name>\n+          Name of the application as it appears in the Menu Bar\n+          This can be different from the application name.\n+          This name must be less than 16 characters long and be suitable for\n+          displaying in the menu bar and the application Info window.\n+          Defaults to the application name.\n+  --mac-package-signing-prefix <prefix>\n+          When signing the application package, this value is prefixed\n+          to all components that need to be signed that don't have\n+          an existing package identifier.\n+  --mac-sign -s\n+          Request that the package or the predefined application image be\n+          signed.\n+  --mac-signing-key-user-name <name>\n+          Team or user name portion of Apple signing identities. For direct\n+          control of the signing identity used to sign application images or\n+          installers use --mac-app-image-sign-identity and\/or\n+          --mac-installer-sign-identity. This option cannot be combined with\n+          --mac-app-image-sign-identity or --mac-installer-sign-identity.\n+  --mac-signing-keychain <keychain name>\n+          Name of the keychain to search for the signing identity\n+          If not specified, the standard keychains are used.\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/help-macos.txt","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+Usage: jpackage <options>\n+\n+Sample usages:\n+--------------\n+    Generate an application package suitable for the host system:\n+        For a modular application:\n+            jpackage -n name -p modulePath -m moduleName\/className\n+        For a non-modular application:\n+            jpackage -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        From a pre-built application image:\n+            jpackage -n name --app-image appImageDir\n+\n+    Generate an application image:\n+        For a modular application:\n+            jpackage --type app-image -n name -p modulePath \\\n+                -m moduleName\/className\n+        For a non-modular application:\n+            jpackage --type app-image -i inputDir -n name \\\n+                --main-class className --main-jar myJar.jar\n+        To provide your own options to jlink, run jlink separately:\n+            jlink --output appRuntimeImage -p modulePath \\\n+                --add-modules moduleName \\\n+                --no-header-files [<additional jlink options>...]\n+            jpackage --type app-image -n name \\\n+                -m moduleName\/className --runtime-image appRuntimeImage\n+\n+    Generate a Java runtime package:\n+        jpackage -n name --runtime-image <runtime-image>\n+\n+Generic Options:\n+  @<filename>\n+          Read options and\/or mode from a file\n+          This option can be used multiple times.\n+  --type -t <type>\n+          The type of package to create\n+          Valid values are: {\"app-image\", \"exe\", \"msi\"}\n+          If this option is not specified a platform dependent\n+          default type will be created.\n+  --app-version <version>\n+          Version of the application and\/or package\n+  --copyright <copyright string>\n+          Copyright for the application\n+  --description <description string>\n+          Description of the application\n+  --dest -d <destination path>\n+          Path where generated output file is placed\n+          (absolute path or relative to the current directory)\n+          Defaults to the current working directory.\n+  --help -h -?\n+          Print the usage text with a list and description of each valid\n+          option for the current platform to the output stream, and exit\n+  --icon <file path>\n+          Path of the icon of the application package\n+          (absolute path or relative to the current directory)\n+  --name -n <name>\n+          Name of the application and\/or package\n+  --temp <directory path>\n+          Path of a new or empty directory used to create temporary files\n+          (absolute path or relative to the current directory)\n+          If specified, the temp dir will not be removed upon the task\n+          completion and must be removed manually.\n+          If not specified, a temporary directory will be created and\n+          removed upon the task completion.\n+  --vendor <vendor string>\n+          Vendor of the application\n+  --verbose\n+          Enables verbose output\n+  --version\n+          Print the product version to the output stream and exit.\n+\n+Options for creating the runtime image:\n+  --add-modules <module name>[,<module name>...]\n+          A comma (\",\") separated list of modules to add\n+          This module list, along with the main module (if specified)\n+          will be passed to jlink as the --add-module argument.\n+          If not specified, either just the main module (if --module is\n+          specified), or the default set of modules (if --main-jar is\n+          specified) are used.\n+          This option can be used multiple times.\n+  --jlink-options <jlink options>\n+          A space separated list of options to pass to jlink\n+          If not specified, defaults to \"--strip-native-commands\n+          --strip-debug --no-man-pages --no-header-files\".\n+          This option can be used multiple times.\n+  --module-path -p <module path>[;<module path>...]\n+          A ; separated list of paths\n+          Each path is either a directory of modules or the path to a\n+          modular jar.\n+          (Each path is absolute or relative to the current directory.)\n+          This option can be used multiple times.\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image that will be copied into\n+          the application image\n+          (absolute path or relative to the current directory)\n+          If --runtime-image is not specified, jpackage will run jlink to\n+          create the runtime image using options:\n+          --strip-debug, --no-header-files, --no-man-pages, and\n+          --strip-native-commands.\n+\n+Options for creating the application image:\n+  --app-content <additional content>[,<additional content>...]\n+          A comma separated list of paths to files and\/or directories\n+          to add to the application payload.\n+          This option can be used more than once.\n+  --input -i <directory path>\n+          Path of the input directory that contains the files to be packaged\n+          (absolute path or relative to the current directory)\n+          All files in the input directory will be packaged into the\n+          application image.\n+\n+Options for creating the application launcher(s):\n+  --add-launcher <launcher name>=<file path>\n+          Name of launcher, and a path to a Properties file that contains\n+          a list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"arguments\", \"description\", \"icon\", \"java-options\",\n+          \"launcher-as-service\", \"main-class\", \"main-jar\", \"module\",\n+          \"win-console\", \"win-menu\", and \"win-shortcut\" can be used.\n+          These options are added to, or used to overwrite, the original\n+          command line options to build an additional alternative launcher.\n+          The main application launcher will be built from the command line\n+          options. Additional alternative launchers can be built using\n+          this option, and this option can be used multiple times to\n+          build multiple additional launchers.\n+  --arguments <main class arguments>\n+          Command line arguments to pass to the main class if no command\n+          line arguments are given to the launcher\n+          This option can be used multiple times.\n+  --java-options <java options>\n+          Options to pass to the Java runtime\n+          This option can be used multiple times.\n+  --main-class <class name>\n+          Qualified name of the application main class to execute\n+          This option can only be used if --main-jar is specified.\n+  --main-jar <main jar file>\n+          The main JAR of the application; containing the main class\n+          (specified as a path relative to the input path)\n+          Either --module or --main-jar option can be specified but not\n+          both.\n+  --module -m <module name>[\/<main class>]\n+          The main module (and optionally main class) of the application\n+          This module must be located on the module path.\n+          When this option is specified, the main module will be linked\n+          in the Java runtime image.  Either --module or --main-jar\n+          option can be specified but not both.\n+\n+Platform dependent option for creating the application launcher:\n+  --win-console\n+          Creates a console launcher for the application, should be\n+          specified for application which requires console interactions\n+\n+Options for creating the application package:\n+  --about-url <url>\n+          URL of the application's home page\n+  --app-image <directory path>\n+          Location of the predefined application image that is used\n+          to build an installable package\n+          (absolute path or relative to the current directory)\n+  --file-associations <file path>[;<file path>...]\n+          Path to a Properties file that contains list of key, value pairs\n+          (absolute path or relative to the current directory)\n+          The keys \"extension\", \"mime-type\", \"icon\", and \"description\"\n+          can be used to describe the association.\n+          This option can be used multiple times.\n+  --install-dir <directory path>\n+          Relative sub-path of the installation location of\n+          the application such as \"Program Files\" or \"AppData\".\n+  --launcher-as-service\n+          Request to create an installer that will register the main\n+          application launcher as a background service-type application.\n+  --license-file <file path>\n+          Path to the license file\n+          (absolute path or relative to the current directory)\n+  --resource-dir <directory path>\n+          Path to override jpackage resources\n+          Icons, template files, and other resources of jpackage can be\n+          over-ridden by adding replacement resources to this directory.\n+          (absolute path or relative to the current directory)\n+  --runtime-image <directory path>\n+          Path of the predefined runtime image to install\n+          (absolute path or relative to the current directory)\n+          Option is required when creating a runtime package.\n+\n+Platform dependent options for creating the application package:\n+  --win-dir-chooser\n+          Adds a dialog to enable the user to choose a directory in which\n+          the product is installed.\n+  --win-help-url <url>\n+          URL where user can obtain further information or technical support\n+  --win-menu [<shortcut startup directory>]\n+          Request to add a Start menu shortcut for this application\n+  --win-menu-group <menu group name>\n+          Start Menu group this application is placed in\n+  --win-per-user-install\n+          Request to perform an install on a per-user basis\n+  --win-shortcut [<shortcut startup directory>]\n+          Request to add desktop shortcut for this application\n+  --win-shortcut-prompt\n+          Adds a dialog to enable the user to choose if shortcuts\n+          will be created by installer.\n+  --win-update-url <url>\n+          URL of available application update information\n+  --win-upgrade-uuid <uuid>\n+          UUID associated with upgrades for this package\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/help-windows.txt","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+| Option | Scope | With runtime installer | With predefined app image | Recognized in add launcher .property file | Merge\n+| --- | --- | :---: | :---: | :---: | :---: |\n+| --about-url | native-bundle | x | x |  | USE_LAST |\n+| --add-launcher | bundle |  |  |  | CONCATENATE |\n+| --add-modules | bundle |  |  |  | CONCATENATE |\n+| --app-content | bundle |  |  |  | CONCATENATE |\n+| --app-image | mac-sign, native-bundle |  | x |  | USE_LAST |\n+| --app-version | bundle | x | x |  | USE_LAST |\n+| --arguments | bundle |  |  | x | CONCATENATE |\n+| --copyright | bundle | x | x |  | USE_LAST |\n+| --description | bundle | x | x | x | USE_LAST |\n+| --dest, -d | bundle | x | x |  | USE_LAST |\n+| --file-associations | bundle |  | x |  | CONCATENATE |\n+| --help, -h, -? | all | x | x |  | USE_LAST |\n+| --icon | bundle | x | x | x | USE_LAST |\n+| --input, -i | bundle |  |  |  | USE_LAST |\n+| --install-dir | bundle | x | x |  | USE_LAST |\n+| --java-options | bundle |  |  | x | CONCATENATE |\n+| --jlink-options | bundle |  |  |  | CONCATENATE |\n+| --launcher-as-service | native-bundle | x | x | x | USE_LAST |\n+| --license-file | bundle | x | x |  | USE_LAST |\n+| --linux-app-category | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-app-release | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-deb-maintainer | linux-deb | x | x |  | USE_LAST |\n+| --linux-menu-group | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-package-deps | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-package-name | linux-deb, linux-rpm | x | x |  | USE_LAST |\n+| --linux-rpm-license-type | linux-rpm | x | x |  | USE_LAST |\n+| --linux-shortcut | linux-deb, linux-rpm | x | x | x | USE_LAST |\n+| --mac-app-category | mac-bundle | x | x |  | USE_LAST |\n+| --mac-app-image-sign-identity | mac | x | x |  | USE_LAST |\n+| --mac-app-store | mac-bundle | x | x |  | USE_LAST |\n+| --mac-dmg-content | mac-dmg | x | x |  | CONCATENATE |\n+| --mac-entitlements | mac | x | x |  | USE_LAST |\n+| --mac-installer-sign-identity | mac-pkg | x | x |  | USE_LAST |\n+| --mac-package-identifier | mac-bundle | x | x |  | USE_LAST |\n+| --mac-package-name | mac-bundle | x | x |  | USE_LAST |\n+| --mac-package-signing-prefix | mac | x | x |  | USE_LAST |\n+| --mac-sign, -s | mac | x | x |  | USE_LAST |\n+| --mac-signing-key-user-name | mac | x | x |  | USE_LAST |\n+| --mac-signing-keychain | mac | x | x |  | USE_LAST |\n+| --main-class | bundle |  |  | x | USE_LAST |\n+| --main-jar | bundle |  |  | x | USE_LAST |\n+| --module, -m | bundle |  |  | x | USE_LAST |\n+| --module-path, -p | bundle |  |  |  | CONCATENATE |\n+| --name, -n | bundle | x | x |  | USE_LAST |\n+| --resource-dir | all | x | x |  | USE_LAST |\n+| --runtime-image | bundle | x |  |  | USE_LAST |\n+| --temp | bundle | x | x |  | USE_LAST |\n+| --type, -t | all | x | x |  | USE_LAST |\n+| --vendor | bundle | x | x |  | USE_LAST |\n+| --verbose | all | x | x |  | USE_LAST |\n+| --version | all | x | x |  | USE_LAST |\n+| --win-console | win |  |  | x | USE_LAST |\n+| --win-dir-chooser | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-help-url | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-menu | win-exe, win-msi | x | x | x | USE_LAST |\n+| --win-menu-group | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-per-user-install | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-shortcut | win-exe, win-msi | x | x | x | USE_LAST |\n+| --win-shortcut-prompt | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-update-url | win-exe, win-msi | x | x |  | USE_LAST |\n+| --win-upgrade-uuid | win-exe, win-msi | x | x |  | USE_LAST |\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/jpackage-options.md","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -177,1 +178,1 @@\n-                \"error.invalid-app-image\", appImageDir, AppImageFile.getPathInAppImage(appImageDir));\n+                \"error.invalid-app-image-file\", AppImageFile.getPathInAppImage(Path.of(\"\")), appImageDir);\n@@ -188,0 +189,18 @@\n+    \/**\n+     * Test building Linux package from the predefined app image with installation\n+     * directory in the \"\/usr\" subtree.\n+     *\/\n+    @Test(ifOS = OperatingSystem.LINUX)\n+    public static void testUsrInstallDir() {\n+        final var appImageCmd = createAppImageCommand();\n+\n+        new PackageTest()\n+        .addRunOnceInitializer(appImageCmd::execute)\n+        .usePredefinedAppImage(appImageCmd)\n+        .addBundleDesktopIntegrationVerifier(false)\n+        .addInitializer(cmd -> {\n+            cmd.addArguments(\"--install-dir\", \"\/usr\");\n+        })\n+        .run();\n+    }\n+\n@@ -189,2 +208,2 @@\n-        return configureBadAppImage(appImageDir,\n-                JPackageStringBundle.MAIN.cannedFormattedString(\"error.foreign-app-image\", appImageDir));\n+        return configureBadAppImage(appImageDir, JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"error.missing-app-image-file\", AppImageFile.getPathInAppImage(Path.of(\"\")), appImageDir));\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.IntStream;\n+import jdk.jpackage.internal.util.function.ThrowingRunnable;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JavaTool;\n+import jdk.jpackage.test.JavaAppDesc;\n+import jdk.jpackage.test.Main;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Runs multiple jpackage tool provider instances asynchronously\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror AsyncTest.java\n+ * @run main\/othervm\/timeout=1080 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=AsyncTest\n+ *\/\n+public class AsyncTest {\n+\n+    @Test\n+    public void test() throws Throwable {\n+\n+        \/\/ Create test jar only once.\n+        \/\/ Besides of saving time, this avoids asynchronous invocations of java tool provider that randomly fail.\n+        APP_JAR.set(HelloApp.createBundle(JavaAppDesc.parse(\"Hello!\"), TKit.workDir()));\n+\n+        \/\/\n+        \/\/ Run test cases from InternalAsyncTest class asynchronously.\n+        \/\/ Spawn a thread for every test case.\n+        \/\/ Input data for test cases will be cooked asynchronously but in a safe way because every test case has an isolated work directory.\n+        \/\/ Multiple jpackage tool provider instances will be invoked asynchronously.\n+        \/\/\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+\n+            var testFuncNames = List.of(\"testAppImage\", \"testNativeBundle\");\n+\n+            var runArg = String.format(\"--jpt-run=%s\", AsyncInnerTest.class.getName());\n+\n+            var futures = executor.invokeAll(IntStream.range(0, JOB_COUNT).mapToObj(Integer::toString).<Workload>mapMulti((idx, consumer) -> {\n+                for (var testFuncName : testFuncNames) {\n+                    var id = String.format(\"%s(%s)\", testFuncName, idx);\n+                    consumer.accept(new Workload(() -> {\n+                        Main.main(runArg, String.format(\"--jpt-include=%s\", id));\n+                    }, id));\n+                }\n+            }).toList());\n+\n+            \/\/ Wait for all test cases completion.\n+            for (var future : futures) {\n+                future.get(3, TimeUnit.MINUTES);\n+            }\n+\n+            Throwable[] fatalError = new Throwable[1];\n+\n+            for (var future : futures) {\n+                var result = future.get();\n+                TKit.trace(String.format(\"[%s] STDOUT BEGIN\\n%s\", result.id(), result.stdoutBuffer()));\n+                TKit.trace(String.format(\"[%s] STDOUT END\", result.id()));\n+                TKit.trace(String.format(\"[%s] STDERR BEGIN\\n%s\", result.id(), result.stderrBuffer()));\n+                TKit.trace(String.format(\"[%s] STDERR END\", result.id()));\n+                result.throwable().filter(Predicate.not(TKit::isSkippedException)).ifPresent(t -> {\n+                    fatalError[0] = t;\n+                });\n+            }\n+\n+            if (fatalError[0] != null) {\n+                throw fatalError[0];\n+            }\n+        }\n+    }\n+\n+    public static final class AsyncInnerTest {\n+\n+        @Test\n+        @ParameterSupplier(\"ids\")\n+        public void testAppImage(int id) throws Exception {\n+            init(new JPackageCommand()).setPackageType(PackageType.IMAGE).executeAndAssertImageCreated();\n+        }\n+\n+        @Test\n+        @ParameterSupplier(\"ids\")\n+        public void testNativeBundle(int id) throws Exception {\n+            new PackageTest().addInitializer(AsyncTest::init).run(Action.CREATE_AND_UNPACK);\n+        }\n+\n+        public static Collection<Object[]> ids() {\n+            return IntStream.range(0, JOB_COUNT).mapToObj(Integer::valueOf).map(v -> {\n+                return new Object[] {v};\n+            }).toList();\n+        }\n+    }\n+\n+    private static JPackageCommand init(JPackageCommand cmd) {\n+        return cmd.useToolProvider(true).setFakeRuntime()\n+                .setDefaultInputOutput()\n+                .setArgumentValue(\"--input\", APP_JAR.get().getParent())\n+                .setArgumentValue(\"--main-jar\", APP_JAR.get().getFileName())\n+                .setArgumentValue(\"--name\", \"Foo\");\n+    }\n+\n+\n+    private record Result(String stdoutBuffer, String stderrBuffer, String id, Optional<Throwable> throwable) {\n+\n+        Result {\n+            Objects.requireNonNull(stdoutBuffer);\n+            Objects.requireNonNull(stderrBuffer);\n+            Objects.requireNonNull(id);\n+            Objects.requireNonNull(throwable);\n+        }\n+    }\n+\n+\n+    private record Workload(\n+            ByteArrayOutputStream stdoutBuffer,\n+            ByteArrayOutputStream stderrBuffer,\n+            ThrowingRunnable runnable,\n+            String id) implements Callable<Result>  {\n+\n+        Workload {\n+            Objects.requireNonNull(stdoutBuffer);\n+            Objects.requireNonNull(stderrBuffer);\n+            Objects.requireNonNull(runnable);\n+            Objects.requireNonNull(id);\n+        }\n+\n+        Workload(ThrowingRunnable runnable, String id) {\n+            this(new ByteArrayOutputStream(), new ByteArrayOutputStream(), runnable, id);\n+        }\n+\n+        private String stdoutBufferAsString() {\n+            return new String(stdoutBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        }\n+\n+        private String stderrBufferAsString() {\n+            return new String(stderrBuffer.toByteArray(), StandardCharsets.UTF_8);\n+        }\n+\n+        @Override\n+        public Result call() {\n+            \/\/ Reset the current test inherited in the state from the parent thread.\n+            TKit.state(DEFAULT_STATE);\n+\n+            var defaultToolProvider = JavaTool.JPACKAGE.asToolProvider();\n+\n+            JPackageCommand.useToolProviderByDefault(new ToolProvider() {\n+\n+                @Override\n+                public int run(PrintWriter out, PrintWriter err, String... args) {\n+                    try (var bufOut = new PrintWriter(stdoutBuffer, true, StandardCharsets.UTF_8);\n+                            var bufErr = new PrintWriter(stderrBuffer, true, StandardCharsets.UTF_8)) {\n+                        return defaultToolProvider.run(bufOut, bufErr, args);\n+                    }\n+                }\n+\n+                @Override\n+                public String name() {\n+                    return defaultToolProvider.name();\n+                }\n+            });\n+\n+            Optional<Throwable> err = Optional.empty();\n+            try (var bufOut = new PrintStream(stdoutBuffer, true, StandardCharsets.UTF_8);\n+                    var bufErr = new PrintStream(stderrBuffer, true, StandardCharsets.UTF_8)) {\n+                TKit.withStackTraceStream(() -> {\n+                    TKit.withMainLogStream(runnable, bufOut);\n+                }, bufErr);\n+            } catch (Throwable t) {\n+                err = Optional.of(t);\n+            }\n+            return new Result(stdoutBufferAsString(), stderrBufferAsString(), id, err);\n+        }\n+    }\n+\n+\n+    private static final int JOB_COUNT = 30;\n+    private static final TKit.State DEFAULT_STATE = TKit.state();\n+    private static final InheritableThreadLocal<Path> APP_JAR = new InheritableThreadLocal<>();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AsyncTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -413,1 +413,1 @@\n-                        \"ERR_BuildRootInvalid\", cmd.getArgumentValue(\"--temp\")));\n+                        \"error.parameter-not-empty-directory\", cmd.getArgumentValue(\"--temp\"), \"--temp\"));\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import static jdk.jpackage.test.CannedFormattedString.cannedAbsolutePath;\n+import static jdk.jpackage.test.JPackageCommand.makeAdvice;\n+import static jdk.jpackage.test.JPackageCommand.makeError;\n@@ -43,0 +44,1 @@\n+import java.util.function.UnaryOperator;\n@@ -49,0 +51,1 @@\n+import jdk.jpackage.test.CannedArgument;\n@@ -144,1 +147,1 @@\n-    record PackageTypeSpec(Optional<PackageType> type, boolean anyNativeType) implements CannedFormattedString.CannedArgument {\n+    record PackageTypeSpec(Optional<PackageType> type, boolean anyNativeType) implements CannedArgument {\n@@ -169,1 +172,1 @@\n-        public String value() {\n+        public String getValue() {\n@@ -203,1 +206,1 @@\n-            List<String> removeArgs, List<CannedFormattedString> expectedErrors) {\n+            List<String> removeArgs, List<CannedFormattedString> expectedMessages) {\n@@ -268,2 +271,2 @@\n-            Builder setErrors(List<CannedFormattedString> v) {\n-                expectedErrors = v;\n+            Builder setMessages(List<CannedFormattedString> v) {\n+                expectedMessages = v;\n@@ -273,2 +276,2 @@\n-            Builder setErrors(CannedFormattedString... v) {\n-                return setErrors(List.of(v));\n+            Builder setMessages(CannedFormattedString... v) {\n+                return setMessages(List.of(v));\n@@ -277,2 +280,2 @@\n-            Builder errors(List<CannedFormattedString> v) {\n-                expectedErrors.addAll(v);\n+            Builder messages(List<CannedFormattedString> v) {\n+                expectedMessages.addAll(v);\n@@ -282,2 +285,2 @@\n-            Builder errors(CannedFormattedString... v) {\n-                return errors(List.of(v));\n+            Builder messages(CannedFormattedString... v) {\n+                return messages(List.of(v));\n@@ -287,1 +290,5 @@\n-                return errors(JPackageStringBundle.MAIN.cannedFormattedString(key, args));\n+                return messages(makeError(JPackageStringBundle.MAIN.cannedFormattedString(key, args)));\n+            }\n+\n+            Builder advice(String key, Object ... args) {\n+                return messages(makeAdvice(JPackageStringBundle.MAIN.cannedFormattedString(key, args)));\n@@ -301,1 +308,1 @@\n-                        List.copyOf(addArgs), List.copyOf(removeArgs), List.copyOf(expectedErrors));\n+                        List.copyOf(addArgs), List.copyOf(removeArgs), List.copyOf(expectedMessages));\n@@ -308,1 +315,1 @@\n-            private List<CannedFormattedString> expectedErrors = new ArrayList<>();\n+            private List<CannedFormattedString> expectedMessages = new ArrayList<>();\n@@ -318,1 +325,1 @@\n-            if (expectedErrors.isEmpty()) {\n+            if (expectedMessages.isEmpty()) {\n@@ -356,1 +363,1 @@\n-            defaultInit(cmd, expectedErrors);\n+            defaultInit(cmd, expectedMessages);\n@@ -360,0 +367,4 @@\n+        TestSpec mapExpectedMessages(UnaryOperator<CannedFormattedString> mapper) {\n+            return new TestSpec(type, appDesc, addArgs, removeArgs, expectedMessages.stream().map(mapper).toList());\n+        }\n+\n@@ -375,1 +386,1 @@\n-            sb.append(\"errors=\").append(expectedErrors);\n+            sb.append(\"errors=\").append(expectedMessages);\n@@ -398,1 +409,1 @@\n-                    .error(\"error.no-main-class-with-main-jar.advice\", \"hello.jar\"),\n+                    .advice(\"error.no-main-class-with-main-jar.advice\", \"hello.jar\"),\n@@ -404,1 +415,1 @@\n-                    .error(\"message.runtime-image-dir-does-not-exist\", \"runtime-image\", \"non-existent.runtime\"),\n+                    .error(\"error.parameter-not-directory\", \"non-existent.runtime\", \"--runtime-image\"),\n@@ -407,1 +418,1 @@\n-                    .error(\"ERR_AppImageNotExist\", \"non-existent.appimage\"),\n+                    .error(\"error.parameter-not-directory\", \"non-existent.appimage\", \"--app-image\"),\n@@ -410,1 +421,1 @@\n-                    .error(\"message.resource-dir-does-not-exist\", \"resource-dir\", \"non-existent.dir\"),\n+                    .error(\"error.parameter-not-directory\", \"non-existent.dir\", \"--resource-dir\"),\n@@ -413,1 +424,1 @@\n-                    .error(\"ERR_IconFileNotExit\", cannedAbsolutePath(\"non-existent.icon\")),\n+                    .error(\"error.parameter-not-file\", \"non-existent.icon\", \"--icon\"),\n@@ -416,1 +427,1 @@\n-                    .error(\"ERR_LicenseFileNotExit\"),\n+                    .error(\"error.parameter-not-file\", \"non-existent.license\", \"--license-file\"),\n@@ -424,1 +435,1 @@\n-                    .error(\"ERR_MissingArgument\", \"--runtime-image or --module-path\"),\n+                    .error(\"ERR_MissingArgument2\", \"--runtime-image\", \"--module-path\"),\n@@ -431,3 +442,0 @@\n-            \/\/ --main-jar and --module-name\n-            testSpec().noAppDesc().addArgs(\"--main-jar\", \"foo.jar\", \"--module\", \"foo.bar\")\n-                    .error(\"ERR_BothMainJarAndModule\"),\n@@ -442,0 +450,6 @@\n+        \/\/ --main-jar and --module-name\n+        createMutuallyExclusive(\n+                new ArgumentGroup(\"--module\", \"foo.bar\"),\n+                new ArgumentGroup(\"--main-jar\", \"foo.jar\")\n+        ).map(TestSpec.Builder::noAppDesc).map(TestSpec.Builder::create).forEach(testCases::add);\n+\n@@ -536,1 +550,9 @@\n-        spec.test(Map.of(Token.ADD_LAUNCHER_PROPERTY_FILE, cmd -> propsFile));\n+        spec.mapExpectedMessages(cannedStr -> {\n+            return cannedStr.mapArgs(arg -> {\n+                if (arg == Token.ADD_LAUNCHER_PROPERTY_FILE) {\n+                    return propsFile;\n+                } else {\n+                    return arg;\n+                }\n+            });\n+        }).test(Map.of(Token.ADD_LAUNCHER_PROPERTY_FILE, cmd -> propsFile));\n@@ -542,1 +564,1 @@\n-                    .error(\"ERR_NoAddLauncherName\"),\n+                    .error(\"error.parameter-add-launcher-malformed\", Token.ADD_LAUNCHER_PROPERTY_FILE, \"--add-launcher\"),\n@@ -544,1 +566,1 @@\n-                    .error(\"ERR_NoUniqueName\")\n+                    .error(\"error.launcher-duplicate-name\", \"foo\")\n@@ -580,1 +602,1 @@\n-                            .error(\"error.missing-service-installer.advice\"),\n+                            .advice(\"error.missing-service-installer.advice\"),\n@@ -585,1 +607,1 @@\n-                            .error(\"error.version-string-wrong-format.advice\"),\n+                            .advice(\"error.version-string-wrong-format.advice\"),\n@@ -588,1 +610,1 @@\n-                            .error(\"error.version-string-wrong-format.advice\"),\n+                            .advice(\"error.version-string-wrong-format.advice\"),\n@@ -591,1 +613,1 @@\n-                            .error(\"error.version-string-wrong-format.advice\"),\n+                            .advice(\"error.version-string-wrong-format.advice\"),\n@@ -594,1 +616,1 @@\n-                            .error(\"error.version-string-wrong-format.advice\"),\n+                            .advice(\"error.version-string-wrong-format.advice\"),\n@@ -597,1 +619,1 @@\n-                            .error(\"error.version-string-wrong-format.advice\")\n+                            .advice(\"error.version-string-wrong-format.advice\")\n@@ -613,1 +635,1 @@\n-                        .error(\"error.invalid-cfbundle-version.advice\"),\n+                        .advice(\"error.invalid-cfbundle-version.advice\"),\n@@ -616,1 +638,1 @@\n-                        .error(\"error.invalid-cfbundle-version.advice\"),\n+                        .advice(\"error.invalid-cfbundle-version.advice\"),\n@@ -662,1 +684,1 @@\n-                        .error(\"error.deb-invalid-value-for-package-name.advice\"),\n+                        .advice(\"error.deb-invalid-value-for-package-name.advice\"),\n@@ -665,1 +687,1 @@\n-                        .error(\"error.rpm-invalid-value-for-package-name.advice\")\n+                        .advice(\"error.rpm-invalid-value-for-package-name.advice\")\n@@ -686,2 +708,2 @@\n-        errorMessages.add(JPackageStringBundle.MAIN.cannedFormattedString(\n-                \"error.cert.not.found\", \"Developer ID Application: \" + signingId, \"\"));\n+        errorMessages.add(makeError(JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"error.cert.not.found\", \"Developer ID Application: \" + signingId, \"\")));\n@@ -689,3 +711,5 @@\n-                \"error.explicit-sign-no-cert\",\n-                \"error.explicit-sign-no-cert.advice\"\n-        ).map(JPackageStringBundle.MAIN::cannedFormattedString).toList());\n+                Map.<String, UnaryOperator<CannedFormattedString>>entry(\"error.explicit-sign-no-cert\", JPackageCommand::makeError),\n+                Map.<String, UnaryOperator<CannedFormattedString>>entry(\"error.explicit-sign-no-cert.advice\", JPackageCommand::makeAdvice)\n+        ).map(e -> {\n+            return e.getValue().apply(JPackageStringBundle.MAIN.cannedFormattedString(e.getKey()));\n+        }).toList());\n@@ -728,1 +752,1 @@\n-            return testSpec().nativeType().addArgs(shortcutOption, value).error(\"error.invalid-option-value\", value, shortcutOption).create();\n+            return testSpec().nativeType().addArgs(shortcutOption, value).error(\"error.parameter-not-launcher-shortcut-dir\", value, shortcutOption).create();\n@@ -733,1 +757,1 @@\n-        var runtimeWithBinDirErr = JPackageStringBundle.MAIN.cannedFormattedString(\n+        var runtimeWithBinDirErr = makeError(JPackageStringBundle.MAIN.cannedFormattedString(\n@@ -736,3 +760,3 @@\n-                }, Token.JAVA_HOME.token()));\n-        var runtimeWithBinDirErrAdvice = JPackageStringBundle.MAIN.cannedFormattedString(\n-                \"error.invalid-runtime-image-bin-dir.advice\", \"--mac-app-store\");\n+                }, Token.JAVA_HOME.token())));\n+        var runtimeWithBinDirErrAdvice = makeAdvice(JPackageStringBundle.MAIN.cannedFormattedString(\n+                \"error.invalid-runtime-image-bin-dir.advice\", \"--mac-app-store\"));\n@@ -742,1 +766,1 @@\n-                        .errors(runtimeWithBinDirErr, runtimeWithBinDirErrAdvice)\n+                        .messages(runtimeWithBinDirErr, runtimeWithBinDirErrAdvice)\n@@ -774,1 +798,1 @@\n-            return builder.addArgs(\"--runtime-image\", runtimeDir.token()).errors(expectedErrorMsg());\n+            return builder.addArgs(\"--runtime-image\", runtimeDir.token()).messages(expectedErrorMsg());\n@@ -778,1 +802,1 @@\n-            return JPackageStringBundle.MAIN.cannedFormattedString(\n+            return makeError(JPackageStringBundle.MAIN.cannedFormattedString(\n@@ -781,1 +805,1 @@\n-                    }, runtimeDir.token()), missingFile);\n+                    }, runtimeDir.token()), missingFile));\n@@ -852,1 +876,1 @@\n-    private static void defaultInit(JPackageCommand cmd, List<CannedFormattedString> expectedErrors) {\n+    private static void defaultInit(JPackageCommand cmd, List<CannedFormattedString> expectedMessages) {\n@@ -863,1 +887,1 @@\n-        cmd.validateOutput(expectedErrors.toArray(CannedFormattedString[]::new));\n+        cmd.validateOutput(expectedMessages.toArray(CannedFormattedString[]::new));\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":81,"deletions":57,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-                        \"ERR_MissingArgument\", \"--runtime-image or --module-path\");\n+                        \"ERR_MissingArgument2\", \"--runtime-image\", \"--module-path\");\n","filename":"test\/jdk\/tools\/jpackage\/share\/ModulePathTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ *      8369531\n@@ -61,3 +62,3 @@\n-                    javax\/swing\/text\/AbstractDocument.AttributeContext.html\" title=\"class or interfa\\\n-                    ce in javax.swing.text\" class=\"external-link\"><code>Link to AttributeContext inn\\\n-                    erclass<\/code><\/a>\"\"\",\n+                    javax\/swing\/text\/AbstractDocument.AttributeContext.html\" title=\"interface in jav\\\n+                    ax.swing.text\" class=\"external-link\"><code>Link to AttributeContext innerclass<\/\\\n+                    code><\/a>\"\"\",\n@@ -65,2 +66,2 @@\n-                    java\/math\/BigDecimal.html\" title=\"class or interface in java.math\" class=\"extern\\\n-                    al-link\"><code>Link to external class BigDecimal<\/code><\/a>\"\"\",\n+                    java\/math\/BigDecimal.html\" title=\"class in java.math\" class=\"external-link\"><cod\\\n+                    e>Link to external class BigDecimal<\/code><\/a>\"\"\",\n@@ -68,2 +69,2 @@\n-                    java\/math\/BigInteger.html#gcd-java.math.BigInteger-\" title=\"class or interface i\\\n-                    n java.math\" class=\"external-link\"><code>Link to external member gcd<\/code><\/a>\"\"\",\n+                    java\/math\/BigInteger.html#gcd-java.math.BigInteger-\" class=\"external-link\"><code\\\n+                    >Link to external member gcd<\/code><\/a>\"\"\",\n@@ -71,2 +72,2 @@\n-                    javax\/tools\/SimpleJavaFileObject.html#uri\" title=\"class or interface in javax.to\\\n-                    ols\" class=\"external-link\"><code>Link to external member URI<\/code><\/a>\"\"\",\n+                    javax\/tools\/SimpleJavaFileObject.html#uri\" class=\"external-link\"><code>Link to e\\\n+                    xternal member URI<\/code><\/a>\"\"\",\n@@ -98,3 +99,3 @@\n-                    javax\/swing\/text\/AbstractDocument.AttributeContext.html\" title=\"class or interfa\\\n-                    ce in javax.swing.text\" class=\"external-link\"><code>Link to AttributeContext inn\\\n-                    erclass<\/code><\/a>\"\"\",\n+                    javax\/swing\/text\/AbstractDocument.AttributeContext.html\" title=\"interface in jav\\\n+                    ax.swing.text\" class=\"external-link\"><code>Link to AttributeContext innerclass<\/\\\n+                    code><\/a>\"\"\",\n@@ -102,2 +103,2 @@\n-                    java\/math\/BigDecimal.html\" title=\"class or interface in java.math\" class=\"extern\\\n-                    al-link\"><code>Link to external class BigDecimal<\/code><\/a>\"\"\",\n+                    java\/math\/BigDecimal.html\" title=\"class in java.math\" class=\"external-link\"><cod\\\n+                    e>Link to external class BigDecimal<\/code><\/a>\"\"\",\n@@ -105,2 +106,2 @@\n-                    java\/math\/BigInteger.html#gcd-java.math.BigInteger-\" title=\"class or interface i\\\n-                    n java.math\" class=\"external-link\"><code>Link to external member gcd<\/code><\/a>\"\"\",\n+                    java\/math\/BigInteger.html#gcd-java.math.BigInteger-\" class=\"external-link\"><code\\\n+                    >Link to external member gcd<\/code><\/a>\"\"\",\n@@ -108,2 +109,2 @@\n-                    javax\/tools\/SimpleJavaFileObject.html#uri\" title=\"class or interface in javax.to\\\n-                    ols\" class=\"external-link\"><code>Link to external member URI<\/code><\/a>\"\"\",\n+                    javax\/tools\/SimpleJavaFileObject.html#uri\" class=\"external-link\"><code>Link to e\\\n+                    xternal member URI<\/code><\/a>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testClassCrossReferences\/TestClassCrossReferences.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-                    \/java\/io\/File.html\" title=\"class or interface in java.io\" class=\"external-link\"><code>File<\/code><\/a>\"\"\",\n+                    \/java\/io\/File.html\" title=\"class in java.io\" class=\"external-link\"><code>File<\/code><\/a>\"\"\",\n@@ -64,1 +64,1 @@\n-                    \/java\/io\/File.html\" title=\"class or interface in java.io\" class=\"external-link\"><code>Second File Link<\/code><\/a>\"\"\",\n+                    \/java\/io\/File.html\" title=\"class in java.io\" class=\"external-link\"><code>Second File Link<\/code><\/a>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocRootInlineTag\/TestDocRootInlineTag.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4857717 8025633 8026567 8164407 8182765 8205593\n+ * @bug 4857717 8025633 8026567 8164407 8182765 8205593 8369531\n@@ -59,3 +59,4 @@\n-                    \/java\/io\/FilterReader.html#read--\" title=\"class or interface in java.io\" class=\"\\\n-                    external-link\">read<\/a><\/code>&nbsp;in class&nbsp;<code><a href=\\\"\"\"\" + uri + \"\"\"\n-                    \/java\/io\/FilterReader.html\" title=\"class or interface in java.io\" class=\"external-link\">FilterReader<\/a><\/code><\/dd>\"\"\",\n+                    \/java\/io\/FilterReader.html#read--\" class=\"external-link\">read<\/a><\/code>&nbsp;in \\\n+                    class&nbsp;<code><a href=\\\"\"\"\" + uri + \"\"\"\n+                    \/java\/io\/FilterReader.html\" title=\"class in java.io\" class=\"external-link\">Filter\\\n+                    Reader<\/a><\/code><\/dd>\"\"\",\n@@ -65,3 +66,4 @@\n-                    \/java\/io\/DataInput.html#readInt--\" title=\"class or interface in java.io\" class=\"\\\n-                    external-link\">readInt<\/a><\/code>&nbsp;in interface&nbsp;<code><a href=\\\"\"\"\" + uri + \"\"\"\n-                    \/java\/io\/DataInput.html\" title=\"class or interface in java.io\" class=\"external-link\">DataInput<\/a><\/code><\/dd>\"\"\"\n+                    \/java\/io\/DataInput.html#readInt--\" class=\"external-link\">readInt<\/a><\/code>&nbsp;\\\n+                    in interface&nbsp;<code><a href=\\\"\"\"\" + uri + \"\"\"\n+                    \/java\/io\/DataInput.html\" title=\"interface in java.io\" class=\"external-link\">DataI\\\n+                    nput<\/a><\/code><\/dd>\"\"\"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testExternalOverriddenMethod\/TestExternalOverriddenMethod.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug     8177280 8262992 8259499 8307377 8352249\n+ * @bug     8177280 8262992 8259499 8307377 8352249 8369531\n@@ -56,7 +56,7 @@\n-                    ist.html\" title=\"class or interface in java.util\" class=\"external-link\">List<\/a>&lt\\\n-                    ;<a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class\\\n-                     or interface in java.lang\" class=\"external-link\">String<\/a>&gt;<\/code>\n-                    <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/util\/List.html\" title=\"class o\\\n-                    r interface in java.util\" class=\"external-link\">List<\/a>&lt;? extends <a href=\"http\\\n-                    :\/\/example.com\/docs\/api\/java.base\/java\/lang\/CharSequence.html\" title=\"class or inte\\\n-                    rface in java.lang\" class=\"external-link\">CharSequence<\/a>&gt;\n+                    ist.html\" title=\"interface in java.util\" class=\"external-link\">List<\/a>&lt;<a href=\\\n+                    \"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class in java.\\\n+                    lang\" class=\"external-link\">String<\/a>&gt;<\/code>\n+                    <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/util\/List.html\" title=\"interfac\\\n+                    e in java.util\" class=\"external-link\">List<\/a>&lt;? extends <a href=\"http:\/\/example\\\n+                    .com\/docs\/api\/java.base\/java\/lang\/CharSequence.html\" title=\"interface in java.lang\"\\\n+                     class=\"external-link\">CharSequence<\/a>&gt;\n@@ -75,5 +75,5 @@\n-                    class or interface in java.util\" class=\"external-link\">Map<\/a>&lt;<a href=\"http:\/\/ex\\\n-                    ample.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class or interface in jav\\\n-                    a.lang\" class=\"external-link\">String<\/a>, ? extends <a href=\"http:\/\/example.com\/\\\n-                    docs\/api\/java.base\/java\/lang\/CharSequence.html\" title=\"class or interface in java.la\\\n-                    ng\" class=\"external-link\">CharSequence<\/a>&gt;<\/code><\/li>\n+                    interface in java.util\" class=\"external-link\">Map<\/a>&lt;<a href=\"http:\/\/example.com\\\n+                    \/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class in java.lang\" class=\"externa\\\n+                    l-link\">String<\/a>, ? extends <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/la\\\n+                    ng\/CharSequence.html\" title=\"interface in java.lang\" class=\"external-link\">CharSeque\\\n+                    nce<\/a>&gt;<\/code><\/li>\n@@ -81,8 +81,7 @@\n-                    class or interface in java.util\" class=\"external-link\">Map<\/a>&lt;<a href=\"http:\/\/ex\\\n-                    ample.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class or interface in jav\\\n-                    a.lang\" class=\"external-link\">String<\/a>, ? super <a href=\"A.html\" title=\"class \\\n-                    in pkg1\">A<\/a>&lt;<a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/String.ht\\\n-                    ml\" title=\"class or interface in java.lang\" class=\"external-link\">String<\/a>, ? \\\n-                    extends <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/RuntimeException.ht\\\n-                    ml\" title=\"class or interface in java.lang\" class=\"external-link\">RuntimeException<\/\\\n-                    a>&gt;&gt;<\/code><\/li>\n+                    interface in java.util\" class=\"external-link\">Map<\/a>&lt;<a href=\"http:\/\/example.com\\\n+                    \/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class in java.lang\" class=\"externa\\\n+                    l-link\">String<\/a>, ? super <a href=\"A.html\" title=\"class in pkg1\">A<\/a>&lt;<a href=\\\n+                    \"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class in java.l\\\n+                    ang\" class=\"external-link\">String<\/a>, ? extends <a href=\"http:\/\/example.com\/docs\/ap\\\n+                    i\/java.base\/java\/lang\/RuntimeException.html\" title=\"class in java.lang\" class=\"exter\\\n+                    nal-link\">RuntimeException<\/a>&gt;&gt;<\/code><\/li>\n@@ -99,5 +98,5 @@\n-                    ttp:\/\/example.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class or interfa\\\n-                    ce in java.lang\" class=\"external-link\">String<\/a>, <a href=\"A.SomeException.htm\\\n-                    l\" title=\"class in pkg1\">A.SomeException<\/a>&gt;<\/code>\n-                    <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/util\/Map.html\" title=\"class or\\\n-                     interface in java.util\" class=\"external-link\">link to generic type with label<\/a>\\\n+                    ttp:\/\/example.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class in java.la\\\n+                    ng\" class=\"external-link\">String<\/a>, <a href=\"A.SomeException.html\" title=\"class i\\\n+                    n pkg1\">A.SomeException<\/a>&gt;<\/code>\n+                    <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/util\/Map.html\" title=\"\\\n+                    interface in java.util\" class=\"external-link\">link to generic type with label<\/a>\\\n@@ -111,6 +110,5 @@\n-                    om\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class or interface in java.lang\\\n-                    \" class=\"external-link\">String<\/a>, <a href=\"A.SomeException.html\" title=\"class\\\n-                     in pkg1\">A.SomeException<\/a>&gt;<\/code><\/li>\n-                    <li><a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/util\/List.html\" title=\"clas\\\n-                    s or interface in java.util\" class=\"external-link\">Link to generic type with label<\\\n-                    \/a><\/li>\n+                    om\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class in java.lang\" class=\"exte\\\n+                    rnal-link\">String<\/a>, <a href=\"A.SomeException.html\" title=\"class in pkg1\">A.SomeE\\\n+                    xception<\/a>&gt;<\/code><\/li>\n+                    <li><a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/util\/List.html\" title=\"inte\\\n+                    rface in java.util\" class=\"external-link\">Link to generic type with label<\/a><\/li>\n@@ -128,5 +126,5 @@\n-                    e.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class or interface in jav\\\n-                    a.lang\" class=\"external-link\">String<\/a>, <a href=\"http:\/\/example.com\/docs\/a\\\n-                    pi\/java.base\/java\/lang\/RuntimeException.html\" title=\"class or interface in java.\\\n-                    lang\" class=\"external-link\">RuntimeException<\/a>&gt;.<a href=\"A.Inner.html\" titl\\\n-                    e=\"class in pkg1\">Inner<\/a><\/code><\/li>\n+                    e.com\/docs\/api\/java.base\/java\/lang\/String.html\" title=\"class in java.lang\" class\\\n+                    =\"external-link\">String<\/a>, <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\\\n+                    \/lang\/RuntimeException.html\" title=\"class in java.lang\" class=\"external-link\">Ru\\\n+                    ntimeException<\/a>&gt;.<a href=\"A.Inner.html\" title=\"class in pkg1\">Inner<\/a><\/c\\\n+                    ode><\/li>\n@@ -135,6 +133,5 @@\n-                    ng\/String.html\" title=\"class or interface in java.lang\" class=\"external-link\">St\\\n-                    ring<\/a>, <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/RuntimeEx\\\n-                    ception.html\" title=\"class or interface in java.lang\" class=\"external-link\">Runt\\\n-                    imeException<\/a>&gt;.<a href=\"A.Inner.html\" title=\"class in pkg1\">Inner<\/a>, \\\n-                    <a href=\"A.SomeException.html\" title=\"class in pkg1\">A.SomeException<\/a>&gt;<\/c\\\n-                    ode><\/li>\n+                    ng\/String.html\" title=\"class in java.lang\" class=\"external-link\">String<\/a>, <a \\\n+                    href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/RuntimeException.html\" tit\\\n+                    le=\"class in java.lang\" class=\"external-link\">RuntimeException<\/a>&gt;.<a href=\"\\\n+                    A.Inner.html\" title=\"class in pkg1\">Inner<\/a>, <a href=\"A.SomeException.html\" ti\\\n+                    tle=\"class in pkg1\">A.SomeException<\/a>&gt;<\/code><\/li>\n@@ -151,4 +148,4 @@\n-                    html\" title=\"class or interface in java.lang\" class=\"external-link\">Object<\/a>, \\\n-                    <a href=\"http:\/\/example.com\/docs\/api\/java.base\/java\/lang\/RuntimeException.ht\\\n-                    ml\" title=\"class or interface in java.lang\" class=\"external-link\">RuntimeExcepti\\\n-                    on<\/a>&gt;.<a href=\"A.Inner.html\" title=\"class in pkg1\">Inner<\/a>\"\"\");\n+                    html\" title=\"class in java.lang\" class=\"external-link\">Object<\/a>, <a href=\"http\\\n+                    :\/\/example.com\/docs\/api\/java.base\/java\/lang\/RuntimeException.html\" title=\"class \\\n+                    in java.lang\" class=\"external-link\">RuntimeException<\/a>&gt;.<a href=\"A.Inner.ht\\\n+                    ml\" title=\"class in pkg1\">Inner<\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testGenericTypeLink\/TestGenericTypeLink.java","additions":44,"deletions":47,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *      8216497\n+ *      8216497 8369531\n@@ -76,2 +76,2 @@\n-                    java\/lang\/String.html\" title=\"class or interface in java.lang\" class=\"external-l\\\n-                    ink\"><code>Link to String Class<\/code><\/a>\"\"\",\n+                    java\/lang\/String.html\" title=\"class in java.lang\" class=\"external-link\"><code>Li\\\n+                    nk to String Class<\/code><\/a>\"\"\",\n@@ -87,1 +87,1 @@\n-                    java\/lang\/Object.html\" title=\"class or interface in java.lang\" class=\"external-link\">Object<\/a>&nbsp;p3)\"\"\");\n+                    java\/lang\/Object.html\" title=\"class in java.lang\" class=\"external-link\">Object<\/a>&nbsp;p3)\"\"\");\n@@ -92,3 +92,2 @@\n-                    java\/lang\/ClassLoader.html#getSystemClassLoader--\" title=\"class or interface in \\\n-                    java.lang\" class=\"external-link\"><code><b>getSystemClassLoader()<\/b><\/code><\/a> \\\n-                    as the parent class loader.<\/div>\"\"\",\n+                    java\/lang\/ClassLoader.html#getSystemClassLoader--\" class=\"external-link\"><code><\\\n+                    b>getSystemClassLoader()<\/b><\/code><\/a> as the parent class loader.<\/div>\"\"\",\n@@ -100,1 +99,2 @@\n-                    java\/lang\/String.html\" title=\"class or interface in java.lang\" class=\"external-link\">Link-Plain to String Class<\/a>\"\"\",\n+                    java\/lang\/String.html\" title=\"class in java.lang\" class=\"external-link\">Link-Pla\\\n+                    in to String Class<\/a>\"\"\",\n@@ -124,2 +124,2 @@\n-                    java\/lang\/Object.html\" title=\"class or interface in java.lang\" class=\"external-l\\\n-                    ink\">Object<\/a><\/span><\/div>\"\"\"\n+                    java\/lang\/Object.html\" title=\"class in java.lang\" class=\"external-link\">Object<\/\\\n+                    a><\/span><\/div>\"\"\"\n@@ -140,1 +140,1 @@\n-                \/pkg\/C.html\" title=\"class or interface in pkg\" class=\"external-link\"><code>Class C<\/code><\/a>.\"\"\"\n+                \/pkg\/C.html\" title=\"class in pkg\" class=\"external-link\"><code>Class C<\/code><\/a>.\"\"\"\n@@ -171,2 +171,2 @@\n-                    <a href=\"..\/..\/out2\/pkg2\/C2.html\" title=\"class or interface in pkg2\" class=\"ext\\\n-                    ernal-link\"><code>link to pkg2.C2<\/code><\/a>\n+                    <a href=\"..\/..\/out2\/pkg2\/C2.html\" title=\"class in pkg2\" class=\"external-link\"><c\\\n+                    ode>link to pkg2.C2<\/code><\/a>\n@@ -174,3 +174,3 @@\n-                    <a href=\"..\/..\/out1\/mylib\/lang\/StringBuilderChild.html\" title=\"class or interfa\\\n-                    ce in mylib.lang\" class=\"external-link\"><code>link to mylib.lang.StringBuilderCh\\\n-                    ild<\/code><\/a>.<\/div>\n+                    <a href=\"..\/..\/out1\/mylib\/lang\/StringBuilderChild.html\" title=\"class in mylib.la\\\n+                    ng\" class=\"external-link\"><code>link to mylib.lang.StringBuilderChild<\/code><\/a>\\\n+                    .<\/div>\n@@ -196,2 +196,2 @@\n-                    <a href=\"..\/..\/copy\/out2\/pkg2\/C2.html\" title=\"class or interface in pkg2\" class\\\n-                    =\"external-link\"><code>link to pkg2.C2<\/code><\/a>\n+                    <a href=\"..\/..\/copy\/out2\/pkg2\/C2.html\" title=\"class in pkg2\" class=\"external-lin\\\n+                    k\"><code>link to pkg2.C2<\/code><\/a>\n@@ -199,3 +199,2 @@\n-                    <a href=\"..\/..\/copy\/out1\/mylib\/lang\/StringBuilderChild.html\" title=\"class or in\\\n-                    terface in mylib.lang\" class=\"external-link\"><code>link to mylib.lang.StringBuil\\\n-                    derChild<\/code><\/a>.<\/div>\n+                    <a href=\"..\/..\/copy\/out1\/mylib\/lang\/StringBuilderChild.html\" title=\"class in myl\\\n+                    ib.lang\" class=\"external-link\"><code>link to mylib.lang.StringBuilderChild<\/code><\/a>.<\/div>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestLinkOption.java","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-                    extends <a href=\"http:\/\/myWebsite\/lib\/LibClass.html\" title=\"class or interface i\\\n+                    extends <a href=\"http:\/\/myWebsite\/lib\/LibClass.html\" title=\"class i\\\n@@ -132,1 +132,1 @@\n-                    extends <a href=\"http:\/\/myWebsite\/lib\/LibClass.html\" title=\"class or interface i\\\n+                    extends <a href=\"http:\/\/myWebsite\/lib\/LibClass.html\" title=\"class i\\\n@@ -157,1 +157,1 @@\n-                    extends <a href=\"http:\/\/myWebsite\/lib\/LibClass.html\" title=\"class or interface i\\\n+                    extends <a href=\"http:\/\/myWebsite\/lib\/LibClass.html\" title=\"class i\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestLinkOptionWithAutomaticModule.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-                    <a href=\"..\/..\/..\/..\/out1a\/com.ex1\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n+                    <a href=\"..\/..\/..\/..\/out1a\/com.ex1\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n@@ -101,1 +101,1 @@\n-                    <a href=\"..\/..\/..\/out2a\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n+                    <a href=\"..\/..\/..\/out2a\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n@@ -124,1 +124,1 @@\n-                    <a href=\"..\/..\/..\/..\/out3a\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n+                    <a href=\"..\/..\/..\/..\/out3a\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n@@ -146,1 +146,1 @@\n-                    <a href=\"..\/..\/..\/out4a\/com.ex1\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n+                    <a href=\"..\/..\/..\/out4a\/com.ex1\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n@@ -170,1 +170,1 @@\n-                    <a href=\"..\/..\/..\/..\/out5a\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n+                    <a href=\"..\/..\/..\/..\/out5a\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n@@ -196,1 +196,1 @@\n-                    <a href=\"..\/..\/..\/out6a\/com.ex1\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n+                    <a href=\"..\/..\/..\/out6a\/com.ex1\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\">A<\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestLinkOptionWithModule.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-                    \/java.base\/java\/lang\/String.html\" title=\"class or interface in java.lang\" class=\\\n+                    \/java.base\/java\/lang\/String.html\" title=\"class in java.lang\" class=\\\n@@ -169,1 +169,2 @@\n-                    \/java.base\/java\/lang\/Object.html\" title=\"class or interface in java.lang\" class=\"external-link\">Object<\/a>\"\"\");\n+                    \/java.base\/java\/lang\/Object.html\" title=\"class in java.lang\" class=\\\n+                    \"external-link\">Object<\/a>\"\"\");\n@@ -275,1 +276,1 @@\n-                        \/mA\/p1\/C1.html\" title=\"class or interface in p1\" class=\"external-link\">C1<\/a>\"\"\");\n+                        \/mA\/p1\/C1.html\" title=\"class in p1\" class=\"external-link\">C1<\/a>\"\"\");\n@@ -278,1 +279,1 @@\n-                        \/mB\/p4\/C4.html\" title=\"class or interface in p4\" class=\"external-link\">C4<\/a>\"\"\");\n+                        \/mB\/p4\/C4.html\" title=\"class in p4\" class=\"external-link\">C4<\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8216497 8297437\n+ * @bug 8216497 8297437 8369531\n@@ -109,3 +109,3 @@\n-                        \"<a href=\\\"\" + url + \"#clone--\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#equals-java.lang.Object-\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#finalize--\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\");\n+                        \"<a href=\\\"\" + url + \"#clone--\\\" title=\\\"clone()\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#equals-java.lang.Object-\\\" title=\\\"equals(Object)\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#finalize--\\\" title=\\\"finalize()\\\" class=\\\"external-link\\\">\");\n@@ -115,3 +115,3 @@\n-                        \"<a href=\\\"\" + url + \"#clone()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#equals(java.lang.Object)\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#finalize()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\");\n+                        \"<a href=\\\"\" + url + \"#clone()\\\" title=\\\"clone()\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#equals(java.lang.Object)\\\" title=\\\"equals(Object)\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#finalize()\\\" title=\\\"finalize()\\\" class=\\\"external-link\\\">\");\n@@ -139,3 +139,3 @@\n-                        \"<a href=\\\"\" + url + \"#clone--\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#equals-java.lang.Object-\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#finalize--\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\");\n+                        \"<a href=\\\"\" + url + \"#clone--\\\" title=\\\"clone()\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#equals-java.lang.Object-\\\" title=\\\"equals(Object)\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#finalize--\\\" title=\\\"finalize()\\\" class=\\\"external-link\\\">\");\n@@ -145,3 +145,3 @@\n-                        \"<a href=\\\"\" + url + \"#clone()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#equals(java.lang.Object)\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#finalize()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\");\n+                        \"<a href=\\\"\" + url + \"#clone()\\\" title=\\\"clone()\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#equals(java.lang.Object)\\\" title=\\\"equals(Object)\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#finalize()\\\" title=\\\"finalize()\\\" class=\\\"external-link\\\">\");\n@@ -169,3 +169,3 @@\n-                        \"<a href=\\\"\" + url + \"#clone--\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#equals-java.lang.Object-\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#finalize--\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\");\n+                        \"<a href=\\\"\" + url + \"#clone--\\\" title=\\\"clone()\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#equals-java.lang.Object-\\\" title=\\\"equals(Object)\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#finalize--\\\" title=\\\"finalize()\\\" class=\\\"external-link\\\">\");\n@@ -175,3 +175,3 @@\n-                        \"<a href=\\\"\" + url + \"#clone()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#equals(java.lang.Object)\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\",\n-                        \"<a href=\\\"\" + url + \"#finalize()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\">\");\n+                        \"<a href=\\\"\" + url + \"#clone()\\\" title=\\\"clone()\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#equals(java.lang.Object)\\\" title=\\\"equals(Object)\\\" class=\\\"external-link\\\">\",\n+                        \"<a href=\\\"\" + url + \"#finalize()\\\" title=\\\"finalize()\\\" class=\\\"external-link\\\">\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkPlatform\/TestLinkPlatform.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -110,6 +110,3 @@\n-                    <a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html\" title=\"class or interface in com.m1.lib\"\\\n-                     class=\"external-link\"><code>Lib<\/code><\/a>\n-                    <a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" title=\"class or\\\n-                     interface in com.m1.lib\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a>\n-                    <a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" title=\"class or\\\n-                     interface in com.m1.lib\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a>\n+                    <a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html\" title=\"class in com.m1.lib\" class=\"external-link\"><code>Lib<\/code><\/a>\n+                    <a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a>\n+                    <a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a>\n@@ -119,5 +116,3 @@\n-                    <a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html\" title=\"class or interface in com.m2.lib\" class=\"external-link\">Lib<\/a>\n-                    <a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" title=\"class or\\\n-                     interface in com.m2.lib\" class=\"external-link\">class link<\/a>\n-                    <a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" title=\"class or\\\n-                     interface in com.m2.lib\" class=\"external-link\">Lib.method(String)<\/a><\/div>\n+                    <a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html\" title=\"class in com.m2.lib\" class=\"external-link\">Lib<\/a>\n+                    <a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\">class link<\/a>\n+                    <a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\">Lib.method(String)<\/a><\/div>\n@@ -167,3 +162,3 @@\n-                    <a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\"><code>class link<\/code><\/a>\n-                    <a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" title=\"class or interface in com.ex1\" class=\"external-link\"><code>A.m()<\/code><\/a>\n-                    <a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" title=\"class or interface in com.ex1\" class=\"external-link\"><code>A.m()<\/code><\/a>\n+                    <a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\"><code>class link<\/code><\/a>\n+                    <a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" class=\"external-link\"><code>A.m()<\/code><\/a>\n+                    <a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" class=\"external-link\"><code>A.m()<\/code><\/a>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkTaglet\/TestLinkTagletWithModule.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-                        \"\/api\/java.base\/java\/lang\/String.html\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String<\/code><\/a>\",\n+                        \"\/api\/java.base\/java\/lang\/String.html\\\" title=\\\"class in java.lang\\\" class=\\\"external-link\\\"><code>String<\/code><\/a>\",\n@@ -251,1 +251,1 @@\n-                        \"\/api\/java.base\/java\/lang\/Runnable.html\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>Runnable<\/code><\/a>\",\n+                        \"\/api\/java.base\/java\/lang\/Runnable.html\\\" title=\\\"interface in java.lang\\\" class=\\\"external-link\\\"><code>Runnable<\/code><\/a>\",\n@@ -254,1 +254,1 @@\n-                        \"\/api\/java.base\/java\/lang\/String.html#CASE_INSENSITIVE_ORDER\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String.CASE_INSENSITIVE_ORDER<\/code><\/a>\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#CASE_INSENSITIVE_ORDER\\\" class=\\\"external-link\\\"><code>String.CASE_INSENSITIVE_ORDER<\/code><\/a>\",\n@@ -257,1 +257,1 @@\n-                        \"\/api\/java.base\/java\/lang\/String.html#%3Cinit%3E()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String()<\/code><\/a><\/li>\",\n+                        \"\/api\/java.base\/java\/lang\/String.html#%3Cinit%3E()\\\" class=\\\"external-link\\\"><code>String()<\/code><\/a><\/li>\",\n@@ -260,1 +260,1 @@\n-                        \"\/api\/java.base\/java\/lang\/String.html#chars()\\\" title=\\\"class or interface in java.lang\\\" class=\\\"external-link\\\"><code>String.chars()<\/code><\/a>\");\n+                        \"\/api\/java.base\/java\/lang\/String.html#chars()\\\" class=\\\"external-link\\\"><code>String.chars()<\/code><\/a>\");\n@@ -349,1 +349,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMarkdown\/TestMarkdownLinks.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1334,2 +1334,2 @@\n-                    ml\" title=\"class or interface in java.lang\" class=\"external-link\"><code>Link to \\\n-                    String Class<\/code><\/a>\"\"\");\n+                    ml\" title=\"class in java.lang\" class=\"external-link\"><code>Link to String Class<\\\n+                    \/code><\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                \"<a href=\\\"\" + doc + \"java.base\/preview\/Core.html\\\" title=\\\"class or interface in preview\\\" class=\"\n+                \"<a href=\\\"\" + doc + \"java.base\/preview\/Core.html\\\" title=\\\"class in preview\\\" class=\"\n@@ -68,1 +68,1 @@\n-                        + \"eview\/Core.html#preview-preview.Core\\\" title=\\\"class or interface in preview\\\" class=\\\"\"\n+                        + \"eview\/Core.html#preview-preview.Core\\\" class=\\\"\"\n@@ -257,1 +257,1 @@\n-                    \"title=\\\"class or interface in java.util\\\" class=\\\"external-link\\\">List<\/a>&lt;<a href=\\\"API.h\"\n+                    \"title=\\\"interface in java.util\\\" class=\\\"external-link\\\">List<\/a>&lt;<a href=\\\"API.h\"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/TestPreview.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,5 @@\n-                    Plain link to <a href=\"..\/p2\/Class2.html#class2-sub-heading\">sub heading above<\/a><\/div>\"\"\",\n+                    Plain link to <a href=\"..\/p2\/Class2.html#class2-sub-heading\">heading in Class2<\/a><\/div>\"\"\",\n+            \"\"\"\n+                    <li><a href=\"#main\">unqualified link to heading above<\/a><\/li>\n+                    <li><a href=\"#main\">qualified link to heading above<\/a><\/li>\n+                    \"\"\",\n@@ -92,1 +96,4 @@\n-                    <a href=\"Class2.html#class2-sub-heading\">See sub heading in p2.Class2<\/a>\"\"\");\n+                    <li><a href=\"Class2.html#class2-sub-heading\">See sub heading in p2.Class2<\/a><\/li>\n+                    <li><a href=\"#package-p2-heading\">local qualified link<\/a><\/li>\n+                    <li><a href=\"#package-p2-heading\">local unqualified link<\/a><\/li>\n+                    \"\"\");\n@@ -98,1 +105,4 @@\n-                    <a href=\"..\/Class2.html#class2main\">See main heading in p2.ClassB<\/a>\"\"\");\n+                    <li><a href=\"..\/Class2.html#class2main\">See main heading in p2.ClassB<\/a><\/li>\n+                    <li><a href=\"..\/package-summary.html#package-p2-heading\">package link<\/a><\/li>\n+                    <li><a href=\"#package-p2-html-file-heading\">local anchor<\/a><\/li>\n+                    \"\"\");\n@@ -115,0 +125,14 @@\n+        checkOrder(\"m1\/com\/m1\/package-summary.html\",\n+            \"\"\"\n+                    <div class=\"block\"><a href=\"#package-anchor\">Link to local anchor<\/a>.\n+                    \"\"\",\n+            \"\"\"\n+                    <span id=\"package-anchor\" class=\"search-tag-result\">package-anchor<\/span><\/div>\n+                    \"\"\",\n+            \"\"\"\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"#package-anchor\">unqualified local anchor<\/a><\/li>\n+                    <li><a href=\"#package-anchor\">qualified local anchor<\/a><\/li>\n+                    <li><a href=\"#package-anchor\">fully qualified local anchor<\/a><\/li>\n+                    <\/ul>\n+                    \"\"\");\n@@ -119,2 +143,33 @@\n-                    <li><a href=\"..\/..\/..\/m2\/com\/m2\/Class2.html#main-heading\">See main heading in Class2<\/a><\/li>\n-                    <li><a href=\"..\/..\/module-summary.html#module-m1-heading\">See heading in module m1<\/a><\/li>\n+                    <p>More links:\n+                    <ul>\n+                    <li><a href=\"..\/..\/..\/m2\/com\/m2\/Class2.html#sub\">qualified remote link<\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/m2\/com\/m2\/Class2.html#sub\">unqualified remote link<\/a><\/li>\n+                    <li><a href=\"..\/..\/module-summary.html#module-m1-heading\">module anchor link<\/a><\/li>\n+                    <li><a href=\"package-summary.html#package-anchor\">package anchor link<\/a><\/li>\n+                    <li><a href=\"#class1-anchor\">qualified local anchor link<\/a><\/li>\n+                    <li><a href=\"#class1-anchor\">unqualified local anchor link<\/a><\/li>\n+                    <\/ul>\n+                    \"\"\",\n+            \"\"\"\n+                    <dt>See Also:<\/dt>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"..\/..\/..\/m2\/com\/m2\/Class2.html#main-heading\">qualified remote link<\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/m2\/com\/m2\/Class2.html#main-heading\">unqualified remote link<\/a><\/li>\n+                    <li><a href=\"..\/..\/module-summary.html#module-m1-heading\">module anchor link<\/a><\/li>\n+                    <li><a href=\"package-summary.html#package-anchor\">package anchor link<\/a><\/li>\n+                    <li><a href=\"#class1-anchor\">qualified local anchor link<\/a><\/li>\n+                    <li><a href=\"#class1-anchor\">unqualified local anchor link<\/a><\/li>\n+                    <\/ul>\n+                    \"\"\");\n+        checkOrder(\"m2\/module-summary.html\",\n+            \"\"\"\n+                    <a href=\"com\/m2\/package-summary.html#pkg-heading\">Plain link to local anchor<\/a>.\"\"\");\n+        checkOrder(\"m2\/com\/m2\/package-summary.html\",\n+            \"\"\"\n+                    <a href=\"#pkg-heading\">Plain link to local anchor<\/a>.\n+                    \"\"\",\n+            \"\"\"\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"#pkg-heading\">See local anchor<\/a><\/li>\n+                    <\/ul>\n@@ -129,1 +184,3 @@\n-                    Link to <a href=\"..\/com\/m2\/Class2.html#main-heading\"><code>heading in Class2<\/code><\/a>.\"\"\",\n+                    Link to <a href=\"..\/com\/m2\/Class2.html#main-heading\"><code>heading in Class2<\/code><\/a>.\n+                    <a href=\"#docfile-heading\">Plain link to local anchor<\/a>.\n+                    \"\"\",\n@@ -131,1 +188,4 @@\n-                    <li><a href=\"..\/..\/m1\/module-summary.html#module-m1-heading\">Heading in module m1<\/a><\/li>\"\"\");\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"..\/..\/m1\/module-summary.html#module-m1-heading\">Heading in module m1<\/a><\/li>\n+                    <li><a href=\"#docfile-heading\">See local anchor<\/a><\/li>\n+                    \"\"\");\n@@ -200,1 +260,3 @@\n-                    Plain link to {@linkplain p2.Class2##class2-sub-heading sub heading above}\n+                    Plain link to {@linkplain p2.Class2##class2-sub-heading heading in Class2}\n+                    @see ##main unqualified link to heading above\n+                    @see p1.Class1##main qualified link to heading above\n@@ -219,0 +281,2 @@\n+                     * @see p2##package-p2-heading local qualified link\n+                     * @see ##package-p2-heading local unqualified link\n@@ -230,0 +294,2 @@\n+                    @see p2##package-p2-heading package link\n+                    @see ##package-p2-html-file-heading local anchor\n@@ -238,0 +304,1 @@\n+                .requires(\"m2\")\n@@ -240,0 +307,3 @@\n+\n+                    import com.m2.Class2;\n+\n@@ -243,2 +313,18 @@\n-                     * @see m2\/com.m2.Class2##main-heading See main heading in Class2\n-                     * @see m1\/##module-m1-heading See heading in module m1\n+                     * <p>More links:\n+                     * <ul>\n+                     * <li>{@linkplain com.m2.Class2##sub qualified remote link}<\/li>\n+                     * <li>{@linkplain Class2##sub unqualified remote link}<\/li>\n+                     * <li>{@linkplain m1\/##module-m1-heading module anchor link}<\/li>\n+                     * <li>{@linkplain com.m1##package-anchor package anchor link}<\/li>\n+                     * <li>{@linkplain Class1##class1-anchor qualified local anchor link}<\/li>\n+                     * <li>{@linkplain ##class1-anchor unqualified local anchor link}<\/li>\n+                     * <\/ul>\n+                     *\n+                     * <p>{@index class1-anchor}\n+                     *\n+                     * @see com.m2.Class2##main-heading  qualified remote link\n+                     * @see Class2##main-heading unqualified remote link\n+                     * @see m1\/##module-m1-heading module anchor link\n+                     * @see com.m1##package-anchor package anchor link\n+                     * @see Class1##class1-anchor qualified local anchor link\n+                     * @see ##class1-anchor unqualified local anchor link\n@@ -253,0 +339,11 @@\n+        tb.writeFile(src.resolve(\"m1\/com\/m1\/package-info.java\"), \"\"\"\n+                    \/**\n+                     * {@linkplain ##package-anchor Link to local anchor}.\n+                     * {@index package-anchor}\n+                     *\n+                     * @see ##package-anchor unqualified local anchor\n+                     * @see com.m1##package-anchor qualified local anchor\n+                     * @see m1\/com.m1##package-anchor fully qualified local anchor\n+                     *\/\n+                    package com.m1;\n+                    \"\"\");\n@@ -267,0 +364,12 @@\n+        tb.writeFile(src.resolve(\"m2\/com\/m2\/package.html\"), \"\"\"\n+                    <html>\n+                    <head><title>Package com.m2<\/title><\/head>\n+                    <body>\n+                    {@linkplain ##pkg-heading Plain link to local anchor}.\n+\n+                    <h2 id=\"pkg-heading\">Package com.m2<\/h2>\n+\n+                    @see ##pkg-heading See local anchor\n+                    <\/body>\n+                    <\/html>\n+                    \"\"\");\n@@ -272,1 +381,2 @@\n-                    <body><h1>Module m2 HTML File<\/h1>\n+                    <body>\n+                    <h1 id=docfile-heading>Module m2 HTML File<\/h1>\n@@ -274,0 +384,2 @@\n+                    {@linkplain ##docfile-heading Plain link to local anchor}.\n+\n@@ -275,0 +387,1 @@\n+                    @see ##docfile-heading See local anchor\n@@ -300,1 +413,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeLinkAnchor\/TestSeeLinkAnchor.java","additions":126,"deletions":13,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -116,5 +116,3 @@\n-                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html\" title=\"class or interface in com.m1.lib\" class=\"external-link\"><code>Lib<\/code><\/a><\/li>\n-                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" title=\"class or \\\n-                    interface in com.m1.lib\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n-                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" title=\"class or \\\n-                    interface in com.m1.lib\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html\" title=\"class in com.m1.lib\" class=\"external-link\"><code>Lib<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m1\/com\/m1\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n@@ -124,5 +122,3 @@\n-                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html\" title=\"class or interface in com.m2.lib\" class=\"external-link\"><code>Lib<\/code><\/a><\/li>\n-                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" title=\"class or \\\n-                    interface in com.m2.lib\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n-                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" title=\"class or \\\n-                    interface in com.m2.lib\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html\" title=\"class in com.m2.lib\" class=\"external-link\"><code>Lib<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/..\/out1\/m2\/com\/m2\/lib\/Lib.html#method(java.lang.String)\" class=\"external-link\"><code>Lib.method(String)<\/code><\/a><\/li>\n@@ -178,3 +174,3 @@\n-                    <li><a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html\" title=\"class or interface in com.ex1\" class=\"external-link\"><code>A<\/code><\/a><\/li>\n-                    <li><a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" title=\"class or interface in com.ex1\" class=\"external-link\"><code>A.m()<\/code><\/a><\/li>\n-                    <li><a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" title=\"class or interface in com.ex1\" class=\"external-link\"><code>A.m()<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html\" title=\"class in com.ex1\" class=\"external-link\"><code>A<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" class=\"external-link\"><code>A.m()<\/code><\/a><\/li>\n+                    <li><a href=\"..\/..\/..\/..\/out1\/com.ex1\/com\/ex1\/A.html#m()\" class=\"external-link\"><code>A.m()<\/code><\/a><\/li>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSeeTag\/TestSeeTagWithModule.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1126,1 +1126,1 @@\n-            Matcher m = Pattern.compile(\"(?is)(<a href=\\\"[^<>]*\\\" title=\\\"[^<>]*\\\" class=\\\"[^<>]*\\\">)\"\n+            Matcher m = Pattern.compile(\"(?is)(<a href=\\\"[^<>]*\\\" class=\\\"[^<>]*\\\">)\"\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                    \/java\/io\/File.html\" title=\"class or interface in java.io\" class=\"external-link\">\\\n+                    \/java\/io\/File.html\" title=\"class in java.io\" class=\"external-link\">\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTitleInHref\/TestTitleInHref.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8371309\n+ * @summary Verify that Diagnostic.getEndPosition works reasonably\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @run junit DiagnosticGetEndPosition\n+ *\/\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.source.util.JavacTask;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import toolbox.ToolBox;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DiagnosticGetEndPosition {\n+    final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+    final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void testGetEndPositionDuringParsing() {\n+        JavaFileObject testFile =\n+                SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/\/Test.java\"),\n+                                               \"\"\"\n+                                               public class Test extends {}\n+                                               \"\"\");\n+        compiler.getTask(\n+            null,\n+            null,\n+            diagnostic -> assertEquals(26, diagnostic.getEndPosition()),\n+            null,\n+            null,\n+            List.of(testFile)\n+        ).call();\n+    }\n+\n+    @Test\n+    public void testNoErrorsFromInternalParses() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module m {\n+                             exports test;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public class Test extends {}\n+                          \"\"\");\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            compiler.getTask(\n+                null,\n+                null,\n+                d -> fail(d.toString()),\n+                List.of(\"-sourcepath\", src.toString()),\n+                null,\n+                fm.getJavaFileObjects(src.resolve(\"module-info.java\"))\n+            ).call();\n+        }\n+    }\n+\n+    @Test\n+    public void testGetEndPositionWorkForImplicitParse() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        String implCode = \"\"\"\n+                          package test;\n+                          public class Impl {\n+                              public static final int C = 1 \/ 0;\n+                          }\n+                          \"\"\";\n+        tb.writeJavaFiles(src,\n+                          implCode,\n+                          \"\"\"\n+                          package test;\n+                          public class Test {\n+                              Impl i; \/\/force parsing of Impl\n+                          }\n+                          \"\"\");\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            compiler.getTask(\n+                null,\n+                null,\n+                d -> assertEquals(\"\", \/\/ideally would be \"0\", but the positions are not fully set yet\n+                                  implCode.substring((int) d.getStartPosition(),\n+                                                     (int) d.getEndPosition())),\n+                List.of(\"-sourcepath\", src.toString(), \"-Xlint:divzero\"),\n+                null,\n+                fm.getJavaFileObjects(src.resolve(\"test\").resolve(\"Test.java\"))\n+            ).call();\n+        }\n+    }\n+\n+    @Test\n+    public void testWronglyNamedClass() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        tb.writeFile(src.resolve(\"test\").resolve(\"WronglyNamed.java\"),\n+                     \"\"\"\n+                     package test;\n+                     class SomeOtherName {}\n+                     \"\"\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          public class Test {\n+                              WronglyNamed l; \/\/parse WronglyNamed.java\n+                          }\n+                          \"\"\");\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            compiler.getTask(\n+                null,\n+                null,\n+                null,\n+                List.of(\"-sourcepath\", src.toString()),\n+                null,\n+                fm.getJavaFileObjects(tb.findJavaFiles(src))\n+            ).call();\n+        }\n+    }\n+\n+    @Test\n+    public void testWronglyNamedPackageInfo() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        tb.writeFile(src.resolve(\"test\").resolve(\"package-info.java\"),\n+                     \"\"\"\n+                     package wrongpackage;\n+                     \"\"\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          public class Test {\n+                          }\n+                          \"\"\");\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            JavacTask task = (JavacTask) compiler.getTask(\n+                null,\n+                null,\n+                null,\n+                List.of(\"-sourcepath\", src.toString()),\n+                null,\n+                fm.getJavaFileObjects(src.resolve(\"test\").resolve(\"Test.java\"))\n+            );\n+            task.analyze();\n+            task.getElements().getPackageElement(\"test\").getAnnotationMirrors();\n+        }\n+    }\n+\n+    @Test\n+    public void testGetEndPositionSyntheticTree() throws Exception {\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        String testCode = \"\"\"\n+                          package test;\n+                          public class Test extends Base {\n+                          }\n+                          class Base {\n+                              Base(int i) {}\n+                          }\n+                          \"\"\";\n+\n+        tb.writeJavaFiles(src, testCode);\n+\n+        try (var fm = compiler.getStandardFileManager(null, null, null)) {\n+            compiler.getTask(\n+                null,\n+                null,\n+                d -> assertEquals(\"\",\n+                                  testCode.substring((int) d.getStartPosition(),\n+                                                     (int) d.getEndPosition())),\n+                List.of(\"-sourcepath\", src.toString(), \"-Xlint:divzero\"),\n+                null,\n+                fm.getJavaFileObjects(src.resolve(\"test\").resolve(\"Test.java\"))\n+            ).call();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/DiagnosticGetEndPosition.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7021614 8278373 8164094\n+ * @bug 7021614 8278373 8164094 8371248\n@@ -46,0 +46,1 @@\n+import java.util.Map;\n@@ -86,0 +87,25 @@\n+ * {@link double Class}\n+ * {@link double.NAN Bad}\n+ * {@link double#NAN Bad}\n+ * {@link double#double Bad}\n+ * {@link java.base\/double Bad}\n+ *\n+ * {@link List<String> Interface}\n+ * {@link List<String>.add Bad}\n+ * {@link List<String>#add Method}\n+ * {@link List<String>#add(Object) Method}\n+ * {@link Map<String, String>.Entry Interface}\n+ * {@link Map<String, String>.Entry<String, String> Interface}\n+ * {@link Map<String, String>.Entry<String, String>.getKey Bad}\n+ * {@link Map<String, String>.Entry<String, String>#getKey Method}\n+ * {@link Map<String, String>.Entry<String, String>#setValue(Object) Method}\n+ *\n+ * {@link java.base\/java.util.List<String> Bad}\n+ * {@link java.base\/java.util.List<String>.add Bad}\n+ * {@link java.base\/java.util.List<String>#add Bad}\n+ * {@link java.base\/java.util.List<String>#add(Object) Bad}\n+ * {@link java.base\/java.util.Map<String, String>.Entry Bad}\n+ * {@link java.base\/java.util.Map<String, String>.Entry<String, String> Bad}\n+ * {@link java.base\/java.util.Map<String, String>.Entry<String, String>.getKey Bad}\n+ * {@link java.base\/java.util.Map<String, String>.Entry<String, String>#getKey Bad}\n+ * {@link java.base\/java.util.Map<String, String>.Entry<String, String>#setValue(Object) Bad}\n","filename":"test\/langtools\/tools\/javac\/doctree\/ReferenceTest.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @compile\/fail\/ref=ResultTypeNotBeingCapturedTest_2.out -XDrawDiagnostics -source 25 ResultTypeNotBeingCapturedTest.java\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/ResultTypeNotBeingCapturedTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-ResultTypeNotBeingCapturedTest.java:43:66: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<compiler.misc.type.captureof: 1, ?>>, ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<?>>)\n-ResultTypeNotBeingCapturedTest.java:47:42: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<compiler.misc.type.captureof: 1, ?>>, ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<?>>)\n+ResultTypeNotBeingCapturedTest.java:44:66: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<compiler.misc.type.captureof: 1, ?>>, ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<?>>)\n+ResultTypeNotBeingCapturedTest.java:48:42: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<compiler.misc.type.captureof: 1, ?>>, ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<?>>)\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/ResultTypeNotBeingCapturedTest.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+- compiler.warn.source.no.system.modules.path: 25, (compiler.misc.source.no.system.modules.path: 25)\n+ResultTypeNotBeingCapturedTest.java:48:42: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<compiler.misc.type.captureof: 1, ?>>, ResultTypeNotBeingCapturedTest.X<ResultTypeNotBeingCapturedTest.X<?>>)\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/lambda\/methodReference\/ResultTypeNotBeingCapturedTest_2.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230 8338678 8351260 8366196\n+ * @bug 8301580 8322159 8333107 8332230 8338678 8351260 8366196 8372336\n@@ -35,0 +35,2 @@\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MethodInvocationTree;\n@@ -40,0 +42,1 @@\n+import java.nio.file.Files;\n@@ -397,0 +400,98 @@\n+\n+    @Test \/\/JDK-8372336\n+    public void testCompletionFailureNoBreakInvocation() throws Exception {\n+        Path curPath = Path.of(\".\");\n+        Path lib = curPath.resolve(\"lib\");\n+        Path classes = lib.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .sources(\"\"\"\n+                     package test;\n+                     public class Intermediate extends Base {}\n+                     \"\"\",\n+                     \"\"\"\n+                     package test;\n+                     public class Base {\n+                         public int get() {\n+                             return -1;\n+                         }\n+                     }\n+                     \"\"\")\n+            .run()\n+            .writeAll();\n+\n+        Files.delete(classes.resolve(\"test\").resolve(\"Base.class\"));\n+\n+        record TestCase(String code, String... expectedErrors) {}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                         package test;\n+                         public class Test {\n+                             private void test(Intermediate i) {\n+                                 int j = i != null ? i.get() : -1;\n+                             }\n+                         }\n+                         \"\"\",\n+                         \"Test.java:4:30: compiler.err.cant.access: test.Base, (compiler.misc.class.file.not.found: test.Base)\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                         package test;\n+                         public class Test {\n+                             private void test(Intermediate i) {\n+                                 i.get();\n+                             }\n+                         }\n+                         \"\"\",\n+                         \"Test.java:4:10: compiler.err.cant.access: test.Base, (compiler.misc.class.file.not.found: test.Base)\",\n+                         \"1 error\")\n+        };\n+\n+        for (TestCase tc : testCases) {\n+            List<String> actual = new JavacTask(tb)\n+                    .options(\"-XDrawDiagnostics\", \"-XDdev\")\n+                    .classpath(classes)\n+                    .sources(tc.code())\n+                    .outdir(curPath)\n+                    .callback(task -> {\n+                        task.addTaskListener(new TaskListener() {\n+                            @Override\n+                            public void finished(TaskEvent e) {\n+                                if (e.getKind() != TaskEvent.Kind.ANALYZE) {\n+                                    return ;\n+                                }\n+                                Trees trees = Trees.instance(task);\n+                                new TreePathScanner<Void, Void>() {\n+                                    @Override\n+                                    public Void visitMethodInvocation(MethodInvocationTree node, Void p) {\n+                                        if (!node.toString().contains(\"super\")) {\n+                                            verifyElement();\n+                                        }\n+                                        return super.visitMethodInvocation(node, p);\n+                                    }\n+                                    @Override\n+                                    public Void visitMemberReference(MemberReferenceTree node, Void p) {\n+                                        verifyElement();\n+                                        return super.visitMemberReference(node, p);\n+                                    }\n+                                    private void verifyElement() {\n+                                        Element el = trees.getElement(getCurrentPath());\n+                                        if (!el.getSimpleName().contentEquals(\"get\")) {\n+                                            error(\"Expected good Element, but got: \" + el);\n+                                        }\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        });\n+                    })\n+                    .run(Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expected = List.of(tc.expectedErrors);\n+\n+            if (!Objects.equals(actual, expected)) {\n+                error(\"Expected: \" + expected + \", but got: \" + actual);\n+            }\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MinMaxVector.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package org.openjdk.bench.java.lang.foreign;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-import jdk.internal.misc.Unsafe;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.MemorySegment;\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n-import java.util.concurrent.TimeUnit;\n-\n-import static java.lang.foreign.ValueLayout.JAVA_INT;\n-import static java.lang.foreign.ValueLayout.JAVA_INT_UNALIGNED;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Fork(value = 3, jvmArgs = { \"--add-opens=java.base\/jdk.internal.misc=ALL-UNNAMED\" })\n-public class BulkOps {\n-\n-    static final Unsafe unsafe = Utils.unsafe;\n-\n-    static final int ELEM_SIZE = 1_000_000;\n-    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n-    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n-\n-    final Arena arena = Arena.ofShared();\n-\n-    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-    final MemorySegment segment = arena.allocate(ALLOC_SIZE, 1);\n-\n-    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n-\n-    final int[] ints = new int[ELEM_SIZE];\n-    @SuppressWarnings(\"initialization\")\n-    final MemorySegment bytesSegment = MemorySegment.ofArray(ints);\n-    final long UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n-\n-    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n-    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n-    final MemorySegment mismatchSegmentLarge1;\n-\n-    {\n-        mismatchSegmentLarge1 = arena.allocate(SIZE_WITH_TAIL, 1);\n-    }\n-\n-    final MemorySegment mismatchSegmentLarge2 = arena.allocate(SIZE_WITH_TAIL, 1);\n-    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-\n-    \/\/ mismatch at first byte\n-    final MemorySegment mismatchSegmentSmall1 = arena.allocate(7, 1);\n-    final MemorySegment mismatchSegmentSmall2 = arena.allocate(7, 1);\n-    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-\n-    @Setup\n-    public void setup() {\n-        mismatchSegmentSmall1.fill((byte) 0xFF);\n-        mismatchBufferSmall1.put((byte) 0xFF).clear();\n-        \/\/ verify expected mismatch indices\n-        long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-        if (si != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-        if (bi != -1)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-        si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-        if (si != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + si);\n-        bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-        if (bi != 0)\n-            throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n-\n-        for (int i = 0; i < ints.length ; i++) {\n-            ints[i] = i;\n-        }\n-    }\n-\n-    @TearDown\n-    public void tearDown() {\n-        arena.close();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_fill() {\n-        unsafe.setMemory(unsafe_addr, ALLOC_SIZE, (byte)42);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_fill() {\n-        segment.fill((byte)42);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_copy() {\n-        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, ALLOC_SIZE);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy() {\n-        segment.copyFrom(bytesSegment);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_small() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_small_dontinline() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void unsafe_copy_small() {\n-        unsafe.copyMemory(ints, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void buffer_copy_small() {\n-        buffer.put(0, ints, 0, 10);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void buffer_copy() {\n-        buffer.put(0, ints, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void segment_copy_static_dontinline() {\n-        MemorySegment.copy(ints, 0, segment, JAVA_INT_UNALIGNED, 0, ints.length);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_large_segment() {\n-        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_large_bytebuffer() {\n-        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public long mismatch_small_segment() {\n-        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int mismatch_small_bytebuffer() {\n-        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/BulkOps.java","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -42,0 +43,1 @@\n+import java.util.Random;\n@@ -44,0 +46,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -52,24 +56,2 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n-    public int ELEM_SIZE;\n-\n-    byte[] srcArray;\n-    byte[] dstArray;\n-    MemorySegment heapSrcSegment;\n-    MemorySegment heapDstSegment;\n-    MemorySegment nativeSrcSegment;\n-    MemorySegment nativeDstSegment;\n-    ByteBuffer srcBuffer;\n-    ByteBuffer dstBuffer;\n-\n-    @Setup\n-    public void setup() {\n-        srcArray = new byte[ELEM_SIZE];\n-        dstArray = new byte[ELEM_SIZE];\n-        heapSrcSegment = MemorySegment.ofArray(srcArray);\n-        heapDstSegment = MemorySegment.ofArray(dstArray);\n-        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n-        srcBuffer = ByteBuffer.wrap(srcArray);\n-        dstBuffer = ByteBuffer.wrap(dstArray);\n-    }\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n@@ -77,4 +59,1 @@\n-    @Benchmark\n-    public void arrayCopy() {\n-        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n-    }\n+    public static class Array extends SegmentBulkCopy {\n@@ -82,4 +61,2 @@\n-    @Benchmark\n-    public void bufferCopy() {\n-        dstBuffer.put(srcBuffer);\n-    }\n+        byte[] srcArray;\n+        byte[] dstArray;\n@@ -87,5 +64,2 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n-    @Benchmark\n-    public void heapSegmentCopyJava() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n+        ByteBuffer srcBuffer;\n+        ByteBuffer dstBuffer;\n@@ -93,5 +67,19 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n-    @Benchmark\n-    public void heapSegmentCopyUnsafe() {\n-        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n-    }\n+        @Setup\n+        public void setup() {\n+            srcArray = new byte[size];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(srcArray);\n+            dstArray = new byte[size];\n+            srcBuffer = ByteBuffer.wrap(srcArray);\n+            dstBuffer = ByteBuffer.wrap(dstArray);\n+        }\n+\n+        @Benchmark\n+        public void arrayCopy() {\n+            System.arraycopy(srcArray, 0, dstArray, 0, size);\n+        }\n+\n+        @Benchmark\n+        public void bufferCopy() {\n+            dstBuffer.put(0, srcBuffer, 0, size);\n+        }\n@@ -99,4 +87,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n-    @Benchmark\n-    public void nativeSegmentCopyJava() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n@@ -105,4 +89,83 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n-    @Benchmark\n-    public void nativeSegmentCopyUnsafe() {\n-        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    public static class Segment extends SegmentBulkCopy {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment srcSegment;\n+        MemorySegment dstSegment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n+\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n+\n+            switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP -> {\n+                    srcSegment = MemorySegment.ofArray(baseArray);\n+                    dstSegment = MemorySegment.ofArray(baseArray.clone());\n+                }\n+                case NATIVE -> {\n+                    srcSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, baseArray);\n+                    dstSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, baseArray);\n+                }\n+            }\n+            switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(0, size);\n+                    dstSegment = dstSegment.asSlice(0, size);\n+                }\n+                case UNALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(1, size);\n+                    dstSegment = dstSegment.asSlice(1, size);\n+                }\n+            }\n+        }\n+\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=31\"})\n+        public void copy() {\n+            MemorySegment.copy(srcSegment, 0, dstSegment, 0, size);\n+        }\n+\n+        @Benchmark\n+        public void copyLoopIntInt() {\n+            for (int i = 0; i < (int) srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void copyLoopIntLong() {\n+            for (int i = 0; i < srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void copyLoopLongLong() {\n+            for (long i = 0; i < srcSegment.byteSize(); i++) {\n+                final byte v = srcSegment.get(ValueLayout.JAVA_BYTE, i);\n+                dstSegment.set(ValueLayout.JAVA_BYTE, i, v);\n+            }\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.copy=0\"})\n+        @Benchmark\n+        public void copyUnsafe() {\n+            MemorySegment.copy(srcSegment, 0, dstSegment, 0, size);\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkCopy.java","additions":114,"deletions":51,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -54,18 +56,1 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n-    public int ELEM_SIZE;\n-\n-    byte[] array;\n-    MemorySegment heapSegment;\n-    MemorySegment nativeSegment;\n-    MemorySegment unalignedSegment;\n-    ByteBuffer buffer;\n-\n-    @Setup\n-    public void setup() {\n-        array = new byte[ELEM_SIZE];\n-        heapSegment = MemorySegment.ofArray(array);\n-        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n-        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n-        buffer = ByteBuffer.wrap(array);\n-    }\n+    private static final byte ZERO = 0;\n@@ -73,4 +58,2 @@\n-    @Benchmark\n-    public void arraysFill() {\n-        Arrays.fill(array, (byte) 0);\n-    }\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n@@ -78,6 +61,4 @@\n-    @Benchmark\n-    public void arraysFillLoop() {\n-        for (int i = 0; i < array.length; i++) {\n-            array[i] = 0;\n-        }\n-    }\n+    public static class Array extends SegmentBulkFill {\n+\n+        byte[] array;\n+        ByteBuffer buffer;\n@@ -85,4 +66,4 @@\n-    @Benchmark\n-    public void bufferFillLoop() {\n-        for (int i = 0; i < array.length; i++) {\n-            buffer.put(i, (byte)0);\n+        @Setup\n+        public void setup() {\n+            array = new byte[size];\n+            buffer = ByteBuffer.wrap(array);\n@@ -90,1 +71,0 @@\n-    }\n@@ -92,5 +72,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void heapSegmentFillJava() {\n-        heapSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void arraysFill() {\n+            Arrays.fill(array, ZERO);\n+        }\n@@ -98,5 +77,6 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void heapSegmentFillUnsafe() {\n-        heapSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void arraysFillLoop() {\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = ZERO;\n+            }\n+        }\n@@ -104,4 +84,5 @@\n-    @Benchmark\n-    public void heapSegmentFillLoop() {\n-        for (long i = 0; i < heapSegment.byteSize(); i++) {\n-            heapSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Benchmark\n+        public void bufferFillLoop() {\n+            for (int i = 0; i < array.length; i++) {\n+                buffer.put(i, ZERO);\n+            }\n@@ -109,1 +90,0 @@\n-    }\n@@ -111,4 +91,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void nativeSegmentFillJava() {\n-        nativeSegment.fill((byte) 0);\n@@ -117,5 +93,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void nativeSegmentFillUnsafe() {\n-        nativeSegment.fill((byte) 0);\n-    }\n+    public static class Segment extends SegmentBulkFill {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n@@ -123,4 +98,22 @@\n-    @Benchmark\n-    public void nativeSegmentFillLoop() {\n-        for (long i = 0; i < nativeSegment.byteSize(); i++) {\n-            nativeSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment segment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray = new long[size \/ Long.BYTES + 1];\n+            var heapSegment = MemorySegment.ofArray(baseArray);\n+\n+            segment = switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP   -> heapSegment;\n+                case NATIVE -> Arena.ofAuto().allocateFrom(JAVA_LONG, baseArray);\n+            };\n+            segment = switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> segment.asSlice(0, size);\n+                case UNALIGNED -> segment.asSlice(1, size);\n+            };\n@@ -128,1 +121,0 @@\n-    }\n@@ -130,5 +122,5 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n-    @Benchmark\n-    public void unalignedSegmentFillJava() {\n-        unalignedSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+        public void fill() {\n+            segment.fill(ZERO);\n+        }\n@@ -136,5 +128,13 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n-    @Benchmark\n-    public void unalignedSegmentFillUnsafe() {\n-        unalignedSegment.fill((byte) 0);\n-    }\n+        @Benchmark\n+        public void fillLoopIntInt() {\n+            for (int i = 0; i < (int)segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void fillLoopIntLong() {\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n+        }\n@@ -142,4 +142,5 @@\n-    @Benchmark\n-    public void unalignedSegmentFillLoop() {\n-        for (long i = 0; i < unalignedSegment.byteSize(); i++) {\n-            unalignedSegment.set(ValueLayout.JAVA_BYTE, i, (byte) 0);\n+        @Benchmark\n+        public void fillLoopLongLong() {\n+            for (long i = 0; i < segment.byteSize(); i++) {\n+                segment.set(ValueLayout.JAVA_BYTE, i, ZERO);\n+            }\n@@ -147,0 +148,7 @@\n+\n+        @Benchmark\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n+        public void fillUnsafe() {\n+            segment.fill(ZERO);\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkFill.java","additions":85,"deletions":77,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n@@ -57,2 +58,2 @@\n-    @Param({\"8\", \"64\"})\n-    public int ELEM_SIZE;\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n@@ -60,3 +61,1 @@\n-    byte[] array;\n-    AbstractMemorySegmentImpl heapSegment;\n-    AbstractMemorySegmentImpl nativeSegment;\n+    public static class Array extends SegmentBulkHash {\n@@ -64,7 +63,9 @@\n-    @Setup\n-    public void setup() {\n-        \/\/ Always use the same alignment regardless of size\n-        nativeSegment = (AbstractMemorySegmentImpl) Arena.ofAuto().allocate(ELEM_SIZE, 16);\n-        var rnd = new Random(42);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            nativeSegment.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+        byte[] array;\n+\n+        @Setup\n+        public void setup() {\n+            byte[]  randomArray = new byte[size + 1];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(randomArray);\n+\n+            array = Arrays.copyOf(randomArray, size);\n@@ -72,3 +73,0 @@\n-        array = nativeSegment.toArray(JAVA_BYTE);\n-        heapSegment = (AbstractMemorySegmentImpl) MemorySegment.ofArray(array);\n-    }\n@@ -76,4 +74,4 @@\n-    @Benchmark\n-    public int array() {\n-        return Arrays.hashCode(array);\n-    }\n+        @Benchmark\n+        public int array() {\n+            return Arrays.hashCode(array);\n+        }\n@@ -81,3 +79,0 @@\n-    @Benchmark\n-    public int heapSegment() {\n-        return SegmentBulkOperations.contentHash(heapSegment, 0, ELEM_SIZE);\n@@ -86,4 +81,17 @@\n-    @Benchmark\n-    public int nativeSegment() {\n-        return SegmentBulkOperations.contentHash(nativeSegment, 0, ELEM_SIZE);\n-    }\n+    public static class Segment extends SegmentBulkHash {\n+\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        AbstractMemorySegmentImpl segment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n@@ -91,5 +99,31 @@\n-    @Benchmark\n-    public int nativeSegmentJava() {\n-        int result = 1;\n-        for (long i = 0; i < ELEM_SIZE; i++) {\n-            result = 31 * result + nativeSegment.get(JAVA_BYTE, i);\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n+            var heapSegment = MemorySegment.ofArray(baseArray);\n+\n+            var s = switch (SegmentType.valueOf(segmentType)) {\n+                    case HEAP   -> heapSegment;\n+                    case NATIVE -> Arena.ofAuto().allocateFrom(JAVA_LONG, baseArray);\n+            };\n+            s = switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED   -> s.asSlice(0, size);\n+                case UNALIGNED -> s.asSlice(1, size);\n+            };\n+\n+            segment = (AbstractMemorySegmentImpl) s;\n+        }\n+\n+        @Benchmark\n+        public int hash() {\n+            return SegmentBulkOperations.contentHash(segment, 0, size);\n+        }\n+\n+        @Benchmark\n+        public int hashLoopIntInt() {\n+            int result = 1;\n+            for (int i = 0; i < (int)segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+            return result;\n@@ -97,1 +131,19 @@\n-        return result;\n+\n+        @Benchmark\n+        public int hashLoopIntLong() {\n+            int result = 1;\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+            return result;\n+        }\n+\n+        @Benchmark\n+        public int hashLoopLongLong() {\n+            int result = 1;\n+            for (long i = 0; i < segment.byteSize(); i++) {\n+                result = 31 * result + segment.get(JAVA_BYTE, i);\n+            }\n+            return result;\n+        }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkHash.java","additions":85,"deletions":33,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -55,19 +56,14 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n-            \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n-    public int ELEM_SIZE;\n-\n-    MemorySegment srcNative;\n-    MemorySegment dstNative;\n-    byte[] srcArray;\n-    byte[] dstArray;\n-    MemorySegment srcHeap;\n-    MemorySegment dstHeap;\n-\n-    @Setup\n-    public void setup() {\n-        \/\/ Always use the same alignment regardless of size\n-        srcNative = Arena.ofAuto().allocate(ELEM_SIZE,16);\n-        dstNative = Arena.ofAuto().allocate(ELEM_SIZE, 16);\n-        var rnd = new Random(42);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            srcNative.set(JAVA_BYTE, i, (byte) rnd.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+    @Param({\"2\", \"4\", \"8\", \"12\", \"16\", \"64\", \"512\", \"4096\", \"32768\", \"262144\", \"2097152\", \"16777216\", \"134217728\"})\n+    public int size;\n+\n+    public static class Array extends SegmentBulkMismatch {\n+\n+        byte[] srcArray;\n+        byte[] dstArray;\n+\n+        @Setup\n+        public void setup() {\n+            srcArray = new byte[size];\n+            var rnd = new Random(42);\n+            rnd.nextBytes(srcArray);\n+            dstArray = Arrays.copyOf(srcArray, size);\n@@ -75,6 +71,0 @@\n-        dstNative.copyFrom(srcNative);\n-        srcArray = srcNative.toArray(JAVA_BYTE);\n-        dstArray = dstNative.toArray(JAVA_BYTE);\n-        srcHeap = MemorySegment.ofArray(srcArray);\n-        dstHeap = MemorySegment.ofArray(dstArray);\n-    }\n@@ -82,5 +72,4 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n-    @Benchmark\n-    public long nativeSegmentJava() {\n-        return srcNative.mismatch(dstNative);\n-    }\n+        @Benchmark\n+        public long array() {\n+            return Arrays.mismatch(srcArray, dstArray);\n+        }\n@@ -88,4 +77,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n-    @Benchmark\n-    public long heapSegmentJava() {\n-        return srcHeap.mismatch(dstHeap);\n@@ -94,5 +79,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n-    @Benchmark\n-    public long nativeSegmentUnsafe() {\n-        return srcNative.mismatch(dstNative);\n-    }\n+    public static class Segment extends SegmentBulkMismatch {\n@@ -100,5 +81,90 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n-    @Benchmark\n-    public long heapSegmentUnsafe() {\n-        return srcHeap.mismatch(dstHeap);\n-    }\n+        enum SegmentType {HEAP, NATIVE}\n+        enum Alignment {ALIGNED, UNALIGNED}\n+\n+        @Param({\"HEAP\", \"NATIVE\"})\n+        String segmentType;\n+\n+        @Param({\"ALIGNED\", \"UNALIGNED\"})\n+        String alignment;\n+\n+        MemorySegment srcSegment;\n+        MemorySegment dstSegment;\n+\n+        @Setup\n+        public void setup() {\n+            \/\/ A long array is likely to be aligned at 8-byte boundaries\n+            long[] baseArray;\n+\n+            baseArray = new long[size \/ Long.BYTES + 1];\n+            var rnd = new Random(42);\n+            for (int i = 0; i < baseArray.length; i++) {\n+                baseArray[i] = rnd.nextLong();\n+            }\n+\n+            switch (SegmentType.valueOf(segmentType)) {\n+                case HEAP -> {\n+                    srcSegment = MemorySegment.ofArray(baseArray);\n+                    dstSegment = MemorySegment.ofArray(baseArray.clone());\n+                }\n+                case NATIVE -> {\n+                    var s = MemorySegment.ofArray(baseArray);\n+                    srcSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, baseArray);\n+                    dstSegment = Arena.ofAuto().allocateFrom(JAVA_LONG, baseArray);\n+                }\n+            }\n+            switch (Alignment.valueOf(alignment)) {\n+                case ALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(0, size);\n+                    dstSegment = dstSegment.asSlice(0, size);\n+                }\n+                case UNALIGNED -> {\n+                    srcSegment = srcSegment.asSlice(1, size);\n+                    dstSegment = dstSegment.asSlice(1, size);\n+                }\n+            }\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=31\"})\n+        @Benchmark\n+        public long mismatch() {\n+            return srcSegment.mismatch(dstSegment);\n+        }\n+\n+        @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.mismatch=0\"})\n+        @Benchmark\n+        public long mismatchUnsafe() {\n+            return srcSegment.mismatch(dstSegment);\n+        }\n+\n+        @Benchmark\n+        public long mismatchLoopIntInt() {\n+            \/\/ Simplified version that assumes the segments are of equal size\n+            for (int i = 0; i < (int)srcSegment.byteSize(); i++) {\n+                if (srcSegment.get(ValueLayout.JAVA_BYTE, i) != dstSegment.get(ValueLayout.JAVA_BYTE, i)) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Benchmark\n+        public long mismatchLoopIntLong() {\n+            \/\/ Simplified version that assumes the segments are of equal size\n+            for (int i = 0; i < srcSegment.byteSize(); i++) {\n+                if (srcSegment.get(ValueLayout.JAVA_BYTE, i) != dstSegment.get(ValueLayout.JAVA_BYTE, i)) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n+\n+        @Benchmark\n+        public long mismatchLoopLongLong() {\n+            \/\/ Simplified version that assumes the segments are of equal size\n+            for (long i = 0; i < srcSegment.byteSize(); i++) {\n+                if (srcSegment.get(ValueLayout.JAVA_BYTE, i) != dstSegment.get(ValueLayout.JAVA_BYTE, i)) {\n+                    return i;\n+                }\n+            }\n+            return -1;\n+        }\n@@ -106,3 +172,0 @@\n-    @Benchmark\n-    public long array() {\n-        return Arrays.mismatch(srcArray, dstArray);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkMismatch.java","additions":111,"deletions":48,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.sun.net.httpserver;\n+\n+import com.sun.net.httpserver.Headers;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+\n+\/**\n+ * Benchmarks {@code jdk.httpserver} header normalization.\n+ * <p>\n+ * You can run this benchmark as follows:\n+ * <pre>{@code\n+ * make run-test TEST=\"micro:HeaderNormalization\" MICRO=\"OPTIONS=-prof gc\"\n+ * }<\/pre>\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\n+        \"--add-exports\", \"jdk.httpserver\/com.sun.net.httpserver=ALL-UNNAMED\",\n+        \"--add-opens\", \"jdk.httpserver\/com.sun.net.httpserver=ALL-UNNAMED\",\n+})\n+public class HeaderNormalization {\n+\n+    private static final Function<String, String> NORMALIZE = findNormalize();\n+\n+    private static Function<String, String> findNormalize() {\n+        var lookup = MethodHandles.lookup();\n+        MethodHandle handle;\n+        try {\n+            handle = MethodHandles\n+                    .privateLookupIn(Headers.class, lookup)\n+                    .findStatic(\n+                            Headers.class, \"normalize\",\n+                            MethodType.methodType(String.class, String.class));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        return key -> {\n+            try {\n+                return (String) handle.invokeExact(key);\n+            } catch (Throwable e) {\n+                throw new RuntimeException(e);\n+            }\n+        };\n+    }\n+\n+    @Param({\n+            \"Accept-charset\",   \/\/ Already normalized\n+            \"4ccept-charset\",   \/\/ Already normalized with a non-alpha first letter\n+            \"accept-charset\",   \/\/ Only the first `a` must be upper-cased\n+            \"Accept-Charset\",   \/\/ Only `c` must be lower-cased\n+            \"ACCEPT-CHARSET\",   \/\/ All secondary must be lower-cased\n+    })\n+    private String key;\n+\n+    @Benchmark\n+    public String n26() {\n+        return NORMALIZE.apply(key);\n+    }\n+\n+    @Benchmark\n+    public String n25() {\n+        return normalize25(key);\n+    }\n+\n+    \/**\n+     * The {@code com.sun.net.httpserver.Headers::normalize} method used in Java 25 and before.\n+     *\/\n+    private static String normalize25(String key) {\n+        Objects.requireNonNull(key);\n+        int len = key.length();\n+        if (len == 0) {\n+            return key;\n+        }\n+        char[] b = key.toCharArray();\n+        if (b[0] >= 'a' && b[0] <= 'z') {\n+            b[0] = (char)(b[0] - ('a' - 'A'));\n+        } else if (b[0] == '\\r' || b[0] == '\\n')\n+            throw new IllegalArgumentException(\"illegal character in key\");\n+\n+        for (int i=1; i<len; i++) {\n+            if (b[i] >= 'A' && b[i] <= 'Z') {\n+                b[i] = (char) (b[i] + ('a' - 'A'));\n+            } else if (b[i] == '\\r' || b[i] == '\\n')\n+                throw new IllegalArgumentException(\"illegal character in key\");\n+        }\n+        return new String(b);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/sun\/net\/httpserver\/HeaderNormalization.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}