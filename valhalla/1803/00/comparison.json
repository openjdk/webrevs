{"files":[{"patch":"@@ -5357,3 +5357,0 @@\n-  if (ik->is_inline_klass()) {\n-    InlineKlass::cast(ik)->init_fixed_block();\n-  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+InlineKlass::InlineKlass() {\n+  assert(CDSConfig::is_dumping_archive() || UseSharedSpaces, \"only for CDS\");\n+}\n+\n@@ -61,1 +65,0 @@\n-}\n@@ -63,3 +66,2 @@\n-InlineKlass::InlineKlass() {\n-  assert(CDSConfig::is_dumping_archive() || UseSharedSpaces, \"only for CDS\");\n-}\n+  \/\/ Set up the offset to the InstanceKlassFixedBlock of this klass\n+  _adr_inlineklass_fixed_block = new (calculate_fixed_block_address()) InlineKlassFixedBlock;\n@@ -67,2 +69,0 @@\n-void InlineKlass::init_fixed_block() {\n-  _adr_inlineklass_fixed_block = inlineklass_static_block();\n@@ -70,5 +70,6 @@\n-  *((Array<SigEntry>**)adr_extended_sig()) = nullptr;\n-  *((Array<VMRegPair>**)adr_return_regs()) = nullptr;\n-  *((address*)adr_pack_handler()) = nullptr;\n-  *((address*)adr_pack_handler_jobject()) = nullptr;\n-  *((address*)adr_unpack_handler()) = nullptr;\n+  set_extended_sig(nullptr);\n+  set_return_regs(nullptr);\n+  set_pack_handler(nullptr);\n+  set_pack_handler_jobject(nullptr);\n+  set_unpack_handler(nullptr);\n+\n@@ -76,0 +77,1 @@\n+\n@@ -87,0 +89,5 @@\n+address InlineKlass::calculate_fixed_block_address() const {\n+  \/\/ The fix block is placed after all other fields inherited from the InstanceKlass\n+  return end_of_instance_klass();\n+}\n+\n@@ -394,1 +401,1 @@\n-    *((Array<SigEntry>**)adr_extended_sig()) = extended_sig;\n+    set_extended_sig(extended_sig);\n@@ -408,1 +415,1 @@\n-        *((Array<VMRegPair>**)adr_return_regs()) = return_regs;\n+        set_return_regs(return_regs);\n@@ -417,3 +424,3 @@\n-        *((address*)adr_pack_handler()) = buffered_blob->pack_fields();\n-        *((address*)adr_pack_handler_jobject()) = buffered_blob->pack_fields_jobject();\n-        *((address*)adr_unpack_handler()) = buffered_blob->unpack_fields();\n+        set_pack_handler(buffered_blob->pack_fields());\n+        set_pack_handler_jobject(buffered_blob->pack_fields_jobject());\n+        set_unpack_handler(buffered_blob->unpack_fields());\n@@ -433,2 +440,2 @@\n-    MetadataFactory::free_array<SigEntry>(loader_data, extended_sig());\n-    *((Array<SigEntry>**)adr_extended_sig()) = nullptr;\n+    MetadataFactory::free_array<SigEntry>(loader_data, fixed_block()._extended_sig);\n+    set_extended_sig(nullptr);\n@@ -437,2 +444,2 @@\n-    MetadataFactory::free_array<VMRegPair>(loader_data, return_regs());\n-    *((Array<VMRegPair>**)adr_return_regs()) = nullptr;\n+    MetadataFactory::free_array<VMRegPair>(loader_data, fixed_block()._return_regs);\n+    set_return_regs(nullptr);\n@@ -453,3 +460,3 @@\n-    *((address*)adr_pack_handler()) = nullptr;\n-    *((address*)adr_pack_handler_jobject()) = nullptr;\n-    *((address*)adr_unpack_handler()) = nullptr;\n+    set_pack_handler(nullptr);\n+    set_pack_handler_jobject(nullptr);\n+    set_unpack_handler(nullptr);\n@@ -655,1 +662,1 @@\n-  _adr_inlineklass_fixed_block = inlineklass_static_block();\n+  _adr_inlineklass_fixed_block = reinterpret_cast<InlineKlassFixedBlock*>(calculate_fixed_block_address());\n@@ -658,5 +665,6 @@\n-  *((Array<SigEntry>**)adr_extended_sig()) = nullptr;\n-  *((Array<VMRegPair>**)adr_return_regs()) = nullptr;\n-  *((address*)adr_pack_handler()) = nullptr;\n-  *((address*)adr_pack_handler_jobject()) = nullptr;\n-  *((address*)adr_unpack_handler()) = nullptr;\n+  set_extended_sig(nullptr);\n+  set_return_regs(nullptr);\n+  set_pack_handler(nullptr);\n+  set_pack_handler_jobject(nullptr);\n+  set_unpack_handler(nullptr);\n+\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n@@ -54,3 +53,3 @@\n-  void init_fixed_block();\n-  inline InlineKlassFixedBlock* inlineklass_static_block() const;\n-  inline address adr_return_regs() const;\n+  \/\/ After the InstanceKlass part of the InlineKlass comes the\n+  \/\/ InlineKlassFixedBlock. It can't be instantiated as a field\n+  \/\/ because InstanceKlass instances have dynamic size.\n@@ -58,4 +57,1 @@\n-  address adr_extended_sig() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _extended_sig));\n-  }\n+  address calculate_fixed_block_address() const;\n@@ -63,4 +59,3 @@\n-  \/\/ pack and unpack handlers for inline types return\n-  address adr_pack_handler() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _pack_handler));\n+  InlineKlassFixedBlock& fixed_block() {\n+    assert(_adr_inlineklass_fixed_block != 0, \"Should have been initialized\");\n+    return *_adr_inlineklass_fixed_block;\n@@ -69,3 +64,3 @@\n-  address adr_pack_handler_jobject() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _pack_handler_jobject));\n+  inline const InlineKlassFixedBlock& fixed_block() const {\n+    InlineKlass* ik = const_cast<InlineKlass*>(this);\n+    return const_cast<const InlineKlassFixedBlock&>(ik->fixed_block());\n@@ -74,4 +69,1 @@\n-  address adr_unpack_handler() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _unpack_handler));\n-  }\n+ public:\n@@ -79,4 +71,2 @@\n-  address adr_null_reset_value_offset() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(null_reset_value_offset_offset());\n-  }\n+  bool is_empty_inline_type() const   { return _misc_flags.is_empty_inline_type(); }\n+  void set_is_empty_inline_type()     { _misc_flags.set_is_empty_inline_type(true); }\n@@ -84,4 +74,1 @@\n-  address adr_payload_offset() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _payload_offset));\n-  }\n+  \/\/ InlineKlassFixedBlock access functions\n@@ -89,4 +76,2 @@\n-  address adr_payload_size_in_bytes() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _payload_size_in_bytes));\n-  }\n+  const Array<SigEntry>* extended_sig() const                 {return fixed_block()._extended_sig; }\n+  void set_extended_sig(Array<SigEntry>* extended_sig)        { fixed_block()._extended_sig = extended_sig; }\n@@ -94,4 +79,2 @@\n-  address adr_payload_alignment() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _payload_alignment));\n-  }\n+  const Array<VMRegPair>* return_regs() const                 { return fixed_block()._return_regs; }\n+  void set_return_regs(Array<VMRegPair>* return_regs)         { fixed_block()._return_regs = return_regs; }\n@@ -99,4 +82,1 @@\n-  address adr_non_atomic_size_in_bytes() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _non_atomic_size_in_bytes));\n-  }\n+  \/\/ pack and unpack handlers for inline types return\n@@ -104,4 +84,2 @@\n-  address adr_non_atomic_alignment() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _non_atomic_alignment));\n-  }\n+  address pack_handler() const                                { return fixed_block()._pack_handler; }\n+  void set_pack_handler(address pack_handler)                 { fixed_block()._pack_handler = pack_handler; }\n@@ -109,4 +87,2 @@\n-  address adr_atomic_size_in_bytes() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _atomic_size_in_bytes));\n-  }\n+  address pack_handler_jobject() const                        { return fixed_block()._pack_handler_jobject; }\n+  void set_pack_handler_jobject(address pack_handler_jobject) { fixed_block()._pack_handler_jobject = pack_handler_jobject; }\n@@ -114,4 +90,2 @@\n-  address adr_nullable_atomic_size_in_bytes() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _nullable_size_in_bytes));\n-  }\n+  address unpack_handler() const                              { return fixed_block()._unpack_handler; }\n+  void set_unpack_handler(address unpack_handler)             { fixed_block()._unpack_handler = unpack_handler; }\n@@ -119,3 +93,4 @@\n-  address adr_null_marker_offset() const {\n-    assert(_adr_inlineklass_fixed_block != nullptr, \"Should have been initialized\");\n-    return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _null_marker_offset));\n+  int null_reset_value_offset() {\n+    int offset = fixed_block()._null_reset_value_offset;\n+    assert(offset != 0, \"must not be called if not initialized\");\n+    return offset;\n@@ -123,5 +98,1 @@\n-\n- public:\n-\n-  bool is_empty_inline_type() const   { return _misc_flags.is_empty_inline_type(); }\n-  void set_is_empty_inline_type()     { _misc_flags.set_is_empty_inline_type(true); }\n+  void set_null_reset_value_offset(int offset)                { fixed_block()._null_reset_value_offset = offset; }\n@@ -130,1 +101,1 @@\n-    int offset = *(int*)adr_payload_offset();\n+    int offset = fixed_block()._payload_offset;\n@@ -134,0 +105,1 @@\n+  void set_payload_offset(int offset)                         { fixed_block()._payload_offset = offset; }\n@@ -135,1 +107,2 @@\n-  void set_payload_offset(int offset) { *(int*)adr_payload_offset() = offset; }\n+  int payload_size_in_bytes() const                           { return fixed_block()._payload_size_in_bytes; }\n+  void set_payload_size_in_bytes(int payload_size)            { fixed_block()._payload_size_in_bytes = payload_size; }\n@@ -137,2 +110,2 @@\n-  int payload_size_in_bytes() const { return *(int*)adr_payload_size_in_bytes(); }\n-  void set_payload_size_in_bytes(int payload_size) { *(int*)adr_payload_size_in_bytes() = payload_size; }\n+  int payload_alignment() const                               { return fixed_block()._payload_alignment; }\n+  void set_payload_alignment(int alignment)                   { fixed_block()._payload_alignment = alignment; }\n@@ -140,2 +113,3 @@\n-  int payload_alignment() const { return *(int*)adr_payload_alignment(); }\n-  void set_payload_alignment(int alignment) { *(int*)adr_payload_alignment() = alignment; }\n+  int non_atomic_size_in_bytes() const                        { return fixed_block()._non_atomic_size_in_bytes; }\n+  void set_non_atomic_size_in_bytes(int size)                 { fixed_block()._non_atomic_size_in_bytes = size; }\n+  bool has_non_atomic_layout() const                          { return non_atomic_size_in_bytes() != -1; }\n@@ -143,5 +117,2 @@\n-  bool has_non_atomic_layout() const { return non_atomic_size_in_bytes() != -1; }\n-  int non_atomic_size_in_bytes() const { return *(int*)adr_non_atomic_size_in_bytes(); }\n-  void set_non_atomic_size_in_bytes(int size) { *(int*)adr_non_atomic_size_in_bytes() = size; }\n-  int non_atomic_alignment() const { return *(int*)adr_non_atomic_alignment(); }\n-  void set_non_atomic_alignment(int alignment) { *(int*)adr_non_atomic_alignment() = alignment; }\n+  int non_atomic_alignment() const                            { return fixed_block()._non_atomic_alignment; }\n+  void set_non_atomic_alignment(int alignment)                { fixed_block()._non_atomic_alignment = alignment; }\n@@ -149,3 +120,3 @@\n-  bool has_atomic_layout() const { return atomic_size_in_bytes() != -1; }\n-  int atomic_size_in_bytes() const { return *(int*)adr_atomic_size_in_bytes(); }\n-  void set_atomic_size_in_bytes(int size) { *(int*)adr_atomic_size_in_bytes() = size; }\n+  int atomic_size_in_bytes() const                            { return fixed_block()._atomic_size_in_bytes; }\n+  void set_atomic_size_in_bytes(int size)                     { fixed_block()._atomic_size_in_bytes = size; }\n+  bool has_atomic_layout() const                              { return atomic_size_in_bytes() != -1; }\n@@ -153,6 +124,8 @@\n-  bool has_nullable_atomic_layout() const { return nullable_atomic_size_in_bytes() != -1; }\n-  int nullable_atomic_size_in_bytes() const { return *(int*)adr_nullable_atomic_size_in_bytes(); }\n-  void set_nullable_size_in_bytes(int size) { *(int*)adr_nullable_atomic_size_in_bytes() = size; }\n-  int null_marker_offset() const { return *(int*)adr_null_marker_offset(); }\n-  int null_marker_offset_in_payload() const { return null_marker_offset() - payload_offset(); }\n-  void set_null_marker_offset(int offset) { *(int*)adr_null_marker_offset() = offset; }\n+  \/\/ FIXME: These names are not consistent w.r.t the atomic part.\n+  int nullable_atomic_size_in_bytes() const                   { return fixed_block()._nullable_size_in_bytes; }\n+  void set_nullable_size_in_bytes(int size)                   { fixed_block()._nullable_size_in_bytes = size; }\n+  bool has_nullable_atomic_layout() const                     { return nullable_atomic_size_in_bytes() != -1; }\n+\n+  int null_marker_offset() const                              { return fixed_block()._null_marker_offset; }\n+  void set_null_marker_offset(int offset)                     { fixed_block()._null_marker_offset = offset; }\n+  int null_marker_offset_in_payload() const                   { return null_marker_offset() - payload_offset(); }\n@@ -249,4 +222,1 @@\n-  Array<SigEntry>* extended_sig() const {\n-    return *((Array<SigEntry>**)adr_extended_sig());\n-  }\n-  inline Array<VMRegPair>* return_regs() const;\n+\n@@ -260,8 +230,0 @@\n-  address pack_handler() const {\n-    return *(address*)adr_pack_handler();\n-  }\n-\n-  address unpack_handler() const {\n-    return *(address*)adr_unpack_handler();\n-  }\n-\n@@ -294,10 +256,0 @@\n-  void set_null_reset_value_offset(int offset) {\n-    *((int*)adr_null_reset_value_offset()) = offset;\n-  }\n-\n-  int null_reset_value_offset() {\n-    int offset = *((int*)adr_null_reset_value_offset());\n-    assert(offset != 0, \"must not be called if not initialized\");\n-    return offset;\n-  }\n-\n@@ -322,1 +274,1 @@\n-#endif \/* SHARE_VM_OOPS_INLINEKLASS_HPP *\/\n+#endif \/\/ SHARE_VM_OOPS_INLINEKLASS_HPP\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":54,"deletions":102,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -36,19 +36,0 @@\n-inline InlineKlassFixedBlock* InlineKlass::inlineklass_static_block() const {\n-\n-  InstanceKlass* volatile* adr_impl = adr_implementor();\n-  if (adr_impl != nullptr) {\n-    return (InlineKlassFixedBlock*)(adr_impl + 1);\n-  }\n-\n-  return (InlineKlassFixedBlock*)end_of_nonstatic_oop_maps();\n-}\n-\n-inline address InlineKlass::adr_return_regs() const {\n-  InlineKlassFixedBlock* vkst = inlineklass_static_block();\n-  return ((address)_adr_inlineklass_fixed_block) + in_bytes(byte_offset_of(InlineKlassFixedBlock, _return_regs));\n-}\n-\n-inline Array<VMRegPair>* InlineKlass::return_regs() const {\n-  return *((Array<VMRegPair>**)adr_return_regs());\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.inline.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -144,16 +144,0 @@\n-  Array<SigEntry>** _extended_sig;\n-  Array<VMRegPair>** _return_regs;\n-  address* _pack_handler;\n-  address* _pack_handler_jobject;\n-  address* _unpack_handler;\n-  int* _null_reset_value_offset;\n-  int _payload_offset;          \/\/ offset of the begining of the payload in a heap buffered instance\n-  int _payload_size_in_bytes;   \/\/ size of payload layout\n-  int _payload_alignment;       \/\/ alignment required for payload\n-  int _non_atomic_size_in_bytes; \/\/ size of null-free non-atomic flat layout\n-  int _non_atomic_alignment;    \/\/ alignment requirement for null-free non-atomic layout\n-  int _atomic_size_in_bytes;    \/\/ size and alignment requirement for a null-free atomic layout, -1 if no atomic flat layout is possible\n-  int _nullable_size_in_bytes;  \/\/ size and alignment requirement for a nullable layout (always atomic), -1 if no nullable flat layout is possible\n-  int _null_marker_offset;      \/\/ expressed as an offset from the beginning of the object for a heap buffered value\n-                                \/\/ payload_offset must be subtracted to get the offset from the beginning of the payload\n-\n@@ -161,0 +145,16 @@\n+\n+  Array<SigEntry>* _extended_sig;\n+  Array<VMRegPair>* _return_regs;\n+  address _pack_handler;\n+  address _pack_handler_jobject;\n+  address _unpack_handler;\n+  int _null_reset_value_offset;\n+  int _payload_offset;           \/\/ offset of the begining of the payload in a heap buffered instance\n+  int _payload_size_in_bytes;    \/\/ size of payload layout\n+  int _payload_alignment;        \/\/ alignment required for payload\n+  int _non_atomic_size_in_bytes; \/\/ size of null-free non-atomic flat layout\n+  int _non_atomic_alignment;     \/\/ alignment requirement for null-free non-atomic layout\n+  int _atomic_size_in_bytes;     \/\/ size and alignment requirement for a null-free atomic layout, -1 if no atomic flat layout is possible\n+  int _nullable_size_in_bytes;   \/\/ size and alignment requirement for a nullable layout (always atomic), -1 if no nullable flat layout is possible\n+  int _null_marker_offset;       \/\/ expressed as an offset from the beginning of the object for a heap buffered value\n+                                 \/\/ payload_offset must be subtracted to get the offset from the beginning of the payload\n@@ -347,1 +347,3 @@\n-  const InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n+\n+  \/\/ Located here because sub-klasses can't have their own explicit fields\n+  InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n@@ -1071,0 +1073,4 @@\n+  \/\/ The end of the memory block that belongs to this InstanceKlass.\n+  \/\/ Sub-klasses can place their fields after this address.\n+  inline address end_of_instance_klass() const;\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":23,"deletions":17,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+inline address InstanceKlass::end_of_instance_klass() const {\n+  return (address)end_of_nonstatic_oop_maps() +\n+      (is_interface() ? sizeof(InstanceKlass*) : 0);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}