{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -39,0 +40,3 @@\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -44,2 +48,2 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.stream.Collectors;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n@@ -47,0 +51,1 @@\n+\n@@ -55,1 +60,0 @@\n-import static java.lang.invoke.MethodHandles.countedLoop;\n@@ -58,1 +62,1 @@\n-import static java.lang.invoke.MethodHandles.filterReturnValue;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n@@ -63,0 +67,3 @@\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toMap;\n@@ -74,1 +81,1 @@\n-    private static final int THRESHOLD =\n+    private static final int MAX_NODE_VISITS =\n@@ -96,4 +103,0 @@\n-        static List<MethodHandle> getters(Class<?> type, Comparator<MethodHandle> comparator) {\n-            return getterStream(type, comparator).toList();\n-        }\n-\n@@ -133,185 +136,1 @@\n-        \/**\n-         * A base method for testing substitutability on a recursive data type,\n-         * a value class with cyclic membership.\n-         *\n-         * This method will first invoke a method handle to test the substitutability\n-         * of fields whose type is not recursively-typed.  If true, then compares the\n-         * value of the fields whose type is a recursive data type.\n-         * For a field of its own type {@code f}, invoke the method handle for\n-         * this base method on the field value of the given objects.\n-         * For a field of other recursive data type, invoke {@link #isSubstitutable(Object, Object)}\n-         * on the field value of the given objects.\n-         *\n-         * @param type  a value class\n-         * @param mh    a MethodHandle that tests substitutability of all fields whose type\n-         *              is not recursively-typed.  The method type is (V, V)boolean\n-         * @param getters all getters for the fields whose type is a recursive data type\n-         * @param recur MethodHandle that is capable of recursively calling itself\n-         *              to test if two objects of the given value class are substitutable.\n-         *              The method type is (Object, Object, AtomicInteger)boolean.\n-         * @param o1    an object\n-         * @param o2    an object to be compared for substitutability\n-         * @param counter an AtomicInteger counter to keep track of the traversal count\n-         * @return\n-         * @param <V>   a value class\n-         *\/\n-        private static <V> boolean substitutableBase(Class<V> type, MethodHandle mh, MethodHandle[] getters,\n-                                                     MethodHandle recur, Object o1, Object o2,\n-                                                     AtomicInteger counter) throws Throwable {\n-            assert isValueClass(type) : type.getName() + \" not a value class\";\n-\n-            if (o1 == null && o2 == null) return true;\n-            if (o1 == null || o2 == null) return false;\n-\n-            if (counter.getAndDecrement() == 0) {\n-                throw new StackOverflowError(\"fail to evaluate == for value class \" + type.getName());\n-            }\n-\n-            \/\/ test if the substitutability of all fields whose type is not recursively-typed\n-            var result = (boolean) mh.invoke(o1, o2);\n-            if (result) {\n-                assert o1.getClass() == type && o2.getClass() == type;\n-\n-                \/\/ test if the fields of a recursive data type are substitutable\n-                for (MethodHandle getter : getters) {\n-                    Class<?> ftype = fieldType(getter);\n-                    var f1 = getter.invoke(o1);\n-                    var f2 = getter.invoke(o2);\n-\n-                    assert !JLIA.isNullRestrictedField(getter) ||  (f1 != null && f2 != null) :\n-                            \"null restricted field \" + ftype.getName() + \" in container \" + type.getName();\n-\n-                    boolean substitutable;\n-                    if (ftype == type) {\n-                        substitutable = (boolean)recur.invokeExact(f1, f2, counter);\n-                    } else {\n-                        MethodHandle recur2 = RECUR_SUBST_METHOD_HANDLES.get(ftype);\n-                        substitutable = (boolean)recur2.invokeExact(f1, f2, counter);\n-                    }\n-                    if (!substitutable) {\n-                        return false;\n-                    }\n-                }\n-            }\n-            return result;\n-        }\n-\n-\n-        \/**\n-         * A base method for computing the hashcode for a recursive data type,\n-         * a value class with cyclic membership.\n-         *\n-         * This method will first invoke a method handle to compute the hash code\n-         * of the fields whose type is not recursively-typed.  Then compute the\n-         * hash code of the remaining fields whose type is a recursive data type.\n-         * For a field of its own type {@code f}, invoke the method handle for\n-         * this base method on the field value of the given object.\n-         * For a field of other recursive data type, invoke {@link Object#hashCode()}\n-         * on the field value of the given object.\n-         *\n-         * @param type  a value class\n-         * @param mh    a MethodHandle that computes the hash code of all fields whose\n-         *              type is not recursively-typed.  The method type is (V)int\n-         * @param getters all getters for the fields whose type is a recursive data type\n-         * @param recur MethodHandle that is capable of recursively calling itself\n-         *              to compute the hash code of a field of the same type.\n-         *              The method type is (Object, AtomicInteger)int.\n-         * @param obj   an object\n-         * @param counter an AtomicInteger counter to keep track of the traversal count\n-         * @return the hash code of a value object of the given type\n-         * @param <V>   a value class\n-         *\/\n-        private static <V> int hashCodeBase(Class<V> type, MethodHandle mh, MethodHandle[] getters,\n-                                            MethodHandle recur, Object obj,\n-                                            AtomicInteger counter) throws Throwable {\n-            assert isValueClass(type) : type.getName() + \" not a value class\";\n-\n-            if (obj == null) return 0;\n-\n-            if (counter.getAndDecrement() == 0) {\n-                throw new StackOverflowError(\"fail to evaluate hashCode of a value object: \" + type.getName());\n-            }\n-\n-            \/\/ compute the hash code of all fields whose type is not recursively-typed\n-            var result = (int) mh.invoke(obj);\n-            if (obj != null) {\n-                assert obj.getClass() == type;\n-\n-                \/\/ test if the fields of a recursive data type are substitutable\n-                for (MethodHandle getter : getters) {\n-                    Class<?> ftype = fieldType(getter);\n-                    var f = getter.invoke(obj);\n-                    assert !JLIA.isNullRestrictedField(getter) || f != null :\n-                            \"null restricted field \" + ftype.getName() + \" in container \" + type.getName();\n-\n-                    int hc;\n-                    if (ftype == type) {\n-                        hc = (int)recur.invokeExact(f, counter);\n-                    } else {\n-                        MethodHandle recur2 = RECUR_HASHCODE_METHOD_HANDLES.get(ftype);\n-                        hc = (int)recur2.invokeExact(f, counter);\n-                    }\n-                    result = hashCombiner(result, hc);\n-                }\n-            }\n-            return result;\n-        }\n-\n-        \/*\n-         * Finds all value class memberships of the given type involved in cycles\n-         *\/\n-        private static Set<Class<?>> recursiveValueTypes(Class<?> type) {\n-            if (!isValueClass(type)) {\n-                return Set.of();\n-            }\n-\n-            Deque<Class<?>> deque = new ArrayDeque<>();\n-            Set<Class<?>> visited = new HashSet<>();\n-            Set<Class<?>> recursiveTypes = new HashSet<>();\n-            Map<Class<?>, List<Class<?>>> unvisitedEdges = new HashMap<>();\n-\n-            Class<?> c;\n-            deque.add(type);\n-            while ((c = deque.peek()) != null) {\n-                if (visited.contains(c)) {\n-                    \/\/ remove the current node being visited\n-                    deque.pop();\n-                    if (deque.contains(c)) {\n-                        \/\/ include all types in the cycle\n-                        for (Class<?> n : deque) {\n-                            recursiveTypes.add(n);\n-                            if (n == c) {\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n-                    \/\/ continue the depth-first search from the parent of c\n-                    if ((c = deque.peek()) == null)\n-                        continue;\n-                } else {\n-                    visited.add(c);\n-                }\n-\n-                \/\/ depth-first search on the field types of type c that are value classes\n-                List<Class<?>> nodes = unvisitedEdges.computeIfAbsent(c, (k) -> fieldTypes(k));\n-                if (nodes.isEmpty()) {\n-                    \/\/ all field types are traversed\n-                    deque.pop();\n-                } else {\n-                    Class<?> n = nodes.remove(0);\n-                    deque.push(n);\n-                }\n-            }\n-\n-            if (recursiveTypes.isEmpty())\n-                return Set.of();\n-\n-            return Arrays.stream(type.getDeclaredFields())\n-                         .filter(f -> !Modifier.isStatic(f.getModifiers()))\n-                         .map(f -> f.getType())\n-                         .filter(recursiveTypes::contains)\n-                         .collect(Collectors.toSet());\n-        }\n-\n-        private static List<Class<?>> fieldTypes(Class<?> type) {\n+        private static List<Class<?>> valueTypeFields(Class<?> type) {\n@@ -327,13 +146,0 @@\n-        private static final ClassValue<MethodHandle> RECUR_SUBST_METHOD_HANDLES = new ClassValue<>() {\n-            \/*\n-             * Produces a MethodHandle that returns boolean if two value objects of\n-             * a recursive data type are substitutable.  This method is invoked by\n-             * the substitutableBase method.\n-             *\n-             * The method type is (Object, Object, AtomicInteger)boolean.\n-             *\/\n-            @Override protected MethodHandle computeValue(Class<?> type) {\n-                return recurValueTypeEquals(type, recursiveValueTypes(type));\n-            }\n-        };\n-\n@@ -345,2 +151,6 @@\n-            \/\/ ensure the reference type of a primitive class not used in the method handle\n-            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+            var builder = METHOD_HANDLE_BUILDERS.get(type);\n+            if (builder == null) {\n+                builder = newBuilder(type);\n+            }\n+            return builder.equalsTarget();\n+        }\n@@ -348,7 +158,8 @@\n-            Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n-            if (recursiveTypes.isEmpty()) {\n-                return valueTypeEquals(type, getters(type, TYPE_SORTER));\n-            } else {\n-                MethodHandle target = recurValueTypeEquals(type, recursiveTypes);\n-                return MethodHandles.insertArguments(target, 2, new AtomicInteger(THRESHOLD))\n-                                    .asType(methodType(boolean.class, type, type));\n+        \/*\n+         * Produces a MethodHandle that computes the hash code of a value object.\n+         * The method type of the return MethodHandle is (V)int.\n+         *\/\n+        static MethodHandle valueTypeHashCode(Class<?> type) {\n+            var builder = METHOD_HANDLE_BUILDERS.get(type);\n+            if (builder == null) {\n+                builder = newBuilder(type);\n@@ -356,0 +167,1 @@\n+            return builder.hashCodeTarget();\n@@ -359,2 +171,2 @@\n-         * Produces a MethodHandle that returns boolean if the given fields\n-         * of the two value objects are substitutable. The method type is (V, V)boolean\n+         * Produces a MethodHandle that returns boolean if the given non-recursively typed\n+         * fields of the two value objects are substitutable. The method type is (V, V)boolean\n@@ -372,2 +184,2 @@\n-                MethodHandle eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n-                MethodHandle thisFieldEqual = filterArguments(eq, 0, getter, getter);\n+                var eq = substitutableInvoker(ftype).asType(methodType(boolean.class, ftype, ftype));\n+                var thisFieldEqual = filterArguments(eq, 0, getter, getter);\n@@ -386,66 +198,0 @@\n-        \/*\n-         * Produces a MethodHandle that returns boolean if two value objects of\n-         * a recursive data type are substitutable.\n-         *\n-         * The method type is (Object, Object, AtomicInteger)boolean.\n-         *\/\n-        static MethodHandle recurValueTypeEquals(Class<?> type, Set<Class<?>> recursiveTypes) {\n-            Stream<MethodHandle> getterStream = getterStream(type, TYPE_SORTER);;\n-            List<MethodHandle> nonRecurTypeGetters = new ArrayList<>();\n-            List<MethodHandle> recurTypeGetters = new ArrayList<>();\n-            getterStream.forEach(getter -> {\n-                Class<?> ftype = fieldType(getter);\n-                if (recursiveTypes.contains(ftype)) {\n-                    \/\/ skip the value class that is involved in a cyclic membership\n-                    recurTypeGetters.add(getter);\n-                } else {\n-                    nonRecurTypeGetters.add(getter);\n-                }\n-            });\n-\n-            if (recurTypeGetters.isEmpty()) {\n-                throw new InternalError(\"must be a recursive data type: \" + type.getName());\n-            }\n-\n-            MethodHandle target = valueTypeEquals(type, nonRecurTypeGetters);\n-            \/\/ This value class contains cyclic membership\n-            \/\/ Create a method handle that is capable of calling itself.\n-            \/\/ - the substitutableBase method first calls the method handle that tests\n-            \/\/   the substitutability of all fields that are not a recursive data type\n-            \/\/ - for a field of its own type, call the recursive method\n-            \/\/ - for a field of a recursive data type, call isSubstitutable\n-            Object[] arguments = new Object[]{type, target, recurTypeGetters.toArray(MethodHandle[]::new)};\n-            target = MethodHandles.insertArguments(RECUR_EQUALS, 0, arguments);\n-            return recursive(target);\n-        }\n-\n-        private static final ClassValue<MethodHandle> RECUR_HASHCODE_METHOD_HANDLES = new ClassValue<>() {\n-            \/*\n-             * Produces a MethodHandle that returns the hashcode of a value object of\n-             * a recursive data type.  This method is invoked by the hashCodeBase method.\n-             *\n-             * The method type is (Object, AtomicInteger)int.\n-             *\/\n-            @Override protected MethodHandle computeValue(Class<?> type) {\n-                return recurValueTypeHashCode(type, recursiveValueTypes(type));\n-            }\n-        };\n-\n-        \/*\n-         * Produces a MethodHandle that computes the hash code of a value object.\n-         * The method type of the return MethodHandle is (V)int.\n-         *\/\n-        static MethodHandle valueTypeHashCode(Class<?> type) {\n-            \/\/ ensure the reference type of a primitive class not used in the method handle\n-            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n-\n-            Set<Class<?>> recursiveTypes = recursiveValueTypes(type);\n-            if (recursiveTypes.isEmpty()) {\n-                return valueTypeHashCode(type, getterStream(type, null).toList());\n-            } else {\n-                MethodHandle target = recurValueTypeHashCode(type, recursiveTypes);\n-                return MethodHandles.insertArguments(target, 1, new AtomicInteger(THRESHOLD))\n-                                    .asType(methodType(int.class, type));\n-            }\n-        }\n-\n@@ -454,1 +200,2 @@\n-         * the given fields of a value object. The method type is (V)int.\n+         * the given non-recursively-typed fields of a value object.\n+         * The method type is (V)int.\n@@ -461,12 +208,5 @@\n-            MethodHandle cls = dropArguments(constant(Class.class, type),0, type);\n-            MethodHandle classHashCode = filterReturnValue(cls, hashCodeForType(Class.class));\n-            MethodHandle combiner = filterArguments(HASH_COMBINER, 0, target, classHashCode);\n-            \/\/ int v = SALT * 31 + type.hashCode();\n-            MethodHandle init = permuteArguments(combiner, target.type(), 0, 0);\n-            int length = getters.size();\n-            MethodHandle iterations = dropArguments(constant(int.class, length), 0, type);\n-            MethodHandle[] hashers = new MethodHandle[length];\n-            for (int i=0; i < length; i++) {\n-                MethodHandle getter = getters.get(i);\n-                Class<?> ftype = fieldType(getter);\n-\n+            MethodHandle classHasher = dropArguments(hashCodeForType(Class.class).bindTo(type), 0, type);\n+            MethodHandle hashCombiner = dropArguments(HASH_COMBINER, 2, type);\n+            MethodHandle accumulator = foldArguments(foldArguments(hashCombiner, 1, classHasher), 0, target);\n+            for (MethodHandle getter : getters) {\n+                Class<?> ft = fieldType(getter);\n@@ -476,2 +216,4 @@\n-                MethodHandle hasher = hashCodeForType(ftype);\n-                hashers[i] = filterReturnValue(getter, hasher);\n+                var hasher = hashCodeForType(ft);\n+                var hashThisField = filterArguments(hasher, 0, getter);    \/\/ (R)I\n+                var combineHashes = foldArguments(hashCombiner, 1, hashThisField);\n+                accumulator = foldArguments(combineHashes, 0, accumulator);\n@@ -479,46 +221,1 @@\n-\n-            \/\/ for (int i=0; i < getters.length; i++) {\n-            \/\/   v = computeHash(v, i, a);\n-            \/\/ }\n-            MethodHandle body = COMPUTE_HASH.bindTo(hashers)\n-                    .asType(methodType(int.class, int.class, int.class, type));\n-            return countedLoop(iterations, init, body);\n-        }\n-\n-        \/*\n-         * Produces a MethodHandle that returns the hashcode of a value object of\n-         * a recursive data type.  This method is invoked by the hashCodeBase method.\n-         *\n-         * The method type is (Object, AtomicInteger)int.\n-         *\/\n-        static MethodHandle recurValueTypeHashCode(Class<?> type, Set<Class<?>> recursiveTypes) {\n-            Stream<MethodHandle> getterStream = getterStream(type, null);;\n-            List<MethodHandle> nonRecurTypeGetters = new ArrayList<>();\n-            List<MethodHandle> recurTypeGetters = new ArrayList<>();\n-            getterStream.forEach(getter -> {\n-                Class<?> ftype = fieldType(getter);\n-                if (recursiveTypes.contains(ftype)) {\n-                    \/\/ skip the value class that is involved in a cyclic membership\n-                    recurTypeGetters.add(getter);\n-                } else {\n-                    nonRecurTypeGetters.add(getter);\n-                }\n-            });\n-\n-            if (recurTypeGetters.isEmpty()) {\n-                throw new InternalError(\"must be a recursive data type: \" + type.getName());\n-            }\n-\n-            MethodHandle target = valueTypeHashCode(type, nonRecurTypeGetters);\n-            if (VERBOSE) {\n-                System.out.println(type.getName() + \" valueHashCode \" + nonRecurTypeGetters + \" recursive types \" + recurTypeGetters);\n-            }\n-            \/\/ This value class contains cyclic membership\n-            \/\/ Create a method handle that is capable of calling itself.\n-            \/\/ - the hashCodeBase method first calls the method handle that computes the hash code\n-            \/\/   of all fields whose type is not recursively-typed\n-            \/\/ - for a field of its own type, call the recursive method\n-            \/\/ - for a field of a recursive data type, call valueObjectHashCode\n-            Object[] arguments = new Object[]{type, target, recurTypeGetters.toArray(MethodHandle[]::new)};\n-            target = MethodHandles.insertArguments(RECUR_HASHCODE, 0, arguments);\n-            return recursive(target);\n+            return accumulator;\n@@ -577,1 +274,11 @@\n-        private static int computeHashCode(MethodHandle[] hashers, int v, int i, Object o) {\n+        private static int[] newCounter(int[] counter) {\n+            return new int[] { counter[0] };\n+        }\n+\n+        private static boolean recurValueEq(MethodHandle target, Object o1, Object o2, int[] counter) {\n+            assert counter[0] > 0;\n+\n+            if (o1 == null && o2 == null) return true;\n+            if (o1 == null || o2 == null) return false;\n+            if (o1.getClass() != o2.getClass()) return false;\n+\n@@ -579,2 +286,23 @@\n-                int hc = (int)hashers[i].invoke(o);\n-                return hashCombiner(v, hc);\n+                counter[0]--;\n+                if (counter[0] == 0) {\n+                    throw new StackOverflowError(\"fail to evaluate == for value class \" + o1.getClass().getName());\n+                }\n+                return (boolean) target.invoke(o1, o2, counter);\n+            } catch (Error|RuntimeException e) {\n+                throw e;\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+\n+        private static int recurValueHashCode(MethodHandle target, Object o, int[] counter) {\n+            assert counter[0] > 0;\n+\n+            if (o == null) return 0;\n+\n+            try {\n+                counter[0]--;\n+                if (counter[0] == 0) {\n+                    throw new StackOverflowError(\"fail to evaluate hashCode for value class \" + o.getClass().getName());\n+                }\n+                return (int) target.invoke(o, counter);\n@@ -591,1 +319,1 @@\n-            findStatic(\"eq\", methodType(boolean.class, Object.class, Object.class));\n+                findStatic(\"eq\", methodType(boolean.class, Object.class, Object.class));\n@@ -593,1 +321,1 @@\n-            findStatic(\"isSameValueClass\", methodType(boolean.class, Object.class, Object.class));\n+                findStatic(\"isSameValueClass\", methodType(boolean.class, Object.class, Object.class));\n@@ -595,1 +323,1 @@\n-            findStatic(\"isNull\", methodType(boolean.class, Object.class, Object.class));\n+                findStatic(\"isNull\", methodType(boolean.class, Object.class, Object.class));\n@@ -597,3 +325,1 @@\n-            findStatic(\"hashCombiner\", methodType(int.class, int.class, int.class));\n-        private static final MethodHandle COMPUTE_HASH =\n-            findStatic(\"computeHashCode\", methodType(int.class, MethodHandle[].class, int.class, int.class, Object.class));\n+                findStatic(\"hashCombiner\", methodType(int.class, int.class, int.class));\n@@ -601,8 +327,6 @@\n-        private static final MethodHandle RECUR_EQUALS =\n-            findStatic(\"substitutableBase\",\n-                       methodType(boolean.class, Class.class, MethodHandle.class, MethodHandle[].class,\n-                                  MethodHandle.class, Object.class, Object.class, AtomicInteger.class));\n-        private static final MethodHandle RECUR_HASHCODE =\n-            findStatic(\"hashCodeBase\",\n-                       methodType(int.class, Class.class, MethodHandle.class, MethodHandle[].class,\n-                                  MethodHandle.class, Object.class, AtomicInteger.class));\n+        private static final MethodHandle RECUR_VALUE_EQ =\n+                findStatic(\"recurValueEq\", methodType(boolean.class, MethodHandle.class, Object.class, Object.class, int[].class));\n+        private static final MethodHandle RECUR_VALUE_HASHCODE =\n+                findStatic(\"recurValueHashCode\", methodType(int.class, MethodHandle.class, Object.class, int[].class));\n+        private static final MethodHandle NEW_COUNTER =\n+                findStatic(\"newCounter\", methodType(int[].class, int[].class));\n@@ -643,0 +367,674 @@\n+\n+        static MethodHandleBuilder newBuilder(Class<?> type) {\n+            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+\n+            Deque<Class<?>> deque = new ArrayDeque<>();\n+            deque.add(type);\n+            Map<Class<?>, MethodHandleBuilder> visited = new HashMap<>();\n+            var builder = new MethodHandleBuilder(type, deque, visited);\n+            visited.put(type, builder);\n+            return builder;\n+        }\n+\n+        enum Status {\n+            NOT_START,\n+            IN_PROGRESS,\n+            TRAVERSAL_DONE,\n+            READY\n+        }\n+\n+        final Class<?> type;\n+        final List<Class<?>> fieldValueTypes;\n+        \/\/ a map of the type of a field T to a cycle of T -> ... -> V\n+        \/\/ where V is this builder's value type\n+        final Map<Class<?>, List<Class<?>>> cyclicMembers = new HashMap<>();\n+        \/\/ recursively-typed fields declared in this builder's value type\n+        final Set<Class<?>> recurFieldTypes = new HashSet<>();\n+        final Deque<Class<?>> path;\n+        final Map<Class<?>, MethodHandleBuilder> visited;;\n+        volatile Status status = Status.NOT_START;\n+        volatile MethodHandle equalsTarget;\n+        volatile MethodHandle hashCodeTarget;\n+\n+        static final VarHandle STATUS_HANDLE;\n+        static {\n+            VarHandle vh = null;\n+            try {\n+                vh = MethodHandles.lookup().findVarHandle(MethodHandleBuilder.class, \"status\", Status.class);\n+            } catch (ReflectiveOperationException e) {\n+                throw new InternalError(e);\n+            }\n+            STATUS_HANDLE = vh;\n+        }\n+\n+        \/**\n+         * Constructs a new MethodHandleBuilder for the given value type.\n+         *\n+         * @param type a value class\n+         * @param path the graph traversal\n+         * @param visited a map of a visited type to a builder\n+         *\/\n+        private MethodHandleBuilder(Class<?> type, Deque<Class<?>> path, Map<Class<?>, MethodHandleBuilder> visited) {\n+            this.type = type;\n+            this.fieldValueTypes = valueTypeFields(type);\n+            this.path = path;\n+            this.visited = visited;\n+            if (VERBOSE) {\n+                System.out.println(\"New builder for \" + type.getName() + \" \" + path);\n+            }\n+        }\n+\n+        \/*\n+         * Returns a method handle that implements equals method for this builder's value class.\n+         *\/\n+        MethodHandle equalsTarget() {\n+            if (status != Status.READY)\n+                throw new IllegalStateException(type.getName() + \" not ready\");\n+\n+            var mh = equalsTarget;\n+            if (mh != null) return mh;\n+\n+            generateMethodHandle();\n+            return equalsTarget;\n+        }\n+\n+        \/*\n+         * Returns a method handle that implements hashCode method for this builder's value class.\n+         *\/\n+        MethodHandle hashCodeTarget() {\n+            if (status != Status.READY)\n+                throw new IllegalStateException(type.getName() + \" not ready\");\n+\n+            var mh = hashCodeTarget;\n+            if (mh != null) return mh;\n+\n+            generateMethodHandle();\n+            return hashCodeTarget;\n+        }\n+\n+        \/*\n+         * Build the graph for this builder's value type.  Detect all cycles.\n+         * This builder after this method returns is in DONE_TRAVERSAL or READY status.\n+         *\n+         * A builder for type V will change to READY status when the entire graph for V\n+         * is traversed (i.e. all builders in this graph are in DONE_TRAVERSAL or READY\n+         * status).\n+         *\/\n+        MethodHandleBuilder build() {\n+            if (status == Status.READY) return this;\n+\n+            if (!STATUS_HANDLE.compareAndSet(this, Status.NOT_START, Status.IN_PROGRESS)) {\n+                throw new RuntimeException(type.getName() + \" in progress\");\n+            }\n+\n+            \/\/ traverse the graph and find all cycles\n+            detectCycles();\n+\n+            if (!STATUS_HANDLE.compareAndSet(this, Status.IN_PROGRESS, Status.TRAVERSAL_DONE)) {\n+                throw new RuntimeException(type.getName() + \" failed to set done traversal. \" + status);\n+            }\n+\n+            \/\/ Check if this node V is ready for building equals\/hashCode method handles.\n+            \/\/ V is ready if the types of all its fields are done traversal.\n+            if (ready()) {\n+                \/\/ Do a pass on all the cycles containing V.  V is ready.\n+                \/\/ If a node N in the cycle has completed the traversal (i.e. cycles are detected),\n+                \/\/ call ready() on N to update its status if ready.\n+                for (List<Class<?>> cycle : cyclicMembers.values()) {\n+                    cycle.stream().filter(c -> c != type)\n+                                  .map(visited::get)\n+                                  .filter(b -> b.status == Status.TRAVERSAL_DONE)\n+                                  .forEach(MethodHandleBuilder::ready);\n+                }\n+            }\n+            return this;\n+        }\n+\n+        \/*\n+         * Traverses the graph and finds all cycles.\n+         *\/\n+        private void detectCycles() {\n+            LinkedList<Class<?>> deque = new LinkedList<>();\n+            deque.addAll(fieldValueTypes);\n+            while (!deque.isEmpty()) {\n+                Class<?> n = deque.pop();\n+                \/\/ detect cyclic membership\n+                if (path.contains(n)) {\n+                    List<Class<?>> cycle = new ArrayList<>();\n+                    Iterator<Class<?>> iter = path.iterator();\n+                    while (iter.hasNext()) {\n+                        Class<?> c = iter.next();\n+                        cycle.add(c);\n+                        if (c == n) break;\n+                    }\n+                    cyclicMembers.put(n, cycle);\n+                    path.pop();\n+                    continue;\n+                }\n+\n+                try {\n+                    path.push(n);\n+                    if (!visited.containsKey(n)) {\n+                        \/\/ Duplicate the path and pass it to an unvisited node\n+                        Deque<Class<?>> newPath = new ArrayDeque<>();\n+                        newPath.addAll(path);\n+                        visited.computeIfAbsent(n, c -> new MethodHandleBuilder(n, newPath, visited));\n+                    }\n+\n+                    var builder = visited.get(n);\n+                    switch (builder.status) {\n+                        case NOT_START -> builder.build();\n+                        case TRAVERSAL_DONE -> builder.ready();\n+                    }\n+                } finally {\n+                    path.pop();\n+                }\n+            }\n+\n+            \/\/ propagate the cycles to the recursively-typed value classes\n+            \/\/ For each cycle A -> B -> C -> A, the cycle is recorded in all\n+            \/\/ the nodes (A, B, and C) in this cycle.\n+            for (Map.Entry<Class<?>, List<Class<?>>> e : cyclicMembers.entrySet()) {\n+                Class<?> c = e.getKey();\n+                List<Class<?>> cycle = e.getValue();\n+                var builder = visited.get(c);\n+                for (Class<?> ft : cycle) {\n+                    if (ft != c && builder.fieldValueTypes.contains(ft)) {\n+                        var v = builder.cyclicMembers.put(ft, cycle);\n+                        assert v == null || cycle.equals(v) : \"mismatched cycle: \" + v + \" vs \" + cycle;\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Tests if this builder is ready for generating equals and hashCode\n+         * method handles for the value class.\n+         *\n+         * This builder is ready if and only if the type graph of all its fields\n+         * are traversed and all cycles are detected.\n+         *\n+         * Before setting to READY, the recursively-typed fields are recorded\n+         * that includes all types in the cycles and the field types which\n+         * references recursive types\n+         *\/\n+        private boolean ready() {\n+            if (status == Status.READY) return true;\n+\n+            boolean inProgress = fieldValueTypes.stream().map(visited::get)\n+                                                .anyMatch(b -> b.status == Status.IN_PROGRESS);\n+            if (inProgress)\n+                return false;\n+\n+            \/\/ collect the recursively-typed value classes required by this method handle\n+            \/\/ all types in the cycles and the field types which references recursive types\n+            recurFieldTypes.addAll(cyclicMembers.keySet());\n+            for (Class<?> c : fieldValueTypes) {\n+                if (c == type) continue;\n+\n+                \/\/ if this field type references a recursive type\n+                var b = visited.get(c);\n+                if (b.cyclicMembers.size() > 0 || b.recurFieldTypes.size() > 0)\n+                    recurFieldTypes.add(c);\n+            };\n+\n+            \/\/ Finished recording recursively-typed fields.  Set to READY.\n+            if (!STATUS_HANDLE.compareAndSet(this, Status.TRAVERSAL_DONE, Status.READY)) {\n+                throw new RuntimeException(type.getName() + \" failed to set READY. \" + status);\n+            }\n+            return true;\n+        }\n+\n+        void generateMethodHandle() {\n+            if (status != Status.READY)\n+                throw new IllegalStateException(type.getName() + \" not ready\");\n+\n+            \/\/ non-recursive value type\n+            if (recurFieldTypes.isEmpty()) {\n+                if (cyclicMembers.size() > 0)\n+                    throw new RuntimeException(type.getName() + \" should not reach here\");\n+\n+                this.equalsTarget = valueTypeEquals(type, getterStream(type, TYPE_SORTER).toList());\n+                this.hashCodeTarget = valueTypeHashCode(type, getterStream(type, null).toList());\n+                return;\n+            }\n+\n+            if (VERBOSE) {\n+                System.out.println(debugString());\n+            }\n+\n+            \/\/ generate the base function for each recursive type\n+            \/\/ boolean base1(MethodHandle entry, MethodHandle base1, MethodHandle base2,....., Object o1, Object o2, int[] counter)\n+            \/\/ :\n+            \/\/ boolean baseN(MethodHandle entry, MethodHandle base1, MethodHandle base2,....., Object o1, Object o2, int[] counter)\n+            \/\/\n+            List<Class<?>> recursiveTypes = aggregateRecursiveTypes();\n+            Map<Class<?>, MethodHandle> bases = new LinkedHashMap<>();\n+            Map<Class<?>, MethodHandle> hashCodeBases = new LinkedHashMap<>();\n+            for (Class<?> c : recursiveTypes) {\n+                bases.put(c, visited.get(c).generateSubstBase(recursiveTypes));\n+                hashCodeBases.put(c, visited.get(c).generateHashCodeBase(recursiveTypes));\n+            }\n+\n+            var handles = bases.values().stream().toArray(MethodHandle[]::new);\n+            var hashCodeHandles = hashCodeBases.values().stream().toArray(MethodHandle[]::new);\n+\n+            \/\/ The entry point for equals for this value type T looks like this:\n+            \/\/\n+            \/\/ boolean entry(MethodHandle entry, MethodHandle base1, MethodHandle base2,....., Object o1, Object o2, int[] counter) {\n+            \/\/    int[] newCounter = new int[] { counter[0] } ;\n+            \/\/    return baseT(o1, o2, newCounter);\n+            \/\/ }\n+            this.equalsTarget = newValueEquals(recursiveTypes, handles);\n+            this.hashCodeTarget = newValueHashCode(recursiveTypes, hashCodeHandles);\n+\n+            \/\/ Precompute the method handles for all recursive data types in the cycles\n+            \/\/ They share the generated base method handles.\n+            var cycles = cyclicMembers.values().stream().flatMap(List::stream)\n+                                .filter(c -> c != type)\n+                                .collect(toMap(Function.identity(), visited::get));\n+            for (Class<?> n : cycles.keySet()) {\n+                var builder = cycles.get(n);\n+                if (builder.status != Status.READY) {\n+                    throw new InternalError(type.getName() + \" is not ready: \" + status);\n+                }\n+\n+                var mh = builder.equalsTarget;\n+                var mh2 = builder.hashCodeTarget;\n+                if (mh != null && mh2 != null) {\n+                    continue;\n+                }\n+\n+                \/\/ precompute the method handles for each recursive type in the cycle\n+                if (mh == null) {\n+                    builder.equalsTarget = builder.newValueEquals(recursiveTypes, handles);\n+                }\n+                if (mh2 == null) {\n+                    builder.hashCodeTarget = builder.newValueHashCode(recursiveTypes, hashCodeHandles);\n+                }\n+            }\n+\n+            \/\/ cache the builders with precomputed method handles in the cache\n+            synchronized (CACHED_METHOD_HANDLE_BUILDERS) {\n+                for (Class<?> n : cycles.keySet()) {\n+                    try {\n+                        \/\/ the builder is added to the builder cache and propapate to\n+                        \/\/ the class value\n+                        CACHED_METHOD_HANDLE_BUILDERS.computeIfAbsent(n, cycles::get);\n+                        METHOD_HANDLE_BUILDERS.get(n);\n+                    } finally {\n+                        \/\/ Remove it from the builder cache once it's in class value\n+                        CACHED_METHOD_HANDLE_BUILDERS.remove(n);\n+                    }\n+                }\n+            }\n+\n+            \/\/ equals and hashCode are generated.  Clear the path and visited builders.\n+            clear();\n+        }\n+\n+        private void clear() {\n+            path.clear();\n+            visited.clear();\n+        }\n+\n+        \/*\n+         * Aggregates all recursive data types for this builder's value types.\n+         * The result is used in generating a recursive method handle\n+         * for this builder's value type.\n+         *\n+         * A graph of V:\n+         * V -> P -> V\n+         *   -> N -> N (self-recursive)\n+         *   -> E -> F -> E\n+         *\n+         * V, P, N, E, F are the mutual recursive types for V. The recursive method handle\n+         * for V is created with the base functions for V, P, N, E, F and it can mutually\n+         * call the recursive method handle for these types.  Specifically, MH_V calls\n+         * MH_P which calls MH_V, MH_N which calls itself, and MH_E which calls MH_F.\n+         *\/\n+        private List<Class<?>> aggregateRecursiveTypes() {\n+            boolean ready = true;\n+            for (List<Class<?>> cycle : cyclicMembers.values()) {\n+                \/\/ ensure all nodes in all cycles that are done traversal and ready for\n+                \/\/ method handle generation\n+                cycle.stream().filter(c -> c != type)\n+                              .map(visited::get)\n+                              .filter(b -> b.status == Status.TRAVERSAL_DONE)\n+                              .forEach(MethodHandleBuilder::ready);\n+\n+                \/\/ check the status\n+                ready = ready && cycle.stream().filter(c -> c != type)\n+                                      .map(visited::get)\n+                                      .allMatch(b -> b.status == Status.READY);\n+            }\n+\n+            if (!ready) {\n+                throw new IllegalStateException(type.getName() + \" \" + status);\n+            }\n+\n+            \/*\n+             * Traverse the graph for V to find all mutual recursive types for V.\n+             *\n+             * Node T is a mutual recursive type for V if any of the following:\n+             * 1. T is a recursively-typed field in V\n+             * 2. T is a type involved the cycles from V ... -> T ... -> V\n+             * 3. T is a mutual recursive type for N where N is a mutual recursive type for V.\n+             *\/\n+            Deque<Class<?>> deque = new ArrayDeque<>();\n+            List<Class<?>> recurTypes = new ArrayList<>();\n+            recurTypes.add(type);\n+            Stream.concat(recurFieldTypes.stream(),\n+                          cyclicMembers.values().stream().flatMap(List::stream))\n+                  .filter(Predicate.not(deque::contains)).forEach(deque::add);\n+            while (!deque.isEmpty()) {\n+                Class<?> c = deque.pop();\n+                if (recurTypes.contains(c)) continue;\n+\n+                recurTypes.add(c);\n+\n+                var builder = visited.get(c);\n+                Stream.concat(builder.recurFieldTypes.stream(),\n+                              builder.cyclicMembers.values().stream().flatMap(List::stream))\n+                      .filter(n -> !recurTypes.contains(n) && !deque.contains(n))\n+                      .forEach(deque::push);\n+            }\n+            return recurTypes;\n+        }\n+\n+        \/*\n+         * Create a new method handle that implements equals(T, Object) for value class T\n+         * for this builder using the given base method handles.  The return method handle\n+         * is capable of recursively calling itself for value class T whose entry point:\n+         *   boolean entry(MethodHandle entry, MethodHandle base1, MethodHandle base2, ..., Object o1, Object o2, int[] counter) {\n+         *       int[] newCounter = new int[] { counter[0] };\n+         *       return baseT(o1, o2, newCounter);\n+         *   }\n+         *\n+         * The counter is used to keep of node visits and throw StackOverflowError\n+         * if the counter gets \"unreasonably\" large of a cyclic value graph\n+         * (regardless of how many real stack frames were consumed.)\n+         *\/\n+        MethodHandle newValueEquals(List<Class<?>> recursiveTypes, MethodHandle[] bases) {\n+            var entry = equalsEntry(recursiveTypes);\n+            var mh = MethodHandles.insertArguments(recursive(entry, bases), 2, new int[] {MAX_NODE_VISITS});\n+            return mh.asType(methodType(boolean.class, type, type));\n+        }\n+\n+        \/*\n+         * Create a new method handle that implements hashCode(T) for value class T\n+         * for this builder using the given base method handles.  The return method handle\n+         * is capable of recursively calling itself for value class T whose entry point:\n+         *   boolean entry(MethodHandle entry, MethodHandle base1, MethodHandle base2, ..., Object o, int[] counter) {\n+         *       int[] newCounter = new int[] { counter[0] };\n+         *       return baseT(o, newCounter);\n+         *   }\n+         *\n+         * The counter is used to keep of node visits and throw StackOverflowError\n+         * if the counter gets \"unreasonably\" large of a cyclic value graph\n+         * (regardless of how many real stack frames were consumed.)\n+         *\/\n+        MethodHandle newValueHashCode(List<Class<?>> recursiveTypes, MethodHandle[] bases) {\n+            var entry = hashCodeEntry(recursiveTypes);\n+            var mh = MethodHandles.insertArguments(recursive(entry, bases), 1, new int[] {MAX_NODE_VISITS});\n+            return mh.asType(methodType(int.class, type));\n+        }\n+\n+        \/*\n+         * Create a method handle where the first N+1 parameters are MethodHandle and\n+         * N is the number of the recursive value types and followed with\n+         * Object, Object and int[] parameters.  The pseudo code looks like this:\n+         *\n+         * boolean eq(MethodHandle entry, MethodHandle base1, MethodHandle base2, ..., Object o1, Object o2, int[] counter) {\n+         *    if (o1 == null && o2 == null) return true;\n+         *    if (o1 == null || o2 == null) return false;\n+         *    if (o1.getClass() != o2. getClass()) return false;\n+         *\n+         *    int[] newCounter = new int[] { counter[0]; }\n+         *    return (boolean) baseT.invoke(o1, o2, newCounter);\n+         * }\n+         *\/\n+        MethodHandle equalsEntry(List<Class<?>> recursiveTypes) {\n+            List<Class<?>> leadingMHParams = new ArrayList<>();\n+            \/\/ the first MethodHandle parameter is this entry point\n+            \/\/ followed with MethodHandle parameter for each mutual exclusive value class\n+            int mhParamCount = recursiveTypes.size()+1;\n+            for (int i=0; i < mhParamCount; i++) {\n+                leadingMHParams.add(MethodHandle.class);\n+            }\n+\n+            MethodType mt = methodType(boolean.class, Stream.concat(leadingMHParams.stream(), Stream.of(type, type, int[].class))\n+                    .collect(toList()));\n+            var allParameters = mt.parameterList();\n+            MethodHandle instanceTrue = dropArguments(TRUE, 0, allParameters).asType(mt);\n+            MethodHandle instanceFalse = dropArguments(FALSE, 0, allParameters).asType(mt);\n+            MethodHandle isNull = dropArguments(dropArguments(IS_NULL, 0, leadingMHParams), mhParamCount+2, int[].class).asType(mt);\n+            MethodHandle isSameValueType = dropArguments(dropArguments(IS_SAME_VALUE_CLASS, 0, leadingMHParams), mhParamCount+2, int[].class).asType(mt);\n+\n+            int index = recursiveTypes.indexOf(type);\n+            var mtype = methodType(boolean.class, Stream.concat(leadingMHParams.stream(), Stream.of(type, type, int[].class)).collect(toList()));\n+            var recurEq = RECUR_VALUE_EQ.asType(methodType(boolean.class, MethodHandle.class, type, type, int[].class));\n+            var eq = permuteArguments(recurEq, mtype, index+1, mhParamCount, mhParamCount+1, mhParamCount+2);\n+            eq = filterArguments(eq, mhParamCount+2, NEW_COUNTER);\n+\n+            \/\/ if both arguments are null, return true;\n+            \/\/ otherwise return the method handle corresponding to this type\n+            return guardWithTest(isNull,\n+                                 instanceTrue,\n+                                 guardWithTest(isSameValueType, eq, instanceFalse));\n+        }\n+\n+        \/*\n+         * A base method for substitutability test for a recursive data type,\n+         * a value class with cyclic membership.\n+         *\n+         * The signature of this base method is:\n+         *    boolean base(MethodHandle entry, MethodHandle base1, MethodHandle base2, ..., V o1, V o2, int[] counter)\n+         *\n+         * where the first N+1 parameters are MethodHandle and N is the number of\n+         * the recursive value types and followed with Object, Object and int[] parameters.\n+         *\n+         * This method first calls the method handle that tests the substitutability\n+         * of all fields that are not recursively-typed, if any, and then test\n+         * the substitutability of the fields that are of each recursive value type.\n+         * The pseudo code looks like this:\n+         *\n+         * boolean base(MethodHandle entry, MethodHandle base1, MethodHandle base2, ..., V o1, V o2, int[] counter) {\n+         *    if (o1 == null && o2 == null) return true;\n+         *    if (o1 == null || o2 == null) return false;\n+         *    if (o1.getClass() != o2. getClass()) return false;\n+         *\n+         *    for each non-recursively-typed field {\n+         *        if (field value of o1 != field value of o2) return false;\n+         *    }\n+         *\n+         *    for each recursively-typed field of type T {\n+         *        if (--counter[0] == 0) throw new StackOverflowError();\n+         *        \/\/ baseT is the method handle corresponding to the recursive type T\n+         *        boolean rc = (boolean) baseT.invoke(o1, o2, counter);\n+         *        if (!rc) return false;\n+         *    }\n+         *    return true;\n+         * }\n+         *\/\n+        MethodHandle generateSubstBase(List<Class<?>> recursiveTypes) {\n+            List<MethodHandle> nonRecurGetters = new ArrayList<>();\n+            Map<Class<?>, List<MethodHandle>> recurGetters = new LinkedHashMap<>();\n+            getterStream(type, TYPE_SORTER).forEach(mh -> {\n+                Class<?> ft = fieldType(mh);\n+                if (!this.recurFieldTypes.contains(ft)) {\n+                    nonRecurGetters.add(mh);\n+                } else {\n+                    assert recursiveTypes.contains(ft);\n+                    recurGetters.computeIfAbsent(ft, t -> new ArrayList<>()).add(mh);\n+                }\n+            });\n+\n+            \/\/ The first parameter is the method handle of the entry point\n+            \/\/ followed with one MethodHandle for each recursive value type\n+            List<Class<?>> leadingMHParams = new ArrayList<>();\n+            int mhParamCount = recursiveTypes.size()+1;\n+            for (int i=0; i < mhParamCount; i++) {\n+                leadingMHParams.add(MethodHandle.class);\n+            }\n+\n+            MethodType mt = methodType(boolean.class,\n+                                       Stream.concat(leadingMHParams.stream(), Stream.of(type, type, int[].class)).collect(toList()));\n+            var allParameters = mt.parameterList();\n+\n+            var instanceTrue = dropArguments(TRUE, 0, allParameters).asType(mt);\n+            var instanceFalse = dropArguments(FALSE, 0, allParameters).asType(mt);\n+            var accumulator = dropArguments(TRUE, 0, allParameters).asType(mt);\n+            var isNull = dropArguments(dropArguments(IS_NULL, 0, leadingMHParams), mhParamCount+2, int[].class).asType(mt);\n+            var isSameValueType = dropArguments(dropArguments(IS_SAME_VALUE_CLASS, 0, leadingMHParams), mhParamCount+2, int[].class).asType(mt);\n+\n+            \/\/ This value class contains cyclic membership.\n+            \/\/ Create a method handle that first calls the method handle that tests\n+            \/\/ the substitutability of all fields that are not recursively-typed, if any,\n+            \/\/ and then test the substitutability of the fields that are of each recursive\n+            \/\/ value type.\n+            \/\/\n+            \/\/ Method handle for the substitutability test for recursive types is built\n+            \/\/ before that for non-recursive types.\n+            for (Map.Entry<Class<?>, List<MethodHandle>> e : recurGetters.entrySet()) {\n+                Class<?> ft = e.getKey();\n+                int index = recursiveTypes.indexOf(ft);\n+                var mtype = methodType(boolean.class,\n+                                Stream.concat(leadingMHParams.stream(), Stream.of(ft, ft, int[].class)).collect(toList()));\n+                var recurEq = RECUR_VALUE_EQ.asType(methodType(boolean.class, MethodHandle.class, ft, ft, int[].class));\n+                var eq = permuteArguments(recurEq, mtype, index+1, mhParamCount, mhParamCount+1, mhParamCount+2);\n+                for (MethodHandle getter : e.getValue()) {\n+                    assert ft == fieldType(getter);\n+                    var thisFieldEqual = filterArguments(eq, mhParamCount, getter, getter);\n+                    accumulator = guardWithTest(thisFieldEqual, accumulator, instanceFalse);\n+                }\n+            }\n+\n+            if (nonRecurGetters.isEmpty()) {\n+                \/\/ if both arguments are null, return true;\n+                \/\/ otherwise return accumulator;\n+                return guardWithTest(isNull,\n+                                     instanceTrue,\n+                                     guardWithTest(isSameValueType, accumulator, instanceFalse));\n+            } else {\n+                \/\/ method handle for substitutability test of the non-recursive-typed fields\n+                var mh = valueTypeEquals(type, nonRecurGetters);\n+                mh = dropArguments(dropArguments(mh, 0, leadingMHParams), mhParamCount+2, int[].class).asType(mt);\n+                return guardWithTest(mh, accumulator, instanceFalse);\n+            }\n+        }\n+\n+        \/*\n+         * Create a method handle where the first N+1 parameters are MethodHandle and\n+         * N is the number of the recursive value types and followed with\n+         * Object and int[] parameters.  The pseudo code looks like this:\n+         *\n+         * int hashCode(MethodHandle entry, MethodHandle base1, MethodHandle base2, ..., Object o, int[] counter) {\n+         *    int[] newCounter = new int[] { counter[0]; }\n+         *    return (int) baseT.invoke(o, newCounter);\n+         * }\n+         *\/\n+        MethodHandle hashCodeEntry(List<Class<?>> recursiveTypes) {\n+            List<Class<?>> leadingMHParams = new ArrayList<>();\n+            int mhParamCount = recursiveTypes.size()+1;\n+            \/\/ the first MethodHandle parameter is this entry point\n+            \/\/ followed with MethodHandle parameter for each mutual exclusive value class\n+            for (int i=0; i < mhParamCount; i++) {\n+                leadingMHParams.add(MethodHandle.class);\n+            }\n+\n+            int index = recursiveTypes.indexOf(type);\n+            var mtype = methodType(int.class, Stream.concat(leadingMHParams.stream(), Stream.of(type, int[].class)).collect(toList()));\n+            var recurHashCode = RECUR_VALUE_HASHCODE.asType(methodType(int.class, MethodHandle.class, type, int[].class));\n+            var mh = permuteArguments(recurHashCode, mtype, index+1, mhParamCount, mhParamCount+1);\n+            return filterArguments(mh, mhParamCount+1, NEW_COUNTER);\n+        }\n+\n+        \/**\n+         * A base method for computing the hashcode for a recursive data type,\n+         * a value class with cyclic membership.\n+         *\n+         * The signature of this base method is:\n+         *    int base(MethodHandle entry, MethodHandle base1, MethodHandle base2, ..., V o, int[] counter)\n+         *\n+         * where the first N+1 parameters are MethodHandle and N is the number of\n+         * the recursive value types and followed with Object and int[] parameters.\n+         *\n+         * This method will first invoke a method handle to compute the hash code\n+         * of the not recursively-typed fields.  Then compute the hash code of the\n+         * remaining recursively-typed fields.\n+         *\/\n+        MethodHandle generateHashCodeBase(List<Class<?>> recursiveTypes) {\n+            assert status == Status.READY;\n+\n+            List<MethodHandle> nonRecurGetters = new ArrayList<>();\n+            Map<Class<?>, List<MethodHandle>> recurGetters = new LinkedHashMap<>();\n+            getterStream(type, null).forEach(mh -> {\n+                Class<?> ft = fieldType(mh);\n+                if (!this.recurFieldTypes.contains(ft)) {\n+                    nonRecurGetters.add(mh);\n+                } else {\n+                    assert recursiveTypes.contains(ft);\n+                    recurGetters.computeIfAbsent(ft, t -> new ArrayList<>()).add(mh);\n+                }\n+            });\n+\n+            int mhParamCount = recursiveTypes.size()+1;\n+            List<Class<?>> leadingMHParams = new ArrayList<>();\n+            for (int i=0; i < mhParamCount; i++) {    \/\/ include entry point\n+                leadingMHParams.add(MethodHandle.class);\n+            }\n+\n+            MethodType mt = methodType(int.class,\n+                                       Stream.concat(leadingMHParams.stream(), Stream.of(type, int[].class)).collect(toList()));\n+            var allParameters = mt.parameterList();\n+            var hashCombiner = dropArguments(HASH_COMBINER, 2, allParameters);\n+            var salt = dropArguments(constant(int.class, SALT), 0, allParameters);\n+            var classHasher = dropArguments(hashCodeForType(Class.class).bindTo(type), 0, allParameters);\n+            var accumulator = foldArguments(foldArguments(hashCombiner, 1, classHasher), 0, salt);\n+            for (MethodHandle getter : nonRecurGetters) {\n+                Class<?> ft = fieldType(getter);\n+                var hasher = dropArguments(hashCodeForType(ft), 0, leadingMHParams);\n+                var hashThisField = filterArguments(hasher, mhParamCount, getter);\n+                var combineHashes = foldArguments(hashCombiner, 1, hashThisField);\n+                accumulator = foldArguments(combineHashes, 0, accumulator);\n+            }\n+\n+            for (Map.Entry<Class<?>, List<MethodHandle>> e : recurGetters.entrySet()) {\n+                Class<?> ft = e.getKey();\n+                int index = recursiveTypes.indexOf(ft);\n+                var mtype = methodType(int.class, Stream.concat(leadingMHParams.stream(), Stream.of(ft, int[].class)).collect(toList()));\n+                var recurHashCode = RECUR_VALUE_HASHCODE.asType(methodType(int.class, MethodHandle.class, ft, int[].class));\n+                var hasher = permuteArguments(recurHashCode, mtype, index + 1, mhParamCount, mhParamCount + 1);\n+                for (MethodHandle getter : e.getValue()) {\n+                    assert ft == fieldType(getter);\n+                    var hashThisField = filterArguments(hasher, mhParamCount, getter);\n+                    var combineHashes = foldArguments(hashCombiner, 1, hashThisField);\n+                    accumulator = foldArguments(combineHashes, 0, accumulator);\n+                }\n+            }\n+            return accumulator;\n+        }\n+\n+        private String debugString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(type.getName()).append(\" \").append(status).append(\"\\n\");\n+            sb.append(fieldValueTypes.stream().filter(c -> !recurFieldTypes.contains(c))\n+                            .map(Class::getName)\n+                            .collect(joining(\" \", \"  non-recursive types: \", \"\\n\")));\n+            sb.append(recurFieldTypes.stream().map(Class::getName)\n+                            .collect(joining(\" \", \"  recursive types: \", \"\\n\")));\n+            for (var n : cyclicMembers.keySet()) {\n+                List<Class<?>> cycle = cyclicMembers.get(n);\n+                sb.append(\"  cycle: \");\n+                int start = cycle.indexOf(n);\n+                for (int i=start; i < cycle.size(); i++ ) {\n+                    sb.append(cycle.get(i).getName()).append(\" -> \");\n+                }\n+                for (int i=0; i < start; i++) {\n+                    sb.append(cycle.get(i).getName()).append(\" -> \");\n+                }\n+                sb.append(n.getName()).append(\"\\n\");\n+            };\n+            return sb.toString();\n+        }\n@@ -786,0 +1184,16 @@\n+    private static final ClassValue<MethodHandleBuilder> METHOD_HANDLE_BUILDERS = new ClassValue<>() {\n+        @Override protected MethodHandleBuilder computeValue(Class<?> type) {\n+            var builder = CACHED_METHOD_HANDLE_BUILDERS.get(type);\n+            if (builder == null) {\n+                builder = MethodHandleBuilder.newBuilder(type).build();\n+            }\n+            return builder;\n+        }\n+    };\n+\n+    \/\/ This cache is only used to propagate the builders of mutual recursive types\n+    \/\/ A -> B -> C -> A as method handles for equals\/hashCode for A, B, C are\n+    \/\/ all precomputed.  This map should only be non-empty only during the short\n+    \/\/ window propagating to the method handle builder class value.\n+    private static Map<Class<?>, MethodHandleBuilder> CACHED_METHOD_HANDLE_BUILDERS = new ConcurrentHashMap<>();\n+\n@@ -886,1 +1300,1 @@\n-     *   return base2(&recursive, &recursive2, &recursive3, a3...);\n+     *   return base3(&recursive, &recursive2, &recursive3, a3...);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":780,"deletions":366,"binary":false,"changes":1146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n@@ -222,1 +220,0 @@\n-\n@@ -227,1 +224,1 @@\n-                Arguments.of(V, hash(hashCodeComponents(V))),\n+                Arguments.of(V, hash(Value.class, P1, L1, V.r, V.s)),\n@@ -242,15 +239,0 @@\n-    private static Object[] hashCodeComponents(Object o) {\n-        Class<?> type = o.getClass();\n-        \/\/ filter static fields\n-        Stream<Object> fields = Arrays.stream(type.getDeclaredFields())\n-            .filter(f -> !Modifier.isStatic(f.getModifiers()))\n-            .map(f -> {\n-                try {\n-                    return f.get(o);\n-                } catch (IllegalAccessException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n-        return Stream.concat(Stream.of(type), fields).toArray(Object[]::new);\n-    }\n-\n@@ -265,1 +247,0 @@\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethods.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n- * @compile -XDenablePrimitiveClasses RecursiveValueClass.java\n- * @run junit\/othervm -Xint -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n+ * @run junit\/othervm -Xint -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n@@ -33,2 +32,1 @@\n- * @compile -XDenablePrimitiveClasses RecursiveValueClass.java\n- * @run junit\/othervm -XX:TieredStopAtLevel=1 -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n+ * @run junit\/othervm -XX:TieredStopAtLevel=1 -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n@@ -40,2 +38,1 @@\n- * @compile -XDenablePrimitiveClasses RecursiveValueClass.java\n- * @run junit\/othervm -Xcomp -XX:+EnableValhalla -XX:+EnablePrimitiveClasses -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n+ * @run junit\/othervm -Xcomp -Djdk.value.recursion.threshold=100000 RecursiveValueClass\n@@ -44,0 +41,3 @@\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.NullRestricted;\n@@ -54,0 +54,1 @@\n+    @ImplicitlyConstructible\n@@ -64,1 +65,2 @@\n-    static primitive class P {\n+    @ImplicitlyConstructible\n+    static value class P {\n@@ -67,1 +69,1 @@\n-        P(Node node) {\n+        P(Node node, V v) {\n@@ -69,1 +71,1 @@\n-            this.v = null;\n+            this.v = v;\n@@ -73,0 +75,1 @@\n+    @ImplicitlyConstructible\n@@ -74,3 +77,3 @@\n-        P.ref p;\n-        V() {\n-            this.p = null;\n+        P p;\n+        V(P p) {\n+            this.p = p;\n@@ -80,0 +83,1 @@\n+    @ImplicitlyConstructible\n@@ -88,0 +92,2 @@\n+\n+    @ImplicitlyConstructible\n@@ -96,0 +102,2 @@\n+\n+    @ImplicitlyConstructible\n@@ -102,0 +110,2 @@\n+\n+    @ImplicitlyConstructible\n@@ -108,0 +118,2 @@\n+\n+    @ImplicitlyConstructible\n@@ -114,0 +126,2 @@\n+\n+    @ImplicitlyConstructible\n@@ -122,1 +136,1 @@\n-        var n1 = Node.default;\n+        var n1 = ValueClass.zeroInstance(Node.class);\n@@ -126,4 +140,8 @@\n-        var p1 = new P(n3);\n-        var p2 = new P(n4);\n-\n-        var e1 = new E(F.default);\n+        var v1 = ValueClass.zeroInstance(V.class);\n+        var p1 = new P(n3, v1);\n+        var p2 = new P(n4, v1);\n+        var v2 = new V(p1);\n+        var v3 = new V(p2);\n+        var p3 = new P(n3, v2);\n+\n+        var e1 = new E(ValueClass.zeroInstance(F.class));\n@@ -134,1 +152,1 @@\n-        var a = new A(B.default, E.default);\n+        var a = new A(ValueClass.zeroInstance(B.class), ValueClass.zeroInstance(E.class));\n@@ -157,1 +175,1 @@\n-                \/\/ primitive class P -> value class V -> P.ref\n+                \/\/ value class P -> value class V -> P\n@@ -159,0 +177,3 @@\n+                Arguments.of(p1, p3,     false),\n+                Arguments.of(p3, p3,     true),\n+                Arguments.of(v2, v3,     true),\n@@ -184,1 +205,1 @@\n-        var n1 = Node.default;\n+        var n1 = ValueClass.zeroInstance(Node.class);\n@@ -187,1 +208,3 @@\n-        var p1 = new P(n3);\n+        var v1 = new V(null);\n+        var p1 = new P(n3, v1);\n+        var v2 = new V(p1);\n@@ -189,1 +212,1 @@\n-        var e1 = new E(F.default);\n+        var e1 = new E(ValueClass.zeroInstance(F.class));\n@@ -194,1 +217,1 @@\n-        var a = new A(B.default, E.default);\n+        var a = new A(ValueClass.zeroInstance(B.class), ValueClass.zeroInstance(E.class));\n@@ -211,2 +234,1 @@\n-\n-                \/\/ primitive class P -> value class V -> P.ref\n+                \/\/ value class P -> value class V -> P\n@@ -214,0 +236,1 @@\n+                Arguments.of(v2),\n@@ -238,0 +261,1 @@\n+    @ImplicitlyConstructible\n@@ -272,1 +296,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/RecursiveValueClass.java","additions":51,"deletions":27,"binary":false,"changes":78,"status":"modified"}]}