{"files":[{"patch":"@@ -42,1 +42,1 @@\n-  $1_Type := $2\n+  $1_InputType := $2\n@@ -44,1 +44,1 @@\n-  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)\/VarHandle$$($1_Type)s.java\n+  $1_FILENAME := $(VARHANDLES_GENSRC_DIR)\/VarHandle$$($1_InputType)s.java\n@@ -48,1 +48,1 @@\n-  ifneq ($$(findstring $$($1_Type), Byte Short Char Int Long Float Double), )\n+  ifneq ($$(findstring $$($1_InputType), Byte Short Char Int Long Float Double), )\n@@ -50,0 +50,7 @@\n+    $1_ARGS += -KNonPlainAccess\n+    $1_ARGS += -KStatic\n+    $1_ARGS += -KArray\n+  endif\n+\n+  ifneq ($$(findstring $$($1_InputType), Byte Short Char Int Long), )\n+    $1_ARGS += -KBitwise\n@@ -52,1 +59,1 @@\n-  ifneq ($$(findstring $$($1_Type), Boolean Byte Short Char Int Long), )\n+  ifeq ($$($1_InputType), Boolean)\n@@ -54,0 +61,3 @@\n+    $1_ARGS += -KNonPlainAccess\n+    $1_ARGS += -KStatic\n+    $1_ARGS += -KArray\n@@ -56,1 +66,1 @@\n-  ifneq ($$(findstring $$($1_Type), Byte Short Char), )\n+  ifneq ($$(findstring $$($1_InputType), Byte Short Char), )\n@@ -60,1 +70,1 @@\n-  ifeq ($$($1_Type), Reference)\n+  ifeq ($$($1_InputType), Reference)\n@@ -62,0 +72,10 @@\n+    $1_ARGS += -KNonPlainAccess\n+    $1_ARGS += -KStatic\n+    $1_ARGS += -KArray\n+  endif\n+\n+  ifeq ($$($1_InputType), NonAtomicReference)\n+      $1_ARGS += -KReference\n+      $1_ARGS += -KStatic\n+      $1_Type := Reference\n+      $1_ARGS += -KArray\n@@ -64,1 +84,6 @@\n-  ifeq ($$($1_Type), FlatValue)\n+  ifeq ($$($1_InputType), FlatValue)\n+    $1_ARGS += -KFlatValue\n+    $1_ARGS += -KNonPlainAccess\n+  endif\n+\n+  ifeq ($$($1_InputType), NonAtomicFlatValue)\n@@ -69,1 +94,7 @@\n-        ifeq ($$($1_Type), Reference)\n+        ifeq ($$($1_InputType), Reference)\n+\t  $$(eval $1_type := Object)\n+\t  $$(eval $1_Type := Reference)\n+        else ifeq ($$($1_InputType), NonAtomicReference)\n+\t  $$(eval $1_type := Object)\n+\t  $$(eval $1_Type := Reference)\n+        else ifeq ($$($1_InputType), FlatValue)\n@@ -71,1 +102,2 @@\n-        else ifeq ($$($1_Type), FlatValue)\n+\t  $$(eval $1_Type := FlatValue)\n+        else ifeq ($$($1_InputType), NonAtomicFlatValue)\n@@ -73,0 +105,1 @@\n+\t  $$(eval $1_Type := FlatValue)\n@@ -74,1 +107,2 @@\n-\t  $$(eval $1_type := $$$$(shell $(TR) '[:upper:]' '[:lower:]' <<< $$$$($1_Type)))\n+\t  $$(eval $1_type := $$$$(shell $(TR) '[:upper:]' '[:lower:]' <<< $$$$($1_InputType)))\n+\t  $$(eval $1_Type := $$$$($1_InputType))\n@@ -78,1 +112,1 @@\n-\t$(TOOL_SPP) -nel -K$$($1_type) -Dtype=$$($1_type) -DType=$$($1_Type) \\\n+\t$(TOOL_SPP) -nel -K$$($1_type) -Dtype=$$($1_type) -DType=$$($1_Type) -DInputType=$$($1_InputType) \\\n@@ -297,1 +331,1 @@\n-VARHANDLES_TYPES := Boolean Byte Short Char Int Long Float Double Reference FlatValue\n+VARHANDLES_TYPES := Boolean Byte Short Char Int Long Float Double Reference FlatValue NonAtomicReference NonAtomicFlatValue\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":46,"deletions":12,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -509,1 +509,0 @@\n-             VarHandleFlatValues.Array,\n@@ -511,1 +510,4 @@\n-             VarHandleFlatValues.FieldStaticReadOnly {\n+             VarHandleNonAtomicReferences.Array,\n+             VarHandleNonAtomicReferences.FieldInstanceReadOnly,\n+             VarHandleNonAtomicReferences.FieldStaticReadOnly,\n+             VarHandleNonAtomicFlatValues.FieldInstanceReadOnly {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.value.NullRestrictedCheckedType;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -53,1 +56,1 @@\n-                if (f.isFlat()) {\n+                if (type.isValue()) {\n@@ -55,3 +58,23 @@\n-                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n-                        ? new VarHandleFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType(), layout)\n-                        : new VarHandleFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType(), layout));\n+                    boolean isAtomic = isAtomicFlat(f);\n+                    boolean isFlat = f.isFlat();\n+                    if (isFlat) {\n+                        if (isAtomic) {\n+                            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                                    ? new VarHandleFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType(), layout)\n+                                    : new VarHandleFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType(), layout));\n+                        } else {\n+                            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                                    ? new VarHandleNonAtomicFlatValues.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType(), layout)\n+                                    : new VarHandleNonAtomicFlatValues.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType(), layout));\n+                        }\n+                    } else {\n+                        if (isAtomic) {\n+                            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                                    ? new VarHandleReferences.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n+                                    : new VarHandleReferences.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n+                        } else {\n+                            return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                                    ? new VarHandleNonAtomicReferences.FieldInstanceReadOnly(refc, foffset, type, f.getCheckedFieldType())\n+                                    : new VarHandleNonAtomicReferences.FieldInstanceReadWrite(refc, foffset, type, f.getCheckedFieldType()));\n+                        }\n+                    }\n@@ -122,6 +145,11 @@\n-            if (f.isFlat()) {\n-                assert false : (\"static field is flat in \" + decl + \".\" + f.getName());\n-                int layout = f.getLayout();\n-                return f.isFinal() && !isWriteAllowedOnFinalFields\n-                        ? new VarHandleFlatValues.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType(), layout)\n-                        : new VarHandleFlatValues.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType(), layout);\n+            assert !f.isFlat() : (\"static field is flat in \" + decl + \".\" + f.getName());\n+            if (type.isValue()) {\n+                if (isAtomicFlat(f)) {\n+                    return f.isFinal() && !isWriteAllowedOnFinalFields\n+                            ? new VarHandleReferences.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n+                            : new VarHandleReferences.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType());\n+                } else {\n+                    return maybeAdapt(f.isFinal() && !isWriteAllowedOnFinalFields\n+                            ? new VarHandleNonAtomicReferences.FieldStaticReadOnly(decl, base, foffset, type, f.getCheckedFieldType())\n+                            : new VarHandleNonAtomicReferences.FieldStaticReadWrite(decl, base, foffset, type, f.getCheckedFieldType()));\n+                }\n@@ -179,0 +207,30 @@\n+    static boolean isAtomicFlat(MemberName field) {\n+        boolean hasAtomicAccess = (field.getModifiers() & Modifier.VOLATILE) != 0 ||\n+                !(field.getCheckedFieldType() instanceof NullRestrictedCheckedType) ||\n+                !field.getFieldType().isAnnotationPresent(LooselyConsistentValue.class);\n+        return hasAtomicAccess && !HAS_OOPS.get(field.getFieldType());\n+    }\n+\n+    static boolean isAtomicFlat(Object[] array) {\n+        Class<?> componentType = array.getClass().componentType();\n+        boolean hasAtomicAccess = ValueClass.isAtomicArray(array) ||\n+                !ValueClass.isNullRestrictedArray(array) ||\n+                !componentType.isAnnotationPresent(LooselyConsistentValue.class);\n+        return hasAtomicAccess && !HAS_OOPS.get(componentType);\n+    }\n+\n+    static final ClassValue<Boolean> HAS_OOPS = new ClassValue<>() {\n+        @Override\n+        protected Boolean computeValue(Class<?> c) {\n+            for (Field f : c.getDeclaredFields()) {\n+                Class<?> ftype = f.getType();\n+                if (UNSAFE.isFlatField(f) && HAS_OOPS.get(ftype)) {\n+                    return true;\n+                } else if (!ftype.isPrimitive()) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    };\n+\n@@ -209,0 +267,7 @@\n+    \/\/ This is invoked by non-flat array var handle code when attempting to access a flat array\n+    public static void checkAtomicFlatArray(Object[] array) {\n+        if (!isAtomicFlat(array)) {\n+            throw new IllegalArgumentException(\"Attempt to perform a non-plain access on a non-atomic array\");\n+        }\n+    }\n+\n@@ -220,8 +285,5 @@\n-            VarHandle vh;\n-            if (UNSAFE.isFlatArray(arrayClass)) {\n-                int layout = UNSAFE.arrayLayout(arrayClass);\n-                vh = new VarHandleFlatValues.Array(aoffset, ashift, arrayClass, layout);\n-            } else {\n-                vh = new VarHandleReferences.Array(aoffset, ashift, arrayClass);\n-            }\n-            return maybeAdapt(vh);\n+            \/\/ Here we always return a reference array element var handle. This is because\n+            \/\/ the access semantics is determined at runtime, when an actual array object is passed\n+            \/\/ to the var handle. The var handle implementation will switch to use flat access\n+            \/\/ primitives if it sees a flat array.\n+            return maybeAdapt(new VarHandleReferences.Array(aoffset, ashift, arrayClass));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":80,"deletions":18,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.reflect.Field;\n@@ -43,1 +44,1 @@\n-final class VarHandle$Type$s {\n+final class VarHandle$InputType$s {\n@@ -119,0 +120,1 @@\n+#if[NonPlainAccess]\n@@ -157,0 +159,1 @@\n+#end[NonPlainAccess]\n@@ -200,0 +203,1 @@\n+#if[NonPlainAccess]\n@@ -301,1 +305,1 @@\n-                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n@@ -309,1 +313,1 @@\n-                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n@@ -317,1 +321,1 @@\n-                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n@@ -422,0 +426,1 @@\n+#end[NonPlainAccess]\n@@ -426,1 +431,1 @@\n-\n+#if[Static]\n@@ -436,1 +441,1 @@\n-        final int layout;\n+        final int layout;        \n@@ -505,0 +510,1 @@\n+#if[NonPlainAccess]\n@@ -543,0 +549,1 @@\n+#end[NonPlainAccess]\n@@ -587,0 +594,1 @@\n+#if[NonPlainAccess]\n@@ -689,1 +697,1 @@\n-                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n@@ -697,1 +705,1 @@\n-                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n@@ -705,1 +713,1 @@\n-                                          handle.fieldOffset{#if[FlatValue]?, handle.layout, handle.fieldType},\n+                                          handle.fieldOffset{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.fieldType},\n@@ -809,0 +817,1 @@\n+#end[NonPlainAccess]\n@@ -812,0 +821,1 @@\n+#end[Static]    \n@@ -813,0 +823,1 @@\n+#if[Array]\n@@ -910,9 +921,0 @@\n-#if[Reference]\n-            Class<?> arrayType = oarray.getClass();\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                vh.set(oarray, index, value);\n-                return;\n-            }\n-#end[Reference]\n@@ -922,0 +924,1 @@\n+#if[NonPlainAccess]\n@@ -932,4 +935,9 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.getVolatile(oarray, index);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.getFlatValueVolatile(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n@@ -939,1 +947,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase);\n@@ -952,4 +960,10 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                vh.setVolatile(oarray, index, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                UNSAFE.putFlatValueVolatile(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -960,2 +974,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    {#if[FlatValue]?handle.layout, handle.componentType, }{#if[Object]?runtimeTypeCheck(handle, array, value):value});\n@@ -974,4 +988,9 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.getOpaque(oarray, index);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.getFlatValueOpaque(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n@@ -994,4 +1013,10 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                vh.setOpaque(oarray, index, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                UNSAFE.putFlatValueOpaque(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1002,2 +1027,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    {#if[FlatValue]?handle.layout, handle.componentType, }{#if[Object]?runtimeTypeCheck(handle, array, value):value});\n@@ -1016,4 +1041,9 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.getAcquire(oarray, index);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.getFlatValueAcquire(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType());\n@@ -1036,4 +1066,10 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                vh.setRelease(oarray, index, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                UNSAFE.putFlatValueRelease(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1044,2 +1080,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    {#if[FlatValue]?handle.layout, handle.componentType, }{#if[Object]?runtimeTypeCheck(handle, array, value):value});\n@@ -1059,4 +1095,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.compareAndSet(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.compareAndSetFlatValue(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1081,4 +1124,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.compareAndExchange(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.compareAndExchangeFlatValue(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1103,4 +1153,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.compareAndExchangeAcquire(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.compareAndExchangeFlatValueAcquire(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1125,4 +1182,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.compareAndExchangeRelease(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.compareAndExchangeFlatValueRelease(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1132,1 +1196,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -1147,4 +1211,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.weakCompareAndSetPlain(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.weakCompareAndSetFlatValuePlain(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1154,1 +1225,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -1169,4 +1240,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.weakCompareAndSet(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.weakCompareAndSetFlatValue(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1176,1 +1254,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -1191,4 +1269,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.weakCompareAndSetAcquire(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.weakCompareAndSetFlatValueAcquire(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1198,1 +1283,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -1213,4 +1298,11 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.weakCompareAndSetRelease(oarray, index, expected, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.weakCompareAndSetFlatValueRelease(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         arrayType.componentType().cast(expected),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1220,1 +1312,1 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout}{#if[Object]?, handle.componentType},\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[Object]?, handle.componentType},\n@@ -1235,4 +1327,10 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.getAndSet(oarray, index, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.getAndSetFlatValue(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1242,2 +1340,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    {#if[Object]?handle.componentType, runtimeTypeCheck(handle, array, value):value});\n@@ -1256,4 +1354,10 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.getAndSetAcquire(oarray, index, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.getAndSetFlatValueAcquire(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1263,2 +1367,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    {#if[Object]?handle.componentType, runtimeTypeCheck(handle, array, value):value});\n@@ -1277,4 +1381,10 @@\n-            if (handle.arrayType != arrayType && UNSAFE.isFlatArray(arrayType)) {\n-                \/\/ delegate to VarHandle of flat array\n-                VarHandle vh = VarHandleFlatValues.flatArrayVarHandle(arrayType);\n-                return vh.getAndSetRelease(oarray, index, value);\n+            if (handle.arrayType != arrayType && ValueClass.isFlatArray(oarray)) {\n+                \/\/ delegate to flat access primitives\n+                VarHandles.checkAtomicFlatArray(array);\n+                int aoffset = (int) UNSAFE.arrayBaseOffset(arrayType);\n+                int ascale = UNSAFE.arrayIndexScale(arrayType);\n+                int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n+                int layout = UNSAFE.arrayLayout(arrayType);\n+                return UNSAFE.getAndSetFlatValueRelease(array,\n+                        (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << ashift) + aoffset, layout, arrayType.componentType(),\n+                         runtimeTypeCheck(handle, array, value));\n@@ -1284,2 +1394,2 @@\n-                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase{#if[FlatValue]?, handle.layout, handle.componentType},\n-                    {#if[Object]?runtimeTypeCheck(handle, array, value):value});\n+                    (((long) Preconditions.checkIndex(index, array.length, Preconditions.AIOOBE_FORMATTER)) << handle.ashift) + handle.abase,\n+                    {#if[Object]?handle.componentType, runtimeTypeCheck(handle, array, value):value});\n@@ -1400,0 +1510,2 @@\n+#end[NonPlainAccess]\n+\n@@ -1402,15 +1514,1 @@\n-#if[FlatValue]\n-    static final ClassValue<Array> flatArrayVarHandles = new ClassValue<>() {\n-        @Override protected Array computeValue(Class<?> arrayClass) {\n-            assert UNSAFE.isFlatArray(arrayClass);\n-            int aoffset = (int) UNSAFE.arrayBaseOffset(arrayClass);\n-            int ascale = UNSAFE.arrayIndexScale(arrayClass);\n-            int ashift = 31 - Integer.numberOfLeadingZeros(ascale);\n-            int layout = UNSAFE.arrayLayout(arrayClass);\n-            return new Array(aoffset, ashift, arrayClass, layout);\n-        }\n-    };\n-    static VarHandle flatArrayVarHandle(Class<?> arrayClass) {\n-        return flatArrayVarHandles.get(arrayClass);\n-    }\n-#end[FlatValue]\n+#end[Array]\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandle.java.template","additions":217,"deletions":119,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -1656,3 +1657,0 @@\n-     *\n-     * TODO: replace global lock workaround with the proper support for\n-     * atomic access to value objects and loosely consistent values.\n@@ -1665,6 +1663,3 @@\n-            synchronized (valueLock) {\n-                Object witness = getReference(o, offset);\n-                if (witness == expected) {\n-                    putReference(o, offset, x);\n-                    return true;\n-                } else {\n+            while (true) {\n+                Object witness = getReferenceVolatile(o, offset);\n+                if (witness != expected) {\n@@ -1673,0 +1668,3 @@\n+                if (compareAndSetReference(o, offset, witness, x)) {\n+                    return true;\n+                }\n@@ -1685,7 +1683,3 @@\n-        synchronized (valueLock) {\n-            Object witness = getFlatValue(o, offset, layout, valueType);\n-            if (witness == expected) {\n-                putFlatValue(o, offset, layout, valueType, x);\n-                return true;\n-            }\n-            else {\n+        while (true) {\n+            Object witness = getFlatValueVolatile(o, offset, layout, valueType);\n+            if (witness != expected) {\n@@ -1694,0 +1688,3 @@\n+            if (compareAndSetFlatValueAsBytes(o, offset, layout, valueType, witness, x)) {\n+                return true;\n+            }\n@@ -1707,4 +1704,7 @@\n-            synchronized (valueLock) {\n-                Object witness = getReference(o, offset);\n-                if (witness == expected) {\n-                    putReference(o, offset, x);\n+            while (true) {\n+                Object witness = getReferenceVolatile(o, offset);\n+                if (witness != expected) {\n+                    return witness;\n+                }\n+                if (compareAndSetReference(o, offset, witness, x)) {\n+                    return witness;\n@@ -1712,1 +1712,0 @@\n-                return witness;\n@@ -1725,4 +1724,7 @@\n-        synchronized (valueLock) {\n-            Object witness = getFlatValue(o, offset, layout, valueType);\n-            if (witness == expected) {\n-                putFlatValue(o, offset, layout, valueType, x);\n+        while (true) {\n+            Object witness = getFlatValueVolatile(o, offset, layout, valueType);\n+            if (witness != expected) {\n+                return witness;\n+            }\n+            if (compareAndSetFlatValueAsBytes(o, offset, layout, valueType, witness, x)) {\n+                return witness;\n@@ -1730,1 +1732,0 @@\n-            return witness;\n@@ -2503,11 +2504,6 @@\n-    \/**\n-     * Global lock for atomic and volatile strength access to any value of\n-     * a value type.  This is a temporary workaround until better localized\n-     * atomic access mechanisms are supported for value class and primitive class.\n-     *\/\n-    private static final Object valueLock = new Object();\n-\n-    public final <V> Object getFlatValueVolatile(Object base, long offset, int layout, Class<?> valueType) {\n-        synchronized (valueLock) {\n-            return getFlatValue(base, offset, layout, valueType);\n-        }\n+    @ForceInline\n+    public final <V> Object getFlatValueVolatile(Object o, long offset, int layout, Class<?> valueType) {\n+        \/\/ we translate using fences (see: https:\/\/gee.cs.oswego.edu\/dl\/html\/j9mm.html)\n+        Object res = getFlatValue(o, offset, layout, valueType);\n+        fullFence();\n+        return res;\n@@ -2523,0 +2519,1 @@\n+    @ForceInline\n@@ -2524,3 +2521,3 @@\n-        synchronized (valueLock) {\n-            putFlatValue(o, offset, layout, valueType, x);\n-        }\n+        \/\/ we translate using fences (see: https:\/\/gee.cs.oswego.edu\/dl\/html\/j9mm.html)\n+        putFlatValueRelease(o, offset, layout, valueType, x);\n+        fullFence();\n@@ -2601,2 +2598,6 @@\n-    public final <V> Object getFlatValueAcquire(Object base, long offset, int layout, Class<?> valueType) {\n-        return getFlatValueVolatile(base, offset, layout, valueType);\n+    @ForceInline\n+    public final <V> Object getFlatValueAcquire(Object o, long offset, int layout, Class<?> valueType) {\n+        \/\/ we translate using fences (see: https:\/\/gee.cs.oswego.edu\/dl\/html\/j9mm.html)\n+        Object res = getFlatValue(o, offset, layout, valueType);\n+        loadFence();\n+        return res;\n@@ -2669,0 +2670,1 @@\n+    @ForceInline\n@@ -2670,1 +2672,3 @@\n-        putFlatValueVolatile(o, offset, layout, valueType, x);\n+        \/\/ we translate using fences (see: https:\/\/gee.cs.oswego.edu\/dl\/html\/j9mm.html)\n+        storeFence();\n+        putFlatValue(o, offset, layout, valueType, x);\n@@ -2729,2 +2733,4 @@\n-    public final <V> Object getFlatValueOpaque(Object base, long offset, int layout, Class<?> valueType) {\n-        return getFlatValueVolatile(base, offset, layout, valueType);\n+    @ForceInline\n+    public final <V> Object getFlatValueOpaque(Object o, long offset, int layout, Class<?> valueType) {\n+        \/\/ this is stronger that opaque semantics\n+        return getFlatValueAcquire(o, offset, layout, valueType);\n@@ -2787,0 +2793,1 @@\n+    @ForceInline\n@@ -2788,1 +2795,2 @@\n-        putFlatValueVolatile(o, offset, layout, valueType, x);\n+        \/\/ this is stronger that opaque semantics\n+        putFlatValueRelease(o, offset, layout, valueType, x);\n@@ -2839,0 +2847,44 @@\n+    private boolean compareAndSetFlatValueAsBytes(Object o, long offset, int layout, Class<?> valueType, Object expected, Object x) {\n+        \/\/ try nullable atomic array first\n+        Object expectedArray = ValueClass.newNullableAtomicArray(valueType, 1);\n+        Object xArray = ValueClass.newNullableAtomicArray(valueType, 1);\n+        if (arrayLayout(expectedArray.getClass()) != layout) {\n+            \/\/ then try null-restricted atomic\n+            expectedArray = ValueClass.newNullRestrictedAtomicArray(valueType, 1);\n+            xArray = ValueClass.newNullRestrictedAtomicArray(valueType, 1);\n+        }\n+        if (arrayLayout(expectedArray.getClass()) != layout) {\n+            \/\/ if layout still doesn't match, give up\n+            throw new IllegalStateException(\"Unsupported layout: \" + layout);\n+        }\n+        long base = arrayBaseOffset(expectedArray.getClass());\n+        int scale = arrayIndexScale(expectedArray.getClass());\n+        putFlatValue(expectedArray, base, layout, valueType, expected);\n+        putFlatValue(xArray, base, layout, valueType, x);\n+        switch (scale) {\n+            case 1: {\n+                byte expectedByte = getByte(expectedArray, base);\n+                byte xByte = getByte(xArray, base);\n+                return compareAndSetByte(o, offset, expectedByte, xByte);\n+            }\n+            case 2: {\n+                short expectedShort = getShort(expectedArray, base);\n+                short xShort = getShort(xArray, base);\n+                return compareAndSetShort(o, offset, expectedShort, xShort);\n+            }\n+            case 4: {\n+                int expectedInt = getInt(expectedArray, base);\n+                int xInt = getInt(xArray, base);\n+                return compareAndSetInt(o, offset, expectedInt, xInt);\n+            }\n+            case 8: {\n+                long expectedLong = getLong(expectedArray, base);\n+                long xLong = getLong(xArray, base);\n+                return compareAndSetLong(o, offset, expectedLong, xLong);\n+            }\n+            default: {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n@@ -3225,7 +3277,15 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public final <V> Object getAndSetFlatValue(Object o, long offset, int layout, Class<?> valueType, V newValue) {\n-        synchronized (valueLock) {\n-            Object oldValue = getFlatValue(o, offset, layout, valueType);\n-            putFlatValue(o, offset, layout, valueType, newValue);\n-            return oldValue;\n-        }\n+    @ForceInline\n+    public final Object getAndSetReference(Object o, long offset, Class<?> valueType, Object newValue) {\n+        Object v;\n+        do {\n+            v = getReferenceVolatile(o, offset);\n+        } while (!compareAndSetReference(o, offset, valueType, v, newValue));\n+        return v;\n+    }\n+\n+    public Object getAndSetFlatValue(Object o, long offset, int layoutKind, Class<?> valueType, Object newValue) {\n+        Object v;\n+        do {\n+            v = getFlatValueVolatile(o, offset, layoutKind, valueType);\n+        } while (!compareAndSetFlatValue(o, offset, layoutKind, valueType, v, newValue));\n+        return v;\n@@ -3244,2 +3304,7 @@\n-    public final <V> Object getAndSetFlatValueRelease(Object o, long offset, int layout, Class<?> valueType, V newValue) {\n-        return getAndSetFlatValue(o, offset, layout, valueType, newValue);\n+    public final Object getAndSetReferenceRelease(Object o, long offset, Class<?> valueType, Object newValue) {\n+        return getAndSetReference(o, offset, valueType, newValue);\n+    }\n+\n+    @ForceInline\n+    public Object getAndSetFlatValueRelease(Object o, long offset, int layoutKind, Class<?> valueType, Object x) {\n+        return getAndSetFlatValue(o, offset, layoutKind, valueType, x);\n@@ -3258,2 +3323,7 @@\n-    public final <V> Object getAndSetFlatValueAcquire(Object o, long offset, int layout, Class<?> valueType, V newValue) {\n-        return getAndSetFlatValue(o, offset, layout, valueType, newValue);\n+    public final Object getAndSetReferenceAcquire(Object o, long offset, Class<?> valueType, Object newValue) {\n+        return getAndSetReference(o, offset, valueType, newValue);\n+    }\n+\n+    @ForceInline\n+    public Object getAndSetFlatValueAcquire(Object o, long offset, int layoutKind, Class<?> valueType, Object x) {\n+        return getAndSetFlatValue(o, offset, layoutKind, valueType, x);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":127,"deletions":57,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -1207,0 +1207,1 @@\n+        if (TEST31_VT_FLATTENED) return;\n@@ -1237,0 +1238,1 @@\n+        if (TEST33_FLATTENED_ARRAY) return;\n@@ -1267,0 +1269,1 @@\n+        if (TEST31_VT_FLATTENED) return;\n@@ -1291,0 +1294,1 @@\n+        if (TEST31_VT_FLATTENED) return;\n@@ -1315,0 +1319,1 @@\n+        if (TEST31_VT_FLATTENED) return;\n@@ -1346,0 +1351,1 @@\n+        if (TEST33_FLATTENED_ARRAY) return;\n@@ -1376,0 +1382,1 @@\n+        if (TEST31_VT_FLATTENED) return;\n@@ -1401,0 +1408,1 @@\n+        if (TEST31_VT_FLATTENED) return;\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestIntrinsics.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import jdk.internal.value.NullRestrictedCheckedType;\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.ParameterizedTest;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.VarHandle.AccessMode;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+\n+\/*\n+ * @test\n+ * @summary Test atomic access modes on var handles for flattened values\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value java.base\/jdk.internal.vm.annotation\n+ * @run junit\/othervm -XX:-UseArrayFlattening -XX:-UseNullableValueFlattening FlatVarHandleTest\n+ * @run junit\/othervm -XX:+UseArrayFlattening -XX:+UseNullableValueFlattening FlatVarHandleTest\n+ *\/\n+public class FlatVarHandleTest {\n+\n+    interface Pointable { }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class WeakPoint implements Pointable {\n+        short x,y;\n+        WeakPoint(int i, int j) { x = (short)i; y = (short)j; }\n+\n+        static WeakPoint[] makePoints(int len, BiFunction<Class<?>, Integer, Object[]> arrayFactory) {\n+            WeakPoint[] array = (WeakPoint[])arrayFactory.apply(WeakPoint.class, len);\n+            for (int i = 0; i < len; ++i) {\n+                array[i] = new WeakPoint(i, i);\n+            }\n+            return array;\n+        }\n+    }\n+\n+    static class WeakPointHolder {\n+        WeakPoint p_i = new WeakPoint(0, 0);\n+        static WeakPoint p_s = new WeakPoint(0, 0);\n+        @NullRestricted\n+        WeakPoint p_i_nr = new WeakPoint(0, 0);\n+        @NullRestricted\n+        static WeakPoint p_s_nr = new WeakPoint(0, 0);\n+    }\n+\n+    @ImplicitlyConstructible\n+    static value class StrongPoint implements Pointable {\n+        short x,y;\n+        StrongPoint(int i, int j) { x = (short)i; y = (short)j; }\n+\n+        static StrongPoint[] makePoints(int len, BiFunction<Class<?>, Integer, Object[]> arrayFactory) {\n+            StrongPoint[] array = (StrongPoint[])arrayFactory.apply(StrongPoint.class, len);\n+            for (int i = 0; i < len; ++i) {\n+                array[i] = new StrongPoint(i, i);\n+            }\n+            return array;\n+        }\n+    }\n+\n+    static class StrongPointHolder {\n+        StrongPoint p_i = new StrongPoint(0, 0);\n+        static StrongPoint p_s = new StrongPoint(0, 0);\n+    }\n+\n+    private static List<Arguments> fieldAccessProvider() {\n+        try {\n+            List<Field> fields = List.of(\n+                    WeakPointHolder.class.getDeclaredField(\"p_s\"),\n+                    WeakPointHolder.class.getDeclaredField(\"p_i\"),\n+                    WeakPointHolder.class.getDeclaredField(\"p_s_nr\"),\n+                    WeakPointHolder.class.getDeclaredField(\"p_i_nr\"),\n+                    StrongPointHolder.class.getDeclaredField(\"p_s\"),\n+                    StrongPointHolder.class.getDeclaredField(\"p_i\"));\n+            List<Arguments> arguments = new ArrayList<>();\n+            for (AccessMode accessMode : AccessMode.values()) {\n+                for (Field field : fields) {\n+                    boolean isStatic = (field.getModifiers() & Modifier.STATIC) != 0;\n+                    boolean isWeak = field.getDeclaringClass().equals(WeakPointHolder.class);\n+                    Object holder = null;\n+                    if (!isStatic) {\n+                        holder = isWeak ? new WeakPointHolder() : new StrongPointHolder();\n+                    }\n+                    BiFunction<Integer, Integer, Object> factory = isWeak ?\n+                            (i1, i2) -> new WeakPoint(i1, i2) :\n+                            (i1, i2) -> new StrongPoint(i1, i2);\n+                    boolean allowsNonPlainAccess = (field.getModifiers() & Modifier.VOLATILE) != 0 ||\n+                            !(ValueClass.checkedType(field) instanceof NullRestrictedCheckedType) ||\n+                            !isWeak;\n+                    arguments.add(Arguments.of(accessMode, holder, factory, field, allowsNonPlainAccess));\n+                }\n+            }\n+            return arguments;\n+        } catch (ReflectiveOperationException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    \/*\n+     * Verify that atomic access modes are not supported on flat fields.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"fieldAccessProvider\")\n+    public void testFieldAccess(AccessMode accessMode, Object holder, BiFunction<Integer, Integer, Object> factory,\n+                                Field field, boolean allowsNonPlainAccess) throws Throwable {\n+        VarHandle varHandle = MethodHandles.lookup().unreflectVarHandle(field);\n+        if (varHandle.isAccessModeSupported(accessMode)) {\n+            assertTrue(isPlain(accessMode) || (allowsNonPlainAccess && !isBitwise(accessMode) && !isNumeric(accessMode)));\n+            MethodHandle methodHandle = varHandle.toMethodHandle(accessMode);\n+            List<Object> arguments = new ArrayList<>();\n+            if (holder != null) {\n+                arguments.add(holder); \/\/ receiver\n+            }\n+            for (int i = arguments.size(); i < methodHandle.type().parameterCount(); i++) {\n+                arguments.add(factory.apply(i, i)); \/\/ add extra setter param\n+            }\n+            methodHandle.invokeWithArguments(arguments.toArray());\n+        } else {\n+            assertTrue(!allowsNonPlainAccess || isBitwise(accessMode) || isNumeric(accessMode));\n+        }\n+    }\n+\n+    private static List<Arguments> arrayAccessProvider() {\n+        List<Object[]> arrayObjects = List.of(\n+                WeakPoint.makePoints(10, ValueClass::newNullableAtomicArray),\n+                WeakPoint.makePoints(10, ValueClass::newNullRestrictedArray),\n+                WeakPoint.makePoints(10, ValueClass::newNullRestrictedAtomicArray),\n+                new WeakPoint[10],\n+                StrongPoint.makePoints(10, ValueClass::newNullableAtomicArray),\n+                StrongPoint.makePoints(10, ValueClass::newNullRestrictedArray),\n+                StrongPoint.makePoints(10, ValueClass::newNullRestrictedAtomicArray),\n+                new StrongPoint[10]);\n+\n+        List<Arguments> arguments = new ArrayList<>();\n+        for (AccessMode accessMode : AccessMode.values()) {\n+            if (accessMode.ordinal() != 2) continue;\n+            for (Object[] arrayObject : arrayObjects) {\n+                boolean isWeak = arrayObject.getClass().getComponentType().equals(WeakPoint.class);\n+                List<Class<?>> arrayTypes = List.of(\n+                        isWeak ? WeakPoint[].class : StrongPoint[].class, Pointable[].class, Object[].class);\n+                for (Class<?> arrayType : arrayTypes) {\n+                    BiFunction<Integer, Integer, Object> factory = isWeak ?\n+                            (i1, i2) -> new WeakPoint(i1, i2) :\n+                            (i1, i2) -> new StrongPoint((short)(int)i1, (short)(int)i2);\n+                    boolean allowsNonPlainAccess = !ValueClass.isNullRestrictedArray(arrayObject) ||\n+                            ValueClass.isAtomicArray(arrayObject) ||\n+                            !isWeak;\n+                    arguments.add(Arguments.of(accessMode, arrayObject, factory, arrayType, allowsNonPlainAccess));\n+                }\n+            }\n+        }\n+        return arguments;\n+    }\n+\n+    \/*\n+     * Verify that atomic access modes are not supported on flat array instances.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arrayAccessProvider\")\n+    public void testArrayAccess(AccessMode accessMode, Object[] arrayObject, BiFunction<Integer, Integer, Object> factory,\n+                                Class<?> arrayType, boolean allowsNonPlainAccess) throws Throwable {\n+        VarHandle varHandle = MethodHandles.arrayElementVarHandle(arrayType);\n+        if (varHandle.isAccessModeSupported(accessMode)) {\n+            assertTrue(!isBitwise(accessMode) && !isNumeric(accessMode));\n+            MethodHandle methodHandle = varHandle.toMethodHandle(accessMode);\n+            List<Object> arguments = new ArrayList<>();\n+            arguments.add(arrayObject); \/\/ array receiver\n+            arguments.add(0); \/\/ index\n+            for (int i = 2; i < methodHandle.type().parameterCount(); i++) {\n+                arguments.add(factory.apply(i, i)); \/\/ add extra setter param\n+            }\n+            try {\n+                methodHandle.invokeWithArguments(arguments.toArray());\n+            } catch (IllegalArgumentException ex) {\n+                assertFalse(allowsNonPlainAccess);\n+            }\n+        } else {\n+            assertTrue(isBitwise(accessMode) || isNumeric(accessMode));\n+        }\n+    }\n+\n+    boolean isBitwise(AccessMode accessMode) {\n+        return switch (accessMode) {\n+            case GET_AND_BITWISE_AND, GET_AND_BITWISE_AND_ACQUIRE,\n+                 GET_AND_BITWISE_AND_RELEASE, GET_AND_BITWISE_OR,\n+                 GET_AND_BITWISE_OR_ACQUIRE, GET_AND_BITWISE_OR_RELEASE,\n+                 GET_AND_BITWISE_XOR, GET_AND_BITWISE_XOR_ACQUIRE,\n+                 GET_AND_BITWISE_XOR_RELEASE -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    boolean isNumeric(AccessMode accessMode) {\n+        return switch (accessMode) {\n+            case GET_AND_ADD, GET_AND_ADD_ACQUIRE, GET_AND_ADD_RELEASE -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    boolean isPlain(AccessMode accessMode) {\n+        return switch (accessMode) {\n+            case GET, SET -> true;\n+            default -> false;\n+        };\n+    }\n+}\n","filename":"test\/jdk\/valhalla\/valuetypes\/FlatVarHandleTest.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -28,2 +28,1 @@\n- * @run junit\/othervm NullRestrictedArraysTest\n- * @run junit\/othervm -XX:-UseArrayFlattening NullRestrictedArraysTest\n+ * @run junit\/othervm -XX:+UseArrayFlattening -XX:+UseNullableValueFlattening NullRestrictedArraysTest\n@@ -43,0 +42,1 @@\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n@@ -57,0 +57,1 @@\n+    @LooselyConsistentValue\n@@ -174,4 +175,4 @@\n-        testVarHandleArray(array, Value[].class);\n-        testVarHandleArray(array, I[].class);\n-        testVarHandleNullRestrictedArray(nullRestrictedArray, Value[].class);\n-        testVarHandleNullRestrictedArray(nullRestrictedArray, I[].class);\n+        testVarHandleArray(array, Value[].class, false);\n+        testVarHandleArray(array, I[].class, false);\n+        testVarHandleArray(nullRestrictedArray, Value[].class, true);\n+        testVarHandleArray(nullRestrictedArray, I[].class, true);\n@@ -180,1 +181,1 @@\n-    private void testVarHandleArray(Object[] array, Class<?> arrayClass) {\n+    private void testVarHandleArray(Object[] array, Class<?> arrayClass, boolean isNullRestricted) {\n@@ -188,0 +189,1 @@\n+        Value value2 =  new Value(2);\n@@ -193,14 +195,0 @@\n-        vh.set(array, 0, null);\n-        vh.setVolatile(array, 0, null);\n-        vh.setOpaque(array, 0, null);\n-        vh.setRelease(array, 0, null);\n-\n-        vh.compareAndSet(array, 1, value1, null);             vh.set(array, 1, value1);\n-        vh.compareAndExchange(array, 1, value1, null);        vh.set(array, 1, value1);\n-        vh.compareAndExchangeAcquire(array, 1, value1, null); vh.set(array, 1, value1);\n-        vh.compareAndExchangeRelease(array, 1, value1, null); vh.set(array, 1, value1);\n-        vh.weakCompareAndSet(array, 1, value1, null);         vh.set(array, 1, value1);\n-        vh.weakCompareAndSetAcquire(array, 1, value1, null);  vh.set(array, 1, value1);\n-        vh.weakCompareAndSetPlain(array, 1, value1, null);    vh.set(array, 1, value1);\n-        vh.weakCompareAndSetRelease(array, 1, value1, null);  vh.set(array, 1, value1);\n-    }\n@@ -208,3 +196,61 @@\n-    private void testVarHandleNullRestrictedArray(Object[] array, Class<?> arrayClass) {\n-        for (int i=0; i < array.length; i++) {\n-            array[i] = new Value(i);\n+        \/\/ test set with null values\n+\n+        if (!isNullRestricted) {\n+            \/\/ if not null-restricted, we expect these set operations to succeed\n+\n+            vh.set(array, 0, null);\n+            assertNull(vh.get(array, 0));\n+            vh.setVolatile(array, 0, null);\n+            assertNull(vh.get(array, 0));\n+            vh.setOpaque(array, 0, null);\n+            assertNull(vh.get(array, 0));\n+            vh.setRelease(array, 0, null);\n+            assertNull(vh.get(array, 0));\n+\n+            assertTrue(vh.compareAndSet(array, 1, value1, null));\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+\n+            assertEquals(vh.compareAndExchange(array, 1, value1, null), value1);\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+\n+            assertEquals(vh.compareAndExchangeAcquire(array, 1, value1, null), value1);\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+\n+            assertEquals(vh.compareAndExchangeRelease(array, 1, value1, null), value1);\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+\n+            assertTrue(vh.weakCompareAndSet(array, 1, value1, null));\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+\n+            assertTrue(vh.weakCompareAndSetAcquire(array, 1, value1, null));\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+\n+            assertTrue(vh.weakCompareAndSetPlain(array, 1, value1, null));\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+\n+            assertTrue(vh.weakCompareAndSetRelease(array, 1, value1, null));\n+            assertNull(vh.get(array, 0));\n+            vh.set(array, 1, value1);\n+        } else {\n+            \/\/ if null-restricted, we expect these set operations to fail\n+\n+            assertThrows(NullPointerException.class, () -> vh.set(array, 0, null));\n+            assertThrows(NullPointerException.class, () -> vh.setVolatile(array, 0, null));\n+            assertThrows(NullPointerException.class, () -> vh.setOpaque(array, 0, null));\n+            assertThrows(NullPointerException.class, () -> vh.setRelease(array, 0, null));\n+\n+            assertThrows(NullPointerException.class, () -> vh.compareAndSet(array, 1, value1, null));\n+            assertThrows(NullPointerException.class, () -> vh.compareAndExchange(array, 1, value1, null));\n+            assertThrows(NullPointerException.class, () -> vh.compareAndExchangeAcquire(array, 1, value1, null));\n+            assertThrows(NullPointerException.class, () -> vh.compareAndExchangeRelease(array, 1, value1, null));\n+            assertThrows(NullPointerException.class, () -> vh.weakCompareAndSet(array, 1, value1, null));\n+            assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetAcquire(array, 1, value1, null));\n+            assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetPlain(array, 1, value1, null));\n+            assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetRelease(array, 1, value1, null));\n@@ -213,21 +259,38 @@\n-        VarHandle vh = MethodHandles.arrayElementVarHandle(arrayClass);\n-        Value value = new Value(0);\n-        Value value1 =  new Value(1);\n-        assertTrue(vh.get(array, 0) == value);\n-        assertTrue(vh.getVolatile(array, 0) == value);\n-        assertTrue(vh.getOpaque(array, 0) == value);\n-        assertTrue(vh.getAcquire(array, 0) == value);\n-        assertThrows(NullPointerException.class, () -> vh.set(array, 0, null));\n-        assertThrows(NullPointerException.class, () -> vh.setVolatile(array, 0, null));\n-        assertThrows(NullPointerException.class, () -> vh.setOpaque(array, 0, null));\n-        assertThrows(NullPointerException.class, () -> vh.setRelease(array, 0, null));\n-\n-        assertThrows(NullPointerException.class, () -> vh.compareAndSet(array, 1, value1, null));\n-        assertThrows(NullPointerException.class, () -> vh.compareAndExchange(array, 1, value1, null));\n-        assertThrows(NullPointerException.class, () -> vh.compareAndExchangeAcquire(array, 1, value1, null));\n-        assertThrows(NullPointerException.class, () -> vh.compareAndExchangeRelease(array, 1, value1, null));\n-        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSet(array, 1, value1, null));\n-        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetAcquire(array, 1, value1, null));\n-        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetPlain(array, 1, value1, null));\n-        assertThrows(NullPointerException.class, () -> vh.weakCompareAndSetRelease(array, 1, value1, null));\n-    }\n+        \/\/ test set with non-null values\n+\n+        vh.set(array, 0, value1);\n+        assertEquals(vh.get(array, 0), value1);\n+        vh.setVolatile(array, 0, value1);\n+        assertEquals(vh.get(array, 0), value1);\n+        vh.setOpaque(array, 0, value1);\n+        assertEquals(vh.get(array, 0), value1);\n+        vh.setRelease(array, 0, value1);\n+        assertEquals(vh.get(array, 0), value1);\n+\n+        assertTrue(vh.compareAndSet(array, 1, value1, value2));\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n+\n+        assertEquals(vh.compareAndExchange(array, 1, value1, value2), value1);\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n+\n+        assertEquals(vh.compareAndExchangeAcquire(array, 1, value1, value2), value1);\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n+\n+        assertEquals(vh.compareAndExchangeRelease(array, 1, value1, value2), value1);\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n+\n+        assertTrue(vh.weakCompareAndSet(array, 1, value1, value2));\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n+\n+        assertTrue(vh.weakCompareAndSetAcquire(array, 1, value1, value2));\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n+\n+        assertTrue(vh.weakCompareAndSetPlain(array, 1, value1, value2));\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n@@ -235,0 +298,30 @@\n+        assertTrue(vh.weakCompareAndSetRelease(array, 1, value1, value2));\n+        assertEquals(vh.get(array, 1), value2);\n+        vh.set(array, 1, value1);\n+\n+        \/\/ test atomic set with null witness\n+\n+        assertFalse(vh.compareAndSet(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+\n+        assertNotNull(vh.compareAndExchange(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+\n+        assertNotNull(vh.compareAndExchangeAcquire(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+\n+        assertNotNull(vh.compareAndExchangeRelease(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+\n+        assertFalse(vh.weakCompareAndSet(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+\n+        assertFalse(vh.weakCompareAndSetAcquire(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+\n+        assertFalse(vh.weakCompareAndSetPlain(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+\n+        assertFalse(vh.weakCompareAndSetRelease(array, 2, null, value1));\n+        assertEquals(vh.get(array, 2), value2);\n+    }\n","filename":"test\/jdk\/valhalla\/valuetypes\/NullRestrictedArraysTest.java","additions":138,"deletions":45,"binary":false,"changes":183,"status":"modified"}]}