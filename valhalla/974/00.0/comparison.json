{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -6250,1 +6251,1 @@\n-void Assembler::testb(Register dst, int imm8) {\n+void Assembler::testb(Register dst, int imm8, bool use_ral) {\n@@ -6253,2 +6254,8 @@\n-    emit_int8((unsigned char)0xA8);\n-    emit_int8(imm8);\n+    if (use_ral) {\n+      emit_int8((unsigned char)0xA8);\n+      emit_int8(imm8);\n+    } else {\n+      emit_int8((unsigned char)0xF6);\n+      emit_int8((unsigned char)0xC4);\n+      emit_int8(imm8);\n+    }\n@@ -11001,0 +11008,30 @@\n+void Assembler::fld_d(Address adr) {\n+  InstructionMark im(this);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand32(rax, adr, 0);\n+}\n+\n+void Assembler::fprem() {\n+  emit_int16((unsigned char)0xD9, (unsigned char)0xF8);\n+}\n+\n+void Assembler::fnstsw_ax() {\n+  emit_int16((unsigned char)0xDF, (unsigned char)0xE0);\n+}\n+\n+void Assembler::fstp_d(Address adr) {\n+  InstructionMark im(this);\n+  emit_int8((unsigned char)0xDD);\n+  emit_operand32(rbx, adr, 0);\n+}\n+\n+void Assembler::fstp_d(int index) {\n+  emit_farith(0xDD, 0xD8, index);\n+}\n+\n+void Assembler::emit_farith(int b1, int b2, int i) {\n+  assert(isByte(b1) && isByte(b2), \"wrong opcode\");\n+  assert(0 <= i &&  i < 8, \"illegal stack offset\");\n+  emit_int16(b1, b2 + i);\n+}\n+\n@@ -11044,6 +11081,0 @@\n-void Assembler::emit_farith(int b1, int b2, int i) {\n-  assert(isByte(b1) && isByte(b2), \"wrong opcode\");\n-  assert(0 <= i &&  i < 8, \"illegal stack offset\");\n-  emit_int16(b1, b2 + i);\n-}\n-\n@@ -11211,6 +11242,0 @@\n-void Assembler::fld_d(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDD);\n-  emit_operand32(rax, adr, 0);\n-}\n-\n@@ -11300,8 +11325,0 @@\n-void Assembler::fnstsw_ax() {\n-  emit_int16((unsigned char)0xDF, (unsigned char)0xE0);\n-}\n-\n-void Assembler::fprem() {\n-  emit_int16((unsigned char)0xD9, (unsigned char)0xF8);\n-}\n-\n@@ -11338,10 +11355,0 @@\n-void Assembler::fstp_d(Address adr) {\n-  InstructionMark im(this);\n-  emit_int8((unsigned char)0xDD);\n-  emit_operand32(rbx, adr, 0);\n-}\n-\n-void Assembler::fstp_d(int index) {\n-  emit_farith(0xDD, 0xD8, index);\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":40,"deletions":33,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -1248,1 +1249,6 @@\n-#ifndef _LP64\n+  void fnstsw_ax();\n+  void fprem();\n+  void fld_d(Address adr);\n+  void fstp_d(Address adr);\n+  void fstp_d(int index);\n+\n@@ -1254,0 +1260,1 @@\n+#ifndef _LP64\n@@ -1312,1 +1319,0 @@\n-  void fld_d(Address adr);\n@@ -1341,4 +1347,0 @@\n-\n-  void fnstsw_ax();\n-\n-  void fprem();\n@@ -1356,2 +1358,0 @@\n-  void fstp_d(Address adr);\n-  void fstp_d(int index);\n@@ -2190,1 +2190,1 @@\n-  void testb(Register dst, int imm8);\n+  void testb(Register dst, int imm8, bool use_ral = true);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-\/\/ Windows ABI: XMM6-XMM31 preserved across function calls\n+\/\/ Windows ABI: XMM6-XMM15 preserved across function calls\n@@ -1257,2 +1257,12 @@\n-    Flag_intel_jcc_erratum = Node::_last_flag << 1,\n-    _last_flag             = Flag_intel_jcc_erratum\n+    Flag_intel_jcc_erratum    = Node::_last_flag << 1,\n+    Flag_sets_carry_flag      = Node::_last_flag << 2,\n+    Flag_sets_parity_flag     = Node::_last_flag << 3,\n+    Flag_sets_zero_flag       = Node::_last_flag << 4,\n+    Flag_sets_overflow_flag   = Node::_last_flag << 5,\n+    Flag_sets_sign_flag       = Node::_last_flag << 6,\n+    Flag_clears_carry_flag    = Node::_last_flag << 7,\n+    Flag_clears_parity_flag   = Node::_last_flag << 8,\n+    Flag_clears_zero_flag     = Node::_last_flag << 9,\n+    Flag_clears_overflow_flag = Node::_last_flag << 10,\n+    Flag_clears_sign_flag     = Node::_last_flag << 11,\n+    _last_flag                = Flag_clears_sign_flag\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+      _flag                 = nullptr;\n@@ -89,0 +90,1 @@\n+      _flag                  = instr->_flag;\n@@ -1897,0 +1899,28 @@\n+\/\/---------------------------------Flag----------------------------------------\n+Flag::Flag(const char *name) : _name(name), _next(nullptr) {\n+  _ftype = Form::FLG;\n+}\n+\n+Flag::~Flag() {\n+}\n+\n+void Flag::append_flag(Flag *next_flag) {\n+  if( _next == nullptr ) {\n+    _next = next_flag;\n+  } else {\n+    _next->append_flag( next_flag );\n+  }\n+}\n+\n+Flag* Flag::next() {\n+  return _next;\n+}\n+\n+void Flag::dump() {\n+  output(stderr);\n+}\n+\n+void Flag::output(FILE *fp) {          \/\/ Write info to output files\n+  fprintf(fp,\"Flag: %s\\n\", (_name?_name:\"\"));\n+}\n+\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -159,1 +159,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -286,3 +286,0 @@\n-  static ClassLoaderData* _saved_java_platform_loader_data;\n-  static ClassLoaderData* _saved_java_system_loader_data;\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -875,1 +876,0 @@\n-                                       bool* const is_declared_atomic,\n@@ -992,0 +992,3 @@\n+    _jdk_internal_ImplicitlyConstructible,\n+    _jdk_internal_LooselyConsistentValue,\n+    _jdk_internal_NullRestricted,\n@@ -1545,0 +1548,2 @@\n+    bool is_null_restricted = false;\n+\n@@ -1564,0 +1569,10 @@\n+        if (parsed_annotations.has_annotation(AnnotationCollector::_jdk_internal_NullRestricted)) {\n+          if (!Signature::has_envelope(sig)) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s with signature %s (primitive types can never be null)\",\n+              name->as_C_string(), sig->as_C_string());\n+          }\n+          is_null_restricted = true;\n+        }\n@@ -1595,1 +1610,1 @@\n-    if (type == T_PRIMITIVE_OBJECT) fieldFlags.update_null_free_inline_type(true);\n+    if (type == T_PRIMITIVE_OBJECT || is_null_restricted) fieldFlags.update_null_free_inline_type(true);\n@@ -2069,0 +2084,12 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ImplicitlyConstructible_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_ImplicitlyConstructible;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_LooselyConsistentValue_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_LooselyConsistentValue;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NullRestricted_signature): {\n+      if (_location != _in_field)   break; \/\/ only allow for fields\n+      return _jdk_internal_NullRestricted;\n+    }\n@@ -4609,0 +4636,1 @@\n+        return;\n@@ -4616,0 +4644,1 @@\n+        return;\n@@ -5078,0 +5107,10 @@\n+bool ClassFileParser::is_class_in_preload_attribute(Symbol *klass) {\n+  if (_preload_classes == nullptr) return false;\n+  for (int i = 0; i < _preload_classes->length(); i++) {\n+        \/\/ if (_cp->tag_at(_preload_classes->at(i)).is_klass()) continue;\n+        Symbol* class_name = _cp->klass_at_noresolve(_preload_classes->at(i));\n+        if (class_name == klass) return true;\n+  }\n+  return false;\n+}\n+\n@@ -5679,3 +5718,6 @@\n-  if (_is_declared_atomic) {\n-    ik->set_is_declared_atomic();\n-  }\n+  if (_must_be_atomic) {\n+    ik->set_must_be_atomic();\n+  }\n+  if (_is_implicitly_constructible) {\n+    ik->set_is_implicitly_constructible();\n+  }\n@@ -5955,1 +5997,2 @@\n-  _is_declared_atomic(false),\n+  _must_be_atomic(true),\n+  _is_implicitly_constructible(false),\n@@ -5958,0 +6001,2 @@\n+  _has_loosely_consistent_annotation(false),\n+  _has_implicitly_constructible_annotation(false),\n@@ -6283,1 +6328,0 @@\n-                   &_is_declared_atomic,\n@@ -6422,2 +6466,13 @@\n-    if (_super_klass->is_declared_atomic()) {\n-      _is_declared_atomic = true;\n+\n+    if (EnableValhalla && _access_flags.is_value_class()) {\n+      const InstanceKlass* k = _super_klass;\n+      int inherited_instance_fields = 0;\n+      while (k != nullptr) {\n+        for (AllFieldStream fs(k); !fs.done(); fs.next()) {\n+          if (!fs.access_flags().is_static()) inherited_instance_fields++;\n+        }\n+        k = k->super() == nullptr ? nullptr :  InstanceKlass::cast(k->super());\n+      }\n+      if (inherited_instance_fields > 0) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Value classes don't support inherited non-static fields yet\");\n+      }\n@@ -6427,5 +6482,34 @@\n-  if (*ForceNonTearable != '\\0') {\n-    \/\/ Allow a command line switch to force the same atomicity property:\n-    const char* class_name_str = _class_name->as_C_string();\n-    if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n-      _is_declared_atomic = true;\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && !_access_flags.is_value_class()) {\n+    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n+          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.LooselyConsistentValue, because it is not a value class\",\n+                  _class_name->as_klass_external_name()));\n+  }\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_ImplicitlyConstructible) && !_access_flags.is_value_class()) {\n+    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n+          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.ImplicitlyConstructible, because it is not a value class\",\n+                  _class_name->as_klass_external_name()));\n+  }\n+\n+  \/\/ Determining is the class allows tearing or not (default is not)\n+  \/\/ Test might need extensions when field inheritance is added for value classes\n+  if (EnableValhalla && _access_flags.is_value_class()) {\n+    if (_access_flags.is_primitive_class()) {\n+      _must_be_atomic = false;             \/\/ old semantic, primitive classes are always non-atomic\n+      _is_implicitly_constructible = true; \/\/ old semantic, primitive classes are always implicitly constructible\n+    } else {\n+      if (_super_klass != nullptr  \/\/ not j.l.Object\n+               && _parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+               && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+        _must_be_atomic = false;\n+      }\n+      if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_ImplicitlyConstructible)) {\n+        _is_implicitly_constructible = true;\n+      }\n+    }\n+    \/\/ Apply VM options override\n+    if (*ForceNonTearable != '\\0') {\n+      \/\/ Allow a command line switch to force the same atomicity property:\n+      const char* class_name_str = _class_name->as_C_string();\n+      if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+        _must_be_atomic = true;\n+      }\n@@ -6477,3 +6561,0 @@\n-      if (InstanceKlass::cast(interf)->is_declared_atomic()) {\n-        _is_declared_atomic = true;\n-      }\n@@ -6518,2 +6599,1 @@\n-\n-  if (EnablePrimitiveClasses) {\n+  if (EnableValhalla) {\n@@ -6527,2 +6607,1 @@\n-\n-        \/\/ Pre-load inline class\n+        \/\/ Pre-load classes of fields that are candidate for flattening\n@@ -6537,4 +6616,4 @@\n-            THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                      err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n-                      _class_name->as_C_string(),\n-                      InstanceKlass::cast(klass)->external_name()));\n+          THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                    err_msg(\"Class %s expects class %s to be an inline type, but it is not\",\n+                    _class_name->as_C_string(),\n+                    InstanceKlass::cast(klass)->external_name()));\n@@ -6543,0 +6622,19 @@\n+      } else {\n+        if (sig != _class_name && is_class_in_preload_attribute(sig)) {\n+          oop loader = loader_data()->class_loader();\n+          Klass* klass = SystemDictionary::resolve_or_null(sig, Handle(THREAD, loader), _protection_domain, THREAD);\n+          if (HAS_PENDING_EXCEPTION) {\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+          \/\/ Should we verify that klass is a value class? What the PreLoad attribute spec says about that?\n+          if (klass != nullptr) {\n+            if (klass->is_inline_klass()) {\n+              _inline_type_field_klasses->at_put(fieldinfo.index(), InlineKlass::cast(klass));\n+              log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute\", sig->as_C_string(), _class_name->as_C_string());\n+            } else {\n+              log_info(class, preload)(\"Preloading class %s during linking of class %s because of its Preload attribute but loaded class is not a value class\", sig->as_C_string(), _class_name->as_C_string());\n+            }\n+          } else {\n+            log_warning(class, preload)(\"Preloading of class %s during linking of class %s (Preload attribute) failed\", sig->as_C_string(), _class_name->as_C_string());\n+          }\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":123,"deletions":25,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -210,1 +210,2 @@\n-  bool _is_declared_atomic;\n+  bool _must_be_atomic;\n+  bool _is_implicitly_constructible;\n@@ -213,0 +214,2 @@\n+  bool _has_loosely_consistent_annotation;\n+  bool _has_implicitly_constructible_annotation;\n@@ -265,1 +268,0 @@\n-                        bool* is_declared_atomic,\n@@ -626,0 +628,2 @@\n+  bool is_class_in_preload_attribute(Symbol *klass);\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+  do_klass(ClassFrameInfo_klass,                        java_lang_ClassFrameInfo                              ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -356,0 +356,8 @@\n+  do_intrinsic(_arraySort,                java_util_DualPivotQuicksort, arraySort_name, arraySort_signature,     F_S)   \\\n+   do_name(     arraySort_name,                                  \"sort\")                                                \\\n+   do_signature(arraySort_signature, \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIILjava\/util\/DualPivotQuicksort$SortOperation;)V\") \\\n+                                                                                                                        \\\n+  do_intrinsic(_arrayPartition,           java_util_DualPivotQuicksort, arrayPartition_name, arrayPartition_signature, F_S) \\\n+   do_name(     arrayPartition_name,                             \"partition\")                                           \\\n+   do_signature(arrayPartition_signature, \"(Ljava\/lang\/Class;Ljava\/lang\/Object;JIIIILjava\/util\/DualPivotQuicksort$PartitionOperation;)[I\") \\\n+                                                                                                                        \\\n@@ -627,0 +635,2 @@\n+  do_intrinsic(_isFlattenedArray,         jdk_internal_misc_Unsafe,     isFlattenedArray_name, class_boolean_signature, F_RN)    \\\n+   do_name(     isFlattenedArray_name,                                  \"isFlattenedArray\")                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+  template(java_util_DualPivotQuicksort,              \"java\/util\/DualPivotQuicksort\")             \\\n@@ -271,0 +272,3 @@\n+  template(jdk_internal_vm_annotation_ImplicitlyConstructible_signature,     \"Ljdk\/internal\/vm\/annotation\/ImplicitlyConstructible;\") \\\n+  template(jdk_internal_vm_annotation_LooselyConsistentValue_signature,      \"Ljdk\/internal\/vm\/annotation\/LooselyConsistentValue;\") \\\n+  template(jdk_internal_vm_annotation_NullRestricted_signature,              \"Ljdk\/internal\/vm\/annotation\/NullRestricted;\") \\\n@@ -303,1 +307,0 @@\n-  template(trusted_final_name,                        \"trustedFinal\")                             \\\n@@ -384,0 +387,1 @@\n+  template(java_lang_ClassFrameInfo,                  \"java\/lang\/ClassFrameInfo\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+        } else if (!should_rebuild_or_scrub(hr)) {\n@@ -132,1 +132,1 @@\n-          \/\/ have been reclaimed during the yield.\n+          \/\/ have been reclaimed during above yield\/safepoint.\n@@ -199,2 +199,3 @@\n-        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n-          \/\/ Region has been reclaimed while yielding. Exit continuing with the next region.\n+        } else if (!should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during above yield\/safepoint.\n@@ -219,1 +220,3 @@\n-        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+        } else if (!should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during above yield\/safepoint.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  if (is_declared_atomic() && !is_naturally_atomic()) {\n+  if (must_be_atomic() && !is_naturally_atomic()) {\n@@ -228,2 +228,2 @@\n-\/\/ The list of basic types that is returned starts with a T_PRIMITIVE_OBJECT\n-\/\/ and ends with an extra T_VOID. T_PRIMITIVE_OBJECT\/T_VOID pairs are used as\n+\/\/ The list of basic types that is returned starts with a T_METADATA\n+\/\/ and ends with an extra T_VOID. T_METADATA\/T_VOID pairs are used as\n@@ -232,1 +232,1 @@\n-\/\/ with a T_PRIMITIVE_OBJECT and ends with a T_VOID. This is so we can\n+\/\/ with a T_METADATA and ends with a T_VOID. This is so we can\n@@ -236,1 +236,1 @@\n-\/\/ T_PRIMITIVE_OBJECT, drop everything until and including the closing\n+\/\/ T_METADATA, drop everything until and including the closing\n@@ -238,1 +238,1 @@\n-\/\/ types is an argument: drop all T_PRIMITIVE_OBJECT\/T_VOID from the list).\n+\/\/ types is an argument: drop all T_METADATA\/T_VOID from the list).\n@@ -241,1 +241,1 @@\n-  SigEntry::add_entry(sig, T_PRIMITIVE_OBJECT, name(), base_off);\n+  SigEntry::add_entry(sig, T_METADATA, name(), base_off);\n@@ -263,1 +263,1 @@\n-  assert(sig->at(0)._bt == T_PRIMITIVE_OBJECT && sig->at(sig->length()-1)._bt == T_VOID, \"broken structure\");\n+  assert(sig->at(0)._bt == T_METADATA && sig->at(sig->length()-1)._bt == T_VOID, \"broken structure\");\n@@ -363,1 +363,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n@@ -391,1 +391,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n@@ -415,1 +415,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-\/\/ Add 2 half-precision floats\n+\/\/ Add 2 floats\n@@ -135,1 +135,1 @@\n-\/\/ Add 2 floats\n+\/\/ Add 2 half-precision floats\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -58,0 +59,3 @@\n+const char* C2Compiler::retry_no_superword() {\n+  return \"retry without SuperWord\";\n+}\n@@ -109,0 +113,2 @@\n+  CompilationMemoryStatisticMark cmsm(directive);\n+\n@@ -115,0 +121,1 @@\n+  bool do_superword = UseSuperWord;\n@@ -117,0 +124,1 @@\n+    ResourceMark rm;\n@@ -118,1 +126,8 @@\n-    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, do_reduce_allocation_merges, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads,\n+                    do_escape_analysis,\n+                    do_iterative_escape_analysis,\n+                    do_reduce_allocation_merges,\n+                    eliminate_boxing,\n+                    do_locks_coarsening,\n+                    do_superword,\n+                    install_code);\n@@ -153,0 +168,6 @@\n+      if (C.failure_reason_is(retry_no_superword())) {\n+        assert(do_superword, \"must make progress\");\n+        do_superword = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -576,0 +597,3 @@\n+  case vmIntrinsics::_sum_float16:\n+    if (!Matcher::match_rule_supported(Op_AddHF)) return false;\n+    break;\n@@ -600,0 +624,2 @@\n+  case vmIntrinsics::_arraySort:\n+  case vmIntrinsics::_arrayPartition:\n@@ -714,0 +740,1 @@\n+  case vmIntrinsics::_isFlattenedArray:\n@@ -777,3 +804,0 @@\n-  case vmIntrinsics::_sum_float16:\n-    if (!Matcher::match_rule_supported(Op_AddHF)) return false;\n-    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -98,0 +99,49 @@\n+uint ConvertNode::ideal_reg() const {\n+  return _type->ideal_reg();\n+}\n+\n+Node* ConvertNode::create_convert(BasicType source, BasicType target, Node* input) {\n+  if (source == T_INT) {\n+    if (target == T_LONG) {\n+      return new ConvI2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvI2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvI2DNode(input);\n+    }\n+  } else if (source == T_LONG) {\n+    if (target == T_INT) {\n+      return new ConvL2INode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvL2FNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvL2DNode(input);\n+    }\n+  } else if (source == T_FLOAT) {\n+    if (target == T_INT) {\n+      return new ConvF2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvF2LNode(input);\n+    } else if (target == T_DOUBLE) {\n+      return new ConvF2DNode(input);\n+    } else if (target == T_SHORT) {\n+      return new ConvF2HFNode(input);\n+    }\n+  } else if (source == T_DOUBLE) {\n+    if (target == T_INT) {\n+      return new ConvD2INode(input);\n+    } else if (target == T_LONG) {\n+      return new ConvD2LNode(input);\n+    } else if (target == T_FLOAT) {\n+      return new ConvD2FNode(input);\n+    }\n+  } else if (source == T_SHORT) {\n+    if (target == T_FLOAT) {\n+      return new ConvHF2FNode(input);\n+    }\n+  }\n+\n+  assert(false, \"Couldn't create conversion for type %s to %s\", type2name(source), type2name(target));\n+  return nullptr;\n+}\n+\n@@ -202,2 +252,3 @@\n-  if (t == Type::FLOAT) return TypeInt::SHORT;\n-  if (StubRoutines::f2hf_adr() == nullptr) return bottom_type();\n+  if (t == Type::FLOAT || StubRoutines::f2hf_adr() == nullptr) {\n+    return TypeInt::SHORT;\n+  }\n@@ -272,2 +323,3 @@\n-  if (t == TypeInt::SHORT) return Type::FLOAT;\n-  if (StubRoutines::hf2f_adr() == nullptr) return bottom_type();\n+  if (t == TypeInt::SHORT || StubRoutines::hf2f_adr() == nullptr) {\n+    return Type::FLOAT;\n+  }\n@@ -279,1 +331,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -289,1 +341,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -299,1 +351,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n@@ -719,1 +771,1 @@\n-  return bottom_type();\n+  return Type::DOUBLE;\n@@ -729,1 +781,1 @@\n-  return bottom_type();\n+  return Type::FLOAT;\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":61,"deletions":9,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -45,0 +45,15 @@\n+class ConvertNode : public TypeNode {\n+protected:\n+  ConvertNode(const Type* t, Node* input) : TypeNode(t, 2) {\n+    init_class_id(Class_Convert);\n+    init_req(1, input);\n+  }\n+public:\n+  virtual const Type* in_type() const = 0;\n+  virtual uint ideal_reg() const;\n+\n+  \/\/ Create a convert node for a given input and output type.\n+  \/\/ Conversions to and from half float are specified via T_SHORT.\n+  static Node* create_convert(BasicType source, BasicType target, Node* input);\n+};\n+\n@@ -48,1 +63,1 @@\n-class ConvD2FNode : public Node {\n+class ConvD2FNode : public ConvertNode {\n@@ -50,1 +65,1 @@\n-  ConvD2FNode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2FNode(Node* in1) : ConvertNode(Type::FLOAT,in1) {}\n@@ -52,1 +67,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -55,2 +70,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -61,1 +75,1 @@\n-class ConvD2INode : public Node {\n+class ConvD2INode : public ConvertNode {\n@@ -63,1 +77,1 @@\n-  ConvD2INode( Node *in1 ) : Node(0,in1) {}\n+  ConvD2INode(Node* in1) : ConvertNode(TypeInt::INT,in1) {}\n@@ -65,1 +79,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -68,2 +82,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -74,1 +87,1 @@\n-class ConvD2LNode : public Node {\n+class ConvD2LNode : public ConvertNode {\n@@ -76,1 +89,1 @@\n-  ConvD2LNode( Node *dbl ) : Node(0,dbl) {}\n+  ConvD2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -78,1 +91,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return Type::DOUBLE; }\n@@ -81,10 +94,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint ideal_reg() const { return Op_RegL; }\n-};\n-\n-class RoundDNode : public Node {\n-  public:\n-  RoundDNode( Node *dbl ) : Node(0,dbl) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n-  virtual uint ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -95,1 +99,1 @@\n-class ConvF2DNode : public Node {\n+class ConvF2DNode : public ConvertNode {\n@@ -97,1 +101,1 @@\n-  ConvF2DNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2DNode(Node* in1) : ConvertNode(Type::DOUBLE,in1) {}\n@@ -99,1 +103,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return Type::FLOAT; }\n@@ -101,1 +105,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -106,1 +109,1 @@\n-class ConvF2HFNode : public Node {\n+class ConvF2HFNode : public ConvertNode {\n@@ -108,1 +111,1 @@\n-  ConvF2HFNode( Node *in1 ) : Node(0,in1) {}\n+  ConvF2HFNode(Node* in1) : ConvertNode(TypeInt::SHORT, in1) {}\n@@ -110,1 +113,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::SHORT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -112,1 +115,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n@@ -117,3 +119,3 @@\n-class ConvF2INode : public Node {\n-  public:\n-  ConvF2INode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2INode : public ConvertNode {\n+public:\n+  ConvF2INode(Node* in1) : ConvertNode(TypeInt::INT, in1) {}\n@@ -121,1 +123,1 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -124,2 +126,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -128,1 +129,0 @@\n-\n@@ -131,3 +131,3 @@\n-class ConvF2LNode : public Node {\n-  public:\n-  ConvF2LNode( Node *in1 ) : Node(0,in1) {}\n+class ConvF2LNode : public ConvertNode {\n+public:\n+  ConvF2LNode(Node* in1) : ConvertNode(TypeLong::LONG, in1) {}\n@@ -135,1 +135,1 @@\n-  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual const Type* in_type() const { return TypeInt::FLOAT; }\n@@ -138,2 +138,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -144,3 +143,3 @@\n-class ConvHF2FNode : public Node {\n-  public:\n-  ConvHF2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvHF2FNode : public ConvertNode {\n+public:\n+  ConvHF2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -148,1 +147,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::SHORT; }\n@@ -150,1 +149,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -155,3 +153,3 @@\n-class ConvI2DNode : public Node {\n-  public:\n-  ConvI2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2DNode : public ConvertNode {\n+public:\n+  ConvI2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -159,1 +157,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -161,1 +159,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n@@ -166,3 +163,3 @@\n-class ConvI2FNode : public Node {\n-  public:\n-  ConvI2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvI2FNode : public ConvertNode {\n+public:\n+  ConvI2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -170,1 +167,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -173,1 +170,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -176,0 +172,2 @@\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Short to Half Float\n@@ -186,0 +184,2 @@\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Half Float to Short\n@@ -195,8 +195,0 @@\n-class RoundFNode : public Node {\n-  public:\n-  RoundFNode( Node *in1 ) : Node(0,in1) {}\n-  virtual int Opcode() const;\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n-  virtual uint  ideal_reg() const { return Op_RegI; }\n-};\n-\n@@ -205,1 +197,1 @@\n-class ConvI2LNode : public TypeNode {\n+class ConvI2LNode : public ConvertNode {\n@@ -207,3 +199,1 @@\n-  ConvI2LNode(Node *in1, const TypeLong* t = TypeLong::INT)\n-  : TypeNode(t, 2)\n-  { init_req(1, in1); }\n+  ConvI2LNode(Node* in1, const TypeLong* t = TypeLong::INT) : ConvertNode(t, in1) {}\n@@ -211,0 +201,1 @@\n+  virtual const Type* in_type() const { return TypeInt::INT; }\n@@ -212,1 +203,1 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -214,1 +205,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegL; }\n@@ -219,3 +209,3 @@\n-class ConvL2DNode : public Node {\n-  public:\n-  ConvL2DNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2DNode : public ConvertNode {\n+public:\n+  ConvL2DNode(Node* in1) : ConvertNode(Type::DOUBLE, in1) {}\n@@ -223,1 +213,1 @@\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -225,1 +215,0 @@\n-  virtual uint ideal_reg() const { return Op_RegD; }\n@@ -230,3 +219,3 @@\n-class ConvL2FNode : public Node {\n-  public:\n-  ConvL2FNode( Node *in1 ) : Node(0,in1) {}\n+class ConvL2FNode : public ConvertNode {\n+public:\n+  ConvL2FNode(Node* in1) : ConvertNode(Type::FLOAT, in1) {}\n@@ -234,1 +223,1 @@\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -236,1 +225,0 @@\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n@@ -241,1 +229,1 @@\n-class ConvL2INode : public TypeNode {\n+class ConvL2INode : public ConvertNode {\n@@ -243,4 +231,1 @@\n-  ConvL2INode(Node *in1, const TypeInt* t = TypeInt::INT)\n-  : TypeNode(t, 2) {\n-    init_req(1, in1);\n-  }\n+  ConvL2INode(Node* in1, const TypeInt* t = TypeInt::INT) : ConvertNode(t, in1) {}\n@@ -248,0 +233,1 @@\n+  virtual const Type* in_type() const { return TypeLong::LONG; }\n@@ -250,1 +236,16 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+};\n+\n+class RoundDNode : public Node {\n+public:\n+  RoundDNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n+class RoundFNode : public Node {\n+public:\n+  RoundFNode(Node* in1) : Node(nullptr, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":90,"deletions":89,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, inline_msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -124,1 +124,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, inline_msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -150,1 +150,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -152,1 +152,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -193,1 +193,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, inline_msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -195,1 +195,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, inline_msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -211,1 +211,1 @@\n-    CompileTask::print_inlining_ul(kit.callee(), jvms->depth() - 1, bci, msg);\n+    CompileTask::print_inlining_ul(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -213,1 +213,1 @@\n-      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, msg);\n+      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -297,0 +297,3 @@\n+  case vmIntrinsics::_arraySort:                return inline_array_sort();\n+  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n+\n@@ -337,1 +340,1 @@\n-  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n+  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false, true);\n@@ -348,1 +351,1 @@\n-  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n+  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false, true);\n@@ -512,0 +515,1 @@\n+  case vmIntrinsics::_isFlattenedArray:         return inline_unsafe_isFlattenedArray();\n@@ -548,1 +552,0 @@\n-\n@@ -2037,1 +2040,1 @@\n-    } else if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {\n+    } else if (type == T_OBJECT) {\n@@ -2277,1 +2280,1 @@\n-bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {\n+bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned, const bool is_flat) {\n@@ -2301,2 +2304,2 @@\n-      assert(rtype == type || (rtype == T_OBJECT && type == T_PRIMITIVE_OBJECT), \"getter must return the expected value\");\n-      assert(sig->count() == 2 || (type == T_PRIMITIVE_OBJECT && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n+      assert(rtype == type, \"getter must return the expected value\");\n+      assert(sig->count() == 2 || (is_flat && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n@@ -2308,1 +2311,1 @@\n-      assert(sig->count() == 3 || (type == T_PRIMITIVE_OBJECT && sig->count() == 4), \"oop putter has 3 arguments\");\n+      assert(sig->count() == 3 || (is_flat && sig->count() == 4), \"oop putter has 3 arguments\");\n@@ -2312,1 +2315,1 @@\n-      assert(vtype == type || (type == T_PRIMITIVE_OBJECT && vtype == T_OBJECT), \"putter must accept the expected value\");\n+      assert(vtype == type, \"putter must accept the expected value\");\n@@ -2336,1 +2339,1 @@\n-  if (type == T_PRIMITIVE_OBJECT) {\n+  if (is_flat) {\n@@ -2366,1 +2369,1 @@\n-          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flat())) {\n+          if (bt == T_ARRAY || bt == T_NARROWOOP) {\n@@ -2369,1 +2372,1 @@\n-          if (bt == type && (bt != T_PRIMITIVE_OBJECT || field->type() == inline_klass)) {\n+          if (bt == type && (!field->is_flat() || field->type() == inline_klass)) {\n@@ -2417,1 +2420,1 @@\n-  Node* val = is_store ? argument(4 + (type == T_PRIMITIVE_OBJECT ? 1 : 0)) : nullptr;\n+  Node* val = is_store ? argument(4 + (is_flat ? 1 : 0)) : nullptr;\n@@ -2455,4 +2458,1 @@\n-    assert(bt == alias_type->basic_type() || bt == T_PRIMITIVE_OBJECT, \"should match\");\n-    if (field != nullptr && bt == T_PRIMITIVE_OBJECT && !field->is_flat()) {\n-      bt = T_OBJECT;\n-    }\n+    assert(bt == alias_type->basic_type() || is_flat, \"should match\");\n@@ -2465,3 +2465,0 @@\n-    if (adr_type->is_flat()) {\n-      bt = T_PRIMITIVE_OBJECT;\n-    }\n@@ -2473,1 +2470,1 @@\n-    if (bt != T_PRIMITIVE_OBJECT && is_reference_type(bt, true)) {\n+    if (is_reference_type(bt, true)) {\n@@ -2488,1 +2485,1 @@\n-  if (type == T_PRIMITIVE_OBJECT) {\n+  if (is_flat) {\n@@ -2512,1 +2509,1 @@\n-  assert(!mismatched || type == T_PRIMITIVE_OBJECT || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n+  assert(!mismatched || is_flat || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n@@ -2525,1 +2522,1 @@\n-    if (type == T_OBJECT) {\n+    if (type == T_OBJECT && !is_flat) {\n@@ -2530,2 +2527,0 @@\n-    } else if (type == T_PRIMITIVE_OBJECT) {\n-      value_type = nullptr;\n@@ -2554,1 +2549,1 @@\n-      if (type == T_PRIMITIVE_OBJECT) {\n+      if (is_flat) {\n@@ -2607,1 +2602,1 @@\n-    if (type == T_PRIMITIVE_OBJECT) {\n+    if (is_flat) {\n@@ -3109,0 +3104,1 @@\n+  Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n@@ -3117,0 +3113,1 @@\n+    sync_kit(ideal);\n@@ -3119,3 +3116,0 @@\n-    Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n-\n-    sync_kit(ideal);\n@@ -3126,1 +3120,0 @@\n-    Node* vt_oop = _gvn.transform(argument(0)); \/\/ this argument - VirtualThread oop\n@@ -5294,0 +5287,14 @@\n+\/\/----------------------inline_unsafe_isFlattenedArray-------------------\n+\/\/ public native boolean Unsafe.isFlattenedArray(Class<?> arrayClass);\n+\/\/ This intrinsic exploits assumptions made by the native implementation\n+\/\/ (arrayClass is neither null nor primitive) to avoid unnecessary null checks.\n+bool LibraryCallKit::inline_unsafe_isFlattenedArray() {\n+  Node* cls = argument(1);\n+  Node* p = basic_plus_adr(cls, java_lang_Class::klass_offset());\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, nullptr, immutable_memory(), p,\n+                                                 TypeRawPtr::BOTTOM, TypeInstKlassPtr::OBJECT));\n+  Node* result = flat_array_test(kls);\n+  set_result(result);\n+  return true;\n+}\n+\n@@ -5423,2 +5430,2 @@\n-        Node* obj_size  = nullptr;\n-        Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n+        Node* array_size = nullptr; \/\/ Size of the array without object alignment padding.\n+        Node* alloc_obj = new_array(obj_klass, obj_length, 0, &array_size, \/*deoptimize_on_exception=*\/true);\n@@ -5457,1 +5464,1 @@\n-          copy_to_clone(obj, alloc_obj, obj_size, true);\n+          copy_to_clone(obj, alloc_obj, array_size, true);\n@@ -5494,1 +5501,1 @@\n-      Node* obj_size  = nullptr;\n+      Node* obj_size = nullptr; \/\/ Total object size, including object alignment padding.\n@@ -5761,0 +5768,95 @@\n+\/\/------------------------------inline_array_partition-----------------------\n+bool LibraryCallKit::inline_array_partition() {\n+\n+  const char *stubName = \"array_partition_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+  Node* indexPivot1     = argument(6);\n+  Node* indexPivot2     = argument(7);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  address stubAddr = nullptr;\n+  stubAddr = StubRoutines::select_array_partition_function();\n+  \/\/ stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+  \/\/ get the address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ create the pivotIndices array of type int and size = 2\n+  Node* size = intcon(2);\n+  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+  Node* pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+  guarantee(alloc != nullptr, \"created above\");\n+  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+\n+  \/\/ pass the basic type enum to the stub\n+  Node* elemType = intcon(bt);\n+\n+  \/\/ Call the stub\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n+                    indexPivot1, indexPivot2);\n+\n+  if (!stopped()) {\n+    set_result(pivotIndices);\n+  }\n+\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_array_sort-----------------------\n+bool LibraryCallKit::inline_array_sort() {\n+\n+  const char *stubName;\n+  stubName = \"arraysort_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  address stubAddr = nullptr;\n+  stubAddr = StubRoutines::select_arraysort_function();\n+  \/\/stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ get address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ pass the basic type enum to the stub\n+  Node* elemType = intcon(bt);\n+\n+  \/\/ Call the stub.\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_sort_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, elemType, fromIndex, toIndex);\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":146,"deletions":44,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);\n+  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned, bool is_flat = false);\n@@ -254,0 +254,1 @@\n+  bool inline_unsafe_isFlattenedArray();\n@@ -303,1 +304,2 @@\n-\n+  bool inline_array_sort();\n+  bool inline_array_partition();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"compiler\/compileLog.hpp\"\n@@ -30,1 +29,1 @@\n-#include \"opto\/callnode.hpp\"\n+#include \"opto\/c2compiler.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"opto\/divnode.hpp\"\n@@ -36,1 +34,0 @@\n-#include \"opto\/mulnode.hpp\"\n@@ -39,1 +36,0 @@\n-#include \"opto\/rootnode.hpp\"\n@@ -72,1 +68,0 @@\n-  _pre_loop_end(nullptr),                                   \/\/ Pre loop CountedLoopEndNode\n@@ -79,1 +74,0 @@\n-  _do_reserve_copy(DoReserveCopyInSuperWord),\n@@ -94,1 +88,1 @@\n-  assert(UseSuperWord, \"should be\");\n+  assert(_phase->C->do_superword(), \"SuperWord option should be enabled\");\n@@ -156,1 +150,1 @@\n-    CountedLoopEndNode* pre_end = find_pre_loop_end(cl);\n+    CountedLoopEndNode* pre_end = cl->find_pre_loop_end();\n@@ -164,1 +158,1 @@\n-    set_pre_loop_end(pre_end);\n+    cl->set_pre_loop_end(pre_end);\n@@ -219,1 +213,1 @@\n-    if (n->is_Phi() && (n->bottom_type() == Type::MEMORY)) {\n+    if (n->is_memory_phi()) {\n@@ -267,1 +261,1 @@\n-          SWPointer p1(current, this, &nstack, true);\n+          VPointer p1(current, phase(), lpt(), &nstack, true);\n@@ -628,1 +622,1 @@\n-    SWPointer align_to_ref_p(mem_ref, this, nullptr, false);\n+    VPointer align_to_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n@@ -634,1 +628,1 @@\n-        SWPointer p2(s, this, nullptr, false);\n+        VPointer p2(s, phase(), lpt(), nullptr, false);\n@@ -756,1 +750,1 @@\n-bool SuperWord::mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, SWPointer &align_to_ref_p,\n+bool SuperWord::mem_ref_has_no_alignment_violation(MemNode* mem_ref, int iv_adjustment, VPointer& align_to_ref_p,\n@@ -787,1 +781,1 @@\n-  SWPointer p2(best_align_to_mem_ref, this, nullptr, false);\n+  VPointer p2(best_align_to_mem_ref, phase(), lpt(), nullptr, false);\n@@ -806,1 +800,1 @@\n-    SWPointer p1(s1, this, nullptr, false);\n+    VPointer p1(s1, phase(), lpt(), nullptr, false);\n@@ -816,1 +810,1 @@\n-        SWPointer p2(s2, this, nullptr, false);\n+        VPointer p2(s2, phase(), lpt(), nullptr, false);\n@@ -837,1 +831,1 @@\n-      SWPointer p(s, this, nullptr, false);\n+      VPointer p(s, phase(), lpt(), nullptr, false);\n@@ -860,1 +854,1 @@\n-        SWPointer p(s, this, nullptr, false);\n+        VPointer p(s, phase(), lpt(), nullptr, false);\n@@ -924,1 +918,1 @@\n-bool SuperWord::ref_is_alignable(SWPointer& p) {\n+bool SuperWord::ref_is_alignable(VPointer& p) {\n@@ -928,1 +922,1 @@\n-  CountedLoopEndNode* pre_end = pre_loop_end();\n+  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n@@ -1022,1 +1016,1 @@\n-  SWPointer align_to_ref_p(mem_ref, this, nullptr, false);\n+  VPointer align_to_ref_p(mem_ref, phase(), lpt(), nullptr, false);\n@@ -1066,1 +1060,1 @@\n-    if (n->is_Mem() || (n->is_Phi() && n->bottom_type() == Type::MEMORY)) {\n+    if (n->is_Mem() || n->is_memory_phi()) {\n@@ -1103,1 +1097,1 @@\n-      SWPointer p1(s1->as_Mem(), this, nullptr, false);\n+      VPointer p1(s1->as_Mem(), phase(), lpt(), nullptr, false);\n@@ -1109,1 +1103,1 @@\n-        SWPointer p2(s2->as_Mem(), this, nullptr, false);\n+        VPointer p2(s2->as_Mem(), phase(), lpt(), nullptr, false);\n@@ -1118,1 +1112,1 @@\n-        if (!SWPointer::not_equal(cmp)) {\n+        if (!VPointer::not_equal(cmp)) {\n@@ -1174,1 +1168,1 @@\n-        } else if (out->is_Phi() && out->bottom_type() == Type::MEMORY && !in_bb(out)) {\n+        } else if (out->is_memory_phi() && !in_bb(out)) {\n@@ -1260,2 +1254,2 @@\n-  SWPointer p1(s1->as_Mem(), this, nullptr, false);\n-  SWPointer p2(s2->as_Mem(), this, nullptr, false);\n+  VPointer p1(s1->as_Mem(), phase(), lpt(), nullptr, false);\n+  VPointer p2(s2->as_Mem(), phase(), lpt(), nullptr, false);\n@@ -2502,16 +2496,0 @@\n-#ifndef PRODUCT\n-void SuperWord::print_loop(bool whole) {\n-  Node_Stack stack(_arena, _phase->C->unique() >> 2);\n-  Node_List rpo_list;\n-  VectorSet visited(_arena);\n-  visited.set(lpt()->_head->_idx);\n-  _phase->rpo(lpt()->_head, stack, visited, rpo_list);\n-  _phase->dump(lpt(), rpo_list.size(), rpo_list );\n-  if(whole) {\n-    tty->print_cr(\"\\n Whole loop tree\");\n-    _phase->dump();\n-    tty->print_cr(\" End of whole loop tree\\n\");\n-  }\n-}\n-#endif\n-\n@@ -2520,0 +2498,5 @@\n+\/\/ At this point, all correctness and profitability checks have passed.\n+\/\/ We start the irreversible process of editing the C2 graph. Should\n+\/\/ there be an unexpected situation (assert fails), then we can only\n+\/\/ bail out of the compilation, as the graph has already been partially\n+\/\/ modified. We bail out, and retry without SuperWord.\n@@ -2547,11 +2530,0 @@\n-  NOT_PRODUCT(if(is_trace_loop_reverse()) {tty->print_cr(\"SWPointer::output: print loop before create_reserve_version_of_loop\"); print_loop(true);})\n-\n-  CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());\n-\n-  NOT_PRODUCT(if(is_trace_loop_reverse()) {tty->print_cr(\"SWPointer::output: print loop after create_reserve_version_of_loop\"); print_loop(true);})\n-\n-  if (do_reserve_copy() && !make_reversable.has_reserved()) {\n-    NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: loop was not reserved correctly, exiting SuperWord\");})\n-    return false;\n-  }\n-\n@@ -2569,1 +2541,1 @@\n-      NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"SWPointer::output: %d executed first, %d executed last in pack\", first->_idx, n->_idx); print_pack(p);})\n+      NOT_PRODUCT(if(is_trace_cmov()) {tty->print_cr(\"VPointer::output: %d executed first, %d executed last in pack\", first->_idx, n->_idx); print_pack(p);})\n@@ -2574,5 +2546,3 @@\n-        SWPointer p1(n->as_Mem(), this, nullptr, false);\n-        \/\/ Identify the memory dependency for the new loadVector node by\n-        \/\/ walking up through memory chain.\n-        \/\/ This is done to give flexibility to the new loadVector node so that\n-        \/\/ it can move above independent storeVector nodes.\n+        \/\/ Set the memory dependency of the LoadVector as early as possible.\n+        \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n+        \/\/ does not have any memory dependency.\n@@ -2580,4 +2550,3 @@\n-          SWPointer p2(mem->as_Mem(), this, nullptr, false);\n-          int cmp = p1.cmp(p2);\n-          if (SWPointer::not_equal(cmp) || !SWPointer::comparable(cmp)) {\n-            mem = mem->in(MemNode::Memory);\n+          VPointer p_store(mem->as_Mem(), phase(), lpt(), nullptr, false);\n+          if (p_store.overlap_possible_with_any_in(p)) {\n+            break;\n@@ -2585,1 +2554,1 @@\n-            break; \/\/ dependent memory\n+            mem = mem->in(MemNode::Memory);\n@@ -2596,6 +2565,3 @@\n-          if (do_reserve_copy()) {\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: val should not be null, exiting SuperWord\");})\n-            assert(false, \"input to vector store was not created\");\n-            return false; \/\/and reverse to backup IG\n-          }\n-          ShouldNotReachHere();\n+          assert(false, \"input to vector store was not created\");\n+          C->record_failure(C2Compiler::retry_no_superword());\n+          return false; \/\/ bailout\n@@ -2738,6 +2704,3 @@\n-            if (do_reserve_copy()) {\n-              NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: in1 should not be null, exiting SuperWord\");})\n-              assert(false, \"input in1 to vector operand was not created\");\n-              return false; \/\/and reverse to backup IG\n-            }\n-            ShouldNotReachHere();\n+            assert(false, \"input in1 to vector operand was not created\");\n+            C->record_failure(C2Compiler::retry_no_superword());\n+            return false; \/\/ bailout\n@@ -2748,6 +2711,3 @@\n-          if (do_reserve_copy()) {\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: in2 should not be null, exiting SuperWord\");})\n-            assert(false, \"input in2 to vector operand was not created\");\n-            return false; \/\/and reverse to backup IG\n-          }\n-          ShouldNotReachHere();\n+          assert(false, \"input in2 to vector operand was not created\");\n+          C->record_failure(C2Compiler::retry_no_superword());\n+          return false; \/\/ bailout\n@@ -2829,6 +2789,3 @@\n-        if (do_reserve_copy()) {\n-          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: Unhandled scalar opcode (%s), ShouldNotReachHere, exiting SuperWord\", NodeClassNames[opc]);})\n-          assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n-          return false; \/\/and reverse to backup IG\n-        }\n-        ShouldNotReachHere();\n+        assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n+        C->record_failure(C2Compiler::retry_no_superword());\n+        return false; \/\/ bailout\n@@ -2837,6 +2794,3 @@\n-      assert(vn != nullptr, \"sanity\");\n-        if (do_reserve_copy()){\n-          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"SWPointer::output: got null node, cannot proceed, exiting SuperWord\");})\n-          return false; \/\/and reverse to backup IG\n-        }\n-        ShouldNotReachHere();\n+        assert(false, \"got null node instead of vector node\");\n+        C->record_failure(C2Compiler::retry_no_superword());\n+        return false; \/\/ bailout\n@@ -2890,5 +2844,0 @@\n-  if (do_reserve_copy()) {\n-    make_reversable.use_new();\n-  }\n-\n-  NOT_PRODUCT(if(is_trace_loop_reverse()) {tty->print_cr(\"\\n Final loop after SuperWord\"); print_loop(true);})\n@@ -2925,2 +2874,1 @@\n-      assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), \"shift's count can't be vector\");\n-        NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"shift's count can't be vector\");})\n+        assert(false, \"shift's count can't be vector\");\n@@ -2951,2 +2899,1 @@\n-        assert(opd->bottom_type()->isa_int(), \"int type only\");\n-          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"Should be int type only\");})\n+          assert(false, \"int type only\");\n@@ -2963,2 +2910,1 @@\n-    assert(!opd->is_StoreVector(), \"such vector is not expected here\");\n-      NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"StoreVector is not expected here\");})\n+      assert(false, \"StoreVector is not expected here\");\n@@ -3002,2 +2948,1 @@\n-    assert(my_pack(in) == nullptr, \"Should already have been unpacked\");\n-      NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"Should already have been unpacked\");})\n+      assert(false, \"Should already have been unpacked\");\n@@ -3011,3 +2956,2 @@\n-      assert(my_pack(in2) == nullptr, \"Should already have been unpacked\");\n-        NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty->print_cr(\"Should already have been unpacked\"); })\n-          return nullptr;\n+        assert(false, \"Should already have been unpacked\");\n+        return nullptr;\n@@ -3200,1 +3144,1 @@\n-    if (in_bb(n) && (n->is_Phi() && n->bottom_type() == Type::MEMORY)) {\n+    if (in_bb(n) && n->is_memory_phi()) {\n@@ -3511,2 +3455,1 @@\n-  NOT_PRODUCT(SWPointer::Tracer::Depth ddd(0);)\n-  SWPointer p(s, this, nullptr, false);\n+  VPointer p(s, phase(), lpt(), nullptr, false);\n@@ -3514,1 +3457,1 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SWPointer::memory_alignment: SWPointer p invalid, return bottom_align\");)\n+    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"VPointer::memory_alignment: VPointer p invalid, return bottom_align\");)\n@@ -3519,1 +3462,1 @@\n-    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SWPointer::memory_alignment: vector_width_in_bytes < 2, return bottom_align\");)\n+    NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"VPointer::memory_alignment: vector_width_in_bytes < 2, return bottom_align\");)\n@@ -3528,1 +3471,1 @@\n-    tty->print_cr(\"SWPointer::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n+    tty->print_cr(\"VPointer::memory_alignment: off_rem = %d, off_mod = %d (offset = %d)\", off_rem, off_mod, offset);\n@@ -3650,1 +3593,1 @@\n-  CountedLoopEndNode* pre_end = pre_loop_end();\n+  CountedLoopEndNode* pre_end = lp()->pre_loop_end();\n@@ -3657,1 +3600,1 @@\n-  Node* pre_ctrl = pre_loop_head()->in(LoopNode::EntryControl);\n+  Node* pre_ctrl = lp()->pre_loop_head()->in(LoopNode::EntryControl);\n@@ -3664,1 +3607,1 @@\n-  SWPointer align_to_ref_p(align_to_ref, this, nullptr, false);\n+  VPointer align_to_ref_p(align_to_ref, phase(), lpt(), nullptr, false);\n@@ -3806,18 +3749,0 @@\n-\/\/----------------------------get_pre_loop_end---------------------------\n-\/\/ Find pre loop end from main loop.  Returns null if none.\n-CountedLoopEndNode* SuperWord::find_pre_loop_end(CountedLoopNode* cl) const {\n-  \/\/ The loop cannot be optimized if the graph shape at\n-  \/\/ the loop entry is inappropriate.\n-  if (cl->is_canonical_loop_entry() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  Node* p_f = cl->skip_assertion_predicates_with_halt()->in(0)->in(0);\n-  if (!p_f->is_IfFalse()) return nullptr;\n-  if (!p_f->in(0)->is_CountedLoopEnd()) return nullptr;\n-  CountedLoopEndNode* pre_end = p_f->in(0)->as_CountedLoopEnd();\n-  CountedLoopNode* loop_node = pre_end->loopnode();\n-  if (loop_node == nullptr || !loop_node->is_pre_loop()) return nullptr;\n-  return pre_end;\n-}\n-\n@@ -3886,667 +3811,0 @@\n-\/\/==============================SWPointer===========================\n-#ifndef PRODUCT\n-int SWPointer::Tracer::_depth = 0;\n-#endif\n-\/\/----------------------------SWPointer------------------------\n-SWPointer::SWPointer(MemNode* mem, SuperWord* slp, Node_Stack *nstack, bool analyze_only) :\n-  _mem(mem), _slp(slp), _base(nullptr), _adr(nullptr),\n-  _scale(0), _offset(0), _invar(nullptr),\n-#ifdef ASSERT\n-  _debug_invar(nullptr), _debug_negate_invar(false), _debug_invar_scale(nullptr),\n-#endif\n-  _nstack(nstack), _analyze_only(analyze_only),\n-  _stack_idx(0)\n-#ifndef PRODUCT\n-  , _tracer(slp)\n-#endif\n-{\n-  NOT_PRODUCT(_tracer.ctor_1(mem);)\n-\n-  Node* adr = mem->in(MemNode::Address);\n-  if (!adr->is_AddP()) {\n-    assert(!valid(), \"too complex\");\n-    return;\n-  }\n-  \/\/ Match AddP(base, AddP(ptr, k*iv [+ invariant]), constant)\n-  Node* base = adr->in(AddPNode::Base);\n-  \/\/ The base address should be loop invariant\n-  if (is_loop_member(base)) {\n-    assert(!valid(), \"base address is loop variant\");\n-    return;\n-  }\n-  \/\/ unsafe references require misaligned vector access support\n-  if (base->is_top() && !Matcher::misaligned_vectors_ok()) {\n-    assert(!valid(), \"unsafe access\");\n-    return;\n-  }\n-\n-  NOT_PRODUCT(if(_slp->is_trace_alignment()) _tracer.store_depth();)\n-  NOT_PRODUCT(_tracer.ctor_2(adr);)\n-\n-  int i;\n-  for (i = 0; ; i++) {\n-    NOT_PRODUCT(_tracer.ctor_3(adr, i);)\n-\n-    if (!scaled_iv_plus_offset(adr->in(AddPNode::Offset))) {\n-      assert(!valid(), \"too complex\");\n-      return;\n-    }\n-    adr = adr->in(AddPNode::Address);\n-    NOT_PRODUCT(_tracer.ctor_4(adr, i);)\n-\n-    if (base == adr || !adr->is_AddP()) {\n-      NOT_PRODUCT(_tracer.ctor_5(adr, base, i);)\n-      break; \/\/ stop looking at addp's\n-    }\n-  }\n-  if (is_loop_member(adr)) {\n-    assert(!valid(), \"adr is loop variant\");\n-    return;\n-  }\n-\n-  if (!base->is_top() && adr != base) {\n-    assert(!valid(), \"adr and base differ\");\n-    return;\n-  }\n-\n-  NOT_PRODUCT(if(_slp->is_trace_alignment()) _tracer.restore_depth();)\n-  NOT_PRODUCT(_tracer.ctor_6(mem);)\n-\n-  _base = base;\n-  _adr  = adr;\n-  assert(valid(), \"Usable\");\n-}\n-\n-\/\/ Following is used to create a temporary object during\n-\/\/ the pattern match of an address expression.\n-SWPointer::SWPointer(SWPointer* p) :\n-  _mem(p->_mem), _slp(p->_slp), _base(nullptr), _adr(nullptr),\n-  _scale(0), _offset(0), _invar(nullptr),\n-#ifdef ASSERT\n-  _debug_invar(nullptr), _debug_negate_invar(false), _debug_invar_scale(nullptr),\n-#endif\n-  _nstack(p->_nstack), _analyze_only(p->_analyze_only),\n-  _stack_idx(p->_stack_idx)\n-  #ifndef PRODUCT\n-  , _tracer(p->_slp)\n-  #endif\n-{}\n-\n-bool SWPointer::is_loop_member(Node* n) const {\n-  Node* n_c = phase()->get_ctrl(n);\n-  return lpt()->is_member(phase()->get_loop(n_c));\n-}\n-\n-bool SWPointer::invariant(Node* n) const {\n-  NOT_PRODUCT(Tracer::Depth dd;)\n-  Node* n_c = phase()->get_ctrl(n);\n-  NOT_PRODUCT(_tracer.invariant_1(n, n_c);)\n-  bool is_not_member = !is_loop_member(n);\n-  if (is_not_member && _slp->lp()->is_main_loop()) {\n-    \/\/ Check that n_c dominates the pre loop head node. If it does not, then we cannot use n as invariant for the pre loop\n-    \/\/ CountedLoopEndNode check because n_c is either part of the pre loop or between the pre and the main loop (illegal\n-    \/\/ invariant: Happens, for example, when n_c is a CastII node that prevents data nodes to flow above the main loop).\n-    return phase()->is_dominator(n_c, _slp->pre_loop_head());\n-  }\n-  return is_not_member;\n-}\n-\n-\/\/------------------------scaled_iv_plus_offset--------------------\n-\/\/ Match: k*iv + offset\n-\/\/ where: k is a constant that maybe zero, and\n-\/\/        offset is (k2 [+\/- invariant]) where k2 maybe zero and invariant is optional\n-bool SWPointer::scaled_iv_plus_offset(Node* n) {\n-  NOT_PRODUCT(Tracer::Depth ddd;)\n-  NOT_PRODUCT(_tracer.scaled_iv_plus_offset_1(n);)\n-\n-  if (scaled_iv(n)) {\n-    NOT_PRODUCT(_tracer.scaled_iv_plus_offset_2(n);)\n-    return true;\n-  }\n-\n-  if (offset_plus_k(n)) {\n-    NOT_PRODUCT(_tracer.scaled_iv_plus_offset_3(n);)\n-    return true;\n-  }\n-\n-  int opc = n->Opcode();\n-  if (opc == Op_AddI) {\n-    if (offset_plus_k(n->in(2)) && scaled_iv_plus_offset(n->in(1))) {\n-      NOT_PRODUCT(_tracer.scaled_iv_plus_offset_4(n);)\n-      return true;\n-    }\n-    if (offset_plus_k(n->in(1)) && scaled_iv_plus_offset(n->in(2))) {\n-      NOT_PRODUCT(_tracer.scaled_iv_plus_offset_5(n);)\n-      return true;\n-    }\n-  } else if (opc == Op_SubI || opc == Op_SubL) {\n-    if (offset_plus_k(n->in(2), true) && scaled_iv_plus_offset(n->in(1))) {\n-      NOT_PRODUCT(_tracer.scaled_iv_plus_offset_6(n);)\n-      return true;\n-    }\n-    if (offset_plus_k(n->in(1)) && scaled_iv_plus_offset(n->in(2))) {\n-      _scale *= -1;\n-      NOT_PRODUCT(_tracer.scaled_iv_plus_offset_7(n);)\n-      return true;\n-    }\n-  }\n-\n-  NOT_PRODUCT(_tracer.scaled_iv_plus_offset_8(n);)\n-  return false;\n-}\n-\n-\/\/----------------------------scaled_iv------------------------\n-\/\/ Match: k*iv where k is a constant that's not zero\n-bool SWPointer::scaled_iv(Node* n) {\n-  NOT_PRODUCT(Tracer::Depth ddd;)\n-  NOT_PRODUCT(_tracer.scaled_iv_1(n);)\n-\n-  if (_scale != 0) { \/\/ already found a scale\n-    NOT_PRODUCT(_tracer.scaled_iv_2(n, _scale);)\n-    return false;\n-  }\n-\n-  if (n == iv()) {\n-    _scale = 1;\n-    NOT_PRODUCT(_tracer.scaled_iv_3(n, _scale);)\n-    return true;\n-  }\n-  if (_analyze_only && (is_loop_member(n))) {\n-    _nstack->push(n, _stack_idx++);\n-  }\n-\n-  int opc = n->Opcode();\n-  if (opc == Op_MulI) {\n-    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n-      _scale = n->in(2)->get_int();\n-      NOT_PRODUCT(_tracer.scaled_iv_4(n, _scale);)\n-      return true;\n-    } else if (n->in(2) == iv() && n->in(1)->is_Con()) {\n-      _scale = n->in(1)->get_int();\n-      NOT_PRODUCT(_tracer.scaled_iv_5(n, _scale);)\n-      return true;\n-    }\n-  } else if (opc == Op_LShiftI) {\n-    if (n->in(1) == iv() && n->in(2)->is_Con()) {\n-      _scale = 1 << n->in(2)->get_int();\n-      NOT_PRODUCT(_tracer.scaled_iv_6(n, _scale);)\n-      return true;\n-    }\n-  } else if (opc == Op_ConvI2L || opc == Op_CastII) {\n-    if (scaled_iv_plus_offset(n->in(1))) {\n-      NOT_PRODUCT(_tracer.scaled_iv_7(n);)\n-      return true;\n-    }\n-  } else if (opc == Op_LShiftL && n->in(2)->is_Con()) {\n-    if (!has_iv()) {\n-      \/\/ Need to preserve the current _offset value, so\n-      \/\/ create a temporary object for this expression subtree.\n-      \/\/ Hacky, so should re-engineer the address pattern match.\n-      NOT_PRODUCT(Tracer::Depth dddd;)\n-      SWPointer tmp(this);\n-      NOT_PRODUCT(_tracer.scaled_iv_8(n, &tmp);)\n-\n-      if (tmp.scaled_iv_plus_offset(n->in(1))) {\n-        int scale = n->in(2)->get_int();\n-        _scale   = tmp._scale  << scale;\n-        _offset += tmp._offset << scale;\n-        if (tmp._invar != nullptr) {\n-          BasicType bt = tmp._invar->bottom_type()->basic_type();\n-          assert(bt == T_INT || bt == T_LONG, \"\");\n-          maybe_add_to_invar(register_if_new(LShiftNode::make(tmp._invar, n->in(2), bt)), false);\n-#ifdef ASSERT\n-          _debug_invar_scale = n->in(2);\n-#endif\n-        }\n-        NOT_PRODUCT(_tracer.scaled_iv_9(n, _scale, _offset, _invar);)\n-        return true;\n-      }\n-    }\n-  }\n-  NOT_PRODUCT(_tracer.scaled_iv_10(n);)\n-  return false;\n-}\n-\n-\/\/----------------------------offset_plus_k------------------------\n-\/\/ Match: offset is (k [+\/- invariant])\n-\/\/ where k maybe zero and invariant is optional, but not both.\n-bool SWPointer::offset_plus_k(Node* n, bool negate) {\n-  NOT_PRODUCT(Tracer::Depth ddd;)\n-  NOT_PRODUCT(_tracer.offset_plus_k_1(n);)\n-\n-  int opc = n->Opcode();\n-  if (opc == Op_ConI) {\n-    _offset += negate ? -(n->get_int()) : n->get_int();\n-    NOT_PRODUCT(_tracer.offset_plus_k_2(n, _offset);)\n-    return true;\n-  } else if (opc == Op_ConL) {\n-    \/\/ Okay if value fits into an int\n-    const TypeLong* t = n->find_long_type();\n-    if (t->higher_equal(TypeLong::INT)) {\n-      jlong loff = n->get_long();\n-      jint  off  = (jint)loff;\n-      _offset += negate ? -off : loff;\n-      NOT_PRODUCT(_tracer.offset_plus_k_3(n, _offset);)\n-      return true;\n-    }\n-    NOT_PRODUCT(_tracer.offset_plus_k_4(n);)\n-    return false;\n-  }\n-  assert((_debug_invar == nullptr) == (_invar == nullptr), \"\");\n-\n-  if (_analyze_only && is_loop_member(n)) {\n-    _nstack->push(n, _stack_idx++);\n-  }\n-  if (opc == Op_AddI) {\n-    if (n->in(2)->is_Con() && invariant(n->in(1))) {\n-      maybe_add_to_invar(n->in(1), negate);\n-      _offset += negate ? -(n->in(2)->get_int()) : n->in(2)->get_int();\n-      NOT_PRODUCT(_tracer.offset_plus_k_6(n, _invar, negate, _offset);)\n-      return true;\n-    } else if (n->in(1)->is_Con() && invariant(n->in(2))) {\n-      _offset += negate ? -(n->in(1)->get_int()) : n->in(1)->get_int();\n-      maybe_add_to_invar(n->in(2), negate);\n-      NOT_PRODUCT(_tracer.offset_plus_k_7(n, _invar, negate, _offset);)\n-      return true;\n-    }\n-  }\n-  if (opc == Op_SubI) {\n-    if (n->in(2)->is_Con() && invariant(n->in(1))) {\n-      maybe_add_to_invar(n->in(1), negate);\n-      _offset += !negate ? -(n->in(2)->get_int()) : n->in(2)->get_int();\n-      NOT_PRODUCT(_tracer.offset_plus_k_8(n, _invar, negate, _offset);)\n-      return true;\n-    } else if (n->in(1)->is_Con() && invariant(n->in(2))) {\n-      _offset += negate ? -(n->in(1)->get_int()) : n->in(1)->get_int();\n-      maybe_add_to_invar(n->in(2), !negate);\n-      NOT_PRODUCT(_tracer.offset_plus_k_9(n, _invar, !negate, _offset);)\n-      return true;\n-    }\n-  }\n-\n-  if (!is_loop_member(n)) {\n-    \/\/ 'n' is loop invariant. Skip ConvI2L and CastII nodes before checking if 'n' is dominating the pre loop.\n-    if (opc == Op_ConvI2L) {\n-      n = n->in(1);\n-    }\n-    if (n->Opcode() == Op_CastII) {\n-      \/\/ Skip CastII nodes\n-      assert(!is_loop_member(n), \"sanity\");\n-      n = n->in(1);\n-    }\n-    \/\/ Check if 'n' can really be used as invariant (not in main loop and dominating the pre loop).\n-    if (invariant(n)) {\n-      maybe_add_to_invar(n, negate);\n-      NOT_PRODUCT(_tracer.offset_plus_k_10(n, _invar, negate, _offset);)\n-      return true;\n-    }\n-  }\n-\n-  NOT_PRODUCT(_tracer.offset_plus_k_11(n);)\n-  return false;\n-}\n-\n-Node* SWPointer::maybe_negate_invar(bool negate, Node* invar) {\n-#ifdef ASSERT\n-  _debug_negate_invar = negate;\n-#endif\n-  if (negate) {\n-    BasicType bt = invar->bottom_type()->basic_type();\n-    assert(bt == T_INT || bt == T_LONG, \"\");\n-    PhaseIterGVN& igvn = phase()->igvn();\n-    Node* zero = igvn.zerocon(bt);\n-    phase()->set_ctrl(zero, phase()->C->root());\n-    Node* sub = SubNode::make(zero, invar, bt);\n-    invar = register_if_new(sub);\n-  }\n-  return invar;\n-}\n-\n-Node* SWPointer::register_if_new(Node* n) const {\n-  PhaseIterGVN& igvn = phase()->igvn();\n-  Node* prev = igvn.hash_find_insert(n);\n-  if (prev != nullptr) {\n-    n->destruct(&igvn);\n-    n = prev;\n-  } else {\n-    Node* c = phase()->get_early_ctrl(n);\n-    phase()->register_new_node(n, c);\n-  }\n-  return n;\n-}\n-\n-void SWPointer::maybe_add_to_invar(Node* new_invar, bool negate) {\n-  new_invar = maybe_negate_invar(negate, new_invar);\n-  if (_invar == nullptr) {\n-    _invar = new_invar;\n-#ifdef ASSERT\n-    _debug_invar = new_invar;\n-#endif\n-    return;\n-  }\n-#ifdef ASSERT\n-  _debug_invar = NodeSentinel;\n-#endif\n-  BasicType new_invar_bt = new_invar->bottom_type()->basic_type();\n-  assert(new_invar_bt == T_INT || new_invar_bt == T_LONG, \"\");\n-  BasicType invar_bt = _invar->bottom_type()->basic_type();\n-  assert(invar_bt == T_INT || invar_bt == T_LONG, \"\");\n-\n-  BasicType bt = (new_invar_bt == T_LONG || invar_bt == T_LONG) ? T_LONG : T_INT;\n-  Node* current_invar = _invar;\n-  if (invar_bt != bt) {\n-    assert(bt == T_LONG && invar_bt == T_INT, \"\");\n-    assert(new_invar_bt == bt, \"\");\n-    current_invar = register_if_new(new ConvI2LNode(current_invar));\n-  } else if (new_invar_bt != bt) {\n-    assert(bt == T_LONG && new_invar_bt == T_INT, \"\");\n-    assert(invar_bt == bt, \"\");\n-    new_invar = register_if_new(new ConvI2LNode(new_invar));\n-  }\n-  Node* add = AddNode::make(current_invar, new_invar, bt);\n-  _invar = register_if_new(add);\n-}\n-\n-\/\/----------------------------print------------------------\n-void SWPointer::print() {\n-#ifndef PRODUCT\n-  tty->print(\"base: [%d]  adr: [%d]  scale: %d  offset: %d\",\n-             _base != nullptr ? _base->_idx : 0,\n-             _adr  != nullptr ? _adr->_idx  : 0,\n-             _scale, _offset);\n-  if (_invar != nullptr) {\n-    tty->print(\"  invar: [%d]\", _invar->_idx);\n-  }\n-  tty->cr();\n-#endif\n-}\n-\n-\/\/----------------------------tracing------------------------\n-#ifndef PRODUCT\n-void SWPointer::Tracer::print_depth() const {\n-  for (int ii = 0; ii < _depth; ++ii) {\n-    tty->print(\"  \");\n-  }\n-}\n-\n-void SWPointer::Tracer::ctor_1 (Node* mem) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print(\" %d SWPointer::SWPointer: start alignment analysis\", mem->_idx); mem->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::ctor_2(Node* adr) {\n-  if(_slp->is_trace_alignment()) {\n-    \/\/store_depth();\n-    inc_depth();\n-    print_depth(); tty->print(\" %d (adr) SWPointer::SWPointer: \", adr->_idx); adr->dump();\n-    inc_depth();\n-    print_depth(); tty->print(\" %d (base) SWPointer::SWPointer: \", adr->in(AddPNode::Base)->_idx); adr->in(AddPNode::Base)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::ctor_3(Node* adr, int i) {\n-  if(_slp->is_trace_alignment()) {\n-    inc_depth();\n-    Node* offset = adr->in(AddPNode::Offset);\n-    print_depth(); tty->print(\" %d (offset) SWPointer::SWPointer: i = %d: \", offset->_idx, i); offset->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::ctor_4(Node* adr, int i) {\n-  if(_slp->is_trace_alignment()) {\n-    inc_depth();\n-    print_depth(); tty->print(\" %d (adr) SWPointer::SWPointer: i = %d: \", adr->_idx, i); adr->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::ctor_5(Node* adr, Node* base, int i) {\n-  if(_slp->is_trace_alignment()) {\n-    inc_depth();\n-    if (base == adr) {\n-      print_depth(); tty->print_cr(\"  \\\\ %d (adr) == %d (base) SWPointer::SWPointer: breaking analysis at i = %d\", adr->_idx, base->_idx, i);\n-    } else if (!adr->is_AddP()) {\n-      print_depth(); tty->print_cr(\"  \\\\ %d (adr) is NOT Addp SWPointer::SWPointer: breaking analysis at i = %d\", adr->_idx, i);\n-    }\n-  }\n-}\n-\n-void SWPointer::Tracer::ctor_6(Node* mem) {\n-  if(_slp->is_trace_alignment()) {\n-    \/\/restore_depth();\n-    print_depth(); tty->print_cr(\" %d (adr) SWPointer::SWPointer: stop analysis\", mem->_idx);\n-  }\n-}\n-\n-void SWPointer::Tracer::invariant_1(Node *n, Node *n_c) const {\n-  if (_slp->do_vector_loop() && _slp->is_debug() && _slp->_lpt->is_member(_slp->_phase->get_loop(n_c)) != (int)_slp->in_bb(n)) {\n-    int is_member =  _slp->_lpt->is_member(_slp->_phase->get_loop(n_c));\n-    int in_bb     =  _slp->in_bb(n);\n-    print_depth(); tty->print(\"  \\\\ \");  tty->print_cr(\" %d SWPointer::invariant  conditions differ: n_c %d\", n->_idx, n_c->_idx);\n-    print_depth(); tty->print(\"  \\\\ \");  tty->print_cr(\"is_member %d, in_bb %d\", is_member, in_bb);\n-    print_depth(); tty->print(\"  \\\\ \");  n->dump();\n-    print_depth(); tty->print(\"  \\\\ \");  n_c->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_1(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print(\" %d SWPointer::scaled_iv_plus_offset testing node: \", n->_idx);\n-    n->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_2(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: PASSED\", n->_idx);\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_3(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: PASSED\", n->_idx);\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_4(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED\", n->_idx);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: \", n->in(1)->_idx); n->in(1)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: \", n->in(2)->_idx); n->in(2)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_5(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_AddI PASSED\", n->_idx);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: \", n->in(2)->_idx); n->in(2)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: \", n->in(1)->_idx); n->in(1)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_6(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_%s PASSED\", n->_idx, n->Name());\n-    print_depth(); tty->print(\"  \\\\  %d SWPointer::scaled_iv_plus_offset: in(1) is scaled_iv: \", n->in(1)->_idx); n->in(1)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv_plus_offset: in(2) is offset_plus_k: \", n->in(2)->_idx); n->in(2)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_7(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: Op_%s PASSED\", n->_idx, n->Name());\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv_plus_offset: in(2) is scaled_iv: \", n->in(2)->_idx); n->in(2)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv_plus_offset: in(1) is offset_plus_k: \", n->in(1)->_idx); n->in(1)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_plus_offset_8(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv_plus_offset: FAILED\", n->_idx);\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_1(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print(\" %d SWPointer::scaled_iv: testing node: \", n->_idx); n->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_2(Node* n, int scale) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: FAILED since another _scale has been detected before\", n->_idx);\n-    print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: _scale (%d) != 0\", scale);\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_3(Node* n, int scale) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: is iv, setting _scale = %d\", n->_idx, scale);\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_4(Node* n, int scale) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d\", n->_idx, scale);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv: in(1) is iv: \", n->in(1)->_idx); n->in(1)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv: in(2) is Con: \", n->in(2)->_idx); n->in(2)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_5(Node* n, int scale) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: Op_MulI PASSED, setting _scale = %d\", n->_idx, scale);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv: in(2) is iv: \", n->in(2)->_idx); n->in(2)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv: in(1) is Con: \", n->in(1)->_idx); n->in(1)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_6(Node* n, int scale) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: Op_LShiftI PASSED, setting _scale = %d\", n->_idx, scale);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv: in(1) is iv: \", n->in(1)->_idx); n->in(1)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::scaled_iv: in(2) is Con: \", n->in(2)->_idx); n->in(2)->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_7(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: Op_ConvI2L PASSED\", n->_idx);\n-    print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: in(1) %d is scaled_iv_plus_offset: \", n->in(1)->_idx);\n-    inc_depth(); inc_depth();\n-    print_depth(); n->in(1)->dump();\n-    dec_depth(); dec_depth();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_8(Node* n, SWPointer* tmp) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print(\" %d SWPointer::scaled_iv: Op_LShiftL, creating tmp SWPointer: \", n->_idx); tmp->print();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_9(Node* n, int scale, int offset, Node* invar) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: Op_LShiftL PASSED, setting _scale = %d, _offset = %d\", n->_idx, scale, offset);\n-    print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: in(1) [%d] is scaled_iv_plus_offset, in(2) [%d] used to scale: _scale = %d, _offset = %d\",\n-    n->in(1)->_idx, n->in(2)->_idx, scale, offset);\n-    if (invar != nullptr) {\n-      print_depth(); tty->print_cr(\"  \\\\ SWPointer::scaled_iv: scaled invariant: [%d]\", invar->_idx);\n-    }\n-    inc_depth(); inc_depth();\n-    print_depth(); n->in(1)->dump();\n-    print_depth(); n->in(2)->dump();\n-    if (invar != nullptr) {\n-      print_depth(); invar->dump();\n-    }\n-    dec_depth(); dec_depth();\n-  }\n-}\n-\n-void SWPointer::Tracer::scaled_iv_10(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::scaled_iv: FAILED\", n->_idx);\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_1(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print(\" %d SWPointer::offset_plus_k: testing node: \", n->_idx); n->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_2(Node* n, int _offset) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_ConI PASSED, setting _offset = %d\", n->_idx, _offset);\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_3(Node* n, int _offset) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_ConL PASSED, setting _offset = %d\", n->_idx, _offset);\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_4(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: FAILED\", n->_idx);\n-    print_depth(); tty->print_cr(\"  \\\\ \" JLONG_FORMAT \" SWPointer::offset_plus_k: Op_ConL FAILED, k is too big\", n->get_long());\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_5(Node* n, Node* _invar) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: FAILED since another invariant has been detected before\", n->_idx);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: _invar is not null: \", _invar->_idx); _invar->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_6(Node* n, Node* _invar, bool _negate_invar, int _offset) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\",\n-    n->_idx, _negate_invar, _invar->_idx, _offset);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(2) is Con: \", n->in(2)->_idx); n->in(2)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(1) is invariant: \", _invar->_idx); _invar->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_7(Node* n, Node* _invar, bool _negate_invar, int _offset) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_AddI PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\",\n-    n->_idx, _negate_invar, _invar->_idx, _offset);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(1) is Con: \", n->in(1)->_idx); n->in(1)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(2) is invariant: \", _invar->_idx); _invar->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_8(Node* n, Node* _invar, bool _negate_invar, int _offset) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_SubI is PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\",\n-    n->_idx, _negate_invar, _invar->_idx, _offset);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(2) is Con: \", n->in(2)->_idx); n->in(2)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(1) is invariant: \", _invar->_idx); _invar->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_9(Node* n, Node* _invar, bool _negate_invar, int _offset) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: Op_SubI PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\", n->_idx, _negate_invar, _invar->_idx, _offset);\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(1) is Con: \", n->in(1)->_idx); n->in(1)->dump();\n-    print_depth(); tty->print(\"  \\\\ %d SWPointer::offset_plus_k: in(2) is invariant: \", _invar->_idx); _invar->dump();\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_10(Node* n, Node* _invar, bool _negate_invar, int _offset) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: PASSED, setting _debug_negate_invar = %d, _invar = %d, _offset = %d\", n->_idx, _negate_invar, _invar->_idx, _offset);\n-    print_depth(); tty->print_cr(\"  \\\\ %d SWPointer::offset_plus_k: is invariant\", n->_idx);\n-  }\n-}\n-\n-void SWPointer::Tracer::offset_plus_k_11(Node* n) {\n-  if(_slp->is_trace_alignment()) {\n-    print_depth(); tty->print_cr(\" %d SWPointer::offset_plus_k: FAILED\", n->_idx);\n-  }\n-}\n-\n-#endif\n@@ -4672,1 +3930,1 @@\n-  } else if (_n->is_Mem() || (_n->is_Phi() && _n->bottom_type() == Type::MEMORY)) {\n+  } else if (_n->is_Mem() || _n->is_memory_phi()) {\n@@ -4705,1 +3963,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":67,"deletions":810,"binary":false,"changes":877,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-                   static_ptr_volatile_field,                                                                                        \\\n+                   volatile_static_field,                                                                                            \\\n@@ -199,0 +199,1 @@\n+                volatile_static_field,                                                                                               \\\n@@ -452,1 +453,1 @@\n-     static_field(PerfMemory,                  _initialized,                                  int)                                   \\\n+     volatile_static_field(PerfMemory,         _initialized,                                  int)                                   \\\n@@ -482,1 +483,1 @@\n-  static_ptr_volatile_field(ClassLoaderDataGraph, _head,                                      ClassLoaderData*)                      \\\n+  volatile_static_field(ClassLoaderDataGraph, _head,                                          ClassLoaderData*)                      \\\n@@ -643,1 +644,1 @@\n-  static_ptr_volatile_field(ThreadsSMRSupport, _java_thread_list,                             ThreadsList*)                          \\\n+  volatile_static_field(ThreadsSMRSupport, _java_thread_list,                                 ThreadsList*)                          \\\n@@ -1502,0 +1503,1 @@\n+  declare_c2_type(ConvertNode, TypeNode)                                  \\\n@@ -2697,1 +2699,1 @@\n-             GENERATE_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY,\n+             GENERATE_VOLATILE_STATIC_VM_STRUCT_ENTRY,\n@@ -2899,1 +2901,1 @@\n-             CHECK_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY,\n+             CHECK_VOLATILE_STATIC_VM_STRUCT_ENTRY,\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -242,0 +242,5 @@\n+    public static final String ADD_VHF = PREFIX + \"ADD_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VHF, \"AddVHF\");\n+    }\n+\n@@ -257,5 +262,0 @@\n-    public static final String ADD_VHF = PREFIX + \"ADD_VHF\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(ADD_VHF, \"AddVHF\");\n-    }\n-\n@@ -445,0 +445,5 @@\n+    public static final String CMP_P = PREFIX + \"CMP_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_P, \"CmpP\");\n+    }\n+\n@@ -450,0 +455,5 @@\n+    public static final String CONV = PREFIX + \"CONV\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CONV, \"Conv\");\n+    }\n+\n@@ -642,0 +652,10 @@\n+    public static final String LOAD_NKLASS = PREFIX + \"LOAD_NKLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_NKLASS, \"LoadNKlass\");\n+    }\n+\n+    public static final String LOAD_KLASS_OR_NKLASS = PREFIX + \"LOAD_KLASS_OR_NKLASS\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(LOAD_KLASS_OR_NKLASS, \"LoadN?Klass\");\n+    }\n+\n@@ -1066,0 +1086,5 @@\n+    public static final String PARTIAL_SUBTYPE_CHECK = PREFIX + \"PARTIAL_SUBTYPE_CHECK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(PARTIAL_SUBTYPE_CHECK, \"PartialSubtypeCheck\");\n+    }\n+\n@@ -2147,0 +2172,10 @@\n+    public static final String X86_TESTI_REG = PREFIX + \"X86_TESTI_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_TESTI_REG, \"testI_reg\");\n+    }\n+\n+    public static final String X86_TESTL_REG = PREFIX + \"X86_TESTL_REG\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_TESTL_REG, \"testL_reg\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":40,"deletions":5,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import compiler.lib.ir_framework.shared.Comparison;\n+import compiler.lib.ir_framework.driver.SuccessOnlyConstraintException;\n@@ -34,0 +34,1 @@\n+import compiler.lib.ir_framework.shared.Comparison;\n@@ -57,1 +58,5 @@\n-        return Constraint.createFailOn(rawIRNode.regex(compilePhase, vmInfo, Comparison.Bound.UPPER), constraintIndex, compilationOutput);\n+        try {\n+            return Constraint.createFailOn(rawIRNode.regex(compilePhase, vmInfo, Comparison.Bound.UPPER), constraintIndex, compilationOutput);\n+        } catch (SuccessOnlyConstraintException e) {\n+            return Constraint.createSuccess();\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/raw\/RawFailOnConstraint.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.Platform;\n@@ -58,0 +59,21 @@\n+    \/\/ Platforms for use in IR preconditions. Please verify that e.g. there is\n+    \/\/ a corresponding use in a jtreg @requires annotation before adding new platforms,\n+    \/\/ as adding non-existent platforms can lead to skipped tests.\n+    private static final List<String> irTestingPlatforms = new ArrayList<String>(Arrays.asList(\n+        \/\/ os.family\n+        \"linux\",\n+        \"mac\",\n+        \"windows\",\n+        \/\/ vm.simpleArch\n+        \"aarch64\",\n+        \"arm\",\n+        \"ppc\",\n+        \"riscv64\",\n+        \"s390\",\n+        \"x64\",\n+        \"x86\",\n+        \/\/ corresponds to vm.bits\n+        \"32-bit\",\n+        \"64-bit\"\n+    ));\n+\n@@ -136,0 +158,9 @@\n+        } else if (irAnno.applyIfPlatform().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatform())) {\n+            printDisableReason(m, \"Constraint not met (applyIfPlatform)\", irAnno.applyIfPlatform(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfPlatformAnd().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatformAnd())) {\n+            printDisableReason(m, \"Not all constraints are met (applyIfPlatformAnd)\", irAnno.applyIfPlatformAnd(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfPlatformOr().length != 0 && !hasAnyRequiredPlatform(irAnno.applyIfPlatformOr())) {\n+            printDisableReason(m, \"None of the constraints are met (applyIfPlatformOr)\", irAnno.applyIfPlatformOr(), ruleIndex, ruleMax);\n+            return false;\n@@ -167,0 +198,1 @@\n+        int platformConstraints = 0;\n@@ -183,0 +215,15 @@\n+        if (irAnno.applyIfPlatform().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatform().length == 2,\n+                                    \"applyIfPlatform expects single platform pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformAnd().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformAnd().length % 2 == 0,\n+                                    \"applyIfPlatformAnd expects more than one platform pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformOr().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformOr().length % 2 == 0,\n+                                    \"applyIfPlatformOr expects more than one platform pair\" + failAt());\n+        }\n@@ -204,0 +251,1 @@\n+        TestFormat.checkNoThrow(platformConstraints <= 1, \"Can only specify one platform constraint\" + failAt());\n@@ -237,0 +285,76 @@\n+    private boolean hasAllRequiredPlatform(String[] andRules) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < andRules.length; i++) {\n+            String platform = andRules[i].trim();\n+            i++;\n+            String value = andRules[i].trim();\n+            returnValue &= checkPlatform(platform, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean hasAnyRequiredPlatform(String[] orRules) {\n+        boolean returnValue = false;\n+        for (int i = 0; i < orRules.length; i++) {\n+            String platform = orRules[i].trim();\n+            i++;\n+            String value = orRules[i].trim();\n+            returnValue |= checkPlatform(platform, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean checkPlatform(String platform, String value) {\n+        if (platform.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty platform\" + failAt());\n+            return false;\n+        }\n+        if (value.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty value for platform \" + platform + failAt());\n+            return false;\n+        }\n+\n+        if (!irTestingPlatforms.contains(platform)) {\n+            TestFormat.failNoThrow(\"Provided platform is not in verified list: \" + platform + failAt());\n+            return false;\n+        }\n+\n+        boolean trueValue = value.contains(\"true\");\n+        boolean falseValue = value.contains(\"false\");\n+\n+        if (!trueValue && !falseValue) {\n+            TestFormat.failNoThrow(\"Provided incorrect value for platform \" + platform + failAt());\n+            return false;\n+        }\n+\n+        String os = \"\";\n+        if (Platform.isLinux()) {\n+            os = \"linux\";\n+        } else if (Platform.isOSX()) {\n+            os = \"mac\";\n+        } else if (Platform.isWindows()) {\n+            os = \"windows\";\n+        }\n+\n+        String arch = \"\";\n+        if (Platform.isAArch64()) {\n+            arch = \"aarch64\";\n+        } else if (Platform.isARM()) {\n+            arch = \"arm\";\n+        } else if (Platform.isPPC()) {\n+            arch = \"ppc\";\n+        } else if (Platform.isRISCV64()) {\n+            arch = \"riscv64\";\n+        } else if (Platform.isS390x()) {\n+            arch = \"s390\";\n+        } else if (Platform.isX64()) {\n+            arch = \"x64\";\n+        } else if (Platform.isX86()) {\n+            arch = \"x86\";\n+        }\n+\n+        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\");\n+\n+        return (trueValue && currentPlatform.contains(platform)) || (falseValue && !currentPlatform.contains(platform));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * @enablePreview\n- * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n@@ -88,1 +86,1 @@\n-            int savedErrno = (int) errnoHandle.get(saveSeg);\n+            int savedErrno = (int) errnoHandle.get(saveSeg, 0L);\n@@ -153,1 +151,1 @@\n-            check = check.andThen(o -> assertEquals(fieldHandle.get(o), value));\n+            check = check.andThen(o -> assertEquals(fieldHandle.get(o, 0L), value));\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      8305975 8304760 8307134 8295894\n+ *      8305975 8304760 8307134 8295894 8314960\n@@ -55,1 +55,1 @@\n-            = \"88:D6:74:27:42:58:D3:C7:40:B2:D7:24:93:4B:09:2D:6C:C1:EB:6A:6D:6A:AD:3D:72:D0:DF:8D:B7:59:99:8E\";\n+            = \"35:5B:BF:02:F8:3E:34:0D:72:01:6C:EB:10:90:CA:A1:DD:B5:01:EF:D8:0C:5B:26:F5:EF:C5:C5:4B:9D:61:3E\";\n@@ -256,0 +256,2 @@\n+            put(\"certignarootca [jdk]\",\n+                    \"D4:8D:3D:23:EE:DB:50:A4:59:E5:51:97:60:1C:27:77:4B:9D:7B:18:C9:4D:5A:05:95:11:A1:02:50:B9:31:68\");\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}