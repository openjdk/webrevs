{"files":[{"patch":"@@ -3148,0 +3148,16 @@\n+void Assembler::vmovw(XMMRegister dst, Register src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x6E, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovw(Register dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x7E, (0xC0 | encode));\n+}\n+\n@@ -7329,0 +7345,16 @@\n+void Assembler::evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(vector_len, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n+void Assembler::evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src) {\n+  assert(VM_Version::supports_avx512_fp16(), \"requires AVX512-FP16\");\n+  InstructionAttr attributes(AVX_128bit, false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_F3, VEX_OPCODE_MAP5, &attributes);\n+  emit_int16(0x58, (0xC0 | encode));\n+}\n+\n@@ -11498,1 +11530,1 @@\n-  \/\/ of form {0F, 0F_38, 0F_3A}\n+  \/\/ of form {0F, 0F_38, 0F_3A, MAP5}\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -551,0 +551,1 @@\n+    VEX_OPCODE_MAP5  = 0x5,\n@@ -1652,0 +1653,3 @@\n+  void vmovw(XMMRegister dst, Register src);\n+  void vmovw(Register dst, XMMRegister src);\n+\n@@ -2399,0 +2403,2 @@\n+  void evaddsh(XMMRegister dst, XMMRegister nds, XMMRegister src);\n+  void evaddph(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -953,0 +953,1 @@\n+    _features &= ~CPU_AVX512_FP16;\n@@ -986,0 +987,1 @@\n+      _features &= ~CPU_AVX512_FP16;\n@@ -3021,0 +3023,3 @@\n+\n+    if (_cpuid_info.sef_cpuid7_edx.bits.avx512_fp16 != 0)\n+      result |= CPU_AVX512_FP16;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1464,0 +1464,7 @@\n+    case Op_AddHF:\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -1737,0 +1744,5 @@\n+    case Op_AddVHF:\n+      if (!VM_Version::supports_avx512_fp16()) {\n+        return false;\n+      }\n+      break;\n@@ -10166,0 +10178,38 @@\n+instruct reinterpretS2H (regF dst, rRegI src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$XMMRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convF2HFAndS2HF (regF dst, regF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ vcvtps2ph($dst$$XMMRegister, $src$$XMMRegister, 0x04, Assembler::AVX_128bit);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct reinterpretH2S (rRegI dst, regF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"vmovw $dst, $src\" %}\n+  ins_encode %{\n+    __ vmovw($dst$$Register, $src$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+instruct addFP16_scalar (regF dst, regF src1, regF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  format %{ \"vaddsh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ evaddsh($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -10167,0 +10217,10 @@\n+instruct vaddVHF (vec dst, vec src1, vec src2)\n+%{\n+  match(Set dst (AddVHF src1 src2));\n+  format %{ \"vaddph $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    __ evaddph($dst$$XMMRegister, $src1$$XMMRegister, $src2$$XMMRegister, vlen_enc);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -4234,1 +4234,1 @@\n-    \"AddVB\",\"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n+    \"AddVB\",\"AddVHF\", \"AddVS\",\"AddVI\",\"AddVL\",\"AddVF\",\"AddVD\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -401,0 +401,1 @@\n+  static void restore_loader_data() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4733,0 +4733,16 @@\n+\/\/ utility function to skip over internal jdk primitive classes used to override the need for passing\n+\/\/ an explict JVM flag EnablePrimitiveClasses.\n+bool ClassFileParser::is_jdk_internal_class(const Symbol* class_name) const {\n+  if (vmSymbols::java_lang_Float16() == class_name) {\n+    return (EnablePrimitiveClasses = true);\n+  }\n+  return false;\n+}\n+\n+bool ClassFileParser::is_jdk_internal_class_sig(const char* sig) const {\n+  if (strstr(sig, vmSymbols::java_lang_Float16_signature()->as_C_string())) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -4763,1 +4779,1 @@\n-  if (is_primitive_class && !EnablePrimitiveClasses) {\n+  if (is_primitive_class && !is_jdk_internal_class(_class_name) && !EnablePrimitiveClasses) {\n@@ -5205,1 +5221,1 @@\n-      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses)) {\n+      if ( (_major_version < 51 \/* CONSTANT_CLASS_DESCRIPTORS *\/ ) || (!EnablePrimitiveClasses && !is_jdk_internal_class_sig(signature))) {\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -223,0 +223,4 @@\n+  bool is_jdk_internal_class(const Symbol* class_name) const;\n+\n+  bool is_jdk_internal_class_sig(const char* sig) const;\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+  do_klass(Float16_klass,                               java_lang_Float16                                     ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,0 +198,6 @@\n+                                                                                                                        \\\n+  \/* Float16 intrinsics, similar to what we have in Math. *\/                                                            \\\n+  do_intrinsic(_sum_float16,              java_lang_Float16,      sum_name,           floa16_float16_signature,  F_S)   \\\n+   do_name(sum_name, \"sum\")                                                                                             \\\n+   do_signature(floa16_float16_signature, \"(Qjava\/lang\/Float16;Qjava\/lang\/Float16;)Qjava\/lang\/Float16;\")                \\\n+                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  template(java_lang_Float16,                         \"java\/lang\/Float16\")                        \\\n+  template(java_lang_Float16_signature,               \"Qjava\/lang\/Float16;\")                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,2 +91,3 @@\n-    \/\/ has been aborted for any reason.\n-    bool yield_if_necessary() {\n+    \/\/ has been aborted for any reason. Yielded is set if there has been an actual\n+    \/\/ yield for a pause.\n+    bool yield_if_necessary(bool& yielded) {\n@@ -95,1 +96,1 @@\n-        _cm->do_yield_check();\n+        yielded = _cm->do_yield_check();\n@@ -125,1 +126,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -193,1 +195,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -213,1 +216,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded = true;\n+        bool mark_aborted = yield_if_necessary(yielded);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -545,0 +545,3 @@\n+  if (vmSymbols::java_lang_Float16() == name()) {\n+    EnablePrimitiveClasses = true;\n+  }\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -134,0 +134,8 @@\n+\/\/------------------------------AddHFNode---------------------------------------\n+\/\/ Add 2 half-precision floats\n+class AddHFNode : public AddFNode {\n+public:\n+  AddHFNode( Node *in1, Node *in2 ) : AddFNode(in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -597,0 +597,3 @@\n+  case vmIntrinsics::_sum_float16:\n+    if (!Matcher::match_rule_supported(Op_AddHF)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -908,0 +908,32 @@\n+\n+const Type* ReinterpretS2HFNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type( in(1) );\n+  \/\/ Convert FP16 constant value to Float constant value, this will allow\n+  \/\/ further constant folding to be done at float granularity by value routines\n+  \/\/ of FP16 IR nodes.\n+  if (type->isa_int() && type->is_int()->is_con()) {\n+     jshort hfval = type->is_int()->get_con();\n+     jfloat fval = StubRoutines::hf2f(hfval);\n+     return TypeF::make(fval);\n+  }\n+  return Type::FLOAT;\n+}\n+\n+Node* ReinterpretS2HFNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReinterpretHF2S) {\n+     assert(in(1)->in(1)->bottom_type()->isa_float(), \"\");\n+     return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+const Type* ReinterpretHF2SNode::Value(PhaseGVN* phase) const {\n+  const Type* type = phase->type( in(1) );\n+  \/\/ Convert Float constant value to FP16 constant value.\n+  if (type->isa_float_constant()) {\n+     jfloat fval = type->is_float_constant()->_f;\n+     jshort hfval = StubRoutines::f2hf(fval);\n+     return TypeInt::make(hfval);\n+  }\n+  return TypeInt::SHORT;\n+}\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -172,0 +172,23 @@\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Short to Half Float\n+class ReinterpretS2HFNode : public Node {\n+  public:\n+  ReinterpretS2HFNode(Node* in1) : Node(0, in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return Type::FLOAT; }\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual uint  ideal_reg() const { return Op_RegF; }\n+};\n+\n+\/\/-----------------------------ReinterpretS2HFNode ---------------------------\n+\/\/ Reinterpret Half Float to Short\n+class ReinterpretHF2SNode : public Node {\n+  public:\n+  ReinterpretHF2SNode( Node *in1 ) : Node(0,in1) {}\n+  virtual int Opcode() const;\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type* bottom_type() const { return TypeInt::SHORT; }\n+  virtual uint  ideal_reg() const { return Op_RegI; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -552,0 +552,1 @@\n+  case vmIntrinsics::_sum_float16:              return inline_fp16_operations(intrinsic_id());\n@@ -5049,0 +5050,28 @@\n+bool LibraryCallKit::inline_fp16_operations(vmIntrinsics::ID id) {\n+  if (!Matcher::match_rule_supported(Op_ReinterpretS2HF) ||\n+      !Matcher::match_rule_supported(Op_ReinterpretHF2S)) {\n+    return false;\n+  }\n+\n+  Node* result = nullptr;\n+  Node* val1 = argument(0);  \/\/ receiver\n+  Node* val2 = argument(1);  \/\/ argument\n+  assert(val1->is_InlineType() && val2->is_InlineType(), \"\");\n+\n+  Node* fld1 = _gvn.transform(new ReinterpretS2HFNode(val1->as_InlineType()->field_value(0)));\n+  Node* fld2 = _gvn.transform(new ReinterpretS2HFNode(val2->as_InlineType()->field_value(0)));\n+\n+  switch (id) {\n+  case vmIntrinsics::_sum_float16:   result = _gvn.transform(new AddHFNode(fld1, fld2)); break;\n+\n+  default:\n+    fatal_unexpected_iid(id);\n+    break;\n+  }\n+  InlineTypeNode* box = InlineTypeNode::make_uninitialized(_gvn, val1->as_InlineType()->inline_klass(), true);\n+  Node* short_result  = _gvn.transform(new ReinterpretHF2SNode(result));\n+  box->set_field_value(0, short_result);\n+  set_result(_gvn.transform(box));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -310,0 +310,1 @@\n+  bool inline_fp16_operations(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2774,0 +2774,7 @@\n+      } else if (opc == Op_ReinterpretS2HF || opc == Op_ReinterpretHF2S) {\n+        assert(n->req() == 2, \"only one input expected\");\n+        BasicType bt = velt_basic_type(n);\n+        const TypeVect* vt = TypeVect::make(bt, vlen);\n+        Node* in = vector_opd(p, 1);\n+        vn = VectorReinterpretNode::make(in, vt, vt);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n@@ -3495,0 +3502,3 @@\n+  if (VectorNode::is_float16_node(n->Opcode())) {\n+    return TypeInt::SHORT;\n+  }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1422,0 +1422,1 @@\n+  declare_c2_type(AddHFNode, AddNode)                                     \\\n@@ -1440,0 +1441,2 @@\n+  declare_c2_type(ReinterpretS2HFNode, Node)                              \\\n+  declare_c2_type(ReinterpretHF2SNode, Node)                              \\\n@@ -1698,0 +1701,1 @@\n+  declare_c2_type(AddVHFNode, VectorNode)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,0 +222,5 @@\n+    public static final String ADD_HF = PREFIX + \"ADD_HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_HF, \"AddHF\");\n+    }\n+\n@@ -237,0 +242,5 @@\n+    public static final String ADD_VHF = PREFIX + \"ADD_VHF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(ADD_VHF, \"AddVHF\");\n+    }\n+\n@@ -1129,0 +1139,10 @@\n+    public static final String REINTERPRET_S2HF = PREFIX + \"REINTERPRET_S2HF\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_S2HF, \"ReinterpretS2HF\");\n+    }\n+\n+    public static final String REINTERPRET_HF2S = PREFIX + \"REINTERPRET_HF2S\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(REINTERPRET_HF2S, \"ReinterpretHF2S\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import compiler.lib.ir_framework.IRNode;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/irrule\/constraint\/raw\/RawFailOnConstraint.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+        \"avx512_fp16\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck) {}\n+    private record SaveValuesCase(String nativeTarget, FunctionDescriptor nativeDesc, boolean trivial, String threadLocalName, Consumer<Object> resultCheck) {}\n@@ -68,2 +68,6 @@\n-        Linker.Option stl = Linker.Option.captureCallState(testCase.threadLocalName());\n-        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), stl);\n+        List<Linker.Option> options = new ArrayList<>();\n+        options.add(Linker.Option.captureCallState(testCase.threadLocalName()));\n+        if (testCase.trivial()) {\n+            options.add(Linker.Option.isTrivial());\n+        }\n+        MethodHandle handle = downcallHandle(testCase.nativeTarget(), testCase.nativeDesc(), options.toArray(Linker.Option[]::new));\n@@ -102,0 +106,4 @@\n+    interface CaseAdder {\n+      void addCase(String nativeTarget, FunctionDescriptor nativeDesc, String threadLocalName, Consumer<Object> resultCheck);\n+    }\n+\n@@ -105,0 +113,4 @@\n+        CaseAdder adder = (nativeTarget, nativeDesc, threadLocalName, resultCheck) -> {\n+          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, false, threadLocalName, resultCheck));\n+          cases.add(new SaveValuesCase(nativeTarget, nativeDesc, true, threadLocalName, resultCheck));\n+        };\n@@ -106,16 +118,16 @@\n-        cases.add(new SaveValuesCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {}));\n-        cases.add(new SaveValuesCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42)));\n-        cases.add(new SaveValuesCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0)));\n-\n-        cases.add(structCase(\"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L)));\n-        cases.add(structCase(\"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                           JAVA_LONG.withName(\"y\"), 42L)));\n-        cases.add(structCase(\"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n-                                            JAVA_LONG.withName(\"y\"), 42L,\n-                                            JAVA_LONG.withName(\"z\"), 42L)));\n-        cases.add(structCase(\"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D)));\n-        cases.add(structCase(\"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                           JAVA_DOUBLE.withName(\"y\"), 42D)));\n-        cases.add(structCase(\"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"y\"), 42D,\n-                                            JAVA_DOUBLE.withName(\"z\"), 42D)));\n+        adder.addCase(\"set_errno_V\", FunctionDescriptor.ofVoid(JAVA_INT), \"errno\", o -> {});\n+        adder.addCase(\"set_errno_I\", FunctionDescriptor.of(JAVA_INT, JAVA_INT), \"errno\", o -> assertEquals((int) o, 42));\n+        adder.addCase(\"set_errno_D\", FunctionDescriptor.of(JAVA_DOUBLE, JAVA_INT), \"errno\", o -> assertEquals((double) o, 42.0));\n+\n+        structCase(adder, \"SL\",  Map.of(JAVA_LONG.withName(\"x\"), 42L));\n+        structCase(adder, \"SLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                         JAVA_LONG.withName(\"y\"), 42L));\n+        structCase(adder, \"SLLL\", Map.of(JAVA_LONG.withName(\"x\"), 42L,\n+                                         JAVA_LONG.withName(\"y\"), 42L,\n+                                         JAVA_LONG.withName(\"z\"), 42L));\n+        structCase(adder, \"SD\",  Map.of(JAVA_DOUBLE.withName(\"x\"), 42D));\n+        structCase(adder, \"SDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                         JAVA_DOUBLE.withName(\"y\"), 42D));\n+        structCase(adder, \"SDDD\", Map.of(JAVA_DOUBLE.withName(\"x\"), 42D,\n+                                         JAVA_DOUBLE.withName(\"y\"), 42D,\n+                                         JAVA_DOUBLE.withName(\"z\"), 42D));\n@@ -124,2 +136,2 @@\n-            cases.add(new SaveValuesCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {}));\n-            cases.add(new SaveValuesCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {}));\n+            adder.addCase(\"SetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"GetLastError\", o -> {});\n+            adder.addCase(\"WSASetLastError\", FunctionDescriptor.ofVoid(JAVA_INT), \"WSAGetLastError\", o -> {});\n@@ -131,1 +143,1 @@\n-    static SaveValuesCase structCase(String name, Map<MemoryLayout, Object> fields) {\n+    static void structCase(CaseAdder adder, String name, Map<MemoryLayout, Object> fields) {\n@@ -142,1 +154,1 @@\n-        return new SaveValuesCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n+        adder.addCase(\"set_errno_\" + name, FunctionDescriptor.of(layout, JAVA_INT), \"errno\", check);\n","filename":"test\/jdk\/java\/foreign\/capturecallstate\/TestCaptureCallState.java","additions":35,"deletions":23,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    private static final int COUNT = 97;\n+    private static final int COUNT = 96;\n","filename":"test\/jdk\/sun\/security\/lib\/cacerts\/VerifyCACerts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}