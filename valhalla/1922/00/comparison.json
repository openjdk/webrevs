{"files":[{"patch":"@@ -68,1 +68,2 @@\n-      ciType* type = vt->field_type(i);\n+      ciField* field = vt->field(i);\n+      ciType* type = field->type();\n@@ -71,1 +72,1 @@\n-        int field_offset = vt->field_offset(i) - vk->payload_offset();\n+        int field_offset = field->offset_in_bytes() - vk->payload_offset();\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/cardTableBarrierSetC2.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    ciType* type = vt->field_type(i);\n+    ciType* type = vt->field(i)->type();\n@@ -89,1 +89,3 @@\n-    bool no_circularity = !gvn->C->has_circular_inline_type() || field_is_flat(i);\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    bool no_circularity = !gvn->C->has_circular_inline_type() || field->is_flat();\n@@ -220,0 +222,2 @@\n+  ciField* field = this->field(index);\n+  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n@@ -221,2 +225,2 @@\n-  if (!recursive || !field_is_flat(index) || value->is_top()) {\n-    assert(offset == field_offset(index), \"offset mismatch\");\n+  if (!recursive || !field->is_flat() || value->is_top()) {\n+    assert(offset == field->offset_in_bytes(), \"offset mismatch\");\n@@ -228,1 +232,2 @@\n-  if (offset == field_null_marker_offset(index)) {\n+  assert(field->is_flat(), \"must be flat\");\n+  if (offset == field->null_marker_offset()) {\n@@ -231,1 +236,1 @@\n-    int sub_offset = offset - field_offset(index); \/\/ Offset of the flattened field inside the declared field\n+    int sub_offset = offset - field->offset_in_bytes(); \/\/ Offset of the flattened field inside the declared field\n@@ -246,5 +251,0 @@\n-int InlineTypeNode::field_offset(uint index) const {\n-  assert(index < field_count(), \"index out of bounds\");\n-  return inline_klass()->declared_nonstatic_field_at(index)->offset_in_bytes();\n-}\n-\n@@ -253,1 +253,1 @@\n-  for (; i < field_count() && field_offset(i) != offset; i++) { }\n+  for (; i < field_count() && field(i)->offset_in_bytes() != offset; i++) { }\n@@ -258,20 +258,1 @@\n-ciType* InlineTypeNode::field_type(uint index) const {\n-  assert(index < field_count(), \"index out of bounds\");\n-  return inline_klass()->declared_nonstatic_field_at(index)->type();\n-}\n-\n-bool InlineTypeNode::field_is_flat(uint index) const {\n-  assert(index < field_count(), \"index out of bounds\");\n-  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n-  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n-  return field->is_flat();\n-}\n-\n-bool InlineTypeNode::field_is_null_free(uint index) const {\n-  assert(index < field_count(), \"index out of bounds\");\n-  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n-  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n-  return field->is_null_free();\n-}\n-\n-bool InlineTypeNode::field_is_volatile(uint index) const {\n+ciField* InlineTypeNode::field(uint index) const {\n@@ -279,10 +260,1 @@\n-  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n-  assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n-  return field->is_volatile();\n-}\n-\n-int InlineTypeNode::field_null_marker_offset(uint index) const {\n-  assert(index < field_count(), \"index out of bounds\");\n-  ciField* field = inline_klass()->declared_nonstatic_field_at(index);\n-  assert(field->is_flat(), \"must be an inline type\");\n-  return field->null_marker_offset();\n+  return inline_klass()->declared_nonstatic_field_at(index);\n@@ -295,1 +267,3 @@\n-    if (field_is_flat(i)) {\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    if (field->is_flat()) {\n@@ -298,1 +272,1 @@\n-      if (!field_is_null_free(i)) {\n+      if (!field->is_null_free()) {\n@@ -430,1 +404,2 @@\n-    ciType* ft = field_type(i);\n+    ciField* field = this->field(i);\n+    ciType* ft = field->type();\n@@ -432,1 +407,2 @@\n-      if (!field_is_flat(i) && visited.contains(ft)) {\n+      assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+      if (!field->is_flat() && visited.contains(ft)) {\n@@ -461,1 +437,3 @@\n-    int field_off = field_offset(i) - vk->payload_offset();\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    int field_off = field->offset_in_bytes() - vk->payload_offset();\n@@ -464,3 +442,3 @@\n-    ciType* ft = field_type(i);\n-    bool field_null_free = field_is_null_free(i);\n-    if (field_is_flat(i)) {\n+    ciType* ft = field->type();\n+    bool field_null_free = field->is_null_free();\n+    if (field->is_flat()) {\n@@ -612,1 +590,3 @@\n-    int field_off = field_offset(i) - vk->payload_offset();\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    int field_off = field->offset_in_bytes() - vk->payload_offset();\n@@ -614,2 +594,2 @@\n-    bool field_null_free = field_is_null_free(i);\n-    ciType* ft = field_type(i);\n+    bool field_null_free = field->is_null_free();\n+    ciType* ft = field->type();\n@@ -617,1 +597,1 @@\n-    if (field_is_flat(i)) {\n+    if (field->is_flat()) {\n@@ -679,1 +659,1 @@\n-    ciType* ft = field_type(i);\n+    ciType* ft = field(i)->type();\n@@ -702,1 +682,2 @@\n-    int field_off = field_offset(i);\n+    ciField* field = this->field(i);\n+    int field_off = field->offset_in_bytes();\n@@ -708,1 +689,1 @@\n-    ciType* ft = field_type(i);\n+    ciType* ft = field->type();\n@@ -721,1 +702,1 @@\n-      if (field_is_flat(i)) {\n+      if (field->is_flat()) {\n@@ -736,1 +717,3 @@\n-      if (!field_is_null_free(i)) {\n+      ciField* field = this->field(i);\n+      assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+      if (!field->is_null_free()) {\n@@ -738,1 +721,1 @@\n-        if (field_is_flat(i)) {\n+        if (field->is_flat()) {\n@@ -775,1 +758,1 @@\n-      this_field->as_InlineType()->check_substitutability(igvn, region, phi, ctrl, mem, other_base, other_field, field_is_flat(i));\n+      this_field->as_InlineType()->check_substitutability(igvn, region, phi, ctrl, mem, other_base, other_field, field->is_flat());\n@@ -912,1 +895,3 @@\n-    if (field_is_flat(i)) {\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    if (field->is_flat()) {\n@@ -916,1 +901,1 @@\n-      if (!field_is_null_free(i)) {\n+      if (!field->is_null_free()) {\n@@ -923,1 +908,1 @@\n-    replace_proj(C, call, proj_idx, value, field_type(i)->basic_type());\n+    replace_proj(C, call, proj_idx, value, field->type()->basic_type());\n@@ -930,2 +915,4 @@\n-     Node* value = field_value(i);\n-     if (field_is_flat(i)) {\n+    Node* value = field_value(i);\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+     if (field->is_flat()) {\n@@ -1053,1 +1040,3 @@\n-    ciType* ft = vt->field_type(i);\n+    ciField* field = vt->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    ciType* ft = field->type();\n@@ -1055,1 +1044,1 @@\n-    if (!vt->field_is_flat(i) && visited.contains(ft)) {\n+    if (!field->is_flat() && visited.contains(ft)) {\n@@ -1061,1 +1050,1 @@\n-      if (vt->field_is_null_free(i)) {\n+      if (field->is_null_free()) {\n@@ -1082,1 +1071,3 @@\n-    if (field_is_null_free(i)) {\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    if (field->is_null_free()) {\n@@ -1085,1 +1076,1 @@\n-      if (!value->is_InlineType() || !value->as_InlineType()->is_all_zero(gvn) || (flat && !field_is_flat(i))) {\n+      if (!value->is_InlineType() || !value->as_InlineType()->is_all_zero(gvn) || (flat && !field->is_flat())) {\n@@ -1336,1 +1327,2 @@\n-    int offset = holder_offset + field_offset(i);\n+    ciField* field = this->field(i);\n+    int offset = holder_offset + field->offset_in_bytes();\n@@ -1339,0 +1331,1 @@\n+      assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n@@ -1342,1 +1335,1 @@\n-      } else if (field_is_flat(i) && vt->is_InlineType()) {\n+      } else if (field->is_flat() && vt->is_InlineType()) {\n@@ -1395,1 +1388,3 @@\n-    if (field_is_flat(i)) {\n+    ciField* field = this->field(i);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    if (field->is_flat()) {\n@@ -1398,2 +1393,2 @@\n-      if (!field_is_null_free(i)) {\n-        assert(field_null_marker_offset(i) != -1, \"inconsistency\");\n+      if (!field->is_null_free()) {\n+        assert(field->null_marker_offset() != -1, \"inconsistency\");\n@@ -1411,1 +1406,1 @@\n-      if (field_type(i)->size() == 2) {\n+      if (field->type()->size() == 2) {\n@@ -1456,1 +1451,2 @@\n-    ciType* type = field_type(i);\n+    ciField* field = this->field(i);\n+    ciType* type = field->type();\n@@ -1458,1 +1454,2 @@\n-    if (field_is_flat(i)) {\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    if (field->is_flat()) {\n@@ -1460,1 +1457,1 @@\n-      InlineTypeNode* vt = make_uninitialized(gvn, type->as_inline_klass(), field_is_null_free(i));\n+      InlineTypeNode* vt = make_uninitialized(gvn, type->as_inline_klass(), field->is_null_free());\n@@ -1462,2 +1459,2 @@\n-      if (!field_is_null_free(i)) {\n-        assert(field_null_marker_offset(i) != -1, \"inconsistency\");\n+      if (!field->is_null_free()) {\n+        assert(field->null_marker_offset() != -1, \"inconsistency\");\n@@ -1485,1 +1482,1 @@\n-      bool null_free = field_is_null_free(i);\n+      bool null_free = field->is_null_free();\n@@ -1580,1 +1577,2 @@\n-    ciType* ft = vt->field_type(i);\n+    ciField* field = vt->field(i);\n+    ciType* ft = field->type();\n@@ -1582,1 +1580,2 @@\n-    if (!vt->field_is_flat(i) && visited.contains(ft)) {\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    if (!field->is_flat() && visited.contains(ft)) {\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":84,"deletions":85,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -121,0 +121,1 @@\n+  ciField*      field(uint index) const;\n@@ -125,1 +126,0 @@\n-  int           field_offset(uint index) const;\n@@ -127,5 +127,0 @@\n-  ciType*       field_type(uint index) const;\n-  bool          field_is_flat(uint index) const;\n-  bool          field_is_null_free(uint index) const;\n-  bool          field_is_volatile(uint index) const;\n-  int           field_null_marker_offset(uint index) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -629,2 +629,3 @@\n-    ciType* field_type = vt->field_type(i);\n-    int field_offset_in_element = offset_in_element + vt->field_offset(i) - vk->payload_offset();\n+    ciField* field = vt->field(i);\n+    ciType* field_type = field->type();\n+    int field_offset_in_element = offset_in_element + field->offset_in_bytes() - vk->payload_offset();\n@@ -632,2 +633,3 @@\n-    if (vt->field_is_flat(i)) {\n-      field_value = inline_type_from_mem(field_type->as_inline_klass(), elem_adr_type, elem_idx, field_offset_in_element, vt->field_is_null_free(i), alloc, sfpt);\n+    assert(!field->is_flat() || field->type()->is_inlinetype(), \"must be an inline type\");\n+    if (field->is_flat()) {\n+      field_value = inline_type_from_mem(field_type->as_inline_klass(), elem_adr_type, elem_idx, field_offset_in_element, field->is_null_free(), alloc, sfpt);\n@@ -764,1 +766,1 @@\n-              if (vt->field_value(i) == use && !vt->field_is_flat(i)) {\n+              if (vt->field_value(i) == use && !vt->field(i)->is_flat()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}