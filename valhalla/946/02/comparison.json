{"files":[{"patch":"@@ -590,1 +590,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -637,1 +636,0 @@\n-  case T_PRIMITIVE_OBJECT:\n@@ -704,1 +702,0 @@\n-  case T_PRIMITIVE_OBJECT:\n@@ -747,1 +744,1 @@\n-    if (src->type() == T_OBJECT || src->type() == T_PRIMITIVE_OBJECT) {\n+    if (src->type() == T_OBJECT) {\n@@ -847,1 +844,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -977,1 +973,1 @@\n-  if (addr->base()->type() == T_OBJECT || addr->base()->type() == T_PRIMITIVE_OBJECT) {\n+  if (addr->base()->type() == T_OBJECT) {\n@@ -1001,1 +997,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1266,1 +1261,1 @@\n-  if (UseSlowPath || op->type() == T_PRIMITIVE_OBJECT ||\n+  if (UseSlowPath || op->is_null_free() ||\n@@ -2150,1 +2145,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -2319,1 +2313,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -2356,1 +2349,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -3394,1 +3386,0 @@\n-  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1190,1 +1190,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n@@ -1224,5 +1224,1 @@\n-  if (x->is_null_free()) {\n-    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_PRIMITIVE_OBJECT, klass_reg, slow_path);\n-  } else {\n-    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n-  }\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n@@ -91,1 +90,0 @@\n-  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6563,1 +6563,1 @@\n-  assert(sig->at(sig_index)._bt == T_PRIMITIVE_OBJECT, \"should be at end delimiter\");\n+  assert(sig->at(sig_index)._bt == T_METADATA, \"should be at delimiter\");\n@@ -6594,1 +6594,1 @@\n-  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_PRIMITIVE_OBJECT);\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_OBJECT);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-       if (bt == T_PRIMITIVE_OBJECT) {\n+       if (bt == T_METADATA) {\n@@ -500,1 +500,1 @@\n-         \/\/ T_PRIMITIVE_OBJECT, followed by the types of the fields of the\n+         \/\/ T_METADATA, followed by the types of the fields of the\n@@ -505,3 +505,3 @@\n-         \/\/ T_PRIMITIVE_OBJECT T_INT T_PRIMITIVE_OBJECT T_INT T_LONG T_VOID (second\n-         \/\/ slot for the T_LONG) T_VOID (inner T_PRIMITIVE_OBJECT) T_VOID\n-         \/\/ (outer T_PRIMITIVE_OBJECT)\n+         \/\/ T_METADATA T_INT T_METADATA T_INT T_LONG T_VOID (second\n+         \/\/ slot for the T_LONG) T_VOID (inner inline type) T_VOID\n+         \/\/ (outer inline type)\n@@ -514,1 +514,1 @@\n-           if (bt == T_PRIMITIVE_OBJECT) {\n+           if (bt == T_METADATA) {\n@@ -652,1 +652,1 @@\n-      has_inline_argument = (sig_extended->at(i)._bt == T_PRIMITIVE_OBJECT);\n+      has_inline_argument = (sig_extended->at(i)._bt == T_METADATA);\n@@ -714,1 +714,1 @@\n-  \/\/ sig_extended, an inline type argument starts with: T_PRIMITIVE_OBJECT,\n+  \/\/ sig_extended, an inline type argument starts with: T_METADATA,\n@@ -717,1 +717,1 @@\n-  \/\/ T_PRIMITIVE_OBJECT\/T_VOID. next_vt_arg is the next inline type argument:\n+  \/\/ T_METADATA\/T_VOID. next_vt_arg is the next inline type argument:\n@@ -728,1 +728,1 @@\n-    if (!InlineTypePassFieldsAsArgs || bt != T_PRIMITIVE_OBJECT) {\n+    if (!InlineTypePassFieldsAsArgs || bt != T_METADATA) {\n@@ -746,1 +746,1 @@\n-      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_PRIMITIVE_OBJECT);\n+      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_OBJECT);\n@@ -761,1 +761,1 @@\n-        if (bt == T_PRIMITIVE_OBJECT) {\n+        if (bt == T_METADATA) {\n@@ -896,2 +896,0 @@\n-\n-    assert(bt != T_PRIMITIVE_OBJECT, \"i2c adapter doesn't unpack inline typ args\");\n@@ -3435,1 +3433,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n@@ -3477,1 +3475,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    if (const_opr->type() == T_OBJECT || const_opr->type() == T_PRIMITIVE_OBJECT) {\n+    if (const_opr->type() == T_OBJECT) {\n@@ -640,1 +640,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -731,1 +730,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -773,1 +771,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -862,1 +859,1 @@\n-    if (src->type() == T_OBJECT || src->type() == T_PRIMITIVE_OBJECT) {\n+    if (src->type() == T_OBJECT) {\n@@ -1048,1 +1045,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1221,1 +1217,1 @@\n-  if (addr->base()->type() == T_OBJECT || addr->base()->type() == T_PRIMITIVE_OBJECT) {\n+  if (addr->base()->type() == T_OBJECT) {\n@@ -1282,1 +1278,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1659,1 +1654,1 @@\n-  if (UseSlowPath || op->type() == T_PRIMITIVE_OBJECT ||\n+  if (UseSlowPath || op->is_null_free() ||\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path);\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, elem_type, klass_reg, slow_path, false);\n@@ -1403,5 +1403,1 @@\n-  if (x->is_null_free()) {\n-    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_PRIMITIVE_OBJECT, klass_reg, slow_path);\n-  } else {\n-    __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path);\n-  }\n+  __ allocate_array(reg, len, tmp1, tmp2, tmp3, tmp4, T_OBJECT, klass_reg, slow_path, x->is_null_free());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n@@ -115,1 +114,0 @@\n-  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -517,1 +517,0 @@\n-  assert(type != T_PRIMITIVE_OBJECT, \"Not supported yet\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6348,1 +6348,1 @@\n-  assert(sig->at(sig_index)._bt == T_PRIMITIVE_OBJECT, \"should be at end delimiter\");\n+  assert(sig->at(sig_index)._bt == T_METADATA, \"should be at delimiter\");\n@@ -6375,1 +6375,1 @@\n-  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_PRIMITIVE_OBJECT);\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_OBJECT);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -695,1 +695,1 @@\n-      if (bt == T_PRIMITIVE_OBJECT) {\n+      if (bt == T_METADATA) {\n@@ -697,1 +697,1 @@\n-        \/\/ T_PRIMITIVE_OBJECT, followed by the types of the fields of the\n+        \/\/ T_METADATA, followed by the types of the fields of the\n@@ -702,3 +702,3 @@\n-        \/\/ T_PRIMITIVE_OBJECT T_INT T_PRIMITIVE_OBJECT T_INT T_LONG T_VOID (second\n-        \/\/ slot for the T_LONG) T_VOID (inner T_PRIMITIVE_OBJECT) T_VOID\n-        \/\/ (outer T_PRIMITIVE_OBJECT)\n+        \/\/ T_METADATA T_INT T_METADATA T_INT T_LONG T_VOID (second\n+        \/\/ slot for the T_LONG) T_VOID (inner inline type) T_VOID\n+        \/\/ (outer inline type)\n@@ -711,1 +711,1 @@\n-          if (bt == T_PRIMITIVE_OBJECT) {\n+          if (bt == T_METADATA) {\n@@ -841,1 +841,1 @@\n-      has_inline_argument = (sig_extended->at(i)._bt == T_PRIMITIVE_OBJECT);\n+      has_inline_argument = (sig_extended->at(i)._bt == T_METADATA);\n@@ -919,1 +919,1 @@\n-  \/\/ sig_extended, an inline type argument starts with: T_PRIMITIVE_OBJECT,\n+  \/\/ sig_extended, an inline type argument starts with: T_METADATA,\n@@ -922,1 +922,1 @@\n-  \/\/ T_PRIMITIVE_OBJECT\/T_VOID. next_vt_arg is the next inline type argument:\n+  \/\/ T_METADATA\/T_VOID. next_vt_arg is the next inline type argument:\n@@ -933,1 +933,1 @@\n-    if (!InlineTypePassFieldsAsArgs || bt != T_PRIMITIVE_OBJECT) {\n+    if (!InlineTypePassFieldsAsArgs || bt != T_METADATA) {\n@@ -951,1 +951,1 @@\n-      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_PRIMITIVE_OBJECT);\n+      int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_OBJECT);\n@@ -966,1 +966,1 @@\n-        if (bt == T_PRIMITIVE_OBJECT) {\n+        if (bt == T_METADATA) {\n@@ -1136,1 +1136,0 @@\n-    assert(bt != T_PRIMITIVE_OBJECT, \"i2c adapter doesn't unpack inline type args\");\n@@ -4032,1 +4031,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n@@ -4076,1 +4075,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    if (t == T_ARRAY || t == T_PRIMITIVE_OBJECT) {\n+    if (t == T_ARRAY) {\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -157,1 +156,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -1517,1 +1515,1 @@\n-void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub) {\n+void LIR_List::allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool is_null_free) {\n@@ -1527,1 +1525,2 @@\n-                           stub));\n+                           stub,\n+                           is_null_free));\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -341,1 +341,0 @@\n-      case T_PRIMITIVE_OBJECT:  \/\/ fall through\n@@ -491,1 +490,0 @@\n-  case T_PRIMITIVE_OBJECT:  \/\/ fall through\n@@ -683,1 +681,0 @@\n-      case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -788,1 +785,0 @@\n-      case T_PRIMITIVE_OBJECT: \/\/ fall through\n@@ -1858,0 +1854,1 @@\n+  bool      _is_null_free;\n@@ -1860,1 +1857,1 @@\n-  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub)\n+  LIR_OpAllocArray(LIR_Opr klass, LIR_Opr len, LIR_Opr result, LIR_Opr t1, LIR_Opr t2, LIR_Opr t3, LIR_Opr t4, BasicType type, CodeStub* stub, bool is_null_free)\n@@ -1869,1 +1866,2 @@\n-    , _stub(stub) {}\n+    , _stub(stub)\n+    , _is_null_free(is_null_free) {}\n@@ -1880,0 +1878,1 @@\n+  bool      is_null_free() const                 { return _is_null_free;}\n@@ -2445,1 +2444,1 @@\n-  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub);\n+  void allocate_array(LIR_Opr dst, LIR_Opr len, LIR_Opr t1,LIR_Opr t2, LIR_Opr t3,LIR_Opr t4, BasicType type, LIR_Opr klass, CodeStub* stub, bool is_null_free);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3166,1 +3166,0 @@\n-    assert(addr->type() != T_PRIMITIVE_OBJECT, \"not supported yet\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,1 +138,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ Fall through\n@@ -159,1 +158,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall through\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    ciInstanceKlass(name, loader, protection_domain, T_PRIMITIVE_OBJECT) {}\n+    ciInstanceKlass(name, loader, protection_domain, T_OBJECT) {}\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-    case T_PRIMITIVE_OBJECT:  \/\/ fall through\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -773,1 +773,0 @@\n-    case T_PRIMITIVE_OBJECT: \/\/ fall-through\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1437,1 +1437,0 @@\n-  if (bt == T_PRIMITIVE_OBJECT)   return T_OBJECT;\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-    if (element_type == T_OBJECT || element_type == T_PRIMITIVE_OBJECT) {\n+    if (element_type == T_OBJECT) {\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1094,1 +1094,0 @@\n-      case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  _basic_type = k->is_array_klass() ? T_ARRAY : (k->is_inline_klass() ? T_PRIMITIVE_OBJECT : T_OBJECT);\n+  _basic_type = k->is_array_klass() ? T_ARRAY : T_OBJECT;\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  assert(bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT, \"or we shouldn't be here\");\n+  assert(bt == T_OBJECT, \"or we shouldn't be here\");\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,2 +228,2 @@\n-\/\/ The list of basic types that is returned starts with a T_PRIMITIVE_OBJECT\n-\/\/ and ends with an extra T_VOID. T_PRIMITIVE_OBJECT\/T_VOID pairs are used as\n+\/\/ The list of basic types that is returned starts with a T_METADATA\n+\/\/ and ends with an extra T_VOID. T_METADATA\/T_VOID pairs are used as\n@@ -232,1 +232,1 @@\n-\/\/ with a T_PRIMITIVE_OBJECT and ends with a T_VOID. This is so we can\n+\/\/ with a T_METADATA and ends with a T_VOID. This is so we can\n@@ -236,1 +236,1 @@\n-\/\/ T_PRIMITIVE_OBJECT, drop everything until and including the closing\n+\/\/ T_METADATA, drop everything until and including the closing\n@@ -238,1 +238,1 @@\n-\/\/ types is an argument: drop all T_PRIMITIVE_OBJECT\/T_VOID from the list).\n+\/\/ types is an argument: drop all T_METADATA\/T_VOID from the list).\n@@ -241,1 +241,1 @@\n-  SigEntry::add_entry(sig, T_PRIMITIVE_OBJECT, name(), base_off);\n+  SigEntry::add_entry(sig, T_METADATA, name(), base_off);\n@@ -263,1 +263,1 @@\n-  assert(sig->at(0)._bt == T_PRIMITIVE_OBJECT && sig->at(sig->length()-1)._bt == T_VOID, \"broken structure\");\n+  assert(sig->at(0)._bt == T_METADATA && sig->at(sig->length()-1)._bt == T_VOID, \"broken structure\");\n@@ -363,1 +363,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n@@ -391,1 +391,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n@@ -415,1 +415,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2358,1 +2358,1 @@\n-  \/\/ Search through signature and check if argument is wrapped in T_PRIMITIVE_OBJECT\/T_VOID\n+  \/\/ Search through signature and check if argument is wrapped in T_METADATA\/T_VOID\n@@ -2363,1 +2363,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -429,3 +429,0 @@\n-      if (bt == T_PRIMITIVE_OBJECT) {\n-        bt = T_OBJECT;\n-      }\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-      push_node(T_PRIMITIVE_OBJECT, retnode);\n+      push_node(T_OBJECT, retnode);\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1305,1 +1305,0 @@\n-    case T_PRIMITIVE_OBJECT : \/\/ fall through\n@@ -1617,1 +1616,1 @@\n-  if (((bt == T_OBJECT || bt == T_PRIMITIVE_OBJECT) && C->do_escape_analysis()) || C->eliminate_boxing()) {\n+  if (((bt == T_OBJECT) && C->do_escape_analysis()) || C->eliminate_boxing()) {\n@@ -1834,1 +1833,0 @@\n-  assert(elembt != T_PRIMITIVE_OBJECT, \"inline types are not supported by this method\");\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -743,1 +743,1 @@\n-  Node* oop = (vk->is_empty() && vk->is_initialized()) ? default_oop(gvn, vk) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n+  Node* oop = (vk->is_empty() && vk->is_initialized()) ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n@@ -763,1 +763,1 @@\n-  Node* oop = vk->is_initialized() ? default_oop(gvn, vk) : gvn.zerocon(T_PRIMITIVE_OBJECT);\n+  Node* oop = vk->is_initialized() ? default_oop(gvn, vk) : gvn.zerocon(T_OBJECT);\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n+  case vmIntrinsics::_getValue:                 return inline_unsafe_access(!is_store, T_OBJECT,   Relaxed, false, true);\n@@ -348,1 +348,1 @@\n-  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_PRIMITIVE_OBJECT,Relaxed, false);\n+  case vmIntrinsics::_putValue:                 return inline_unsafe_access( is_store, T_OBJECT,   Relaxed, false, true);\n@@ -2036,1 +2036,1 @@\n-    } else if (type == T_OBJECT || type == T_PRIMITIVE_OBJECT) {\n+    } else if (type == T_OBJECT) {\n@@ -2276,1 +2276,1 @@\n-bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned) {\n+bool LibraryCallKit::inline_unsafe_access(bool is_store, const BasicType type, const AccessKind kind, const bool unaligned, const bool is_flat) {\n@@ -2300,2 +2300,2 @@\n-      assert(rtype == type || (rtype == T_OBJECT && type == T_PRIMITIVE_OBJECT), \"getter must return the expected value\");\n-      assert(sig->count() == 2 || (type == T_PRIMITIVE_OBJECT && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n+      assert(rtype == type, \"getter must return the expected value\");\n+      assert(sig->count() == 2 || (is_flat && sig->count() == 3), \"oop getter has 2 or 3 arguments\");\n@@ -2307,1 +2307,1 @@\n-      assert(sig->count() == 3 || (type == T_PRIMITIVE_OBJECT && sig->count() == 4), \"oop putter has 3 arguments\");\n+      assert(sig->count() == 3 || (is_flat && sig->count() == 4), \"oop putter has 3 arguments\");\n@@ -2311,1 +2311,1 @@\n-      assert(vtype == type || (type == T_PRIMITIVE_OBJECT && vtype == T_OBJECT), \"putter must accept the expected value\");\n+      assert(vtype == type, \"putter must accept the expected value\");\n@@ -2335,1 +2335,1 @@\n-  if (type == T_PRIMITIVE_OBJECT) {\n+  if (is_flat) {\n@@ -2365,1 +2365,1 @@\n-          if (bt == T_ARRAY || bt == T_NARROWOOP || (bt == T_PRIMITIVE_OBJECT && !field->is_flat())) {\n+          if (bt == T_ARRAY || bt == T_NARROWOOP) {\n@@ -2368,1 +2368,1 @@\n-          if (bt == type && (bt != T_PRIMITIVE_OBJECT || field->type() == inline_klass)) {\n+          if (bt == type && (field->is_flat() || field->type() == inline_klass)) {\n@@ -2416,1 +2416,1 @@\n-  Node* val = is_store ? argument(4 + (type == T_PRIMITIVE_OBJECT ? 1 : 0)) : nullptr;\n+  Node* val = is_store ? argument(4 + (is_flat ? 1 : 0)) : nullptr;\n@@ -2454,4 +2454,1 @@\n-    assert(bt == alias_type->basic_type() || bt == T_PRIMITIVE_OBJECT, \"should match\");\n-    if (field != nullptr && bt == T_PRIMITIVE_OBJECT && !field->is_flat()) {\n-      bt = T_OBJECT;\n-    }\n+    assert(bt == alias_type->basic_type() || is_flat, \"should match\");\n@@ -2464,3 +2461,0 @@\n-    if (adr_type->is_flat()) {\n-      bt = T_PRIMITIVE_OBJECT;\n-    }\n@@ -2472,1 +2466,1 @@\n-    if (bt != T_PRIMITIVE_OBJECT && is_reference_type(bt, true)) {\n+    if (is_reference_type(bt, true)) {\n@@ -2487,1 +2481,1 @@\n-  if (type == T_PRIMITIVE_OBJECT) {\n+  if (is_flat) {\n@@ -2511,1 +2505,1 @@\n-  assert(!mismatched || type == T_PRIMITIVE_OBJECT || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n+  assert(!mismatched || is_flat || alias_type->adr_type()->is_oopptr(), \"off-heap access can't be mismatched\");\n@@ -2529,1 +2523,1 @@\n-    } else if (type == T_PRIMITIVE_OBJECT) {\n+    } else if (is_flat) {\n@@ -2553,1 +2547,1 @@\n-      if (type == T_PRIMITIVE_OBJECT) {\n+      if (is_flat) {\n@@ -2606,1 +2600,1 @@\n-    if (type == T_PRIMITIVE_OBJECT) {\n+    if (is_flat) {\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned);\n+  bool inline_unsafe_access(bool is_store, BasicType type, AccessKind kind, bool is_unaligned, bool is_flat = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1079,1 +1079,1 @@\n-        use->as_InlineType()->set_oop(_igvn.zerocon(T_PRIMITIVE_OBJECT));\n+        use->as_InlineType()->set_oop(_igvn.zerocon(T_OBJECT));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -932,1 +932,0 @@\n-  assert(basic_elem_type != T_PRIMITIVE_OBJECT, \"should have been converted to a basic type copy\");\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -933,1 +933,0 @@\n-  case T_PRIMITIVE_OBJECT:\n@@ -1168,1 +1167,0 @@\n-      assert(memory_type() != T_PRIMITIVE_OBJECT, \"should not be used for inline types\");\n@@ -2700,1 +2698,0 @@\n-  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,1 +128,0 @@\n-  case T_PRIMITIVE_OBJECT:\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-    bt = T_PRIMITIVE_OBJECT;\n+    bt = T_OBJECT;\n@@ -123,1 +123,1 @@\n-        Node* casted_adr = array_element_address(cast, idx, T_PRIMITIVE_OBJECT, ary_t->size(), control());\n+        Node* casted_adr = array_element_address(cast, idx, T_OBJECT, ary_t->size(), control());\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-  new_vt->set_oop(gvn().zerocon(T_PRIMITIVE_OBJECT));\n+  new_vt->set_oop(gvn().zerocon(T_OBJECT));\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -272,4 +272,2 @@\n-  case T_PRIMITIVE_OBJECT: {\n-    ciInlineKlass* vk = type->unwrap()->as_inline_klass();\n-    return TypeOopPtr::make_from_klass(vk)->join_speculative(type->is_null_free() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n-  }\n+  case T_OBJECT:\n+    return Type::get_const_type(type->unwrap())->join_speculative(type->is_null_free() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -305,1 +303,0 @@\n-    case T_PRIMITIVE_OBJECT:\n@@ -343,1 +340,0 @@\n-    case T_PRIMITIVE_OBJECT: conbt = T_OBJECT; break;\n@@ -350,1 +346,0 @@\n-    case T_PRIMITIVE_OBJECT: loadbt = T_OBJECT; break;\n@@ -2208,1 +2203,0 @@\n-\n@@ -2220,11 +2214,1 @@\n-  case T_ARRAY:\n-  case T_BOOLEAN:\n-  case T_CHAR:\n-  case T_FLOAT:\n-  case T_BYTE:\n-  case T_SHORT:\n-  case T_INT:\n-    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n-    break;\n-  case T_PRIMITIVE_OBJECT:\n-    if (ret_vt_fields) {\n+    if (return_type->is_inlinetype() && ret_vt_fields) {\n@@ -2238,0 +2222,1 @@\n+      break;\n@@ -2239,1 +2224,1 @@\n-      field_array[TypeFunc::Parms] = get_const_type(return_type)->join_speculative(sig->returns_null_free_inline_type() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n+      field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling)->join_speculative(sig->returns_null_free_inline_type() ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n@@ -2242,0 +2227,9 @@\n+  case T_ARRAY:\n+  case T_BOOLEAN:\n+  case T_CHAR:\n+  case T_FLOAT:\n+  case T_BYTE:\n+  case T_SHORT:\n+  case T_INT:\n+    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n+    break;\n@@ -2288,0 +2282,10 @@\n+      if (type->is_inlinetype() && vt_fields_as_args && method->is_scalarized_arg(i + (method->is_static() ? 0 : 1))) {\n+        if (!sig->is_null_free_at(i)) {\n+          \/\/ InlineTypeNode::IsInit field used for null checking\n+          field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n+        }\n+        collect_inline_fields(type->as_inline_klass(), field_array, pos);\n+      } else {\n+        field_array[pos++] = get_const_type(type, interface_handling)->join_speculative(sig->is_null_free_at(i) ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n+      }\n+      break;\n@@ -2299,12 +2303,0 @@\n-    case T_PRIMITIVE_OBJECT: {\n-      if (vt_fields_as_args && method->is_scalarized_arg(i + (method->is_static() ? 0 : 1))) {\n-        if (!sig->is_null_free_at(i)) {\n-          \/\/ InlineTypeNode::IsInit field used for null checking\n-          field_array[pos++] = get_const_basic_type(T_BOOLEAN);\n-        }\n-        collect_inline_fields(type->as_inline_klass(), field_array, pos);\n-      } else {\n-        field_array[pos++] = get_const_type(type)->join_speculative(sig->is_null_free_at(i) ? TypePtr::NOTNULL : TypePtr::BOTTOM);\n-      }\n-      break;\n-    }\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":24,"deletions":32,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1632,1 +1632,1 @@\n-  int base_offset = arrayOopDesc::base_offset_in_bytes(T_PRIMITIVE_OBJECT) - InlineKlass::cast(vk)->first_field_offset();\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_OBJECT) - InlineKlass::cast(vk)->first_field_offset();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -948,1 +948,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2510,1 +2510,1 @@\n-    _basic_type_bits = 4,\n+    _basic_type_bits = 5,\n@@ -2590,1 +2590,1 @@\n-          if (bt == T_PRIMITIVE_OBJECT) {\n+          if (bt == T_METADATA) {\n@@ -3101,1 +3101,1 @@\n-              \/\/ Nullable inline type argument, insert InlineTypeNode::IsInit field right after T_PRIMITIVE_OBJECT\n+              \/\/ Nullable inline type argument, insert InlineTypeNode::IsInit field right after T_METADATA delimiter\n@@ -3876,1 +3876,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT) {\n+    if (bt == T_METADATA) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -701,1 +701,1 @@\n-  return (sig->at(i)._bt != T_PRIMITIVE_OBJECT &&\n+  return (sig->at(i)._bt != T_METADATA &&\n@@ -725,1 +725,1 @@\n-    if (bt == T_PRIMITIVE_OBJECT || bt == T_VOID) {\n+    if (bt == T_METADATA || bt == T_VOID) {\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-           e1->_bt == T_PRIMITIVE_OBJECT || e2->_bt == T_PRIMITIVE_OBJECT || e1->_bt == T_VOID || e2->_bt == T_VOID, \"bad bt\");\n+           e1->_bt == T_METADATA || e2->_bt == T_METADATA || e1->_bt == T_VOID || e2->_bt == T_VOID, \"bad bt\");\n@@ -602,1 +602,1 @@\n-      assert(e1->_bt == T_PRIMITIVE_OBJECT || e1->_bt == T_VOID, \"only ones with duplicate offsets\");\n+      assert(e1->_bt == T_METADATA || e1->_bt == T_VOID, \"only ones with duplicate offsets\");\n@@ -606,1 +606,1 @@\n-        e2->_bt == T_PRIMITIVE_OBJECT) {\n+        e2->_bt == T_METADATA) {\n@@ -609,1 +609,1 @@\n-    if (e1->_bt == T_PRIMITIVE_OBJECT ||\n+    if (e1->_bt == T_METADATA ||\n@@ -624,1 +624,1 @@\n-  bool operator()(const SigEntry& entry) { return entry._bt != T_PRIMITIVE_OBJECT && entry._bt != T_VOID; }\n+  bool operator()(const SigEntry& entry) { return entry._bt != T_METADATA && entry._bt != T_VOID; }\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-      if (bt == T_PRIMITIVE_OBJECT) {\n+      if (bt == T_METADATA) {\n@@ -78,1 +78,1 @@\n-    assert(_sig->at(_sig_idx)._bt == (_step > 0) ? T_PRIMITIVE_OBJECT : T_VOID, \"should be at inline type delimiter\");\n+    assert(_sig->at(_sig_idx)._bt == (_step > 0) ? T_METADATA : T_VOID, \"should be at inline type delimiter\");\n","filename":"src\/hotspot\/share\/runtime\/signature_cc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-      case T_PRIMITIVE_OBJECT:\n@@ -282,1 +281,1 @@\n-  T_PRIMITIVE_OBJECT,      \/\/ T_PRIMITIVE_OBJECT = 14,\n+  T_OBJECT,                \/\/ T_PRIMITIVE_OBJECT = 14,\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}