{"files":[{"patch":"@@ -0,0 +1,446 @@\n+\/*\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * An implementation of complex numbers using \"textbook\" algorithms\n+ * for the arithmetic operations and using {@code double} values for\n+ * the real and imaginary component. This class is intended only for\n+ * prototyping and <em>not<\/em> intended for production use.\n+ *\n+ * <p>For explanatory purposes, in the discussions below of the semantics\n+ * of arithmetic methods, two complex numbers\n+ * <br>(<i>a<\/i> + <i>i<\/i>&middot;<i>b<\/i>) and (<i>c<\/i> + <i>i<\/i>&middot;<i>d<\/i>)\n+ * <br>will be used for notational convenience in specifying the\n+ * calculations used to compute the real and imaginary components of the result.\n+ *\n+ * @apiNote\n+ * TODO: For a production-level complex number class, discussion of (real,\n+ * imaginary) model, polar coordinates and {@linkplain #proj\n+ * projection method}, infinities (complex plane vs Riemann sphere),\n+ * branch cuts, component-wise vs norm-wise error, specific algorithms\n+ * used subject to change, etc.\n+ *\/\n+@Deprecated(forRemoval=true)\n+@jdk.internal.ValueBased\n+public final class \/*value record*\/ ComplexTextbook  {\n+    \/\/ This type should be Numerical, but *not* Orderable since\n+    \/\/ complex numbers are not an ordered field.\n+\n+    \/**\n+     * The real component of the complex number.\n+     *\/\n+    private final double  real;\n+\n+    \/**\n+     * The imaginary component of the complex number.\n+     * (Note that a more than textbook implementation may use a\n+     * separate imaginary type.)\n+     *\/\n+    private final double  imag;\n+\n+    \/**\n+     * Constructs a complex number.\n+     *\/\n+    private ComplexTextbook(double real, double imag) {\n+        this.real = real;\n+        this.imag = imag;\n+    }\n+\n+    \/**\n+     * A complex number with the value of zero, both real and\n+     * imaginary components of +0.0.\n+     *\n+     * @see #isZero(ComplexTextbook)\n+     *\/\n+    public static final ComplexTextbook ZERO = valueOf(0.0, 0.0);\n+\n+    \/**\n+     * A complex number with a real component of 1.0 and a 0.0\n+     * imaginary component.\n+     *\/\n+    public static final ComplexTextbook ONE = valueOf(1.0, 0.0);\n+\n+    \/**\n+     * A complex number with a real component of positive infinity and\n+     * a 0.0 imaginary component.\n+     *\n+     * @see #isInfinite(ComplexTextbook)\n+     * @see #proj(ComplexTextbook)\n+     *\/\n+    public static final ComplexTextbook INFINITY = valueOf(Double.POSITIVE_INFINITY, 0.0);\n+\n+    \/**\n+     * A complex number with NaN real component and imaginary\n+     * component.\n+     *\n+     * @see #isNaN(ComplexTextbook)\n+     *\/\n+    public static final ComplexTextbook NaN = valueOf(Double.NaN, Double.NaN);\n+\n+    \/**\n+     * {@return the real component of this complex number}\n+     *\/\n+    public double real() { \/\/ better as a static method?\n+        return real;\n+    }\n+\n+    \/**\n+     * {@return the imaginary component of this complex number}\n+     *\/\n+    public double imag() { \/\/ better as a static method?\n+        return imag;\n+    }\n+\n+    \/**\n+     * {@return a complex number with real and imaginary components\n+     * equivalent to the real and imaginary arguments, respectively}\n+     *\n+     * @param real the real component\n+     * @param imag the imaginary component\n+     *\/\n+    public static ComplexTextbook valueOf(double real, double imag) {\n+        return new ComplexTextbook(real, imag);\n+    }\n+\n+    \/**\n+     * {@return a complex number with the real component equivalent to the\n+     * argument and a {@code +0.0} imaginary component}\n+     *\n+     * @param real the real component\n+     *\/\n+    public static ComplexTextbook valueOf(double real) {\n+        return new ComplexTextbook(real, 0.0);\n+    }\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     *\n+     * @param s the string to be parsed\n+     *\n+     * @see Double#parseDouble(String)\n+     *\/\n+    public static ComplexTextbook valueOf(String s) {\n+        throw new UnsupportedOperationException(\"work in progress\");\n+    }\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     *\n+     * @apiNote\n+     * To convert <em>to<\/em> polar form, use {@code r = ComplexTextbook.abs(c)} and\n+     * {@code theta = Math.atan2(c.imag(), c.real())}.\n+     *\n+     * @param r the modulus, {@linkplain abs absolute value}, of the\n+     * complex number in polar form\n+     * @param theta the phase angle of the complex number in polar form\n+     *\n+     * @see Math#atan2(double, double)\n+     *\/\n+    public static ComplexTextbook valueOfPolar(double r, double theta) {\n+        return valueOf(r*Math.cos(theta),\n+                       r*Math.sin(theta));\n+    }\n+\n+    \/**\n+     * {@return a string representing the complex number}\n+     *\/\n+    @Override\n+    public String toString() {\n+        return \"(\" + real + \" + \" + \"i*\" + imag  + \")\";\n+    }\n+\n+    \/**\n+     * {@return a string representing the argument}\n+     *\n+     * @param c the complex number to be represented\n+     *\/\n+    public static String toString(ComplexTextbook c) {\n+        return c.toString();\n+    }\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     * @param that lorem ipsum}\n+     *\/\n+    @Override\n+    public boolean equals(Object that) {\n+        if (that instanceof ComplexTextbook c) {\n+            return this.real == c.real && this.imag == c.imag;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     *\/\n+    \/\/ @Override\n+    public int hashCode(){\n+        \/\/ Add 0.0 to be consistent with current equals impl.\n+        return Double.hashCode(real + 0.0) ^ Double.hashCode(imag + 0.0);\n+    }\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     *\n+     * @apiNote\n+     * Relate to {@linkplain Double##repEquivalence equivalence\n+     * discussion} in {@code double}...\n+     *\n+     * @param c1 lorem ipsum}\n+     * @param c2 lorem ipsum}\n+     *\/\n+    public static boolean equivalent(ComplexTextbook c1, ComplexTextbook c2) {\n+        return Double.compare(c1.real, c2.real) == 0 &&\n+               Double.compare(c1.imag, c2.imag) == 0;\n+    }\n+\n+    \/\/ Arithmetic operators\n+\n+    \/**\n+     * Addition operation, binary \"{@code +}\".\n+     *\n+     * @implSpec\n+     * The computed sum is equivalent to\n+     * (<i>a<\/i>&nbsp;+&nbsp;<i>c<\/i>)&nbsp;+&nbsp;<i>i<\/i>&middot;(<i>b<\/i>&nbsp;+&nbsp;<i>d<\/i>).\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\/\n+    public static ComplexTextbook add(ComplexTextbook addend,\n+                                      ComplexTextbook augend) {\n+        double a = addend.real;\n+        double b = addend.imag;\n+        double c = augend.real;\n+        double d = augend.imag;\n+\n+        return valueOf(a + c, b + d);\n+    }\n+\n+    \/**\n+     * Subtraction operation, binary \"{@code -}\".\n+     *\n+     * @implSpec\n+     * The computed difference is equivalent to\n+     * (<i>a<\/i>&nbsp;&minus;&nbsp;<i>c<\/i>)&nbsp;+&nbsp;<i>i<\/i>&middot;(<i>b<\/i>&nbsp;&minus;&nbsp;<i>d<\/i>).\n+     *\n+     * @param minuend the first operand\n+     * @param subtrahend the second operand\n+     * @return the difference of the operands\n+     *\/\n+    public static ComplexTextbook subtract(ComplexTextbook minuend,\n+                                           ComplexTextbook subtrahend) {\n+        double a = minuend.real;\n+        double b = minuend.imag;\n+        double c = subtrahend.real;\n+        double d = subtrahend.imag;\n+\n+        return valueOf(a - c, b - d);\n+    }\n+\n+    \/**\n+     * Multiplication operation, \"{@code *}\".\n+     *\n+     * @apiNote\n+     * WARNING: while simple, the calculation technique used by this\n+     * method is subject to spurious underflow and overflow as well as\n+     * inaccurate component-wise results.\n+     *\n+     * @implSpec\n+     * The computed product is calculated by\n+     * (<i>ac<\/i>&nbsp;&minus;&nbsp;<i>bd<\/i>)&nbsp;+&nbsp;<i>i<\/i>&middot;(<i>ad<\/i>&nbsp;+&nbsp;<i>bc<\/i>)\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\/\n+    public static ComplexTextbook multiply(ComplexTextbook multiplier,\n+                                           ComplexTextbook multiplicand) {\n+        double a = multiplier.real;\n+        double b = multiplier.imag;\n+        double c = multiplicand.real;\n+        double d = multiplicand.imag;\n+\n+        return valueOf(a*c - b*d, a*d + b*c);\n+    }\n+\n+    \/**\n+     * Division operation, \"{@code \/}\".\n+     *\n+     * @apiNote\n+     * TODO: Bad numerical things can happen warning...\n+     *\n+     * @implSpec\n+     * The computed quotient is calculated by\n+     * (<i>ac<\/i> + <i>bd<\/i>)\/(<i>c<\/i>&sup2; + <i>d<\/i>&sup2;) + <i>i<\/i>*(<i>bc<\/i> &minus; <i>ad<\/i>)\/(<i>c<\/i>&sup2; + <i>d<\/i>&sup2;)\n+     *\n+     * @param dividend the value to be divided\n+     * @param divisor the value being divided by\n+     * @return the quotient of the first argument divided by\n+     * the second argument\n+     *\/\n+    public static ComplexTextbook divide(ComplexTextbook dividend,\n+                                         ComplexTextbook divisor) {\n+        double a = dividend.real;\n+        double b = dividend.imag;\n+        double c = divisor.real;\n+        double d = divisor.imag;\n+\n+        double scale = c*c + d*d;\n+\n+        return valueOf((a*c + b*d)\/scale, (b*c - a*d)\/scale);\n+    }\n+\n+    \/**\n+     * Remainder operation, \"{@code %}\".\n+     *\n+     * @param dividend the value to be divided to compute the remainder\n+     * @param divisor the value being divided by\n+     * @return the remainder of the first argument divided by\n+     * the second argument\n+     *\/\n+    public static ComplexTextbook remainder(ComplexTextbook dividend,\n+                                        ComplexTextbook divisor) {\n+        throw new UnsupportedOperationException(\"tbd\");\n+    }\n+\n+    \/\/ TODO: API decision, is this method needed?\n+\n+    \/**\n+     * Unary plus operation, \"{@code +}\".\n+     *\n+     * @param operand the operand\n+     * @return unary plus of the operand\n+     *\/\n+    public static ComplexTextbook plus(ComplexTextbook operand) {\n+        return operand;\n+    }\n+\n+    \/\/ TODO: API discussion, is this method needed?\n+    \/\/\n+    \/\/ If there is a single interface defining the operations over\n+    \/\/ integral types, negation should be defined over unsigned\n+    \/\/ values. If there are separate interfaces for signed and\n+    \/\/ unsigned integral types, the negate method can be elided on\n+    \/\/ unsigned types.\n+\n+    \/**\n+     * Negation operation, unary \"{@code -}\".\n+     *\n+     * @implSpec\n+     * The negation is equivalent to\n+     * &minus;<i>a<\/i>&nbsp;+&nbsp;&minus;<i>i<\/i>&middot;<i>b<\/i>\n+     *\n+     * @param c the operand\n+     * @return the negation of the operand\n+     *\/\n+    public static ComplexTextbook negate(ComplexTextbook c) {\n+        return valueOf(-c.real, -c.imag);\n+    }\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     *\n+     * @implSpec\n+     * The conjugate is equivalent to\n+     * <i>a<\/i>&nbsp;+&nbsp;&minus;<i>i<\/i>&middot;<i>b<\/i>\n+     *\n+     * @param c a complex number\n+     *\/\n+    public static ComplexTextbook conj(ComplexTextbook c) {\n+        return valueOf(c.real, -c.imag);\n+    }\n+\n+    \/\/ Utility methods\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     *\n+     * @implSpec\n+     * use hypot\n+     * @param c a complex number\n+     * @see Math#abs(double)\n+     *\/\n+    public static double abs(ComplexTextbook c) {\n+        double a = c.real;\n+        double b = c.imag;\n+        return StrictMath.hypot(a, b);\n+    }\n+\n+    \/**\n+     * {@return lorem ipsum}\n+     *\n+     * If the argument is infinite, return the canonical infinity,\n+     * otherwise return the argument.\n+     *\n+     * @param c a complex number\n+     *\/\n+    public static ComplexTextbook proj(ComplexTextbook c) {\n+        return isInfinite(c) ? INFINITY : c;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if both the real and imaginary components\n+     * are zero; {@code false} otherwise}\n+     *\n+     * @param c a complex number\n+     *\/\n+    public static boolean isZero(ComplexTextbook c) {\n+        return c.real == 0.0 && c.imag == 0.0;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if either the real or imaginary component\n+     * is NaN; {@code false} otherwise}\n+     *\n+     * @param c a complex number\n+     *\/\n+    public static boolean isNaN(ComplexTextbook c) {\n+        return Double.isNaN(c.real) || Double.isNaN(c.imag);\n+    }\n+\n+    \/**\n+     * {@return {@code true} if either the real or imaginary component\n+     * is infinite; {@code false} otherwise}\n+     *\n+     * @param c a complex number\n+     *\/\n+    public static boolean isInfinite(ComplexTextbook c) {\n+        return Double.isInfinite(c.real) || Double.isInfinite(c.imag);\n+    }\n+\n+    \/**\n+     * {@return {@code true} if both the real and imaginary components\n+     * are finite; {@code false} otherwise}\n+     *\n+     * @param c a complex number\n+     *\/\n+    public static boolean isFinite(ComplexTextbook c) {\n+        return Double.isFinite(c.real) && Double.isFinite(c.imag);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ComplexTextbook.java","additions":446,"deletions":0,"binary":false,"changes":446,"status":"added"}]}