{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,0 @@\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,1 +570,1 @@\n-  ldr(r2, Address(r1, Method::access_flags_offset()));\n+  ldrh(r2, Address(r1, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -599,1 +599,1 @@\n-      __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));\n+      __ ldrh(rscratch1, Address(rmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -818,1 +818,1 @@\n-    __ ldrw(r0, access_flags);\n+    __ ldrh(r0, access_flags);\n@@ -829,1 +829,1 @@\n-    __ ldrw(r0, access_flags);\n+    __ ldrh(r0, access_flags);\n@@ -1234,1 +1234,1 @@\n-  __ ldrw(r0, access_flags);\n+  __ ldrh(r0, access_flags);\n@@ -1286,1 +1286,1 @@\n-      __ ldrw(r0, access_flags);\n+      __ ldrh(r0, access_flags);\n@@ -1363,1 +1363,1 @@\n-    __ ldrw(t, Address(rmethod, Method::access_flags_offset()));\n+    __ ldrh(t, Address(rmethod, Method::access_flags_offset()));\n@@ -1573,1 +1573,1 @@\n-    __ ldrw(t, Address(rmethod, Method::access_flags_offset()));\n+    __ ldrh(t, Address(rmethod, Method::access_flags_offset()));\n@@ -1704,1 +1704,1 @@\n-  __ ldrw(r0, access_flags);\n+  __ ldrh(r0, access_flags);\n@@ -1760,1 +1760,1 @@\n-      __ ldrw(r0, access_flags);\n+      __ ldrh(r0, access_flags);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -684,1 +684,1 @@\n-    lwz(Raccess_flags, in_bytes(Method::access_flags_offset()), R19_method);\n+    lhz(Raccess_flags, in_bytes(Method::access_flags_offset()), R19_method);\n@@ -691,1 +691,1 @@\n-    rldicl_(R0, Raccess_flags, 64-JVM_ACC_SYNCHRONIZED_BIT, 63); \/\/ Extract bit and compare to 0.\n+    testbitdi(CCR0, R0, Raccess_flags, JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -783,1 +783,1 @@\n-    testbit(method2_(R_method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+    testbit_ushort(method2_(R_method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1038,1 +1038,1 @@\n-  movl(rcx, Address(rcx, Method::access_flags_offset()));\n+  load_unsigned_short(rcx, Address(rcx, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -885,1 +885,1 @@\n-      __ movl(flags, Address(method, Method::access_flags_offset()));\n+      __ load_unsigned_short(flags, Address(method, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -604,1 +604,1 @@\n-    __ movl(rax, access_flags);\n+    __ load_unsigned_short(rax, access_flags);\n@@ -615,1 +615,1 @@\n-    __ movl(rax, access_flags);\n+    __ load_unsigned_short(rax, access_flags);\n@@ -863,1 +863,1 @@\n-  __ movl(rax, access_flags);\n+  __ load_unsigned_short(rax, access_flags);\n@@ -917,1 +917,1 @@\n-      __ movl(rax, access_flags);\n+      __ load_unsigned_short(rax, access_flags);\n@@ -1007,1 +1007,1 @@\n-    __ movl(t, Address(method, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(method, Method::access_flags_offset()));\n@@ -1288,1 +1288,1 @@\n-    __ movl(t, Address(method, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(method, Method::access_flags_offset()));\n@@ -1440,1 +1440,1 @@\n-  __ movl(rax, access_flags);\n+  __ load_unsigned_short(rax, access_flags);\n@@ -1497,1 +1497,1 @@\n-      __ movl(rax, access_flags);\n+      __ load_unsigned_short(rax, access_flags);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1369,1 +1369,1 @@\n-  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_INT), klass_modifiers);\n+  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_CHAR), klass_modifiers);\n@@ -1374,2 +1374,1 @@\n-  __ cmove(lir_cond_equal, prim_modifiers, klass_modifiers, result, T_INT);\n-\n+  __ cmove(lir_cond_equal, prim_modifiers, klass_modifiers, result, T_CHAR);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -992,0 +992,3 @@\n+    } else {\n+      assert(!SystemDictionaryShared::has_class_failed_verification(ik), \"sanity\");\n+      ik->compute_has_loops_flag_for_methods();\n@@ -993,1 +996,0 @@\n-    ik->compute_has_loops_flag_for_methods();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-  st->print(\" flags=%x\", _flags);\n+  st->print(\" flags=%x\", _flags.as_unsigned_short());\n","filename":"src\/hotspot\/share\/ci\/ciFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"jvm_constants.h\"\n@@ -42,1 +41,1 @@\n-  jint _flags;\n+  AccessFlags _flags;\n@@ -44,1 +43,1 @@\n-  bool _intialized_final_update;\n+  bool _initialized_final_update;\n@@ -46,1 +45,1 @@\n-  ciFlags() :_flags(0), _stable(false), _intialized_final_update(false) { }\n+  ciFlags() :_flags(0), _stable(false), _initialized_final_update(false) { }\n@@ -48,1 +47,1 @@\n-    _flags(flags.as_int()), _stable(is_stable), _intialized_final_update(is_initialized_final_update) { }\n+    _flags(flags), _stable(is_stable), _initialized_final_update(is_initialized_final_update) { }\n@@ -52,13 +51,14 @@\n-  bool is_public               () const { return (_flags & JVM_ACC_PUBLIC                    ) != 0; }\n-  bool is_private              () const { return (_flags & JVM_ACC_PRIVATE                   ) != 0; }\n-  bool is_protected            () const { return (_flags & JVM_ACC_PROTECTED                 ) != 0; }\n-  bool is_static               () const { return (_flags & JVM_ACC_STATIC                    ) != 0; }\n-  bool is_final                () const { return (_flags & JVM_ACC_FINAL                     ) != 0; }\n-  bool is_synchronized         () const { return (_flags & JVM_ACC_SYNCHRONIZED              ) != 0; }\n-  bool is_volatile             () const { return (_flags & JVM_ACC_VOLATILE                  ) != 0; }\n-  bool is_transient            () const { return (_flags & JVM_ACC_TRANSIENT                 ) != 0; }\n-  bool is_native               () const { return (_flags & JVM_ACC_NATIVE                    ) != 0; }\n-  bool is_interface            () const { return (_flags & JVM_ACC_INTERFACE                 ) != 0; }\n-  bool is_abstract             () const { return (_flags & JVM_ACC_ABSTRACT                  ) != 0; }\n-  bool has_vararg              () const { return (_flags & JVM_ACC_VARARGS                   ) != 0; }\n-  bool is_identity             () const { return (_flags & JVM_ACC_IDENTITY                  ) != 0; }\n+  bool is_public               () const { return _flags.is_public();       }\n+  bool is_private              () const { return _flags.is_private();      }\n+  bool is_protected            () const { return _flags.is_protected();    }\n+  bool is_static               () const { return _flags.is_static();       }\n+  bool is_final                () const { return _flags.is_final();        }\n+  bool is_synchronized         () const { return _flags.is_synchronized(); }\n+  bool is_volatile             () const { return _flags.is_volatile();     }\n+  bool is_transient            () const { return _flags.is_transient();    }\n+  bool is_native               () const { return _flags.is_native();       }\n+  bool is_interface            () const { return _flags.is_interface();    }\n+  bool is_abstract             () const { return _flags.is_abstract();     }\n+  bool has_vararg              () const { return _flags.has_vararg();      }\n+  bool is_identity             () const { return _flags.is_identity_class(); }\n+\n@@ -70,1 +70,1 @@\n-  bool has_initialized_final_update() const { return _intialized_final_update; };\n+  bool has_initialized_final_update() const { return _initialized_final_update; };\n@@ -73,1 +73,1 @@\n-  jint   as_int()                      { return _flags; }\n+  jint   as_int()                      { return _flags.as_unsigned_short(); }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-    return get_Klass()->access_flags().as_int();\n+    return get_Klass()->access_flags().as_unsigned_short();\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3068,1 +3068,1 @@\n-    jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n+    u2 recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n@@ -3075,1 +3075,1 @@\n-    jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    u2 flags = cfs->get_u2_fast() & recognized_modifiers;\n@@ -3097,1 +3097,1 @@\n-    inner_classes->at_put(index++, inner_access_flags.as_short());\n+    inner_classes->at_put(index++, inner_access_flags.as_unsigned_short());\n@@ -3920,1 +3920,1 @@\n-  int computed_modifiers = this_klass->compute_modifier_flags();\n+  u2 computed_modifiers = this_klass->compute_modifier_flags();\n@@ -5648,1 +5648,1 @@\n-  assert(0 == _access_flags.as_int(), \"invariant\");\n+  assert(0 == _access_flags.as_unsigned_short(), \"invariant\");\n@@ -5809,1 +5809,1 @@\n-  jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n+  u2 recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n@@ -5816,1 +5816,1 @@\n-  jint flags = stream->get_u2_fast() & recognized_modifiers;\n+  u2 flags = stream->get_u2_fast() & recognized_modifiers;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3190,1 +3190,1 @@\n-  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  int flags = m->access_flags().as_method_flags();\n@@ -5565,1 +5565,1 @@\n-    tty->print_cr(\"  name: %s, sig: %s, flags: %08x\", fs.name()->as_C_string(), fs.signature()->as_C_string(), fs.access_flags().as_int());\n+    tty->print_cr(\"  name: %s, sig: %s, flags: %08x\", fs.name()->as_C_string(), fs.signature()->as_C_string(), fs.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-inline bool match_F_R(jshort flags) {\n+inline bool match_F_R(u2 flags) {\n@@ -45,1 +45,1 @@\n-inline bool match_F_Y(jshort flags) {\n+inline bool match_F_Y(u2 flags) {\n@@ -51,1 +51,1 @@\n-inline bool match_F_RN(jshort flags) {\n+inline bool match_F_RN(u2 flags) {\n@@ -57,1 +57,1 @@\n-inline bool match_F_S(jshort flags) {\n+inline bool match_F_S(u2 flags) {\n@@ -63,1 +63,1 @@\n-inline bool match_F_SN(jshort flags) {\n+inline bool match_F_SN(u2 flags) {\n@@ -719,1 +719,1 @@\n-                                            jshort flags) {\n+                                            u2 flags) {\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1512,1 +1512,1 @@\n-                         jshort flags);\n+                         u2 flags);\n@@ -1523,1 +1523,1 @@\n-                    jshort flags) {\n+                    u2 flags) {\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2535,0 +2535,5 @@\n+  \/\/ Update compilation times. Used by the implementation of JFR CompilerStatistics\n+  \/\/ and java.lang.management.CompilationMXBean.\n+  _perf_total_compilation->inc(time.ticks());\n+  _peak_compilation_time = MAX2(time.milliseconds(), _peak_compilation_time);\n+\n@@ -2553,6 +2558,0 @@\n-\n-    \/\/ update compilation ticks - used by the implementation of\n-    \/\/ java.lang.management.CompilationMXBean\n-    _perf_total_compilation->inc(time.ticks());\n-    _peak_compilation_time = time.milliseconds() > _peak_compilation_time ? time.milliseconds() : _peak_compilation_time;\n-\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -39,1 +40,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -83,2 +84,1 @@\n-    _partial_array_state_allocator(g1h->partial_array_state_manager()),\n-    _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n+    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers),\n@@ -172,3 +172,6 @@\n-  \/\/ Must be in the collection set--it's already been copied.\n-  oop p = task->source();\n-  assert(_g1h->is_in_cset(p), \"p=\" PTR_FORMAT, p2i(p));\n+  assert(task != nullptr, \"invariant\");\n+  \/\/ Source isn't used for processing, so not recorded in task.\n+  assert(task->source() == nullptr, \"invariant\");\n+  oop p = task->destination();\n+  assert(_g1h->is_in_reserved(p),\n+         \"task=\" PTR_FORMAT \" dest=\" PTR_FORMAT, p2i(task), p2i(p));\n@@ -225,24 +228,5 @@\n-void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n-  oop to_obj = state->destination();\n-\n-#ifdef ASSERT\n-  oop from_obj = state->source();\n-  assert(_g1h->is_in_reserved(from_obj), \"must be in heap.\");\n-  assert(from_obj->is_forwarded(), \"must be forwarded\");\n-  assert(from_obj != to_obj, \"should not be chunking self-forwarded objects\");\n-  assert(to_obj->is_objArray(), \"must be obj array\");\n-#endif \/\/ ASSERT\n-\n-  objArrayOop to_array = objArrayOop(to_obj);\n-\n-  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  \/\/ Push any additional partial scan tasks needed.  Pushed before processing\n-  \/\/ the claimed chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  }\n-\n+void G1ParScanThreadState::do_partial_array(PartialArrayState* state, bool stolen) {\n+  \/\/ Access state before release by claim().\n+  objArrayOop to_array = objArrayOop(state->destination());\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, _task_queue, stolen);\n@@ -253,4 +237,2 @@\n-                              checked_cast<int>(step._index),\n-                              checked_cast<int>(step._index + _partial_array_stepper.chunk_size()));\n-  \/\/ Release reference to the state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n+                              checked_cast<int>(claim._start),\n+                              checked_cast<int>(claim._end));\n@@ -268,20 +250,3 @@\n-\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n-  \/\/ initial chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    assert(step._index < array_length, \"invariant\");\n-    assert(((array_length - step._index) % _partial_array_stepper.chunk_size()) == 0,\n-           \"invariant\");\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(from_obj, to_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  } else {\n-    assert(step._index == array_length, \"invariant\");\n-  }\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(_task_queue, nullptr, to_array, array_length);\n@@ -299,1 +264,1 @@\n-  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(step._index));\n+  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(initial_chunk_size));\n@@ -303,1 +268,1 @@\n-void G1ParScanThreadState::dispatch_task(ScannerTask task) {\n+void G1ParScanThreadState::dispatch_task(ScannerTask task, bool stolen) {\n@@ -310,1 +275,1 @@\n-    do_partial_array(task.to_partial_array_state());\n+    do_partial_array(task.to_partial_array_state(), stolen);\n@@ -323,1 +288,1 @@\n-        dispatch_task(task);\n+        dispatch_task(task, false);\n@@ -327,1 +292,1 @@\n-      dispatch_task(task);\n+      dispatch_task(task, false);\n@@ -336,1 +301,1 @@\n-    dispatch_task(stolen_task);\n+    dispatch_task(stolen_task, true);\n@@ -721,0 +686,8 @@\n+#if TASKQUEUE_STATS\n+\n+PartialArrayTaskStats* G1ParScanThreadState::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -748,0 +721,12 @@\n+\n+#if TASKQUEUE_STATS\n+\n+void G1ParScanThreadStateSet::print_partial_array_task_stats() {\n+  auto get_stats = [&](uint i) {\n+    return state_for_worker(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(_num_workers, get_stats,\n+                                 \"Partial Array Task Stats\");\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":45,"deletions":60,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -125,1 +125,1 @@\n-  TASKQUEUE_STATS_ONLY(print_taskqueue_stats());\n+  TASKQUEUE_STATS_ONLY(print_and_reset_taskqueue_stats());\n@@ -149,23 +149,2 @@\n-void\n-PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {\n-  #define FMT \" \" SIZE_FORMAT_W(10)\n-  out->print_cr(\"%3u\" FMT FMT FMT FMT,\n-                i, _array_chunk_pushes, _array_chunk_steals,\n-                _arrays_chunked, _array_chunks_processed);\n-  #undef FMT\n-}\n-\n-static const char* const pm_stats_hdr[] = {\n-  \"    ----partial array----     arrays      array\",\n-  \"thr       push      steal    chunked     chunks\",\n-  \"--- ---------- ---------- ---------- ----------\"\n-};\n-\n-void PSPromotionManager::print_taskqueue_stats() {\n-  if (!log_is_enabled(Trace, gc, task, stats)) {\n-    return;\n-  }\n-  Log(gc, task, stats) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n-  stack_array_depth()->print_taskqueue_stats(&ls, \"Oop Queue\");\n+void PSPromotionManager::print_and_reset_taskqueue_stats() {\n+  stack_array_depth()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n@@ -174,2 +153,5 @@\n-  const uint hlines = sizeof(pm_stats_hdr) \/ sizeof(pm_stats_hdr[0]);\n-  for (uint i = 0; i < hlines; ++i) ls.print_cr(\"%s\", pm_stats_hdr[i]);\n+  auto get_pa_stats = [&](uint i) {\n+    return manager_array(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(ParallelGCThreads, get_pa_stats,\n+                                 \"Partial Array Task Stats\");\n@@ -177,1 +159,1 @@\n-    manager_array(i)->print_local_stats(&ls, i);\n+    get_pa_stats(i)->reset();\n@@ -181,4 +163,2 @@\n-void PSPromotionManager::reset_stats() {\n-  claimed_stack_depth()->stats.reset();\n-  _array_chunk_pushes = _array_chunk_steals = 0;\n-  _arrays_chunked = _array_chunks_processed = 0;\n+PartialArrayTaskStats* PSPromotionManager::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n@@ -186,0 +166,1 @@\n+\n@@ -190,2 +171,1 @@\n-  : _partial_array_state_allocator(_partial_array_state_manager),\n-    _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n@@ -225,2 +205,0 @@\n-\n-  TASKQUEUE_STATS_ONLY(reset_stats());\n@@ -250,1 +228,1 @@\n-        process_popped_location_depth(task);\n+        process_popped_location_depth(task, false);\n@@ -255,1 +233,1 @@\n-      process_popped_location_depth(task);\n+      process_popped_location_depth(task, false);\n@@ -283,3 +261,2 @@\n-template <class T> void PSPromotionManager::process_array_chunk_work(\n-                                                 oop obj,\n-                                                 int start, int end) {\n+template <class T>\n+void PSPromotionManager::process_array_chunk_work(oop obj, int start, int end) {\n@@ -296,16 +273,7 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n-  TASKQUEUE_STATS_ONLY(++_array_chunks_processed);\n-\n-  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n-  \/\/ chunk to allow other workers to steal while we're processing.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n-  int start = checked_cast<int>(step._index);\n-  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n-  assert(start < end, \"invariant\");\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state, bool stolen) {\n+  \/\/ Access before release by claim().\n+  oop new_obj = state->destination();\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_claimed_stack_depth, stolen);\n+  int start = checked_cast<int>(claim._start);\n+  int end = checked_cast<int>(claim._end);\n@@ -313,1 +281,1 @@\n-    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, start, end);\n@@ -315,1 +283,1 @@\n-    process_array_chunk_work<oop>(state->destination(), start, end);\n+    process_array_chunk_work<oop>(new_obj, start, end);\n@@ -317,2 +285,0 @@\n-  \/\/ Release reference to state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n@@ -326,15 +292,6 @@\n-  size_t array_length = objArrayOop(new_obj)->length();\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  if (step._ncreate > 0) {\n-    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(old_obj, new_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n+  objArrayOop to_array = objArrayOop(new_obj);\n+  size_t array_length = to_array->length();\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(&_claimed_stack_depth, nullptr, to_array, array_length);\n+  int end = checked_cast<int>(initial_chunk_size);\n@@ -342,1 +299,1 @@\n-    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<narrowOop>(to_array, 0, end);\n@@ -344,1 +301,1 @@\n-    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<oop>(to_array, 0, end);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":35,"deletions":78,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-      increment_total_full_collections();\n+      _total_full_collections++;\n@@ -391,2 +391,0 @@\n-  void increment_total_full_collections() { _total_full_collections++; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -586,1 +586,1 @@\n-    jint new_flags = flags.as_int();\n+    u2 new_flags = flags.as_method_flags();\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1003,1 +1003,1 @@\n-  JVMCIENV->put_int_at(info, 0, fd.access_flags().as_int());\n+  JVMCIENV->put_int_at(info, 0, fd.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,1 +276,1 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               jint)                                  \\\n+  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n@@ -491,1 +491,0 @@\n-  declare_constant(JVM_ACC_WRITTEN_FLAGS)                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-                access_flags().as_int(),\n+                access_flags().as_field_flags(),\n@@ -100,1 +100,1 @@\n-    assert(fi_ref->access_flags().as_int() == fi.access_flags().as_int(), \"Must be\");\n+    assert(fi_ref->access_flags().as_field_flags() == fi.access_flags().as_field_flags(), \"Must be\");\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  _consumer->accept_uint(fi.access_flags().as_int());\n+  _consumer->accept_uint(fi.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-jint FlatArrayKlass::compute_modifier_flags() const {\n+u2 FlatArrayKlass::compute_modifier_flags() const {\n@@ -381,1 +381,1 @@\n-  jint element_flags = element_klass()->compute_modifier_flags();\n+  u2 element_flags = element_klass()->compute_modifier_flags();\n@@ -383,1 +383,1 @@\n-  int identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n+  u2 identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3601,2 +3601,2 @@\n-jint InstanceKlass::compute_modifier_flags() const {\n-  jint access = access_flags().as_int();\n+u2 InstanceKlass::compute_modifier_flags() const {\n+  u2 access = access_flags().as_unsigned_short();\n@@ -3621,1 +3621,1 @@\n-  return (access & JVM_ACC_WRITTEN_FLAGS);\n+  return access;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -484,2 +484,2 @@\n-  int field_offset      (int index) const { return field(index).offset(); }\n-  int field_access_flags(int index) const { return field(index).access_flags().as_int(); }\n+  int     field_offset      (int index) const { return field(index).offset(); }\n+  int     field_access_flags(int index) const { return field(index).access_flags().as_field_flags(); }\n@@ -788,2 +788,0 @@\n-  \/\/ The flag is in access_flags so that it can be set and reset using atomic\n-  \/\/ operations, and not be reset by other misc_flag settings.\n@@ -1259,1 +1257,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  enum KlassKind {\n+  enum KlassKind : u2 {\n@@ -118,1 +118,1 @@\n-  jint        _layout_helper;\n+  jint _layout_helper;\n@@ -125,0 +125,3 @@\n+  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n+                                \/\/ Some flags created by the JVM, not in the class file itself,\n+                                \/\/ are in _misc_flags below.\n@@ -126,1 +129,3 @@\n-  jint        _modifier_flags;\n+  u2          _modifier_flags;\n+\n+  KlassFlags  _misc_flags;\n@@ -162,0 +167,2 @@\n+  markWord _prototype_header;   \/\/ Used to initialize objects' header\n+\n@@ -166,12 +173,0 @@\n-  markWord _prototype_header;   \/\/ Used to initialize objects' header\n-\n-  int _vtable_len;              \/\/ vtable length. This field may be read very often when we\n-                                \/\/ have lots of itable dispatches (e.g., lambdas and streams).\n-                                \/\/ Keep it away from the beginning of a Klass to avoid cacheline\n-                                \/\/ contention that may happen when a nearby object is modified.\n-  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n-                                \/\/ Some flags created by the JVM, not in the class file itself,\n-                                \/\/ are in _misc_flags below.\n-\n-  JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n-\n@@ -205,1 +200,4 @@\n-  KlassFlags  _misc_flags;\n+  int _vtable_len;              \/\/ vtable length. This field may be read very often when we\n+                                \/\/ have lots of itable dispatches (e.g., lambdas and streams).\n+                                \/\/ Keep it away from the beginning of a Klass to avoid cacheline\n+                                \/\/ contention that may happen when a nearby object is modified.\n@@ -209,0 +207,4 @@\n+public:\n+\n+  JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n+\n@@ -297,2 +299,2 @@\n-  jint modifier_flags() const          { return _modifier_flags; }\n-  void set_modifier_flags(jint flags)  { _modifier_flags = flags; }\n+  u2 modifier_flags() const          { return _modifier_flags; }\n+  void set_modifier_flags(u2 flags)  { _modifier_flags = flags; }\n@@ -785,1 +787,1 @@\n-  virtual jint compute_modifier_flags() const = 0;\n+  virtual u2 compute_modifier_flags() const = 0;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-  bool must_be_preserved(const oopDesc* obj) const {\n+  bool must_be_preserved() const {\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1718,1 +1718,1 @@\n-  jshort flags = access_flags().as_short();\n+  u2 flags = access_flags().as_method_flags();\n@@ -2391,1 +2391,1 @@\n-  st->print   (\" - access:            0x%x  \", access_flags().as_int()); access_flags().print_on(st); st->cr();\n+  st->print   (\" - access:            0x%x  \", access_flags().as_method_flags()); access_flags().print_on(st); st->cr();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  AccessFlags       _access_flags;               \/\/ Access flags\n+  AccessFlags       _access_flags;               \/\/ Access flags\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-jint ObjArrayKlass::compute_modifier_flags() const {\n+u2 ObjArrayKlass::compute_modifier_flags() const {\n@@ -368,1 +368,1 @@\n-  jint element_flags = bottom_klass()->compute_modifier_flags();\n+  u2 element_flags = bottom_klass()->compute_modifier_flags();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,1 +138,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  return m.must_be_preserved(this);\n+  return m.must_be_preserved();\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,2 +78,2 @@\n-jint TypeArrayKlass::compute_modifier_flags() const {\n-  int identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n+u2 TypeArrayKlass::compute_modifier_flags() const {\n+  u2 identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -236,7 +236,1 @@\n-  \/\/ But here we have to pay extra attention:\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (!_range_check_dependency) {\n-    res = widen_type(phase, res, T_INT);\n-  }\n+  res = widen_type(phase, res, T_INT);\n@@ -247,2 +241,4 @@\n-static Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInteger* type, ConstraintCastNode::DependencyType dependency, BasicType bt) {\n-  Node* n = ConstraintCastNode::make_cast_for_basic_type(control, parent, type, dependency, bt);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n+  Node* n = clone();\n+  n->set_req(1, parent);\n+  n->as_ConstraintCast()->set_type(type);\n@@ -262,1 +258,1 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n@@ -266,1 +262,1 @@\n-  if (!_range_check_dependency) {\n+  if (!_range_check_dependency || phase->C->post_loop_opts_phase()) {\n@@ -269,0 +265,1 @@\n+  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -277,7 +274,0 @@\n-  if (_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      return this->in(1);\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n@@ -312,0 +302,28 @@\n+void CastIINode::remove_range_check_cast(Compile* C) {\n+  if (has_range_check()) {\n+    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n+    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n+    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n+    \/\/ range check or a null divisor check.\n+    assert(in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n+    ResourceMark rm;\n+    Unique_Node_List wq;\n+    wq.push(this);\n+    for (uint next = 0; next < wq.size(); ++next) {\n+      Node* m = wq.at(next);\n+      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+        Node* use = m->fast_out(i);\n+        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n+          use->ensure_control_or_add_prec(in(0));\n+        } else if (!use->is_CFG() && !use->is_Phi()) {\n+          wq.push(use);\n+        }\n+      }\n+    }\n+    subsume_by(in(1), C);\n+    if (outcnt() == 0) {\n+      disconnect_inputs(C);\n+    }\n+  }\n+}\n+\n@@ -548,2 +566,2 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, in(0), rx, _dependency, bt);\n-    Node* cy = find_or_make_integer_cast(igvn, y, in(0), ry, _dependency, bt);\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n@@ -124,0 +125,1 @@\n+  void remove_range_check_cast(Compile* C);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3631,0 +3631,7 @@\n+    \/\/ If the divisor input for a Div (or Mod etc.) is not zero, then the control input of the Div is set to zero.\n+    \/\/ It could be that the divisor input is found not zero because its type is narrowed down by a CastII in the\n+    \/\/ subgraph for that input. Range check CastIIs are removed during final graph reshape. To preserve the dependency\n+    \/\/ carried by a CastII, precedence edges are added to the Div node. We need to transfer the precedence edges to the\n+    \/\/ DivMod node so the dependency is not lost.\n+    divmod->add_prec_from(n);\n+    divmod->add_prec_from(d);\n@@ -3917,0 +3924,4 @@\n+  case Op_CastII: {\n+    n->as_CastII()->remove_range_check_cast(this);\n+    break;\n+  }\n@@ -4068,10 +4079,0 @@\n-#ifdef ASSERT\n-  case Op_CastII:\n-    \/\/ Verify that all range check dependent CastII nodes were removed.\n-    if (n->isa_CastII()->has_range_check()) {\n-      n->dump(3);\n-      assert(false, \"Range check dependent CastII node was not removed\");\n-    }\n-    break;\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -4069,1 +4069,1 @@\n-                                    Klass::access_flags_offset(), TypeInt::INT, T_INT);\n+                                    Klass::access_flags_offset(), TypeInt::CHAR, T_CHAR);\n@@ -4102,2 +4102,1 @@\n-    assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), \"change next line\");\n-    return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);\n+    return_type = TypeInt::CHAR;\n@@ -4125,1 +4124,1 @@\n-    return_type = TypeInt::INT;  \/\/ not bool!  6297094\n+    return_type = TypeInt::CHAR;\n@@ -4186,1 +4185,1 @@\n-    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n@@ -4251,1 +4250,1 @@\n-    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2007,1 +2007,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _modifier_flags\");\n+    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _modifier_flags\");\n@@ -2013,1 +2013,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _access_flags\");\n+    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _access_flags\");\n@@ -2019,1 +2019,1 @@\n-    assert(this->Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n+    assert(Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n@@ -2024,1 +2024,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _layout_helper\");\n+    assert(Opcode() == Op_LoadI, \"must load an int from _layout_helper\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2904,0 +2904,9 @@\n+void Node::add_prec_from(Node* n) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    Node* prec = n->in(i);\n+    if (prec != nullptr) {\n+      add_prec(prec);\n+    }\n+  }\n+}\n+\n@@ -2927,0 +2936,3 @@\n+bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n+                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-  const node_idx_t _idx;\n+  node_idx_t _idx;\n@@ -593,2 +593,1 @@\n-    const node_idx_t* ref = &_idx;\n-    *(node_idx_t*)ref = new_idx;\n+    _idx = new_idx;\n@@ -1183,0 +1182,1 @@\n+  void add_prec_from(Node* n);\n@@ -1294,0 +1294,2 @@\n+  bool is_div_or_mod(BasicType bt) const;\n+\n@@ -2077,0 +2079,4 @@\n+Op_IL(Div)\n+Op_IL(Mod)\n+Op_IL(UDiv)\n+Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2511,1 +2511,1 @@\n-#define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \\\n+#define DEFINE_GETSCALARARRAYELEMENTS(ElementType,Result \\\n@@ -2545,1 +2545,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool\n+DEFINE_GETSCALARARRAYELEMENTS(jboolean, Boolean\n@@ -2548,1 +2548,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte\n+DEFINE_GETSCALARARRAYELEMENTS(jbyte,    Byte\n@@ -2551,1 +2551,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short\n+DEFINE_GETSCALARARRAYELEMENTS(jshort,   Short\n@@ -2554,1 +2554,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char\n+DEFINE_GETSCALARARRAYELEMENTS(jchar,    Char\n@@ -2557,1 +2557,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int\n+DEFINE_GETSCALARARRAYELEMENTS(jint,     Int\n@@ -2560,1 +2560,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long\n+DEFINE_GETSCALARARRAYELEMENTS(jlong,    Long\n@@ -2564,1 +2564,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float\n+DEFINE_GETSCALARARRAYELEMENTS(jfloat,   Float\n@@ -2567,1 +2567,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double\n+DEFINE_GETSCALARARRAYELEMENTS(jdouble,  Double\n@@ -2572,2 +2572,2 @@\n-#define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \\\n-                                          , EntryProbe, ReturnProbe);\\\n+#define DEFINE_RELEASESCALARARRAYELEMENTS(ElementType,Result \\\n+                                          , EntryProbe, ReturnProbe) \\\n@@ -2592,1 +2592,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool\n+DEFINE_RELEASESCALARARRAYELEMENTS(jboolean, Boolean\n@@ -2595,1 +2595,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte\n+DEFINE_RELEASESCALARARRAYELEMENTS(jbyte,    Byte\n@@ -2598,1 +2598,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short\n+DEFINE_RELEASESCALARARRAYELEMENTS(jshort,   Short\n@@ -2601,1 +2601,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char\n+DEFINE_RELEASESCALARARRAYELEMENTS(jchar,    Char\n@@ -2604,1 +2604,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int\n+DEFINE_RELEASESCALARARRAYELEMENTS(jint,     Int\n@@ -2607,1 +2607,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long\n+DEFINE_RELEASESCALARARRAYELEMENTS(jlong,    Long\n@@ -2610,1 +2610,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float\n+DEFINE_RELEASESCALARARRAYELEMENTS(jfloat,   Float\n@@ -2613,1 +2613,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double\n+DEFINE_RELEASESCALARARRAYELEMENTS(jdouble,  Double\n@@ -2631,2 +2631,2 @@\n-#define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \\\n-                                    , EntryProbe, ReturnProbe); \\\n+#define DEFINE_GETSCALARARRAYREGION(ElementType,Result \\\n+                                    , EntryProbe, ReturnProbe) \\\n@@ -2648,1 +2648,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool\n+DEFINE_GETSCALARARRAYREGION(jboolean,Boolean\n@@ -2651,1 +2651,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte\n+DEFINE_GETSCALARARRAYREGION(jbyte,   Byte\n@@ -2654,1 +2654,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short\n+DEFINE_GETSCALARARRAYREGION(jshort,  Short\n@@ -2657,1 +2657,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char\n+DEFINE_GETSCALARARRAYREGION(jchar,   Char\n@@ -2660,1 +2660,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int\n+DEFINE_GETSCALARARRAYREGION(jint,    Int\n@@ -2663,1 +2663,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long\n+DEFINE_GETSCALARARRAYREGION(jlong,   Long\n@@ -2666,1 +2666,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float\n+DEFINE_GETSCALARARRAYREGION(jfloat,  Float\n@@ -2669,1 +2669,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double\n+DEFINE_GETSCALARARRAYREGION(jdouble, Double\n@@ -2674,2 +2674,2 @@\n-#define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \\\n-                                    , EntryProbe, ReturnProbe); \\\n+#define DEFINE_SETSCALARARRAYREGION(ElementType,Result \\\n+                                    , EntryProbe, ReturnProbe) \\\n@@ -2691,1 +2691,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool\n+DEFINE_SETSCALARARRAYREGION(jboolean, Boolean\n@@ -2694,1 +2694,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte\n+DEFINE_SETSCALARARRAYREGION(jbyte,    Byte\n@@ -2697,1 +2697,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short\n+DEFINE_SETSCALARARRAYREGION(jshort,   Short\n@@ -2700,1 +2700,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char\n+DEFINE_SETSCALARARRAYREGION(jchar,    Char\n@@ -2703,1 +2703,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int\n+DEFINE_SETSCALARARRAYREGION(jint,     Int\n@@ -2706,1 +2706,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long\n+DEFINE_SETSCALARARRAYREGION(jlong,    Long\n@@ -2709,1 +2709,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float\n+DEFINE_SETSCALARARRAYREGION(jfloat,   Float\n@@ -2712,1 +2712,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double\n+DEFINE_SETSCALARARRAYREGION(jdouble,  Double\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1432,1 +1432,1 @@\n-  debug_only(int computed_modifiers = k->compute_modifier_flags());\n+  debug_only(u2 computed_modifiers = k->compute_modifier_flags());\n@@ -1944,1 +1944,1 @@\n-  return k->access_flags().as_int() & JVM_ACC_WRITTEN_FLAGS;\n+  return k->access_flags().as_class_flags();\n@@ -2623,1 +2623,1 @@\n-  return method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  return method->access_flags().as_method_flags();\n@@ -2820,1 +2820,1 @@\n-          return fs.access_flags().as_short();\n+          return fs.access_flags().as_field_flags();\n@@ -2849,1 +2849,1 @@\n-            return method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+            return method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-    write_u2(access_flags.get_flags());\n+    write_u2(access_flags.as_field_flags());\n@@ -728,1 +728,1 @@\n-  write_u2(access_flags.get_flags() & JVM_RECOGNIZED_METHOD_MODIFIERS);\n+  write_u2(access_flags.as_method_flags());\n@@ -949,1 +949,2 @@\n-  write_u2(ik()->access_flags().get_flags() & (JVM_RECOGNIZED_CLASS_MODIFIERS));\n+  write_u2(ik()->access_flags().as_class_flags());\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3154,1 +3154,1 @@\n-  jint result = resultFlags.as_int();\n+  jint result = resultFlags.as_field_flags();\n@@ -3233,1 +3233,1 @@\n-  (*modifiers_ptr) = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  (*modifiers_ptr) = method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1007,2 +1007,2 @@\n-  jushort old_flags = (jushort) the_class->access_flags().get_flags();\n-  jushort new_flags = (jushort) scratch_class->access_flags().get_flags();\n+  u2 old_flags = the_class->access_flags().as_class_flags();\n+  u2 new_flags = scratch_class->access_flags().as_class_flags();\n@@ -1042,3 +1042,3 @@\n-    old_flags = old_fs.access_flags().as_short();\n-    new_flags = new_fs.access_flags().as_short();\n-    if ((old_flags ^ new_flags) & JVM_RECOGNIZED_FIELD_MODIFIERS) {\n+    old_flags = old_fs.access_flags().as_field_flags();\n+    new_flags = new_fs.access_flags().as_field_flags();\n+    if (old_flags != new_flags) {\n@@ -1149,2 +1149,2 @@\n-      old_flags = (jushort) k_old_method->access_flags().get_flags();\n-      new_flags = (jushort) k_new_method->access_flags().get_flags();\n+      old_flags = k_old_method->access_flags().as_method_flags();\n+      new_flags = k_new_method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  int flags = (m->access_flags().as_method_flags());\n@@ -358,1 +358,1 @@\n-  int flags = (jushort)( fd.access_flags().as_short());\n+  int flags = fd.access_flags().as_field_flags();\n@@ -416,1 +416,1 @@\n-    int flags = m->access_flags().as_int();\n+    int flags = m->access_flags().as_method_flags();\n@@ -429,1 +429,1 @@\n-    int flags = m->access_flags().as_int();\n+    int flags = m->access_flags().as_method_flags();\n@@ -534,1 +534,1 @@\n-      int flags = m->access_flags().as_int();\n+      int flags = m->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -928,0 +928,7 @@\n+  AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);\n+  if (comp == nullptr) {\n+    \/\/ Could have compLevel == 0, or !TieredCompilation and incompatible values of TieredStopAtLevel and compLevel.\n+    tty->print_cr(\"WB error: no compiler for requested compilation level %d\", compLevel);\n+    return false;\n+  }\n+\n@@ -934,2 +941,0 @@\n-  AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);\n-  assert(comp != nullptr, \"compiler not available\");\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1206,4 +1206,1 @@\n-  if (CrashGCForDumpingJavaThread) {\n-    char *t = nullptr;\n-    *t = 'c';\n-  }\n+  guarantee(!CrashGCForDumpingJavaThread, \"\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -784,1 +784,1 @@\n-  const int modifiers = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  const int modifiers = method->access_flags().as_method_flags();\n@@ -826,1 +826,1 @@\n-  const int modifiers = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  const int modifiers = method->access_flags().as_method_flags();\n@@ -873,2 +873,1 @@\n-  int modifiers = fd->access_flags().as_int();\n-  java_lang_reflect_Field::set_modifiers(rh(), modifiers);\n+  java_lang_reflect_Field::set_modifiers(rh(), fd->access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1313,7 +1313,0 @@\n-  \/\/ Start with ceiling based on a per-thread estimate:\n-  size_t ceiling = ObjectSynchronizer::in_use_list_ceiling();\n-  size_t old_ceiling = ceiling;\n-  if (ceiling < list->max()) {\n-    \/\/ The max used by the system has exceeded the ceiling so use that:\n-    ceiling = list->max();\n-  }\n@@ -1324,11 +1317,6 @@\n-  if (NoAsyncDeflationProgressMax != 0 &&\n-      _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n-    double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n-    size_t new_ceiling = ceiling + (size_t)((double)ceiling * remainder) + 1;\n-    ObjectSynchronizer::set_in_use_list_ceiling(new_ceiling);\n-    log_info(monitorinflation)(\"Too many deflations without progress; \"\n-                               \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n-                               \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n-    _no_progress_cnt = 0;\n-    ceiling = new_ceiling;\n-  }\n+  size_t old_ceiling = ObjectSynchronizer::in_use_list_ceiling();\n+  \/\/ Make sure that we use a ceiling value that is not lower than\n+  \/\/ previous, not lower than the recorded max used by the system, and\n+  \/\/ not lower than the current number of monitors in use (which can\n+  \/\/ race ahead of max). The result is guaranteed > 0.\n+  size_t ceiling = MAX3(old_ceiling, list->max(), monitors_used);\n@@ -1339,0 +1327,25 @@\n+    \/\/ Deflate monitors if over the threshold percentage, unless no\n+    \/\/ progress on previous deflations.\n+    bool is_above_threshold = true;\n+\n+    \/\/ Check if it's time to adjust the in_use_list_ceiling up, due\n+    \/\/ to too many async deflation attempts without any progress.\n+    if (NoAsyncDeflationProgressMax != 0 &&\n+        _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n+      double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n+      size_t delta = (size_t)(ceiling * remainder) + 1;\n+      size_t new_ceiling = (ceiling > SIZE_MAX - delta)\n+        ? SIZE_MAX         \/\/ Overflow, let's clamp new_ceiling.\n+        : ceiling + delta;\n+\n+      ObjectSynchronizer::set_in_use_list_ceiling(new_ceiling);\n+      log_info(monitorinflation)(\"Too many deflations without progress; \"\n+                                 \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n+                                 \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n+      _no_progress_cnt = 0;\n+      ceiling = new_ceiling;\n+\n+      \/\/ Check if our monitor usage is still above the threshold:\n+      monitor_usage = (monitors_used * 100LL) \/ ceiling;\n+      is_above_threshold = int(monitor_usage) > MonitorUsedDeflationThreshold;\n+    }\n@@ -1342,1 +1355,1 @@\n-    return true;\n+    return is_above_threshold;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,1 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               jint)                                  \\\n+  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n@@ -1022,1 +1022,1 @@\n-  nonstatic_field(AccessFlags,                 _flags,                                        jint)                                  \\\n+  nonstatic_field(AccessFlags,                 _flags,                                        u2)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  assert(sizeof(AccessFlags) == sizeof(jint), \"just checking size of flags\");\n+  assert(sizeof(AccessFlags) == sizeof(u2), \"just checking size of flags\");\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-\/\/ AccessFlags is an abstraction over Java access flags.\n+\/\/ AccessFlags is an abstraction over Java ACC flags.\n+\/\/ See generated file classfile_constants.h for shared JVM_ACC_XXX access flags\n@@ -37,10 +38,0 @@\n-enum {\n-  \/\/ See jvm.h for shared JVM_ACC_XXX access flags\n-\n-  \/\/ flags actually put in .class file\n-  JVM_ACC_WRITTEN_FLAGS           = 0x00007FFF,\n-\n-  \/\/ Do not add new ACC flags here.\n-};\n-\n-\n@@ -50,1 +41,1 @@\n-  jint _flags;  \/\/ TODO: move 4 access flags above to Klass and change to u2\n+  u2 _flags;\n@@ -54,1 +45,1 @@\n-  explicit AccessFlags(jint flags) : _flags(flags) {}\n+  explicit AccessFlags(u2 flags) : _flags(flags) {}\n@@ -69,0 +60,1 @@\n+  bool has_vararg     () const         { return (_flags & JVM_ACC_VARARGS     ) != 0; }\n@@ -74,2 +66,2 @@\n-  \/\/ get .class file flags\n-  jint get_flags               () const { return (_flags & JVM_ACC_WRITTEN_FLAGS); }\n+  \/\/ get as integral value\n+  u2 as_unsigned_short() const         { return _flags; }\n@@ -77,6 +69,1 @@\n-  \/\/ Initialization\n-  void set_field_flags(jint flags)      {\n-    assert((flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == flags, \"only recognized flags\");\n-    _flags = (flags & JVM_RECOGNIZED_FIELD_MODIFIERS);\n-  }\n-  void set_flags(jint flags)            { _flags = (flags & JVM_ACC_WRITTEN_FLAGS); }\n+  void set_flags(u2 flags)            { _flags = flags; }\n@@ -94,3 +81,1 @@\n-  \/\/ Conversion\n-  jshort as_short() const              { return (jshort)_flags; }\n-  jint   as_int() const                { return _flags; }\n+  inline friend AccessFlags accessFlags_from(u2 flags);\n@@ -98,1 +83,14 @@\n-  inline friend AccessFlags accessFlags_from(jint flags);\n+  u2 as_method_flags() const {\n+    assert((_flags & JVM_RECOGNIZED_METHOD_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n+\n+  u2 as_field_flags() const  {\n+    assert((_flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n+\n+  u2 as_class_flags() const  {\n+    assert((_flags & JVM_RECOGNIZED_CLASS_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n@@ -108,1 +106,1 @@\n-inline AccessFlags accessFlags_from(jint flags) {\n+inline AccessFlags accessFlags_from(u2 flags) {\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+\/\/  _0    - print as hexadecimal, with leading 0s, without 0x prefix: 0012345\n@@ -134,0 +135,1 @@\n+#define UINT64_FORMAT_0          \"%016\"       PRIx64\n@@ -188,0 +190,5 @@\n+\/\/ Convert pointer to uintptr_t\n+inline uintptr_t p2u(const volatile void* p) {\n+  return (uintptr_t) p;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,6 +143,7 @@\n-     * transforming a classfile.  Reusing the constant pool enables significant\n-     * optimizations in processing time and minimizes differences between the\n-     * original and transformed classfile, but may result in a bigger classfile\n-     * when a classfile is significantly transformed.\n-     * Default is {@code SHARED_POOL} to preserve the original constant\n-     * pool.\n+     * transforming a {@code class} file.  Reusing the constant pool enables\n+     * significant optimizations in processing time and minimizes differences\n+     * between the original and transformed {@code class} files, but may result\n+     * in a bigger transformed {@code class} file when many elements of the\n+     * original {@code class} file are dropped and many original constant\n+     * pool entries become unused.  Default is {@link #SHARED_POOL} to preserve\n+     * the original constant pool.\n@@ -150,0 +151,3 @@\n+     * @see ConstantPoolBuilder\n+     * @see #build(ClassEntry, ConstantPoolBuilder, Consumer)\n+     * @see #transformClass(ClassModel, ClassTransform)\n@@ -154,1 +158,17 @@\n-        \/** Preserves the original constant pool when transforming classfile *\/\n+        \/**\n+         * Preserves the original constant pool when transforming the {@code\n+         * class} file.\n+         * <p>\n+         * These two transformations below are equivalent:\n+         * {@snippet lang=java :\n+         * ClassModel originalClass = null; \/\/ @replace substring=null; replacement=...\n+         * ClassDesc resultClassName = null; \/\/ @replace substring=null; replacement=...\n+         * ClassTransform classTransform = null; \/\/ @replace substring=null; replacement=...\n+         * var resultOne = ClassFile.of(ConstantPoolSharingOption.SHARED_POOL)\n+         *         .transformClass(originalClass, resultClassName, classTransform);\n+         * var resultTwo = ClassFile.of().build(resultClassName, ConstantPoolBuilder.of(originalClass),\n+         *         clb -> clb.transform(originalClass, classTransform));\n+         * }\n+         *\n+         * @see ConstantPoolBuilder#of(ClassModel) ConstantPoolBuilder::of(ClassModel)\n+         *\/\n@@ -157,1 +177,16 @@\n-        \/** Creates a new constant pool when transforming classfile *\/\n+        \/**\n+         * Creates a new constant pool when transforming the {@code class} file.\n+         * <p>\n+         * These two transformations below are equivalent:\n+         * {@snippet lang=java :\n+         * ClassModel originalClass = null; \/\/ @replace substring=null; replacement=...\n+         * ClassDesc resultClassName = null; \/\/ @replace substring=null; replacement=...\n+         * ClassTransform classTransform = null; \/\/ @replace substring=null; replacement=...\n+         * var resultOne = ClassFile.of(ConstantPoolSharingOption.NEW_POOL)\n+         *         .transformClass(originalClass, resultClassName, classTransform);\n+         * var resultTwo = ClassFile.of().build(resultClassName, ConstantPoolBuilder.of(),\n+         *         clb -> clb.transform(originalClass, classTransform));\n+         * }\n+         *\n+         * @see ConstantPoolBuilder#of() ConstantPoolBuilder::of()\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,8 +199,0 @@\n-    exports jdk.internal.org.objectweb.asm to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.tree to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.util to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.commons to\n-        jdk.jfr;\n@@ -228,1 +220,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.graal.compiler;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.stream.Stream;\n@@ -34,1 +35,2 @@\n-import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.util.Assert;\n@@ -39,1 +41,1 @@\n-import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Names;\n@@ -42,1 +44,0 @@\n-import com.sun.tools.javac.util.Pair;\n@@ -52,2 +53,2 @@\n-public class Lint\n-{\n+public class Lint {\n+\n@@ -66,2 +67,9 @@\n-     * Returns the result of combining the values in this object with\n-     * the given annotation.\n+     * Obtain an instance with additional warning supression applied from any\n+     * @SuppressWarnings and\/or @Deprecated annotations on the given symbol.\n+     *\n+     * <p>\n+     * The returned instance will be different from this instance if and only if\n+     * {@link #suppressionsFrom} returns a non-empty set.\n+     *\n+     * @param sym symbol\n+     * @return lint instance with new warning suppressions applied, or this instance if none\n@@ -69,2 +77,9 @@\n-    public Lint augment(Attribute.Compound attr) {\n-        return augmentor.augment(this, attr);\n+    public Lint augment(Symbol sym) {\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(sym);\n+        if (!suppressions.isEmpty()) {\n+            Lint lint = new Lint(this);\n+            lint.values.removeAll(suppressions);\n+            lint.suppressedValues.addAll(suppressions);\n+            return lint;\n+        }\n+        return this;\n@@ -73,3 +88,2 @@\n-\n-     * Returns the result of combining the values in this object with\n-     * the metadata on the given symbol.\n+     * Returns a new Lint that has the given LintCategorys enabled.\n+     * @param lc one or more categories to be enabled\n@@ -78,8 +92,4 @@\n-    public Lint augment(Symbol sym) {\n-        Lint l = augmentor.augment(this, sym.getDeclarationAttributes());\n-        if (sym.isDeprecated() && sym.isDeprecatableViaAnnotation()) {\n-            if (l == this)\n-                l = new Lint(this);\n-            l.values.remove(LintCategory.DEPRECATION);\n-            l.suppressedValues.add(LintCategory.DEPRECATION);\n-        }\n+    public Lint enable(LintCategory... lc) {\n+        Lint l = new Lint(this);\n+        l.values.addAll(Arrays.asList(lc));\n+        l.suppressedValues.removeAll(Arrays.asList(lc));\n@@ -100,1 +110,5 @@\n-    private final AugmentVisitor augmentor;\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily to avoid dependency loops\n+    private Symtab syms;\n+    private Names names;\n@@ -102,0 +116,1 @@\n+    \/\/ Invariant: it's never the case that a category is in both \"values\" and \"suppressedValues\"\n@@ -117,1 +132,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -120,1 +135,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -149,1 +164,1 @@\n-        suppressedValues = EnumSet.noneOf(LintCategory.class);\n+        suppressedValues = LintCategory.newEmptySet();\n@@ -151,0 +166,1 @@\n+        this.context = context;\n@@ -152,1 +168,0 @@\n-        augmentor = new AugmentVisitor(context);\n@@ -156,1 +171,3 @@\n-        this.augmentor = other.augmentor;\n+        this.context = other.context;\n+        this.syms = other.syms;\n+        this.names = other.names;\n@@ -163,1 +180,1 @@\n-        return \"Lint:[values\" + values + \" suppressedValues\" + suppressedValues + \"]\";\n+        return \"Lint:[enable\" + values + \",suppress\" + suppressedValues + \"]\";\n@@ -381,0 +398,5 @@\n+        public static EnumSet<LintCategory> newEmptySet() {\n+            return EnumSet.noneOf(LintCategory.class);\n+        }\n+\n+        \/** Get the string representing this category in @SuppressAnnotations and -Xlint options. *\/\n@@ -412,63 +434,16 @@\n-    protected static class AugmentVisitor implements Attribute.Visitor {\n-        private final Context context;\n-        private Symtab syms;\n-        private Lint parent;\n-        private Lint lint;\n-\n-        AugmentVisitor(Context context) {\n-            \/\/ to break an ugly sequence of initialization dependencies,\n-            \/\/ we defer the initialization of syms until it is needed\n-            this.context = context;\n-        }\n-\n-        Lint augment(Lint parent, Attribute.Compound attr) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            attr.accept(this);\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        Lint augment(Lint parent, List<Attribute.Compound> attrs) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            for (Attribute.Compound a: attrs) {\n-                a.accept(this);\n-            }\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        private void initSyms() {\n-            if (syms == null)\n-                syms = Symtab.instance(context);\n-        }\n-\n-        private void suppress(LintCategory lc) {\n-            if (lint == null)\n-                lint = new Lint(parent);\n-            lint.suppressedValues.add(lc);\n-            lint.values.remove(lc);\n-        }\n-\n-        public void visitConstant(Attribute.Constant value) {\n-            if (value.type.tsym == syms.stringType.tsym) {\n-                LintCategory.get((String)value.value)\n-                  .ifPresent(this::suppress);\n-            }\n-        }\n-\n-        public void visitClass(Attribute.Class clazz) {\n-        }\n-\n-        \/\/ If we find a @SuppressWarnings annotation, then we continue\n-        \/\/ walking the tree, in order to suppress the individual warnings\n-        \/\/ specified in the @SuppressWarnings annotation.\n-        public void visitCompound(Attribute.Compound compound) {\n-            if (compound.type.tsym == syms.suppressWarningsType.tsym) {\n-                for (List<Pair<MethodSymbol,Attribute>> v = compound.values;\n-                     v.nonEmpty(); v = v.tail) {\n-                    Pair<MethodSymbol,Attribute> value = v.head;\n-                    if (value.fst.name.toString().equals(\"value\"))\n-                        value.snd.accept(this);\n-                }\n+    \/**\n+     * Obtain the set of recognized lint warning categories suppressed at the given symbol's declaration.\n+     *\n+     * <p>\n+     * This set can be non-empty only if the symbol is annotated with either\n+     * @SuppressWarnings or @Deprecated.\n+     *\n+     * @param symbol symbol corresponding to a possibly-annotated declaration\n+     * @return new warning suppressions applied to sym\n+     *\/\n+    public EnumSet<LintCategory> suppressionsFrom(Symbol symbol) {\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(symbol.getDeclarationAttributes().stream());\n+        if (symbol.isDeprecated() && symbol.isDeprecatableViaAnnotation())\n+            suppressions.add(LintCategory.DEPRECATION);\n+        return suppressions;\n+    }\n@@ -476,2 +451,13 @@\n-            }\n-        }\n+    \/**\n+     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n+     *\n+     * @param annotation @SuppressWarnings annotation, or null\n+     * @return set of lint categories, possibly empty but never null\n+     *\/\n+    private EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n+        initializeIfNeeded();\n+        if (annotation == null)\n+            return LintCategory.newEmptySet();\n+        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n+        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n+    }\n@@ -479,4 +465,10 @@\n-        public void visitArray(Attribute.Array array) {\n-            for (Attribute value : array.values)\n-                value.accept(this);\n-        }\n+    \/\/ Find the @SuppressWarnings annotation in the given stream and extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Stream<Attribute.Compound> attributes) {\n+        initializeIfNeeded();\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        attributes\n+          .filter(attribute -> attribute.type.tsym == syms.suppressWarningsType.tsym)\n+          .map(this::suppressionsFrom)\n+          .forEach(result::addAll);\n+        return result;\n+    }\n@@ -484,1 +476,8 @@\n-        public void visitEnum(Attribute.Enum e) {\n+    \/\/ Given a @SuppressWarnings annotation, extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Attribute.Compound suppressWarnings) {\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        Attribute.Array values = (Attribute.Array)suppressWarnings.member(names.value);\n+        for (Attribute value : values.values) {\n+            Optional.of((String)((Attribute.Constant)value).value)\n+              .flatMap(LintCategory::get)\n+              .ifPresent(result::add);\n@@ -486,0 +485,2 @@\n+        return result;\n+    }\n@@ -487,1 +488,4 @@\n-        public void visitError(Attribute.Error e) {\n+    private void initializeIfNeeded() {\n+        if (syms == null) {\n+            syms = Symtab.instance(context);\n+            names = Names.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":103,"deletions":99,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3049,0 +3049,1 @@\n+    \/\/ Apply special flag \"-XDwarnOnAccessToMembers\" which turns on just this particular warning for all types of access\n@@ -3050,4 +3051,11 @@\n-        if (warnOnAnyAccessToMembers ||\n-            (lint.isEnabled(LintCategory.SERIAL) &&\n-            !lint.isSuppressed(LintCategory.SERIAL) &&\n-            isLambda)) {\n+        final Lint prevLint = setLint(warnOnAnyAccessToMembers ? lint.enable(LintCategory.SERIAL) : lint);\n+        try {\n+            if (warnOnAnyAccessToMembers || isLambda)\n+                checkAccessFromSerializableElementInner(tree, isLambda);\n+        } finally {\n+            setLint(prevLint);\n+        }\n+    }\n+\n+    private void checkAccessFromSerializableElementInner(final JCTree tree, boolean isLambda) {\n+        if (lint.isEnabled(LintCategory.SERIAL)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,1 +232,0 @@\n-        new ThisEscapeAnalyzer(names, syms, types, rs, log, lint).analyzeTree(env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -247,1 +247,0 @@\n-vmTestbase\/gc\/memory\/Nio\/Nio.java 8340728 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-java\/util\/concurrent\/locks\/StampedLock\/OOMEInStampedLock.java 8345266 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -589,2 +589,0 @@\n-java\/nio\/channels\/AsynchronousSocketChannel\/StressLoopback.java 8211851 aix-ppc64\n-\n@@ -733,0 +731,2 @@\n+com\/sun\/jdi\/ProcessAttachTest.java         8346827 linux-all\n+com\/sun\/jdi\/ReattachStressTest.java        8346827 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}