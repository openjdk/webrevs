{"files":[{"patch":"@@ -248,1 +248,1 @@\n-<code>ASSERT_TRUE((val1 == val2 &amp;&amp; isFail(foo(8)) || i == 18)<\/code>\n+<code>ASSERT_TRUE((val1 == val2 &amp;&amp; isFail(foo(8))) || i == 18)<\/code>\n","filename":"doc\/hotspot-unit-tests.html","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-`ASSERT_TRUE((val1 == val2 && isFail(foo(8)) || i == 18)` prints only\n+`ASSERT_TRUE((val1 == val2 && isFail(foo(8))) || i == 18)` prints only\n","filename":"doc\/hotspot-unit-tests.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,0 @@\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,1 +570,1 @@\n-  ldr(r2, Address(r1, Method::access_flags_offset()));\n+  ldrh(r2, Address(r1, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2302,1 +2302,1 @@\n-  ldrw(temp_reg, Address(klass, Klass::access_flags_offset()));\n+  ldrh(temp_reg, Address(klass, Klass::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -599,1 +599,1 @@\n-      __ ldrw(rscratch1, Address(rmethod, Method::access_flags_offset()));\n+      __ ldrh(rscratch1, Address(rmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -818,1 +818,1 @@\n-    __ ldrw(r0, access_flags);\n+    __ ldrh(r0, access_flags);\n@@ -829,1 +829,1 @@\n-    __ ldrw(r0, access_flags);\n+    __ ldrh(r0, access_flags);\n@@ -1234,1 +1234,1 @@\n-  __ ldrw(r0, access_flags);\n+  __ ldrh(r0, access_flags);\n@@ -1286,1 +1286,1 @@\n-      __ ldrw(r0, access_flags);\n+      __ ldrh(r0, access_flags);\n@@ -1363,1 +1363,1 @@\n-    __ ldrw(t, Address(rmethod, Method::access_flags_offset()));\n+    __ ldrh(t, Address(rmethod, Method::access_flags_offset()));\n@@ -1573,1 +1573,1 @@\n-    __ ldrw(t, Address(rmethod, Method::access_flags_offset()));\n+    __ ldrh(t, Address(rmethod, Method::access_flags_offset()));\n@@ -1704,1 +1704,1 @@\n-  __ ldrw(r0, access_flags);\n+  __ ldrh(r0, access_flags);\n@@ -1760,1 +1760,1 @@\n-      __ ldrw(r0, access_flags);\n+      __ ldrh(r0, access_flags);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -739,1 +739,1 @@\n-  ldr_u32(Raccess_flags, Address(Rmethod, Method::access_flags_offset()));\n+  ldrh(Raccess_flags, Address(Rmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -582,1 +582,1 @@\n-      __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+      __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -591,1 +591,1 @@\n-    __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+    __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -854,1 +854,1 @@\n-  __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+  __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -896,1 +896,1 @@\n-        __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+        __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -978,1 +978,1 @@\n-    __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+    __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -1207,1 +1207,1 @@\n-  __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+  __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n@@ -1252,1 +1252,1 @@\n-        __ ldr_u32(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n+        __ ldrh(Rtemp, Address(Rmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -684,1 +684,1 @@\n-    lwz(Raccess_flags, in_bytes(Method::access_flags_offset()), R19_method);\n+    lhz(Raccess_flags, in_bytes(Method::access_flags_offset()), R19_method);\n@@ -691,1 +691,1 @@\n-    rldicl_(R0, Raccess_flags, 64-JVM_ACC_SYNCHRONIZED_BIT, 63); \/\/ Extract bit and compare to 0.\n+    testbitdi(CCR0, R0, Raccess_flags, JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1205,1 +1205,1 @@\n-      __ lwz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n+      __ lhz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,3 +147,3 @@\n-    \/\/ _access_flags must be a 32 bit value.\n-    assert(sizeof(AccessFlags) == 4, \"wrong size\");\n-    __ lwa(R11_scratch1\/*access_flags*\/, method_(access_flags));\n+    \/\/ _access_flags must be a 16 bit value.\n+    assert(sizeof(AccessFlags) == 2, \"wrong size\");\n+    __ lhz(R11_scratch1\/*access_flags*\/, method_(access_flags));\n@@ -826,1 +826,1 @@\n-      __ lwz(Rflags, method_(access_flags));\n+      __ lhz(Rflags, method_(access_flags));\n@@ -1304,2 +1304,2 @@\n-  assert(4 == sizeof(AccessFlags), \"unexpected field size\");\n-  __ lwz(access_flags, method_(access_flags));\n+  assert(2 == sizeof(AccessFlags), \"unexpected field size\");\n+  __ lhz(access_flags, method_(access_flags));\n@@ -1772,1 +1772,1 @@\n-    __ lwz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n+    __ lhz(R0, in_bytes(Method::access_flags_offset()), R19_method);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  static bool supports_shared_stubs() { return false; }\n+  static bool supports_shared_stubs() { return true; }\n","filename":"src\/hotspot\/cpu\/riscv\/codeBuffer_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  \/\/ RiscV loads a 64-bit immediate in up to four separate steps, splitting it into four different sections\n+  \/\/ RISC-V loads a 64-bit immediate in up to four separate steps, splitting it into four different sections\n@@ -54,5 +54,0 @@\n-  \/\/ Failing that, attempt to reserve for base=zero shift>0\n-  if (result == nullptr && optimize_for_zero_base) {\n-    result = reserve_address_space_for_zerobased_encoding(size, aslr);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/compressedKlass_riscv.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -547,1 +547,1 @@\n-  ld(x12, Address(x11, Method::access_flags_offset()));\n+  load_unsigned_short(x12, Address(x11, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -644,1 +644,1 @@\n-      __ lwu(t0, Address(xmethod, Method::access_flags_offset()));\n+      __ load_unsigned_short(t0, Address(xmethod, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,1 +192,1 @@\n-      __ call(fn);\n+      __ rt_call(fn);\n@@ -205,1 +205,1 @@\n-      __ call(fn);\n+      __ rt_call(fn);\n@@ -218,1 +218,1 @@\n-      __ call(fn);\n+      __ rt_call(fn);\n@@ -231,1 +231,1 @@\n-      __ call(fn);\n+      __ rt_call(fn);\n@@ -244,1 +244,1 @@\n-      __ call(fn);\n+      __ rt_call(fn);\n@@ -257,1 +257,1 @@\n-      __ call(fn);\n+      __ rt_call(fn);\n@@ -271,1 +271,1 @@\n-      __ call(fn);\n+      __ rt_call(fn);\n@@ -717,1 +717,1 @@\n-  __ lwu(x10, access_flags);\n+  __ load_unsigned_short(x10, access_flags);\n@@ -724,1 +724,1 @@\n-    __ lwu(x10, access_flags);\n+    __ load_unsigned_short(x10, access_flags);\n@@ -1031,1 +1031,1 @@\n-  __ lwu(x10, access_flags);\n+  __ load_unsigned_short(x10, access_flags);\n@@ -1069,1 +1069,1 @@\n-    __ lwu(x10, access_flags);\n+    __ load_unsigned_short(x10, access_flags);\n@@ -1133,1 +1133,1 @@\n-    __ lwu(t, Address(xmethod, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(xmethod, Method::access_flags_offset()));\n@@ -1349,1 +1349,1 @@\n-    __ lwu(t, Address(xmethod, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(xmethod, Method::access_flags_offset()));\n@@ -1475,1 +1475,1 @@\n-  __ lwu(x10, access_flags);\n+  __ load_unsigned_short(x10, access_flags);\n@@ -1522,1 +1522,1 @@\n-    __ lwu(x10, access_flags);\n+    __ load_unsigned_short(x10, access_flags);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -783,1 +783,1 @@\n-    testbit(method2_(R_method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+    testbit_ushort(method2_(R_method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1018,0 +1018,12 @@\n+\/\/ Test a bit in memory for 2 byte datatype.\n+void MacroAssembler::testbit_ushort(const Address &a, unsigned int bit) {\n+  assert(a.index() == noreg, \"no index reg allowed in testbit\");\n+  if (bit <= 7) {\n+    z_tm(a.disp() + 1, a.base(), 1 << bit);\n+  } else if (bit <= 15) {\n+    z_tm(a.disp() + 0, a.base(), 1 << (bit - 8));\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,0 +202,1 @@\n+  void testbit_ushort(const Address &a, unsigned int bit);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2398,1 +2398,1 @@\n-      __ testbit(Address(Z_method, Method::access_flags_offset()), JVM_ACC_STATIC_BIT);\n+      __ testbit_ushort(Address(Z_method, Method::access_flags_offset()), JVM_ACC_STATIC_BIT);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,1 +167,1 @@\n-    __ testbit(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n+    __ testbit_ushort(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n@@ -886,1 +886,1 @@\n-    __ testbit(method2_(method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+    __ testbit_ushort(method2_(method, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n@@ -900,1 +900,1 @@\n-    __ testbit(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n+    __ testbit_ushort(method2_(method, access_flags), JVM_ACC_STATIC_BIT);\n@@ -1352,0 +1352,2 @@\n+  \/\/ _access_flags must be a 16 bit value.\n+  assert(sizeof(AccessFlags) == 2, \"testbit_ushort will fail\");\n@@ -1354,1 +1356,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_NATIVE_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_NATIVE_BIT);\n@@ -1360,1 +1362,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n@@ -1406,1 +1408,1 @@\n-      __ testbit(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+      __ testbit_ushort(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n@@ -1464,1 +1466,1 @@\n-    __ testbit(method2_(Rmethod, access_flags), JVM_ACC_STATIC_BIT);\n+    __ testbit_ushort(method2_(Rmethod, access_flags), JVM_ACC_STATIC_BIT);\n@@ -1722,1 +1724,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_NATIVE_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_NATIVE_BIT);\n@@ -1728,1 +1730,1 @@\n-    __ testbit(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n+    __ testbit_ushort(method_(access_flags), JVM_ACC_ABSTRACT_BIT);\n@@ -1778,1 +1780,1 @@\n-      __ testbit(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n+      __ testbit_ushort(method2_(Z_R1_scratch, access_flags), JVM_ACC_SYNCHRONIZED_BIT);\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -311,0 +311,6 @@\n+\n+  \/\/ The OptoScheduling information is not maintained in s390.ad.\n+  if (OptoScheduling) {\n+    warning(\"OptoScheduling is not supported on this CPU.\");\n+    FLAG_SET_DEFAULT(OptoScheduling, false);\n+  }\n@@ -326,6 +332,0 @@\n-\n-  \/\/ The OptoScheduling information is not maintained in s390.ad.\n-  if (OptoScheduling) {\n-    warning(\"OptoScheduling is not supported on this CPU.\");\n-    FLAG_SET_DEFAULT(OptoScheduling, false);\n-  }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1038,1 +1038,1 @@\n-  movl(rcx, Address(rcx, Method::access_flags_offset()));\n+  load_unsigned_short(rcx, Address(rcx, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2930,1 +2930,1 @@\n-  movl(temp_reg, Address(klass, Klass::access_flags_offset()));\n+  load_unsigned_short(temp_reg, Address(klass, Klass::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -885,1 +885,1 @@\n-      __ movl(flags, Address(method, Method::access_flags_offset()));\n+      __ load_unsigned_short(flags, Address(method, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -604,1 +604,1 @@\n-    __ movl(rax, access_flags);\n+    __ load_unsigned_short(rax, access_flags);\n@@ -615,1 +615,1 @@\n-    __ movl(rax, access_flags);\n+    __ load_unsigned_short(rax, access_flags);\n@@ -863,1 +863,1 @@\n-  __ movl(rax, access_flags);\n+  __ load_unsigned_short(rax, access_flags);\n@@ -917,1 +917,1 @@\n-      __ movl(rax, access_flags);\n+      __ load_unsigned_short(rax, access_flags);\n@@ -1007,1 +1007,1 @@\n-    __ movl(t, Address(method, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(method, Method::access_flags_offset()));\n@@ -1288,1 +1288,1 @@\n-    __ movl(t, Address(method, Method::access_flags_offset()));\n+    __ load_unsigned_short(t, Address(method, Method::access_flags_offset()));\n@@ -1440,1 +1440,1 @@\n-  __ movl(rax, access_flags);\n+  __ load_unsigned_short(rax, access_flags);\n@@ -1497,1 +1497,1 @@\n-      __ movl(rax, access_flags);\n+      __ load_unsigned_short(rax, access_flags);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-        __ movl(rscratch1, Address(rbx, Method::access_flags_offset()));\n+        __ load_unsigned_short(rscratch1, Address(rbx, Method::access_flags_offset()));\n@@ -162,1 +162,1 @@\n-  __ movl(c_rarg3, Address(rbx, Method::access_flags_offset()));\n+  __ load_unsigned_short(c_rarg3, Address(rbx, Method::access_flags_offset()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3250,0 +3250,2 @@\n+      set_numa_bitmask_equal(CAST_TO_FN_PTR(numa_bitmask_equal_func_t,\n+                                            libnuma_dlsym(handle, \"numa_bitmask_equal\")));\n@@ -3260,0 +3262,2 @@\n+      set_numa_get_run_node_mask(CAST_TO_FN_PTR(numa_get_run_node_mask_func_t,\n+                                                libnuma_v2_dlsym(handle, \"numa_get_run_node_mask\")));\n@@ -3267,0 +3271,1 @@\n+        set_numa_cpunodebind_bitmask(_numa_get_run_node_mask());\n@@ -3443,0 +3448,1 @@\n+os::Linux::numa_bitmask_equal_func_t os::Linux::_numa_bitmask_equal;\n@@ -3446,0 +3452,1 @@\n+os::Linux::numa_get_run_node_mask_func_t os::Linux::_numa_get_run_node_mask;\n@@ -3454,0 +3461,1 @@\n+struct bitmask* os::Linux::_numa_cpunodebind_bitmask;\n@@ -4478,2 +4486,1 @@\n-    FLAG_SET_ERGO(UseNUMA, false);\n-    FLAG_SET_ERGO(UseNUMAInterleaving, false); \/\/ Also depends on libnuma.\n+    disable_numa(\"Failed to initialize libnuma\");\n@@ -4481,4 +4488,7 @@\n-    if ((Linux::numa_max_node() < 1) || Linux::is_bound_to_single_node()) {\n-      \/\/ If there's only one node (they start from 0) or if the process\n-      \/\/ is bound explicitly to a single node using membind, disable NUMA\n-      UseNUMA = false;\n+    Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n+    if (Linux::numa_max_node() < 1) {\n+      disable_numa(\"Only a single NUMA node is available\");\n+    } else if (Linux::is_bound_to_single_mem_node()) {\n+      disable_numa(\"The process is bound to a single NUMA node\");\n+    } else if (Linux::mem_and_cpu_node_mismatch()) {\n+      disable_numa(\"The process memory and cpu node configuration does not match\");\n@@ -4489,2 +4499,0 @@\n-      Linux::set_configured_numa_policy(Linux::identify_numa_policy());\n-\n@@ -4528,0 +4536,10 @@\n+void os::Linux::disable_numa(const char* reason) {\n+  if ((UseNUMA && FLAG_IS_CMDLINE(UseNUMA)) ||\n+      (UseNUMAInterleaving && FLAG_IS_CMDLINE(UseNUMAInterleaving))) {\n+    \/\/ Only issue a warning if the user explicitly asked for NUMA support\n+    log_warning(os)(\"NUMA support disabled: %s\", reason);\n+  }\n+  FLAG_SET_ERGO(UseNUMA, false);\n+  FLAG_SET_ERGO(UseNUMAInterleaving, false);\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -196,0 +196,1 @@\n+  static void disable_numa(const char* reason);\n@@ -207,0 +208,1 @@\n+  typedef struct bitmask* (*numa_get_run_node_mask_func_t)(void);\n@@ -211,0 +213,1 @@\n+  typedef int (*numa_bitmask_equal_func_t)(struct bitmask *bmp1, struct bitmask *bmp2);\n@@ -224,0 +227,1 @@\n+  static numa_bitmask_equal_func_t _numa_bitmask_equal;\n@@ -226,0 +230,1 @@\n+  static numa_get_run_node_mask_func_t _numa_get_run_node_mask;\n@@ -234,0 +239,1 @@\n+  static struct bitmask* _numa_cpunodebind_bitmask;\n@@ -246,0 +252,1 @@\n+  static void set_numa_bitmask_equal(numa_bitmask_equal_func_t func) { _numa_bitmask_equal = func; }\n@@ -248,0 +255,1 @@\n+  static void set_numa_get_run_node_mask(numa_get_run_node_mask_func_t func) { _numa_get_run_node_mask = func; }\n@@ -256,0 +264,1 @@\n+  static void set_numa_cpunodebind_bitmask(struct bitmask* ptr)        { _numa_cpunodebind_bitmask = ptr ;      }\n@@ -361,3 +370,3 @@\n-  \/\/ Check if bound to only one numa node.\n-  \/\/ Returns true if bound to a single numa node, otherwise returns false.\n-  static bool is_bound_to_single_node() {\n+  \/\/ Check if memory is bound to only one numa node.\n+  \/\/ Returns true if memory is bound to a single numa node, otherwise returns false.\n+  static bool is_bound_to_single_mem_node() {\n@@ -368,1 +377,6 @@\n-    if (_numa_membind_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask != nullptr && _numa_max_node != nullptr && _numa_bitmask_isbitset != nullptr) {\n@@ -375,1 +389,1 @@\n-      if (_numa_bitmask_isbitset(_numa_membind_bitmask, node)) {\n+      if (_numa_bitmask_isbitset(mem_nodes_bitmask, node)) {\n@@ -386,0 +400,13 @@\n+  \/\/ Check if cpu and memory nodes are aligned, returns true if nodes misalign\n+  static bool mem_and_cpu_node_mismatch() {\n+    struct bitmask* mem_nodes_bitmask = Linux::_numa_membind_bitmask;\n+    if (Linux::is_running_in_interleave_mode()) {\n+      mem_nodes_bitmask = Linux::_numa_interleave_bitmask;\n+    }\n+\n+    if (mem_nodes_bitmask == nullptr || Linux::_numa_cpunodebind_bitmask == nullptr) {\n+      return false;\n+    }\n+\n+    return !_numa_bitmask_equal(mem_nodes_bitmask, Linux::_numa_cpunodebind_bitmask);\n+  }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1369,1 +1369,1 @@\n-  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_INT), klass_modifiers);\n+  __ move(new LIR_Address(klass, in_bytes(Klass::modifier_flags_offset()), T_CHAR), klass_modifiers);\n@@ -1374,2 +1374,1 @@\n-  __ cmove(lir_cond_equal, prim_modifiers, klass_modifiers, result, T_INT);\n-\n+  __ cmove(lir_cond_equal, prim_modifiers, klass_modifiers, result, T_CHAR);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -512,6 +512,3 @@\n-    \/\/ copy shared path table to saved.\n-    if (!HAS_PENDING_EXCEPTION) {\n-      VM_PopulateDynamicDumpSharedSpace op(archive_name);\n-      VMThread::execute(&op);\n-      return;\n-    }\n+    VM_PopulateDynamicDumpSharedSpace op(archive_name);\n+    VMThread::execute(&op);\n+    return;\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -992,0 +992,3 @@\n+    } else {\n+      assert(!SystemDictionaryShared::has_class_failed_verification(ik), \"sanity\");\n+      ik->compute_has_loops_flag_for_methods();\n@@ -993,1 +996,0 @@\n-    ik->compute_has_loops_flag_for_methods();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-  st->print(\" flags=%x\", _flags);\n+  st->print(\" flags=%x\", _flags.as_unsigned_short());\n","filename":"src\/hotspot\/share\/ci\/ciFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"jvm_constants.h\"\n@@ -42,1 +41,1 @@\n-  jint _flags;\n+  AccessFlags _flags;\n@@ -44,1 +43,1 @@\n-  bool _intialized_final_update;\n+  bool _initialized_final_update;\n@@ -46,1 +45,1 @@\n-  ciFlags() :_flags(0), _stable(false), _intialized_final_update(false) { }\n+  ciFlags() :_flags(0), _stable(false), _initialized_final_update(false) { }\n@@ -48,1 +47,1 @@\n-    _flags(flags.as_int()), _stable(is_stable), _intialized_final_update(is_initialized_final_update) { }\n+    _flags(flags), _stable(is_stable), _initialized_final_update(is_initialized_final_update) { }\n@@ -52,13 +51,14 @@\n-  bool is_public               () const { return (_flags & JVM_ACC_PUBLIC                    ) != 0; }\n-  bool is_private              () const { return (_flags & JVM_ACC_PRIVATE                   ) != 0; }\n-  bool is_protected            () const { return (_flags & JVM_ACC_PROTECTED                 ) != 0; }\n-  bool is_static               () const { return (_flags & JVM_ACC_STATIC                    ) != 0; }\n-  bool is_final                () const { return (_flags & JVM_ACC_FINAL                     ) != 0; }\n-  bool is_synchronized         () const { return (_flags & JVM_ACC_SYNCHRONIZED              ) != 0; }\n-  bool is_volatile             () const { return (_flags & JVM_ACC_VOLATILE                  ) != 0; }\n-  bool is_transient            () const { return (_flags & JVM_ACC_TRANSIENT                 ) != 0; }\n-  bool is_native               () const { return (_flags & JVM_ACC_NATIVE                    ) != 0; }\n-  bool is_interface            () const { return (_flags & JVM_ACC_INTERFACE                 ) != 0; }\n-  bool is_abstract             () const { return (_flags & JVM_ACC_ABSTRACT                  ) != 0; }\n-  bool has_vararg              () const { return (_flags & JVM_ACC_VARARGS                   ) != 0; }\n-  bool is_identity             () const { return (_flags & JVM_ACC_IDENTITY                  ) != 0; }\n+  bool is_public               () const { return _flags.is_public();       }\n+  bool is_private              () const { return _flags.is_private();      }\n+  bool is_protected            () const { return _flags.is_protected();    }\n+  bool is_static               () const { return _flags.is_static();       }\n+  bool is_final                () const { return _flags.is_final();        }\n+  bool is_synchronized         () const { return _flags.is_synchronized(); }\n+  bool is_volatile             () const { return _flags.is_volatile();     }\n+  bool is_transient            () const { return _flags.is_transient();    }\n+  bool is_native               () const { return _flags.is_native();       }\n+  bool is_interface            () const { return _flags.is_interface();    }\n+  bool is_abstract             () const { return _flags.is_abstract();     }\n+  bool has_vararg              () const { return _flags.has_vararg();      }\n+  bool is_identity             () const { return _flags.is_identity_class(); }\n+\n@@ -70,1 +70,1 @@\n-  bool has_initialized_final_update() const { return _intialized_final_update; };\n+  bool has_initialized_final_update() const { return _initialized_final_update; };\n@@ -73,1 +73,1 @@\n-  jint   as_int()                      { return _flags; }\n+  jint   as_int()                      { return _flags.as_unsigned_short(); }\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,1 +225,1 @@\n-    return get_Klass()->access_flags().as_int();\n+    return get_Klass()->access_flags().as_unsigned_short();\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3068,1 +3068,1 @@\n-    jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n+    u2 recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;\n@@ -3075,1 +3075,1 @@\n-    jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    u2 flags = cfs->get_u2_fast() & recognized_modifiers;\n@@ -3097,1 +3097,1 @@\n-    inner_classes->at_put(index++, inner_access_flags.as_short());\n+    inner_classes->at_put(index++, inner_access_flags.as_unsigned_short());\n@@ -3920,1 +3920,1 @@\n-  int computed_modifiers = this_klass->compute_modifier_flags();\n+  u2 computed_modifiers = this_klass->compute_modifier_flags();\n@@ -5648,1 +5648,1 @@\n-  assert(0 == _access_flags.as_int(), \"invariant\");\n+  assert(0 == _access_flags.as_unsigned_short(), \"invariant\");\n@@ -5809,1 +5809,1 @@\n-  jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n+  u2 recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;\n@@ -5816,1 +5816,1 @@\n-  jint flags = stream->get_u2_fast() & recognized_modifiers;\n+  u2 flags = stream->get_u2_fast() & recognized_modifiers;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3190,1 +3190,1 @@\n-  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  int flags = m->access_flags().as_method_flags();\n@@ -5565,1 +5565,1 @@\n-    tty->print_cr(\"  name: %s, sig: %s, flags: %08x\", fs.name()->as_C_string(), fs.signature()->as_C_string(), fs.access_flags().as_int());\n+    tty->print_cr(\"  name: %s, sig: %s, flags: %08x\", fs.name()->as_C_string(), fs.signature()->as_C_string(), fs.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-inline bool match_F_R(jshort flags) {\n+inline bool match_F_R(u2 flags) {\n@@ -45,1 +45,1 @@\n-inline bool match_F_Y(jshort flags) {\n+inline bool match_F_Y(u2 flags) {\n@@ -51,1 +51,1 @@\n-inline bool match_F_RN(jshort flags) {\n+inline bool match_F_RN(u2 flags) {\n@@ -57,1 +57,1 @@\n-inline bool match_F_S(jshort flags) {\n+inline bool match_F_S(u2 flags) {\n@@ -63,1 +63,1 @@\n-inline bool match_F_SN(jshort flags) {\n+inline bool match_F_SN(u2 flags) {\n@@ -719,1 +719,1 @@\n-                                            jshort flags) {\n+                                            u2 flags) {\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1512,1 +1512,1 @@\n-                         jshort flags);\n+                         u2 flags);\n@@ -1523,1 +1523,1 @@\n-                    jshort flags) {\n+                    u2 flags) {\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2535,0 +2535,5 @@\n+  \/\/ Update compilation times. Used by the implementation of JFR CompilerStatistics\n+  \/\/ and java.lang.management.CompilationMXBean.\n+  _perf_total_compilation->inc(time.ticks());\n+  _peak_compilation_time = MAX2(time.milliseconds(), _peak_compilation_time);\n+\n@@ -2553,6 +2558,0 @@\n-\n-    \/\/ update compilation ticks - used by the implementation of\n-    \/\/ java.lang.management.CompilationMXBean\n-    _perf_total_compilation->inc(time.ticks());\n-    _peak_compilation_time = time.milliseconds() > _peak_compilation_time ? time.milliseconds() : _peak_compilation_time;\n-\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -201,0 +201,8 @@\n+  assert(free_ratio <= 100, \"precondition\");\n+  if (free_ratio == 100) {\n+    \/\/ If 100 then below calculations will divide by zero and return min of\n+    \/\/ resulting infinity and MaxHeapSize.  Avoid issues of UB vs is_iec559\n+    \/\/ and ubsan warnings, and just immediately return MaxHeapSize.\n+    return MaxHeapSize;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -39,1 +40,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -83,2 +84,1 @@\n-    _partial_array_state_allocator(g1h->partial_array_state_manager()),\n-    _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n+    _partial_array_splitter(g1h->partial_array_state_manager(), num_workers),\n@@ -172,3 +172,6 @@\n-  \/\/ Must be in the collection set--it's already been copied.\n-  oop p = task->source();\n-  assert(_g1h->is_in_cset(p), \"p=\" PTR_FORMAT, p2i(p));\n+  assert(task != nullptr, \"invariant\");\n+  \/\/ Source isn't used for processing, so not recorded in task.\n+  assert(task->source() == nullptr, \"invariant\");\n+  oop p = task->destination();\n+  assert(_g1h->is_in_reserved(p),\n+         \"task=\" PTR_FORMAT \" dest=\" PTR_FORMAT, p2i(task), p2i(p));\n@@ -225,24 +228,5 @@\n-void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n-  oop to_obj = state->destination();\n-\n-#ifdef ASSERT\n-  oop from_obj = state->source();\n-  assert(_g1h->is_in_reserved(from_obj), \"must be in heap.\");\n-  assert(from_obj->is_forwarded(), \"must be forwarded\");\n-  assert(from_obj != to_obj, \"should not be chunking self-forwarded objects\");\n-  assert(to_obj->is_objArray(), \"must be obj array\");\n-#endif \/\/ ASSERT\n-\n-  objArrayOop to_array = objArrayOop(to_obj);\n-\n-  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  \/\/ Push any additional partial scan tasks needed.  Pushed before processing\n-  \/\/ the claimed chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  }\n-\n+void G1ParScanThreadState::do_partial_array(PartialArrayState* state, bool stolen) {\n+  \/\/ Access state before release by claim().\n+  objArrayOop to_array = objArrayOop(state->destination());\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, _task_queue, stolen);\n@@ -253,4 +237,2 @@\n-                              checked_cast<int>(step._index),\n-                              checked_cast<int>(step._index + _partial_array_stepper.chunk_size()));\n-  \/\/ Release reference to the state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n+                              checked_cast<int>(claim._start),\n+                              checked_cast<int>(claim._end));\n@@ -268,1 +250,0 @@\n-\n@@ -270,19 +251,3 @@\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  \/\/ Push any needed partial scan tasks.  Pushed before processing the\n-  \/\/ initial chunk to allow other workers to steal while we're processing.\n-  if (step._ncreate > 0) {\n-    assert(step._index < array_length, \"invariant\");\n-    assert(((array_length - step._index) % _partial_array_stepper.chunk_size()) == 0,\n-           \"invariant\");\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(from_obj, to_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_on_queue(ScannerTask(state));\n-    }\n-  } else {\n-    assert(step._index == array_length, \"invariant\");\n-  }\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(_task_queue, nullptr, to_array, array_length);\n@@ -299,1 +264,1 @@\n-  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(step._index));\n+  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(initial_chunk_size));\n@@ -303,1 +268,1 @@\n-void G1ParScanThreadState::dispatch_task(ScannerTask task) {\n+void G1ParScanThreadState::dispatch_task(ScannerTask task, bool stolen) {\n@@ -310,1 +275,1 @@\n-    do_partial_array(task.to_partial_array_state());\n+    do_partial_array(task.to_partial_array_state(), stolen);\n@@ -323,1 +288,1 @@\n-        dispatch_task(task);\n+        dispatch_task(task, false);\n@@ -327,1 +292,1 @@\n-      dispatch_task(task);\n+      dispatch_task(task, false);\n@@ -336,1 +301,1 @@\n-    dispatch_task(stolen_task);\n+    dispatch_task(stolen_task, true);\n@@ -721,0 +686,8 @@\n+#if TASKQUEUE_STATS\n+\n+PartialArrayTaskStats* G1ParScanThreadState::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -748,0 +721,12 @@\n+\n+#if TASKQUEUE_STATS\n+\n+void G1ParScanThreadStateSet::print_partial_array_task_stats() {\n+  auto get_stats = [&](uint i) {\n+    return state_for_worker(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(_num_workers, get_stats,\n+                                 \"Partial Array Task Stats\");\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":45,"deletions":60,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -87,2 +87,1 @@\n-  PartialArrayStateAllocator _partial_array_state_allocator;\n-  PartialArrayTaskStepper _partial_array_stepper;\n+  PartialArraySplitter _partial_array_splitter;\n@@ -166,0 +165,4 @@\n+#if TASKQUEUE_STATS\n+  PartialArrayTaskStats* partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n@@ -167,1 +170,1 @@\n-  void do_partial_array(PartialArrayState* state);\n+  void do_partial_array(PartialArrayState* state, bool stolen);\n@@ -190,1 +193,1 @@\n-  void dispatch_task(ScannerTask task);\n+  void dispatch_task(ScannerTask task, bool stolen);\n@@ -262,0 +265,3 @@\n+#if TASKQUEUE_STATS\n+  void print_partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1016,0 +1016,6 @@\n+#if TASKQUEUE_STATS\n+  \/\/ Logging uses thread states, which are deleted by cleanup, so this must\n+  \/\/ be done before cleanup.\n+  per_thread_states->print_partial_array_task_stats();\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/partialArraySplitter.inline.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -125,1 +125,1 @@\n-  TASKQUEUE_STATS_ONLY(print_taskqueue_stats());\n+  TASKQUEUE_STATS_ONLY(print_and_reset_taskqueue_stats());\n@@ -149,22 +149,0 @@\n-void\n-PSPromotionManager::print_local_stats(outputStream* const out, uint i) const {\n-  #define FMT \" \" SIZE_FORMAT_W(10)\n-  out->print_cr(\"%3u\" FMT FMT FMT FMT,\n-                i, _array_chunk_pushes, _array_chunk_steals,\n-                _arrays_chunked, _array_chunks_processed);\n-  #undef FMT\n-}\n-\n-static const char* const pm_stats_hdr[] = {\n-  \"    ----partial array----     arrays      array\",\n-  \"thr       push      steal    chunked     chunks\",\n-  \"--- ---------- ---------- ---------- ----------\"\n-};\n-\n-void PSPromotionManager::print_taskqueue_stats() {\n-  if (!log_is_enabled(Trace, gc, task, stats)) {\n-    return;\n-  }\n-  Log(gc, task, stats) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n@@ -172,1 +150,2 @@\n-  stack_array_depth()->print_taskqueue_stats(&ls, \"Oop Queue\");\n+void PSPromotionManager::print_and_reset_taskqueue_stats() {\n+  stack_array_depth()->print_and_reset_taskqueue_stats(\"Oop Queue\");\n@@ -174,2 +153,5 @@\n-  const uint hlines = sizeof(pm_stats_hdr) \/ sizeof(pm_stats_hdr[0]);\n-  for (uint i = 0; i < hlines; ++i) ls.print_cr(\"%s\", pm_stats_hdr[i]);\n+  auto get_pa_stats = [&](uint i) {\n+    return manager_array(i)->partial_array_task_stats();\n+  };\n+  PartialArrayTaskStats::log_set(ParallelGCThreads, get_pa_stats,\n+                                 \"Partial Array Task Stats\");\n@@ -177,1 +159,1 @@\n-    manager_array(i)->print_local_stats(&ls, i);\n+    get_pa_stats(i)->reset();\n@@ -181,4 +163,2 @@\n-void PSPromotionManager::reset_stats() {\n-  claimed_stack_depth()->stats.reset();\n-  _array_chunk_pushes = _array_chunk_steals = 0;\n-  _arrays_chunked = _array_chunks_processed = 0;\n+PartialArrayTaskStats* PSPromotionManager::partial_array_task_stats() {\n+  return _partial_array_splitter.stats();\n@@ -186,0 +166,1 @@\n+\n@@ -190,2 +171,1 @@\n-  : _partial_array_state_allocator(_partial_array_state_manager),\n-    _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+  : _partial_array_splitter(_partial_array_state_manager, ParallelGCThreads)\n@@ -225,2 +205,0 @@\n-\n-  TASKQUEUE_STATS_ONLY(reset_stats());\n@@ -250,1 +228,1 @@\n-        process_popped_location_depth(task);\n+        process_popped_location_depth(task, false);\n@@ -255,1 +233,1 @@\n-      process_popped_location_depth(task);\n+      process_popped_location_depth(task, false);\n@@ -283,3 +261,2 @@\n-template <class T> void PSPromotionManager::process_array_chunk_work(\n-                                                 oop obj,\n-                                                 int start, int end) {\n+template <class T>\n+void PSPromotionManager::process_array_chunk_work(oop obj, int start, int end) {\n@@ -296,16 +273,7 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n-  TASKQUEUE_STATS_ONLY(++_array_chunks_processed);\n-\n-  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n-  \/\/ chunk to allow other workers to steal while we're processing.\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n-  if (step._ncreate > 0) {\n-    state->add_references(step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n-  int start = checked_cast<int>(step._index);\n-  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n-  assert(start < end, \"invariant\");\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state, bool stolen) {\n+  \/\/ Access before release by claim().\n+  oop new_obj = state->destination();\n+  PartialArraySplitter::Claim claim =\n+    _partial_array_splitter.claim(state, &_claimed_stack_depth, stolen);\n+  int start = checked_cast<int>(claim._start);\n+  int end = checked_cast<int>(claim._end);\n@@ -313,1 +281,1 @@\n-    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, start, end);\n@@ -315,1 +283,1 @@\n-    process_array_chunk_work<oop>(state->destination(), start, end);\n+    process_array_chunk_work<oop>(new_obj, start, end);\n@@ -317,2 +285,0 @@\n-  \/\/ Release reference to state, now that we're done with it.\n-  _partial_array_state_allocator.release(state);\n@@ -326,15 +292,6 @@\n-  size_t array_length = objArrayOop(new_obj)->length();\n-  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n-\n-  if (step._ncreate > 0) {\n-    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n-    PartialArrayState* state =\n-      _partial_array_state_allocator.allocate(old_obj, new_obj,\n-                                              step._index,\n-                                              array_length,\n-                                              step._ncreate);\n-    for (uint i = 0; i < step._ncreate; ++i) {\n-      push_depth(ScannerTask(state));\n-    }\n-    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n-  }\n+  objArrayOop to_array = objArrayOop(new_obj);\n+  size_t array_length = to_array->length();\n+  size_t initial_chunk_size =\n+    \/\/ The source array is unused when processing states.\n+    _partial_array_splitter.start(&_claimed_stack_depth, nullptr, to_array, array_length);\n+  int end = checked_cast<int>(initial_chunk_size);\n@@ -342,1 +299,1 @@\n-    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<narrowOop>(to_array, 0, end);\n@@ -344,1 +301,1 @@\n-    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n+    process_array_chunk_work<oop>(to_array, 0, end);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":35,"deletions":78,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n@@ -32,1 +33,1 @@\n-#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n@@ -70,9 +71,2 @@\n-  size_t                              _array_chunk_pushes;\n-  size_t                              _array_chunk_steals;\n-  size_t                              _arrays_chunked;\n-  size_t                              _array_chunks_processed;\n-\n-  void print_local_stats(outputStream* const out, uint i) const;\n-  static void print_taskqueue_stats();\n-\n-  void reset_stats();\n+  static void print_and_reset_taskqueue_stats();\n+  PartialArrayTaskStats* partial_array_task_stats();\n@@ -91,2 +85,1 @@\n-  PartialArrayStateAllocator          _partial_array_state_allocator;\n-  PartialArrayTaskStepper             _partial_array_stepper;\n+  PartialArraySplitter                _partial_array_splitter;\n@@ -108,1 +101,1 @@\n-  void process_array_chunk(PartialArrayState* state);\n+  void process_array_chunk(PartialArrayState* state, bool stolen);\n@@ -167,1 +160,1 @@\n-  inline void process_popped_location_depth(ScannerTask task);\n+  inline void process_popped_location_depth(ScannerTask task, bool stolen);\n@@ -177,2 +170,0 @@\n-  TASKQUEUE_STATS_ONLY(inline void record_steal(ScannerTask task);)\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -334,1 +334,2 @@\n-inline void PSPromotionManager::process_popped_location_depth(ScannerTask task) {\n+inline void PSPromotionManager::process_popped_location_depth(ScannerTask task,\n+                                                              bool stolen) {\n@@ -337,1 +338,1 @@\n-    process_array_chunk(task.to_partial_array_state());\n+    process_array_chunk(task.to_partial_array_state(), stolen);\n@@ -352,8 +353,0 @@\n-#if TASKQUEUE_STATS\n-void PSPromotionManager::record_steal(ScannerTask task) {\n-  if (task.is_partial_array_state()) {\n-    ++_array_chunk_steals;\n-  }\n-}\n-#endif \/\/ TASKQUEUE_STATS\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -131,2 +131,1 @@\n-      TASKQUEUE_STATS_ONLY(pm->record_steal(task));\n-      pm->process_popped_location_depth(task);\n+      pm->process_popped_location_depth(task, true);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -387,1 +387,1 @@\n-      increment_total_full_collections();\n+      _total_full_collections++;\n@@ -391,2 +391,0 @@\n-  void increment_total_full_collections() { _total_full_collections++; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+PartialArraySplitter::PartialArraySplitter(PartialArrayStateManager* manager,\n+                                           uint num_workers)\n+  : _allocator(manager),\n+    _stepper(num_workers, ParGCArrayScanChunk)\n+    TASKQUEUE_STATS_ONLY(COMMA _stats())\n+{}\n+\n+#if TASKQUEUE_STATS\n+PartialArrayTaskStats* PartialArraySplitter::stats() {\n+  return &_stats;\n+}\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n+\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class outputStream;\n+\n+\/\/ Helper class for splitting the processing of a large objArray into multiple\n+\/\/ tasks, to permit multiple threads to work on different pieces of the array\n+\/\/ in parallel.\n+class PartialArraySplitter {\n+  PartialArrayStateAllocator _allocator;\n+  PartialArrayTaskStepper _stepper;\n+  TASKQUEUE_STATS_ONLY(PartialArrayTaskStats _stats;)\n+\n+public:\n+  PartialArraySplitter(PartialArrayStateManager* manager, uint num_workers);\n+  ~PartialArraySplitter() = default;\n+\n+  NONCOPYABLE(PartialArraySplitter);\n+\n+  \/\/ Setup to process an objArray in chunks.\n+  \/\/\n+  \/\/ from_array is the array found by the collector that needs processing.  It\n+  \/\/ may be null if to_array contains everything needed for processing.\n+  \/\/\n+  \/\/ to_array is an unprocessed (possibly partial) copy of from_array, or null\n+  \/\/ if a copy of from_array is not required.\n+  \/\/\n+  \/\/ length is their length in elements.\n+  \/\/\n+  \/\/ If t is a ScannerTask, queue->push(t) must be a valid expression.  The\n+  \/\/ result of that expression is ignored.\n+  \/\/\n+  \/\/ Returns the size of the initial chunk that is to be processed by the\n+  \/\/ caller.\n+  \/\/\n+  \/\/ Adds PartialArrayState ScannerTasks to the queue if needed to process the\n+  \/\/ array in chunks. This permits other workers to steal and process them\n+  \/\/ even while the caller is processing the initial chunk.  If length doesn't\n+  \/\/ exceed the chunk size then the result will be length, indicating the\n+  \/\/ caller is to process the entire array.  In this case, no tasks will have\n+  \/\/ been added to the queue.\n+  template<typename Queue>\n+  size_t start(Queue* queue,\n+               objArrayOop from_array,\n+               objArrayOop to_array,\n+               size_t length);\n+\n+  \/\/ Result type for claim(), carrying multiple values.  Provides the claimed\n+  \/\/ chunk's start and end array indices.\n+  struct Claim {\n+    size_t _start;\n+    size_t _end;\n+  };\n+\n+  \/\/ Claims a chunk from state, returning the index range for that chunk.  The\n+  \/\/ caller is expected to process that chunk.  Adds more state-based tasks to\n+  \/\/ the queue if needed, permitting other workers to steal and process them\n+  \/\/ even while the caller is processing this claim.\n+  \/\/\n+  \/\/ Releases the state. Callers must not use state after the call to this\n+  \/\/ function. The state may have been recycled and reused.\n+  \/\/\n+  \/\/ The queue has the same requirements as for start().\n+  \/\/\n+  \/\/ stolen indicates whether the state task was obtained from this queue or\n+  \/\/ stolen from some other queue.\n+  template<typename Queue>\n+  Claim claim(PartialArrayState* state, Queue* queue, bool stolen);\n+\n+  TASKQUEUE_STATS_ONLY(PartialArrayTaskStats* stats();)\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSPLITTER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.hpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n+\n+#include \"gc\/shared\/partialArraySplitter.hpp\"\n+\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n+#include \"gc\/shared\/taskqueue.inline.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+template<typename Queue>\n+size_t PartialArraySplitter::start(Queue* queue,\n+                                   objArrayOop source,\n+                                   objArrayOop destination,\n+                                   size_t length) {\n+  PartialArrayTaskStepper::Step step = _stepper.start(length);\n+  \/\/ Push initial partial scan tasks.\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(_stats.inc_split(););\n+    TASKQUEUE_STATS_ONLY(_stats.inc_pushed(step._ncreate);)\n+    PartialArrayState* state =\n+      _allocator.allocate(source, destination, step._index, length, step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      queue->push(ScannerTask(state));\n+    }\n+  } else {\n+    assert(step._index == length, \"invariant\");\n+  }\n+  return step._index;\n+}\n+\n+template<typename Queue>\n+PartialArraySplitter::Claim\n+PartialArraySplitter::claim(PartialArrayState* state, Queue* queue, bool stolen) {\n+#if TASKQUEUE_STATS\n+  if (stolen) _stats.inc_stolen();\n+  _stats.inc_processed();\n+#endif \/\/ TASKQUEUE_STATS\n+\n+  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n+  PartialArrayTaskStepper::Step step = _stepper.next(state);\n+  \/\/ Push additional tasks.\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(_stats.inc_pushed(step._ncreate);)\n+    \/\/ Adjust reference count for tasks being added to the queue.\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      queue->push(ScannerTask(state));\n+    }\n+  }\n+  \/\/ Release state, decrementing refcount, now that we're done with it.\n+  _allocator.release(state);\n+  return Claim{step._index, step._index + _stepper.chunk_size()};\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSPLITTER_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArraySplitter.inline.hpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStats.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#if TASKQUEUE_STATS\n+\n+PartialArrayTaskStats::PartialArrayTaskStats()\n+  : _split(0), _pushed(0), _stolen(0), _processed(0)\n+{}\n+\n+void PartialArrayTaskStats::accumulate(const PartialArrayTaskStats& stats) {\n+  _split += stats._split;\n+  _pushed += stats._pushed;\n+  _stolen += stats._stolen;\n+  _processed += stats._processed;\n+}\n+\n+void PartialArrayTaskStats::reset() {\n+  *this = PartialArrayTaskStats();\n+}\n+\n+LogTargetHandle PartialArrayTaskStats::log_target() {\n+  LogTarget(Trace, gc, task, stats) lt;\n+  return LogTargetHandle(lt);\n+}\n+\n+bool PartialArrayTaskStats::is_log_enabled() {\n+  return log_target().is_enabled();\n+}\n+\n+static const char* const stats_hdr[] = {\n+  \"     ----partial array----      arrays      array\",\n+  \"thread       push      steal    chunked     chunks\",\n+  \"------ ---------- ---------- ---------- ----------\"\n+};\n+\n+void PartialArrayTaskStats::print_header(outputStream* s, const char* title) {\n+  s->print_cr(\"%s:\", title);\n+  for (uint i = 0; i < ARRAY_SIZE(stats_hdr); ++i) {\n+    s->print_cr(\"%s\", stats_hdr[i]);\n+  }\n+}\n+\n+void PartialArrayTaskStats::print_values_impl(outputStream* s) const {\n+  \/\/ 10 digits for each counter, matching the segments in stats_hdr.\n+  s->print_cr(\" %10zu %10zu %10zu %10zu\",\n+              _pushed, _stolen, _split, _processed);\n+}\n+\n+void PartialArrayTaskStats::print_values(outputStream* s, uint id) const {\n+  \/\/ 6 digits for thread number, matching the segement in stats_hdr.\n+  s->print(\"%6u\", id);\n+  print_values_impl(s);\n+}\n+\n+void PartialArrayTaskStats::print_total(outputStream* s) const {\n+  \/\/ 6 characters for \"total\" id, matching the segment in stats_hdr.\n+  s->print(\"%6s\", \"total\");\n+  print_values_impl(s);\n+}\n+\n+#endif \/\/ TASKQUEUE_STATS\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStats.cpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n+\n+#include \"logging\/logHandle.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#if TASKQUEUE_STATS\n+\n+class outputStream;\n+\n+\/\/ Repository for collecting and reporting statistics about partial array task\n+\/\/ processing.  Not thread-safe; each processing thread should have its own\n+\/\/ stats object.\n+class PartialArrayTaskStats {\n+  size_t _split;\n+  size_t _pushed;\n+  size_t _stolen;\n+  size_t _processed;\n+\n+  static LogTargetHandle log_target();\n+  static bool is_log_enabled();\n+  static void print_header(outputStream* s, const char* title);\n+  void print_values(outputStream* s, uint id) const;\n+  void print_total(outputStream* s) const;\n+  void print_values_impl(outputStream* s) const;\n+\n+  void accumulate(const PartialArrayTaskStats& stats);\n+\n+public:\n+  \/\/ All counters are initially zero.\n+  PartialArrayTaskStats();\n+\n+  \/\/ Trivially copied and destroyed.\n+\n+  \/\/ Number of arrays split into partial array tasks.\n+  size_t split() const { return _split; }\n+\n+  \/\/ Number of partial array tasks pushed onto a queue.\n+  size_t pushed() const { return _pushed; }\n+\n+  \/\/ Number of partial array tasks stolen from some other queue.\n+  size_t stolen() const { return _stolen; }\n+\n+  \/\/ Number of partial array tasks processed.\n+  size_t processed() const { return _processed; }\n+\n+  void inc_split() { _split += 1; }\n+  void inc_pushed(size_t n) { _pushed += n; }\n+  void inc_stolen() { _stolen += 1; }\n+  void inc_processed() { _processed += 1; }\n+\n+  \/\/ Set all counters to zero.\n+  void reset();\n+\n+  \/\/ Log a table of statistics, if logging is enabled (gc+task+stats=trace).\n+  \/\/\n+  \/\/ num_stats: The number of stats objects to include in the table, one row\n+  \/\/ for each.\n+  \/\/\n+  \/\/ access: A function taking a uint value < num_stats, and returning a\n+  \/\/ pointer to the corresponding stats object.\n+  \/\/\n+  \/\/ title: A string title for the table.\n+  template<typename StatsAccess>\n+  static void log_set(uint num_stats, StatsAccess access, const char* title) {\n+    if (is_log_enabled()) {\n+      LogStream ls(log_target());\n+      PartialArrayTaskStats total;\n+      print_header(&ls, title);\n+      for (uint i = 0; i < num_stats; ++i) {\n+        const PartialArrayTaskStats* stats = access(i);\n+        stats->print_values(&ls, i);\n+        total.accumulate(*stats);\n+      }\n+      total.print_total(&ls);\n+    }\n+  }\n+};\n+\n+#endif \/\/ TASKQUEUE_STATS\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYTASKSTATS_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStats.hpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -37,14 +37,0 @@\n-\/\/ Simple TaskQueue stats that are collected by default in debug builds.\n-\n-#if !defined(TASKQUEUE_STATS) && defined(ASSERT)\n-#define TASKQUEUE_STATS 1\n-#elif !defined(TASKQUEUE_STATS)\n-#define TASKQUEUE_STATS 0\n-#endif\n-\n-#if TASKQUEUE_STATS\n-#define TASKQUEUE_STATS_ONLY(code) code\n-#else\n-#define TASKQUEUE_STATS_ONLY(code)\n-#endif \/\/ TASKQUEUE_STATS\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -208,15 +208,18 @@\n-  size_t v_used = used();\n-  size_t v_used_regions = used_regions_size();\n-  size_t v_soft_max_capacity = soft_max_capacity();\n-  size_t v_max_capacity = max_capacity();\n-  size_t v_available = available();\n-  size_t v_humongous_waste = get_humongous_waste();\n-  LogGcInfo::print(\"%s: %s generation used: \" SIZE_FORMAT \"%s, used regions: \" SIZE_FORMAT \"%s, \"\n-                   \"humongous waste: \" SIZE_FORMAT \"%s, soft capacity: \" SIZE_FORMAT \"%s, max capacity: \" SIZE_FORMAT \"%s, \"\n-                   \"available: \" SIZE_FORMAT \"%s\", msg, name(),\n-                   byte_size_in_proper_unit(v_used),              proper_unit_for_byte_size(v_used),\n-                   byte_size_in_proper_unit(v_used_regions),      proper_unit_for_byte_size(v_used_regions),\n-                   byte_size_in_proper_unit(v_humongous_waste),   proper_unit_for_byte_size(v_humongous_waste),\n-                   byte_size_in_proper_unit(v_soft_max_capacity), proper_unit_for_byte_size(v_soft_max_capacity),\n-                   byte_size_in_proper_unit(v_max_capacity),      proper_unit_for_byte_size(v_max_capacity),\n-                   byte_size_in_proper_unit(v_available),         proper_unit_for_byte_size(v_available));\n+  const size_t v_used = used();\n+  const size_t v_used_regions = used_regions_size();\n+  const size_t v_soft_max_capacity = soft_max_capacity();\n+  const size_t v_max_capacity = max_capacity();\n+  const size_t v_available = available();\n+  const size_t v_humongous_waste = get_humongous_waste();\n+\n+  const LogGcInfo target;\n+  LogStream ls(target);\n+  ls.print(\"%s: \", msg);\n+  if (_type != NON_GEN) {\n+    ls.print(\"%s generation \", name());\n+  }\n+\n+  ls.print_cr(\"used: \" PROPERFMT \", used regions: \" PROPERFMT \", humongous waste: \" PROPERFMT\n+              \", soft capacity: \" PROPERFMT \", max capacity: \" PROPERFMT \", available: \" PROPERFMT,\n+              PROPERFMTARGS(v_used), PROPERFMTARGS(v_used_regions), PROPERFMTARGS(v_humongous_waste),\n+              PROPERFMTARGS(v_soft_max_capacity), PROPERFMTARGS(v_max_capacity), PROPERFMTARGS(v_available));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-size_t ShenandoahGenerationalMemoryPool::max_size() const {\n-  return _generation->max_capacity();\n-}\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-  size_t max_size() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMemoryPool.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -67,1 +67,2 @@\n-          log_debug(gc)(\"Heuristics request for global (unload classes) accepted.\");\n+          \/\/ Some of vmTestbase\/metaspace tests depend on following line to count GC cycles\n+          _global_heuristics->log_trigger(\"%s\", GCCause::to_string(GCCause::_metadata_GC_threshold));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +77,0 @@\n-  ShenandoahThreadLocalData::create(worker);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -586,1 +586,1 @@\n-    jint new_flags = flags.as_int();\n+    u2 new_flags = flags.as_method_flags();\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-        *modifiers = jfs.access_flags().as_short();\n+        *modifiers = jfs.access_flags().as_field_flags();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-       try (var rf = new RecordingFile(Path.of(\"dump.jfr)) {\n+       try (var rf = new RecordingFile(Path.of(\"dump.jfr\"))) {\n@@ -52,1 +52,1 @@\n-               System.out.println(e.getName() + \" \" + e.getDuration()));\n+               System.out.println(e.getName() + \" \" + e.getDuration());\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-static s4 get_flags(const T* ptr) {\n+static u2 get_flags(const T* ptr) {\n@@ -232,1 +232,1 @@\n-  return ptr->access_flags().get_flags();\n+  return ptr->access_flags().as_unsigned_short();\n@@ -971,1 +971,1 @@\n-  writer->write(static_cast<u2>(get_flags(method)));\n+  writer->write(get_flags(method));\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1003,1 +1003,1 @@\n-  JVMCIENV->put_int_at(info, 0, fd.access_flags().as_int());\n+  JVMCIENV->put_int_at(info, 0, fd.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1595,1 +1595,1 @@\n-    HotSpotJVMCI::FieldInfo::set_classfileFlags(JVMCIENV, obj_h(), (jint)fieldinfo->access_flags().as_int());\n+    HotSpotJVMCI::FieldInfo::set_classfileFlags(JVMCIENV, obj_h(), (jint)fieldinfo->access_flags().as_field_flags());\n@@ -1606,1 +1606,1 @@\n-                                      (jint)fieldinfo->access_flags().as_int(),\n+                                      (jint)fieldinfo->access_flags().as_field_flags(),\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,1 +276,1 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               jint)                                  \\\n+  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n@@ -491,1 +491,0 @@\n-  declare_constant(JVM_ACC_WRITTEN_FLAGS)                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,3 @@\n-    token = comma_pos + 1;\n+    if (comma_pos != nullptr) {\n+      token = comma_pos + 1;\n+    }\n","filename":"src\/hotspot\/share\/logging\/logDecorators.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,3 @@\n-    cur_tag = plus_pos + 1;\n+    if (plus_pos != nullptr) {\n+      cur_tag = plus_pos + 1;\n+    }\n","filename":"src\/hotspot\/share\/logging\/logSelection.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-  for (char *comma_pos = copy, *cur = copy; success && comma_pos != nullptr; cur = comma_pos + 1) {\n+  for (char *comma_pos = copy, *cur = copy; success; cur = comma_pos + 1) {\n@@ -93,0 +93,4 @@\n+\n+    if (comma_pos == nullptr) {\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/logging\/logSelectionList.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/os.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  const address encoding_end = _base + nth_bit(narrow_klass_pointer_bits() + _shift);\n+  const address encoding_end = (address)(p2u(_base) + (uintptr_t)nth_bit(narrow_klass_pointer_bits() + _shift));\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-                access_flags().as_int(),\n+                access_flags().as_field_flags(),\n@@ -100,1 +100,1 @@\n-    assert(fi_ref->access_flags().as_int() == fi.access_flags().as_int(), \"Must be\");\n+    assert(fi_ref->access_flags().as_field_flags() == fi.access_flags().as_field_flags(), \"Must be\");\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-  _consumer->accept_uint(fi.access_flags().as_int());\n+  _consumer->accept_uint(fi.access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-jint FlatArrayKlass::compute_modifier_flags() const {\n+u2 FlatArrayKlass::compute_modifier_flags() const {\n@@ -381,1 +381,1 @@\n-  jint element_flags = element_klass()->compute_modifier_flags();\n+  u2 element_flags = element_klass()->compute_modifier_flags();\n@@ -383,1 +383,1 @@\n-  int identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n+  u2 identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3601,2 +3601,2 @@\n-jint InstanceKlass::compute_modifier_flags() const {\n-  jint access = access_flags().as_int();\n+u2 InstanceKlass::compute_modifier_flags() const {\n+  u2 access = access_flags().as_unsigned_short();\n@@ -3621,1 +3621,1 @@\n-  return (access & JVM_ACC_WRITTEN_FLAGS);\n+  return access;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -484,2 +484,2 @@\n-  int field_offset      (int index) const { return field(index).offset(); }\n-  int field_access_flags(int index) const { return field(index).access_flags().as_int(); }\n+  int     field_offset      (int index) const { return field(index).offset(); }\n+  int     field_access_flags(int index) const { return field(index).access_flags().as_field_flags(); }\n@@ -788,2 +788,0 @@\n-  \/\/ The flag is in access_flags so that it can be set and reset using atomic\n-  \/\/ operations, and not be reset by other misc_flag settings.\n@@ -1259,1 +1257,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  enum KlassKind {\n+  enum KlassKind : u2 {\n@@ -118,1 +118,1 @@\n-  jint        _layout_helper;\n+  jint _layout_helper;\n@@ -125,0 +125,3 @@\n+  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n+                                \/\/ Some flags created by the JVM, not in the class file itself,\n+                                \/\/ are in _misc_flags below.\n@@ -126,1 +129,3 @@\n-  jint        _modifier_flags;\n+  u2          _modifier_flags;\n+\n+  KlassFlags  _misc_flags;\n@@ -162,0 +167,2 @@\n+  markWord _prototype_header;   \/\/ Used to initialize objects' header\n+\n@@ -166,12 +173,0 @@\n-  markWord _prototype_header;   \/\/ Used to initialize objects' header\n-\n-  int _vtable_len;              \/\/ vtable length. This field may be read very often when we\n-                                \/\/ have lots of itable dispatches (e.g., lambdas and streams).\n-                                \/\/ Keep it away from the beginning of a Klass to avoid cacheline\n-                                \/\/ contention that may happen when a nearby object is modified.\n-  AccessFlags _access_flags;    \/\/ Access flags. The class\/interface distinction is stored here.\n-                                \/\/ Some flags created by the JVM, not in the class file itself,\n-                                \/\/ are in _misc_flags below.\n-\n-  JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n-\n@@ -205,1 +200,4 @@\n-  KlassFlags  _misc_flags;\n+  int _vtable_len;              \/\/ vtable length. This field may be read very often when we\n+                                \/\/ have lots of itable dispatches (e.g., lambdas and streams).\n+                                \/\/ Keep it away from the beginning of a Klass to avoid cacheline\n+                                \/\/ contention that may happen when a nearby object is modified.\n@@ -209,0 +207,4 @@\n+public:\n+\n+  JFR_ONLY(DEFINE_TRACE_ID_FIELD;)\n+\n@@ -297,2 +299,2 @@\n-  jint modifier_flags() const          { return _modifier_flags; }\n-  void set_modifier_flags(jint flags)  { _modifier_flags = flags; }\n+  u2 modifier_flags() const          { return _modifier_flags; }\n+  void set_modifier_flags(u2 flags)  { _modifier_flags = flags; }\n@@ -785,1 +787,1 @@\n-  virtual jint compute_modifier_flags() const = 0;\n+  virtual u2 compute_modifier_flags() const = 0;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-  bool must_be_preserved(const oopDesc* obj) const {\n+  bool must_be_preserved() const {\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1718,1 +1718,0 @@\n-  jshort flags = access_flags().as_short();\n@@ -1720,0 +1719,1 @@\n+  u2 flags = access_flags().as_method_flags();\n@@ -2391,1 +2391,1 @@\n-  st->print   (\" - access:            0x%x  \", access_flags().as_int()); access_flags().print_on(st); st->cr();\n+  st->print   (\" - access:            0x%x  \", access_flags().as_method_flags()); access_flags().print_on(st); st->cr();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,0 @@\n-  AccessFlags       _access_flags;               \/\/ Access flags\n@@ -80,0 +79,1 @@\n+  AccessFlags       _access_flags;               \/\/ Access flags\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-jint ObjArrayKlass::compute_modifier_flags() const {\n+u2 ObjArrayKlass::compute_modifier_flags() const {\n@@ -368,1 +368,1 @@\n-  jint element_flags = bottom_klass()->compute_modifier_flags();\n+  u2 element_flags = bottom_klass()->compute_modifier_flags();\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,1 +138,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-  return m.must_be_preserved(this);\n+  return m.must_be_preserved();\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,2 +78,2 @@\n-jint TypeArrayKlass::compute_modifier_flags() const {\n-  int identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n+u2 TypeArrayKlass::compute_modifier_flags() const {\n+  u2 identity_flag = (Arguments::enable_preview()) ? JVM_ACC_IDENTITY : 0;\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  jint compute_modifier_flags() const;\n+  u2 compute_modifier_flags() const;\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,7 +236,1 @@\n-  \/\/ But here we have to pay extra attention:\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (!_range_check_dependency) {\n-    res = widen_type(phase, res, T_INT);\n-  }\n+  res = widen_type(phase, res, T_INT);\n@@ -247,2 +241,4 @@\n-static Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInteger* type, ConstraintCastNode::DependencyType dependency, BasicType bt) {\n-  Node* n = ConstraintCastNode::make_cast_for_basic_type(control, parent, type, dependency, bt);\n+Node* ConstraintCastNode::find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const {\n+  Node* n = clone();\n+  n->set_req(1, parent);\n+  n->as_ConstraintCast()->set_type(type);\n@@ -262,1 +258,1 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n@@ -266,1 +262,1 @@\n-  if (!_range_check_dependency) {\n+  if (!_range_check_dependency || phase->C->post_loop_opts_phase()) {\n@@ -269,0 +265,1 @@\n+  phase->C->record_for_post_loop_opts_igvn(this);\n@@ -277,7 +274,0 @@\n-  if (_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      return this->in(1);\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n@@ -312,0 +302,28 @@\n+void CastIINode::remove_range_check_cast(Compile* C) {\n+  if (has_range_check()) {\n+    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n+    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n+    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n+    \/\/ range check or a null divisor check.\n+    assert(in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n+    ResourceMark rm;\n+    Unique_Node_List wq;\n+    wq.push(this);\n+    for (uint next = 0; next < wq.size(); ++next) {\n+      Node* m = wq.at(next);\n+      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+        Node* use = m->fast_out(i);\n+        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n+          use->ensure_control_or_add_prec(in(0));\n+        } else if (!use->is_CFG() && !use->is_Phi()) {\n+          wq.push(use);\n+        }\n+      }\n+    }\n+    subsume_by(in(1), C);\n+    if (outcnt() == 0) {\n+      disconnect_inputs(C);\n+    }\n+  }\n+}\n+\n@@ -548,2 +566,2 @@\n-    Node* cx = find_or_make_integer_cast(igvn, x, in(0), rx, _dependency, bt);\n-    Node* cy = find_or_make_integer_cast(igvn, y, in(0), ry, _dependency, bt);\n+    Node* cx = find_or_make_integer_cast(igvn, x, rx);\n+    Node* cy = find_or_make_integer_cast(igvn, y, ry);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, const TypeInteger* type) const;\n@@ -124,0 +125,1 @@\n+  void remove_range_check_cast(Compile* C);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3631,0 +3631,7 @@\n+    \/\/ If the divisor input for a Div (or Mod etc.) is not zero, then the control input of the Div is set to zero.\n+    \/\/ It could be that the divisor input is found not zero because its type is narrowed down by a CastII in the\n+    \/\/ subgraph for that input. Range check CastIIs are removed during final graph reshape. To preserve the dependency\n+    \/\/ carried by a CastII, precedence edges are added to the Div node. We need to transfer the precedence edges to the\n+    \/\/ DivMod node so the dependency is not lost.\n+    divmod->add_prec_from(n);\n+    divmod->add_prec_from(d);\n@@ -3917,0 +3924,4 @@\n+  case Op_CastII: {\n+    n->as_CastII()->remove_range_check_cast(this);\n+    break;\n+  }\n@@ -4068,10 +4079,0 @@\n-#ifdef ASSERT\n-  case Op_CastII:\n-    \/\/ Verify that all range check dependent CastII nodes were removed.\n-    if (n->isa_CastII()->has_range_check()) {\n-      n->dump(3);\n-      assert(false, \"Range check dependent CastII node was not removed\");\n-    }\n-    break;\n-#endif\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -4069,1 +4069,1 @@\n-                                    Klass::access_flags_offset(), TypeInt::INT, T_INT);\n+                                    Klass::access_flags_offset(), TypeInt::CHAR, T_CHAR);\n@@ -4102,2 +4102,1 @@\n-    assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), \"change next line\");\n-    return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);\n+    return_type = TypeInt::CHAR;\n@@ -4125,1 +4124,1 @@\n-    return_type = TypeInt::INT;  \/\/ not bool!  6297094\n+    return_type = TypeInt::CHAR;\n@@ -4186,1 +4185,1 @@\n-    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n@@ -4251,1 +4250,1 @@\n-    query_value = make_load(nullptr, p, TypeInt::INT, T_INT, MemNode::unordered);\n+    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2007,1 +2007,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _modifier_flags\");\n+    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _modifier_flags\");\n@@ -2013,1 +2013,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _access_flags\");\n+    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _access_flags\");\n@@ -2019,1 +2019,1 @@\n-    assert(this->Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n+    assert(Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n@@ -2024,1 +2024,1 @@\n-    assert(this->Opcode() == Op_LoadI, \"must load an int from _layout_helper\");\n+    assert(Opcode() == Op_LoadI, \"must load an int from _layout_helper\");\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2904,0 +2904,9 @@\n+void Node::add_prec_from(Node* n) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    Node* prec = n->in(i);\n+    if (prec != nullptr) {\n+      add_prec(prec);\n+    }\n+  }\n+}\n+\n@@ -2927,0 +2936,3 @@\n+bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n+                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-  const node_idx_t _idx;\n+  node_idx_t _idx;\n@@ -593,2 +593,1 @@\n-    const node_idx_t* ref = &_idx;\n-    *(node_idx_t*)ref = new_idx;\n+    _idx = new_idx;\n@@ -1183,0 +1182,1 @@\n+  void add_prec_from(Node* n);\n@@ -1294,0 +1294,2 @@\n+  bool is_div_or_mod(BasicType bt) const;\n+\n@@ -2077,0 +2079,4 @@\n+Op_IL(Div)\n+Op_IL(Mod)\n+Op_IL(UDiv)\n+Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -669,1 +669,1 @@\n-\/\/ Make a vector node for binary operation\n+\/\/ Make a vector node for unary or binary operation\n@@ -750,0 +750,3 @@\n+  case Op_LShiftCntV: return new LShiftCntVNode(n1, vt);\n+  case Op_RShiftCntV: return new RShiftCntVNode(n1, vt);\n+\n@@ -769,0 +772,12 @@\n+  case Op_VectorCastB2X:  return new VectorCastB2XNode(n1, vt);\n+  case Op_VectorCastS2X:  return new VectorCastS2XNode(n1, vt);\n+  case Op_VectorCastI2X:  return new VectorCastI2XNode(n1, vt);\n+  case Op_VectorCastL2X:  return new VectorCastL2XNode(n1, vt);\n+  case Op_VectorCastF2X:  return new VectorCastF2XNode(n1, vt);\n+  case Op_VectorCastD2X:  return new VectorCastD2XNode(n1, vt);\n+  case Op_VectorUCastB2X: return new VectorUCastB2XNode(n1, vt);\n+  case Op_VectorUCastS2X: return new VectorUCastS2XNode(n1, vt);\n+  case Op_VectorUCastI2X: return new VectorUCastI2XNode(n1, vt);\n+  case Op_VectorCastHF2F: return new VectorCastHF2FNode(n1, vt);\n+  case Op_VectorCastF2HF: return new VectorCastF2HFNode(n1, vt);\n+\n@@ -794,0 +809,1 @@\n+  case Op_VectorBlend: return new VectorBlendNode(n1, n2, n3);\n@@ -821,1 +837,1 @@\n-  \/\/ Match shift count type with shift vector type.\n+  int vopc = VectorNode::shift_count_opcode(opc);\n@@ -823,0 +839,4 @@\n+  return VectorNode::make(vopc, cnt, nullptr, vt);\n+}\n+\n+int VectorNode::shift_count_opcode(int opc) {\n@@ -826,1 +846,1 @@\n-    return new LShiftCntVNode(cnt, vt);\n+    return Op_LShiftCntV;\n@@ -833,1 +853,1 @@\n-    return new RShiftCntVNode(cnt, vt);\n+    return Op_RShiftCntV;\n@@ -835,2 +855,2 @@\n-    fatal(\"Missed vector creation for '%s'\", NodeClassNames[opc]);\n-    return nullptr;\n+    fatal(\"Node class '%s' is not supported for shift count\", NodeClassNames[opc]);\n+    return -1;\n@@ -1415,1 +1435,1 @@\n-VectorCastNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {\n+VectorNode* VectorCastNode::make(int vopc, Node* n1, BasicType bt, uint vlen) {\n@@ -1417,16 +1437,1 @@\n-  switch (vopc) {\n-    case Op_VectorCastB2X:  return new VectorCastB2XNode(n1, vt);\n-    case Op_VectorCastS2X:  return new VectorCastS2XNode(n1, vt);\n-    case Op_VectorCastI2X:  return new VectorCastI2XNode(n1, vt);\n-    case Op_VectorCastL2X:  return new VectorCastL2XNode(n1, vt);\n-    case Op_VectorCastF2X:  return new VectorCastF2XNode(n1, vt);\n-    case Op_VectorCastD2X:  return new VectorCastD2XNode(n1, vt);\n-    case Op_VectorUCastB2X: return new VectorUCastB2XNode(n1, vt);\n-    case Op_VectorUCastS2X: return new VectorUCastS2XNode(n1, vt);\n-    case Op_VectorUCastI2X: return new VectorUCastI2XNode(n1, vt);\n-    case Op_VectorCastHF2F: return new VectorCastHF2FNode(n1, vt);\n-    case Op_VectorCastF2HF: return new VectorCastF2HFNode(n1, vt);\n-    default:\n-      assert(false, \"unknown node: %s\", NodeClassNames[vopc]);\n-      return nullptr;\n-  }\n+  return VectorNode::make(vopc, n1, nullptr, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,0 +98,2 @@\n+  static int shift_count_opcode(int opc);\n+\n@@ -1767,1 +1769,1 @@\n-  static VectorCastNode* make(int vopc, Node* n1, BasicType bt, uint vlen);\n+  static VectorNode* make(int vopc, Node* n1, BasicType bt, uint vlen);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2511,1 +2511,1 @@\n-#define DEFINE_GETSCALARARRAYELEMENTS(ElementTag,ElementType,Result, Tag \\\n+#define DEFINE_GETSCALARARRAYELEMENTS(ElementType,Result \\\n@@ -2545,1 +2545,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool\n+DEFINE_GETSCALARARRAYELEMENTS(jboolean, Boolean\n@@ -2548,1 +2548,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte\n+DEFINE_GETSCALARARRAYELEMENTS(jbyte,    Byte\n@@ -2551,1 +2551,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short\n+DEFINE_GETSCALARARRAYELEMENTS(jshort,   Short\n@@ -2554,1 +2554,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char\n+DEFINE_GETSCALARARRAYELEMENTS(jchar,    Char\n@@ -2557,1 +2557,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_INT,     jint,     Int,     int\n+DEFINE_GETSCALARARRAYELEMENTS(jint,     Int\n@@ -2560,1 +2560,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long\n+DEFINE_GETSCALARARRAYELEMENTS(jlong,    Long\n@@ -2564,1 +2564,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float\n+DEFINE_GETSCALARARRAYELEMENTS(jfloat,   Float\n@@ -2567,1 +2567,1 @@\n-DEFINE_GETSCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double\n+DEFINE_GETSCALARARRAYELEMENTS(jdouble,  Double\n@@ -2572,2 +2572,2 @@\n-#define DEFINE_RELEASESCALARARRAYELEMENTS(ElementTag,ElementType,Result,Tag \\\n-                                          , EntryProbe, ReturnProbe);\\\n+#define DEFINE_RELEASESCALARARRAYELEMENTS(ElementType,Result \\\n+                                          , EntryProbe, ReturnProbe) \\\n@@ -2592,1 +2592,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_BOOLEAN, jboolean, Boolean, bool\n+DEFINE_RELEASESCALARARRAYELEMENTS(jboolean, Boolean\n@@ -2595,1 +2595,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_BYTE,    jbyte,    Byte,    byte\n+DEFINE_RELEASESCALARARRAYELEMENTS(jbyte,    Byte\n@@ -2598,1 +2598,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_SHORT,   jshort,   Short,   short\n+DEFINE_RELEASESCALARARRAYELEMENTS(jshort,   Short\n@@ -2601,1 +2601,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_CHAR,    jchar,    Char,    char\n+DEFINE_RELEASESCALARARRAYELEMENTS(jchar,    Char\n@@ -2604,1 +2604,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_INT,     jint,     Int,     int\n+DEFINE_RELEASESCALARARRAYELEMENTS(jint,     Int\n@@ -2607,1 +2607,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_LONG,    jlong,    Long,    long\n+DEFINE_RELEASESCALARARRAYELEMENTS(jlong,    Long\n@@ -2610,1 +2610,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_FLOAT,   jfloat,   Float,   float\n+DEFINE_RELEASESCALARARRAYELEMENTS(jfloat,   Float\n@@ -2613,1 +2613,1 @@\n-DEFINE_RELEASESCALARARRAYELEMENTS(T_DOUBLE,  jdouble,  Double,  double\n+DEFINE_RELEASESCALARARRAYELEMENTS(jdouble,  Double\n@@ -2631,2 +2631,2 @@\n-#define DEFINE_GETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \\\n-                                    , EntryProbe, ReturnProbe); \\\n+#define DEFINE_GETSCALARARRAYREGION(ElementType,Result \\\n+                                    , EntryProbe, ReturnProbe) \\\n@@ -2648,1 +2648,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_BOOLEAN, jboolean,Boolean, bool\n+DEFINE_GETSCALARARRAYREGION(jboolean,Boolean\n@@ -2651,1 +2651,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_BYTE,    jbyte,   Byte,    byte\n+DEFINE_GETSCALARARRAYREGION(jbyte,   Byte\n@@ -2654,1 +2654,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_SHORT,   jshort,  Short,   short\n+DEFINE_GETSCALARARRAYREGION(jshort,  Short\n@@ -2657,1 +2657,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_CHAR,    jchar,   Char,    char\n+DEFINE_GETSCALARARRAYREGION(jchar,   Char\n@@ -2660,1 +2660,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_INT,     jint,    Int,     int\n+DEFINE_GETSCALARARRAYREGION(jint,    Int\n@@ -2663,1 +2663,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_LONG,    jlong,   Long,    long\n+DEFINE_GETSCALARARRAYREGION(jlong,   Long\n@@ -2666,1 +2666,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_FLOAT,   jfloat,  Float,   float\n+DEFINE_GETSCALARARRAYREGION(jfloat,  Float\n@@ -2669,1 +2669,1 @@\n-DEFINE_GETSCALARARRAYREGION(T_DOUBLE,  jdouble, Double,  double\n+DEFINE_GETSCALARARRAYREGION(jdouble, Double\n@@ -2674,2 +2674,2 @@\n-#define DEFINE_SETSCALARARRAYREGION(ElementTag,ElementType,Result, Tag \\\n-                                    , EntryProbe, ReturnProbe); \\\n+#define DEFINE_SETSCALARARRAYREGION(ElementType,Result \\\n+                                    , EntryProbe, ReturnProbe) \\\n@@ -2691,1 +2691,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_BOOLEAN, jboolean, Boolean, bool\n+DEFINE_SETSCALARARRAYREGION(jboolean, Boolean\n@@ -2694,1 +2694,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_BYTE,    jbyte,    Byte,    byte\n+DEFINE_SETSCALARARRAYREGION(jbyte,    Byte\n@@ -2697,1 +2697,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_SHORT,   jshort,   Short,   short\n+DEFINE_SETSCALARARRAYREGION(jshort,   Short\n@@ -2700,1 +2700,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_CHAR,    jchar,    Char,    char\n+DEFINE_SETSCALARARRAYREGION(jchar,    Char\n@@ -2703,1 +2703,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_INT,     jint,     Int,     int\n+DEFINE_SETSCALARARRAYREGION(jint,     Int\n@@ -2706,1 +2706,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_LONG,    jlong,    Long,    long\n+DEFINE_SETSCALARARRAYREGION(jlong,    Long\n@@ -2709,1 +2709,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_FLOAT,   jfloat,   Float,   float\n+DEFINE_SETSCALARARRAYREGION(jfloat,   Float\n@@ -2712,1 +2712,1 @@\n-DEFINE_SETSCALARARRAYREGION(T_DOUBLE,  jdouble,  Double,  double\n+DEFINE_SETSCALARARRAYREGION(jdouble,  Double\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1432,1 +1432,1 @@\n-  debug_only(int computed_modifiers = k->compute_modifier_flags());\n+  debug_only(u2 computed_modifiers = k->compute_modifier_flags());\n@@ -1944,1 +1944,1 @@\n-  return k->access_flags().as_int() & JVM_ACC_WRITTEN_FLAGS;\n+  return k->access_flags().as_class_flags();\n@@ -2623,1 +2623,1 @@\n-  return method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  return method->access_flags().as_method_flags();\n@@ -2820,1 +2820,1 @@\n-          return fs.access_flags().as_short();\n+          return fs.access_flags().as_field_flags();\n@@ -2849,1 +2849,1 @@\n-            return method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+            return method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1221,1 +1221,1 @@\n-                                    id=\"JVMTI_THREAD_STATE_WAITING_INDEFINITELY\"><code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY<\/code><\/datalink><\/li>\n+                                    id=\"JVMTI_THREAD_STATE_WAITING_INDEFINITELY\"><code>JVMTI_THREAD_STATE_WAITING_INDEFINITELY<\/code><\/datalink>)<\/li>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-    write_u2(access_flags.get_flags());\n+    write_u2(access_flags.as_field_flags());\n@@ -728,1 +728,1 @@\n-  write_u2(access_flags.get_flags() & JVM_RECOGNIZED_METHOD_MODIFIERS);\n+  write_u2(access_flags.as_method_flags());\n@@ -949,1 +949,2 @@\n-  write_u2(ik()->access_flags().get_flags() & (JVM_RECOGNIZED_CLASS_MODIFIERS));\n+  write_u2(ik()->access_flags().as_class_flags());\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3154,1 +3154,1 @@\n-  jint result = resultFlags.as_int();\n+  jint result = resultFlags.as_field_flags();\n@@ -3233,1 +3233,1 @@\n-  (*modifiers_ptr) = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  (*modifiers_ptr) = method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1007,2 +1007,2 @@\n-  jushort old_flags = (jushort) the_class->access_flags().get_flags();\n-  jushort new_flags = (jushort) scratch_class->access_flags().get_flags();\n+  u2 old_flags = the_class->access_flags().as_class_flags();\n+  u2 new_flags = scratch_class->access_flags().as_class_flags();\n@@ -1042,3 +1042,3 @@\n-    old_flags = old_fs.access_flags().as_short();\n-    new_flags = new_fs.access_flags().as_short();\n-    if ((old_flags ^ new_flags) & JVM_RECOGNIZED_FIELD_MODIFIERS) {\n+    old_flags = old_fs.access_flags().as_field_flags();\n+    new_flags = new_fs.access_flags().as_field_flags();\n+    if (old_flags != new_flags) {\n@@ -1149,2 +1149,2 @@\n-      old_flags = (jushort) k_old_method->access_flags().get_flags();\n-      new_flags = (jushort) k_new_method->access_flags().get_flags();\n+      old_flags = k_old_method->access_flags().as_method_flags();\n+      new_flags = k_new_method->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,1 +245,1 @@\n-  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  int flags = (m->access_flags().as_method_flags());\n@@ -358,1 +358,1 @@\n-  int flags = (jushort)( fd.access_flags().as_short());\n+  int flags = fd.access_flags().as_field_flags();\n@@ -416,1 +416,1 @@\n-    int flags = m->access_flags().as_int();\n+    int flags = m->access_flags().as_method_flags();\n@@ -429,1 +429,1 @@\n-    int flags = m->access_flags().as_int();\n+    int flags = m->access_flags().as_method_flags();\n@@ -534,1 +534,1 @@\n-      int flags = m->access_flags().as_int();\n+      int flags = m->access_flags().as_method_flags();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -928,0 +928,7 @@\n+  AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);\n+  if (comp == nullptr) {\n+    \/\/ Could have compLevel == 0, or !TieredCompilation and incompatible values of TieredStopAtLevel and compLevel.\n+    tty->print_cr(\"WB error: no compiler for requested compilation level %d\", compLevel);\n+    return false;\n+  }\n+\n@@ -934,2 +941,0 @@\n-  AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);\n-  assert(comp != nullptr, \"compiler not available\");\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  JavaThread* _target;\n+  JavaThread* _current;\n@@ -69,2 +69,2 @@\n-    _vthread(t, t->vthread()), _target(t), _result(freeze_pinned_native), _failed(false) {\n-    assert(!_target->is_in_VTMS_transition(), \"must be\");\n+    _vthread(t, t->vthread()), _current(t), _result(freeze_pinned_native), _failed(false) {\n+    assert(!_current->is_in_VTMS_transition(), \"must be\");\n@@ -78,2 +78,2 @@\n-        JvmtiThreadState* state = _target->jvmti_thread_state();\n-        if (_target->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n+        JvmtiThreadState* state = _current->jvmti_thread_state();\n+        if (_current->has_pending_popframe() || (state != nullptr && state->is_earlyret_pending())) {\n@@ -86,1 +86,1 @@\n-      if (_target->has_async_exception_condition()) {\n+      if (_current->has_async_exception_condition()) {\n@@ -90,1 +90,1 @@\n-      _target->set_is_in_VTMS_transition(true);\n+      _current->set_is_in_VTMS_transition(true);\n@@ -95,1 +95,1 @@\n-    assert(!_target->is_suspended(), \"must be\");\n+    assert(!_current->is_suspended(), \"must be\");\n@@ -97,1 +97,1 @@\n-    assert(_target->is_in_VTMS_transition(), \"must be\");\n+    assert(_current->is_in_VTMS_transition(), \"must be\");\n@@ -109,1 +109,1 @@\n-        _target->set_is_in_VTMS_transition(false);\n+        _current->set_is_in_VTMS_transition(false);\n@@ -118,3 +118,3 @@\n-static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* target) {\n-  if (target->is_in_VTMS_transition()) {\n-    \/\/ We caught target at the end of a mount transition.\n+static bool is_vthread_safe_to_preempt_for_jvmti(JavaThread* current) {\n+  if (current->is_in_VTMS_transition()) {\n+    \/\/ We are at the end of a mount transition.\n@@ -127,1 +127,1 @@\n-static bool is_vthread_safe_to_preempt(JavaThread* target, oop vthread) {\n+static bool is_vthread_safe_to_preempt(JavaThread* current, oop vthread) {\n@@ -132,1 +132,1 @@\n-  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(target)) NOT_JVMTI(true);\n+  return JVMTI_ONLY(is_vthread_safe_to_preempt_for_jvmti(current)) NOT_JVMTI(true);\n@@ -137,6 +137,6 @@\n-static void verify_preempt_preconditions(JavaThread* target, oop continuation) {\n-  assert(target == JavaThread::current(), \"no support for external preemption\");\n-  assert(target->has_last_Java_frame(), \"\");\n-  assert(!target->preempting(), \"\");\n-  assert(target->last_continuation() != nullptr, \"\");\n-  assert(target->last_continuation()->cont_oop(target) == continuation, \"\");\n+static void verify_preempt_preconditions(JavaThread* current, oop continuation) {\n+  assert(current == JavaThread::current(), \"no support for external preemption\");\n+  assert(current->has_last_Java_frame(), \"\");\n+  assert(!current->preempting(), \"\");\n+  assert(current->last_continuation() != nullptr, \"\");\n+  assert(current->last_continuation()->cont_oop(current) == continuation, \"\");\n@@ -144,1 +144,1 @@\n-  assert(!target->has_pending_exception(), \"\");\n+  assert(!current->has_pending_exception(), \"\");\n@@ -147,2 +147,2 @@\n-freeze_result Continuation::try_preempt(JavaThread* target, oop continuation) {\n-  verify_preempt_preconditions(target, continuation);\n+freeze_result Continuation::try_preempt(JavaThread* current, oop continuation) {\n+  verify_preempt_preconditions(current, continuation);\n@@ -154,1 +154,1 @@\n-  if (!is_vthread_safe_to_preempt(target, target->vthread())) {\n+  if (!is_vthread_safe_to_preempt(current, current->vthread())) {\n@@ -158,1 +158,1 @@\n-  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(target);)\n+  JVMTI_ONLY(JvmtiUnmountBeginMark jubm(current);)\n@@ -160,1 +160,1 @@\n-  freeze_result res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(target, target->last_Java_sp());\n+  freeze_result res = CAST_TO_FN_PTR(FreezeContFnT, freeze_preempt_entry())(current, current->last_Java_sp());\n@@ -163,0 +163,8 @@\n+\n+  if (current->has_pending_exception()) {\n+    assert(res == freeze_exception, \"expecting an exception result from freeze\");\n+    \/\/ We don't want to throw exceptions, especially when returning\n+    \/\/ from monitorenter since the compiler does not expect one. We\n+    \/\/ just ignore the exception and pin the vthread to the carrier.\n+    current->clear_pending_exception();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1206,4 +1206,1 @@\n-  if (CrashGCForDumpingJavaThread) {\n-    char *t = nullptr;\n-    *t = 'c';\n-  }\n+  guarantee(!CrashGCForDumpingJavaThread, \"\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -974,1 +974,1 @@\n-      st->print(\"%016\" FORMAT64_MODIFIER \"x\", value);\n+      st->print(UINT64_FORMAT_0, value);\n@@ -998,1 +998,1 @@\n-      case 8: st->print(\"%016\" FORMAT64_MODIFIER \"x\", (u8)value); break;\n+      case 8: st->print(UINT64_FORMAT_0, (u8)value); break;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -784,1 +784,1 @@\n-  const int modifiers = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  const int modifiers = method->access_flags().as_method_flags();\n@@ -826,1 +826,1 @@\n-  const int modifiers = method->access_flags().as_int() & JVM_RECOGNIZED_METHOD_MODIFIERS;\n+  const int modifiers = method->access_flags().as_method_flags();\n@@ -873,2 +873,1 @@\n-  int modifiers = fd->access_flags().as_int();\n-  java_lang_reflect_Field::set_modifiers(rh(), modifiers);\n+  java_lang_reflect_Field::set_modifiers(rh(), fd->access_flags().as_field_flags());\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1313,7 +1313,0 @@\n-  \/\/ Start with ceiling based on a per-thread estimate:\n-  size_t ceiling = ObjectSynchronizer::in_use_list_ceiling();\n-  size_t old_ceiling = ceiling;\n-  if (ceiling < list->max()) {\n-    \/\/ The max used by the system has exceeded the ceiling so use that:\n-    ceiling = list->max();\n-  }\n@@ -1324,11 +1317,6 @@\n-  if (NoAsyncDeflationProgressMax != 0 &&\n-      _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n-    double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n-    size_t new_ceiling = ceiling + (size_t)((double)ceiling * remainder) + 1;\n-    ObjectSynchronizer::set_in_use_list_ceiling(new_ceiling);\n-    log_info(monitorinflation)(\"Too many deflations without progress; \"\n-                               \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n-                               \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n-    _no_progress_cnt = 0;\n-    ceiling = new_ceiling;\n-  }\n+  size_t old_ceiling = ObjectSynchronizer::in_use_list_ceiling();\n+  \/\/ Make sure that we use a ceiling value that is not lower than\n+  \/\/ previous, not lower than the recorded max used by the system, and\n+  \/\/ not lower than the current number of monitors in use (which can\n+  \/\/ race ahead of max). The result is guaranteed > 0.\n+  size_t ceiling = MAX3(old_ceiling, list->max(), monitors_used);\n@@ -1339,0 +1327,25 @@\n+    \/\/ Deflate monitors if over the threshold percentage, unless no\n+    \/\/ progress on previous deflations.\n+    bool is_above_threshold = true;\n+\n+    \/\/ Check if it's time to adjust the in_use_list_ceiling up, due\n+    \/\/ to too many async deflation attempts without any progress.\n+    if (NoAsyncDeflationProgressMax != 0 &&\n+        _no_progress_cnt >= NoAsyncDeflationProgressMax) {\n+      double remainder = (100.0 - MonitorUsedDeflationThreshold) \/ 100.0;\n+      size_t delta = (size_t)(ceiling * remainder) + 1;\n+      size_t new_ceiling = (ceiling > SIZE_MAX - delta)\n+        ? SIZE_MAX         \/\/ Overflow, let's clamp new_ceiling.\n+        : ceiling + delta;\n+\n+      ObjectSynchronizer::set_in_use_list_ceiling(new_ceiling);\n+      log_info(monitorinflation)(\"Too many deflations without progress; \"\n+                                 \"bumping in_use_list_ceiling from \" SIZE_FORMAT\n+                                 \" to \" SIZE_FORMAT, old_ceiling, new_ceiling);\n+      _no_progress_cnt = 0;\n+      ceiling = new_ceiling;\n+\n+      \/\/ Check if our monitor usage is still above the threshold:\n+      monitor_usage = (monitors_used * 100LL) \/ ceiling;\n+      is_above_threshold = int(monitor_usage) > MonitorUsedDeflationThreshold;\n+    }\n@@ -1342,1 +1355,1 @@\n-    return true;\n+    return is_above_threshold;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,1 @@\n-  nonstatic_field(Klass,                       _modifier_flags,                               jint)                                  \\\n+  nonstatic_field(Klass,                       _modifier_flags,                               u2)                                    \\\n@@ -1022,1 +1022,1 @@\n-  nonstatic_field(AccessFlags,                 _flags,                                        jint)                                  \\\n+  nonstatic_field(AccessFlags,                 _flags,                                        u2)                                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-  assert(sizeof(AccessFlags) == sizeof(jint), \"just checking size of flags\");\n+  assert(sizeof(AccessFlags) == sizeof(u2), \"just checking size of flags\");\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-\/\/ AccessFlags is an abstraction over Java access flags.\n+\/\/ AccessFlags is an abstraction over Java ACC flags.\n+\/\/ See generated file classfile_constants.h for shared JVM_ACC_XXX access flags\n@@ -37,10 +38,0 @@\n-enum {\n-  \/\/ See jvm.h for shared JVM_ACC_XXX access flags\n-\n-  \/\/ flags actually put in .class file\n-  JVM_ACC_WRITTEN_FLAGS           = 0x00007FFF,\n-\n-  \/\/ Do not add new ACC flags here.\n-};\n-\n-\n@@ -50,1 +41,1 @@\n-  jint _flags;  \/\/ TODO: move 4 access flags above to Klass and change to u2\n+  u2 _flags;\n@@ -54,1 +45,1 @@\n-  explicit AccessFlags(jint flags) : _flags(flags) {}\n+  explicit AccessFlags(u2 flags) : _flags(flags) {}\n@@ -69,0 +60,1 @@\n+  bool has_vararg     () const         { return (_flags & JVM_ACC_VARARGS     ) != 0; }\n@@ -74,2 +66,2 @@\n-  \/\/ get .class file flags\n-  jint get_flags               () const { return (_flags & JVM_ACC_WRITTEN_FLAGS); }\n+  \/\/ get as integral value\n+  u2 as_unsigned_short() const         { return _flags; }\n@@ -77,6 +69,1 @@\n-  \/\/ Initialization\n-  void set_field_flags(jint flags)      {\n-    assert((flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == flags, \"only recognized flags\");\n-    _flags = (flags & JVM_RECOGNIZED_FIELD_MODIFIERS);\n-  }\n-  void set_flags(jint flags)            { _flags = (flags & JVM_ACC_WRITTEN_FLAGS); }\n+  void set_flags(u2 flags)            { _flags = flags; }\n@@ -94,3 +81,1 @@\n-  \/\/ Conversion\n-  jshort as_short() const              { return (jshort)_flags; }\n-  jint   as_int() const                { return _flags; }\n+  inline friend AccessFlags accessFlags_from(u2 flags);\n@@ -98,1 +83,14 @@\n-  inline friend AccessFlags accessFlags_from(jint flags);\n+  u2 as_method_flags() const {\n+    assert((_flags & JVM_RECOGNIZED_METHOD_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n+\n+  u2 as_field_flags() const  {\n+    assert((_flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n+\n+  u2 as_class_flags() const  {\n+    assert((_flags & JVM_RECOGNIZED_CLASS_MODIFIERS) == _flags, \"only recognized flags\");\n+    return _flags;\n+  }\n@@ -108,1 +106,1 @@\n-inline AccessFlags accessFlags_from(jint flags) {\n+inline AccessFlags accessFlags_from(u2 flags) {\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+\/\/  _0    - print as hexadecimal, with leading 0s, without 0x prefix: 0012345\n@@ -134,0 +135,1 @@\n+#define UINT64_FORMAT_0          \"%016\"       PRIx64\n@@ -188,0 +190,5 @@\n+\/\/ Convert pointer to uintptr_t\n+inline uintptr_t p2u(const volatile void* p) {\n+  return (uintptr_t) p;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,11 +93,0 @@\n-\/\/ Formatting.\n-#ifdef _LP64\n-# ifdef __APPLE__\n-# define FORMAT64_MODIFIER \"ll\"\n-# else\n-# define FORMAT64_MODIFIER \"l\"\n-# endif\n-#else \/\/ !_LP64\n-#define FORMAT64_MODIFIER \"ll\"\n-#endif \/\/ _LP64\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,3 +106,0 @@\n-\/\/ Formatting.\n-#define FORMAT64_MODIFIER \"ll\"\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -361,0 +361,15 @@\n+\/\/ Enable collection of TaskQueue statistics.\n+\/\/ Enabled by default in debug builds.  Otherwise, disabled by default.\n+#ifndef TASKQUEUE_STATS\n+#ifdef ASSERT\n+#define TASKQUEUE_STATS 1\n+#else\n+#define TASKQUEUE_STATS 0\n+#endif \/\/ ASSERT\n+#endif \/\/ TASKQUEUE_STATS\n+#if TASKQUEUE_STATS\n+#define TASKQUEUE_STATS_ONLY(code) code\n+#else\n+#define TASKQUEUE_STATS_ONLY(code)\n+#endif \/\/ TASKQUEUE_STATS\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 SAP SE. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -29,2 +29,1 @@\n-import java.nio.channels.spi.AsynchronousChannelProvider;\n-import sun.nio.ch.Pollset;\n+import java.io.FileDescriptor;\n@@ -32,2 +31,1 @@\n-import java.util.HashSet;\n-import java.util.Iterator;\n+import java.nio.channels.spi.AsynchronousChannelProvider;\n@@ -35,1 +33,0 @@\n-import java.util.concurrent.RejectedExecutionException;\n@@ -38,0 +35,5 @@\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import sun.nio.ch.IOUtil;\n+import sun.nio.ch.Pollset;\n@@ -144,0 +146,2 @@\n+            \/\/ make the reading part of the socket nonblocking, so the drain (drain_all) method works\n+            IOUtil.configureBlocking(IOUtil.newFD(sv[0]), false);\n@@ -274,14 +278,11 @@\n-        synchronized (controlQueue) {\n-            \/\/ On Aix it is only possible to set the event\n-            \/\/ bits on the first call of pollsetCtl. Later\n-            \/\/ calls only add bits, but cannot remove them.\n-            \/\/ Therefore, we always remove the file\n-            \/\/ descriptor ignoring the error and then add it.\n-            Iterator<ControlEvent> iter = controlQueue.iterator();\n-            while (iter.hasNext()) {\n-                ControlEvent ev = iter.next();\n-                Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n-                if (!ev.removeOnly()) {\n-                    ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n-                }\n-                iter.remove();\n+        \/\/ On Aix it is only possible to set the event\n+        \/\/ bits on the first call of pollsetCtl. Later\n+        \/\/ calls only add bits, but cannot remove them.\n+        \/\/ Therefore, we always remove the file\n+        \/\/ descriptor ignoring the error and then add it.\n+        Iterator<ControlEvent> iter = controlQueue.iterator();\n+        while (iter.hasNext()) {\n+            ControlEvent ev = iter.next();\n+            Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n+            if (!ev.removeOnly()) {\n+                ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n@@ -289,1 +290,1 @@\n-            controlQueue.notifyAll();\n+            iter.remove();\n@@ -291,0 +292,1 @@\n+        controlQueue.notifyAll();\n@@ -309,1 +311,2 @@\n-                        n = Pollset.pollsetPoll(pollset, address,\n+                        int m;\n+                        m = n = Pollset.pollsetPoll(pollset, address,\n@@ -311,0 +314,12 @@\n+                        while (m-- > 0) {\n+                            long eventAddress = Pollset.getEvent(address, m);\n+                            int fd = Pollset.getDescriptor(eventAddress);\n+\n+                            \/\/ To emulate one shot semantic we need to remove\n+                            \/\/ the file descriptor here.\n+                            if (fd != sp[0] && fd != ctlSp[0]) {\n+                                synchronized (controlQueue) {\n+                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n+                                }\n+                            }\n+                        }\n@@ -326,8 +341,0 @@\n-                            \/\/ To emulate one shot semantic we need to remove\n-                            \/\/ the file descriptor here.\n-                            if (fd != sp[0] && fd != ctlSp[0]) {\n-                                synchronized (controlQueue) {\n-                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n-                                }\n-                            }\n-\n@@ -353,1 +360,1 @@\n-                                    Pollset.drain1(ctlSp[0]);\n+                                    IOUtil.drain(ctlSp[0]);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/AixPollPort.java","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n@@ -29,0 +30,1 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -37,3 +39,12 @@\n- * is stored in the {@code BootstrapMethods} attribute, but is modeled by\n- * the {@link ConstantPool}, since the bootstrap method table is logically\n- * part of the constant pool.\n+ * is stored in the {@link BootstrapMethodsAttribute BootstrapMethods}\n+ * attribute, but is modeled by the {@link ConstantPool}, since the bootstrap\n+ * method table is logically part of the constant pool.\n+ * <p>\n+ * A bootstrap method entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"BootstrapMethodEntry\" target=\"ConstantPoolBuilder#bsmEntry(MethodHandleEntry, List)\" :\n+ * BootstrapMethodEntry(\n+ *     MethodHandleEntry bootstrapMethod, \/\/ @link substring=\"bootstrapMethod\" target=\"#bootstrapMethod\"\n+ *     List<LoadableConstantEntry> arguments \/\/ @link substring=\"arguments\" target=\"#arguments()\"\n+ * )\n+ * }\n@@ -41,0 +52,1 @@\n+ * @see ConstantPoolBuilder#bsmEntry ConstantPoolBuilder::bsmEntry\n@@ -48,0 +60,7 @@\n+     *\n+     * @apiNote\n+     * Given a {@link ConstantPoolBuilder} {@code builder} and a {@code\n+     * BootstrapMethodEntry} {@code entry}, use {@link\n+     * ConstantPoolBuilder#canWriteDirect\n+     * builder.canWriteDirect(entry.constantPool())} instead of object equality\n+     * of the constant pool to determine if an entry is compatible.\n@@ -52,1 +71,2 @@\n-     * {@return the index into the bootstrap method table corresponding to this entry}\n+     * {@return the index into the bootstrap method table corresponding to this\n+     * entry}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/BootstrapMethodEntry.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,6 +143,7 @@\n-     * transforming a classfile.  Reusing the constant pool enables significant\n-     * optimizations in processing time and minimizes differences between the\n-     * original and transformed classfile, but may result in a bigger classfile\n-     * when a classfile is significantly transformed.\n-     * Default is {@code SHARED_POOL} to preserve the original constant\n-     * pool.\n+     * transforming a {@code class} file.  Reusing the constant pool enables\n+     * significant optimizations in processing time and minimizes differences\n+     * between the original and transformed {@code class} files, but may result\n+     * in a bigger transformed {@code class} file when many elements of the\n+     * original {@code class} file are dropped and many original constant\n+     * pool entries become unused.  Default is {@link #SHARED_POOL} to preserve\n+     * the original constant pool.\n@@ -150,0 +151,3 @@\n+     * @see ConstantPoolBuilder\n+     * @see #build(ClassEntry, ConstantPoolBuilder, Consumer)\n+     * @see #transformClass(ClassModel, ClassTransform)\n@@ -154,1 +158,17 @@\n-        \/** Preserves the original constant pool when transforming classfile *\/\n+        \/**\n+         * Preserves the original constant pool when transforming the {@code\n+         * class} file.\n+         * <p>\n+         * These two transformations below are equivalent:\n+         * {@snippet lang=java :\n+         * ClassModel originalClass = null; \/\/ @replace substring=null; replacement=...\n+         * ClassDesc resultClassName = null; \/\/ @replace substring=null; replacement=...\n+         * ClassTransform classTransform = null; \/\/ @replace substring=null; replacement=...\n+         * var resultOne = ClassFile.of(ConstantPoolSharingOption.SHARED_POOL)\n+         *         .transformClass(originalClass, resultClassName, classTransform);\n+         * var resultTwo = ClassFile.of().build(resultClassName, ConstantPoolBuilder.of(originalClass),\n+         *         clb -> clb.transform(originalClass, classTransform));\n+         * }\n+         *\n+         * @see ConstantPoolBuilder#of(ClassModel) ConstantPoolBuilder::of(ClassModel)\n+         *\/\n@@ -157,1 +177,16 @@\n-        \/** Creates a new constant pool when transforming classfile *\/\n+        \/**\n+         * Creates a new constant pool when transforming the {@code class} file.\n+         * <p>\n+         * These two transformations below are equivalent:\n+         * {@snippet lang=java :\n+         * ClassModel originalClass = null; \/\/ @replace substring=null; replacement=...\n+         * ClassDesc resultClassName = null; \/\/ @replace substring=null; replacement=...\n+         * ClassTransform classTransform = null; \/\/ @replace substring=null; replacement=...\n+         * var resultOne = ClassFile.of(ConstantPoolSharingOption.NEW_POOL)\n+         *         .transformClass(originalClass, resultClassName, classTransform);\n+         * var resultTwo = ClassFile.of().build(resultClassName, ConstantPoolBuilder.of(),\n+         *         clb -> clb.transform(originalClass, classTransform));\n+         * }\n+         *\n+         * @see ConstantPoolBuilder#of() ConstantPoolBuilder::of()\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,4 +31,3 @@\n- * A constant pool entry that may be used by annotation constant values,\n- * which includes the four kinds of primitive constants and UTF8 constants.\n- * These entries are also the only entries that do not refer to other\n- * constant pool entries.\n+ * Marker interface for constant pool entries that can represent constant values\n+ * associated with elements of annotations.  They are also the only entries that\n+ * do not refer to other constant pool entries.\n@@ -43,0 +42,1 @@\n+ * @jvms 4.7.16.1 The {@code element_value} structure\n@@ -50,3 +50,3 @@\n-     * {@return the constant value}  The constant value will be an {@link Integer},\n-     * {@link Long}, {@link Float}, {@link Double} for the primitive constants,\n-     * or {@link String} for UTF8 constants.\n+     * {@return the constant value}  The constant value will be an {@link\n+     * Integer}, {@link Long}, {@link Float}, {@link Double} for the primitive\n+     * constants, or {@link String} for UTF8 constants.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/AnnotationConstantValueEntry.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,24 @@\n- * Models a {@code CONSTANT_Class_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.1 The CONSTANT_Class_info Structure\n+ * Models a {@code CONSTANT_Class_info} structure, representing a reference\n+ * type, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code ClassEntry} is modeled by a {@link ClassDesc} that is not\n+ * primitive.  Conversions are through {@link ConstantPoolBuilder#classEntry(\n+ * ClassDesc)} and {@link #asSymbol()}.\n+ * <p>\n+ * A {@code ClassEntry} is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"ClassEntry\" target=\"ConstantPoolBuilder#classEntry(Utf8Entry)\" :\n+ * ClassEntry(Utf8Entry name) \/\/ @link substring=\"name\" target=\"#name\"\n+ * }\n+ * where {@code name} represents:\n+ * <ul>\n+ * <li>The internal form of a binary name (JVMS {@jvms 4.2.1}), if and only if\n+ * this {@code ClassEntry} represents a class or interface, such as {@code\n+ * java\/lang\/String} for the {@link String} class.\n+ * <li>A field descriptor string (JVMS {@jvms 4.3.2}) representing an array type,\n+ * if and only if this {@code ClassEntry} represents an array type, such as\n+ * {@code [I} for the {@code int[]} type, or {@code [Ljava\/lang\/String;} for the\n+ * {@code String[]} type.\n+ * <\/ul>\n+ * A field descriptor string for an array type can be distinguished by its\n+ * leading {@code '['} character.\n@@ -37,0 +58,9 @@\n+ * @apiNote\n+ * The internal form of a binary name, where all occurrences of {@code .} in the\n+ * name are replaced by {@code \/}, is informally known as an <dfn>{@index\n+ * \"internal name\"}<\/dfn>.  This concept also applies to package names in\n+ * addition to class and interface names.\n+ *\n+ * @see ConstantPoolBuilder#classEntry ConstantPoolBuilder::classEntry\n+ * @see ClassDesc\n+ * @jvms 4.4.1 The {@code CONSTANT_Class_info} Structure\n@@ -43,0 +73,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -49,1 +84,8 @@\n-     * {@return the UTF8 constant pool entry for the class name}\n+     * {@return the {@code Utf8Entry} referred by this structure}  If the\n+     * value of the UTF8 starts with a {@code [}, this represents an array type\n+     * and the value is a descriptor string; otherwise, this represents a class\n+     * or interface and the value is the {@linkplain ##internalname internal\n+     * form} of a binary name.\n+     *\n+     * @see ConstantPoolBuilder#classEntry(Utf8Entry)\n+     *      ConstantPoolBuilder::classEntry(Utf8Entry)\n@@ -54,1 +96,3 @@\n-     * {@return the class name, as an internal binary name}\n+     * {@return the represented reference type, as the {@linkplain\n+     * ##internalname internal form} of a binary name or an array descriptor\n+     * string}  This is a shortcut for {@link #name() name().stringValue()}.\n@@ -59,1 +103,6 @@\n-     * {@return the class name, as a symbolic descriptor}\n+     * {@return the represented reference type, as a symbolic descriptor}  The\n+     * returned descriptor is never {@linkplain ClassDesc#isPrimitive()\n+     * primitive}.\n+     *\n+     * @see ConstantPoolBuilder#classEntry(ClassDesc)\n+     *      ConstantPoolBuilder::classEntry(ClassDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ClassEntry.java","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,18 @@\n- * Models a {@code CONSTANT_Dynamic_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+ * Models a {@code CONSTANT_Dynamic_info} structure, representing a <dfn>{@index\n+ * \"dynamically-computed constant\"}<\/dfn>, in the constant pool of a {@code\n+ * class} file.\n+ * <p>\n+ * The use of a {@code ConstantDynamicEntry} is modeled by a {@link\n+ * DynamicConstantDesc}.  Conversions are through {@link #asSymbol()} and {@link\n+ * ConstantPoolBuilder#constantDynamicEntry(DynamicConstantDesc)}.\n+ * <p>\n+ * A dynamic constant entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"ConstantDynamicEntry\" target=\"ConstantPoolBuilder#constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\" :\n+ * ConstantDynamicEntry(\n+ *     BootstrapMethodEntry bootstrap, \/\/ @link substring=\"bootstrap\" target=\"#bootstrap()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where {@link #type() nameAndType.type()} is a {@linkplain #typeSymbol()\n+ * field descriptor} string.\n@@ -40,0 +55,11 @@\n+ * @apiNote\n+ * A dynamically-computed constant is frequently called a <dfn>{@index \"dynamic\n+ * constant\"}<\/dfn>, or a <dfn>{@index \"condy\"}<\/dfn>, from the abbreviation of\n+ * \"constant dynamic\".\n+ *\n+ * @see ConstantPoolBuilder#constantDynamicEntry\n+ *      ConstantPoolBuilder::constantDynamicEntry\n+ * @see DynamicConstantDesc\n+ * @see java.lang.invoke##condycon Dynamically-computed constants\n+ * @jvms 4.4.10 The {@code CONSTANT_Dynamic_info} and {@code\n+ *              CONSTANT_InvokeDynamic_info} Structures\n@@ -47,1 +73,2 @@\n-     * {@return a symbolic descriptor for the dynamic constant's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() field type} of\n+     * this dynamically-computed constant}\n@@ -53,0 +80,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -59,1 +91,4 @@\n-     * {@return the symbolic descriptor for the {@code invokedynamic} constant}\n+     * {@return a symbolic descriptor for this dynamically-computed constant}\n+     *\n+     * @see ConstantPoolBuilder#constantDynamicEntry(DynamicConstantDesc)\n+     *      ConstantPoolBuilder::constantDynamicEntry(DynamicConstantDesc)\n@@ -71,1 +106,6 @@\n-     * {@return the type of the constant}\n+     * {@inheritDoc}\n+     *\n+     * @apiNote\n+     * The data type of a dynamically-computed constant depends on its\n+     * {@linkplain #type() descriptor}, while the data type of all other\n+     * constants can be determined by their {@linkplain #tag() constant type}.\n@@ -75,1 +115,1 @@\n-        return TypeKind.fromDescriptor(type().stringValue());\n+        return TypeKind.fromDescriptor(type());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantDynamicEntry.java","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.classfile.attribute.BootstrapMethodsAttribute;\n@@ -34,3 +35,8 @@\n- * Provides read access to the constant pool and bootstrap method table of a\n- * classfile.\n- * @jvms 4.4 The Constant Pool\n+ * Provides read access to the constant pool and the bootstrap method table of a\n+ * {@code class} file.\n+ *\n+ * <h2 id=\"index\">Index in the Constant Pool<\/h2>\n+ * The constant pool entries are accessed by index.  A valid index is in the\n+ * range of {@link #size() [1, size())}.  It is {@linkplain PoolEntry#width()\n+ * unusable} if a {@link LongEntry} or {@link DoubleEntry} is at its previous\n+ * index.\n@@ -38,0 +44,2 @@\n+ * @see BootstrapMethodsAttribute\n+ * @jvms 4.4 The Constant Pool\n@@ -49,1 +57,1 @@\n-     * int, Class) entryByIndex(int, Class)}.\n+     * int, Class)}.\n@@ -58,1 +66,5 @@\n-     * {@return the size of the constant pool}\n+     * {@return the exclusive upper bound of the valid indices of this constant\n+     * pool}  The actual number of entries is lower because {@code 0}, {@code\n+     * size()} are not valid, and a valid index may be unusable.\n+     *\n+     * @see ##index Index in the Constant Pool\n@@ -69,1 +81,2 @@\n-     *         constant pool, or the entry is not of the given type\n+     *         constant pool or considered unusable, or the entry is not\n+     *         of the given type\n@@ -75,0 +88,4 @@\n+     *\n+     * @apiNote\n+     * This skips any unusable index and is less error-prone than iterating by\n+     * raw index.  See <em>{@linkplain ##index Index in the Constant Pool}<\/em>.\n@@ -96,1 +113,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPool.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileBuilder;\n@@ -30,0 +31,3 @@\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.attribute.ConstantValueAttribute;\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -31,0 +35,1 @@\n+import java.lang.invoke.MethodHandleInfo;\n@@ -32,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -42,3 +48,12 @@\n- * Builder for the constant pool of a classfile.  Provides read and write access\n- * to the constant pool that is being built.  Writing is append-only and idempotent\n- * (entry-bearing methods will return an existing entry if there is one).\n+ * Builder for the constant pool of a {@code class} file.  Provides read and\n+ * write access to the constant pool that is {@linkplain ClassFileBuilder#constantPool()\n+ * being built}.  Writing is append-only (the index of new entries monotonically\n+ * increase) and idempotent (entry-bearing methods will return an existing entry\n+ * if there is a suitable one).\n+ * <p>\n+ * For {@code class} file building, an overload of {@link ClassFile#build(\n+ * ClassEntry, ConstantPoolBuilder, Consumer) ClassFile::build} takes a\n+ * {@code ConstantPoolBuilder}.  For {@code class} file transformations via\n+ * {@link ClassFile#transformClass ClassFile::transformClass}, the {@link\n+ * ClassFile.ConstantPoolSharingOption} controls how the constant pool builder\n+ * of the resulting {@code class} is created.\n@@ -46,3 +61,24 @@\n- * A {@linkplain ConstantPoolBuilder} is associated with a {@link ClassBuilder}.\n- * The {@linkplain ConstantPoolBuilder} also provides access to some of the\n- * state of the {@linkplain ClassBuilder}, such as classfile processing options.\n+ * <h2 id=\"alien\">Alien Constant Pool Entries<\/h2>\n+ * In {@code class} file building and constant pool building, some constant pool\n+ * entries supplied may be {@linkplain #canWriteDirect(ConstantPool) alien}\n+ * to this constant pool builder of the active class file builder.  For example,\n+ * {@link #classEntry(Utf8Entry) classEntry(Utf8Entry)} may be called with an\n+ * alien UTF8 entry.  Alien entries will be converted to a pool entry in\n+ * this constant pool builder, reusing equivalent entries or adding new entries\n+ * if there is none.  As a result, all pool entries returned by entry-bearing\n+ * methods in this constant pool builder belong to this constant pool.\n+ * <p>\n+ * Some {@link ClassFileBuilder} methods may have their outputs adjusted if they\n+ * receive pool entries alien to {@linkplain ClassFileBuilder#constantPool\n+ * their constant pools}.  For example, if an {@link ConstantInstruction#ofLoad\n+ * ldc_w} instruction with an alien entry is written to a {@link CodeBuilder},\n+ * the {@code CodeBuilder} may emit a functionally equivalent {@code ldc}\n+ * instruction instead, if the converted entry can be encoded in such an\n+ * instruction.\n+ * <p>\n+ * To avoid the conversion of alien constant pool entries, such as for the\n+ * accuracy of the generated {@code class} file, users can always supply\n+ * constant pool entries obtained by calling the constant pool builder\n+ * entry-bearing methods of the constant pools associated with the {@code\n+ * ClassFileBuilder}.  Otherwise, the conversions have no impact on the\n+ * behaviors of the generated {@code class} files.\n@@ -50,0 +86,1 @@\n+ * @see ClassFileBuilder#constantPool()\n@@ -58,2 +95,4 @@\n-     * be pre-populated with the contents of the constant pool associated with\n-     * the class reader.\n+     * be pre-populated with the contents of the constant pool {@linkplain\n+     * ClassModel#constantPool() associated with} the given class model.  The\n+     * index of new entries will start from the {@link ConstantPool#size()\n+     * size()} of the source pool.\n@@ -62,0 +101,2 @@\n+     * @see ClassFile#build(ClassEntry, ConstantPoolBuilder, Consumer)\n+     * @see ClassFile.ConstantPoolSharingOption#SHARED_POOL\n@@ -69,1 +110,3 @@\n-     * will be empty.\n+     * will be empty.  The index of new entries will start from {@code 1}.\n+     *\n+     * @see ClassFile.ConstantPoolSharingOption#NEW_POOL\n@@ -76,3 +119,8 @@\n-     * {@return whether the provided constant pool is index-compatible with this\n-     * one}  This may be because they are the same constant pool, or because this\n-     * constant pool was copied from the other.\n+     * {@return {@code true} if the index of any entry in the given constant\n+     * pool refers to the same entry in this builder}  This may be because they\n+     * are the same builder, or because this builder was {@linkplain\n+     * #of(ClassModel) pre-populated} from the given constant pool.\n+     * <p>\n+     * If the constant pool of an entry is not directly writable to this pool,\n+     * it is alien to this pool, and a {@link ClassFileBuilder} associated\n+     * with this constant pool will convert that alien constant pool entry.\n@@ -80,1 +128,3 @@\n-     * @param constantPool the other constant pool\n+     * @param constantPool the given constant pool\n+     * @see ClassFileBuilder#constantPool() ClassFileBuilder::constantPool\n+     * @see ##alien Alien Constant Pool Entries\n@@ -85,3 +135,1 @@\n-     * {@return A {@link Utf8Entry} describing the provided {@linkplain String}}\n-     * If a UTF8 entry in the pool already describes this string, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link Utf8Entry} describing the provided {@link String}}\n@@ -90,0 +138,1 @@\n+     * @see Utf8Entry#stringValue() Utf8Entry::stringValue\n@@ -94,4 +143,8 @@\n-     * {@return A {@link Utf8Entry} describing the field descriptor of the provided\n-     * {@linkplain ClassDesc}}\n-     * If a UTF8 entry in the pool already describes this field descriptor, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link Utf8Entry} describing the {@linkplain\n+     * ClassDesc#descriptorString() field descriptor string} of the provided\n+     * {@link ClassDesc}}\n+     *\n+     * @apiNote\n+     * The resulting {@code Utf8Entry} is usually not {@linkplain\n+     * #classEntry(Utf8Entry) referable by} a {@link ClassEntry}, which uses\n+     * internal form of binary names.\n@@ -106,4 +159,3 @@\n-     * {@return A {@link Utf8Entry} describing the method descriptor of the provided\n-     * {@linkplain MethodTypeDesc}}\n-     * If a UTF8 entry in the pool already describes this field descriptor, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link Utf8Entry} describing the {@linkplain\n+     * MethodTypeDesc#descriptorString() method descriptor string} of the\n+     * provided {@link MethodTypeDesc}}\n@@ -118,5 +170,4 @@\n-     * {@return A {@link ClassEntry} describing the class whose internal name\n-     * is encoded in the provided {@linkplain Utf8Entry}}\n-     * If a Class entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ClassEntry} referring to the provided {@link\n+     * Utf8Entry}}  The {@code Utf8Entry} describes the internal form\n+     * of the binary name of a class or interface or the field descriptor\n+     * string of an array type.\n@@ -124,1 +175,2 @@\n-     * @param ne the constant pool entry describing the internal name of the class\n+     * @param ne the {@code Utf8Entry}\n+     * @see ClassEntry#name() ClassEntry::name\n@@ -129,5 +181,2 @@\n-     * {@return A {@link ClassEntry} describing the class described by\n-     * provided {@linkplain ClassDesc}}\n-     * If a Class entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ClassEntry} describing the same reference type\n+     * as the provided {@link ClassDesc}}\n@@ -135,2 +184,4 @@\n-     * @param classDesc the symbolic descriptor for the class\n-     * @throws IllegalArgumentException if {@code classDesc} represents a primitive type\n+     * @param classDesc the symbolic descriptor for the reference type\n+     * @throws IllegalArgumentException if {@code classDesc} represents a\n+     *         primitive type\n+     * @see ClassEntry#asSymbol() ClassEntry::asSymbol\n@@ -148,5 +199,3 @@\n-     * {@return A {@link PackageEntry} describing the class whose internal name\n-     * is encoded in the provided {@linkplain Utf8Entry}}\n-     * If a Package entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link PackageEntry} referring to the provided {@link\n+     * Utf8Entry}}  The {@code Utf8Entry} describes the internal form\n+     * of the name of a package.\n@@ -154,2 +203,2 @@\n-     * @param nameEntry the constant pool entry describing the internal name of\n-     *                  the package\n+     * @param nameEntry the {@code Utf8Entry}\n+     * @see PackageEntry#name() PackageEntry::name\n@@ -160,5 +209,2 @@\n-     * {@return A {@link PackageEntry} describing the class described by\n-     * provided {@linkplain PackageDesc}}\n-     * If a Package entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link PackageEntry} describing the same package as the\n+     * provided {@link PackageDesc}}\n@@ -166,1 +212,2 @@\n-     * @param packageDesc the symbolic descriptor for the class\n+     * @param packageDesc the symbolic descriptor for the package\n+     * @see PackageEntry#asSymbol() PackageEntry::asSymbol\n@@ -173,5 +220,2 @@\n-     * {@return A {@link ModuleEntry} describing the module whose name\n-     * is encoded in the provided {@linkplain Utf8Entry}}\n-     * If a module entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ModuleEntry} referring to the provided {@link\n+     * Utf8Entry}}  The {@code Utf8Entry} describes the module name.\n@@ -180,0 +224,1 @@\n+     * @see ModuleEntry#name() ModuleEntry::name\n@@ -184,5 +229,2 @@\n-     * {@return A {@link ModuleEntry} describing the module described by\n-     * provided {@linkplain ModuleDesc}}\n-     * If a module entry in the pool already describes this class,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ModuleEntry} describing the same module as the provided\n+     * {@link ModuleDesc}}\n@@ -190,1 +232,2 @@\n-     * @param moduleDesc the symbolic descriptor for the class\n+     * @param moduleDesc the symbolic descriptor for the module\n+     * @see ModuleEntry#asSymbol() ModuleEntry::asSymbol\n@@ -197,4 +240,5 @@\n-     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n-     * If a NameAndType entry in the pool already describes this name and type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link NameAndTypeEntry} referring to the provided name and\n+     * type {@link Utf8Entry}}  The name {@code Utf8Entry} describes an\n+     * unqualified name or the special name {@value ConstantDescs#INIT_NAME},\n+     * and the type {@code Utf8Entry} describes a field or method descriptor\n+     * string.\n@@ -202,2 +246,4 @@\n-     * @param nameEntry the member name\n-     * @param typeEntry the member field or method descriptor\n+     * @param nameEntry the name {@code Utf8Entry}\n+     * @param typeEntry the type {@code Utf8Entry}\n+     * @see NameAndTypeEntry#name() NameAndTypeEntry::name\n+     * @see NameAndTypeEntry#type() NameAndTypeEntry::type\n@@ -208,4 +254,2 @@\n-     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n-     * If a NameAndType entry in the pool already describes this name and type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link NameAndTypeEntry} describing the provided unqualified\n+     * name and field descriptor}\n@@ -213,2 +257,2 @@\n-     * @param name the member name\n-     * @param type the symbolic descriptor for a field type\n+     * @param name the unqualified name\n+     * @param type the field descriptor\n@@ -221,4 +265,3 @@\n-     * {@return A {@link NameAndTypeEntry} describing the provided name and type}\n-     * If a NameAndType entry in the pool already describes this name and type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link NameAndTypeEntry} describing the provided name and\n+     * method descriptor}  The name can be an unqualified name or the\n+     * special name {@value ConstantDescs#INIT_NAME}.\n@@ -226,2 +269,2 @@\n-     * @param name the member name\n-     * @param type the symbolic descriptor for a method type\n+     * @param name the unqualified name, or {@value ConstantDescs#INIT_NAME}\n+     * @param type the method descriptor\n@@ -234,4 +277,5 @@\n-     * {@return A {@link FieldRefEntry} describing a field of a class}\n-     * If a FieldRef entry in the pool already describes this field,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link FieldRefEntry} referring to a {@link ClassEntry} and a\n+     * {@link NameAndTypeEntry}}  The {@code ClassEntry} describes a class or\n+     * interface that has this field as a member, and the {@code\n+     * NameAndTypeEntry} describes the unqualified name and the field descriptor\n+     * for this field.\n@@ -239,2 +283,4 @@\n-     * @param owner the class the field is a member of\n-     * @param nameAndType the name and type of the field\n+     * @param owner the {@code ClassEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see FieldRefEntry#owner() FieldRefEntry::owner\n+     * @see FieldRefEntry#nameAndType() FieldRefEntry::nameAndType\n@@ -245,4 +291,1 @@\n-     * {@return A {@link FieldRefEntry} describing a field of a class}\n-     * If a FieldRef entry in the pool already describes this field,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link FieldRefEntry} describing a field of a class}\n@@ -250,3 +293,3 @@\n-     * @param owner the class the field is a member of\n-     * @param name the name of the field\n-     * @param type the type of the field\n+     * @param owner the class or interface the field is a member of\n+     * @param name the unqualified name of the field\n+     * @param type the field descriptor\n@@ -254,0 +297,1 @@\n+     * @see FieldRefEntry#typeSymbol() FieldRefEntry::typeSymbol\n@@ -260,4 +304,5 @@\n-     * {@return A {@link MethodRefEntry} describing a method of a class}\n-     * If a MethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodRefEntry} referring to a {@link ClassEntry} and a\n+     * {@link NameAndTypeEntry}}  The {@code ClassEntry} describes a class that\n+     * has this method as a member, and the {@code NameAndTypeEntry} describes\n+     * the unqualified name or the special name {@value ConstantDescs#INIT_NAME}\n+     * and the method descriptor for this method.\n@@ -265,2 +310,4 @@\n-     * @param owner the class the method is a member of\n-     * @param nameAndType the name and type of the method\n+     * @param owner the {@code ClassEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see MethodRefEntry#owner() MethodRefEntry::owner\n+     * @see MethodRefEntry#nameAndType() MethodRefEntry::nameAndType\n@@ -271,4 +318,1 @@\n-     * {@return A {@link MethodRefEntry} describing a method of a class}\n-     * If a MethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodRefEntry} describing a method of a class}\n@@ -277,2 +321,3 @@\n-     * @param name the name of the method\n-     * @param type the type of the method\n+     * @param name the unqualified name, or special name {@value\n+     *        ConstantDescs#INIT_NAME}, of the method\n+     * @param type the method descriptor\n@@ -280,0 +325,1 @@\n+     * @see MethodRefEntry#typeSymbol() MethodRefEntry::typeSymbol\n@@ -286,4 +332,5 @@\n-     * {@return A {@link InterfaceMethodRefEntry} describing a method of a class}\n-     * If a InterfaceMethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InterfaceMethodRefEntry} referring to a {@link\n+     * ClassEntry} and a {@link NameAndTypeEntry}}  The {@code ClassEntry}\n+     * describes an interface that has this method as a member, and the {@code\n+     * NameAndTypeEntry} describes the unqualified name and the method\n+     * descriptor for this method.\n@@ -291,2 +338,5 @@\n-     * @param owner the class the method is a member of\n-     * @param nameAndType the name and type of the method\n+     * @param owner the {@code ClassEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see InterfaceMethodRefEntry#owner() InterfaceMethodRefEntry::owner\n+     * @see InterfaceMethodRefEntry#nameAndType()\n+     *      InterfaceMethodRefEntry::nameAndType\n@@ -297,4 +347,2 @@\n-     * {@return A {@link InterfaceMethodRefEntry} describing a method of a class}\n-     * If a InterfaceMethodRefEntry entry in the pool already describes this method,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InterfaceMethodRefEntry} describing a method of an\n+     * interface}\n@@ -302,3 +350,3 @@\n-     * @param owner the class the method is a member of\n-     * @param name the name of the method\n-     * @param type the type of the method\n+     * @param owner the interface the method is a member of\n+     * @param name the unqualified name of the method\n+     * @param type the method descriptor\n@@ -306,0 +354,1 @@\n+     * @see InterfaceMethodRefEntry#typeSymbol() InterfaceMethodRefEntry::typeSymbol\n@@ -312,4 +361,2 @@\n-     * {@return A {@link MethodTypeEntry} describing a method type}\n-     * If a MethodType entry in the pool already describes this method type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodTypeEntry} describing the same method type as\n+     * the provided {@link MethodTypeDesc}}\n@@ -318,0 +365,1 @@\n+     * @see MethodTypeEntry#asSymbol() MethodTypeEntry::asSymbol\n@@ -322,4 +370,2 @@\n-     * {@return A {@link MethodTypeEntry} describing a method type}\n-     * If a MethodType entry in the pool already describes this method type,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodTypeEntry} referring to a {@link Utf8Entry}}\n+     * The {@code Utf8Entry} represents a method descriptor string.\n@@ -327,1 +373,2 @@\n-     * @param descriptor the constant pool entry for the method type descriptor\n+     * @param descriptor the {@code Utf8Entry}\n+     * @see MethodTypeEntry#descriptor() MethodTypeEntry::descriptor\n@@ -332,4 +379,2 @@\n-     * {@return A {@link MethodHandleEntry} describing a direct method handle}\n-     * If a MethodHandle entry in the pool already describes this method handle,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodHandleEntry} describing the same method handle as\n+     * the given {@link DirectMethodHandleDesc}}\n@@ -338,0 +383,1 @@\n+     * @see MethodHandleEntry#asSymbol() MethodHandleEntry::asSymbol\n@@ -350,4 +396,4 @@\n-     * {@return A {@link MethodHandleEntry} describing a field accessor or method}\n-     * If a MethodHandle entry in the pool already describes this method handle,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link MethodHandleEntry} encoding a reference kind and\n+     * referring to a {@link MemberRefEntry}}  The reference kind must be\n+     * in {@code [1, 9]}, and the {@code MemberRefEntry} is subject to\n+     * various restrictions based on the reference kind (JVMS {@jvms 4.4.8}).\n@@ -355,2 +401,5 @@\n-     * @param refKind the reference kind of the method handle (JVMS {@jvms 4.4.8})\n-     * @param reference the constant pool entry describing the field or method\n+     * @param refKind the reference kind of the method handle\n+     * @param reference the {@code MemberRefEntry}\n+     * @see MethodHandleInfo##refkinds Reference kinds\n+     * @see MethodHandleEntry#kind() MethodHandleEntry::kind\n+     * @see MethodHandleEntry#reference() MethodHandleEntry::reference\n@@ -361,4 +410,2 @@\n-     * {@return An {@link InvokeDynamicEntry} describing a dynamic call site}\n-     * If an InvokeDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InvokeDynamicEntry} describing the same dynamic call\n+     * site as the provided {@link DynamicCallSiteDesc}}\n@@ -366,1 +413,2 @@\n-     * @param dcsd the symbolic descriptor of the method handle\n+     * @param dcsd the symbolic descriptor of the dynamic call site\n+     * @see InvokeDynamicEntry#asSymbol() InvokeDynamicEntry::asSymbol\n@@ -373,4 +421,5 @@\n-     * {@return An {@link InvokeDynamicEntry} describing a dynamic call site}\n-     * If an InvokeDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return an {@link InvokeDynamicEntry} referring to a {@link\n+     * BootstrapMethodEntry} and a {@link NameAndTypeEntry}}\n+     * The {@code BootstrapMethodEntry} describes the bootstrap method\n+     * and its invocation arguments in addition to the name and type,\n+     * and the {@code NameAndTypeEntry} a name and a method descriptor.\n@@ -378,2 +427,4 @@\n-     * @param bootstrapMethodEntry the entry in the bootstrap method table\n-     * @param nameAndType the invocation name and type\n+     * @param bootstrapMethodEntry the {@code BootstrapMethodEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see InvokeDynamicEntry#bootstrap() InvokeDynamicEntry::bootstrap\n+     * @see InvokeDynamicEntry#nameAndType() InvokeDynamicEntry::nameAndType\n@@ -385,4 +436,2 @@\n-     * {@return A {@link ConstantDynamicEntry} describing a dynamic constant}\n-     * If a ConstantDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ConstantDynamicEntry} describing the dynamic constant\n+     * as the provided {@link DynamicConstantDesc}}\n@@ -391,0 +440,1 @@\n+     * @see ConstantDynamicEntry#asSymbol() ConstantDynamicEntry::asSymbol\n@@ -397,4 +447,5 @@\n-     * {@return A {@link ConstantDynamicEntry} describing a dynamic constant}\n-     * If a ConstantDynamic entry in the pool already describes this site,\n-     * it is returned; otherwise, a new entry is added and the new entry is\n-     * returned.\n+     * {@return a {@link ConstantDynamicEntry} referring to a {@link\n+     * BootstrapMethodEntry} and a {@link NameAndTypeEntry}}\n+     * The {@code BootstrapMethodEntry} describes the bootstrap method\n+     * and its invocation arguments in addition to the name and type,\n+     * and the {@code NameAndTypeEntry} a name and a field descriptor.\n@@ -402,2 +453,4 @@\n-     * @param bootstrapMethodEntry the entry in the bootstrap method table\n-     * @param nameAndType the invocation name and type\n+     * @param bootstrapMethodEntry the {@code BootstrapMethodEntry}\n+     * @param nameAndType the {@code NameAndTypeEntry}\n+     * @see ConstantDynamicEntry#bootstrap() ConstantDynamicEntry::bootstrap\n+     * @see ConstantDynamicEntry#nameAndType() ConstantDynamicEntry::nameAndType\n@@ -408,3 +461,1 @@\n-     * {@return An {@link IntegerEntry} describing the provided value}\n-     * If an integer entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return an {@link IntegerEntry} describing the provided value}\n@@ -413,0 +464,1 @@\n+     * @see IntegerEntry#intValue() IntegerEntry::intValue\n@@ -417,3 +469,1 @@\n-     * {@return A {@link FloatEntry} describing the provided value}\n-     * If a float entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link FloatEntry} describing the provided value}\n@@ -422,0 +472,1 @@\n+     * @see FloatEntry#floatValue() FloatEntry::floatValue\n@@ -426,3 +477,1 @@\n-     * {@return A {@link LongEntry} describing the provided value}\n-     * If a long entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link LongEntry} describing the provided value}\n@@ -431,0 +480,1 @@\n+     * @see LongEntry#longValue() LongEntry::longValue\n@@ -435,3 +485,1 @@\n-     * {@return A {@link DoubleEntry} describing the provided value}\n-     * If a double entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link DoubleEntry} describing the provided value}\n@@ -440,0 +488,1 @@\n+     * @see DoubleEntry#doubleValue() DoubleEntry::doubleValue\n@@ -444,3 +493,2 @@\n-     * {@return A {@link StringEntry} referencing the provided UTF8 entry}\n-     * If a String entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link StringEntry} referring to a {@link Utf8Entry}}\n+     * The {@code Utf8Entry} describes the string value.\n@@ -448,1 +496,2 @@\n-     * @param utf8 the UTF8 entry describing the string\n+     * @param utf8 the {@code Utf8Entry}\n+     * @see StringEntry#utf8() StringEntry::utf8\n@@ -453,3 +502,1 @@\n-     * {@return A {@link StringEntry} describing the provided value}\n-     * If a string entry in the pool already describes this value, it is returned;\n-     * otherwise, a new entry is added and the new entry is returned.\n+     * {@return a {@link StringEntry} describing the provided value}\n@@ -458,0 +505,1 @@\n+     * @see StringEntry#stringValue() StringEntry::stringValue\n@@ -464,2 +512,3 @@\n-     * {@return A {@link ConstantValueEntry} describing the provided\n-     * Integer, Long, Float, Double, or String constant}\n+     * {@return a {@link ConstantValueEntry} describing the provided constant\n+     * {@link Integer}, {@link Long}, {@link Float}, {@link Double}, or {@link\n+     * String} value}\n@@ -467,2 +516,7 @@\n-     * @param c the constant\n-     * @see ConstantValueEntry#constantValue()\n+     * @param c the provided constant value\n+     * @throws IllegalArgumentException if the value is not one of {@code\n+     *         Integer}, {@code Long}, {@code Float}, {@code Double}, or {@code\n+     *         String}\n+     * @see ConstantValueEntry#constantValue() ConstantValueEntry::constantValue\n+     * @see ConstantValueAttribute#of(ConstantDesc)\n+     *      ConstantValueAttribute::of(ConstantDesc)\n@@ -480,5 +534,2 @@\n-     * {@return A {@link LoadableConstantEntry} describing the provided\n-     * constant}  The constant should be an Integer, String, Long, Float,\n-     * Double, ClassDesc (for a Class constant), MethodTypeDesc (for a MethodType\n-     * constant), DirectMethodHandleDesc (for a MethodHandle constant), or\n-     * a DynamicConstantDesc (for a dynamic constant.)\n+     * {@return a {@link LoadableConstantEntry} describing the provided constant\n+     * value}\n@@ -486,1 +537,1 @@\n-     * @param c the constant\n+     * @param c the nominal descriptor for the constant\n@@ -503,1 +554,1 @@\n-     * bootstrap method and static arguments}\n+     * bootstrap method and arguments}\n@@ -506,1 +557,1 @@\n-     * @param arguments the bootstrap arguments\n+     * @param arguments the arguments\n@@ -515,2 +566,4 @@\n-     * {@return a {@link BootstrapMethodEntry} describing the provided\n-     * bootstrap method and static arguments}\n+     * {@return a {@link BootstrapMethodEntry} referring to a {@link\n+     * MethodHandleEntry} and a list of {@link LoadableConstantEntry}}\n+     * The {@code MethodHandleEntry} is the bootstrap method, and the\n+     * list of {@code LoadableConstantEntry} is the arguments.\n@@ -518,2 +571,5 @@\n-     * @param methodReference the bootstrap method\n-     * @param arguments the bootstrap arguments\n+     * @param methodReference the {@code MethodHandleEntry}\n+     * @param arguments the list of {@code LoadableConstantEntry}\n+     * @see BootstrapMethodEntry#bootstrapMethod()\n+     *      BootstrapMethodEntry::bootstrapMethod\n+     * @see BootstrapMethodEntry#arguments() BootstrapMethodEntry::arguments\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":250,"deletions":194,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,3 @@\n- * pool.\n+ * pool or the bootstrap method table.  This is also thrown when the lazy\n+ * evaluation of constant pool or bootstrap method table entries encounter\n+ * format errors.\n@@ -50,1 +52,2 @@\n-     * @param message the detail message.\n+     * @param message the detail message, may be {@code null} for no detail\n+     *                message\n@@ -58,5 +61,4 @@\n-     * a detail message of {@code (cause==null ? null : cause.toString())}.\n-     * @param cause the cause (which is saved for later retrieval by the\n-     *        {@link Throwable#getCause()} method).  (A {@code null} value is\n-     *        permitted, and indicates that the cause is nonexistent or\n-     *        unknown.)\n+     * a detail message of {@code cause == null ? null : cause.toString()}.\n+     *\n+     * @param cause the cause, may be {@code null} for nonexistent or unknown\n+     *              cause\n@@ -72,6 +74,4 @@\n-     * @param message the detail message (which is saved for later retrieval\n-     *        by the {@link Throwable#getMessage()} method).\n-     * @param cause the cause (which is saved for later retrieval by the\n-     *        {@link Throwable#getCause()} method).  (A {@code null} value\n-     *        is permitted, and indicates that the cause is nonexistent or\n-     *        unknown.)\n+     * @param message the detail message, may be {@code null} for no detail\n+     *                message\n+     * @param cause the cause, may be {@code null} for nonexistent or unknown\n+     *              cause\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolException.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,2 @@\n- * Models a constant pool entry that can be used as the constant in a\n- * {@link Attributes#constantValue() ConstantValue} attribute; this includes the four\n- * primitive constant types and {@linkplain String} constants.\n+ * Marker interface for constant pool entries that can represent constant values\n+ * in the {@link Attributes#constantValue() ConstantValue} attribute.\n@@ -35,0 +34,2 @@\n+ * @see ConstantPoolBuilder#constantValueEntry\n+ *      ConstantPoolBuilder::constantValueEntry\n@@ -42,2 +43,2 @@\n-     * {@return the constant value}  The constant value will be an {@link Integer},\n-     * {@link Long}, {@link Float}, {@link Double}, or {@link String}.\n+     * {@return the constant value}  The constant value will be an {@link\n+     * Integer}, {@link Long}, {@link Float}, {@link Double}, or {@link String}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantValueEntry.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,10 @@\n- * Models a {@code CONSTANT_Double_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info Structures\n+ * Models a {@code CONSTANT_Double_info} structure, representing a {@code\n+ * double} constant, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code DoubleEntry} is modeled by a {@code double}.  Conversions\n+ * are through {@link ConstantPoolBuilder#doubleEntry} and {@link #doubleValue()}.\n+ * In the conversions, all NaN values of the {@code double} may be collapsed\n+ * into a single {@linkplain Double#NaN \"canonical\" NaN value}.\n+ * <p>\n+ * A double entry has a {@linkplain #width() width} of {@code 2}, making its\n+ * subsequent constant pool index valid and unusable.\n@@ -36,0 +43,3 @@\n+ * @see ConstantPoolBuilder#doubleEntry ConstantPoolBuilder::doubleEntry\n+ * @jvms 4.4.5 The {@code CONSTANT_Long_info} and {@code CONSTANT_Double_info}\n+ *             Structures\n@@ -43,1 +53,4 @@\n-     * {@return the double value}\n+     * {@return the {@code double} value}\n+     *\n+     * @see ConstantPoolBuilder#doubleEntry(double)\n+     *      ConstantPoolBuilder::doubleEntry(double)\n@@ -47,3 +60,0 @@\n-    \/**\n-     * {@return the type of the constant}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/DoubleEntry.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,15 @@\n- * Models a dynamic constant pool entry, which is either {@link ConstantDynamicEntry}\n- * or {@link InvokeDynamicEntry}.\n- * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+ * Superinterface modeling dynamically-computed constant pool entries, which\n+ * include {@link ConstantDynamicEntry} and {@link InvokeDynamicEntry}, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * Different types of dynamically-computed constant pool entries bear structural\n+ * similarities, but they appear in distinct locations.  As a result, their uses\n+ * are represented by different symbolic descriptors, specific to each subtype.\n+ * <p>\n+ * A dynamic constant entry is composite:\n+ * {@snippet lang=text :\n+ * DynamicConstantPoolEntry(\n+ *     BootstrapMethodEntry bootstrap, \/\/ @link substring=\"bootstrap\" target=\"#bootstrap()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n@@ -34,0 +46,5 @@\n+ * @see java.lang.invoke##jvm_mods Dynamic resolution of call sites and\n+ *      constants\n+ * @jvms 4.4.10 The {@code CONSTANT_Dynamic_info} and {@code\n+ *              CONSTANT_InvokeDynamic_info} Structures\n+ * @jvms 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n@@ -42,0 +59,6 @@\n+     *\n+     * @see java.lang.invoke##bsm Execution of bootstrap methods\n+     * @see ConstantPoolBuilder#constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     * @see ConstantPoolBuilder#invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n@@ -46,1 +69,3 @@\n-     * {@return index of the entry in the bootstrap method table for this constant}\n+     * {@return index of the entry in the bootstrap method table for this\n+     * constant}  The return value is equivalent to {@code\n+     * bootstrap().bsmIndex()}.\n@@ -51,1 +76,8 @@\n-     * {@return the invocation name and type}\n+     * {@return the name and the descriptor string indicated by this symbolic\n+     * reference}\n+     *\n+     * @see java.lang.invoke##bsm Execution of bootstrap methods\n+     * @see ConstantPoolBuilder#constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::constantDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     * @see ConstantPoolBuilder#invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n+     *      ConstantPoolBuilder::invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\n@@ -56,1 +88,1 @@\n-     * {@return the invocation name}\n+     * {@return the name indicated by this symbolic reference}\n@@ -63,1 +95,8 @@\n-     * {@return the invocation type}\n+     * {@return the descriptor string indicated by this symbolic reference}\n+     * This is a field descriptor string if this entry is a {@link\n+     * ConstantDynamicEntry}, or a method descriptor string if this entry is a\n+     * {@link InvokeDynamicEntry}.\n+     *\n+     * @apiNote\n+     * Each subinterface has its specific accessor named {@code typeSymbol} for\n+     * the symbolic descriptor derived from this descriptor string.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/DynamicConstantPoolEntry.java","additions":47,"deletions":8,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,13 @@\n- * Models a {@code CONSTANT_Fieldref_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures\n+ * Models a {@code CONSTANT_Fieldref_info} structure, or a symbolic reference\n+ * to a field, in the constant pool of a {@code class} file.\n+ * <p>\n+ * A field reference constant pool entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"FieldRefEntry\" target=\"ConstantPoolBuilder#fieldRefEntry(ClassEntry, NameAndTypeEntry)\" :\n+ * FieldRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the {@link #type() nameAndType.type()} represents a {@linkplain\n+ * #typeSymbol() field descriptor} string.\n@@ -37,0 +47,4 @@\n+ * @see ConstantPoolBuilder#fieldRefEntry ConstantPoolBuilder::fieldRefEntry\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -43,1 +57,1 @@\n-     * {@return a symbolic descriptor for the field's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() field type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/FieldRefEntry.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,7 @@\n- * Models a {@code CONSTANT_Float_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures\n+ * Models a {@code CONSTANT_Float_info} structure, or a {@code float} constant,\n+ * in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code FloatEntry} is modeled by a {@code float}.  Conversions\n+ * are through {@link ConstantPoolBuilder#floatEntry} and {@link #floatValue()}.\n+ * In the conversions, all NaN values of the {@code float} may be collapsed into\n+ * a single {@linkplain Float#NaN \"canonical\" NaN value}.\n@@ -36,0 +40,3 @@\n+ * @see ConstantPoolBuilder#floatEntry ConstantPoolBuilder::floatEntry\n+ * @jvms 4.4.4 The {@code CONSTANT_Integer_info} and {@code CONSTANT_Float_info}\n+ *             Structures\n@@ -43,1 +50,3 @@\n-     * {@return the float value}\n+     * {@return the {@code float} value}\n+     *\n+     * @see ConstantPoolBuilder#floatEntry(float)\n@@ -45,1 +54,0 @@\n-\n@@ -48,3 +56,0 @@\n-    \/**\n-     * {@return the type of the constant}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/FloatEntry.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,5 @@\n- * Models a {@code CONSTANT_Integer_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures\n+ * Models a {@code CONSTANT_Integer_info} structure, or an {@code int} constant,\n+ * in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code IntegerEntry} is modeled by an {@code int}.  Conversions\n+ * are through {@link ConstantPoolBuilder#intEntry(int)} and {@link #intValue()}.\n@@ -36,0 +38,3 @@\n+ * @see ConstantPoolBuilder#intEntry ConstantPoolBuilder::intEntry\n+ * @jvms 4.4.4 The {@code CONSTANT_Integer_info} and {@code CONSTANT_Float_info}\n+ *             Structures\n@@ -43,1 +48,3 @@\n-     * {@return the integer value}\n+     * {@return the {@code int} value}\n+     *\n+     * @see ConstantPoolBuilder#intEntry(int)\n@@ -47,3 +54,0 @@\n-    \/**\n-     * {@return the type of the constant}\n-     *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/IntegerEntry.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,14 @@\n- * Models a {@code CONSTANT_InterfaceMethodRef_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures\n+ * Models a {@code CONSTANT_InterfaceMethodRef_info} structure, or a symbolic\n+ * reference to an interface method, in the constant pool of a {@code class}\n+ * file.\n+ * <p>\n+ * An interface method reference entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"InterfaceMethodRefEntry\" target=\"ConstantPoolBuilder#interfaceMethodRefEntry(ClassEntry, NameAndTypeEntry)\" :\n+ * InterfaceMethodRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the {@link #type() type} in the {@code nameAndType} is a {@linkplain\n+ * #typeSymbol() method descriptor} string.\n@@ -37,0 +48,5 @@\n+ * @see ConstantPoolBuilder#interfaceMethodRefEntry\n+ *      ConstantPoolBuilder::interfaceMethodRefEntry\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -44,1 +60,1 @@\n-     * {@return a symbolic descriptor for the interface method's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() method type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/InterfaceMethodRefEntry.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,20 @@\n- * Models a constant pool entry for a dynamic call site.\n- * @jvms 4.4.10 The CONSTANT_Dynamic_info and CONSTANT_InvokeDynamic_info Structures\n+ * Models a {@code CONSTANT_InvokeDynamic_info} structure, or the symbolic\n+ * reference to a <dfn>{@index \"dynamically-computed call site\"}<\/dfn>, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code InvokeDynamicEntry} is modeled by a {@link\n+ * DynamicCallSiteDesc} symbolic descriptor.  It can be obtained from {@link\n+ * #asSymbol() InvokeDynamicEntry::asSymbol} and converted back to a constant\n+ * pool entry through {@link ConstantPoolBuilder#invokeDynamicEntry(DynamicCallSiteDesc)\n+ * ConstantPoolBuilder::invokeDynamicEntry}.\n+ * <p>\n+ * An invoke dynamic entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"InvokeDynamicEntry\" target=\"ConstantPoolBuilder#invokeDynamicEntry(BootstrapMethodEntry, NameAndTypeEntry)\" :\n+ * InvokeDynamicEntry(\n+ *     BootstrapMethodEntry bootstrap, \/\/ @link substring=\"bootstrap\" target=\"#bootstrap()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the {@link #type() type} in the {@code nameAndType} is a {@linkplain\n+ * #typeSymbol() method descriptor} string.\n@@ -38,0 +56,11 @@\n+ * @apiNote\n+ * A dynamically-computed call site is frequently called a <dfn>{@index \"dynamic\n+ * call site\"}<\/dfn>, or an <dfn>{@index \"indy\"}<\/dfn>, from the abbreviation of\n+ * \"invoke dynamic\".\n+ *\n+ * @see ConstantPoolBuilder#invokeDynamicEntry\n+ *      ConstantPoolBuilder::invokeDynamicEntry\n+ * @see DynamicCallSiteDesc\n+ * @see java.lang.invoke##indyinsn Dynamically-computed call sites\n+ * @jvms 4.4.10 The {@code CONSTANT_Dynamic_info} and {@code\n+ *              CONSTANT_InvokeDynamic_info} Structures\n@@ -45,1 +74,2 @@\n-     * {@return a symbolic descriptor for the call site's invocation type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() invocation\n+     * type} of this dynamic call site}\n@@ -52,1 +82,4 @@\n-     * {@return a symbolic descriptor for the dynamic call site}\n+     * {@return a symbolic descriptor for this dynamic call site}\n+     *\n+     * @see ConstantPoolBuilder#invokeDynamicEntry(DynamicCallSiteDesc)\n+     *      ConstantPoolBuilder::invokeDynamicEntry(DynamicCallSiteDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/InvokeDynamicEntry.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Opcode;\n@@ -28,0 +30,1 @@\n+import java.lang.classfile.instruction.ConstantInstruction;\n@@ -32,1 +35,5 @@\n- * {@code LDC} instructions.\n+ * {@link ConstantInstruction.LoadConstantInstruction ldc} instructions.\n+ * <p>\n+ * The use of a {@code LoadableConstantEntry} is modeled by a {@link ConstantDesc}.\n+ * Conversions are through {@link ConstantPoolBuilder#loadableConstantEntry(ConstantDesc)}\n+ * and {@link #constantValue()}.\n@@ -34,0 +41,2 @@\n+ * @see CodeBuilder#ldc(LoadableConstantEntry)\n+ * @jvms 4.4 The Constant Pool\n@@ -41,1 +50,3 @@\n-     * {@return the constant described by this entry}\n+     * {@return a symbolic descriptor of this constant}\n+     *\n+     * @see ConstantPoolBuilder#loadableConstantEntry(ConstantDesc)\n@@ -46,1 +57,6 @@\n-     * {@return the type of the constant}\n+     * {@return the data type of this constant}\n+     * <p>\n+     * If the data type is of {@linkplain TypeKind#slotSize() category} 2, this\n+     * constant must be loaded with {@link Opcode#LDC2_W ldc2_w}; otherwise, the\n+     * data type is of category 1, and this constant must be loaded with {@link\n+     * Opcode#LDC ldc} or {@link Opcode#LDC_W ldc_w}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,8 @@\n- * Models a {@code CONSTANT_Long_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info Structures\n+ * Models a {@code CONSTANT_Long_info} structure, or a {@code long} constant, in\n+ * the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code LongEntry} is modeled by a {@code long}.  Conversions are\n+ * through {@link ConstantPoolBuilder#longEntry(long)} and {@link #longValue()}.\n+ * <p>\n+ * A long entry has a {@linkplain #width() width} of {@code 2}, making its\n+ * subsequent constant pool index valid and unusable.\n@@ -36,0 +41,3 @@\n+ * @see ConstantPoolBuilder#longEntry ConstantPoolBuilder::longEntry\n+ * @jvms 4.4.5 The {@code CONSTANT_Long_info} and {@code CONSTANT_Double_info}\n+ *             Structures\n@@ -43,1 +51,4 @@\n-     * {@return the long value}\n+     * {@return the {@code long} value}\n+     *\n+     * @see ConstantPoolBuilder#longEntry(long)\n+     *      ConstantPoolBuilder::longEntry(long)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LongEntry.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.lang.classfile.Opcode;\n+\n@@ -30,2 +32,18 @@\n- * Models a member reference constant in the constant pool of a classfile,\n- * which includes references to fields, methods, and interface methods.\n+ * Superinterface modeling symbolic references to a member of a class or interface\n+ * in the constant pool of a {@code class} file, which include references to\n+ * {@linkplain FieldRefEntry fields}, {@linkplain MethodRefEntry class methods},\n+ * and {@linkplain InterfaceMethodRefEntry interface methods}.\n+ * <p>\n+ * Different types of symbolic references to a member of a class or interface\n+ * bear structural similarities and share parts of the resolution processes, and\n+ * they can sometimes appear in the same locations.  For example, both {@link\n+ * MethodRefEntry} and {@link InterfaceMethodRefEntry} can appear in an {@link\n+ * Opcode#INVOKESTATIC invokestatic} instruction.\n+ * <p>\n+ * A member reference entry is composite:\n+ * {@snippet lang=text :\n+ * MemberRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n@@ -33,0 +51,3 @@\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -39,1 +60,1 @@\n-     * {@return the class in which this member ref lives}\n+     * {@return the class or interface which this member belongs to}\n@@ -44,1 +65,1 @@\n-     * {@return the name and type of the member}\n+     * {@return the name and descriptor string of the member}\n@@ -56,1 +77,8 @@\n-     * {@return the type of the member}\n+     * {@return the descriptor string of the member}  This is a field descriptor\n+     * string if this entry is a {@link FieldRefEntry}, or a method descriptor\n+     * string if this entry is a {@link MethodRefEntry} or {@link\n+     * InterfaceMethodRefEntry}.\n+     *\n+     * @apiNote\n+     * Each subinterface defines a {@code typeSymbol()} accessor for the\n+     * symbolic descriptor for the member type.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MemberRefEntry.java","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleInfo;\n@@ -33,3 +35,23 @@\n- * Models a {@code CONSTANT_MethodHandle_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.8 The CONSTANT_MethodHandle_info Structure\n+ * Models a {@code CONSTANT_MethodHandle_info} structure, or a symbolic\n+ * reference to a {@linkplain MethodHandle method handle}, in the constant pool\n+ * of a {@code class} file.  The method handle directly accesses an accessible\n+ * method, field, or constructor.\n+ * <p>\n+ * The use of a {@code MethodHandleEntry} is modeled by a {@link\n+ * DirectMethodHandleDesc}.  Conversions are through {@link\n+ * ConstantPoolBuilder#methodHandleEntry(DirectMethodHandleDesc)} and {@link\n+ * #asSymbol()}.\n+ * <p>\n+ * A method handle entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"MethodHandleEntry\" target=\"ConstantPoolBuilder#methodHandleEntry(int, MemberRefEntry)\" :\n+ * MethodHandleEntry(\n+ *     int refKind, \/\/ @link substring=\"refKind\" target=\"#kind()\"\n+ *     MemberRefEntry reference \/\/ @link substring=\"reference\" target=\"#reference()\"\n+ * )\n+ * }\n+ * where {@code refKind} is in the range {@code [1, 9]}.\n+ *\n+ * @see ConstantPoolBuilder#methodHandleEntry\n+ *      ConstantPoolBuilder::methodHandleEntry\n+ * @jvms 4.4.8 The {@code CONSTANT_MethodHandle_info} Structure\n@@ -43,0 +65,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -50,1 +77,2 @@\n-     * @see java.lang.invoke.MethodHandleInfo\n+     *\n+     * @see MethodHandleInfo##refkinds Reference kinds\n@@ -55,1 +83,2 @@\n-     * {@return the constant pool entry describing the method}\n+     * {@return the constant pool entry describing the field or method,\n+     * according to the {@linkplain #kind() reference kind}}\n@@ -61,0 +90,3 @@\n+     *\n+     * @see ConstantPoolBuilder#methodHandleEntry(DirectMethodHandleDesc)\n+     *      ConstantPoolBuilder::methodHandleEntry(DirectMethodHandleDesc)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodHandleEntry.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,13 @@\n- * Models a {@code CONSTANT_MethodRef_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures\n+ * Models a {@code CONSTANT_MethodRef_info} structure, or a symbolic reference\n+ * to a class method, in the constant pool of a {@code class} file.\n+ * <p>\n+ * A class method reference entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"MethodRefEntry\" target=\"ConstantPoolBuilder#methodRefEntry(ClassEntry, NameAndTypeEntry)\" :\n+ * MethodRefEntry(\n+ *     ClassEntry owner, \/\/ @link substring=\"owner\" target=\"#owner()\"\n+ *     NameAndTypeEntry nameAndType \/\/ @link substring=\"nameAndType\" target=\"#nameAndType()\"\n+ * )\n+ * }\n+ * where the type in the {@code NameAndTypeEntry} is a {@linkplain #typeSymbol()\n+ * method descriptor} string.\n@@ -37,0 +47,4 @@\n+ * @see ConstantPoolBuilder#methodRefEntry ConstantPoolBuilder::methodRefEntry\n+ * @jvms 4.4.2 The {@code CONSTANT_Fieldref_info}, {@code\n+ *             CONSTANT_Methodref_info}, and {@code\n+ *             CONSTANT_InterfaceMethodref_info} Structures\n@@ -43,1 +57,1 @@\n-     * {@return a symbolic descriptor for the method's type}\n+     * {@return a symbolic descriptor for the {@linkplain #type() method type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodRefEntry.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,14 @@\n- * Models a {@code CONSTANT_MethodType_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.9 The CONSTANT_MethodType_info Structure\n+ * Models a {@code CONSTANT_MethodType_info} structure, or a symbolic reference\n+ * to a method type, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code MethodTypeEntry} is modeled by a {@link MethodTypeDesc}.\n+ * Conversions are through {@link ConstantPoolBuilder#methodTypeEntry(MethodTypeDesc)}\n+ * and {@link #asSymbol()}.\n+ * <p>\n+ * A method type entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"MethodTypeEntry\" target=\"ConstantPoolBuilder#methodTypeEntry(Utf8Entry)\" :\n+ * MethodTypeEntry(Utf8Entry descriptor) \/\/ @link substring=\"descriptor\" target=\"#descriptor()\"\n+ * }\n+ * where {@code descriptor} is a {@linkplain #asSymbol() method descriptor}\n+ * string.\n@@ -37,0 +48,1 @@\n+ * @jvms 4.4.9 The {@code CONSTANT_MethodType_info} Structure\n@@ -43,0 +55,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     * <p>\n+     * This is equivalent to {@link #asSymbol() asSymbol()}.\n+     *\/\n@@ -49,1 +66,1 @@\n-     * {@return the constant pool entry describing the method type}\n+     * {@return the {@linkplain #asSymbol() method descriptor} string}\n@@ -54,1 +71,2 @@\n-     * {@return a symbolic descriptor for the method type}\n+     * {@return a symbolic descriptor for the {@linkplain #descriptor() method\n+     * type}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodTypeEntry.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,13 @@\n- * Models a {@code CONSTANT_Module_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.11 The CONSTANT_Module_info Structure\n+ * Models a {@code CONSTANT_Module_info} structure, denoting a module, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code ModuleEntry} is modeled by a {@link ModuleDesc}.\n+ * Conversions are through {@link ConstantPoolBuilder#moduleEntry(ModuleDesc)}\n+ * and {@link #asSymbol()}.\n+ * <p>\n+ * A module entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"ModuleEntry\" target=\"ConstantPoolBuilder#moduleEntry(Utf8Entry)\" :\n+ * ModuleEntry(Utf8Entry name) \/\/ @link substring=\"name\" target=\"#name()\"\n+ * }\n+ * where {@code name} is a {@linkplain #asSymbol() module name}.\n@@ -36,0 +46,1 @@\n+ * @jvms 4.4.11 The {@code CONSTANT_Module_info} Structure\n@@ -41,1 +52,1 @@\n-     * {@return the name of the module}\n+     * {@return the name of the {@linkplain #asSymbol() module}}\n@@ -46,1 +57,1 @@\n-     * {@return a symbolic descriptor for the module}\n+     * {@return a symbolic descriptor for the {@linkplain #name() module name}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ModuleEntry.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.TypeDescriptor;\n+\n@@ -30,3 +34,21 @@\n- * Models a {@code CONSTANT_NameAndType_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.6 The CONSTANT_NameAndType_info Structure\n+ * Models a {@code CONSTANT_NameAndType_info} structure, representing a field or\n+ * method, in the constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code NameAndTypeEntry} is symbolically represented as a\n+ * {@code String name}, and a {@link ConstantPoolBuilder#nameAndTypeEntry(String,\n+ * ClassDesc) ClassDesc} or a {@link ConstantPoolBuilder#nameAndTypeEntry(String,\n+ * MethodTypeDesc) MethodTypeDesc} {@code type}, depending on where this {@code\n+ * NameAndTypeEntry} appears.  The accessors to the symbolic descriptors for the\n+ * {@code type} is defined on a per-use-site basis, such as {@link\n+ * FieldRefEntry#typeSymbol()} returning a {@code ClassDesc}, and {@link\n+ * MethodRefEntry#typeSymbol()} returning a {@code MethodTypeDesc}.\n+ * <p>\n+ * A name and type entry is composite:\n+ * {@snippet lang=text :\n+ * NameAndTypeEntry( \/\/ @link substring=\"NameAndTypeEntry\" target=\"ConstantPoolBuilder#nameAndTypeEntry(Utf8Entry, Utf8Entry)\"\n+ *     Utf8Entry name, \/\/ @link substring=\"name\" target=\"#name()\"\n+ *     Utf8Entry type  \/\/ @link substring=\"type\" target=\"#type()\"\n+ * )\n+ * }\n+ * where {@code name} is an unqualified name, and {@code type} is a field or\n+ * method descriptor string.\n@@ -34,0 +56,1 @@\n+ * @jvms 4.4.6 The {@code CONSTANT_NameAndType_info} Structure\n@@ -45,1 +68,4 @@\n-     * {@return the field or method descriptor}\n+     * {@return the field or method {@linkplain TypeDescriptor descriptor}\n+     * string}  It is a method descriptor strings if it starts with {@code (}.\n+     * Otherwise, it is a field descriptor string, and must start with one of\n+     * the {@code BCDFIJSZL[} characters.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/NameAndTypeEntry.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,15 @@\n- * Models a {@code CONSTANT_Package_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.12 The CONSTANT_Package_info Structure\n+ * Models a {@code CONSTANT_Package_info}, representing a package, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code PackageEntry} is represented by a {@link PackageDesc}\n+ * that does not represent the unnamed package.  Conversions are through\n+ * {@link ConstantPoolBuilder#packageEntry(PackageDesc)} and\n+ * {@link #asSymbol()}.\n+ * <p>\n+ * A package entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"PackageEntry\" target=\"ConstantPoolBuilder#packageEntry(Utf8Entry)\" :\n+ * PackageEntry(Utf8Entry name) \/\/ @link substring=\"name\" target=\"#name()\"\n+ * }\n+ * where {@code name} is the {@linkplain ClassEntry##internalname internal form}\n+ * of a binary package name and is not empty.\n@@ -36,0 +48,1 @@\n+ * @jvms 4.4.12 The {@code CONSTANT_Package_info} Structure\n@@ -41,1 +54,2 @@\n-     * {@return the package name}\n+     * {@return the {@linkplain ClassEntry##internalname internal form} of the\n+     * {@linkplain #asSymbol() package} name}\n@@ -46,1 +60,1 @@\n-     * {@return a symbolic descriptor for the package name}\n+     * {@return a symbolic descriptor for the {@linkplain #name() package name}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PackageEntry.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,5 @@\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.ClassFileBuilder;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+\n@@ -28,1 +33,14 @@\n- * Models an entry in the constant pool of a classfile.\n+ * Models an entry in the constant pool of a {@code class} file.  Entries are\n+ * read from {@code class} files, and can be created with a {@link\n+ * ConstantPoolBuilder} to write to {@code class} files.\n+ *\n+ * @implNote\n+ * <h2 id=\"unbound\">Unbound Constant Pool Entries<\/h2>\n+ * Implementations may create unbound constant pool entries not belonging to\n+ * an actual constant pool.  They conveniently represent constant pool entries\n+ * referred by unbound {@linkplain Attribute attributes} not read from a {@code\n+ * class} file.  Their {@link #index() index()} return a non-positive invalid\n+ * value, and behaviors of their {@link #constantPool() constantPool()} are\n+ * unspecified.  They are considered alien to any {@linkplain\n+ * ClassFileBuilder#constantPool() contextual constant pool} and will be\n+ * converted when they are written to {@code class} files.\n@@ -30,0 +48,1 @@\n+ * @see ConstantPoolBuilder##alien Alien Constant Pool Entries\n@@ -91,0 +110,8 @@\n+     *\n+     * @apiNote\n+     * Given a {@link ConstantPoolBuilder} {@code builder} and a {@code\n+     * PoolEntry entry}, use {@link ConstantPoolBuilder#canWriteDirect\n+     * builder.canWriteDirect(entry.constantPool())} instead of object equality\n+     * of the constant pool to determine if an entry belongs to the builder.\n+     *\n+     * @see ##unbound Unbound Constant Pool Entries\n@@ -105,0 +132,4 @@\n+     * A valid index is always positive; if the index is non-positive, this\n+     * entry is {@linkplain ##unbound unbound}.\n+     *\n+     * @see ##unbound Unbound Constant Pool Entries\n@@ -110,0 +141,17 @@\n+     * <p>\n+     * All pool entries except {@link LongEntry CONSTANT_Long} and {@link\n+     * DoubleEntry CONSTANT_Double} have width {@code 1}. These two exceptions\n+     * have width {@code 2}, and their subsequent indices at {@link #index()\n+     * index() + 1} are considered unusable.\n+     *\n+     * @apiNote\n+     * If this entry is {@linkplain LoadableConstantEntry loadable}, the width\n+     * of this entry does not decide if this entry should be loaded with {@link\n+     * Opcode#LDC ldc} or {@link Opcode#LDC2_W ldc2_w}.  For example, {@link\n+     * ConstantDynamicEntry} always has width {@code 1}, but it must be loaded\n+     * with {@code ldc2_w} if its {@linkplain ConstantDynamicEntry#typeKind()\n+     * type} is {@link TypeKind#LONG long} or {@link TypeKind#DOUBLE double}.\n+     * Use {@link LoadableConstantEntry#typeKind() typeKind().slotSize()} to\n+     * determine the loading instruction instead.\n+     *\n+     * @see ConstantPool##index Index in the Constant Pool\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PoolEntry.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,12 @@\n- * Models a {@code CONSTANT_String_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.3 The CONSTANT_String_info Structure\n+ * Models a {@code CONSTANT_String_info} structure, or a string constant, in the\n+ * constant pool of a {@code class} file.\n+ * <p>\n+ * The use of a {@code StringEntry} is represented by a {@link String}.\n+ * Conversions are through {@link ConstantPoolBuilder#stringEntry(String)} and\n+ * {@link #stringValue()}.\n+ * <p>\n+ * A string entry is composite:\n+ * {@snippet lang=text :\n+ * \/\/ @link substring=\"StringEntry\" target=\"ConstantPoolBuilder#stringEntry(Utf8Entry)\" :\n+ * StringEntry(Utf8Entry utf8) \/\/ @link substring=\"utf8\" target=\"#utf8()\"\n+ * }\n@@ -34,0 +43,1 @@\n+ * @jvms 4.4.3 The {@code CONSTANT_String_info} Structure\n@@ -41,0 +51,2 @@\n+     *\n+     * @see ConstantPoolBuilder#stringEntry(Utf8Entry)\n@@ -46,0 +58,2 @@\n+     *\n+     * @see ConstantPoolBuilder#stringEntry(String)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/StringEntry.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,7 @@\n+import java.io.DataInput;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.MethodModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.TypeDescriptor;\n+\n@@ -30,3 +37,21 @@\n- * Models a {@code CONSTANT_UTF8_info} constant in the constant pool of a\n- * classfile.\n- * @jvms 4.4.7 The CONSTANT_Utf8_info Structure\n+ * Models a {@code CONSTANT_UTF8_info} constant, representing strings, in the\n+ * constant pool of a {@code class} file.  This describes strings in the\n+ * {@linkplain DataInput##modified-utf-8 Modified UTF-8} format.\n+ * <p>\n+ * The use of a {@code Utf8Entry} is represented by a {@link String}.\n+ * Conversions are through {@link ConstantPoolBuilder#utf8Entry(String)} and\n+ * {@link #stringValue()}.\n+ * <p>\n+ * Some uses of {@code Utf8Entry} represent field or method {@linkplain\n+ * TypeDescriptor#descriptorString() descriptor strings}, symbolically\n+ * represented as {@link ClassDesc} or {@link MethodTypeDesc}, depending on\n+ * where a {@code Utf8Entry} appear.  Entries representing such uses are created\n+ * with {@link ConstantPoolBuilder#utf8Entry(ClassDesc)} and {@link\n+ * ConstantPoolBuilder#utf8Entry(MethodTypeDesc)}, and they can be converted to\n+ * symbolic descriptors on a per-use-site basis, such as in {@link\n+ * AnnotationValue.OfClass#classSymbol()} and {@link MethodModel#methodTypeSymbol()}.\n+ * <p>\n+ * Unlike most constant pool entries, a UTF-8 entry is of flexible length: it is\n+ * represented as an array structure, with an {@code u2} for the data length in\n+ * bytes, followed by that number of bytes of Modified UTF-8 data.  It can\n+ * represent at most 65535 bytes of data due to the physical restrictions.\n@@ -34,0 +59,2 @@\n+ * @jvms 4.4.7 The {@code CONSTANT_Utf8_info} Structure\n+ * @see DataInput##modified-utf-8 Modified UTF-8\n@@ -42,0 +69,9 @@\n+     *\n+     * @apiNote\n+     * A {@code Utf8Entry} can be used directly as a {@link CharSequence} if\n+     * {@code String} functionalities are not strictly desired.  If only string\n+     * equivalence is desired, {@link #equalsString(String) equalsString} should\n+     * be used.  Reduction of string processing can significantly improve {@code\n+     * class} file reading performance.\n+     *\n+     * @see ConstantPoolBuilder#utf8Entry(String)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * <h2>Provides interfaces describing classfile constant pool entries for the {@link java.lang.classfile} library.<\/h2>\n+ * <h2>Provides interfaces describing constant pool entries for the {@link java.lang.classfile} library.<\/h2>\n@@ -29,1 +29,7 @@\n- * The {@code java.lang.classfile.constantpool} package contains interfaces describing classfile constant pool entries.\n+ * The {@code java.lang.classfile.constantpool} package contains interfaces describing constant pool entries in the\n+ * {@code class} file format.  Constant pool entries are low-level models to faithfully represent the exact structure\n+ * of a {@code class} file.\n+ * <p>\n+ * Unless otherwise specified, passing {@code null} or an array or collection containing a {@code null} element as an\n+ * argument to a constructor or method of any Class-File API class or interface will cause a {@link NullPointerException}\n+ * to be thrown.\n@@ -31,0 +37,38 @@\n+ * <h2 id=\"reading\">Reading the constant pool entries<\/h2>\n+ * When read from {@code class} files, the pool entries are lazily inflated; the contents of these entries, besides the\n+ * bare structure, are not evaluated to speed up parsing.  Entries to users interest, usually accessed from other models\n+ * and elements, have their contents read on demand.  For example, to search for methods, a user should filter first by\n+ * access flags and then by method name, and use {@link Utf8Entry#equalsString(String)} instead of checking equality\n+ * against {@link Utf8Entry#stringValue()}.  This avoids inflation of UTF-8 entries as much as possible:\n+ * {@snippet lang=\"java\" class=\"PackageSnippets\" region=\"isStaticWorkMethod\"}\n+ * <p>\n+ * The entries also define accessors to validated symbolic information with nominal descriptor abstractions from the\n+ * {@link java.lang.constant} package.  These symbolic information accessors perform validation against the read\n+ * {@code class} files, and throw {@link IllegalArgumentException} when the accessed constant pool entry contains\n+ * invalid data.  The nominal descriptors represent validated data, which saves users from extra validations in future\n+ * processing.\n+ * <p>\n+ * Due to the lazy nature of {@code class} file parsing, {@link IllegalArgumentException} indicating malformed\n+ * {@code class} file data can be thrown at any method invocation.  For example, an exception may come from a {@link\n+ * ClassEntry} when it is first read from the constant pool (referring to an invalid index or wrong type of entry), when\n+ * its referred UTF-8 entry is expanded (malformed UTF-8 data), or when its symbolic information is accessed (the string\n+ * is not valid for a class entry).\n+ *\n+ * <h2 id=\"writing\">Writing the constant pool entries<\/h2>\n+ * In general, users do not need to worry about working with the constant pool and its entries when writing {@code\n+ * class} files.  Most Class-File API models and elements have two sets of factory methods: one that accepts symbolic\n+ * information representing the uses, and another that accepts constant pool entries.  The constant pool builder\n+ * associated with {@code class} file builders, {@link ClassFileBuilder#constantPool}, automatically creates or reuses\n+ * pool entries from the symbolic information.  Validated data in symbolic information helps {@code class} file\n+ * generation by avoiding extraneous parsing of raw constant pool entry data.\n+ * <p>\n+ * As always, users can use factories that accept constant pool entries if they already have them by hand, or if they\n+ * desire fine-grained control over {@code class} file generation.\n+ * <p>\n+ * If many models and elements are reused from another {@link ClassModel} in class building, the class building process\n+ * can use a constant pool builder that extends from the given {@code ClassModel}, available through {@link\n+ * ConstantPoolBuilder#of(ClassModel) ConstantPoolBuilder::of(ClassModel)}, so that byte data with constant pool\n+ * references can be copied in batch, speeding up class building.  This is especially applicable to class transformations,\n+ * and {@link ClassFile.ConstantPoolSharingOption ConstantPoolSharingOption} exists to control this behavior.\n+ *\n+ * @jvms 4.4 The Constant Pool\n@@ -35,0 +79,4 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileBuilder;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/package-info.java","additions":51,"deletions":3,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.classfile.constantpool.snippet;\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+\n+class PackageSnippets {\n+\n+    \/\/ @start region=isStaticWorkMethod\n+    boolean isStaticWorkMethod(MethodModel method) {\n+        \/\/ check static flag first to avoid unnecessary evaluation of UTF-8 entry\n+        return (method.flags().flagsMask() & ClassFile.ACC_STATIC) != 0\n+                \/\/ use equalsString to avoid full conversion to String for comparison\n+                \/\/ the Utf8Entry can also act as a basic CharSequence without full conversion\n+                \/\/ @link substring=\"methodName\" target=\"MethodModel#methodName\" :\n+                && method.methodName().equalsString(\"work\"); \/\/ @link substring=\"equalsString\" target=\"Utf8Entry#equalsString\"\n+    }\n+    \/\/ @end\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/snippet-files\/PackageSnippets.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -58,1 +58,1 @@\n- * cob.labelBinding(lt.label()); \/\/ @link substring=\"label\" target=\"#label\"\n+ * cob.labelBinding(lt.label()); \/\/ @link regex=\"label(?=\\()\" target=\"#label\"\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LabelTarget.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-                    sun.net.www.MimeTable.loadTable();\n+                    sun.net.www.MimeTable.getDefaultTable();\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.loader.ClassLoaders;\n@@ -115,5 +116,3 @@\n-                        Class<?> c = Class\n-                            .forName(cn, true, ClassLoader.getSystemClassLoader());\n-                        Constructor<?> ctor = c\n-                            .getDeclaredConstructor(FileSystemProvider.class);\n-                        provider = (FileSystemProvider)ctor.newInstance(provider);\n+                        Class<?> c = Class.forName(cn, true, ClassLoaders.appClassLoader());\n+                        Constructor<?> ctor = c.getDeclaredConstructor(FileSystemProvider.class);\n+                        provider = (FileSystemProvider) ctor.newInstance(provider);\n@@ -149,7 +148,11 @@\n-     * is defined then it is taken to be a list of one or more fully-qualified\n-     * names of concrete provider classes identified by the URI scheme\n-     * {@code \"file\"}. Where the property is a list of more than one name then\n-     * the names are separated by a comma. Each class is loaded, using the system\n-     * class loader, and instantiated by invoking a one argument constructor\n-     * whose formal parameter type is {@code FileSystemProvider}. The providers\n-     * are loaded and instantiated in the order they are listed in the property.\n+     * is defined then it is taken to be a list of one or more fully-qualified names\n+     * of concrete provider classes identified by the URI scheme {@code \"file\"}.\n+     * If the property is a list of more than one name then the names are separated\n+     * by a comma character. Each provider class is a {@code public} class with a\n+     * {@code public} constructor that has one formal parameter of type {@code\n+     * FileSystemProvider}. If the provider class is in a named module then the module\n+     * exports the package containing the provider class to at least {@code java.base}.\n+     * Each provider class is loaded, using the\n+     * {@linkplain ClassLoader#getSystemClassLoader() default system class loader},\n+     * and instantiated by invoking the constructor. The providers are loaded and\n+     * instantiated in the order they are listed in the property.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/FileSystems.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -427,2 +427,8 @@\n-            return SECONDS_CACHE.computeIfAbsent(totalSeconds, totalSecs -> {\n-                ZoneOffset result = new ZoneOffset(totalSecs);\n+            Integer totalSecs = totalSeconds;\n+            ZoneOffset result = SECONDS_CACHE.get(totalSecs);\n+            if (result == null) {\n+                result = new ZoneOffset(totalSeconds);\n+                var existing = SECONDS_CACHE.putIfAbsent(totalSecs, result);\n+                if (existing != null) {\n+                    result = existing;\n+                }\n@@ -430,2 +436,2 @@\n-                return result;\n-            });\n+            }\n+            return result;\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZoneOffset.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1100,8 +1100,8 @@\n-     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n-     * expects an offset-based zone and will not match region-based zones.\n-     * The offset ID, such as '+02:30', may be at the start of the parse,\n-     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n-     * equivalent to using {@link #appendOffset(String, String)} using the\n-     * arguments 'HH:MM:ss' and the no offset string '0'.\n-     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n-     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.\n+     * If the parse starts with '+' or '-', then the parser expects an\n+     * offset-based zone and will not match region-based zones. The offset\n+     * ID parsing is equivalent to using {@link #appendOffset(String, String)}\n+     * using the arguments 'HH:MM:ss' and the no offset string '0'.\n+     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser can\n+     * match a following offset, then a region-based zone with the parsed\n+     * offset will be returned, or else if the parser cannot match a following\n+     * offset, then {@link ZoneOffset#UTC} is selected.\n@@ -1121,3 +1121,3 @@\n-     *   \"UT+01:30\"                -- ZoneOffset.of(\"+01:30\")\n-     *   \"UTC+01:30\"               -- ZoneOffset.of(\"+01:30\")\n-     *   \"GMT+01:30\"               -- ZoneOffset.of(\"+01:30\")\n+     *   \"UT+01:30\"                -- ZoneId.of(\"UT+01:30\")\n+     *   \"UTC+01:30\"               -- ZoneId.of(\"UTC+01:30\")\n+     *   \"GMT+01:30\"               -- ZoneId.of(\"GMT+01:30\")\n@@ -1138,2 +1138,1 @@\n-     * This appends an instruction to format\/parse the zone ID to the builder\n-     * only if it is a region-based ID.\n+     * This appends an instruction to format only region-based zone IDs to the builder.\n@@ -1151,8 +1150,8 @@\n-     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n-     * expects an offset-based zone and will not match region-based zones.\n-     * The offset ID, such as '+02:30', may be at the start of the parse,\n-     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n-     * equivalent to using {@link #appendOffset(String, String)} using the\n-     * arguments 'HH:MM:ss' and the no offset string '0'.\n-     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n-     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.\n+     * If the parse starts with '+' or '-', then the parser expects an\n+     * offset-based zone and will not match region-based zones. The offset\n+     * ID parsing is equivalent to using {@link #appendOffset(String, String)}\n+     * using the arguments 'HH:MM:ss' and the no offset string '0'.\n+     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser can\n+     * match a following offset, then a region-based zone with the parsed\n+     * offset will be returned, or else if the parser cannot match a following\n+     * offset, then {@link ZoneOffset#UTC} is selected.\n@@ -1172,3 +1171,3 @@\n-     *   \"UT+01:30\"                -- ZoneOffset.of(\"+01:30\")\n-     *   \"UTC+01:30\"               -- ZoneOffset.of(\"+01:30\")\n-     *   \"GMT+01:30\"               -- ZoneOffset.of(\"+01:30\")\n+     *   \"UT+01:30\"                -- ZoneId.of(\"UT+01:30\")\n+     *   \"UTC+01:30\"               -- ZoneId.of(\"UTC+01:30\")\n+     *   \"GMT+01:30\"               -- ZoneId.of(\"GMT+01:30\")\n@@ -1209,8 +1208,8 @@\n-     * If the parse starts with '+', '-', 'UT', 'UTC' or 'GMT', then the parser\n-     * expects an offset-based zone and will not match region-based zones.\n-     * The offset ID, such as '+02:30', may be at the start of the parse,\n-     * or prefixed by  'UT', 'UTC' or 'GMT'. The offset ID parsing is\n-     * equivalent to using {@link #appendOffset(String, String)} using the\n-     * arguments 'HH:MM:ss' and the no offset string '0'.\n-     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser cannot\n-     * match a following offset ID, then {@link ZoneOffset#UTC} is selected.\n+     * If the parse starts with '+' or '-', then the parser expects an\n+     * offset-based zone and will not match region-based zones. The offset\n+     * ID parsing is equivalent to using {@link #appendOffset(String, String)}\n+     * using the arguments 'HH:MM:ss' and the no offset string '0'.\n+     * If the parse starts with 'UT', 'UTC' or 'GMT', and the parser can\n+     * match a following offset, then a region-based zone with the parsed\n+     * offset will be returned, or else if the parser cannot match a following\n+     * offset, then {@link ZoneOffset#UTC} is selected.\n@@ -1230,3 +1229,3 @@\n-     *   \"UT+01:30\"                -- ZoneOffset.of(\"UT+01:30\")\n-     *   \"UTC+01:30\"               -- ZoneOffset.of(\"UTC+01:30\")\n-     *   \"GMT+01:30\"               -- ZoneOffset.of(\"GMT+01:30\")\n+     *   \"UT+01:30\"                -- ZoneId.of(\"UT+01:30\")\n+     *   \"UTC+01:30\"               -- ZoneId.of(\"UTC+01:30\")\n+     *   \"GMT+01:30\"               -- ZoneId.of(\"GMT+01:30\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,9 @@\n-        return CACHE.computeIfAbsent(key, e -> createStore(e.getKey(), e.getValue()));\n+        Object store = CACHE.get(key);\n+        if (store == null) {\n+            store = createStore(field, locale);\n+            var existing = CACHE.putIfAbsent(key, store);\n+            if (existing != null) {\n+                store = existing;\n+            }\n+        }\n+        return store;\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeTextProvider.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,9 @@\n-        return CACHE.computeIfAbsent(locale, DecimalStyle::create);\n+        DecimalStyle info = CACHE.get(locale);\n+        if (info == null) {\n+            info = create(locale);\n+            var existing = CACHE.putIfAbsent(locale, info);\n+            if (existing != null) {\n+                info = existing;\n+            }\n+        }\n+        return info;\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DecimalStyle.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,3 +148,1 @@\n-        Runnable action = cleanup != null ?\n-                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address(), newSize)) :\n-                null;\n+        Runnable action = cleanupAction(address(), newSize, cleanup);\n@@ -154,0 +152,7 @@\n+    \/\/ Using a static helper method ensures there is no unintended lambda capturing of `this`\n+    private static Runnable cleanupAction(long address, long newSize, Consumer<MemorySegment> cleanup) {\n+        return cleanup != null ?\n+                () -> cleanup.accept(SegmentFactories.makeNativeSegmentUnchecked(address, newSize)) :\n+                null;\n+    }\n+\n@@ -489,3 +494,12 @@\n-        return \"MemorySegment{ \" +\n-                heapBase().map(hb -> \"heapBase: \" + hb + \", \").orElse(\"\") +\n-                \"address: \" + Utils.toHexString(address()) +\n+        final String kind;\n+        if (this instanceof HeapMemorySegmentImpl) {\n+            kind = \"heap\";\n+        } else if (this instanceof MappedMemorySegmentImpl) {\n+            kind = \"mapped\";\n+        } else {\n+            kind = \"native\";\n+        }\n+        return \"MemorySegment{ kind: \" +\n+                kind +\n+                heapBase().map(hb -> \", heapBase: \" + hb).orElse(\"\") +\n+                \", address: \" + Utils.toHexString(address()) +\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n@@ -31,1 +33,0 @@\n-import java.nio.file.Paths;\n@@ -50,2 +51,17 @@\n-    private static final Path BOOT_MODULES_JIMAGE =\n-        Paths.get(JAVA_HOME, \"lib\", \"modules\");\n+    private static final Path BOOT_MODULES_JIMAGE;\n+\n+    static {\n+        FileSystem fs;\n+        if (ImageReaderFactory.class.getClassLoader() == null) {\n+            try {\n+                fs = (FileSystem) Class.forName(\"sun.nio.fs.DefaultFileSystemProvider\")\n+                        .getMethod(\"theFileSystem\")\n+                        .invoke(null);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        } else {\n+            fs = FileSystems.getDefault();\n+        }\n+        BOOT_MODULES_JIMAGE = fs.getPath(JAVA_HOME, \"lib\", \"modules\");\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageReaderFactory.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,8 +199,0 @@\n-    exports jdk.internal.org.objectweb.asm to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.tree to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.util to\n-        jdk.jfr;\n-    exports jdk.internal.org.objectweb.asm.commons to\n-        jdk.jfr;\n@@ -228,1 +220,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.graal.compiler;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.util.StaticProperty;\n-\n@@ -33,1 +31,0 @@\n-import java.io.FileOutputStream;\n@@ -43,1 +40,2 @@\n-public class MimeTable implements FileNameMap {\n+public final class MimeTable implements FileNameMap {\n+\n@@ -47,3 +45,0 @@\n-    \/** Keyed by content type, returns MimeEntries *\/\n-    private final Hashtable<String, MimeEntry> entries = new Hashtable<>();\n-\n@@ -53,7 +48,1 @@\n-    \/\/ Will be reset if in the platform-specific data file\n-    private static String tempFileTemplate =\n-            System.getProperty(\"content.types.temp.file.template\", \"\/tmp\/%s\");\n-\n-    private static final String filePreamble = \"sun.net.www MIME content-types table\";\n-\n-    MimeTable() {\n+    private MimeTable() {\n@@ -63,2 +52,2 @@\n-    private static class DefaultInstanceHolder {\n-        static final MimeTable defaultInstance = getDefaultInstance();\n+    private static final class DefaultInstanceHolder {\n+        private static final MimeTable defaultInstance = getDefaultInstance();\n@@ -66,1 +55,1 @@\n-        static MimeTable getDefaultInstance() {\n+        private static MimeTable getDefaultInstance() {\n@@ -81,9 +70,0 @@\n-    public static FileNameMap loadTable() {\n-        MimeTable mt = getDefaultTable();\n-        return mt;\n-    }\n-\n-    public synchronized int getSize() {\n-        return entries.size();\n-    }\n-\n@@ -99,4 +79,2 @@\n-    public synchronized void add(MimeEntry m) {\n-        entries.put(m.getType(), m);\n-\n-        String exts[] = m.getExtensions();\n+    private void add(MimeEntry m) {\n+        String[] exts = m.getExtensions();\n@@ -107,2 +85,2 @@\n-        for (int i = 0; i < exts.length; i++) {\n-            extensionMap.put(exts[i], m);\n+        for (String ext : exts) {\n+            extensionMap.put(ext, m);\n@@ -112,32 +90,0 @@\n-    public synchronized MimeEntry remove(String type) {\n-        MimeEntry entry = entries.get(type);\n-        return remove(entry);\n-    }\n-\n-    public synchronized MimeEntry remove(MimeEntry entry) {\n-        String[] extensionKeys = entry.getExtensions();\n-        if (extensionKeys != null) {\n-            for (int i = 0; i < extensionKeys.length; i++) {\n-                extensionMap.remove(extensionKeys[i]);\n-            }\n-        }\n-\n-        return entries.remove(entry.getType());\n-    }\n-\n-    public synchronized MimeEntry find(String type) {\n-        MimeEntry entry = entries.get(type);\n-        if (entry == null) {\n-            \/\/ try a wildcard lookup\n-            Enumeration<MimeEntry> e = entries.elements();\n-            while (e.hasMoreElements()) {\n-                MimeEntry wild = e.nextElement();\n-                if (wild.matches(type)) {\n-                    return wild;\n-                }\n-            }\n-        }\n-\n-        return entry;\n-    }\n-\n@@ -147,1 +93,1 @@\n-    private MimeEntry findViaFileExtension(String fname) {\n+    private MimeEntry findByFileExtension(String fname) {\n@@ -158,1 +104,2 @@\n-        return findByExt(ext);\n+        return extensionMap.get(ext);\n+\n@@ -169,2 +116,1 @@\n-    public MimeEntry findByFileName(String fname) {\n-        MimeEntry entry = null;\n+    private MimeEntry findByFileName(String fname) {\n@@ -176,1 +122,1 @@\n-            entry = findViaFileExtension(fname.substring(0, hashIndex));\n+            MimeEntry entry = findByFileExtension(fname.substring(0, hashIndex));\n@@ -182,2 +128,0 @@\n-        assert entry == null;\n-\n@@ -186,27 +130,1 @@\n-        if (entry == null) {\n-            entry = findViaFileExtension(fname);\n-        }\n-\n-        return entry;\n-    }\n-\n-    \/**\n-     * Locate a MimeEntry by the file extension that has been associated\n-     * with it.\n-     *\/\n-    public synchronized MimeEntry findByExt(String fileExtension) {\n-        return extensionMap.get(fileExtension);\n-    }\n-\n-    public synchronized MimeEntry findByDescription(String description) {\n-        Enumeration<MimeEntry> e = elements();\n-        while (e.hasMoreElements()) {\n-            MimeEntry entry = e.nextElement();\n-            if (description.equals(entry.getDescription())) {\n-                return entry;\n-            }\n-        }\n-\n-        \/\/ We failed, now try treating description as type\n-        return find(description);\n-    }\n+        return findByFileExtension(fname);\n@@ -214,2 +132,0 @@\n-    String getTempFileTemplate() {\n-        return tempFileTemplate;\n@@ -218,17 +134,1 @@\n-    public synchronized Enumeration<MimeEntry> elements() {\n-        return entries.elements();\n-    }\n-\n-    \/\/ For backward compatibility -- mailcap format files\n-    \/\/ This is not currently used, but may in the future when we add ability\n-    \/\/ to read BOTH the properties format and the mailcap format.\n-    protected static String[] mailcapLocations =\n-            new String[]{\n-                    System.getProperty(\"user.mailcap\"),\n-                    StaticProperty.userHome() + \"\/.mailcap\",\n-                    \"\/etc\/mailcap\",\n-                    \"\/usr\/etc\/mailcap\",\n-                    \"\/usr\/local\/etc\/mailcap\"\n-            };\n-\n-    public synchronized void load() {\n+    private synchronized void load() {\n@@ -236,1 +136,1 @@\n-        File file = null;\n+        File file;\n@@ -263,1 +163,1 @@\n-    void parse(Properties entries) {\n+    private void parse(Properties entries) {\n@@ -268,1 +168,0 @@\n-            MimeTable.tempFileTemplate = tempFileTemplate;\n@@ -307,1 +206,1 @@\n-    void parse(String type, String attrs) {\n+    private void parse(String type, String attrs) {\n@@ -320,1 +219,1 @@\n-    void parse(String pair, MimeEntry entry) {\n+    private static void parse(String pair, MimeEntry entry) {\n@@ -340,1 +239,1 @@\n-    void fill(MimeEntry entry, String name, String value) {\n+    private static void fill(MimeEntry entry, String name, String value) {\n@@ -360,1 +259,1 @@\n-    int getActionCode(String action) {\n+    private static int getActionCode(String action) {\n@@ -370,57 +269,0 @@\n-    public Properties getAsProperties() {\n-        Properties properties = new Properties();\n-        Enumeration<MimeEntry> e = elements();\n-        while (e.hasMoreElements()) {\n-            MimeEntry entry = e.nextElement();\n-            properties.put(entry.getType(), entry.toProperty());\n-        }\n-\n-        return properties;\n-    }\n-\n-    protected boolean saveAsProperties(File file) {\n-        try (FileOutputStream os = new FileOutputStream(file)) {\n-            Properties properties = getAsProperties();\n-            properties.put(\"temp.file.template\", tempFileTemplate);\n-            String tag;\n-            String user = StaticProperty.userName();\n-            if (user != null) {\n-                tag = \"; customized for \" + user;\n-                properties.store(os, filePreamble + tag);\n-            }\n-            else {\n-                properties.store(os, filePreamble);\n-            }\n-        }\n-        catch (IOException e) {\n-            e.printStackTrace();\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-    \/*\n-     * Debugging utilities\n-     *\n-    public void list(PrintStream out) {\n-        Enumeration keys = entries.keys();\n-        while (keys.hasMoreElements()) {\n-            String key = (String)keys.nextElement();\n-            MimeEntry entry = (MimeEntry)entries.get(key);\n-            out.println(key + \": \" + entry);\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        MimeTable testTable = MimeTable.getDefaultTable();\n-\n-        Enumeration e = testTable.elements();\n-        while (e.hasMoreElements()) {\n-            MimeEntry entry = (MimeEntry)e.nextElement();\n-            System.out.println(entry);\n-        }\n-\n-        testTable.save(File.separator + \"tmp\" +\n-                       File.separator + \"mime_table.save\");\n-    }\n-    *\/\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MimeTable.java","additions":23,"deletions":181,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-            Thread t = new Thread(r);\n+            Thread t = InnocuousThread.newThread(r);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ThreadPool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.file.*;\n@@ -30,0 +29,1 @@\n+import java.nio.file.*;\n@@ -31,0 +31,1 @@\n+import jdk.internal.misc.InnocuousThread;\n@@ -56,5 +57,1 @@\n-        Thread thr = new Thread(null,\n-                                this,\n-                                \"FileSystemWatchService\",\n-                                0,\n-                                false);\n+        Thread thr = InnocuousThread.newThread(\"FileSystemWatchService\", this);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/AbstractPoller.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -30,0 +29,2 @@\n+import jdk.internal.misc.InnocuousThread;\n+import jdk.internal.misc.Unsafe;\n@@ -34,2 +35,2 @@\n- * task is executed by invoking the {@link runInterruptibly} method defined\n- * here and cancelled by invoking Thread.interrupt.\n+ * task is executed by invoking the {@linkplain #runInterruptibly} method\n+ * defined here and cancelled by invoking Thread.interrupt.\n@@ -120,1 +121,1 @@\n-        Thread t = new Thread(null, task, \"NIO-Task\", 0, false);\n+        Thread t = InnocuousThread.newThread(\"CancellableOp\", task);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/Cancellable.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.internal.misc.InnocuousThread;\n@@ -76,1 +77,1 @@\n-                     Thread t = new Thread(null, r, \"FileSystemWatcher\", 0, false);\n+                     Thread t = InnocuousThread.newThread(\"FileSystemWatcher\", r);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/PollingWatchService.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,9 @@\n+\/**\n+ * An enum of the defined TLS handshake message types.\n+ * <p>\n+ * These are defined in the IANA TLS Parameters.\n+ * https:\/\/www.iana.org\/assignments\/tls-parameters\/tls-parameters.xhtml#tls-parameters-7\n+ * <p>\n+ * Most of these come from the SLS\/TLS specs in RFCs 6601\/2246\/4346\/8446 and\n+ * friends.  Others are called out where defined.\n+ *\/\n@@ -84,0 +93,4 @@\n+    \/\/ Even though there is a TLS HandshakeType entry for\n+    \/\/ hello_retry_request_RESERVED (0x06), the TLSv1.3 (RFC 8446)\n+    \/\/ HelloRetryRequest is actually a ServerHello with a specific Random value\n+    \/\/ (Section 4.1.3).\n@@ -133,0 +146,1 @@\n+\n@@ -150,0 +164,4 @@\n+    \/\/ RFC 9147 - DTLS 1.3\n+    REQUEST_CONNECTION_ID       ((byte)0x09, \"request_connection_id\"),\n+    NEW_CONNECTION_ID           ((byte)0x0a, \"new_connection_id\"),\n+\n@@ -288,0 +306,3 @@\n+    \/\/ RFC 9261 - Exported Authenticators\n+    CLIENT_CERTIFICATE_REQUEST  ((byte)0x11, \"client_certificate_request\"),\n+\n@@ -350,0 +371,7 @@\n+\n+    \/\/ RFC 8879 - TLS Certificate Compression\n+    COMPRESSED_CERTIFICATE      ((byte)0x19, \"compressed_certificate\"),\n+\n+    \/\/ RFC 8870 - Encrypted Key Transport for DTLS\/Secure RTP\n+    EKT_KEY                     ((byte)0x1A, \"ekt_key\"),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLHandshake.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,413 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# So much for footnotes about Saudi Arabia.\n-# Apparent noon times below are for Riyadh; your mileage will vary.\n-# Times were computed using formulas in the U.S. Naval Observatory's\n-# Almanac for Computers 1987; the formulas \"will give EqT to an accuracy of\n-# [plus or minus two] seconds during the current year.\"\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol87\t1987\tonly\t-\tJan\t1\t12:03:20s -0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t2\t12:03:50s -0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t3\t12:04:15s -0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t4\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t5\t12:05:10s -0:05:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t6\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t7\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t8\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t9\t12:06:55s -0:06:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t10\t12:07:20s -0:07:20 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t11\t12:07:45s -0:07:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t12\t12:08:10s -0:08:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t13\t12:08:30s -0:08:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t14\t12:08:55s -0:08:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t15\t12:09:15s -0:09:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t16\t12:09:35s -0:09:35 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t17\t12:09:55s -0:09:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t18\t12:10:15s -0:10:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t19\t12:10:35s -0:10:35 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t20\t12:10:55s -0:10:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t21\t12:11:10s -0:11:10 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t22\t12:11:30s -0:11:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t23\t12:11:45s -0:11:45 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t24\t12:12:00s -0:12:00 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t25\t12:12:15s -0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t26\t12:12:30s -0:12:30 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t27\t12:12:40s -0:12:40 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t28\t12:12:55s -0:12:55 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t29\t12:13:05s -0:13:05 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t30\t12:13:15s -0:13:15 -\n-Rule\tsol87\t1987\tonly\t-\tJan\t31\t12:13:25s -0:13:25 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t1\t12:13:35s -0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t2\t12:13:40s -0:13:40 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t3\t12:13:50s -0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t4\t12:13:55s -0:13:55 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t5\t12:14:00s -0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t6\t12:14:05s -0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t8\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t10\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t11\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t12\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t21\t12:13:45s -0:13:45 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t22\t12:13:35s -0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t23\t12:13:30s -0:13:30 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t24\t12:13:20s -0:13:20 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t25\t12:13:10s -0:13:10 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t26\t12:13:00s -0:13:00 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t27\t12:12:50s -0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tFeb\t28\t12:12:40s -0:12:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t1\t12:12:30s -0:12:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t2\t12:12:20s -0:12:20 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t3\t12:12:05s -0:12:05 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t4\t12:11:55s -0:11:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t5\t12:11:40s -0:11:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t6\t12:11:25s -0:11:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t7\t12:11:15s -0:11:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t8\t12:11:00s -0:11:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t9\t12:10:45s -0:10:45 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t10\t12:10:30s -0:10:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t11\t12:10:15s -0:10:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t12\t12:09:55s -0:09:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t13\t12:09:40s -0:09:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t14\t12:09:25s -0:09:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t15\t12:09:10s -0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t16\t12:08:50s -0:08:50 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t17\t12:08:35s -0:08:35 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t18\t12:08:15s -0:08:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t19\t12:08:00s -0:08:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t20\t12:07:40s -0:07:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t21\t12:07:25s -0:07:25 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t22\t12:07:05s -0:07:05 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t23\t12:06:50s -0:06:50 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t24\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t25\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t26\t12:05:55s -0:05:55 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t27\t12:05:35s -0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t28\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t29\t12:05:00s -0:05:00 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t30\t12:04:40s -0:04:40 -\n-Rule\tsol87\t1987\tonly\t-\tMar\t31\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t1\t12:04:05s -0:04:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t2\t12:03:45s -0:03:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t3\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t4\t12:03:10s -0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t5\t12:02:55s -0:02:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t6\t12:02:35s -0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t7\t12:02:20s -0:02:20 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t8\t12:02:05s -0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t9\t12:01:45s -0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t10\t12:01:30s -0:01:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t11\t12:01:15s -0:01:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t12\t12:00:55s -0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t13\t12:00:40s -0:00:40 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t14\t12:00:25s -0:00:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t15\t12:00:10s -0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t16\t11:59:55s 0:00:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t17\t11:59:45s 0:00:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t18\t11:59:30s 0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t19\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t20\t11:59:05s 0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t21\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t22\t11:58:40s 0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t23\t11:58:25s 0:01:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t24\t11:58:15s 0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t25\t11:58:05s 0:01:55 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t26\t11:57:55s 0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t27\t11:57:45s 0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t28\t11:57:35s 0:02:25 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t29\t11:57:25s 0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tApr\t30\t11:57:15s 0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t1\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t2\t11:57:00s 0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t3\t11:56:55s 0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t4\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t5\t11:56:45s 0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t6\t11:56:40s 0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t7\t11:56:35s 0:03:25 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t8\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t10\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t18\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t20\t11:56:25s 0:03:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t21\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t22\t11:56:35s 0:03:25 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t23\t11:56:40s 0:03:20 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t24\t11:56:45s 0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t25\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t26\t11:56:55s 0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t27\t11:57:00s 0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t28\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t29\t11:57:15s 0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t30\t11:57:25s 0:02:35 -\n-Rule\tsol87\t1987\tonly\t-\tMay\t31\t11:57:30s 0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t1\t11:57:40s 0:02:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t2\t11:57:50s 0:02:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t3\t11:58:00s 0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t4\t11:58:10s 0:01:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t5\t11:58:20s 0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t6\t11:58:30s 0:01:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t7\t11:58:40s 0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t8\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t9\t11:59:05s 0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t10\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t11\t11:59:30s 0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t12\t11:59:40s 0:00:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t13\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t14\t12:00:05s -0:00:05 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t15\t12:00:15s -0:00:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t16\t12:00:30s -0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t17\t12:00:45s -0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t18\t12:00:55s -0:00:55 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t19\t12:01:10s -0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t20\t12:01:20s -0:01:20 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t21\t12:01:35s -0:01:35 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t22\t12:01:50s -0:01:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t23\t12:02:00s -0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t24\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t25\t12:02:25s -0:02:25 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t26\t12:02:40s -0:02:40 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t27\t12:02:50s -0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t28\t12:03:05s -0:03:05 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t29\t12:03:15s -0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tJun\t30\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t1\t12:03:40s -0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t2\t12:03:50s -0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t3\t12:04:05s -0:04:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t4\t12:04:15s -0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t5\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t6\t12:04:35s -0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t7\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t8\t12:04:55s -0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t9\t12:05:05s -0:05:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t10\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t11\t12:05:20s -0:05:20 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t12\t12:05:30s -0:05:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t13\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t14\t12:05:45s -0:05:45 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t15\t12:05:50s -0:05:50 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t20\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t21\t12:06:20s -0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t24\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tJul\t31\t12:06:25s -0:06:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t1\t12:06:20s -0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t5\t12:06:00s -0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t6\t12:05:55s -0:05:55 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t7\t12:05:50s -0:05:50 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t8\t12:05:40s -0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t9\t12:05:35s -0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t10\t12:05:25s -0:05:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t11\t12:05:15s -0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t12\t12:05:05s -0:05:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t13\t12:04:55s -0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t14\t12:04:45s -0:04:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t15\t12:04:35s -0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t16\t12:04:25s -0:04:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t17\t12:04:10s -0:04:10 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t18\t12:04:00s -0:04:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t19\t12:03:45s -0:03:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t20\t12:03:30s -0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t21\t12:03:15s -0:03:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t22\t12:03:00s -0:03:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t23\t12:02:45s -0:02:45 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t24\t12:02:30s -0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t25\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t26\t12:02:00s -0:02:00 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t27\t12:01:40s -0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t28\t12:01:25s -0:01:25 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t29\t12:01:05s -0:01:05 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t30\t12:00:50s -0:00:50 -\n-Rule\tsol87\t1987\tonly\t-\tAug\t31\t12:00:30s -0:00:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t1\t12:00:10s -0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t2\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t3\t11:59:35s 0:00:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t4\t11:59:15s 0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t5\t11:58:55s 0:01:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t6\t11:58:35s 0:01:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t7\t11:58:15s 0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t8\t11:57:55s 0:02:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t9\t11:57:30s 0:02:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t10\t11:57:10s 0:02:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t11\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t12\t11:56:30s 0:03:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t13\t11:56:10s 0:03:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t14\t11:55:45s 0:04:15 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t15\t11:55:25s 0:04:35 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t16\t11:55:05s 0:04:55 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t17\t11:54:45s 0:05:15 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t18\t11:54:20s 0:05:40 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t19\t11:54:00s 0:06:00 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t20\t11:53:40s 0:06:20 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t21\t11:53:15s 0:06:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t22\t11:52:55s 0:07:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t23\t11:52:35s 0:07:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t24\t11:52:15s 0:07:45 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t25\t11:51:55s 0:08:05 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t26\t11:51:35s 0:08:25 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t27\t11:51:10s 0:08:50 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t28\t11:50:50s 0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t29\t11:50:30s 0:09:30 -\n-Rule\tsol87\t1987\tonly\t-\tSep\t30\t11:50:10s 0:09:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t1\t11:49:50s 0:10:10 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t2\t11:49:35s 0:10:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t3\t11:49:15s 0:10:45 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t4\t11:48:55s 0:11:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t5\t11:48:35s 0:11:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t6\t11:48:20s 0:11:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t7\t11:48:00s 0:12:00 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t8\t11:47:45s 0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t9\t11:47:25s 0:12:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t10\t11:47:10s 0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t11\t11:46:55s 0:13:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t12\t11:46:40s 0:13:20 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t13\t11:46:25s 0:13:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t14\t11:46:10s 0:13:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t15\t11:45:55s 0:14:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t16\t11:45:45s 0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t17\t11:45:30s 0:14:30 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t18\t11:45:20s 0:14:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t19\t11:45:05s 0:14:55 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t20\t11:44:55s 0:15:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t21\t11:44:45s 0:15:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t22\t11:44:35s 0:15:25 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t23\t11:44:25s 0:15:35 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t24\t11:44:20s 0:15:40 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t25\t11:44:10s 0:15:50 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t26\t11:44:05s 0:15:55 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t27\t11:43:55s 0:16:05 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t28\t11:43:50s 0:16:10 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t29\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t30\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tOct\t31\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t1\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t3\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t5\t11:43:35s 0:16:25 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t6\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t7\t11:43:40s 0:16:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t10\t11:43:55s 0:16:05 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t11\t11:44:00s 0:16:00 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t12\t11:44:05s 0:15:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t13\t11:44:15s 0:15:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t14\t11:44:20s 0:15:40 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t15\t11:44:30s 0:15:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t16\t11:44:40s 0:15:20 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t17\t11:44:50s 0:15:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t18\t11:45:05s 0:14:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t19\t11:45:15s 0:14:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t20\t11:45:30s 0:14:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t21\t11:45:45s 0:14:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t22\t11:46:00s 0:14:00 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t23\t11:46:15s 0:13:45 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t24\t11:46:30s 0:13:30 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t25\t11:46:50s 0:13:10 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t26\t11:47:10s 0:12:50 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t27\t11:47:25s 0:12:35 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t28\t11:47:45s 0:12:15 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t29\t11:48:05s 0:11:55 -\n-Rule\tsol87\t1987\tonly\t-\tNov\t30\t11:48:30s 0:11:30 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t1\t11:48:50s 0:11:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t2\t11:49:10s 0:10:50 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t3\t11:49:35s 0:10:25 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t4\t11:50:00s 0:10:00 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t5\t11:50:25s 0:09:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t6\t11:50:50s 0:09:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t7\t11:51:15s 0:08:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t8\t11:51:40s 0:08:20 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t9\t11:52:05s 0:07:55 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t10\t11:52:30s 0:07:30 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t11\t11:53:00s 0:07:00 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t12\t11:53:25s 0:06:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t13\t11:53:55s 0:06:05 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t14\t11:54:25s 0:05:35 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t15\t11:54:50s 0:05:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t16\t11:55:20s 0:04:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t17\t11:55:50s 0:04:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t18\t11:56:20s 0:03:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t19\t11:56:50s 0:03:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t20\t11:57:20s 0:02:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t21\t11:57:50s 0:02:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t22\t11:58:20s 0:01:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t23\t11:58:50s 0:01:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t24\t11:59:20s 0:00:40 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t25\t11:59:50s 0:00:10 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t26\t12:00:20s -0:00:20 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t27\t12:00:45s -0:00:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t28\t12:01:15s -0:01:15 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t29\t12:01:45s -0:01:45 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t30\t12:02:15s -0:02:15 -\n-Rule\tsol87\t1987\tonly\t-\tDec\t31\t12:02:45s -0:02:45 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1987, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh87\t3:07:04\t-\t\tzzz\t1987\n-\t\t\t3:07:04\tsol87\t\tzzz\t1988\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh87\tMideast\/Riyadh87\n","filename":"src\/java.base\/share\/data\/tzdata\/solar87","additions":0,"deletions":413,"binary":false,"changes":413,"status":"deleted"},{"patch":"@@ -1,413 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# Apparent noon times below are for Riyadh; they're a bit off for other places.\n-# Times were computed using formulas in the U.S. Naval Observatory's\n-# Almanac for Computers 1988; the formulas \"will give EqT to an accuracy of\n-# [plus or minus two] seconds during the current year.\"\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol88\t1988\tonly\t-\tJan\t1\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t2\t12:03:40s -0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t3\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t4\t12:04:40s -0:04:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t5\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t6\t12:05:30s -0:05:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t7\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t8\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t9\t12:06:50s -0:06:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t10\t12:07:15s -0:07:15 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t11\t12:07:40s -0:07:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t12\t12:08:05s -0:08:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t13\t12:08:25s -0:08:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t14\t12:08:50s -0:08:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t15\t12:09:10s -0:09:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t16\t12:09:30s -0:09:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t17\t12:09:50s -0:09:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t18\t12:10:10s -0:10:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t19\t12:10:30s -0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t20\t12:10:50s -0:10:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t21\t12:11:05s -0:11:05 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t22\t12:11:25s -0:11:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t23\t12:11:40s -0:11:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t24\t12:11:55s -0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t25\t12:12:10s -0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t26\t12:12:25s -0:12:25 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t27\t12:12:40s -0:12:40 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t28\t12:12:50s -0:12:50 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t29\t12:13:00s -0:13:00 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t30\t12:13:10s -0:13:10 -\n-Rule\tsol88\t1988\tonly\t-\tJan\t31\t12:13:20s -0:13:20 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t1\t12:13:30s -0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t2\t12:13:40s -0:13:40 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t3\t12:13:45s -0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t4\t12:13:55s -0:13:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t5\t12:14:00s -0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t6\t12:14:05s -0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t8\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t10\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t11\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t12\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t21\t12:13:45s -0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t22\t12:13:40s -0:13:40 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t23\t12:13:30s -0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t24\t12:13:20s -0:13:20 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t25\t12:13:15s -0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t26\t12:13:05s -0:13:05 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t27\t12:12:55s -0:12:55 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t28\t12:12:45s -0:12:45 -\n-Rule\tsol88\t1988\tonly\t-\tFeb\t29\t12:12:30s -0:12:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t1\t12:12:20s -0:12:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t2\t12:12:10s -0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t3\t12:11:55s -0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t4\t12:11:45s -0:11:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t5\t12:11:30s -0:11:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t6\t12:11:15s -0:11:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t7\t12:11:00s -0:11:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t8\t12:10:45s -0:10:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t9\t12:10:30s -0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t10\t12:10:15s -0:10:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t11\t12:10:00s -0:10:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t12\t12:09:45s -0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t13\t12:09:30s -0:09:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t14\t12:09:10s -0:09:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t15\t12:08:55s -0:08:55 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t16\t12:08:40s -0:08:40 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t17\t12:08:20s -0:08:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t18\t12:08:05s -0:08:05 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t19\t12:07:45s -0:07:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t20\t12:07:30s -0:07:30 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t21\t12:07:10s -0:07:10 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t22\t12:06:50s -0:06:50 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t23\t12:06:35s -0:06:35 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t24\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t25\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t26\t12:05:40s -0:05:40 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t27\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t28\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t29\t12:04:45s -0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t30\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tMar\t31\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t1\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t2\t12:03:35s -0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t3\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t4\t12:03:00s -0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t5\t12:02:40s -0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t6\t12:02:25s -0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t7\t12:02:05s -0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t8\t12:01:50s -0:01:50 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t9\t12:01:35s -0:01:35 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t10\t12:01:15s -0:01:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t11\t12:01:00s -0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t12\t12:00:45s -0:00:45 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t13\t12:00:30s -0:00:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t14\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t15\t12:00:00s 0:00:00 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t16\t11:59:45s 0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t17\t11:59:30s 0:00:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t18\t11:59:20s 0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t19\t11:59:05s 0:00:55 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t20\t11:58:55s 0:01:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t21\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t22\t11:58:30s 0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t23\t11:58:15s 0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t24\t11:58:05s 0:01:55 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t25\t11:57:55s 0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t26\t11:57:45s 0:02:15 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t27\t11:57:35s 0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t28\t11:57:30s 0:02:30 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t29\t11:57:20s 0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tApr\t30\t11:57:10s 0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t1\t11:57:05s 0:02:55 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t2\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t3\t11:56:50s 0:03:10 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t4\t11:56:45s 0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t5\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t6\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t7\t11:56:30s 0:03:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t8\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t10\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t18\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t20\t11:56:30s 0:03:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t21\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t22\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t23\t11:56:45s 0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t24\t11:56:50s 0:03:10 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t25\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t26\t11:57:00s 0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t27\t11:57:05s 0:02:55 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t28\t11:57:15s 0:02:45 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t29\t11:57:20s 0:02:40 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t30\t11:57:30s 0:02:30 -\n-Rule\tsol88\t1988\tonly\t-\tMay\t31\t11:57:40s 0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t1\t11:57:50s 0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t2\t11:57:55s 0:02:05 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t3\t11:58:05s 0:01:55 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t4\t11:58:15s 0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t5\t11:58:30s 0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t6\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t7\t11:58:50s 0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t8\t11:59:00s 0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t9\t11:59:15s 0:00:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t10\t11:59:25s 0:00:35 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t11\t11:59:35s 0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t12\t11:59:50s 0:00:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t13\t12:00:00s 0:00:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t14\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t15\t12:00:25s -0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t16\t12:00:40s -0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t17\t12:00:55s -0:00:55 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t18\t12:01:05s -0:01:05 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t19\t12:01:20s -0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t20\t12:01:30s -0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t21\t12:01:45s -0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t22\t12:02:00s -0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t23\t12:02:10s -0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t24\t12:02:25s -0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t25\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t26\t12:02:50s -0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t27\t12:03:00s -0:03:00 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t28\t12:03:15s -0:03:15 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t29\t12:03:25s -0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tJun\t30\t12:03:40s -0:03:40 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t1\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t2\t12:04:00s -0:04:00 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t3\t12:04:10s -0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t4\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t5\t12:04:35s -0:04:35 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t6\t12:04:45s -0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t7\t12:04:55s -0:04:55 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t8\t12:05:05s -0:05:05 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t9\t12:05:10s -0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t10\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t11\t12:05:30s -0:05:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t12\t12:05:35s -0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t13\t12:05:45s -0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t14\t12:05:50s -0:05:50 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t15\t12:05:55s -0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t20\t12:06:20s -0:06:20 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t21\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t24\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol88\t1988\tonly\t-\tJul\t31\t12:06:20s -0:06:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t1\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t5\t12:05:55s -0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t6\t12:05:50s -0:05:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t7\t12:05:45s -0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t8\t12:05:35s -0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t9\t12:05:25s -0:05:25 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t10\t12:05:20s -0:05:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t11\t12:05:10s -0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t12\t12:05:00s -0:05:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t13\t12:04:50s -0:04:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t14\t12:04:35s -0:04:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t15\t12:04:25s -0:04:25 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t16\t12:04:15s -0:04:15 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t17\t12:04:00s -0:04:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t18\t12:03:50s -0:03:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t19\t12:03:35s -0:03:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t20\t12:03:20s -0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t21\t12:03:05s -0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t22\t12:02:50s -0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t23\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t24\t12:02:20s -0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t25\t12:02:00s -0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t26\t12:01:45s -0:01:45 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t27\t12:01:30s -0:01:30 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t28\t12:01:10s -0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t29\t12:00:50s -0:00:50 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t30\t12:00:35s -0:00:35 -\n-Rule\tsol88\t1988\tonly\t-\tAug\t31\t12:00:15s -0:00:15 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t1\t11:59:55s 0:00:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t2\t11:59:35s 0:00:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t3\t11:59:20s 0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t4\t11:59:00s 0:01:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t5\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t6\t11:58:20s 0:01:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t7\t11:58:00s 0:02:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t8\t11:57:35s 0:02:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t9\t11:57:15s 0:02:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t10\t11:56:55s 0:03:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t11\t11:56:35s 0:03:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t12\t11:56:15s 0:03:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t13\t11:55:50s 0:04:10 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t14\t11:55:30s 0:04:30 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t15\t11:55:10s 0:04:50 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t16\t11:54:50s 0:05:10 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t17\t11:54:25s 0:05:35 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t18\t11:54:05s 0:05:55 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t19\t11:53:45s 0:06:15 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t20\t11:53:25s 0:06:35 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t21\t11:53:00s 0:07:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t22\t11:52:40s 0:07:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t23\t11:52:20s 0:07:40 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t24\t11:52:00s 0:08:00 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t25\t11:51:40s 0:08:20 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t26\t11:51:15s 0:08:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t27\t11:50:55s 0:09:05 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t28\t11:50:35s 0:09:25 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t29\t11:50:15s 0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tSep\t30\t11:49:55s 0:10:05 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t1\t11:49:35s 0:10:25 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t2\t11:49:20s 0:10:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t3\t11:49:00s 0:11:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t4\t11:48:40s 0:11:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t5\t11:48:25s 0:11:35 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t6\t11:48:05s 0:11:55 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t7\t11:47:50s 0:12:10 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t8\t11:47:30s 0:12:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t9\t11:47:15s 0:12:45 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t10\t11:47:00s 0:13:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t11\t11:46:45s 0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t12\t11:46:30s 0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t13\t11:46:15s 0:13:45 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t14\t11:46:00s 0:14:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t15\t11:45:45s 0:14:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t16\t11:45:35s 0:14:25 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t17\t11:45:20s 0:14:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t18\t11:45:10s 0:14:50 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t19\t11:45:00s 0:15:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t20\t11:44:45s 0:15:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t21\t11:44:40s 0:15:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t22\t11:44:30s 0:15:30 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t23\t11:44:20s 0:15:40 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t24\t11:44:10s 0:15:50 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t25\t11:44:05s 0:15:55 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t26\t11:44:00s 0:16:00 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t27\t11:43:55s 0:16:05 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t28\t11:43:50s 0:16:10 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t29\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t30\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tOct\t31\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t1\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t3\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t5\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t6\t11:43:40s 0:16:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t7\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t10\t11:44:00s 0:16:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t11\t11:44:05s 0:15:55 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t12\t11:44:10s 0:15:50 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t13\t11:44:20s 0:15:40 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t14\t11:44:30s 0:15:30 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t15\t11:44:40s 0:15:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t16\t11:44:50s 0:15:10 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t17\t11:45:00s 0:15:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t18\t11:45:15s 0:14:45 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t19\t11:45:25s 0:14:35 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t20\t11:45:40s 0:14:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t21\t11:45:55s 0:14:05 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t22\t11:46:10s 0:13:50 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t23\t11:46:30s 0:13:30 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t24\t11:46:45s 0:13:15 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t25\t11:47:05s 0:12:55 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t26\t11:47:20s 0:12:40 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t27\t11:47:40s 0:12:20 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t28\t11:48:00s 0:12:00 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t29\t11:48:25s 0:11:35 -\n-Rule\tsol88\t1988\tonly\t-\tNov\t30\t11:48:45s 0:11:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t1\t11:49:05s 0:10:55 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t2\t11:49:30s 0:10:30 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t3\t11:49:55s 0:10:05 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t4\t11:50:15s 0:09:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t5\t11:50:40s 0:09:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t6\t11:51:05s 0:08:55 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t7\t11:51:35s 0:08:25 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t8\t11:52:00s 0:08:00 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t9\t11:52:25s 0:07:35 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t10\t11:52:55s 0:07:05 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t11\t11:53:20s 0:06:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t12\t11:53:50s 0:06:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t13\t11:54:15s 0:05:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t14\t11:54:45s 0:05:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t15\t11:55:15s 0:04:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t16\t11:55:45s 0:04:15 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t17\t11:56:15s 0:03:45 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t18\t11:56:40s 0:03:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t19\t11:57:10s 0:02:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t20\t11:57:40s 0:02:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t21\t11:58:10s 0:01:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t22\t11:58:40s 0:01:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t23\t11:59:10s 0:00:50 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t24\t11:59:40s 0:00:20 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t25\t12:00:10s -0:00:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t26\t12:00:40s -0:00:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t27\t12:01:10s -0:01:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t28\t12:01:40s -0:01:40 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t29\t12:02:10s -0:02:10 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t30\t12:02:35s -0:02:35 -\n-Rule\tsol88\t1988\tonly\t-\tDec\t31\t12:03:05s -0:03:05 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1988, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh88\t3:07:04\t-\t\tzzz\t1988\n-\t\t\t3:07:04\tsol88\t\tzzz\t1989\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh88\tMideast\/Riyadh88\n","filename":"src\/java.base\/share\/data\/tzdata\/solar88","additions":0,"deletions":413,"binary":false,"changes":413,"status":"deleted"},{"patch":"@@ -1,418 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# <pre>\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-\n-# Apparent noon times below are for Riyadh; they're a bit off for other places.\n-# Times were computed using a formula provided by the U. S. Naval Observatory:\n-#\teqt = -105.8 * sin(l) + 596.2 * sin(2 * l) + 4.4 * sin(3 * l)\n-#\t\t-12.7 * sin(4 * l) - 429.0 * cos(l) - 2.1 * cos (2 * l)\n-#\t\t+ 19.3 * cos(3 * l);\n-# where l is the \"mean longitude of the Sun\" given by\n-#\tl = 279.642 degrees + 0.985647 * d\n-# and d is the interval in days from January 0, 0 hours Universal Time\n-# (equaling the day of the year plus the fraction of a day from zero hours).\n-# The accuracy of the formula is plus or minus three seconds.\n-#\n-# Rounding to the nearest five seconds results in fewer than\n-# 256 different \"time types\"--a limit that's faced because time types are\n-# stored on disk as unsigned chars.\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tsol89\t1989\tonly\t-\tJan\t1\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t2\t12:04:05s -0:04:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t3\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t4\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t5\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t6\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t7\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t8\t12:06:45s -0:06:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t9\t12:07:10s -0:07:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t10\t12:07:35s -0:07:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t11\t12:07:55s -0:07:55 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t12\t12:08:20s -0:08:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t13\t12:08:45s -0:08:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t14\t12:09:05s -0:09:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t15\t12:09:25s -0:09:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t16\t12:09:45s -0:09:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t17\t12:10:05s -0:10:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t18\t12:10:25s -0:10:25 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t19\t12:10:45s -0:10:45 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t20\t12:11:05s -0:11:05 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t21\t12:11:20s -0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t22\t12:11:35s -0:11:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t23\t12:11:55s -0:11:55 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t24\t12:12:10s -0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t25\t12:12:20s -0:12:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t26\t12:12:35s -0:12:35 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t27\t12:12:50s -0:12:50 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t28\t12:13:00s -0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t29\t12:13:10s -0:13:10 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t30\t12:13:20s -0:13:20 -\n-Rule\tsol89\t1989\tonly\t-\tJan\t31\t12:13:30s -0:13:30 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t1\t12:13:40s -0:13:40 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t2\t12:13:45s -0:13:45 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t3\t12:13:55s -0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t4\t12:14:00s -0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t5\t12:14:05s -0:14:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t6\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t7\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t8\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t9\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t10\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t11\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t12\t12:14:20s -0:14:20 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t13\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t14\t12:14:15s -0:14:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t15\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t16\t12:14:10s -0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t17\t12:14:05s -0:14:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t18\t12:14:00s -0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t19\t12:13:55s -0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t20\t12:13:50s -0:13:50 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t21\t12:13:40s -0:13:40 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t22\t12:13:35s -0:13:35 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t23\t12:13:25s -0:13:25 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t24\t12:13:15s -0:13:15 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t25\t12:13:05s -0:13:05 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t26\t12:12:55s -0:12:55 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t27\t12:12:45s -0:12:45 -\n-Rule\tsol89\t1989\tonly\t-\tFeb\t28\t12:12:35s -0:12:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t1\t12:12:25s -0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t2\t12:12:10s -0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t3\t12:12:00s -0:12:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t4\t12:11:45s -0:11:45 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t5\t12:11:35s -0:11:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t6\t12:11:20s -0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t7\t12:11:05s -0:11:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t8\t12:10:50s -0:10:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t9\t12:10:35s -0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t10\t12:10:20s -0:10:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t11\t12:10:05s -0:10:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t12\t12:09:50s -0:09:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t13\t12:09:30s -0:09:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t14\t12:09:15s -0:09:15 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t15\t12:09:00s -0:09:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t16\t12:08:40s -0:08:40 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t17\t12:08:25s -0:08:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t18\t12:08:05s -0:08:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t19\t12:07:50s -0:07:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t20\t12:07:30s -0:07:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t21\t12:07:15s -0:07:15 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t22\t12:06:55s -0:06:55 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t23\t12:06:35s -0:06:35 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t24\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t25\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t26\t12:05:40s -0:05:40 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t27\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t28\t12:05:05s -0:05:05 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t29\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t30\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tMar\t31\t12:04:10s -0:04:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t1\t12:03:55s -0:03:55 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t2\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t3\t12:03:20s -0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t4\t12:03:00s -0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t5\t12:02:45s -0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t6\t12:02:25s -0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t7\t12:02:10s -0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t8\t12:01:50s -0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t9\t12:01:35s -0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t10\t12:01:20s -0:01:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t11\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t12\t12:00:50s -0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t13\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t14\t12:00:20s -0:00:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t15\t12:00:05s -0:00:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t16\t11:59:50s 0:00:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t17\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t18\t11:59:20s 0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t19\t11:59:10s 0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t20\t11:58:55s 0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t21\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t22\t11:58:30s 0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t23\t11:58:20s 0:01:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t24\t11:58:10s 0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t25\t11:58:00s 0:02:00 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t26\t11:57:50s 0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t27\t11:57:40s 0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t28\t11:57:30s 0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t29\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tApr\t30\t11:57:15s 0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t1\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t2\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t3\t11:56:50s 0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t4\t11:56:45s 0:03:15 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t5\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t6\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t7\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t8\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t9\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t10\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t11\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t12\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t13\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t14\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t15\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t16\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t17\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t18\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t19\t11:56:25s 0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t20\t11:56:30s 0:03:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t21\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t22\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t23\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t24\t11:56:45s 0:03:15 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t25\t11:56:55s 0:03:05 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t26\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t27\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t28\t11:57:15s 0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t29\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t30\t11:57:30s 0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tMay\t31\t11:57:35s 0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t1\t11:57:45s 0:02:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t2\t11:57:55s 0:02:05 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t3\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t4\t11:58:15s 0:01:45 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t5\t11:58:25s 0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t6\t11:58:35s 0:01:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t7\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t8\t11:59:00s 0:01:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t9\t11:59:10s 0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t10\t11:59:20s 0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t11\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t12\t11:59:45s 0:00:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t13\t12:00:00s 0:00:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t14\t12:00:10s -0:00:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t15\t12:00:25s -0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t16\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t17\t12:00:50s -0:00:50 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t18\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t19\t12:01:15s -0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t20\t12:01:30s -0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t21\t12:01:40s -0:01:40 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t22\t12:01:55s -0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t23\t12:02:10s -0:02:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t24\t12:02:20s -0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t25\t12:02:35s -0:02:35 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t26\t12:02:45s -0:02:45 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t27\t12:03:00s -0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t28\t12:03:10s -0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t29\t12:03:25s -0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tJun\t30\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t1\t12:03:45s -0:03:45 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t2\t12:04:00s -0:04:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t3\t12:04:10s -0:04:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t4\t12:04:20s -0:04:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t5\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t6\t12:04:40s -0:04:40 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t7\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t8\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t9\t12:05:10s -0:05:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t10\t12:05:20s -0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t11\t12:05:25s -0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t12\t12:05:35s -0:05:35 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t13\t12:05:40s -0:05:40 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t14\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t15\t12:05:55s -0:05:55 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t16\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t17\t12:06:05s -0:06:05 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t18\t12:06:10s -0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t19\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t20\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t21\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t22\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t23\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t24\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t25\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t26\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t27\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t28\t12:06:30s -0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t29\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t30\t12:06:25s -0:06:25 -\n-Rule\tsol89\t1989\tonly\t-\tJul\t31\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t1\t12:06:20s -0:06:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t2\t12:06:15s -0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t3\t12:06:10s -0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t4\t12:06:05s -0:06:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t5\t12:06:00s -0:06:00 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t6\t12:05:50s -0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t7\t12:05:45s -0:05:45 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t8\t12:05:35s -0:05:35 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t9\t12:05:30s -0:05:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t10\t12:05:20s -0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t11\t12:05:10s -0:05:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t12\t12:05:00s -0:05:00 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t13\t12:04:50s -0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t14\t12:04:40s -0:04:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t15\t12:04:30s -0:04:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t16\t12:04:15s -0:04:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t17\t12:04:05s -0:04:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t18\t12:03:50s -0:03:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t19\t12:03:35s -0:03:35 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t20\t12:03:25s -0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t21\t12:03:10s -0:03:10 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t22\t12:02:55s -0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t23\t12:02:40s -0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t24\t12:02:20s -0:02:20 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t25\t12:02:05s -0:02:05 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t26\t12:01:50s -0:01:50 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t27\t12:01:30s -0:01:30 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t28\t12:01:15s -0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t29\t12:00:55s -0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t30\t12:00:40s -0:00:40 -\n-Rule\tsol89\t1989\tonly\t-\tAug\t31\t12:00:20s -0:00:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t1\t12:00:00s 0:00:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t2\t11:59:45s 0:00:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t3\t11:59:25s 0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t4\t11:59:05s 0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t5\t11:58:45s 0:01:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t6\t11:58:25s 0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t7\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t8\t11:57:45s 0:02:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t9\t11:57:20s 0:02:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t10\t11:57:00s 0:03:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t11\t11:56:40s 0:03:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t12\t11:56:20s 0:03:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t13\t11:56:00s 0:04:00 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t14\t11:55:35s 0:04:25 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t15\t11:55:15s 0:04:45 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t16\t11:54:55s 0:05:05 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t17\t11:54:35s 0:05:25 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t18\t11:54:10s 0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t19\t11:53:50s 0:06:10 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t20\t11:53:30s 0:06:30 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t21\t11:53:10s 0:06:50 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t22\t11:52:45s 0:07:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t23\t11:52:25s 0:07:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t24\t11:52:05s 0:07:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t25\t11:51:45s 0:08:15 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t26\t11:51:25s 0:08:35 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t27\t11:51:05s 0:08:55 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t28\t11:50:40s 0:09:20 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t29\t11:50:20s 0:09:40 -\n-Rule\tsol89\t1989\tonly\t-\tSep\t30\t11:50:00s 0:10:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t1\t11:49:45s 0:10:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t2\t11:49:25s 0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t3\t11:49:05s 0:10:55 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t4\t11:48:45s 0:11:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t5\t11:48:30s 0:11:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t6\t11:48:10s 0:11:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t7\t11:47:50s 0:12:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t8\t11:47:35s 0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t9\t11:47:20s 0:12:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t10\t11:47:00s 0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t11\t11:46:45s 0:13:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t12\t11:46:30s 0:13:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t13\t11:46:15s 0:13:45 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t14\t11:46:00s 0:14:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t15\t11:45:50s 0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t16\t11:45:35s 0:14:25 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t17\t11:45:20s 0:14:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t18\t11:45:10s 0:14:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t19\t11:45:00s 0:15:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t20\t11:44:50s 0:15:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t21\t11:44:40s 0:15:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t22\t11:44:30s 0:15:30 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t23\t11:44:20s 0:15:40 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t24\t11:44:10s 0:15:50 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t25\t11:44:05s 0:15:55 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t26\t11:44:00s 0:16:00 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t27\t11:43:50s 0:16:10 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t28\t11:43:45s 0:16:15 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t29\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t30\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tOct\t31\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t1\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t2\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t3\t11:43:30s 0:16:30 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t4\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t5\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t6\t11:43:35s 0:16:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t7\t11:43:40s 0:16:20 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t8\t11:43:45s 0:16:15 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t9\t11:43:50s 0:16:10 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t10\t11:43:55s 0:16:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t11\t11:44:00s 0:16:00 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t12\t11:44:05s 0:15:55 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t13\t11:44:15s 0:15:45 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t14\t11:44:25s 0:15:35 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t15\t11:44:35s 0:15:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t16\t11:44:45s 0:15:15 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t17\t11:44:55s 0:15:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t18\t11:45:10s 0:14:50 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t19\t11:45:20s 0:14:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t20\t11:45:35s 0:14:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t21\t11:45:50s 0:14:10 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t22\t11:46:05s 0:13:55 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t23\t11:46:25s 0:13:35 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t24\t11:46:40s 0:13:20 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t25\t11:47:00s 0:13:00 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t26\t11:47:20s 0:12:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t27\t11:47:35s 0:12:25 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t28\t11:47:55s 0:12:05 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t29\t11:48:20s 0:11:40 -\n-Rule\tsol89\t1989\tonly\t-\tNov\t30\t11:48:40s 0:11:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t1\t11:49:00s 0:11:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t2\t11:49:25s 0:10:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t3\t11:49:50s 0:10:10 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t4\t11:50:15s 0:09:45 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t5\t11:50:35s 0:09:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t6\t11:51:00s 0:09:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t7\t11:51:30s 0:08:30 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t8\t11:51:55s 0:08:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t9\t11:52:20s 0:07:40 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t10\t11:52:50s 0:07:10 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t11\t11:53:15s 0:06:45 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t12\t11:53:45s 0:06:15 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t13\t11:54:10s 0:05:50 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t14\t11:54:40s 0:05:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t15\t11:55:10s 0:04:50 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t16\t11:55:40s 0:04:20 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t17\t11:56:05s 0:03:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t18\t11:56:35s 0:03:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t19\t11:57:05s 0:02:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t20\t11:57:35s 0:02:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t21\t11:58:05s 0:01:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t22\t11:58:35s 0:01:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t23\t11:59:05s 0:00:55 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t24\t11:59:35s 0:00:25 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t25\t12:00:05s -0:00:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t26\t12:00:35s -0:00:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t27\t12:01:05s -0:01:05 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t28\t12:01:35s -0:01:35 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t29\t12:02:00s -0:02:00 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t30\t12:02:30s -0:02:30 -\n-Rule\tsol89\t1989\tonly\t-\tDec\t31\t12:03:00s -0:03:00 -\n-\n-# Riyadh is at about 46 degrees 46 minutes East:  3 hrs, 7 mins, 4 secs\n-# Before and after 1989, we'll operate on local mean solar time.\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Riyadh89\t3:07:04\t-\t\tzzz\t1989\n-\t\t\t3:07:04\tsol89\t\tzzz\t1990\n-\t\t\t3:07:04\t-\t\tzzz\n-# For backward compatibility...\n-Link\tAsia\/Riyadh89\tMideast\/Riyadh89\n","filename":"src\/java.base\/share\/data\/tzdata\/solar89","additions":0,"deletions":418,"binary":false,"changes":418,"status":"deleted"},{"patch":"@@ -1,470 +0,0 @@\n-#\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# tzdb timezone descriptions (deprecated version)\n-#\n-# This file is in the public domain, so clarified as of\n-# 2009-05-17 by Arthur David Olson.\n-#\n-# From Paul Eggert (2021-09-20):\n-# This file is intended as a backward-compatibility aid for older programs.\n-# New programs should use zone1970.tab.  This file is like zone1970.tab (see\n-# zone1970.tab's comments), but with the following additional restrictions:\n-#\n-# 1.  This file contains only ASCII characters.\n-# 2.  The first data column contains exactly one country code.\n-#\n-# Because of (2), each row stands for an area that is the intersection\n-# of a region identified by a country code and of a timezone where civil\n-# clocks have agreed since 1970; this is a narrower definition than\n-# that of zone1970.tab.\n-#\n-# Unlike zone1970.tab, a row's third column can be a Link from\n-# 'backward' instead of a Zone.\n-#\n-# This table is intended as an aid for users, to help them select timezones\n-# appropriate for their practical needs.  It is not intended to take or\n-# endorse any position on legal or territorial claims.\n-#\n-#country-\n-#code\tcoordinates\tTZ\t\t\tcomments\n-AD\t+4230+00131\tEurope\/Andorra\n-AE\t+2518+05518\tAsia\/Dubai\n-AF\t+3431+06912\tAsia\/Kabul\n-AG\t+1703-06148\tAmerica\/Antigua\n-AI\t+1812-06304\tAmerica\/Anguilla\n-AL\t+4120+01950\tEurope\/Tirane\n-AM\t+4011+04430\tAsia\/Yerevan\n-AO\t-0848+01314\tAfrica\/Luanda\n-AQ\t-7750+16636\tAntarctica\/McMurdo\tNew Zealand time - McMurdo, South Pole\n-AQ\t-6617+11031\tAntarctica\/Casey\tCasey\n-AQ\t-6835+07758\tAntarctica\/Davis\tDavis\n-AQ\t-6640+14001\tAntarctica\/DumontDUrville\tDumont-d'Urville\n-AQ\t-6736+06253\tAntarctica\/Mawson\tMawson\n-AQ\t-6448-06406\tAntarctica\/Palmer\tPalmer\n-AQ\t-6734-06808\tAntarctica\/Rothera\tRothera\n-AQ\t-690022+0393524\tAntarctica\/Syowa\tSyowa\n-AQ\t-720041+0023206\tAntarctica\/Troll\tTroll\n-AQ\t-7824+10654\tAntarctica\/Vostok\tVostok\n-AR\t-3436-05827\tAmerica\/Argentina\/Buenos_Aires\tBuenos Aires (BA, CF)\n-AR\t-3124-06411\tAmerica\/Argentina\/Cordoba\tArgentina (most areas: CB, CC, CN, ER, FM, MN, SE, SF)\n-AR\t-2447-06525\tAmerica\/Argentina\/Salta\tSalta (SA, LP, NQ, RN)\n-AR\t-2411-06518\tAmerica\/Argentina\/Jujuy\tJujuy (JY)\n-AR\t-2649-06513\tAmerica\/Argentina\/Tucuman\tTucuman (TM)\n-AR\t-2828-06547\tAmerica\/Argentina\/Catamarca\tCatamarca (CT), Chubut (CH)\n-AR\t-2926-06651\tAmerica\/Argentina\/La_Rioja\tLa Rioja (LR)\n-AR\t-3132-06831\tAmerica\/Argentina\/San_Juan\tSan Juan (SJ)\n-AR\t-3253-06849\tAmerica\/Argentina\/Mendoza\tMendoza (MZ)\n-AR\t-3319-06621\tAmerica\/Argentina\/San_Luis\tSan Luis (SL)\n-AR\t-5138-06913\tAmerica\/Argentina\/Rio_Gallegos\tSanta Cruz (SC)\n-AR\t-5448-06818\tAmerica\/Argentina\/Ushuaia\tTierra del Fuego (TF)\n-AS\t-1416-17042\tPacific\/Pago_Pago\n-AT\t+4813+01620\tEurope\/Vienna\n-AU\t-3133+15905\tAustralia\/Lord_Howe\tLord Howe Island\n-AU\t-5430+15857\tAntarctica\/Macquarie\tMacquarie Island\n-AU\t-4253+14719\tAustralia\/Hobart\tTasmania\n-AU\t-3749+14458\tAustralia\/Melbourne\tVictoria\n-AU\t-3352+15113\tAustralia\/Sydney\tNew South Wales (most areas)\n-AU\t-3157+14127\tAustralia\/Broken_Hill\tNew South Wales (Yancowinna)\n-AU\t-2728+15302\tAustralia\/Brisbane\tQueensland (most areas)\n-AU\t-2016+14900\tAustralia\/Lindeman\tQueensland (Whitsunday Islands)\n-AU\t-3455+13835\tAustralia\/Adelaide\tSouth Australia\n-AU\t-1228+13050\tAustralia\/Darwin\tNorthern Territory\n-AU\t-3157+11551\tAustralia\/Perth\tWestern Australia (most areas)\n-AU\t-3143+12852\tAustralia\/Eucla\tWestern Australia (Eucla)\n-AW\t+1230-06958\tAmerica\/Aruba\n-AX\t+6006+01957\tEurope\/Mariehamn\n-AZ\t+4023+04951\tAsia\/Baku\n-BA\t+4352+01825\tEurope\/Sarajevo\n-BB\t+1306-05937\tAmerica\/Barbados\n-BD\t+2343+09025\tAsia\/Dhaka\n-BE\t+5050+00420\tEurope\/Brussels\n-BF\t+1222-00131\tAfrica\/Ouagadougou\n-BG\t+4241+02319\tEurope\/Sofia\n-BH\t+2623+05035\tAsia\/Bahrain\n-BI\t-0323+02922\tAfrica\/Bujumbura\n-BJ\t+0629+00237\tAfrica\/Porto-Novo\n-BL\t+1753-06251\tAmerica\/St_Barthelemy\n-BM\t+3217-06446\tAtlantic\/Bermuda\n-BN\t+0456+11455\tAsia\/Brunei\n-BO\t-1630-06809\tAmerica\/La_Paz\n-BQ\t+120903-0681636\tAmerica\/Kralendijk\n-BR\t-0351-03225\tAmerica\/Noronha\tAtlantic islands\n-BR\t-0127-04829\tAmerica\/Belem\tPara (east), Amapa\n-BR\t-0343-03830\tAmerica\/Fortaleza\tBrazil (northeast: MA, PI, CE, RN, PB)\n-BR\t-0803-03454\tAmerica\/Recife\tPernambuco\n-BR\t-0712-04812\tAmerica\/Araguaina\tTocantins\n-BR\t-0940-03543\tAmerica\/Maceio\tAlagoas, Sergipe\n-BR\t-1259-03831\tAmerica\/Bahia\tBahia\n-BR\t-2332-04637\tAmerica\/Sao_Paulo\tBrazil (southeast: GO, DF, MG, ES, RJ, SP, PR, SC, RS)\n-BR\t-2027-05437\tAmerica\/Campo_Grande\tMato Grosso do Sul\n-BR\t-1535-05605\tAmerica\/Cuiaba\tMato Grosso\n-BR\t-0226-05452\tAmerica\/Santarem\tPara (west)\n-BR\t-0846-06354\tAmerica\/Porto_Velho\tRondonia\n-BR\t+0249-06040\tAmerica\/Boa_Vista\tRoraima\n-BR\t-0308-06001\tAmerica\/Manaus\tAmazonas (east)\n-BR\t-0640-06952\tAmerica\/Eirunepe\tAmazonas (west)\n-BR\t-0958-06748\tAmerica\/Rio_Branco\tAcre\n-BS\t+2505-07721\tAmerica\/Nassau\n-BT\t+2728+08939\tAsia\/Thimphu\n-BW\t-2439+02555\tAfrica\/Gaborone\n-BY\t+5354+02734\tEurope\/Minsk\n-BZ\t+1730-08812\tAmerica\/Belize\n-CA\t+4734-05243\tAmerica\/St_Johns\tNewfoundland, Labrador (SE)\n-CA\t+4439-06336\tAmerica\/Halifax\tAtlantic - NS (most areas), PE\n-CA\t+4612-05957\tAmerica\/Glace_Bay\tAtlantic - NS (Cape Breton)\n-CA\t+4606-06447\tAmerica\/Moncton\tAtlantic - New Brunswick\n-CA\t+5320-06025\tAmerica\/Goose_Bay\tAtlantic - Labrador (most areas)\n-CA\t+5125-05707\tAmerica\/Blanc-Sablon\tAST - QC (Lower North Shore)\n-CA\t+4339-07923\tAmerica\/Toronto\tEastern - ON & QC (most areas)\n-CA\t+6344-06828\tAmerica\/Iqaluit\tEastern - NU (most areas)\n-CA\t+484531-0913718\tAmerica\/Atikokan\tEST - ON (Atikokan), NU (Coral H)\n-CA\t+4953-09709\tAmerica\/Winnipeg\tCentral - ON (west), Manitoba\n-CA\t+744144-0944945\tAmerica\/Resolute\tCentral - NU (Resolute)\n-CA\t+624900-0920459\tAmerica\/Rankin_Inlet\tCentral - NU (central)\n-CA\t+5024-10439\tAmerica\/Regina\tCST - SK (most areas)\n-CA\t+5017-10750\tAmerica\/Swift_Current\tCST - SK (midwest)\n-CA\t+5333-11328\tAmerica\/Edmonton\tMountain - AB, BC(E), NT(E), SK(W)\n-CA\t+690650-1050310\tAmerica\/Cambridge_Bay\tMountain - NU (west)\n-CA\t+682059-1334300\tAmerica\/Inuvik\tMountain - NT (west)\n-CA\t+4906-11631\tAmerica\/Creston\tMST - BC (Creston)\n-CA\t+5546-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n-CA\t+5848-12242\tAmerica\/Fort_Nelson\tMST - BC (Ft Nelson)\n-CA\t+6043-13503\tAmerica\/Whitehorse\tMST - Yukon (east)\n-CA\t+6404-13925\tAmerica\/Dawson\tMST - Yukon (west)\n-CA\t+4916-12307\tAmerica\/Vancouver\tPacific - BC (most areas)\n-CC\t-1210+09655\tIndian\/Cocos\n-CD\t-0418+01518\tAfrica\/Kinshasa\tDem. Rep. of Congo (west)\n-CD\t-1140+02728\tAfrica\/Lubumbashi\tDem. Rep. of Congo (east)\n-CF\t+0422+01835\tAfrica\/Bangui\n-CG\t-0416+01517\tAfrica\/Brazzaville\n-CH\t+4723+00832\tEurope\/Zurich\n-CI\t+0519-00402\tAfrica\/Abidjan\n-CK\t-2114-15946\tPacific\/Rarotonga\n-CL\t-3327-07040\tAmerica\/Santiago\tmost of Chile\n-CL\t-5309-07055\tAmerica\/Punta_Arenas\tRegion of Magallanes\n-CL\t-2709-10926\tPacific\/Easter\tEaster Island\n-CM\t+0403+00942\tAfrica\/Douala\n-CN\t+3114+12128\tAsia\/Shanghai\tBeijing Time\n-CN\t+4348+08735\tAsia\/Urumqi\tXinjiang Time\n-CO\t+0436-07405\tAmerica\/Bogota\n-CR\t+0956-08405\tAmerica\/Costa_Rica\n-CU\t+2308-08222\tAmerica\/Havana\n-CV\t+1455-02331\tAtlantic\/Cape_Verde\n-CW\t+1211-06900\tAmerica\/Curacao\n-CX\t-1025+10543\tIndian\/Christmas\n-CY\t+3510+03322\tAsia\/Nicosia\tmost of Cyprus\n-CY\t+3507+03357\tAsia\/Famagusta\tNorthern Cyprus\n-CZ\t+5005+01426\tEurope\/Prague\n-DE\t+5230+01322\tEurope\/Berlin\tmost of Germany\n-DE\t+4742+00841\tEurope\/Busingen\tBusingen\n-DJ\t+1136+04309\tAfrica\/Djibouti\n-DK\t+5540+01235\tEurope\/Copenhagen\n-DM\t+1518-06124\tAmerica\/Dominica\n-DO\t+1828-06954\tAmerica\/Santo_Domingo\n-DZ\t+3647+00303\tAfrica\/Algiers\n-EC\t-0210-07950\tAmerica\/Guayaquil\tEcuador (mainland)\n-EC\t-0054-08936\tPacific\/Galapagos\tGalapagos Islands\n-EE\t+5925+02445\tEurope\/Tallinn\n-EG\t+3003+03115\tAfrica\/Cairo\n-EH\t+2709-01312\tAfrica\/El_Aaiun\n-ER\t+1520+03853\tAfrica\/Asmara\n-ES\t+4024-00341\tEurope\/Madrid\tSpain (mainland)\n-ES\t+3553-00519\tAfrica\/Ceuta\tCeuta, Melilla\n-ES\t+2806-01524\tAtlantic\/Canary\tCanary Islands\n-ET\t+0902+03842\tAfrica\/Addis_Ababa\n-FI\t+6010+02458\tEurope\/Helsinki\n-FJ\t-1808+17825\tPacific\/Fiji\n-FK\t-5142-05751\tAtlantic\/Stanley\n-FM\t+0725+15147\tPacific\/Chuuk\tChuuk\/Truk, Yap\n-FM\t+0658+15813\tPacific\/Pohnpei\tPohnpei\/Ponape\n-FM\t+0519+16259\tPacific\/Kosrae\tKosrae\n-FO\t+6201-00646\tAtlantic\/Faroe\n-FR\t+4852+00220\tEurope\/Paris\n-GA\t+0023+00927\tAfrica\/Libreville\n-GB\t+513030-0000731\tEurope\/London\n-GD\t+1203-06145\tAmerica\/Grenada\n-GE\t+4143+04449\tAsia\/Tbilisi\n-GF\t+0456-05220\tAmerica\/Cayenne\n-GG\t+492717-0023210\tEurope\/Guernsey\n-GH\t+0533-00013\tAfrica\/Accra\n-GI\t+3608-00521\tEurope\/Gibraltar\n-GL\t+6411-05144\tAmerica\/Nuuk\tmost of Greenland\n-GL\t+7646-01840\tAmerica\/Danmarkshavn\tNational Park (east coast)\n-GL\t+7029-02158\tAmerica\/Scoresbysund\tScoresbysund\/Ittoqqortoormiit\n-GL\t+7634-06847\tAmerica\/Thule\tThule\/Pituffik\n-GM\t+1328-01639\tAfrica\/Banjul\n-GN\t+0931-01343\tAfrica\/Conakry\n-GP\t+1614-06132\tAmerica\/Guadeloupe\n-GQ\t+0345+00847\tAfrica\/Malabo\n-GR\t+3758+02343\tEurope\/Athens\n-GS\t-5416-03632\tAtlantic\/South_Georgia\n-GT\t+1438-09031\tAmerica\/Guatemala\n-GU\t+1328+14445\tPacific\/Guam\n-GW\t+1151-01535\tAfrica\/Bissau\n-GY\t+0648-05810\tAmerica\/Guyana\n-HK\t+2217+11409\tAsia\/Hong_Kong\n-HN\t+1406-08713\tAmerica\/Tegucigalpa\n-HR\t+4548+01558\tEurope\/Zagreb\n-HT\t+1832-07220\tAmerica\/Port-au-Prince\n-HU\t+4730+01905\tEurope\/Budapest\n-ID\t-0610+10648\tAsia\/Jakarta\tJava, Sumatra\n-ID\t-0002+10920\tAsia\/Pontianak\tBorneo (west, central)\n-ID\t-0507+11924\tAsia\/Makassar\tBorneo (east, south), Sulawesi\/Celebes, Bali, Nusa Tengarra, Timor (west)\n-ID\t-0232+14042\tAsia\/Jayapura\tNew Guinea (West Papua \/ Irian Jaya), Malukus\/Moluccas\n-IE\t+5320-00615\tEurope\/Dublin\n-IL\t+314650+0351326\tAsia\/Jerusalem\n-IM\t+5409-00428\tEurope\/Isle_of_Man\n-IN\t+2232+08822\tAsia\/Kolkata\n-IO\t-0720+07225\tIndian\/Chagos\n-IQ\t+3321+04425\tAsia\/Baghdad\n-IR\t+3540+05126\tAsia\/Tehran\n-IS\t+6409-02151\tAtlantic\/Reykjavik\n-IT\t+4154+01229\tEurope\/Rome\n-JE\t+491101-0020624\tEurope\/Jersey\n-JM\t+175805-0764736\tAmerica\/Jamaica\n-JO\t+3157+03556\tAsia\/Amman\n-JP\t+353916+1394441\tAsia\/Tokyo\n-KE\t-0117+03649\tAfrica\/Nairobi\n-KG\t+4254+07436\tAsia\/Bishkek\n-KH\t+1133+10455\tAsia\/Phnom_Penh\n-KI\t+0125+17300\tPacific\/Tarawa\tGilbert Islands\n-KI\t-0247-17143\tPacific\/Kanton\tPhoenix Islands\n-KI\t+0152-15720\tPacific\/Kiritimati\tLine Islands\n-KM\t-1141+04316\tIndian\/Comoro\n-KN\t+1718-06243\tAmerica\/St_Kitts\n-KP\t+3901+12545\tAsia\/Pyongyang\n-KR\t+3733+12658\tAsia\/Seoul\n-KW\t+2920+04759\tAsia\/Kuwait\n-KY\t+1918-08123\tAmerica\/Cayman\n-KZ\t+4315+07657\tAsia\/Almaty\tmost of Kazakhstan\n-KZ\t+4448+06528\tAsia\/Qyzylorda\tQyzylorda\/Kyzylorda\/Kzyl-Orda\n-KZ\t+5312+06337\tAsia\/Qostanay\tQostanay\/Kostanay\/Kustanay\n-KZ\t+5017+05710\tAsia\/Aqtobe\tAqtobe\/Aktobe\n-KZ\t+4431+05016\tAsia\/Aqtau\tMangghystau\/Mankistau\n-KZ\t+4707+05156\tAsia\/Atyrau\tAtyrau\/Atirau\/Gur'yev\n-KZ\t+5113+05121\tAsia\/Oral\tWest Kazakhstan\n-LA\t+1758+10236\tAsia\/Vientiane\n-LB\t+3353+03530\tAsia\/Beirut\n-LC\t+1401-06100\tAmerica\/St_Lucia\n-LI\t+4709+00931\tEurope\/Vaduz\n-LK\t+0656+07951\tAsia\/Colombo\n-LR\t+0618-01047\tAfrica\/Monrovia\n-LS\t-2928+02730\tAfrica\/Maseru\n-LT\t+5441+02519\tEurope\/Vilnius\n-LU\t+4936+00609\tEurope\/Luxembourg\n-LV\t+5657+02406\tEurope\/Riga\n-LY\t+3254+01311\tAfrica\/Tripoli\n-MA\t+3339-00735\tAfrica\/Casablanca\n-MC\t+4342+00723\tEurope\/Monaco\n-MD\t+4700+02850\tEurope\/Chisinau\n-ME\t+4226+01916\tEurope\/Podgorica\n-MF\t+1804-06305\tAmerica\/Marigot\n-MG\t-1855+04731\tIndian\/Antananarivo\n-MH\t+0709+17112\tPacific\/Majuro\tmost of Marshall Islands\n-MH\t+0905+16720\tPacific\/Kwajalein\tKwajalein\n-MK\t+4159+02126\tEurope\/Skopje\n-ML\t+1239-00800\tAfrica\/Bamako\n-MM\t+1647+09610\tAsia\/Yangon\n-MN\t+4755+10653\tAsia\/Ulaanbaatar\tmost of Mongolia\n-MN\t+4801+09139\tAsia\/Hovd\tBayan-Olgii, Hovd, Uvs\n-MO\t+221150+1133230\tAsia\/Macau\n-MP\t+1512+14545\tPacific\/Saipan\n-MQ\t+1436-06105\tAmerica\/Martinique\n-MR\t+1806-01557\tAfrica\/Nouakchott\n-MS\t+1643-06213\tAmerica\/Montserrat\n-MT\t+3554+01431\tEurope\/Malta\n-MU\t-2010+05730\tIndian\/Mauritius\n-MV\t+0410+07330\tIndian\/Maldives\n-MW\t-1547+03500\tAfrica\/Blantyre\n-MX\t+1924-09909\tAmerica\/Mexico_City\tCentral Mexico\n-MX\t+2105-08646\tAmerica\/Cancun\tQuintana Roo\n-MX\t+2058-08937\tAmerica\/Merida\tCampeche, Yucatan\n-MX\t+2540-10019\tAmerica\/Monterrey\tDurango; Coahuila, Nuevo Leon, Tamaulipas (most areas)\n-MX\t+2550-09730\tAmerica\/Matamoros\tCoahuila, Nuevo Leon, Tamaulipas (US border)\n-MX\t+2838-10605\tAmerica\/Chihuahua\tChihuahua (most areas)\n-MX\t+3144-10629\tAmerica\/Ciudad_Juarez\tChihuahua (US border - west)\n-MX\t+2934-10425\tAmerica\/Ojinaga\tChihuahua (US border - east)\n-MX\t+2313-10625\tAmerica\/Mazatlan\tBaja California Sur, Nayarit (most areas), Sinaloa\n-MX\t+2048-10515\tAmerica\/Bahia_Banderas\tBahia de Banderas\n-MX\t+2904-11058\tAmerica\/Hermosillo\tSonora\n-MX\t+3232-11701\tAmerica\/Tijuana\tBaja California\n-MY\t+0310+10142\tAsia\/Kuala_Lumpur\tMalaysia (peninsula)\n-MY\t+0133+11020\tAsia\/Kuching\tSabah, Sarawak\n-MZ\t-2558+03235\tAfrica\/Maputo\n-NA\t-2234+01706\tAfrica\/Windhoek\n-NC\t-2216+16627\tPacific\/Noumea\n-NE\t+1331+00207\tAfrica\/Niamey\n-NF\t-2903+16758\tPacific\/Norfolk\n-NG\t+0627+00324\tAfrica\/Lagos\n-NI\t+1209-08617\tAmerica\/Managua\n-NL\t+5222+00454\tEurope\/Amsterdam\n-NO\t+5955+01045\tEurope\/Oslo\n-NP\t+2743+08519\tAsia\/Kathmandu\n-NR\t-0031+16655\tPacific\/Nauru\n-NU\t-1901-16955\tPacific\/Niue\n-NZ\t-3652+17446\tPacific\/Auckland\tmost of New Zealand\n-NZ\t-4357-17633\tPacific\/Chatham\tChatham Islands\n-OM\t+2336+05835\tAsia\/Muscat\n-PA\t+0858-07932\tAmerica\/Panama\n-PE\t-1203-07703\tAmerica\/Lima\n-PF\t-1732-14934\tPacific\/Tahiti\tSociety Islands\n-PF\t-0900-13930\tPacific\/Marquesas\tMarquesas Islands\n-PF\t-2308-13457\tPacific\/Gambier\tGambier Islands\n-PG\t-0930+14710\tPacific\/Port_Moresby\tmost of Papua New Guinea\n-PG\t-0613+15534\tPacific\/Bougainville\tBougainville\n-PH\t+1435+12100\tAsia\/Manila\n-PK\t+2452+06703\tAsia\/Karachi\n-PL\t+5215+02100\tEurope\/Warsaw\n-PM\t+4703-05620\tAmerica\/Miquelon\n-PN\t-2504-13005\tPacific\/Pitcairn\n-PR\t+182806-0660622\tAmerica\/Puerto_Rico\n-PS\t+3130+03428\tAsia\/Gaza\tGaza Strip\n-PS\t+313200+0350542\tAsia\/Hebron\tWest Bank\n-PT\t+3843-00908\tEurope\/Lisbon\tPortugal (mainland)\n-PT\t+3238-01654\tAtlantic\/Madeira\tMadeira Islands\n-PT\t+3744-02540\tAtlantic\/Azores\tAzores\n-PW\t+0720+13429\tPacific\/Palau\n-PY\t-2516-05740\tAmerica\/Asuncion\n-QA\t+2517+05132\tAsia\/Qatar\n-RE\t-2052+05528\tIndian\/Reunion\n-RO\t+4426+02606\tEurope\/Bucharest\n-RS\t+4450+02030\tEurope\/Belgrade\n-RU\t+5443+02030\tEurope\/Kaliningrad\tMSK-01 - Kaliningrad\n-RU\t+554521+0373704\tEurope\/Moscow\tMSK+00 - Moscow area\n-# The obsolescent zone.tab format cannot represent Europe\/Simferopol well.\n-# Put it in RU section and list as UA.  See \"territorial claims\" above.\n-# Programs should use zone1970.tab instead; see above.\n-UA\t+4457+03406\tEurope\/Simferopol\tCrimea\n-RU\t+5836+04939\tEurope\/Kirov\tMSK+00 - Kirov\n-RU\t+4844+04425\tEurope\/Volgograd\tMSK+00 - Volgograd\n-RU\t+4621+04803\tEurope\/Astrakhan\tMSK+01 - Astrakhan\n-RU\t+5134+04602\tEurope\/Saratov\tMSK+01 - Saratov\n-RU\t+5420+04824\tEurope\/Ulyanovsk\tMSK+01 - Ulyanovsk\n-RU\t+5312+05009\tEurope\/Samara\tMSK+01 - Samara, Udmurtia\n-RU\t+5651+06036\tAsia\/Yekaterinburg\tMSK+02 - Urals\n-RU\t+5500+07324\tAsia\/Omsk\tMSK+03 - Omsk\n-RU\t+5502+08255\tAsia\/Novosibirsk\tMSK+04 - Novosibirsk\n-RU\t+5322+08345\tAsia\/Barnaul\tMSK+04 - Altai\n-RU\t+5630+08458\tAsia\/Tomsk\tMSK+04 - Tomsk\n-RU\t+5345+08707\tAsia\/Novokuznetsk\tMSK+04 - Kemerovo\n-RU\t+5601+09250\tAsia\/Krasnoyarsk\tMSK+04 - Krasnoyarsk area\n-RU\t+5216+10420\tAsia\/Irkutsk\tMSK+05 - Irkutsk, Buryatia\n-RU\t+5203+11328\tAsia\/Chita\tMSK+06 - Zabaykalsky\n-RU\t+6200+12940\tAsia\/Yakutsk\tMSK+06 - Lena River\n-RU\t+623923+1353314\tAsia\/Khandyga\tMSK+06 - Tomponsky, Ust-Maysky\n-RU\t+4310+13156\tAsia\/Vladivostok\tMSK+07 - Amur River\n-RU\t+643337+1431336\tAsia\/Ust-Nera\tMSK+07 - Oymyakonsky\n-RU\t+5934+15048\tAsia\/Magadan\tMSK+08 - Magadan\n-RU\t+4658+14242\tAsia\/Sakhalin\tMSK+08 - Sakhalin Island\n-RU\t+6728+15343\tAsia\/Srednekolymsk\tMSK+08 - Sakha (E), N Kuril Is\n-RU\t+5301+15839\tAsia\/Kamchatka\tMSK+09 - Kamchatka\n-RU\t+6445+17729\tAsia\/Anadyr\tMSK+09 - Bering Sea\n-RW\t-0157+03004\tAfrica\/Kigali\n-SA\t+2438+04643\tAsia\/Riyadh\n-SB\t-0932+16012\tPacific\/Guadalcanal\n-SC\t-0440+05528\tIndian\/Mahe\n-SD\t+1536+03232\tAfrica\/Khartoum\n-SE\t+5920+01803\tEurope\/Stockholm\n-SG\t+0117+10351\tAsia\/Singapore\n-SH\t-1555-00542\tAtlantic\/St_Helena\n-SI\t+4603+01431\tEurope\/Ljubljana\n-SJ\t+7800+01600\tArctic\/Longyearbyen\n-SK\t+4809+01707\tEurope\/Bratislava\n-SL\t+0830-01315\tAfrica\/Freetown\n-SM\t+4355+01228\tEurope\/San_Marino\n-SN\t+1440-01726\tAfrica\/Dakar\n-SO\t+0204+04522\tAfrica\/Mogadishu\n-SR\t+0550-05510\tAmerica\/Paramaribo\n-SS\t+0451+03137\tAfrica\/Juba\n-ST\t+0020+00644\tAfrica\/Sao_Tome\n-SV\t+1342-08912\tAmerica\/El_Salvador\n-SX\t+180305-0630250\tAmerica\/Lower_Princes\n-SY\t+3330+03618\tAsia\/Damascus\n-SZ\t-2618+03106\tAfrica\/Mbabane\n-TC\t+2128-07108\tAmerica\/Grand_Turk\n-TD\t+1207+01503\tAfrica\/Ndjamena\n-TF\t-492110+0701303\tIndian\/Kerguelen\n-TG\t+0608+00113\tAfrica\/Lome\n-TH\t+1345+10031\tAsia\/Bangkok\n-TJ\t+3835+06848\tAsia\/Dushanbe\n-TK\t-0922-17114\tPacific\/Fakaofo\n-TL\t-0833+12535\tAsia\/Dili\n-TM\t+3757+05823\tAsia\/Ashgabat\n-TN\t+3648+01011\tAfrica\/Tunis\n-TO\t-210800-1751200\tPacific\/Tongatapu\n-TR\t+4101+02858\tEurope\/Istanbul\n-TT\t+1039-06131\tAmerica\/Port_of_Spain\n-TV\t-0831+17913\tPacific\/Funafuti\n-TW\t+2503+12130\tAsia\/Taipei\n-TZ\t-0648+03917\tAfrica\/Dar_es_Salaam\n-UA\t+5026+03031\tEurope\/Kyiv\tmost of Ukraine\n-UG\t+0019+03225\tAfrica\/Kampala\n-UM\t+2813-17722\tPacific\/Midway\tMidway Islands\n-UM\t+1917+16637\tPacific\/Wake\tWake Island\n-US\t+404251-0740023\tAmerica\/New_York\tEastern (most areas)\n-US\t+421953-0830245\tAmerica\/Detroit\tEastern - MI (most areas)\n-US\t+381515-0854534\tAmerica\/Kentucky\/Louisville\tEastern - KY (Louisville area)\n-US\t+364947-0845057\tAmerica\/Kentucky\/Monticello\tEastern - KY (Wayne)\n-US\t+394606-0860929\tAmerica\/Indiana\/Indianapolis\tEastern - IN (most areas)\n-US\t+384038-0873143\tAmerica\/Indiana\/Vincennes\tEastern - IN (Da, Du, K, Mn)\n-US\t+410305-0863611\tAmerica\/Indiana\/Winamac\tEastern - IN (Pulaski)\n-US\t+382232-0862041\tAmerica\/Indiana\/Marengo\tEastern - IN (Crawford)\n-US\t+382931-0871643\tAmerica\/Indiana\/Petersburg\tEastern - IN (Pike)\n-US\t+384452-0850402\tAmerica\/Indiana\/Vevay\tEastern - IN (Switzerland)\n-US\t+415100-0873900\tAmerica\/Chicago\tCentral (most areas)\n-US\t+375711-0864541\tAmerica\/Indiana\/Tell_City\tCentral - IN (Perry)\n-US\t+411745-0863730\tAmerica\/Indiana\/Knox\tCentral - IN (Starke)\n-US\t+450628-0873651\tAmerica\/Menominee\tCentral - MI (Wisconsin border)\n-US\t+470659-1011757\tAmerica\/North_Dakota\/Center\tCentral - ND (Oliver)\n-US\t+465042-1012439\tAmerica\/North_Dakota\/New_Salem\tCentral - ND (Morton rural)\n-US\t+471551-1014640\tAmerica\/North_Dakota\/Beulah\tCentral - ND (Mercer)\n-US\t+394421-1045903\tAmerica\/Denver\tMountain (most areas)\n-US\t+433649-1161209\tAmerica\/Boise\tMountain - ID (south), OR (east)\n-US\t+332654-1120424\tAmerica\/Phoenix\tMST - AZ (except Navajo)\n-US\t+340308-1181434\tAmerica\/Los_Angeles\tPacific\n-US\t+611305-1495401\tAmerica\/Anchorage\tAlaska (most areas)\n-US\t+581807-1342511\tAmerica\/Juneau\tAlaska - Juneau area\n-US\t+571035-1351807\tAmerica\/Sitka\tAlaska - Sitka area\n-US\t+550737-1313435\tAmerica\/Metlakatla\tAlaska - Annette Island\n-US\t+593249-1394338\tAmerica\/Yakutat\tAlaska - Yakutat\n-US\t+643004-1652423\tAmerica\/Nome\tAlaska (west)\n-US\t+515248-1763929\tAmerica\/Adak\tAlaska - western Aleutians\n-US\t+211825-1575130\tPacific\/Honolulu\tHawaii\n-UY\t-345433-0561245\tAmerica\/Montevideo\n-UZ\t+3940+06648\tAsia\/Samarkand\tUzbekistan (west)\n-UZ\t+4120+06918\tAsia\/Tashkent\tUzbekistan (east)\n-VA\t+415408+0122711\tEurope\/Vatican\n-VC\t+1309-06114\tAmerica\/St_Vincent\n-VE\t+1030-06656\tAmerica\/Caracas\n-VG\t+1827-06437\tAmerica\/Tortola\n-VI\t+1821-06456\tAmerica\/St_Thomas\n-VN\t+1045+10640\tAsia\/Ho_Chi_Minh\n-VU\t-1740+16825\tPacific\/Efate\n-WF\t-1318-17610\tPacific\/Wallis\n-WS\t-1350-17144\tPacific\/Apia\n-YE\t+1245+04512\tAsia\/Aden\n-YT\t-1247+04514\tIndian\/Mayotte\n-ZA\t-2615+02800\tAfrica\/Johannesburg\n-ZM\t-1525+02817\tAfrica\/Lusaka\n-ZW\t-1750+03103\tAfrica\/Harare\n","filename":"src\/java.base\/share\/data\/tzdata\/zone.tab","additions":0,"deletions":470,"binary":false,"changes":470,"status":"deleted"},{"patch":"@@ -1295,1 +1295,2 @@\n-    when an `OutOfMemoryError` exception is first thrown. If the string\n+    when an `OutOfMemoryError` exception is first thrown by the JVM.\n+    If the string\n@@ -1299,0 +1300,4 @@\n+    This applies only to `OutOfMemoryError` exceptions caused by Java Heap\n+    exhaustion; it does not apply to `OutOfMemoryError` exceptions thrown\n+    directly from Java code, nor by the JVM for other types of resource\n+    exhaustion (such as native thread creation errors).\n@@ -1309,1 +1314,1 @@\n-    pointer of the currently executing method (`-XX:+PreserveFramePointer` . If\n+    pointer of the currently executing method (`-XX:+PreserveFramePointer`). If\n@@ -2192,1 +2197,1 @@\n-    exception is thrown. You can explicitly set the heap dump file path and\n+    exception is thrown by the JVM. You can explicitly set the heap dump file path and\n@@ -2196,0 +2201,4 @@\n+    This applies only to `OutOfMemoryError` exceptions caused by Java Heap\n+    exhaustion; it does not apply to `OutOfMemoryError` exceptions thrown\n+    directly from Java code, nor by the JVM for other types of resource\n+    exhaustion (such as native thread creation errors).\n","filename":"src\/java.base\/share\/man\/java.md","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -665,1 +665,1 @@\n-    -   {`-addprovider` *name* \\[`-providerarg` *arg*\\]: Add security provider\n+    -   {`-addprovider` *name* \\[`-providerarg` *arg*\\]}: Add security provider\n@@ -1620,1 +1620,1 @@\n-`cn=`*myname*`, ou=`*mygroup*`, o=`*mycompany*`, c=`*mycountry*).\n+`cn=`*myname*`, ou=`*mygroup*`, o=`*mycompany*`, c=`*mycountry*.\n@@ -1917,1 +1917,1 @@\n-    keystore information.)The `jarsigner` commands can read a keystore from any\n+    keystore information. The `jarsigner` commands can read a keystore from any\n","filename":"src\/java.base\/share\/man\/keytool.md","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -561,1 +561,3 @@\n-    offset = copystrings(buf, offset, &c->envv[0]);\n+    if (c->envv != NULL) {\n+        offset = copystrings(buf, offset, &c->envv[0]);\n+    }\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessImpl_md.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-                Thread connThread = new Thread(connector) {\n+                Thread connThread = new Thread(connector, \"LoopbackConnector\") {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -624,1 +624,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n@@ -736,1 +735,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n@@ -751,1 +749,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKFileChooserUI.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+\n@@ -29,0 +30,1 @@\n+import javax.swing.UIManager;\n@@ -38,0 +40,6 @@\n+        if (ui instanceof SynthOptionPaneUI) {\n+            Object value = super.getDefault(c, ui, key);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthDefaultLookup.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,6 +206,6 @@\n-\n-            \/\/ add this new custom media size name to MediaSize array\n-            if ((width > 0.0) && (length > 0.0)) {\n-                try {\n-                    new MediaSize(width, length, Size2DSyntax.INCH, value);\n-                } catch (IllegalArgumentException e) {\n+            if (value.getStandardMedia() == null) {\n+                \/\/ add this new custom media size name to MediaSize array\n+                if ((width > 0.0) && (length > 0.0)) {\n+                    try {\n+                        new MediaSize(width, length, Size2DSyntax.INCH, value);\n+                    } catch (IllegalArgumentException e) {\n@@ -215,1 +215,2 @@\n-                    new MediaSize(length, width, Size2DSyntax.INCH, value);\n+                        new MediaSize(length, width, Size2DSyntax.INCH, value);\n+                    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/CustomMediaSizeName.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,0 @@\n-    @SuppressWarnings(\"deprecation\")\n@@ -247,1 +246,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XComponentPeer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ Anonymous class\n@@ -781,1 +780,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XFileDialogPeer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XFramePeer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XMouseInfoPeer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindowPeer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,1 +276,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n@@ -298,1 +297,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n@@ -480,1 +478,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n@@ -521,1 +518,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n@@ -540,1 +536,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n@@ -977,1 +972,0 @@\n-    @SuppressWarnings(\"serial\") \/\/ anonymous class\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsFileChooserUI.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -292,1 +292,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ anonymous class\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsInternalFrameTitlePane.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,0 @@\n-    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WDialogPeer.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,4 +43,1 @@\n-#define dprintf(s) printf(s)\n-#define dprintf1(s, p1) printf(s, p1)\n-#define dprintf2(s, p1, p2) printf(s, p1, p2)\n-#define dprintf3(s, p1, p2, p3) printf(s, p1, p2, p3)\n+#define debug_printf(format, ...) printf(format, ##__VA_ARGS__)\n@@ -48,4 +45,1 @@\n-#define dprintf(s)\n-#define dprintf1(s, p1)\n-#define dprintf2(s, p1, p2)\n-#define dprintf3(s, p1, p2, p3)\n+#define debug_printf(format, ...)\n@@ -115,1 +109,1 @@\n-    dprintf(\"-establishContext\\n\");\n+    debug_printf(\"-establishContext\\n\");\n@@ -188,1 +182,1 @@\n-    dprintf1(\"-context: %x\\n\", context);\n+    debug_printf(\"-context: %x\\n\", context);\n@@ -193,1 +187,1 @@\n-    dprintf1(\"-size: %d\\n\", size);\n+    debug_printf(\"-size: %d\\n\", size);\n@@ -207,1 +201,1 @@\n-        dprintf1(\"-String: %s\\n\", mszReaders);\n+        debug_printf(\"-String: %s\\n\", mszReaders);\n@@ -233,2 +227,2 @@\n-    dprintf1(\"-cardhandle: %x\\n\", card);\n-    dprintf1(\"-protocol: %d\\n\", proto);\n+    debug_printf(\"-cardhandle: %x\\n\", card);\n+    debug_printf(\"-protocol: %d\\n\", proto);\n@@ -298,3 +292,3 @@\n-    dprintf1(\"-reader: %s\\n\", readerName);\n-    dprintf1(\"-status: %d\\n\", state);\n-    dprintf1(\"-protocol: %d\\n\", protocol);\n+    debug_printf(\"-reader: %s\\n\", readerName);\n+    debug_printf(\"-status: %d\\n\", state);\n+    debug_printf(\"-protocol: %d\\n\", protocol);\n@@ -326,1 +320,1 @@\n-    dprintf1(\"-disconnect: 0x%X\\n\", rv);\n+    debug_printf(\"-disconnect: 0x%X\\n\", rv);\n@@ -395,1 +389,1 @@\n-        dprintf3(\"-reader status %s: 0x%X, 0x%X\\n\", readerState[i].szReader,\n+        debug_printf(\"-reader status %s: 0x%X, 0x%X\\n\", readerState[i].szReader,\n@@ -420,1 +414,1 @@\n-    dprintf1(\"-beginTransaction: 0x%X\\n\", rv);\n+    debug_printf(\"-beginTransaction: 0x%X\\n\", rv);\n@@ -432,1 +426,1 @@\n-    dprintf1(\"-endTransaction: 0x%X\\n\", rv);\n+    debug_printf(\"-endTransaction: 0x%X\\n\", rv);\n","filename":"src\/java.smartcardio\/share\/native\/libj2pcsc\/pcsc.c","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.stream.Stream;\n@@ -34,1 +35,0 @@\n-import com.sun.tools.javac.code.Symbol.*;\n@@ -36,0 +36,2 @@\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.util.Assert;\n@@ -39,1 +41,0 @@\n-import com.sun.tools.javac.util.List;\n@@ -41,0 +42,1 @@\n+import com.sun.tools.javac.util.Names;\n@@ -42,1 +44,0 @@\n-import com.sun.tools.javac.util.Pair;\n@@ -52,2 +53,2 @@\n-public class Lint\n-{\n+public class Lint {\n+\n@@ -66,2 +67,9 @@\n-     * Returns the result of combining the values in this object with\n-     * the given annotation.\n+     * Obtain an instance with additional warning supression applied from any\n+     * @SuppressWarnings and\/or @Deprecated annotations on the given symbol.\n+     *\n+     * <p>\n+     * The returned instance will be different from this instance if and only if\n+     * {@link #suppressionsFrom} returns a non-empty set.\n+     *\n+     * @param sym symbol\n+     * @return lint instance with new warning suppressions applied, or this instance if none\n@@ -69,2 +77,9 @@\n-    public Lint augment(Attribute.Compound attr) {\n-        return augmentor.augment(this, attr);\n+    public Lint augment(Symbol sym) {\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(sym);\n+        if (!suppressions.isEmpty()) {\n+            Lint lint = new Lint(this);\n+            lint.values.removeAll(suppressions);\n+            lint.suppressedValues.addAll(suppressions);\n+            return lint;\n+        }\n+        return this;\n@@ -73,1 +88,0 @@\n-\n@@ -75,2 +89,2 @@\n-     * Returns the result of combining the values in this object with\n-     * the metadata on the given symbol.\n+     * Returns a new Lint that has the given LintCategorys enabled.\n+     * @param lc one or more categories to be enabled\n@@ -78,8 +92,4 @@\n-    public Lint augment(Symbol sym) {\n-        Lint l = augmentor.augment(this, sym.getDeclarationAttributes());\n-        if (sym.isDeprecated() && sym.isDeprecatableViaAnnotation()) {\n-            if (l == this)\n-                l = new Lint(this);\n-            l.values.remove(LintCategory.DEPRECATION);\n-            l.suppressedValues.add(LintCategory.DEPRECATION);\n-        }\n+    public Lint enable(LintCategory... lc) {\n+        Lint l = new Lint(this);\n+        l.values.addAll(Arrays.asList(lc));\n+        l.suppressedValues.removeAll(Arrays.asList(lc));\n@@ -100,1 +110,5 @@\n-    private final AugmentVisitor augmentor;\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily to avoid dependency loops\n+    private Symtab syms;\n+    private Names names;\n@@ -102,0 +116,1 @@\n+    \/\/ Invariant: it's never the case that a category is in both \"values\" and \"suppressedValues\"\n@@ -117,1 +132,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -120,1 +135,1 @@\n-            values = EnumSet.noneOf(LintCategory.class);\n+            values = LintCategory.newEmptySet();\n@@ -149,1 +164,1 @@\n-        suppressedValues = EnumSet.noneOf(LintCategory.class);\n+        suppressedValues = LintCategory.newEmptySet();\n@@ -151,0 +166,1 @@\n+        this.context = context;\n@@ -152,1 +168,0 @@\n-        augmentor = new AugmentVisitor(context);\n@@ -156,1 +171,3 @@\n-        this.augmentor = other.augmentor;\n+        this.context = other.context;\n+        this.syms = other.syms;\n+        this.names = other.names;\n@@ -163,1 +180,1 @@\n-        return \"Lint:[values\" + values + \" suppressedValues\" + suppressedValues + \"]\";\n+        return \"Lint:[enable\" + values + \",suppress\" + suppressedValues + \"]\";\n@@ -381,0 +398,5 @@\n+        public static EnumSet<LintCategory> newEmptySet() {\n+            return EnumSet.noneOf(LintCategory.class);\n+        }\n+\n+        \/** Get the string representing this category in @SuppressAnnotations and -Xlint options. *\/\n@@ -412,63 +434,16 @@\n-    protected static class AugmentVisitor implements Attribute.Visitor {\n-        private final Context context;\n-        private Symtab syms;\n-        private Lint parent;\n-        private Lint lint;\n-\n-        AugmentVisitor(Context context) {\n-            \/\/ to break an ugly sequence of initialization dependencies,\n-            \/\/ we defer the initialization of syms until it is needed\n-            this.context = context;\n-        }\n-\n-        Lint augment(Lint parent, Attribute.Compound attr) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            attr.accept(this);\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        Lint augment(Lint parent, List<Attribute.Compound> attrs) {\n-            initSyms();\n-            this.parent = parent;\n-            lint = null;\n-            for (Attribute.Compound a: attrs) {\n-                a.accept(this);\n-            }\n-            return (lint == null ? parent : lint);\n-        }\n-\n-        private void initSyms() {\n-            if (syms == null)\n-                syms = Symtab.instance(context);\n-        }\n-\n-        private void suppress(LintCategory lc) {\n-            if (lint == null)\n-                lint = new Lint(parent);\n-            lint.suppressedValues.add(lc);\n-            lint.values.remove(lc);\n-        }\n-\n-        public void visitConstant(Attribute.Constant value) {\n-            if (value.type.tsym == syms.stringType.tsym) {\n-                LintCategory.get((String)value.value)\n-                  .ifPresent(this::suppress);\n-            }\n-        }\n-\n-        public void visitClass(Attribute.Class clazz) {\n-        }\n-\n-        \/\/ If we find a @SuppressWarnings annotation, then we continue\n-        \/\/ walking the tree, in order to suppress the individual warnings\n-        \/\/ specified in the @SuppressWarnings annotation.\n-        public void visitCompound(Attribute.Compound compound) {\n-            if (compound.type.tsym == syms.suppressWarningsType.tsym) {\n-                for (List<Pair<MethodSymbol,Attribute>> v = compound.values;\n-                     v.nonEmpty(); v = v.tail) {\n-                    Pair<MethodSymbol,Attribute> value = v.head;\n-                    if (value.fst.name.toString().equals(\"value\"))\n-                        value.snd.accept(this);\n-                }\n+    \/**\n+     * Obtain the set of recognized lint warning categories suppressed at the given symbol's declaration.\n+     *\n+     * <p>\n+     * This set can be non-empty only if the symbol is annotated with either\n+     * @SuppressWarnings or @Deprecated.\n+     *\n+     * @param symbol symbol corresponding to a possibly-annotated declaration\n+     * @return new warning suppressions applied to sym\n+     *\/\n+    public EnumSet<LintCategory> suppressionsFrom(Symbol symbol) {\n+        EnumSet<LintCategory> suppressions = suppressionsFrom(symbol.getDeclarationAttributes().stream());\n+        if (symbol.isDeprecated() && symbol.isDeprecatableViaAnnotation())\n+            suppressions.add(LintCategory.DEPRECATION);\n+        return suppressions;\n+    }\n@@ -476,2 +451,13 @@\n-            }\n-        }\n+    \/**\n+     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n+     *\n+     * @param annotation @SuppressWarnings annotation, or null\n+     * @return set of lint categories, possibly empty but never null\n+     *\/\n+    private EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n+        initializeIfNeeded();\n+        if (annotation == null)\n+            return LintCategory.newEmptySet();\n+        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n+        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n+    }\n@@ -479,4 +465,10 @@\n-        public void visitArray(Attribute.Array array) {\n-            for (Attribute value : array.values)\n-                value.accept(this);\n-        }\n+    \/\/ Find the @SuppressWarnings annotation in the given stream and extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Stream<Attribute.Compound> attributes) {\n+        initializeIfNeeded();\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        attributes\n+          .filter(attribute -> attribute.type.tsym == syms.suppressWarningsType.tsym)\n+          .map(this::suppressionsFrom)\n+          .forEach(result::addAll);\n+        return result;\n+    }\n@@ -484,1 +476,8 @@\n-        public void visitEnum(Attribute.Enum e) {\n+    \/\/ Given a @SuppressWarnings annotation, extract the recognized suppressions\n+    private EnumSet<LintCategory> suppressionsFrom(Attribute.Compound suppressWarnings) {\n+        EnumSet<LintCategory> result = LintCategory.newEmptySet();\n+        Attribute.Array values = (Attribute.Array)suppressWarnings.member(names.value);\n+        for (Attribute value : values.values) {\n+            Optional.of((String)((Attribute.Constant)value).value)\n+              .flatMap(LintCategory::get)\n+              .ifPresent(result::add);\n@@ -486,0 +485,2 @@\n+        return result;\n+    }\n@@ -487,1 +488,4 @@\n-        public void visitError(Attribute.Error e) {\n+    private void initializeIfNeeded() {\n+        if (syms == null) {\n+            syms = Symtab.instance(context);\n+            names = Names.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":103,"deletions":99,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3049,0 +3049,1 @@\n+    \/\/ Apply special flag \"-XDwarnOnAccessToMembers\" which turns on just this particular warning for all types of access\n@@ -3050,4 +3051,11 @@\n-        if (warnOnAnyAccessToMembers ||\n-            (lint.isEnabled(LintCategory.SERIAL) &&\n-            !lint.isSuppressed(LintCategory.SERIAL) &&\n-            isLambda)) {\n+        final Lint prevLint = setLint(warnOnAnyAccessToMembers ? lint.enable(LintCategory.SERIAL) : lint);\n+        try {\n+            if (warnOnAnyAccessToMembers || isLambda)\n+                checkAccessFromSerializableElementInner(tree, isLambda);\n+        } finally {\n+            setLint(prevLint);\n+        }\n+    }\n+\n+    private void checkAccessFromSerializableElementInner(final JCTree tree, boolean isLambda) {\n+        if (lint.isEnabled(LintCategory.SERIAL)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,5 +61,6 @@\n-        TRANSTYPES(6),\n-        TRANSPATTERNS(7),\n-        LOWER(8),\n-        UNLAMBDA(9),\n-        GENERATE(10);\n+        WARN(6),\n+        TRANSTYPES(7),\n+        TRANSPATTERNS(8),\n+        LOWER(9),\n+        UNLAMBDA(10),\n+        GENERATE(11);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,1 +232,0 @@\n-        new ThisEscapeAnalyzer(names, syms, types, rs, log, lint).analyzeTree(env);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+import com.sun.tools.javac.util.Context;\n@@ -143,0 +144,5 @@\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n@@ -144,1 +150,5 @@\n-class ThisEscapeAnalyzer extends TreeScanner {\n+public class ThisEscapeAnalyzer extends TreeScanner {\n+\n+    protected static final Context.Key<ThisEscapeAnalyzer> contextKey = new Context.Key<>();\n+\n+\/\/ Other singletons we utilize\n@@ -214,1 +224,1 @@\n-\/\/ Constructor\n+\/\/ Access\n@@ -216,7 +226,16 @@\n-    ThisEscapeAnalyzer(Names names, Symtab syms, Types types, Resolve rs, Log log, Lint lint) {\n-        this.names = names;\n-        this.syms = syms;\n-        this.types = types;\n-        this.rs = rs;\n-        this.log = log;\n-        this.lint = lint;\n+    public static ThisEscapeAnalyzer instance(Context context) {\n+        ThisEscapeAnalyzer instance = context.get(contextKey);\n+        if (instance == null)\n+            instance = new ThisEscapeAnalyzer(context);\n+        return instance;\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ThisEscapeAnalyzer(Context context) {\n+        context.put(contextKey, this);\n+        names = Names.instance(context);\n+        log = Log.instance(context);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        rs = Resolve.instance(context);\n+        lint = Lint.instance(context);\n@@ -230,0 +249,18 @@\n+        try {\n+            doAnalyzeTree(env);\n+        } finally {\n+            attrEnv = null;\n+            methodMap.clear();\n+            nonPublicOuters.clear();\n+            targetClass = null;\n+            warningList.clear();\n+            methodClass = null;\n+            callStack.clear();\n+            invocations.clear();\n+            pendingWarning = null;\n+            depth = -1;\n+            refs = null;\n+        }\n+    }\n+\n+    private void doAnalyzeTree(Env<AttrContext> env) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1171,1 +1171,1 @@\n-            \"The current compile state [%s] of class %s is previous to FLOW\";\n+            \"The current compile state [%s] of class %s is previous to WARN\";\n@@ -1192,1 +1192,1 @@\n-         *  2) has a compile state which is previous to Flow state.\n+         *  2) has a compile state which is previous to WARN state.\n@@ -1200,1 +1200,1 @@\n-                CompileState.FLOW.isAfter(compileStates.get(myEnv))) {\n+                CompileState.WARN.isAfter(compileStates.get(myEnv))) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Log;\n+\n+\/** This pass checks for various things to warn about.\n+ *  It runs after attribution and flow analysis.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class WarningAnalyzer {\n+\n+    protected static final Context.Key<WarningAnalyzer> contextKey = new Context.Key<>();\n+\n+    private final Log log;\n+    private final ThisEscapeAnalyzer thisEscapeAnalyzer;\n+\n+    public static WarningAnalyzer instance(Context context) {\n+        WarningAnalyzer instance = context.get(contextKey);\n+        if (instance == null)\n+            instance = new WarningAnalyzer(context);\n+        return instance;\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected WarningAnalyzer(Context context) {\n+        context.put(contextKey, this);\n+        log = Log.instance(context);\n+        thisEscapeAnalyzer = ThisEscapeAnalyzer.instance(context);\n+    }\n+\n+    public void analyzeTree(Env<AttrContext> env) {\n+        thisEscapeAnalyzer.analyzeTree(env);\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/WarningAnalyzer.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -93,1 +94,2 @@\n-        boolean warn = options.isLintSet(\"path\");\n+        boolean warn = options.isLintSet(LintCategory.PATH.option);\n+        boolean fileClashOption = options.isLintSet(LintCategory.OUTPUT_FILE_CLASH.option);\n@@ -95,0 +97,2 @@\n+\n+        \/\/ Only track file clashes if enabled\n@@ -96,1 +100,1 @@\n-            outputFilesWritten = options.isLintSet(\"output-file-clash\") ? new HashSet<>() : null;\n+            outputFilesWritten = fileClashOption ? new HashSet<>() : null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,0 +309,4 @@\n+    \/** The warning analyzer.\n+     *\/\n+    protected WarningAnalyzer warningAnalyzer;\n+\n@@ -422,0 +426,1 @@\n+        warningAnalyzer = WarningAnalyzer.instance(context);\n@@ -965,1 +970,1 @@\n-                    generate(desugar(flow(attribute(todo))));\n+                    generate(desugar(warn(flow(attribute(todo)))));\n@@ -971,1 +976,1 @@\n-                            generate(desugar(flow(attribute(q.remove()))));\n+                            generate(desugar(warn(flow(attribute(q.remove())))));\n@@ -978,1 +983,1 @@\n-                        generate(desugar(flow(attribute(todo.remove()))));\n+                        generate(desugar(warn(flow(attribute(todo.remove())))));\n@@ -1438,0 +1443,50 @@\n+    \/**\n+     * Check for various things to warn about.\n+     *\n+     * @return the list of attributed parse trees\n+     *\/\n+    public Queue<Env<AttrContext>> warn(Queue<Env<AttrContext>> envs) {\n+        ListBuffer<Env<AttrContext>> results = new ListBuffer<>();\n+        for (Env<AttrContext> env: envs) {\n+            warn(env, results);\n+        }\n+        return stopIfError(CompileState.WARN, results);\n+    }\n+\n+    \/**\n+     * Check for various things to warn about in an attributed parse tree.\n+     *\/\n+    public Queue<Env<AttrContext>> warn(Env<AttrContext> env) {\n+        ListBuffer<Env<AttrContext>> results = new ListBuffer<>();\n+        warn(env, results);\n+        return stopIfError(CompileState.WARN, results);\n+    }\n+\n+    \/**\n+     * Check for various things to warn about in an attributed parse tree.\n+     *\/\n+    protected void warn(Env<AttrContext> env, Queue<Env<AttrContext>> results) {\n+        if (compileStates.isDone(env, CompileState.WARN)) {\n+            results.add(env);\n+            return;\n+        }\n+\n+        if (shouldStop(CompileState.WARN))\n+            return;\n+\n+        if (verboseCompilePolicy)\n+            printNote(\"[warn \" + env.enclClass.sym + \"]\");\n+        JavaFileObject prev = log.useSource(\n+                                            env.enclClass.sym.sourcefile != null ?\n+                                            env.enclClass.sym.sourcefile :\n+                                            env.toplevel.sourcefile);\n+        try {\n+            warningAnalyzer.analyzeTree(env);\n+            compileStates.put(env, CompileState.WARN);\n+            results.add(env);\n+        }\n+        finally {\n+            log.useSource(prev);\n+        }\n+    }\n+\n@@ -1496,0 +1551,4 @@\n+        \/\/ Ensure the file has reached the WARN state\n+        if (!compileStates.isDone(env, CompileState.WARN))\n+            warn(env);\n+\n@@ -1579,2 +1638,2 @@\n-        if (!compileStates.isDone(dep, CompileState.FLOW))\n-            desugaredEnvs.put(dep, desugar(flow(attribute(dep))));\n+        if (!compileStates.isDone(dep, CompileState.WARN))\n+            desugaredEnvs.put(dep, desugar(warn(flow(attribute(dep)))));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":65,"deletions":6,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-     * Report an error at the given position using the provided arguments.\n+     * Report a warning at the given position using the provided arguments.\n@@ -227,1 +227,1 @@\n-    protected void lexWarning(int pos, JCDiagnostic.Warning key) {\n+    protected void lexWarning(int pos, JCDiagnostic.LintWarning key) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,2 @@\n-    private EnumSet<LintCategory> nonSilentLintSet = EnumSet.noneOf(LintCategory.class);\n-    private EnumSet<LintCategory> silentLintSet = EnumSet.noneOf(LintCategory.class);\n+    private EnumSet<LintCategory> nonSilentLintSet = LintCategory.newEmptySet();\n+    private EnumSet<LintCategory> silentLintSet = LintCategory.newEmptySet();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Warner.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/classfile,java\/lang\/classfile\/attribute,java\/lang\/classfile\/constantpool,java\/lang\/classfile\/instruction,java\/lang\/constant,java\/lang\/foreign,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert,jdk\/internal\/event[jdk.jfr],jdk\/internal\/javac[java.compiler\\u005C;u002C;java.desktop\\u005C;u002C;java.se\\u005C;u002C;jdk.compiler\\u005C;u002C;jdk.incubator.vector\\u005C;u002C;jdk.jartool\\u005C;u002C;jdk.jdeps\\u005C;u002C;jdk.jfr\\u005C;u002C;jdk.jlink\\u005C;u002C;jdk.jshell],jdk\/internal\/vm\/vector[jdk.incubator.vector] extraModulePackages jdk\/internal\/access\/foreign,jdk\/internal\/classfile\/impl,jdk\/internal\/constant,jdk\/internal\/foreign\/abi,jdk\/internal\/foreign\/abi\/aarch64\/linux,jdk\/internal\/foreign\/abi\/aarch64\/macos,jdk\/internal\/foreign\/abi\/aarch64\/windows,jdk\/internal\/foreign\/abi\/fallback,jdk\/internal\/foreign\/abi\/ppc64\/aix,jdk\/internal\/foreign\/abi\/ppc64\/linux,jdk\/internal\/foreign\/abi\/riscv64\/linux,jdk\/internal\/foreign\/abi\/s390\/linux,jdk\/internal\/foreign\/abi\/x64\/sysv,jdk\/internal\/foreign\/abi\/x64\/windows,jdk\/internal\/foreign\/layout,sun\/nio\/ch,sun\/net,jdk\/internal\/foreign,jdk\/internal\/foreign,sun\/net,sun\/nio\/ch uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/InetAddressResolverProvider,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/io\/JdkConsoleProvider,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider target macos-aarch64 flags 8000\n+header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/classfile,java\/lang\/classfile\/attribute,java\/lang\/classfile\/constantpool,java\/lang\/classfile\/instruction,java\/lang\/constant,java\/lang\/foreign,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert,jdk\/internal\/event[jdk.jfr],jdk\/internal\/javac[java.compiler\\u005C;u002C;java.desktop\\u005C;u002C;jdk.compiler\\u005C;u002C;jdk.incubator.vector\\u005C;u002C;jdk.jartool\\u005C;u002C;jdk.jdeps\\u005C;u002C;jdk.jfr\\u005C;u002C;jdk.jlink\\u005C;u002C;jdk.jshell],jdk\/internal\/vm\/vector[jdk.incubator.vector] extraModulePackages jdk\/internal\/access\/foreign,jdk\/internal\/classfile\/impl,jdk\/internal\/constant,jdk\/internal\/foreign\/abi,jdk\/internal\/foreign\/abi\/aarch64\/linux,jdk\/internal\/foreign\/abi\/aarch64\/macos,jdk\/internal\/foreign\/abi\/aarch64\/windows,jdk\/internal\/foreign\/abi\/fallback,jdk\/internal\/foreign\/abi\/ppc64\/aix,jdk\/internal\/foreign\/abi\/ppc64\/linux,jdk\/internal\/foreign\/abi\/riscv64\/linux,jdk\/internal\/foreign\/abi\/s390\/linux,jdk\/internal\/foreign\/abi\/x64\/sysv,jdk\/internal\/foreign\/abi\/x64\/windows,jdk\/internal\/foreign\/layout,sun\/nio\/ch,sun\/net,jdk\/internal\/foreign,jdk\/internal\/foreign,sun\/net,sun\/nio\/ch uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/InetAddressResolverProvider,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/io\/JdkConsoleProvider,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider target macos-aarch64 flags 8000\n@@ -973,0 +973,1 @@\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n@@ -976,0 +977,1 @@\n+method name toDebugString descriptor ()Ljava\/lang\/String; flags 1\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-O.sym.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-header requires name\\u0020;java.base\\u0020;flags\\u0020;20,name\\u0020;java.compiler\\u0020;flags\\u0020;20,name\\u0020;java.datatransfer\\u0020;flags\\u0020;20,name\\u0020;java.desktop\\u0020;flags\\u0020;20,name\\u0020;java.instrument\\u0020;flags\\u0020;20,name\\u0020;java.logging\\u0020;flags\\u0020;20,name\\u0020;java.management\\u0020;flags\\u0020;20,name\\u0020;java.management.rmi\\u0020;flags\\u0020;20,name\\u0020;java.naming\\u0020;flags\\u0020;20,name\\u0020;java.net.http\\u0020;flags\\u0020;20,name\\u0020;java.prefs\\u0020;flags\\u0020;20,name\\u0020;java.rmi\\u0020;flags\\u0020;20,name\\u0020;java.scripting\\u0020;flags\\u0020;20,name\\u0020;java.security.jgss\\u0020;flags\\u0020;20,name\\u0020;java.security.sasl\\u0020;flags\\u0020;20,name\\u0020;java.sql\\u0020;flags\\u0020;20,name\\u0020;java.sql.rowset\\u0020;flags\\u0020;20,name\\u0020;java.transaction.xa\\u0020;flags\\u0020;20,name\\u0020;java.xml\\u0020;flags\\u0020;20,name\\u0020;java.xml.crypto\\u0020;flags\\u0020;20 target macos-aarch64 flags 8000 classAnnotations @Ljdk\/internal\/javac\/ParticipatesInPreview;\n+header requires name\\u0020;java.base\\u0020;flags\\u0020;20,name\\u0020;java.compiler\\u0020;flags\\u0020;20,name\\u0020;java.datatransfer\\u0020;flags\\u0020;20,name\\u0020;java.desktop\\u0020;flags\\u0020;20,name\\u0020;java.instrument\\u0020;flags\\u0020;20,name\\u0020;java.logging\\u0020;flags\\u0020;20,name\\u0020;java.management\\u0020;flags\\u0020;20,name\\u0020;java.management.rmi\\u0020;flags\\u0020;20,name\\u0020;java.naming\\u0020;flags\\u0020;20,name\\u0020;java.net.http\\u0020;flags\\u0020;20,name\\u0020;java.prefs\\u0020;flags\\u0020;20,name\\u0020;java.rmi\\u0020;flags\\u0020;20,name\\u0020;java.scripting\\u0020;flags\\u0020;20,name\\u0020;java.security.jgss\\u0020;flags\\u0020;20,name\\u0020;java.security.sasl\\u0020;flags\\u0020;20,name\\u0020;java.sql\\u0020;flags\\u0020;20,name\\u0020;java.sql.rowset\\u0020;flags\\u0020;20,name\\u0020;java.transaction.xa\\u0020;flags\\u0020;20,name\\u0020;java.xml\\u0020;flags\\u0020;20,name\\u0020;java.xml.crypto\\u0020;flags\\u0020;20 target macos-aarch64 flags 8000\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.se-O.sym.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1670,1 +1670,1 @@\n-      }  catch (NullPointerException(); {\n+      }  catch (NullPointerException e) {\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    dprintf2(\"-version >=%s: %d\\n\", requiredVersion, res);\n+    debug_printf(\"-version >=%s: %d\\n\", requiredVersion, res);\n@@ -149,1 +149,1 @@\n-    dprintf1(\"-res: %d\\n\", res);\n+    debug_printf(\"-res: %d\\n\", res);\n@@ -153,1 +153,1 @@\n-            dprintf1(\"-NSS error: %d\\n\", getError());\n+            debug_printf(\"-NSS error: %d\\n\", getError());\n@@ -176,1 +176,1 @@\n-        dprintf(\"-getmodulelist function not found\\n\");\n+        debug_printf(\"-getmodulelist function not found\\n\");\n@@ -181,1 +181,1 @@\n-        dprintf(\"-module list is null\\n\");\n+        debug_printf(\"-module list is null\\n\");\n@@ -214,6 +214,6 @@\n-        dprintf1(\"-commonname: %s\\n\", module->commonName);\n-        dprintf1(\"-dllname: %s\\n\", (module->dllName != NULL) ? module->dllName : \"NULL\");\n-        dprintf1(\"-slots: %d\\n\", module->slotCount);\n-        dprintf1(\"-loaded: %d\\n\", module->loaded);\n-        dprintf1(\"-internal: %d\\n\", module->internal);\n-        dprintf1(\"-fips: %d\\n\", module->isFIPS);\n+        debug_printf(\"-commonname: %s\\n\", module->commonName);\n+        debug_printf(\"-dllname: %s\\n\", (module->dllName != NULL) ? module->dllName : \"NULL\");\n+        debug_printf(\"-slots: %d\\n\", module->slotCount);\n+        debug_printf(\"-loaded: %d\\n\", module->loaded);\n+        debug_printf(\"-internal: %d\\n\", module->internal);\n+        debug_printf(\"-fips: %d\\n\", module->isFIPS);\n@@ -251,1 +251,1 @@\n-    dprintf(\"-ok\\n\");\n+    debug_printf(\"-ok\\n\");\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/j2secmod.c","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,4 +40,1 @@\n-#define dprintf(s) printf(s)\n-#define dprintf1(s, p1) printf(s, p1)\n-#define dprintf2(s, p1, p2) printf(s, p1, p2)\n-#define dprintf3(s, p1, p2, p3) printf(s, p1, p2, p3)\n+#define debug_printf(format, ...) printf(format, ##__VA_ARGS__)\n@@ -45,4 +42,1 @@\n-#define dprintf(s)\n-#define dprintf1(s, p1)\n-#define dprintf2(s, p1, p2)\n-#define dprintf3(s, p1, p2, p3)\n+#define debug_printf(format, ...)\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/j2secmod.h","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    dprintf2(\"-handle for %s: %u\\n\", libName, hModule);\n+    debug_printf(\"-handle for %s: %u\\n\", libName, hModule);\n@@ -78,1 +78,1 @@\n-    dprintf1(\"-lib %s\\n\", libName);\n+    debug_printf(\"-lib %s\\n\", libName);\n@@ -81,1 +81,1 @@\n-    dprintf2(\"-handle: %u (0X%X)\\n\", hModule, hModule);\n+    debug_printf(\"-handle: %u (0X%X)\\n\", hModule, hModule);\n","filename":"src\/jdk.crypto.cryptoki\/unix\/native\/libj2pkcs11\/j2secmod_md.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    dprintf2(\"-handle for %s: %d\\n\", libName, hModule);\n+    debug_printf(\"-handle for %s: %d\\n\", libName, hModule);\n@@ -66,1 +66,1 @@\n-    dprintf1(\"-lib %s\\n\", libName);\n+    debug_printf(\"-lib %s\\n\", libName);\n@@ -83,1 +83,1 @@\n-        dprintf1(\"-error: %s\\n\", lpMsgBuf);\n+        debug_printf(\"-error: %s\\n\", lpMsgBuf);\n@@ -88,1 +88,1 @@\n-    dprintf2(\"-handle: %d (0X%X)\\n\", hModule, hModule);\n+    debug_printf(\"-handle: %d (0X%X)\\n\", hModule, hModule);\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/j2secmod_md.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  * module descriptor.\n+  * and java.base's module descriptors.\n","filename":"src\/jdk.graal.compiler\/share\/classes\/module-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,5 +78,0 @@\n-\n-  \/\/ get flags written to .class files\n-  public int getStandardFlags() {\n-    return (int) (flags & JVM_ACC_WRITTEN_FLAGS);\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/AccessFlags.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,8 +101,0 @@\n-    \/\/ from accessFlags.hpp - hotspot internal flags\n-\n-    \/\/ flags actually put in .class file\n-    public static final long JVM_ACC_WRITTEN_FLAGS = 0x00007FFF;\n-\n-    \/\/ flags accepted by set_field_flags\n-    public static final long JVM_ACC_FIELD_FLAGS = 0x00008000 | JVM_ACC_WRITTEN_FLAGS;\n-\n@@ -110,1 +102,0 @@\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ClassConstants.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,2 +111,0 @@\n- * @param <E> the boxed version of {@code ETYPE},\n- *           the element type of a vector\n@@ -131,0 +129,3 @@\n+ *\n+ * @param <E> the boxed version of {@code ETYPE},\n+ *           the element type of a vector\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-                final String tmpbase = (fname == null)\n+                String tmpFilePrefix = (fname == null)\n@@ -321,2 +321,4 @@\n-\n-                tmpFile = createTemporaryFile(tmpbase, \".jar\");\n+                if (tmpFilePrefix.length() < 3) {\n+                    tmpFilePrefix = \"tmpjar\" + tmpFilePrefix;\n+                }\n+                tmpFile = createTemporaryFile(tmpFilePrefix, \".jar\");\n@@ -1778,1 +1780,2 @@\n-            \/\/ Were unable to create temporary file, fall back to temporary file in the same folder\n+            \/\/ We were unable to create temporary file, fall back to temporary file in the\n+            \/\/ same folder as the JAR file\n@@ -1782,1 +1785,1 @@\n-                    tmpfile = File.createTempFile(fname, \".tmp\" + suffix, tmpfolder);\n+                    tmpfile = File.createTempFile(tmpbase, \".tmp\" + suffix, tmpfolder);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -356,3 +356,4 @@\n-                        String n = we.name + \".\" + subField.getName();\n-                        String l = we.label + \" : \" + makeLabel(subField, false);\n-                        if (stack.size() < 2) { \/\/ Limit depth to 2\n+                        \/\/ Limit depth to 2\n+                        if (!we.name.contains(\".\")) {\n+                            String n = we.name + \".\" + subField.getName();\n+                            String l = we.label + \" : \" + makeLabel(subField, false);\n@@ -372,1 +373,0 @@\n-            field.index = result.size();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            return createPercentile(field, 0.9999);\n+            return createPercentile(field, 0.999);\n@@ -178,3 +178,3 @@\n-                long s = seconds \/ count;\n-                long n = nanos \/ count;\n-                return Duration.ofSeconds(s, n);\n+                double total = 1_000_000_000.0 * seconds + nanos;\n+                double average = total \/ count;\n+                return Duration.ofNanos(Math.round(average));\n@@ -581,1 +581,1 @@\n-            double fraction = doubleIndex - valueIndex;\n+            double fraction = doubleIndex - (int) doubleIndex;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Function.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+        applyIndex();\n@@ -106,0 +107,7 @@\n+    private void applyIndex() {\n+        int index = 0;\n+        for (Field field : resultFields) {\n+            field.index = index++;\n+        }\n+    }\n+\n@@ -241,1 +249,0 @@\n-            field.index = resultFields.size();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryResolver.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -280,8 +280,0 @@\n-            if (options.modulePath.isEmpty()) {\n-                \/\/ no --module-path specified - try to set $JAVA_HOME\/jmods if that exists\n-                Path jmods = getDefaultModulePath();\n-                if (jmods != null) {\n-                    options.modulePath.add(jmods);\n-                }\n-            }\n-\n@@ -380,0 +372,4 @@\n+        \/\/ Empty module path not allowed with ALL-MODULE-PATH in --add-modules\n+        if (options.addMods.contains(ALL_MODULE_PATH) && options.modulePath.isEmpty()) {\n+            throw taskHelper.newBadArgs(\"err.no.module.path\");\n+        }\n@@ -382,0 +378,1 @@\n+\n@@ -396,2 +393,3 @@\n-                options.modulePath.add(defModPath);\n-                finder = newModuleFinder(options.modulePath);\n+                List<Path> combinedPaths = new ArrayList<>(options.modulePath);\n+                combinedPaths.add(defModPath);\n+                finder = newModuleFinder(combinedPaths);\n@@ -422,2 +420,25 @@\n-                ModuleFinder mf = newLimitedFinder(finder, options.limitMods,\n-                                              Set.of());\n+                \/\/ Using --limit-modules with ALL-MODULE-PATH is an error\n+                if (!options.limitMods.isEmpty()) {\n+                    throw taskHelper.newBadArgs(\"err.limit.modules\");\n+                }\n+                \/\/ all observable modules in the app module path are roots\n+                Set<String> initialRoots = appModuleFinder.findAll()\n+                        .stream()\n+                        .map(ModuleReference::descriptor)\n+                        .map(ModuleDescriptor::name)\n+                        .collect(Collectors.toSet());\n+\n+                \/\/ Error if no module is found on the app module path\n+                if (initialRoots.isEmpty()) {\n+                    String modPath = options.modulePath.stream()\n+                            .map(a -> a.toString())\n+                            .collect(Collectors.joining(\", \"));\n+                    throw taskHelper.newBadArgs(\"err.empty.module.path\", modPath);\n+                }\n+\n+                \/\/ Use a module finder with limited observability, as determined\n+                \/\/ by initialRoots, to find the observable modules from the\n+                \/\/ application module path (--module-path option) only. We must\n+                \/\/ not include JDK modules from the default module path or the\n+                \/\/ run-time image.\n+                ModuleFinder mf = limitFinder(finder, initialRoots, Set.of());\n@@ -433,1 +454,1 @@\n-        finder = newLimitedFinder(finder, options.limitMods, roots);\n+        finder = limitFinder(finder, options.limitMods, roots);\n@@ -500,1 +521,1 @@\n-    public static ModuleFinder newLimitedFinder(ModuleFinder finder,\n+    public static ModuleFinder limitFinder(ModuleFinder finder,\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/JlinkTask.java","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n@@ -52,0 +55,1 @@\n+        public InputStream getResource(String name);\n@@ -74,1 +78,0 @@\n-                byte[] baseBytes = base.getResourceBytes(item);\n@@ -85,1 +88,1 @@\n-                           .setResourceBytes(baseBytes)\n+                           .setResourceBytes(base.getResourceBytes(item))\n@@ -91,2 +94,1 @@\n-                boolean contentEquals = Arrays.equals(baseBytes, image.getResourceBytes(item));\n-                if (!contentEquals) {\n+                if (!compareStreams(base.getResource(item), image.getResource(item))) {\n@@ -97,1 +99,1 @@\n-                        .setResourceBytes(baseBytes)\n+                        .setResourceBytes(base.getResourceBytes(item))\n@@ -115,0 +117,47 @@\n+    \/**\n+     * Compare the contents of the two input streams (byte-by-byte).\n+     *\n+     * @param is1 The first input stream\n+     * @param is2 The second input stream\n+     * @return {@code true} iff the two streams contain the same number of\n+     *         bytes and each byte of the streams are equal. {@code false}\n+     *         otherwise.\n+     *\/\n+    private boolean compareStreams(InputStream is1, InputStream is2) {\n+        byte[] buf1 = new byte[1024];\n+        byte[] buf2 = new byte[1024];\n+        int bytesRead1, bytesRead2 = 0;\n+        try {\n+            try (is1; is2) {\n+                while ((bytesRead1 = is1.read(buf1)) != -1 &&\n+                       (bytesRead2 = is2.read(buf2)) != -1) {\n+                    if (bytesRead1 != bytesRead2) {\n+                        return false;\n+                    }\n+                    if (bytesRead1 == buf1.length) {\n+                        if (!Arrays.equals(buf1, buf2)) {\n+                            return false;\n+                        }\n+                    } else {\n+                        for (int i = 0; i < bytesRead1; i++) {\n+                            if (buf1[i] != buf2[i]) {\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                }\n+                \/\/ ensure we read both to the end\n+                if (bytesRead1 == -1) {\n+                    bytesRead2 = is2.read(buf2);\n+                    if (bytesRead2 != -1) {\n+                        return false;\n+                    }\n+                    return true;\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(\"IO exception when comparing bytes\", e);\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/JimageDiffGenerator.java","additions":54,"deletions":5,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.io.InputStream;\n@@ -59,0 +60,5 @@\n+    @Override\n+    public InputStream getResource(String name) {\n+        return pool.findEntry(name).orElseThrow().content();\n+    }\n+\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/runtimelink\/ResourcePoolReader.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,1 +130,3 @@\n-err.empty.module.path=empty module path\n+err.no.module.path=--module-path option must be specified with --add-modules ALL-MODULE-PATH\n+err.empty.module.path=No module found in module path ''{0}'' with --add-modules ALL-MODULE-PATH\n+err.limit.modules=--limit-modules not allowed with --add-modules ALL-MODULE-PATH\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/resources\/jlink.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.LAYOUT_NODE_DEGREE_COMPARATOR;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n+import java.util.*;\n+\n+public class FreeInteractiveLayoutManager extends LayoutManager implements LayoutMover {\n+\n+    private boolean cutEdges = false;\n+\n+    private static final int LINE_OFFSET = 10;\n+\n+    private Map<Vertex, LayoutNode> layoutNodes;\n+\n+    private LayoutGraph prevGraph;\n+\n+    private final Random random = new Random(42);\n+\n+    \/\/ Constants for offsets and displacements\n+    private static final int MAX_OFFSET_AROUND_NEIGHBOR = 200; \/\/ Max offset for random positioning around a neighbor\n+    private static final int MAX_OFFSET_AROUND_ORIGIN = 200; \/\/ Max offset for random positioning around origin\n+    private static final int DISPLACEMENT_RANGE_BARYCENTER = 100; \/\/ Displacement range for barycenter calculation\n+    private static final int DISPLACEMENT_RANGE_SINGLE = 200;\n+\n+    \/\/ Create a comparator to sort nodes by the number of unassigned neighbors\n+    private final Comparator<LayoutNode> LeastUnassignedNeighborsComparator = Comparator.comparingInt(node -> {\n+        Vertex vertex = node.getVertex();\n+        int unassignedNeighbors = 0;\n+        for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+            if (!layoutNodes.containsKey(neighborVertex)) {\n+                unassignedNeighbors++;\n+            }\n+        }\n+        return unassignedNeighbors;\n+    });\n+\n+    public FreeInteractiveLayoutManager() {\n+        this.cutEdges = false;\n+        this.layoutNodes = new HashMap<>();\n+        this.prevGraph = null;\n+    }\n+\n+    @Override\n+    public void moveLink(Point linkPos, int shiftX) {}\n+\n+    @Override\n+    public void moveVertices(Set<? extends Vertex> movedVertices) {\n+        for (Vertex v : movedVertices) {\n+            moveVertex(v);\n+        }\n+    }\n+\n+    @Override\n+    public void moveVertex(Vertex vertex) {\n+        assert prevGraph.containsVertex(vertex);\n+        LayoutNode layoutNode = layoutNodes.get(vertex);\n+        layoutNode.setX(vertex.getPosition().x);\n+        layoutNode.setY(vertex.getPosition().y);\n+        for (Link link : prevGraph.getAllLinks(vertex)) {\n+            setLinkControlPoints(link);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isFreeForm() {\n+        return true;\n+    }\n+\n+    public void setCutEdges(boolean enable) {\n+        this.cutEdges = enable;\n+    }\n+\n+    @Override\n+    public void doLayout(LayoutGraph graph) {\n+        prevGraph = graph;\n+        if (layoutNodes.isEmpty()) {\n+            HierarchicalLayoutManager manager = new HierarchicalLayoutManager();\n+            manager.doLayout(graph);\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                node.initSize();\n+                layoutNodes.put(node.getVertex(), node);\n+            }\n+            graph.clearLayout();\n+        } else {\n+            \/\/ add new vertices to layoutNodes, x\/y from barycenter\n+            List<LayoutNode> newLayoutNodes = new ArrayList<>();\n+\n+            \/\/ Set up layout nodes for each vertex\n+            for (Vertex vertex : prevGraph.getVertices()) {\n+                if (!layoutNodes.containsKey(vertex)) {\n+                    LayoutNode addedNode = new LayoutNode(vertex);\n+                    addedNode.initSize();\n+                    newLayoutNodes.add(addedNode);\n+                }\n+            }\n+\n+            positionNewLayoutNodes(newLayoutNodes);\n+        }\n+\n+        \/\/ Write back vertices\n+        for (Vertex vertex : prevGraph.getVertices()) {\n+            LayoutNode layoutNode = layoutNodes.get(vertex);\n+            layoutNode.setVertex(vertex);\n+            vertex.setPosition(new Point(layoutNode.getLeft(), layoutNode.getTop()));\n+        }\n+\n+        \/\/ Write back links\n+        for (Link link : prevGraph.getLinks()) {\n+            setLinkControlPoints(link);\n+        }\n+    }\n+\n+    public void positionNewLayoutNodes(List<LayoutNode> newLayoutNodes) {\n+        \/\/ First pass: Initial positioning based on unassigned neighbors\n+        newLayoutNodes.sort(LeastUnassignedNeighborsComparator);\n+\n+        for (LayoutNode node : newLayoutNodes) {\n+            Vertex vertex = node.getVertex();\n+\n+            \/\/ Gather assigned neighbors\n+            List<LayoutNode> assignedNeighbors = new ArrayList<>();\n+            for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+                if (layoutNodes.containsKey(neighborVertex)) {\n+                    assignedNeighbors.add(layoutNodes.get(neighborVertex));\n+                }\n+            }\n+\n+            if (!assignedNeighbors.isEmpty()) {\n+                if (assignedNeighbors.size() == 1) {\n+                    \/\/ Single neighbor: position around the neighbor\n+                    setPositionAroundSingleNode(node, assignedNeighbors.get(0), DISPLACEMENT_RANGE_SINGLE);\n+                } else {\n+                    \/\/ Multiple neighbors: Calculate barycenter with displacement\n+                    calculateBarycenterWithDisplacement(node, assignedNeighbors, DISPLACEMENT_RANGE_BARYCENTER);\n+                }\n+            } else {\n+                \/\/ No neighbors: Position randomly around (0, 0)\n+                setRandomPositionAroundOrigin(node, random);\n+            }\n+\n+            \/\/ Add the new node to the layout\n+            layoutNodes.put(vertex, node);\n+        }\n+\n+        \/\/ Second pass: Refine positions based on neighbor degree\n+        newLayoutNodes.sort(LAYOUT_NODE_DEGREE_COMPARATOR.reversed());\n+\n+        \/\/ Collect all nodes (existing and new)\n+        Collection<LayoutNode> allNodes = layoutNodes.values();\n+\n+        for (LayoutNode node : newLayoutNodes) {\n+            Vertex vertex = node.getVertex();\n+\n+            \/\/ Gather assigned neighbors\n+            List<LayoutNode> assignedNeighbors = new ArrayList<>();\n+            for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+                if (layoutNodes.containsKey(neighborVertex)) {\n+                    assignedNeighbors.add(layoutNodes.get(neighborVertex));\n+                }\n+            }\n+\n+            if (!assignedNeighbors.isEmpty()) {\n+                \/\/ Refine position based on force-based method\n+                applyForceBasedAdjustment(node, assignedNeighbors, allNodes);\n+            }\n+\n+            \/\/ Ensure node's position remains updated in the layout\n+            layoutNodes.put(vertex, node);\n+        }\n+    }\n+\n+    \/**\n+     * Applies a force-based adjustment to the position of a given layout node\n+     * based on repulsive forces from all other nodes and attractive forces from its assigned neighbors.\n+     * <p>\n+     * This method simulates a physical system where nodes repel each other to maintain spacing\n+     * and are pulled towards their neighbors to maintain connectivity. The forces are calculated\n+     * using Coulomb's law for repulsion and Hooke's law for attraction. The system iterates for\n+     * a fixed number of iterations to stabilize the position of the node.\n+     *\n+     * @param node               The node whose position is being adjusted.\n+     * @param assignedNeighbors  A list of neighboring nodes that attract this node.\n+     * @param allNodes           A collection of all nodes in the layout, used for repulsive forces.\n+     *\/\n+    private void applyForceBasedAdjustment(LayoutNode node, List<LayoutNode> assignedNeighbors, Collection<LayoutNode> allNodes) {\n+        \/\/ Constants for force-based adjustment\n+        final int ITERATIONS = 50; \/\/ Number of simulation iterations\n+        final double REPULSION_CONSTANT = 1000; \/\/ Magnitude of repulsive forces (Coulomb's law)\n+        final double SPRING_CONSTANT = 0.2; \/\/ Strength of attractive forces to neighbors (Hooke's law)\n+        final double DAMPING = 0.8; \/\/ Factor to reduce displacement and ensure stability\n+        final double IDEAL_LENGTH = 100; \/\/ Desired distance between a node and its neighbors\n+        final double MAX_FORCE = 1000; \/\/ Upper limit for the magnitude of applied forces\n+        final double CONVERGENCE_THRESHOLD = 0.01; \/\/ Force threshold for stopping early\n+\n+        double posX = node.getX();\n+        double posY = node.getY();\n+        double dx = 0, dy = 0; \/\/ Displacement\n+\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            double netForceX = 0;\n+            double netForceY = 0;\n+\n+            \/\/ Repulsive forces from all other nodes\n+            for (LayoutNode otherNode : allNodes) {\n+                if (otherNode == node) continue; \/\/ Skip self\n+\n+                double deltaX = posX - otherNode.getX();\n+                double deltaY = posY - otherNode.getY();\n+                double distanceSquared = deltaX * deltaX + deltaY * deltaY;\n+                double distance = Math.sqrt(distanceSquared);\n+\n+                \/\/ Avoid division by zero by introducing a minimum distance\n+                if (distance < 1e-6) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05;\n+                    deltaY = random.nextDouble() * 0.1 - 0.05;\n+                    distanceSquared = deltaX * deltaX + deltaY * deltaY;\n+                    distance = Math.sqrt(distanceSquared);\n+                }\n+\n+                \/\/ Repulsive force (Coulomb's law)\n+                double repulsiveForce = REPULSION_CONSTANT \/ distanceSquared;\n+\n+                \/\/ Normalize force to prevent large displacements\n+                if (repulsiveForce > MAX_FORCE) repulsiveForce = MAX_FORCE;\n+\n+                netForceX += (deltaX \/ distance) * repulsiveForce;\n+                netForceY += (deltaY \/ distance) * repulsiveForce;\n+            }\n+\n+            \/\/ Attractive forces to assigned neighbors\n+            for (LayoutNode neighbor : assignedNeighbors) {\n+                double deltaX = neighbor.getX() - posX;\n+                double deltaY = neighbor.getY() - posY;\n+                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n+\n+                if (distance < 1e-6) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05;\n+                    deltaY = random.nextDouble() * 0.1 - 0.05;\n+                    distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n+                }\n+\n+                \/\/ Attractive force (Hooke's law)\n+                double displacement = distance - IDEAL_LENGTH;\n+                double attractiveForce = SPRING_CONSTANT * displacement;\n+\n+                if (attractiveForce > MAX_FORCE) attractiveForce = MAX_FORCE;\n+\n+                netForceX += (deltaX \/ distance) * attractiveForce;\n+                netForceY += (deltaY \/ distance) * attractiveForce;\n+            }\n+\n+            \/\/ Apply damping and update displacement\n+            dx = (dx + netForceX) * DAMPING;\n+            dy = (dy + netForceY) * DAMPING;\n+\n+            \/\/ Scale displacement if it's too large\n+            double displacementMagnitude = Math.sqrt(dx * dx + dy * dy);\n+            if (displacementMagnitude > MAX_FORCE) {\n+                dx *= MAX_FORCE \/ displacementMagnitude;\n+                dy *= MAX_FORCE \/ displacementMagnitude;\n+            }\n+\n+            \/\/ Update position\n+            posX += dx;\n+            posY += dy;\n+\n+            \/\/ Stop early if the net force is negligible\n+            if (Math.abs(netForceX) < CONVERGENCE_THRESHOLD && Math.abs(netForceY) < CONVERGENCE_THRESHOLD) {\n+                break;\n+            }\n+\n+            \/\/ Validate position to avoid invalid or extreme values\n+            if (Double.isNaN(posX) || Double.isInfinite(posX) || Double.isNaN(posY) || Double.isInfinite(posY)) {\n+                posX = node.getX(); \/\/ Reset to original position\n+                posY = node.getY();\n+                break;\n+            }\n+        }\n+\n+        \/\/ Set final position\n+        node.setX((int) Math.round(posX));\n+        node.setY((int) Math.round(posY));\n+    }\n+\n+    \/\/ Utility method: position around a given node\n+    private void setPositionAroundSingleNode(LayoutNode node, LayoutNode neighbor, int displacement) {\n+        boolean neighborIsPredecessor = prevGraph.isPredecessorVertex(node.getVertex(), neighbor.getVertex());\n+        boolean neighborIsSuccessor = prevGraph.isSuccessorVertex(node.getVertex(), neighbor.getVertex());\n+\n+        int shiftY = 0;\n+        if (neighborIsPredecessor) {\n+            shiftY = displacement;\n+        } else if (neighborIsSuccessor) {\n+            shiftY = -displacement;\n+        }\n+        assert shiftY != 0;\n+\n+        int randomY = neighbor.getY() + random.nextInt(MAX_OFFSET_AROUND_NEIGHBOR + 1) + shiftY;\n+        int randomX = neighbor.getX() + random.nextInt(MAX_OFFSET_AROUND_NEIGHBOR + 1);\n+        node.setX(randomX);\n+        node.setY(randomY);\n+    }\n+\n+    \/\/ Utility method: Random position around origin\n+    private void setRandomPositionAroundOrigin(LayoutNode node, Random random) {\n+        int randomX = random.nextInt(MAX_OFFSET_AROUND_ORIGIN + 1);\n+        int randomY = random.nextInt(MAX_OFFSET_AROUND_ORIGIN + 1);\n+        node.setX(randomX);\n+        node.setY(randomY);\n+    }\n+\n+    \/\/ Utility method: Calculate barycenter with displacement\n+    private void calculateBarycenterWithDisplacement(LayoutNode node, List<LayoutNode> neighbors, int displacementRange) {\n+        double barycenterX = 0, barycenterY = 0;\n+        for (LayoutNode neighbor : neighbors) {\n+            barycenterX += neighbor.getX();\n+            barycenterY += neighbor.getY();\n+        }\n+        barycenterX \/= neighbors.size();\n+        barycenterY \/= neighbors.size();\n+\n+        \/\/ Add random displacement for slight separation\n+        int displacementX = random.nextInt(displacementRange + 1);\n+        int displacementY = random.nextInt(displacementRange + 1);\n+        node.setX((int) barycenterX + displacementX);\n+        node.setY((int) barycenterY + displacementY);\n+    }\n+\n+    \/**\n+     * Sets control points for a given link based on its start and end layout nodes.\n+     * <p>\n+     * Calculates the start and end points, applies offsets for curvature, and updates\n+     * the link's control points.\n+     *\n+     * @param link The link to process.\n+     *\/\n+    private void setLinkControlPoints(Link link) {\n+        if (link.getFrom().getVertex() == link.getTo().getVertex()) return; \/\/ Skip self-links\n+\n+        LayoutNode from = layoutNodes.get(link.getFrom().getVertex());\n+        from.setVertex(link.getFrom().getVertex());\n+        from.updateSize();\n+\n+        LayoutNode to = layoutNodes.get(link.getTo().getVertex());\n+        to.setVertex(link.getTo().getVertex());\n+        to.updateSize();\n+\n+        Point startPoint = new Point(from.getLeft() + link.getFrom().getRelativePosition().x, from.getBottom());\n+        Point endPoint = new Point(to.getLeft() + link.getTo().getRelativePosition().x, to.getTop());\n+\n+        List<Point> controlPoints = new ArrayList<>();\n+        controlPoints.add(startPoint);\n+        controlPoints.add(new Point(startPoint.x, startPoint.y + LINE_OFFSET));\n+        controlPoints.add(new Point(endPoint.x, endPoint.y - LINE_OFFSET));\n+        controlPoints.add(endPoint);\n+\n+        link.setControlPoints(controlPoints);\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/FreeInteractiveLayoutManager.java","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -56,0 +56,5 @@\n+   @Override\n+    public boolean isFreeForm() {\n+        return false;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,1 +172,1 @@\n-     * @return An unmodifiable list containing all nodes in the graph.\n+     * @return An unmodifiable list containing all nodes in the graph\n@@ -450,0 +450,57 @@\n+    \/**\n+     * Checks if the given predecessorVertex is a direct predecessor of the specified vertex.\n+     *\n+     * @param vertex The vertex to check for predecessors.\n+     * @param predecessorVertex The vertex to verify as a predecessor of the given vertex.\n+     * @return true if predecessorVertex is a direct predecessor of vertex, false otherwise.\n+     *\/\n+    public boolean isPredecessorVertex(Vertex vertex, Vertex predecessorVertex) {\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link inputLink : portLinks.getOrDefault(inputPort, Collections.emptySet())) {\n+                Vertex fromVertex = inputLink.getFrom().getVertex();\n+                if (fromVertex.equals(predecessorVertex)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Checks if the given successorVertex is a direct successor of the specified vertex.\n+     *\n+     * @param vertex The vertex to check for successors.\n+     * @param successorVertex The vertex to verify as a successor of the given vertex.\n+     * @return true if successorVertex is a direct successor of vertex, false otherwise.\n+     *\/\n+    public boolean isSuccessorVertex(Vertex vertex, Vertex successorVertex) {\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link outputLink : portLinks.getOrDefault(outputPort, Collections.emptySet())) {\n+                Vertex toVertex = outputLink.getTo().getVertex();\n+                if (toVertex.equals(successorVertex)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public List<Vertex> getNeighborVertices(Vertex vertex) {\n+        List<Vertex> neighborVertices = new ArrayList<>();\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link inputLink : portLinks.getOrDefault(inputPort, Collections.emptySet())) {\n+                Vertex fromVertex = inputLink.getFrom().getVertex();\n+                assert fromVertex != null;\n+                neighborVertices.add(fromVertex);\n+            }\n+        }\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link outputLink : portLinks.getOrDefault(outputPort, Collections.emptySet())) {\n+                Vertex toVertex = outputLink.getTo().getVertex();\n+                assert toVertex != null;\n+                neighborVertices.add(toVertex);\n+            }\n+        }\n+        return neighborVertices;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutGraph.java","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+\n+    boolean isFreeForm();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutMover.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,6 +110,1 @@\n-    \/**\n-     * Initializes the size and margins of the node.\n-     * If the node represents a real vertex, it uses the vertex's size.\n-     * Dummy nodes use default dimensions.\n-     *\/\n-    public void initSize() {\n+    public void updateSize() {\n@@ -124,0 +119,9 @@\n+    }\n+\n+    \/**\n+     * Initializes the size and margins of the node.\n+     * If the node represents a real vertex, it uses the vertex's size.\n+     * Dummy nodes use default dimensions.\n+     *\/\n+    public void initSize() {\n+        updateSize();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutNode.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+        public static final int INTERACTIVE_FREE_NODES = 4;\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    private final FreeInteractiveLayoutManager freeInteractiveLayoutManager;\n@@ -514,0 +515,1 @@\n+        freeInteractiveLayoutManager = new FreeInteractiveLayoutManager();\n@@ -646,0 +648,2 @@\n+                if (layoutMover.isFreeForm()) return;\n+\n@@ -705,2 +709,6 @@\n-                int shiftY = magnetToStartLayerY(widget, location);\n-\n+                int shiftY;\n+                if (layoutMover.isFreeForm()) {\n+                    shiftY = location.y - widget.getLocation().y;\n+                } else {\n+                    shiftY = magnetToStartLayerY(widget, location);\n+                }\n@@ -716,1 +724,0 @@\n-                                Point toPt = lw.getTo();\n@@ -718,4 +725,8 @@\n-                                if (toPt != null && fromPt != null) {\n-                                    int xTo = toPt.x + shiftX;\n-                                    int yTo = toPt.y + shiftY;\n-                                    lw.setTo(new Point(xTo, yTo));\n+                                Point toPt = lw.getTo();\n+                                if (toPt == null || fromPt == null) {\n+                                    continue;\n+                                }\n+                                int xTo = toPt.x + shiftX;\n+                                int yTo = toPt.y + shiftY;\n+                                lw.setTo(new Point(xTo, yTo));\n+                                if (!layoutMover.isFreeForm()) {\n@@ -738,4 +749,7 @@\n-                                if (toPt != null && fromPt != null) {\n-                                    int xFrom = fromPt.x + shiftX;\n-                                    int yFrom = fromPt.y + shiftY;\n-                                    lw.setFrom(new Point(xFrom, yFrom));\n+                                if (toPt == null || fromPt == null) {\n+                                    continue;\n+                                }\n+                                int xFrom = fromPt.x + shiftX;\n+                                int yFrom = fromPt.y + shiftY;\n+                                lw.setFrom(new Point(xFrom, yFrom));\n+                                if (!layoutMover.isFreeForm()) {\n@@ -756,4 +770,6 @@\n-                FigureWidget fw = getWidget(selectedFigures.iterator().next());\n-                pointerWidget.setVisible(true);\n-                Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n-                ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                if (selectedFigures.size() == 1 && !layoutMover.isFreeForm()) {\n+                    FigureWidget fw = getWidget(selectedFigures.iterator().next());\n+                    pointerWidget.setVisible(true);\n+                    Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n+                    ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                }\n@@ -837,1 +853,3 @@\n-        if (getModel().getShowStableSea()) {\n+        if (getModel().getShowFreeInteractive()) {\n+            doFreeInteractiveLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowStableSea()) {\n@@ -907,0 +925,6 @@\n+    private void doFreeInteractiveLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        layoutMover = freeInteractiveLayoutManager;\n+        freeInteractiveLayoutManager.setCutEdges(model.getCutEdges());\n+        freeInteractiveLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n+    }\n+\n@@ -1111,0 +1135,46 @@\n+    private void processFreeForm(OutputSlot outputSlot, List<FigureConnection> connections) {\n+        for (FigureConnection connection : connections) {\n+            if (isVisibleFigureConnection(connection)) {\n+                boolean isBold = false;\n+                boolean isDashed = true;\n+                boolean isVisible = true;\n+                if (connection.getStyle() == Connection.ConnectionStyle.BOLD) {\n+                    isBold = true;\n+                } else if (connection.getStyle() == Connection.ConnectionStyle.INVISIBLE) {\n+                    isVisible = false;\n+                }\n+                if (connection.getStyle() != Connection.ConnectionStyle.DASHED) {\n+                    isDashed = false;\n+                }\n+\n+\n+                List<Point> controlPoints = connection.getControlPoints();\n+                if (controlPoints.size() <= 2) continue;\n+                Point firstPoint = controlPoints.get(0); \/\/ First point\n+                Point lastPoint = controlPoints.get(controlPoints.size() - 1); \/\/ Last point\n+                List<FigureConnection> connectionList = new ArrayList<>(Collections.singleton(connection));\n+                LineWidget line = new LineWidget(this, outputSlot, connectionList, firstPoint, lastPoint, null, isBold, isDashed);\n+                line.setFromControlYOffset(50);\n+                line.setToControlYOffset(-50);\n+                line.setVisible(isVisible);\n+                connectionLayer.addChild(line);\n+\n+                addObject(new ConnectionSet(connectionList), line);\n+                line.getActions().addAction(hoverAction);\n+\n+                if (outputSlotToLineWidget.containsKey(outputSlot)) {\n+                    outputSlotToLineWidget.get(outputSlot).add(line);\n+                } else {\n+                    outputSlotToLineWidget.put(outputSlot, new HashSet<>(Collections.singleton(line)));\n+                }\n+\n+                InputSlot inputSlot = connection.getInputSlot();\n+                if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                    inputSlotToLineWidget.get(inputSlot).add(line);\n+                } else {\n+                    inputSlotToLineWidget.put(inputSlot, new HashSet<>(Collections.singleton(line)));\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1284,1 +1354,5 @@\n-                processOutputSlot(outputSlot, connectionList, 0, null, null);\n+                if (layoutMover != null && layoutMover.isFreeForm()) {\n+                    processFreeForm(outputSlot, connectionList);\n+                } else {\n+                    processOutputSlot(outputSlot, connectionList, 0, null, null);\n+                }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":91,"deletions":17,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private boolean showFreeInteractive;\n@@ -107,0 +108,11 @@\n+    public boolean getShowFreeInteractive() {\n+        return showFreeInteractive;\n+    }\n+\n+    public void setShowFreeInteractive(boolean enable) {\n+        showFreeInteractive = enable;\n+        if (enable) {\n+            diagramChangedEvent.fire();\n+        }\n+    }\n+\n@@ -227,0 +239,1 @@\n+        showFreeInteractive = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.INTERACTIVE_FREE_NODES;\n@@ -269,1 +282,1 @@\n-        if (nodes.size() >= 1) {\n+        if (!nodes.isEmpty()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -179,0 +179,5 @@\n+        JToggleButton freeInteractiveLayoutButton = new JToggleButton(new EnableFreeLayoutAction(this));\n+        freeInteractiveLayoutButton.setSelected(diagramViewModel.getShowFreeInteractive());\n+        layoutButtons.add(freeInteractiveLayoutButton);\n+        toolBar.add(freeInteractiveLayoutButton);\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.actions;\n+\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n+import java.beans.PropertyChangeEvent;\n+\n+public class EnableFreeLayoutAction extends EnableLayoutAction {\n+\n+    public EnableFreeLayoutAction(EditorTopComponent etc) {\n+        super(etc);\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/dynamic.png\";\n+    }\n+\n+    @Override\n+    protected String getDescription() {\n+        return \"Show dynamic free layout\";\n+    }\n+\n+    @Override\n+    public void propertyChange(PropertyChangeEvent evt) {\n+        editor.getModel().setShowFreeInteractive(this.isSelected());\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/EnableFreeLayoutAction.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.hotspot.igv.view.actions.CustomSelectAction;\n@@ -35,0 +34,1 @@\n+import java.awt.geom.CubicCurve2D;\n@@ -41,0 +41,2 @@\n+\n+import com.sun.hotspot.igv.view.actions.CustomSelectAction;\n@@ -73,0 +75,2 @@\n+    private int fromControlYOffset;\n+    private int toControlYOffset;\n@@ -175,0 +179,10 @@\n+    public void setFromControlYOffset(int fromControlYOffset) {\n+        this.fromControlYOffset = fromControlYOffset;\n+        computeClientArea();\n+    }\n+\n+    public void setToControlYOffset(int toControlYOffset) {\n+        this.toControlYOffset = toControlYOffset;\n+        computeClientArea();\n+    }\n+\n@@ -228,1 +242,35 @@\n-        g.drawLine(from.x, from.y, to.x, to.y);\n+        \/\/ Define S-shaped curve with control points\n+        if (fromControlYOffset != 0 && toControlYOffset != 0) {\n+            if (from.y < to.y) { \/\/ non-reversed edges\n+                if (Math.abs(from.x - to.x) > 10) {\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x, from.y + fromControlYOffset,\n+                            to.x, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                } else {\n+                    g.drawLine(from.x, from.y, to.x, to.y);\n+                }\n+            } else {  \/\/ reverse edges\n+                if (from.x - to.x > 0) {\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x - 150, from.y + fromControlYOffset,\n+                            to.x + 150, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                } else {\n+                    \/\/ add x offset\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x + 150, from.y + fromControlYOffset,\n+                            to.x - 150, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                }\n+            }\n+        } else {\n+            \/\/ Fallback to straight line if control points are not set\n+            g.drawLine(from.x, from.y, to.x, to.y);\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/dynamic.png","binary":true,"status":"added"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @library \/test\/lib ..\/..\/tools\/tester\n- * @build jtreg.SkippedException\n- * @summary example of a test on the generated documentation\n- * @run main TestDocs\n- *\/\n-\n-import java.nio.file.Files;\n-\n-public class TestDocs {\n-    public static void main(String... args) throws Exception {\n-        var docs = DocTester.resolveDocs();\n-        System.err.println(\"Path to the docs is: \" + docs);\n-        System.err.println(\"Do docs exits?\");\n-        System.err.println(Files.exists(docs));\n-        System.err.println(\"tidy location\");\n-        System.err.println(System.getProperty(\"tidy\"));\n-        System.err.println(\"End of test\");\n-    }\n-}\n","filename":"test\/docs\/jdk\/javadoc\/TestDocs.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import doccheckutils.FileChecker;\n+import doccheckutils.FileProcessor;\n+import doccheckutils.HtmlFileChecker;\n+import doccheckutils.checkers.BadCharacterChecker;\n+import doccheckutils.checkers.DocTypeChecker;\n+import doccheckutils.checkers.LinkChecker;\n+import doccheckutils.checkers.TidyChecker;\n+import doccheckutils.checkers.ExtLinkChecker;\n+import toolbox.TestRunner;\n+\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+\/**\n+ * DocCheck\n+ * <p>\n+ * For the sake of brevity, to run all of these checkers use\n+ * <p>\n+ * `make test-docs_all TEST_DEPS=docs-jdk`\n+ * <p>\n+ * This collection of tests provide a variety of checks for JDK documentation bundle.\n+ * <p>\n+ * It is meant to provide a convenient way to alert users of any errors in their documentation\n+ * before a push and verify the quality of the documentation.\n+ * It is not meant to replace more authoritative checkers; instead,\n+ * it is more focused on providing a convenient, easy overview of any possible issues.\n+ * <p>\n+ * It supports the following checks:\n+ * <p>\n+ * *HTML* -- We use the standard `tidy` utility to check for HTML compliance,\n+ * according to the declared version of HTML.\n+ * The output from `tidy` is analysed to generate a report summarizing any issues that were found.\n+ * <p>\n+ * Version `5.9.20` of `tidy` is expected, or the output from the `--version` option should contain the string `version 5`.\n+ * The test warns the user if he is using an earlier version.\n+ * <p>\n+ * *Bad Characters* -- We assumee that HTML files are encoded in UTF-8,\n+ * and reports any character encoding issues that it finds.\n+ * <p>\n+ * *DocType* --  We assume that HTML files should use HTML5, and reports\n+ * any files for which that is not the case.\n+ * <p>\n+ * *Links* -- We check links within a set of files, and reports on links\n+ * to external resources, without otherwise checking them.\n+ * <p>\n+ *  *External Links* -- We scan the files for URLs that refer to\n+ *     external resources, and validates those references using a \"golden file\" that includes a list of vetted links.\n+ * <p>\n+ * Each external reference is only checked once; but if an issue is found, all the files containing the\n+ * reference will be reported.\n+ *\/\n+public class DocCheck extends TestRunner {\n+\n+    private static final String DOCCHECK_DIR = System.getProperty(\"doccheck.dir\");\n+    private static final Path DIR = Path.of(DOCCHECK_DIR != null ? DOCCHECK_DIR : \"\");\n+    private static final Set<String> CHECKS_LIST = new HashSet<>();\n+    private static Path DOCS_DIR;\n+\n+    private static boolean html;\n+    private static boolean links;\n+    private static boolean badchars;\n+    private static boolean doctype;\n+    private static boolean extlinks;\n+\n+    private List<Path> files;\n+\n+    public DocCheck() {\n+        super(System.err);\n+        init();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        chooseCheckers();\n+        DocCheck docCheck = new DocCheck();\n+        docCheck.runTests();\n+    }\n+\n+    private static void chooseCheckers() {\n+        final String checks = System.getProperty(\"doccheck.checks\");\n+\n+        if (!checks.isEmpty()) {\n+            if (checks.contains(\",\")) {\n+                CHECKS_LIST.addAll(Arrays.asList(checks.split(\",\")));\n+            } else {\n+                CHECKS_LIST.add(checks);\n+            }\n+        }\n+\n+        if (CHECKS_LIST.contains(\"all\")) {\n+            html = true;\n+            links = true;\n+            badchars = true;\n+            doctype = true;\n+            extlinks = true;\n+        } else {\n+            if (CHECKS_LIST.contains(\"html\")) {\n+                html = true;\n+            }\n+            if (CHECKS_LIST.contains(\"links\")) {\n+                links = true;\n+            }\n+            if (CHECKS_LIST.contains(\"badchars\")) {\n+                badchars = true;\n+            }\n+            if (CHECKS_LIST.contains(\"doctype\")) {\n+                doctype = true;\n+            }\n+            if (CHECKS_LIST.contains(\"extlinks\")) {\n+                extlinks = true;\n+            }\n+        }\n+    }\n+\n+    public void init() {\n+        var fileTester = new FileProcessor();\n+        DOCS_DIR = DocTester.resolveDocs();\n+        var baseDir = DOCS_DIR.resolve(DIR);\n+        fileTester.processFiles(baseDir);\n+        files = fileTester.getFiles();\n+    }\n+\n+    public List<FileChecker> getCheckers() {\n+\n+        List<FileChecker> checkers = new ArrayList<>();\n+        if (html) {\n+            checkers.add(new TidyChecker());\n+        }\n+        if (links) {\n+            var linkChecker = new LinkChecker();\n+            linkChecker.setBaseDir(DOCS_DIR);\n+            checkers.add(new HtmlFileChecker(linkChecker, DOCS_DIR));\n+        }\n+\n+        if (extlinks) {\n+            checkers.add(new HtmlFileChecker(new ExtLinkChecker(), DOCS_DIR));\n+        }\n+\n+        \/\/ there should be almost nothing reported from these two checkers\n+        \/\/ most reports should be broken anchors\/links, missing files and errors in html\n+        if (badchars) {\n+            checkers.add(new BadCharacterChecker());\n+        }\n+        if (doctype) {\n+            checkers.add(new HtmlFileChecker(new DocTypeChecker(), DOCS_DIR));\n+        }\n+\n+        return checkers;\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        List<FileChecker> checkers = getCheckers();\n+        runCheckersSequentially(checkers);\n+    }\n+\n+    private void runCheckersSequentially(List<FileChecker> checkers) throws Exception {\n+        List<Throwable> exceptions = new ArrayList<>();\n+\n+        for (FileChecker checker : checkers) {\n+            try (checker) {\n+                checker.checkFiles(files);\n+            } catch (Exception e) {\n+                exceptions.add(e);\n+            }\n+        }\n+\n+        if (!exceptions.isEmpty()) {\n+            throw new Exception(\"One or more HTML checkers failed: \" + exceptions);\n+        }\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/DocCheck.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,773 @@\n+# This file is used to check external links in the JDK generated documentation\n+# to prevent broken links from backsliding into the JDK source.\n+#\n+# The file serves as a \"whitelist\" of links that have been checked to be working as intended\n+# and JDK developers should add external links to this file whenever they add them to their documentation.\n+#\n+#\n+# The links in this file are checked before every release.\n+#\n+#\n+#\n+http:\/\/cldr.unicode.org\/\n+http:\/\/csrc.nist.gov\/publications\/fips\/fips186-3\/fips_186-3.pdf\n+http:\/\/csrc.nist.gov\/publications\/nistpubs\/800-38D\/SP-800-38D.pdf\n+http:\/\/docs.oracle.com\/javase\/feedback.html\n+http:\/\/docs.oracle.com\/javase\/jndi\/tutorial\/index.html\n+http:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-12.html\n+http:\/\/docs.oracle.com\/javase\/tutorial\/collections\/index.html\n+http:\/\/docs.oracle.com\/javase\/tutorial\/i18n\/format\/decimalFormat.html\n+http:\/\/docs.oracle.com\/javase\/tutorial\/i18n\/format\/simpleDateFormat.html\n+http:\/\/docs.oracle.com\/javase\/tutorial\/jdbc\/\n+http:\/\/docs.oracle.com\/javase\/tutorial\/jdbc\/basics\/index.html\n+http:\/\/docs.oracle.com\/javase\/tutorial\/jdbc\/basics\/rowset.html\n+http:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/dnd\/index.html\n+http:\/\/en.wikipedia.org\/wiki\/Skip_list\n+http:\/\/jclark.com\/xml\/xmlns.htm\n+http:\/\/jcp.org\/en\/jsr\/detail?id=173\n+http:\/\/jcp.org\/en\/jsr\/detail?id=268\n+http:\/\/relaxng.org\/spec-20011203.html\n+http:\/\/sax.sourceforge.net\/?selected=get-set\n+http:\/\/standards.iso.org\/iso\/9075\/2002\/12\/sqlxml.xsd\n+http:\/\/svn.python.org\/projects\/python\/trunk\/Objects\/listsort.txt\n+http:\/\/tools.ietf.org\/html\/rfc1421\n+http:\/\/tools.ietf.org\/html\/rfc5869\n+http:\/\/unicode.org\/reports\/tr35\/\n+http:\/\/unicode.org\/reports\/tr35\/tr35-numbers.html\n+http:\/\/web.archive.org\/web\/20051219043731\/http:\/\/archive.ncsa.uiuc.edu\/SDG\/Software\/Mosaic\/Demo\/url-primer.html\n+http:\/\/www.cl.cam.ac.uk\/~mgk25\/time\/utc-sls\/\n+http:\/\/www.cs.rochester.edu\/~scott\/papers\/1996_PODC_queues.pdf\n+http:\/\/www.iana.org\/\n+http:\/\/www.iana.org\/assignments\/character-sets\n+http:\/\/www.iana.org\/assignments\/character-sets\/character-sets.xhtml\n+http:\/\/www.iana.org\/assignments\/media-types\/\n+http:\/\/www.iana.org\/assignments\/uri-schemes.html\n+http:\/\/www.ietf.org\/\n+http:\/\/www.ietf.org\/rfc\/rfc0793.txt\n+http:\/\/www.ietf.org\/rfc\/rfc0822.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1122.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1123.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1323.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1349.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1521.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1522.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1918.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1950.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1950.txt.pdf\n+http:\/\/www.ietf.org\/rfc\/rfc1951.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1951.txt.pdf\n+http:\/\/www.ietf.org\/rfc\/rfc1952.txt\n+http:\/\/www.ietf.org\/rfc\/rfc1952.txt.pdf\n+http:\/\/www.ietf.org\/rfc\/rfc1964.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2045.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2046.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2078.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2104.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2109.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2222.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2236.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2245.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2246.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2251.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2253.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2254.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2255.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2268.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2278.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2279.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2296.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2365.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2373.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2396.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2440.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2474.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2609.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2616.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2696\n+http:\/\/www.ietf.org\/rfc\/rfc2696.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2710.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2732.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2743.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2781.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2782.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2830.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2831.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2853.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2891.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2898.txt\n+http:\/\/www.ietf.org\/rfc\/rfc2965.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3023.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3111.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3275.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3279.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3296.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3330.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3376.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3454.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3490.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3491.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3492.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3530.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3720.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3720.txt.pdf\n+http:\/\/www.ietf.org\/rfc\/rfc3758.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3810.txt\n+http:\/\/www.ietf.org\/rfc\/rfc3986.txt\n+http:\/\/www.ietf.org\/rfc\/rfc4120.txt\n+http:\/\/www.ietf.org\/rfc\/rfc4122.txt\n+http:\/\/www.ietf.org\/rfc\/rfc4366.txt\n+http:\/\/www.ietf.org\/rfc\/rfc4512.txt\n+http:\/\/www.ietf.org\/rfc\/rfc4648.txt\n+http:\/\/www.ietf.org\/rfc\/rfc5116.txt\n+http:\/\/www.ietf.org\/rfc\/rfc5280.txt\n+http:\/\/www.ietf.org\/rfc\/rfc5890.txt\n+http:\/\/www.ietf.org\/rfc\/rfc6066.txt\n+http:\/\/www.ietf.org\/rfc\/rfc7301.txt\n+http:\/\/www.ietf.org\/rfc\/rfc790.txt\n+http:\/\/www.ietf.org\/rfc\/rfc793.txt\n+http:\/\/www.ietf.org\/rfc\/rfc822.txt\n+http:\/\/www.ietf.org\/rfc\/rfc919.txt\n+http:\/\/www.info-zip.org\/doc\/appnote-19970311-iz.zip\n+http:\/\/www.ioplex.com\/utilities\/keytab.txt\n+http:\/\/www.iso.org\/iso\/home\/standards\/currency_codes.htm\n+http:\/\/www.jcp.org\n+http:\/\/www.jcp.org\/en\/jsr\/detail?id=203\n+http:\/\/www.jpeg.org\n+http:\/\/www.libpng.org\/pub\/png\/spec\/\n+http:\/\/www.microsoft.com\/typography\/otspec\/\n+http:\/\/www.midi.org\n+http:\/\/www.oasis-open.org\/committees\/entity\/spec-2001-08-06.html\n+http:\/\/www.oasis-open.org\/committees\/tc_home.php?wg_abbrev=dss\n+http:\/\/www.opengroup.org\n+http:\/\/www.oracle.com\/technetwork\/articles\/java\/mixing-components-433992.html\n+http:\/\/www.oracle.com\/technetwork\/java\/architecture-142923.html\n+http:\/\/www.oracle.com\/technetwork\/java\/javase\/documentation\/serialized-criteria-137781.html\n+http:\/\/www.oracle.com\/technetwork\/java\/javase\/documentation\/spec-136004.html\n+http:\/\/www.oracle.com\/technetwork\/java\/javase\/javasecarootcertsprogram-1876540.html\n+http:\/\/www.oracle.com\/technetwork\/java\/javase\/tech\/javamanagement-140525.html\n+http:\/\/www.oracle.com\/technetwork\/java\/painting-140037.html\n+http:\/\/www.oracle.com\/technetwork\/java\/persistence2-141443.html\n+http:\/\/www.oracle.com\/technetwork\/java\/persistence3-139471.html\n+http:\/\/www.oracle.com\/technetwork\/java\/persistence4-140124.html\n+http:\/\/www.oreilly.com\/catalog\/regex\/\n+http:\/\/www.oreilly.com\/catalog\/regex3\/\n+http:\/\/www.reactive-streams.org\/\n+http:\/\/www.relaxng.org\/\n+http:\/\/www.rfc-editor.org\/rfc\/bcp\/bcp47.txt\n+http:\/\/www.saxproject.org\n+http:\/\/www.saxproject.org\/\n+http:\/\/www.unicode.org\n+http:\/\/www.unicode.org\/\n+http:\/\/www.unicode.org\/glossary\/\n+http:\/\/www.unicode.org\/reports\/tr15\/\n+http:\/\/www.unicode.org\/reports\/tr18\/\n+http:\/\/www.unicode.org\/reports\/tr24\/\n+http:\/\/www.unicode.org\/reports\/tr27\/\n+http:\/\/www.unicode.org\/reports\/tr36\/\n+http:\/\/www.unicode.org\/reports\/tr44\/\n+http:\/\/www.unicode.org\/standard\/standard.html\n+http:\/\/www.w3.org\/2000\/09\/xmldsig\n+http:\/\/www.w3.org\/2000\/xmlns\/\n+http:\/\/www.w3.org\/2001\/04\/xmldsig-more\n+http:\/\/www.w3.org\/2001\/04\/xmlenc\n+http:\/\/www.w3.org\/2001\/05\/xmlschema-errata\n+http:\/\/www.w3.org\/2001\/10\/xml-exc-c14n\n+http:\/\/www.w3.org\/2002\/06\/xmldsig-filter2\n+http:\/\/www.w3.org\/2007\/05\/xmldsig-more\n+http:\/\/www.w3.org\/2009\/xmldsig11\n+http:\/\/www.w3.org\/2021\/04\/xmldsig-more\n+http:\/\/www.w3.org\/Graphics\/GIF\/spec-gif89a.txt\n+http:\/\/www.w3.org\/TR\/1998\/REC-CSS2-19980512\n+http:\/\/www.w3.org\/TR\/1999\/REC-html401-19991224\/\n+http:\/\/www.w3.org\/TR\/1999\/REC-xml-names-19990114\/\n+http:\/\/www.w3.org\/TR\/1999\/REC-xpath-19991116\n+http:\/\/www.w3.org\/TR\/1999\/REC-xslt-19991116\n+http:\/\/www.w3.org\/TR\/2000\/CR-DOM-Level-2-20000510\n+http:\/\/www.w3.org\/TR\/2000\/REC-DOM-Level-2-Core-20001113\n+http:\/\/www.w3.org\/TR\/2000\/REC-DOM-Level-2-Events-20001113\n+http:\/\/www.w3.org\/TR\/2000\/REC-DOM-Level-2-Style-20001113\n+http:\/\/www.w3.org\/TR\/2000\/REC-DOM-Level-2-Traversal-Range-20001113\n+http:\/\/www.w3.org\/TR\/2000\/REC-DOM-Level-2-Views-20001113\n+http:\/\/www.w3.org\/TR\/2001\/REC-xml-c14n-20010315\n+http:\/\/www.w3.org\/TR\/2001\/REC-xmlschema-1-20010502\/\n+http:\/\/www.w3.org\/TR\/2003\/NOTE-DOM-Level-3-Events-20031107\n+http:\/\/www.w3.org\/TR\/2003\/REC-DOM-Level-2-HTML-20030109\n+http:\/\/www.w3.org\/TR\/2003\/REC-SVG11-20030114\/\n+http:\/\/www.w3.org\/TR\/2003\/REC-xptr-framework-20030325\/\n+http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-Core-20040407\n+http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-Core-20040407\/core.html\n+http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-LS-20040407\n+http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-Val-20040127\/\n+http:\/\/www.w3.org\/TR\/2004\/REC-xml-20040204\n+http:\/\/www.w3.org\/TR\/2004\/REC-xml-infoset-20040204\n+http:\/\/www.w3.org\/TR\/2004\/REC-xml-infoset-20040204\/\n+http:\/\/www.w3.org\/TR\/2004\/REC-xml-names11-20040204\/\n+http:\/\/www.w3.org\/TR\/2004\/REC-xml11-20040204\/\n+http:\/\/www.w3.org\/TR\/DOM-Level-2\n+http:\/\/www.w3.org\/TR\/DOM-Level-2-Core\/\n+http:\/\/www.w3.org\/TR\/DOM-Level-3-Core\n+http:\/\/www.w3.org\/TR\/DOM-Level-3-LS\n+http:\/\/www.w3.org\/TR\/ElementTraversal\/\n+http:\/\/www.w3.org\/TR\/NOTE-datetime\n+http:\/\/www.w3.org\/TR\/REC-CSS1\n+http:\/\/www.w3.org\/TR\/REC-html32.html\n+http:\/\/www.w3.org\/TR\/REC-xml\n+http:\/\/www.w3.org\/TR\/REC-xml-names\n+http:\/\/www.w3.org\/TR\/REC-xml-names\/\n+http:\/\/www.w3.org\/TR\/REC-xml\/\n+http:\/\/www.w3.org\/TR\/html4\/\n+http:\/\/www.w3.org\/TR\/html40\/appendix\/notes.html\n+http:\/\/www.w3.org\/TR\/xinclude\/\n+http:\/\/www.w3.org\/TR\/xml-exc-c14n\/\n+http:\/\/www.w3.org\/TR\/xml-names11\/\n+http:\/\/www.w3.org\/TR\/xml-stylesheet\/\n+http:\/\/www.w3.org\/TR\/xml11\/\n+http:\/\/www.w3.org\/TR\/xmldsig-core\/\n+http:\/\/www.w3.org\/TR\/xmldsig-filter2\n+http:\/\/www.w3.org\/TR\/xmldsig-filter2\/\n+http:\/\/www.w3.org\/TR\/xmlschema-1\n+http:\/\/www.w3.org\/TR\/xmlschema-1\/\n+http:\/\/www.w3.org\/TR\/xmlschema-2\/\n+http:\/\/www.w3.org\/TR\/xpath\n+http:\/\/www.w3.org\/TR\/xpath-datamodel\n+http:\/\/www.w3.org\/TR\/xpath\/\n+http:\/\/www.w3.org\/TR\/xslt\n+http:\/\/www.w3.org\/XML\/1998\/namespace\n+http:\/\/www.w3.org\/XML\/Schema\n+http:\/\/www.w3.org\/XML\/xml-V10-2e-errata\n+http:\/\/www.w3.org\/pub\/WWW\/Graphics\/Color\/sRGB.html\n+http:\/\/www.w3.org\/pub\/WWW\/Protocols\/\n+http:\/\/xmlns.jcp.org\/xml\/ns\/\/jdbc\/webrowset.xsd\n+https:\/\/bugreport.java.com\/bugreport\/\n+https:\/\/bugs.openjdk.org\/secure\/attachment\/75649\/JVM_CodeHeap_StateAnalytics_V2.pdf\n+https:\/\/cldr.unicode.org\/index\/downloads\n+https:\/\/csrc.nist.gov\/publications\/PubsFIPS.html\n+https:\/\/csrc.nist.gov\/publications\/fips\/archive\/fips186-2\/fips186-2.pdf\n+https:\/\/csrc.nist.gov\/publications\/fips\/fips180-4\/fips-180-4.pdf\n+https:\/\/csrc.nist.gov\/publications\/fips\/fips186-3\/fips_186-3.pdf\n+https:\/\/csrc.nist.gov\/publications\/fips\/fips197\/fips-197.pdf\n+https:\/\/csrc.nist.gov\/publications\/fips\/fips46-3\/fips46-3.pdf\n+https:\/\/csrc.nist.gov\/publications\/fips\/fips81\/fips81.htm\n+https:\/\/csrc.nist.gov\/publications\/nistpubs\/800-38C\/SP800-38C_updated-July20_2007.pdf\n+https:\/\/csrc.nist.gov\/publications\/nistpubs\/800-38D\/SP-800-38D.pdf\n+https:\/\/csrc.nist.gov\/pubs\/fips\/203\/final\n+https:\/\/csrc.nist.gov\/pubs\/fips\/204\/final\n+https:\/\/datatracker.ietf.org\/doc\/html\/rfc5646\n+https:\/\/datatracker.ietf.org\/doc\/html\/rfc8017\n+https:\/\/developer.apple.com\/documentation\n+https:\/\/docs.oracle.com\/en\/java\/javase\/11\/tools\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/12\/language\/index.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/12\/tools\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/12\/vm\/compiler-control1.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/13\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/14\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/15\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/16\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/17\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/18\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/19\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/20\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/21\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/22\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/23\/docs\/api\/java.base\/java\/lang\/Double.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/23\/docs\/api\/java.base\/java\/math\/BigDecimal.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/23\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/24\/docs\/specs\/man\/java.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/@@JAVASE_VERSION@@\/docs\/api\/java.base\/java\/lang\/String.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/@@JAVASE_VERSION@@\/docs\/specs\/javadoc\/javadoc-search-spec.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/@@JAVASE_VERSION@@\/docs\/specs\/man\/javadoc.html\n+https:\/\/docs.oracle.com\/en\/java\/javase\/index.html\n+https:\/\/docs.oracle.com\/javase\/10\/tools\/java.htm\n+https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/tools\/unix\/java.html\n+https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/tools\/windows\/java.html\n+https:\/\/docs.oracle.com\/javase\/9\/tools\/java.htm\n+https:\/\/docs.oracle.com\/javase\/specs\/\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se10\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se11\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se12\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se13\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se14\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se15\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se16\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se17\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se18\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se19\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se20\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se21\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-13.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-14.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-15.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-17.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-3.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-4.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-5.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-6.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-8.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se22\/html\/jls-9.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-10.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-11.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-12.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-14.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-15.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-16.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-18.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-2.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-3.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-4.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-5.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-6.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-7.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-8.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se23\/html\/jls-9.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se24\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se24\/html\/jls-9.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-10.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-11.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-12.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-13.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-14.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-15.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-17.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-18.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-3.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-4.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-5.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-6.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-7.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-8.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/html\/jls-9.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se@@JAVASE_VERSION@@\/jls@@JAVASE_VERSION@@.pdf\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se6\/html\/j3TOC.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se7\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se8\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jls\/se9\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se10\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se12\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se13\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se14\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se15\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se16\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se17\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se18\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se19\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se20\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se21\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se22\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se23\/html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se23\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se23\/html\/jvms-5.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se24\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se24\/html\/jvms-4.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/html\/jvms-1.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/html\/jvms-2.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/html\/jvms-3.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/html\/jvms-4.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/html\/jvms-5.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/html\/jvms-6.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se@@JAVASE_VERSION@@\/jvms@@JAVASE_VERSION@@.pdf\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/index.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/\n+https:\/\/docs.oracle.com\/javase\/tutorial\/2d\/text\/fonts.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/extra\/fullscreen\/index.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/index.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/javabeans\/\n+https:\/\/docs.oracle.com\/javase\/tutorial\/javabeans\/writing\/properties.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/sound\/\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/applet.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/border.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/button.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/colorchooser.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/combobox.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/dialog.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/filechooser.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/frame.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/generaltext.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/icon.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/internalframe.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/jcomponent.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/label.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/layeredpane.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/list.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/menu.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/panel.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/progress.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/rootpane.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/scrollpane.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/slider.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/spinner.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/splitpane.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/tabbedpane.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/table.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/text.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/textfield.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/toolbar.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/tooltip.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/toplevel.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/components\/tree.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/concurrency\/index.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/dnd\/index.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/actionlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/componentlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/containerlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/focuslistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/index.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/internalframelistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/itemlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/keylistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/mouselistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/mousemotionlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/treeexpansionlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/treemodellistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/treeselectionlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/treewillexpandlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/events\/windowlistener.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/index.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/layout\/box.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/layout\/spring.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/lookandfeel\/plaf.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/misc\/action.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/misc\/focus.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/misc\/keybinding.html\n+https:\/\/docs.oracle.com\/javase\/tutorial\/uiswing\/misc\/timer.html\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=GUID-FE2D2E28-C991-4EF9-9DBE-2A4982726313\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=homepage\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=i18n_overview\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=imf_overview\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=jndi_ldap_gl_prop\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=jndi_overview\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=logging_overview\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=monitoring_and_management_using_jmx_technology\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=rmi_guide\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=secure_coding_guidelines_javase\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_impl_provider\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_jca\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_jca_provider\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_jdk_providers\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_jgss_tutorial\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_overview\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_pki\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_sasl\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=security_guide_tools\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=serialization_filter_guide\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=serialver_tool_reference\n+https:\/\/docs.oracle.com\/pls\/topic\/lookup?ctx=javase@@JAVASE_VERSION@@&id=using_jconsole\n+https:\/\/ftp.pwg.org\/pub\/pwg\/candidates\/cs-ippoutputbin10-20010207-5100.2.pdf\n+https:\/\/ftp.pwg.org\/pub\/pwg\/standards\/temp_archive\/pwg5100.3.pdf\n+https:\/\/github.github.com\/gfm\/\n+https:\/\/help.ubuntu.com\/community\/UnityLaunchersAndDesktopFiles\n+https:\/\/html.spec.whatwg.org\n+https:\/\/html.spec.whatwg.org\/multipage\/\n+https:\/\/html.spec.whatwg.org\/multipage\/introduction.html\n+https:\/\/html.spec.whatwg.org\/multipage\/sections.html\n+https:\/\/html.spec.whatwg.org\/multipage\/semantics.html\n+https:\/\/jcp.org\/aboutJava\/communityprocess\/maintenance\/jsr924\/index.html\n+https:\/\/jcp.org\/aboutJava\/communityprocess\/maintenance\/jsr924\/index2.html\n+https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\n+https:\/\/jcp.org\/en\/jsr\/detail?id=14\n+https:\/\/jcp.org\/en\/jsr\/detail?id=175\n+https:\/\/jcp.org\/en\/jsr\/detail?id=201\n+https:\/\/jcp.org\/en\/jsr\/detail?id=221\n+https:\/\/jcp.org\/en\/jsr\/detail?id=269\n+https:\/\/jcp.org\/en\/jsr\/detail?id=334\n+https:\/\/jcp.org\/en\/jsr\/detail?id=335\n+https:\/\/jcp.org\/en\/jsr\/detail?id=376\n+https:\/\/jcp.org\/en\/jsr\/detail?id=41\n+https:\/\/jcp.org\/en\/procedures\/jcp2\n+https:\/\/mermaid.js.org\n+https:\/\/msdn.microsoft.com\/en-us\/library\/cc236621.aspx\n+https:\/\/msdn.microsoft.com\/en-us\/library\/dd183391.aspx\n+https:\/\/nvlpubs.nist.gov\/nistpubs\/FIPS\/NIST.FIPS.140-2.pdf\n+https:\/\/nvlpubs.nist.gov\/nistpubs\/FIPS\/NIST.FIPS.186-4.pdf\n+https:\/\/nvlpubs.nist.gov\/nistpubs\/FIPS\/NIST.FIPS.202.pdf\n+https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf\n+https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-90Ar1.pdf\n+https:\/\/openjdk.org\/jeps\/11\n+https:\/\/openjdk.org\/jeps\/12\n+https:\/\/openjdk.org\/jeps\/181\n+https:\/\/openjdk.org\/jeps\/213\n+https:\/\/openjdk.org\/jeps\/225\n+https:\/\/openjdk.org\/jeps\/261\n+https:\/\/openjdk.org\/jeps\/286\n+https:\/\/openjdk.org\/jeps\/306\n+https:\/\/openjdk.org\/jeps\/323\n+https:\/\/openjdk.org\/jeps\/361\n+https:\/\/openjdk.org\/jeps\/371\n+https:\/\/openjdk.org\/jeps\/378\n+https:\/\/openjdk.org\/jeps\/394\n+https:\/\/openjdk.org\/jeps\/395\n+https:\/\/openjdk.org\/jeps\/396\n+https:\/\/openjdk.org\/jeps\/403\n+https:\/\/openjdk.org\/jeps\/409\n+https:\/\/openjdk.org\/jeps\/421\n+https:\/\/openjdk.org\/jeps\/440\n+https:\/\/openjdk.org\/jeps\/441\n+https:\/\/openjdk.org\/jeps\/454\n+https:\/\/openjdk.org\/jeps\/456\n+https:\/\/openjdk.org\/jeps\/458\n+https:\/\/openjdk.org\/jeps\/467\n+https:\/\/openjdk.org\/jeps\/478\n+https:\/\/openjdk.org\/jeps\/487\n+https:\/\/openjdk.org\/jeps\/488\n+https:\/\/openjdk.org\/jeps\/492\n+https:\/\/openjdk.org\/jeps\/494\n+https:\/\/openjdk.org\/jeps\/495\n+https:\/\/openjdk.org\/jeps\/499\n+https:\/\/prismjs.com\n+https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/inet_addr.html\n+https:\/\/relaxng.org\/\n+https:\/\/reproducible-builds.org\/\n+https:\/\/spec.commonmark.org\/0.31.2\n+https:\/\/spec.commonmark.org\/0.31.2\/\n+https:\/\/standards.ieee.org\/ieee\/754\/6210\/\n+https:\/\/standards.iso.org\/ittf\/PubliclyAvailableStandards\/c055982_ISO_IEC_19757-3_2016.zip\n+https:\/\/standards.iso.org\/ittf\/PubliclyAvailableStandards\/index.html\n+https:\/\/support.pkware.com\/pkzip\/appnote\n+https:\/\/tools.ietf.org\/html\/rfc1319\n+https:\/\/tools.ietf.org\/html\/rfc1321\n+https:\/\/tools.ietf.org\/html\/rfc1779\n+https:\/\/tools.ietf.org\/html\/rfc2040\n+https:\/\/tools.ietf.org\/html\/rfc2104\n+https:\/\/tools.ietf.org\/html\/rfc2195\n+https:\/\/tools.ietf.org\/html\/rfc2222\n+https:\/\/tools.ietf.org\/html\/rfc2246\n+https:\/\/tools.ietf.org\/html\/rfc2253\n+https:\/\/tools.ietf.org\/html\/rfc2595\n+https:\/\/tools.ietf.org\/html\/rfc2616\n+https:\/\/tools.ietf.org\/html\/rfc2712\n+https:\/\/tools.ietf.org\/html\/rfc2818\n+https:\/\/tools.ietf.org\/html\/rfc2830\n+https:\/\/tools.ietf.org\/html\/rfc2831\n+https:\/\/tools.ietf.org\/html\/rfc3217\n+https:\/\/tools.ietf.org\/html\/rfc3278\n+https:\/\/tools.ietf.org\/html\/rfc3394\n+https:\/\/tools.ietf.org\/html\/rfc3986\n+https:\/\/tools.ietf.org\/html\/rfc4086\n+https:\/\/tools.ietf.org\/html\/rfc4121\n+https:\/\/tools.ietf.org\/html\/rfc4162\n+https:\/\/tools.ietf.org\/html\/rfc4178\n+https:\/\/tools.ietf.org\/html\/rfc4234\n+https:\/\/tools.ietf.org\/html\/rfc4279\n+https:\/\/tools.ietf.org\/html\/rfc4346\n+https:\/\/tools.ietf.org\/html\/rfc4347\n+https:\/\/tools.ietf.org\/html\/rfc4492\n+https:\/\/tools.ietf.org\/html\/rfc4512\n+https:\/\/tools.ietf.org\/html\/rfc4647\n+https:\/\/tools.ietf.org\/html\/rfc4785\n+https:\/\/tools.ietf.org\/html\/rfc4960\n+https:\/\/tools.ietf.org\/html\/rfc5054\n+https:\/\/tools.ietf.org\/html\/rfc5061\n+https:\/\/tools.ietf.org\/html\/rfc5084\n+https:\/\/tools.ietf.org\/html\/rfc5246\n+https:\/\/tools.ietf.org\/html\/rfc5280\n+https:\/\/tools.ietf.org\/html\/rfc5288\n+https:\/\/tools.ietf.org\/html\/rfc5289\n+https:\/\/tools.ietf.org\/html\/rfc5469\n+https:\/\/tools.ietf.org\/html\/rfc5487\n+https:\/\/tools.ietf.org\/html\/rfc5489\n+https:\/\/tools.ietf.org\/html\/rfc5639\n+https:\/\/tools.ietf.org\/html\/rfc5646\n+https:\/\/tools.ietf.org\/html\/rfc5649\n+https:\/\/tools.ietf.org\/html\/rfc5746\n+https:\/\/tools.ietf.org\/html\/rfc5932\n+https:\/\/tools.ietf.org\/html\/rfc6209\n+https:\/\/tools.ietf.org\/html\/rfc6347\n+https:\/\/tools.ietf.org\/html\/rfc6367\n+https:\/\/tools.ietf.org\/html\/rfc6454\n+https:\/\/tools.ietf.org\/html\/rfc6455\n+https:\/\/tools.ietf.org\/html\/rfc6655\n+https:\/\/tools.ietf.org\/html\/rfc6931\n+https:\/\/tools.ietf.org\/html\/rfc7230\n+https:\/\/tools.ietf.org\/html\/rfc7231\n+https:\/\/tools.ietf.org\/html\/rfc7251\n+https:\/\/tools.ietf.org\/html\/rfc7292\n+https:\/\/tools.ietf.org\/html\/rfc7507\n+https:\/\/tools.ietf.org\/html\/rfc7539\n+https:\/\/tools.ietf.org\/html\/rfc7540\n+https:\/\/tools.ietf.org\/html\/rfc7748\n+https:\/\/tools.ietf.org\/html\/rfc7905\n+https:\/\/tools.ietf.org\/html\/rfc7919\n+https:\/\/tools.ietf.org\/html\/rfc8017\n+https:\/\/tools.ietf.org\/html\/rfc8018\n+https:\/\/tools.ietf.org\/html\/rfc8032\n+https:\/\/tools.ietf.org\/html\/rfc8103\n+https:\/\/tools.ietf.org\/html\/rfc8353\n+https:\/\/tools.ietf.org\/html\/rfc8422\n+https:\/\/tools.ietf.org\/html\/rfc8446\n+https:\/\/tools.ietf.org\/html\/rfc8554\n+https:\/\/tools.ietf.org\/id\/draft-kaukonen-cipher-arcfour-03.txt\n+https:\/\/tools.ietf.org\/rfc\/rfc5280.txt\n+https:\/\/tools.ietf.org\/rfc\/rfc8017.txt\n+https:\/\/unicode.org\/reports\/tr31\/\n+https:\/\/unicode.org\/reports\/tr35\/\n+https:\/\/unicode.org\/reports\/tr35\/tr35-dates.html\n+https:\/\/unicode.org\/reports\/tr35\/tr35-numbers.html\n+https:\/\/unicode.org\/reports\/tr51\/\n+https:\/\/web.mit.edu\/kerberos\/\n+https:\/\/webhome.phy.duke.edu\/~rgb\/General\/dieharder.php\n+https:\/\/www.cipa.jp\/std\/documents\/e\/DC-008-2012_E.pdf\n+https:\/\/www.color.org\n+https:\/\/www.color.org\/ICC1V42.pdf\n+https:\/\/www.iana.org\/assignments\/kerberos-parameters\/kerberos-parameters.xhtml\n+https:\/\/www.iana.org\/assignments\/language-subtag-registry\/language-subtag-registry\n+https:\/\/www.iana.org\/assignments\/tls-parameters\/tls-parameters.xhtml\n+https:\/\/www.iana.org\/time-zones\n+https:\/\/www.ietf.org\/rfc\/rfc2616.txt\n+https:\/\/www.ietf.org\/rfc\/rfc2818.txt\n+https:\/\/www.ietf.org\/rfc\/rfc6931.txt\n+https:\/\/www.ietf.org\/rfc\/rfc6943.html\n+https:\/\/www.iso.org\/home.html\n+https:\/\/www.iso.org\/iso-4217-currency-codes.html\n+https:\/\/www.iso.org\/iso-8601-date-and-time-format.html\n+https:\/\/www.iso.org\/standard\/18114.html\n+https:\/\/www.itu.int\/itudoc\/itu-t\/com16\/tiff-fx\/docs\/tiff6.pdf\n+https:\/\/www.itu.int\/rec\/T-REC-X.509\/en\n+https:\/\/www.netlib.org\/fdlibm\/\n+https:\/\/www.oasis-open.org\n+https:\/\/www.oasis-open.org\/committees\/download.php\/14809\/xml-catalogs.html\n+https:\/\/www.oracle.com\/java\/javase\/terms\/license\/java@@JAVASE_VERSION@@speclicense.html\n+https:\/\/www.oracle.com\/java\/technologies\/a-swing-architecture.html\n+https:\/\/www.oracle.com\/java\/technologies\/javase\/seccodeguide.html\n+https:\/\/www.oracle.com\/java\/technologies\/javase\/training-support.html\n+https:\/\/www.oracle.com\/pls\/topic\/lookup?ctx=en\/java\/javase&id=security_guide_implement_provider_jca\n+https:\/\/www.oracle.com\/technetwork\/java\/javase\/documentation\/spec-136004.html\n+https:\/\/www.oracle.com\/technetwork\/java\/javasebusiness\/downloads\/java-archive-downloads-java-plat-419418.html\n+https:\/\/www.oracle.com\/technetwork\/java\/redist-137594.html\n+https:\/\/www.oracle.com\/technetwork\/java\/seccodeguide-139067.html\n+https:\/\/www.owasp.org\n+https:\/\/www.rfc-editor.org\/info\/rfc1122\n+https:\/\/www.rfc-editor.org\/info\/rfc1123\n+https:\/\/www.rfc-editor.org\/info\/rfc1323\n+https:\/\/www.rfc-editor.org\/info\/rfc1349\n+https:\/\/www.rfc-editor.org\/info\/rfc1738\n+https:\/\/www.rfc-editor.org\/info\/rfc1779\n+https:\/\/www.rfc-editor.org\/info\/rfc1918\n+https:\/\/www.rfc-editor.org\/info\/rfc1950\n+https:\/\/www.rfc-editor.org\/info\/rfc1951\n+https:\/\/www.rfc-editor.org\/info\/rfc1952\n+https:\/\/www.rfc-editor.org\/info\/rfc2040\n+https:\/\/www.rfc-editor.org\/info\/rfc2045\n+https:\/\/www.rfc-editor.org\/info\/rfc2046\n+https:\/\/www.rfc-editor.org\/info\/rfc2109\n+https:\/\/www.rfc-editor.org\/info\/rfc2236\n+https:\/\/www.rfc-editor.org\/info\/rfc2246\n+https:\/\/www.rfc-editor.org\/info\/rfc2253\n+https:\/\/www.rfc-editor.org\/info\/rfc2268\n+https:\/\/www.rfc-editor.org\/info\/rfc2278\n+https:\/\/www.rfc-editor.org\/info\/rfc2279\n+https:\/\/www.rfc-editor.org\/info\/rfc2296\n+https:\/\/www.rfc-editor.org\/info\/rfc2306\n+https:\/\/www.rfc-editor.org\/info\/rfc2365\n+https:\/\/www.rfc-editor.org\/info\/rfc2368\n+https:\/\/www.rfc-editor.org\/info\/rfc2373\n+https:\/\/www.rfc-editor.org\/info\/rfc2396\n+https:\/\/www.rfc-editor.org\/info\/rfc2474\n+https:\/\/www.rfc-editor.org\/info\/rfc2560\n+https:\/\/www.rfc-editor.org\/info\/rfc2616\n+https:\/\/www.rfc-editor.org\/info\/rfc2710\n+https:\/\/www.rfc-editor.org\/info\/rfc2732\n+https:\/\/www.rfc-editor.org\/info\/rfc2781\n+https:\/\/www.rfc-editor.org\/info\/rfc2898\n+https:\/\/www.rfc-editor.org\/info\/rfc2911\n+https:\/\/www.rfc-editor.org\/info\/rfc2965\n+https:\/\/www.rfc-editor.org\/info\/rfc3279\n+https:\/\/www.rfc-editor.org\/info\/rfc3330\n+https:\/\/www.rfc-editor.org\/info\/rfc3376\n+https:\/\/www.rfc-editor.org\/info\/rfc3454\n+https:\/\/www.rfc-editor.org\/info\/rfc3490\n+https:\/\/www.rfc-editor.org\/info\/rfc3491\n+https:\/\/www.rfc-editor.org\/info\/rfc3492\n+https:\/\/www.rfc-editor.org\/info\/rfc3530\n+https:\/\/www.rfc-editor.org\/info\/rfc3720\n+https:\/\/www.rfc-editor.org\/info\/rfc3810\n+https:\/\/www.rfc-editor.org\/info\/rfc3986\n+https:\/\/www.rfc-editor.org\/info\/rfc4007\n+https:\/\/www.rfc-editor.org\/info\/rfc4086\n+https:\/\/www.rfc-editor.org\/info\/rfc4122\n+https:\/\/www.rfc-editor.org\/info\/rfc4234\n+https:\/\/www.rfc-editor.org\/info\/rfc4366\n+https:\/\/www.rfc-editor.org\/info\/rfc4512\n+https:\/\/www.rfc-editor.org\/info\/rfc4647\n+https:\/\/www.rfc-editor.org\/info\/rfc4648\n+https:\/\/www.rfc-editor.org\/info\/rfc5116\n+https:\/\/www.rfc-editor.org\/info\/rfc5280\n+https:\/\/www.rfc-editor.org\/info\/rfc5646\n+https:\/\/www.rfc-editor.org\/info\/rfc5869\n+https:\/\/www.rfc-editor.org\/info\/rfc5890\n+https:\/\/www.rfc-editor.org\/info\/rfc6066\n+https:\/\/www.rfc-editor.org\/info\/rfc7301\n+https:\/\/www.rfc-editor.org\/info\/rfc7539\n+https:\/\/www.rfc-editor.org\/info\/rfc790\n+https:\/\/www.rfc-editor.org\/info\/rfc793\n+https:\/\/www.rfc-editor.org\/info\/rfc8017\n+https:\/\/www.rfc-editor.org\/info\/rfc8032\n+https:\/\/www.rfc-editor.org\/info\/rfc822\n+https:\/\/www.rfc-editor.org\/info\/rfc919\n+https:\/\/www.rfc-editor.org\/info\/rfc9231\n+https:\/\/www.rfc-editor.org\/rfc\/rfc2315.txt\n+https:\/\/www.rfc-editor.org\/rfc\/rfc5208.html\n+https:\/\/www.rfc-editor.org\/rfc\/rfc5280.html\n+https:\/\/www.rfc-editor.org\/rfc\/rfc5646\n+https:\/\/www.rfc-editor.org\/rfc\/rfc5646.html\n+https:\/\/www.rfc-editor.org\/rfc\/rfc5869\n+https:\/\/www.rfc-editor.org\/rfc\/rfc6943.html\n+https:\/\/www.rfc-editor.org\/rfc\/rfc8017\n+https:\/\/www.rfc-editor.org\/rfc\/rfc8017.html\n+https:\/\/www.rfc-editor.org\/rfc\/rfc9180\n+https:\/\/www.schneier.com\/blowfish.html\n+https:\/\/www.secg.org\/sec2-v2.pdf\n+https:\/\/www.unicode.org\/reports\/tr15\n+https:\/\/www.unicode.org\/reports\/tr15\/\n+https:\/\/www.unicode.org\/reports\/tr18\n+https:\/\/www.unicode.org\/reports\/tr24\n+https:\/\/www.unicode.org\/reports\/tr27\n+https:\/\/www.unicode.org\/reports\/tr29\/\n+https:\/\/www.unicode.org\/reports\/tr31\n+https:\/\/www.unicode.org\/reports\/tr35\n+https:\/\/www.unicode.org\/reports\/tr35\/\n+https:\/\/www.unicode.org\/reports\/tr35\/tr35-collation.html\n+https:\/\/www.unicode.org\/reports\/tr35\/tr35-dates.html\n+https:\/\/www.unicode.org\/reports\/tr35\/tr35-general.html\n+https:\/\/www.unicode.org\/reports\/tr35\/tr35.html\n+https:\/\/www.unicode.org\/reports\/tr36\n+https:\/\/www.unicode.org\/reports\/tr44\n+https:\/\/www.unicode.org\/reports\/tr44\/\n+https:\/\/www.usno.navy.mil\/USNO\n+https:\/\/www.usno.navy.mil\/USNO\/time\/master-clock\/systems-of-time\n+https:\/\/www.w3.org\n+https:\/\/www.w3.org\/Daemon\/User\/Config\/Logging.html\n+https:\/\/www.w3.org\/TR\/1998\/REC-html40-19980424\/\n+https:\/\/www.w3.org\/TR\/1999\/REC-xpath-19991116\/\n+https:\/\/www.w3.org\/TR\/2001\/REC-xml-c14n-20010315\n+https:\/\/www.w3.org\/TR\/2002\/REC-xml-exc-c14n-20020718\/\n+https:\/\/www.w3.org\/TR\/2002\/REC-xmldsig-filter2-20021108\/\n+https:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-Core-20040407\/core.html\n+https:\/\/www.w3.org\/TR\/CSS22\n+https:\/\/www.w3.org\/TR\/CSS22\/syndata.html\n+https:\/\/www.w3.org\/TR\/DOM-Level-3-XPath\/\n+https:\/\/www.w3.org\/TR\/NOTE-datetime\n+https:\/\/www.w3.org\/TR\/REC-CSS1\n+https:\/\/www.w3.org\/TR\/REC-html32.html\n+https:\/\/www.w3.org\/TR\/REC-xml-names\/\n+https:\/\/www.w3.org\/TR\/html4\n+https:\/\/www.w3.org\/TR\/html52\n+https:\/\/www.w3.org\/TR\/html52\/dom.html\n+https:\/\/www.w3.org\/TR\/html52\/syntax.html\n+https:\/\/www.w3.org\/TR\/xml\n+https:\/\/www.w3.org\/TR\/xml-c14n11\/\n+https:\/\/www.w3.org\/TR\/xml\/\n+https:\/\/www.w3.org\/TR\/xmldsig-core\/\n+https:\/\/www.w3.org\/TR\/xmlschema-2\n+https:\/\/www.w3.org\/WAI\/standards-guidelines\/wcag\/\n+https:\/\/www.w3.org\/XML\/Schema\n+https:\/\/www.w3.org\/XML\/xml-names-19990114-errata.html\n+https:\/\/www.wapforum.org\/what\/technical\/SPEC-WAESpec-19990524.pdf\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/ExtLinksJdk.txt","additions":773,"deletions":0,"binary":false,"changes":773,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337109\n+ * @summary Check external links in the generated documentation\n+ * @library \/test\/langtools\/tools\/lib ..\/..\/doccheck \/test\/lib ..\/..\/..\/..\/tools\/tester\n+ * @build DocTester toolbox.TestRunner\n+ * @run main\/othervm -Ddoccheck.checks=extlinks DocCheck\n+ *\/\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/checks\/jdkCheckExtlinks.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337109\n+ * @summary Check the html in the generated documentation\n+ * @library \/test\/langtools\/tools\/lib ..\/..\/doccheck \/test\/lib ..\/..\/..\/..\/tools\/tester\n+ * @build DocTester toolbox.TestRunner\n+ * @run main\/othervm -Ddoccheck.checks=html DocCheck\n+ *\/\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/checks\/jdkCheckHtml.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337109\n+ * @summary Check Links in the generated documentation\n+ * @library \/test\/langtools\/tools\/lib ..\/..\/doccheck \/test\/lib ..\/..\/..\/..\/tools\/tester\n+ * @build DocTester toolbox.TestRunner\n+ * @run main\/othervm -Ddoccheck.checks=links DocCheck\n+ *\/\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/checks\/jdkCheckLinks.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337109\n+ * @summary Check doctype and character encoding in the generated documentation\n+ * @library \/test\/langtools\/tools\/lib ..\/..\/doccheck \/test\/lib ..\/..\/..\/..\/tools\/tester\n+ * @build DocTester toolbox.TestRunner\n+ * @run main\/othervm -Ddoccheck.checks=doctype,badchars DocCheck\n+ *\/\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/checks\/jdkDoctypeBadcharsCheck.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils;\n+\n+import java.io.Closeable;\n+\n+\/**\n+ * Base class for {@link FileChecker file checkers} and\n+ *\/\n+public interface Checker extends Closeable {\n+\n+    \/**\n+     * Writes a report at the end of a run, to summarize the results of the\n+     * checking done by this checker.\n+     *\/\n+    void report();\n+\n+    boolean isOK();\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/Checker.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+public interface FileChecker extends Checker {\n+    void checkFiles(List<Path> files);\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/FileChecker.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils;\n+\n+import java.io.IOException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FileProcessor {\n+    private final List<Path> files;\n+\n+    public FileProcessor() {\n+        files = new ArrayList<>();\n+    }\n+\n+    public List<Path> getFiles() {\n+        return files;\n+    }\n+\n+    public void processFiles(Path directory) {\n+        try {\n+            Files.walkFileTree(directory, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                    if (file.toString().endsWith(\".html\"))\n+                        files.add(file);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+\n+                @Override\n+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } catch (IOException e) {\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/FileProcessor.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils;\n+\n+import java.nio.file.Path;\n+import java.util.Map;\n+\n+\/**\n+ * Base class for HTML checkers.\n+ * <p>\n+ * For details on HTML syntax and the terms used in this API, see\n+ * W3C <a href=\"https:\/\/html.spec.whatwg.org\/multipage\/syntax.html#syntax\">The HTML syntax<\/a>.\n+ *\/\n+public interface HtmlChecker extends Checker {\n+    \/**\n+     * Starts checking a new file,\n+     * <p>\n+     * The file becomes the <em>current<\/em> file until {@link #endFile endFile}\n+     * is called.\n+     *\n+     * @param path the file.\n+     *\/\n+    void startFile(Path path);\n+\n+    \/**\n+     * Ends checking the current file.\n+     *\/\n+    void endFile();\n+\n+    \/**\n+     * Checks the content of a {@code <?xml ... ?>} declaration in the\n+     * current file.\n+     *\n+     * @param line  the line number on which the declaration was found\n+     * @param attrs the content of the declaration\n+     *\/\n+    void xml(int line, Map<String, String> attrs);\n+\n+    \/**\n+     * Checks the content of a {@code <!doctype ... >} declaration in the\n+     * current file.\n+     *\n+     * @param line    the line number on which the declaration was found\n+     * @param docType the content of the declaration\n+     *\/\n+    void docType(int line, String docType);\n+\n+    \/**\n+     * Checks the start of an HTML tag in the current file.\n+     *\n+     * @param line        the line number on which the start tag for an element was found\n+     * @param name        the name of the tag\n+     * @param attrs       the attributes of the tag\n+     * @param selfClosing whether the tag is self-closing\n+     *\/\n+    void startElement(int line, String name, Map<String, String> attrs, boolean selfClosing);\n+\n+    \/**\n+     * Checks the end of an HTML tag in the current file.\n+     *\n+     * @param line the line number on which the end tag for an element was found\n+     * @param name the name of the tag\n+     *\/\n+    void endElement(int line, String name);\n+\n+    \/**\n+     * Checks the content appearing in between HTML tags.\n+     *\n+     * @param line    the line number on which the content was found\n+     * @param content the content\n+     *\/\n+    default void content(int line, String content) {\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/HtmlChecker.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CodingErrorAction;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Reads an HTML file, and calls a series of{@link HtmlChecker HTML checkers}\n+ * for the HTML constructs found therein.\n+ *\/\n+public class HtmlFileChecker implements FileChecker {\n+    private final CharsetDecoder decoder = StandardCharsets.UTF_8.newDecoder()\n+            .onMalformedInput(CodingErrorAction.IGNORE)\n+            .onUnmappableCharacter(CodingErrorAction.IGNORE);\n+\n+    private final Log log;\n+    private final HtmlChecker htmlChecker;\n+    private Path path;\n+    private BufferedReader in;\n+    private int ch;\n+    private int lineNumber;\n+    private boolean inScript;\n+    private boolean xml;\n+\n+    public HtmlFileChecker(HtmlChecker htmlChecker, Path BaseDir) {\n+        this.log = new Log();\n+        log.setBaseDirectory(BaseDir);\n+        this.htmlChecker = htmlChecker;\n+    }\n+\n+    @Override\n+    public void checkFiles(List<Path> files) {\n+        for (Path file : files) {\n+            read(file);\n+        }\n+    }\n+\n+    @Override\n+    public void report() {\n+        System.err.println(log);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+\/\/        report();\n+        htmlChecker.close();\n+    }\n+\n+    private void read(Path path) {\n+        try (BufferedReader r = new BufferedReader(\n+                new InputStreamReader(Files.newInputStream(path), decoder))) {\n+            this.path = path;\n+            this.in = r;\n+            StringBuilder content = new StringBuilder();\n+\n+            startFile(path);\n+            try {\n+                lineNumber = 1;\n+                xml = false;\n+                nextChar();\n+\n+                while (ch != -1) {\n+                    if (ch == '<') {\n+                        content(content.toString());\n+                        content.setLength(0);\n+                        html();\n+                    } else {\n+                        content.append((char) ch);\n+                        if (ch == '\\n') {\n+                            content(content.toString());\n+                            content.setLength(0);\n+                        }\n+                        nextChar();\n+                    }\n+                }\n+            } finally {\n+                endFile();\n+            }\n+        } catch (IOException e) {\n+            log.log(path, lineNumber, e);\n+        } catch (Throwable t) {\n+            log.log(path, lineNumber, t);\n+            log.log(String.valueOf(t));\n+        }\n+    }\n+\n+    private void startFile(Path path) {\n+        htmlChecker.startFile(path);\n+    }\n+\n+    private void endFile() {\n+        htmlChecker.endFile();\n+    }\n+\n+    private void docType(String s) {\n+        htmlChecker.docType(lineNumber, s);\n+    }\n+\n+    private void startElement(String name, Map<String, String> attrs, boolean selfClosing) {\n+        htmlChecker.startElement(lineNumber, name, attrs, selfClosing);\n+    }\n+\n+    private void endElement(String name) {\n+        htmlChecker.endElement(lineNumber, name);\n+    }\n+\n+    private void content(String s) {\n+        htmlChecker.content(lineNumber, s);\n+    }\n+\n+    private void nextChar() throws IOException {\n+        ch = in.read();\n+        if (ch == '\\n')\n+            lineNumber++;\n+    }\n+\n+    \/**\n+     * Read the start or end of an HTML tag, or an HTML comment\n+     * {@literal <identifier attrs> } or {@literal <\/identifier> }\n+     *\n+     * @throws IOException if there is a problem reading the file\n+     *\/\n+    protected void html() throws IOException {\n+        nextChar();\n+        if (isIdentifierStart((char) ch)) {\n+            String name = readIdentifier().toLowerCase(Locale.US);\n+            Map<String, String> attrs = htmlAttrs();\n+            if (attrs != null) {\n+                boolean selfClosing = false;\n+                if (ch == '\/') {\n+                    nextChar();\n+                    selfClosing = true;\n+                }\n+                if (ch == '>') {\n+                    nextChar();\n+                    startElement(name, attrs, selfClosing);\n+                    if (name.equals(\"script\")) {\n+                        inScript = true;\n+                    }\n+                    return;\n+                }\n+            }\n+        } else if (ch == '\/') {\n+            nextChar();\n+            if (isIdentifierStart((char) ch)) {\n+                String name = readIdentifier().toLowerCase(Locale.US);\n+                skipWhitespace();\n+                if (ch == '>') {\n+                    nextChar();\n+                    endElement(name);\n+                    if (name.equals(\"script\")) {\n+                        inScript = false;\n+                    }\n+                    return;\n+                }\n+            }\n+        } else if (ch == '!') {\n+            nextChar();\n+            if (ch == '-') {\n+                nextChar();\n+                if (ch == '-') {\n+                    nextChar();\n+                    while (ch != -1) {\n+                        int dash = 0;\n+                        while (ch == '-') {\n+                            dash++;\n+                            nextChar();\n+                        }\n+                        \/\/ Strictly speaking, a comment should not contain \"--\"\n+                        \/\/ so dash > 2 is an error, dash == 2 implies ch == '>'\n+                        \/\/ See http:\/\/www.w3.org\/TR\/html-markup\/syntax.html#syntax-comments\n+                        \/\/ for more details.\n+                        if (dash >= 2 && ch == '>') {\n+                            nextChar();\n+                            return;\n+                        }\n+\n+                        nextChar();\n+                    }\n+                }\n+            } else if (ch == '[') {\n+                nextChar();\n+                if (ch == 'C') {\n+                    nextChar();\n+                    if (ch == 'D') {\n+                        nextChar();\n+                        if (ch == 'A') {\n+                            nextChar();\n+                            if (ch == 'T') {\n+                                nextChar();\n+                                if (ch == 'A') {\n+                                    nextChar();\n+                                    if (ch == '[') {\n+                                        while (true) {\n+                                            nextChar();\n+                                            if (ch == ']') {\n+                                                nextChar();\n+                                                if (ch == ']') {\n+                                                    nextChar();\n+                                                    if (ch == '>') {\n+                                                        nextChar();\n+                                                        return;\n+                                                    }\n+                                                }\n+                                            }\n+                                        }\n+\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            } else {\n+                StringBuilder sb = new StringBuilder();\n+                while (ch != -1 && ch != '>') {\n+                    sb.append((char) ch);\n+                    nextChar();\n+                }\n+                Pattern p = Pattern.compile(\"(?is)doctype\\\\s+html\\\\s?.*\");\n+                String s = sb.toString();\n+                if (p.matcher(s).matches()) {\n+                    xml = s.contains(\"XHTML\");\n+                    docType(s);\n+                    return;\n+                }\n+            }\n+        } else if (ch == '?') {\n+            nextChar();\n+            if (ch == 'x') {\n+                nextChar();\n+                if (ch == 'm') {\n+                    nextChar();\n+                    if (ch == 'l') {\n+                        nextChar();\n+                        if (ch == '?') {\n+                            nextChar();\n+                            if (ch == '>') {\n+                                nextChar();\n+                                xml = true;\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+            }\n+        }\n+\n+        if (!inScript) {\n+            log.log(path, lineNumber, \"bad html\");\n+        }\n+    }\n+\n+    \/**\n+     * Read a series of HTML attributes, terminated by {@literal > }.\n+     * Each attribute is of the form {@literal identifier[=value] }.\n+     * \"value\" may be unquoted, single-quoted, or double-quoted.\n+     *\/\n+    protected Map<String, String> htmlAttrs() throws IOException {\n+        Map<String, String> map = new LinkedHashMap<>();\n+        skipWhitespace();\n+\n+        while (isIdentifierStart((char) ch)) {\n+            String name = readAttributeName().toLowerCase(Locale.US);\n+            skipWhitespace();\n+            String value = null;\n+            if (ch == '=') {\n+                nextChar();\n+                skipWhitespace();\n+                if (ch == '\\'' || ch == '\"') {\n+                    char quote = (char) ch;\n+                    nextChar();\n+                    StringBuilder sb = new StringBuilder();\n+                    while (ch != -1 && ch != quote) {\n+\/\/                            if (ch == '\\n') {\n+\/\/                                error(path, lineNumber, \"unterminated string\");\n+\/\/                                \/\/ No point trying to read more.\n+\/\/                                \/\/ In fact, all attrs get discarded by the caller\n+\/\/                                \/\/ and superseded by a malformed.html node because\n+\/\/                                \/\/ the html tag itself is not terminated correctly.\n+\/\/                                break loop;\n+\/\/                            }\n+                        sb.append((char) ch);\n+                        nextChar();\n+                    }\n+                    value = sb.toString() \/\/ hack to replace common entities\n+                            .replace(\"&lt;\", \"<\")\n+                            .replace(\"&gt;\", \">\")\n+                            .replace(\"&amp;\", \"&\");\n+                    nextChar();\n+                } else {\n+                    StringBuilder sb = new StringBuilder();\n+                    while (ch != -1 && !isUnquotedAttrValueTerminator((char) ch)) {\n+                        sb.append((char) ch);\n+                        nextChar();\n+                    }\n+                    value = sb.toString();\n+                }\n+                skipWhitespace();\n+            }\n+            map.put(name, value);\n+        }\n+\n+        return map;\n+    }\n+\n+    protected boolean isIdentifierStart(char ch) {\n+        return Character.isUnicodeIdentifierStart(ch);\n+    }\n+\n+    protected String readIdentifier() throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append((char) ch);\n+        nextChar();\n+        while (ch != -1 && Character.isUnicodeIdentifierPart(ch)) {\n+            sb.append((char) ch);\n+            nextChar();\n+        }\n+        return sb.toString();\n+    }\n+\n+    protected String readAttributeName() throws IOException {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append((char) ch);\n+        nextChar();\n+        while ((ch != -1 && Character.isUnicodeIdentifierPart(ch))\n+                || ch == '-'\n+                || (xml && ch == ':')) {\n+            sb.append((char) ch);\n+            nextChar();\n+        }\n+        return sb.toString();\n+    }\n+\n+    protected boolean isWhitespace(char ch) {\n+        return Character.isWhitespace(ch);\n+    }\n+\n+    protected void skipWhitespace() throws IOException {\n+        while (isWhitespace((char) ch)) {\n+            nextChar();\n+        }\n+    }\n+\n+    protected boolean isUnquotedAttrValueTerminator(char ch) {\n+        return switch (ch) {\n+            case '\\f', '\\n', '\\r', '\\t', ' ', '\"', '\\'', '`', '=', '<', '>' -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/HtmlFileChecker.java","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class Log {\n+    private final ArrayList<String> errors;\n+\n+    private Path baseDir;\n+\n+    public Log() {\n+        errors = new ArrayList<>();\n+    }\n+\n+    public List<String> getErrors() {\n+        return errors;\n+    }\n+\n+    public void log(Path path, int line, String message, Object... args) {\n+        errors.add(formatErrorMessage(path, line, message, args));\n+    }\n+\n+\n+    public String formatErrorMessage(Path path, int line, String message, Object... args) {\n+        return path + \":\" + line + \": \" + formatErrorMessage(message, args);\n+    }\n+\n+    public String formatErrorMessage(Path path, int line, Throwable t) {\n+        return path + \":\" + line + \": \" + t;\n+    }\n+\n+    public String formatErrorMessage(Path path, Throwable t) {\n+        return path + \": \" + t;\n+    }\n+\n+\n+    public String formatErrorMessage(String message, Object... args) {\n+        return String.format(message, args);\n+    }\n+\n+    public void log(String message) {\n+        errors.add(message);\n+    }\n+\n+    public void log(Path path, int lineNumber, String s, int errorsOnLine) {\n+        log(formatErrorMessage(path, lineNumber, s, errorsOnLine));\n+    }\n+\n+    public void log(Path path, int line, Throwable t) {\n+        log(formatErrorMessage(path, line, t));\n+    }\n+\n+    public void log(Path path, Throwable t) {\n+        log(formatErrorMessage(path, t));\n+    }\n+\n+    public void log(String message, Object... args) {\n+        log(formatErrorMessage(message, args));\n+    }\n+\n+    public void setBaseDirectory(Path baseDir) {\n+        this.baseDir = baseDir.toAbsolutePath();\n+    }\n+\n+    public Path relativize(Path path) {\n+        return baseDir != null && path.startsWith(baseDir) ? baseDir.relativize(path) : path;\n+    }\n+\n+    public boolean noErrors() {\n+        return errors.isEmpty();\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/Log.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils.checkers;\n+\n+import doccheckutils.FileChecker;\n+import doccheckutils.Log;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CodingErrorAction;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Checks the contents of an HTML file for bad\/unmappable characters.\n+ * <p>\n+ * The file encoding is determined from the file contents.\n+ *\/\n+public class BadCharacterChecker implements FileChecker, AutoCloseable {\n+    private static final Pattern doctype = Pattern.compile(\"(?i)<!doctype html>\");\n+    private static final Pattern metaCharset = Pattern.compile(\"(?i)<meta\\\\s+charset=\\\"([^\\\"]+)\\\">\");\n+    private static final Pattern metaContentType = Pattern.compile(\"(?i)<meta\\\\s+http-equiv=\\\"Content-Type\\\"\\\\s+content=\\\"text\/html;charset=([^\\\"]+)\\\">\");\n+    private final Log errors;\n+    private int files = 0;\n+    private int badFiles = 0;\n+\n+    public BadCharacterChecker() {\n+        errors = new Log();\n+    }\n+\n+    public void checkFile(Path path) {\n+        files++;\n+        boolean ok = true;\n+        try (InputStream in = new BufferedInputStream(Files.newInputStream(path))) {\n+            CharsetDecoder d = getCharset(in).newDecoder()\n+                    .onMalformedInput(CodingErrorAction.REPLACE)\n+                    .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            BufferedReader r = new BufferedReader(new InputStreamReader(in, d));\n+            int lineNumber = 0;\n+            String line;\n+            try {\n+                while ((line = r.readLine()) != null) {\n+                    lineNumber++;\n+                    int errorsOnLine = 0;\n+                    for (int i = 0; i < line.length(); i++) {\n+                        char ch = line.charAt(i);\n+                        if (ch == 0xFFFD) {\n+                            errorsOnLine++;\n+                        }\n+                    }\n+                    if (errorsOnLine > 0) {\n+                        errors.log(path, lineNumber, \"found %d invalid characters\", errorsOnLine);\n+                        ok = false;\n+                    }\n+                }\n+            } catch (IOException e) {\n+                errors.log(path, lineNumber, e);\n+                ok = false;\n+\n+            }\n+        } catch (IOException e) {\n+            errors.log(path, e);\n+            ok = false;\n+        }\n+        if (!ok)\n+            badFiles++;\n+    }\n+\n+    @Override\n+    public void checkFiles(List<Path> files) {\n+        for (Path file : files) {\n+            checkFile(file);\n+        }\n+    }\n+\n+    private Charset getCharset(InputStream in) throws IOException {\n+        CharsetDecoder initial = StandardCharsets.US_ASCII.newDecoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+\n+        in.mark(1024);\n+        try {\n+            BufferedReader r = new BufferedReader(new InputStreamReader(in, initial));\n+            char[] buf = new char[1024];\n+            int n = r.read(buf, 0, buf.length);\n+            String head = new String(buf, 0, n);\n+            boolean html5 = doctype.matcher(head).find();\n+            Matcher m1 = metaCharset.matcher(head);\n+            if (m1.find()) {\n+                return Charset.forName(m1.group(1));\n+            }\n+            Matcher m2 = metaContentType.matcher(head);\n+            if (m2.find()) {\n+                return Charset.forName(m2.group(1));\n+            }\n+            return html5 ? StandardCharsets.UTF_8 : StandardCharsets.ISO_8859_1;\n+        } finally {\n+            in.reset();\n+        }\n+    }\n+\n+    @Override\n+    public void report() {\n+        if (!errors.noErrors() && files > 0) {\n+            System.err.println(\"Bad characters found in the generated HTML\");\n+\n+            System.err.println(MessageFormat.format(\n+                    \"\"\"\n+                            Bad Characters Report\n+                            {0} files read\n+                                {1} files contained bad characters\"\n+                                {2} bad characters or other errors found\n+                            \"\"\",\n+                    files, badFiles, files));\n+\n+            for (String s : errors.getErrors()) {\n+                System.err.println(s);\n+            }\n+            throw new RuntimeException(\"Bad character found in the generated HTML\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return errors.noErrors();\n+    }\n+\n+    @Override\n+    public void close() {\n+        report();\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/checkers\/BadCharacterChecker.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils.checkers;\n+\n+import doccheckutils.HtmlChecker;\n+import doccheckutils.Log;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Checks the DocType declared at the head of an HTML file.\n+ *\n+ * @see <a href=\"https:\/\/www.w3.org\/TR\/html5\/syntax.html#syntax-doctype\">\n+ * W3C HTML5 8.1.1 The DOCTYPE<\/a>\n+ *\/\n+public class DocTypeChecker implements HtmlChecker {\n+    private final Log log;\n+    private final Map<String, Integer> counts = new HashMap<>();\n+    private int html5;\n+    private int html5_legacy;\n+    private int xml;\n+    private int other;\n+\n+    private Path path;\n+\n+    public DocTypeChecker() {\n+        log = new Log();\n+    }\n+\n+    @Override\n+    public void startFile(Path path) {\n+        this.path = path;\n+    }\n+\n+    @Override\n+    public void endFile() {\n+    }\n+\n+    @Override\n+    public void xml(int line, Map<String, String> attrs) {\n+        xml++;\n+    }\n+\n+    @Override\n+    public void docType(int line, String docType) {\n+        if (docType.equalsIgnoreCase(\"doctype html\")) {\n+            html5++;\n+        } else {\n+            Pattern p = Pattern.compile(\"(?i)doctype\"\n+                    + \"\\\\s+html\"\n+                    + \"\\\\s+([a-z]+)\"\n+                    + \"\\\\s+(?:\\\"([^\\\"]+)\\\"|'([^']+)')\"\n+                    + \"(?:\\\\s+(?:\\\"([^\\\"]+)\\\"|'([^']+)'))?\"\n+                    + \"\\\\s*\");\n+            Matcher m = p.matcher(docType);\n+            if (m.matches()) {\n+                \/\/ See http:\/\/www.w3.org\/tr\/html52\/syntax.html#the-doctype\n+                if (m.group(1).equalsIgnoreCase(\"system\")\n+                        && m.group(2).equals(\"about:legacy-compat\")) {\n+                    html5_legacy++;\n+                } else {\n+                    String version = m.group(2);\n+                    List<String> allowedVersions = List.of(\n+                            \"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\"\n+                    );\n+                    if (allowedVersions.stream().noneMatch(v -> v.equals(version))) {\n+                        log.log(path, line, \"unexpected doctype: \" + version);\n+                    }\n+                    counts.put(version, counts.getOrDefault(version, 0) + 1);\n+                }\n+            } else {\n+                log.log(path, line, \"doctype not recognized: \" + docType);\n+                other++;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void startElement(int line, String name, Map<String, String> attrs, boolean selfClosing) {\n+    }\n+\n+    @Override\n+    public void endElement(int line, String name) {\n+    }\n+\n+    @Override\n+    public void report() {\n+        log.log(\"DocType Report\");\n+        if (xml > 0) {\n+            log.log(\"%6d: XHTML%n\", xml);\n+        }\n+        if (html5 > 0) {\n+            log.log(\"%6d: HTML5%n\", html5);\n+        }\n+        if (html5_legacy > 0) {\n+            log.log(\"%6d: HTML5 (legacy)%n\", html5_legacy);\n+        }\n+\n+        Map<Integer, Set<String>> sortedCounts = new TreeMap<>(Comparator.reverseOrder());\n+\n+        for (Map.Entry<String, Integer> e : counts.entrySet()) {\n+            String s = e.getKey();\n+            Integer n = e.getValue();\n+            Set<String> set = sortedCounts.computeIfAbsent(n, k -> new TreeSet<>());\n+            set.add(s);\n+        }\n+\n+        for (Map.Entry<Integer, Set<String>> e : sortedCounts.entrySet()) {\n+            for (String p : e.getValue()) {\n+                log.log(\"%6d: %s%n\", e.getKey(), p);\n+            }\n+        }\n+\n+        if (other > 0) {\n+            log.log(\"%6d: other\/unrecognized%n\", other);\n+        }\n+\n+        for (var line : log.getErrors()) {\n+            System.err.println(line);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return counts.isEmpty() && (other == 0);\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (!isOK()) {\n+            report();\n+            throw new RuntimeException(\"Found HTML files with missing doctype declaration\");\n+        }\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/checkers\/DocTypeChecker.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package doccheckutils.checkers;\n+\n+\n+import doccheckutils.HtmlChecker;\n+import doccheckutils.Log;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Checks the external links referenced in HTML files.\n+ *\/\n+public class ExtLinkChecker implements HtmlChecker, AutoCloseable {\n+    private static final Path testBasePath = Path.of(System.getProperty(\"test.src\"));\n+    private static final Set<String> extLinks = new HashSet<>();\n+\n+    private static final String currentVersion = String.valueOf(Runtime.version().feature());\n+\n+    static {\n+        String input = null;\n+        try {\n+            input = Files.readString(testBasePath.getParent().resolve(\"ExtLinksJdk.txt\"));\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+        extLinks.addAll(input.lines()\n+                .filter(line -> !line.startsWith(\"#\"))\n+                .map(line -> line.replaceAll(\"\\\\@\\\\@JAVASE_VERSION\\\\@\\\\@\", currentVersion))\n+                .collect(Collectors.toUnmodifiableSet()));\n+    }\n+\n+    private final Log log;\n+    private final Map<URI, Set<Path>> allURIs;\n+    private int badURIs;\n+    private Path currFile;\n+\n+    public ExtLinkChecker() {\n+        this.log = new Log();\n+        allURIs = new TreeMap<>();\n+    }\n+\n+    @Override\n+    public void startFile(Path path) {\n+        currFile = path.toAbsolutePath().normalize();\n+    }\n+\n+    @Override\n+    public void endFile() {\n+    }\n+\n+    @Override\n+    public void xml(int line, Map<String, String> attrs) {\n+    }\n+\n+    @Override\n+    public void docType(int line, String doctype) {\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"fallthrough\")\n+    public void startElement(int line, String name, Map<String, String> attrs, boolean selfClosing) {\n+        switch (name) {\n+            case \"a\":\n+            case \"link\":\n+                String href = attrs.get(\"href\");\n+                if (href != null) {\n+                    foundReference(line, href);\n+                }\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void endElement(int line, String name) {\n+    }\n+\n+    private void foundReference(int line, String ref) {\n+        try {\n+            String uriPath = ref;\n+            String fragment = null;\n+\n+            \/\/ The checker runs into a problem with links that have more than one hash character.\n+            \/\/ You cannot create a URI unless the second hash is escaped.\n+\n+            int firstHashIndex = ref.indexOf('#');\n+            int lastHashIndex = ref.lastIndexOf('#');\n+            if (firstHashIndex != -1 && firstHashIndex != lastHashIndex) {\n+                uriPath = ref.substring(0, firstHashIndex);\n+                fragment = ref.substring(firstHashIndex + 1).replace(\"#\", \"%23\");\n+            } else if (firstHashIndex != -1) {\n+                uriPath = ref.substring(0, firstHashIndex);\n+                fragment = ref.substring(firstHashIndex + 1);\n+            }\n+\n+            URI uri = new URI(uriPath);\n+            if (fragment != null) {\n+                uri = new URI(uri + \"#\" + fragment);\n+            }\n+\n+            if (uri.isAbsolute()) {\n+                if (Objects.equals(uri.getScheme(), \"javascript\")) {\n+                    \/\/ ignore JavaScript URIs\n+                    return;\n+                }\n+                String rawFragment = uri.getRawFragment();\n+                URI noFrag = new URI(uri.toString().replaceAll(\"#\\\\Q\" + rawFragment + \"\\\\E$\", \"\"));\n+                allURIs.computeIfAbsent(noFrag, _ -> new LinkedHashSet<>()).add(currFile);\n+            }\n+        } catch (URISyntaxException e) {\n+            log.log(currFile, line, \"invalid URI: \" + e);\n+        }\n+    }\n+\n+    @Override\n+    public void report() {\n+        checkURIs();\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return badURIs == 0;\n+    }\n+\n+    @Override\n+    public void close() {\n+        report();\n+    }\n+\n+    private void checkURIs() {\n+        System.err.println(\"ExtLinkChecker: checking external links\");\n+        allURIs.forEach(this::checkURI);\n+        System.err.println(\"ExtLinkChecker: finished checking external links\");\n+    }\n+\n+    private void checkURI(URI uri, Set<Path> files) {\n+        try {\n+            switch (uri.getScheme()) {\n+                case \"ftp\":\n+                case \"http\":\n+                case \"https\":\n+                  isVettedLink(uri, files);\n+                    break;\n+                default:\n+                    warning(files, uri);\n+            }\n+        } catch (Throwable t) {\n+            badURIs++;\n+            error(files, uri, t);\n+        }\n+    }\n+\n+    private void isVettedLink(URI uri, Set<Path> files) {\n+        if (!extLinks.contains(uri.toString())) {\n+            System.err.println(MessageFormat.format(\"\"\"\n+                    The external link {0} needs to be added to the whitelist test\/docs\/jdk\/javadoc\/doccheck\/ExtLinksJdk.txt in order to be checked regularly\\s\n+                    The link is present in:\n+                        {1}\\n\n+                    \"\"\", uri, files.stream().map(Path::toString).collect(Collectors.joining(\"\\n    \"))));\n+        }\n+    }\n+\n+    private void warning(Set<Path> files, Object... args) {\n+        Iterator<Path> iter = files.iterator();\n+        Path first = iter.next();\n+        log.log(String.valueOf(first), \"URI not supported: %s\", args);\n+        reportAlsoFoundIn(iter);\n+    }\n+\n+    private void error(Set<Path> files, Object... args) {\n+        Iterator<Path> iter = files.iterator();\n+        Path first = iter.next();\n+        log.log(String.valueOf(first), \"Exception accessing uri: %s%n    [%s]\", args);\n+        reportAlsoFoundIn(iter);\n+    }\n+\n+    private void reportAlsoFoundIn(Iterator<Path> iter) {\n+        int MAX_EXTRA = 10;\n+        int n = 0;\n+        while (iter.hasNext()) {\n+            log.log(\"    Also found in %s\", log.relativize(iter.next()));\n+            if (n++ == MAX_EXTRA) {\n+                int rest = 0;\n+                while (iter.hasNext()) {\n+                    iter.next();\n+                    rest++;\n+                }\n+                log.log(\"    ... and %d more\", rest);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/checkers\/ExtLinkChecker.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,440 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils.checkers;\n+\n+\n+import doccheckutils.HtmlChecker;\n+import doccheckutils.Log;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+\/**\n+ * Checks the links defined by and referenced in HTML files.\n+ *\/\n+public class LinkChecker implements HtmlChecker {\n+\n+    private final Log log;\n+    private final Map<Path, IDTable> allFiles;\n+    private final Map<URI, IDTable> allURIs;\n+    \/\/ left for debugging\n+    private final boolean checkInwardReferencesOnly = false;\n+    private int files;\n+    private int links;\n+    private int duplicateIds;\n+    private int missingFiles;\n+    private int missingIds;\n+    private int badSchemes;\n+    private Path currFile;\n+    private IDTable currTable;\n+    private boolean html5;\n+    public LinkChecker() {\n+        this.log = new Log();\n+        allFiles = new HashMap<>();\n+        allURIs = new HashMap<>();\n+    }\n+\n+    public void setBaseDir(Path dir) {\n+        log.setBaseDirectory(dir);\n+    }\n+\n+    @Override\n+    public void startFile(Path path) {\n+        currFile = path.toAbsolutePath().normalize();\n+        currTable = allFiles.computeIfAbsent(currFile, p -> new IDTable(log.relativize(p)));\n+        html5 = false;\n+        files++;\n+    }\n+\n+    @Override\n+    public void endFile() {\n+        currTable.check();\n+    }\n+\n+\n+    \/\/unused\n+    public List<Path> getUncheckedFiles() {\n+        return allFiles.entrySet().stream()\n+                .filter(e -> !e.getValue().checked\n+                        && e.getKey().toString().endsWith(\".html\")\n+                        && Files.exists(e.getKey()))\n+                .map(Map.Entry::getKey)\n+                .toList();\n+    }\n+\n+    public List<Path> getMissingFiles() {\n+        return allFiles.keySet().stream()\n+                .filter(idTable -> !Files.exists(idTable)).toList();\n+    }\n+\n+    @Override\n+    public void xml(int line, Map<String, String> attrs) {\n+    }\n+\n+    @Override\n+    public void docType(int line, String doctype) {\n+        html5 = doctype.matches(\"(?i)<\\\\?doctype\\\\s+html>\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"fallthrough\")\n+    public void startElement(int line, String name, Map<String, String> attrs, boolean selfClosing) {\n+        switch (name) {\n+            case \"a\":\n+                String nameAttr = html5 ? null : attrs.get(\"name\");\n+                if (nameAttr != null) {\n+                    foundAnchor(line, nameAttr);\n+                }\n+                \/\/ fallthrough\n+            case \"link\":\n+                String href = attrs.get(\"href\");\n+                if (href != null && !checkInwardReferencesOnly) {\n+                    foundReference(line, href);\n+                }\n+                break;\n+        }\n+\n+        String idAttr = attrs.get(\"id\");\n+        if (idAttr != null) {\n+            foundAnchor(line, idAttr);\n+        }\n+    }\n+\n+    @Override\n+    public void endElement(int line, String name) {\n+    }\n+\n+    @Override\n+    public void content(int line, String content) {\n+        HtmlChecker.super.content(line, content);\n+    }\n+\n+    @Override\n+    public void report() {\n+        List<Path> pathList = getMissingFiles();\n+        log.log(\"\");\n+        log.log(\"Link Checker Report\");\n+\n+        if (!pathList.isEmpty()) {\n+            log.log(\"\");\n+            log.log(\"Missing files: (\" + pathList.size() + \")\");\n+            pathList.stream()\n+                    .sorted()\n+                    .forEach(this::reportMissingFile);\n+        }\n+\n+        int anchors = 0;\n+        for (IDTable t : allFiles.values()) {\n+            anchors += (int) t.map.values().stream()\n+                    .filter(e -> !e.getReferences().isEmpty())\n+                    .count();\n+        }\n+        for (IDTable t : allURIs.values()) {\n+            anchors += (int) t.map.values().stream()\n+                    .filter(e -> !e.references.isEmpty())\n+                    .count();\n+        }\n+\n+        log.log(\"Checked \" + files + \" files.\");\n+        log.log(\"Found \" + links + \" references to \" + anchors + \" anchors \"\n+                + \"in \" + allFiles.size() + \" files and \" + allURIs.size() + \" other URIs.\");\n+        if (!pathList.isEmpty()) {\n+            log.log(\"%6d missing files\", pathList.size());\n+        }\n+        if (duplicateIds > 0) {\n+            log.log(\"%6d duplicate ids\", duplicateIds);\n+\n+        }\n+        if (missingIds > 0) {\n+            log.log(\"%6d missing ids\", missingIds);\n+\n+        }\n+\n+        Map<String, Integer> hostCounts = new TreeMap<>(new HostComparator());\n+        for (URI uri : allURIs.keySet()) {\n+            String host = uri.getHost();\n+            if (host != null) {\n+                hostCounts.put(host, hostCounts.computeIfAbsent(host, h -> 0) + 1);\n+            }\n+        }\n+\n+\/\/        if (hostCounts.size() > 0) {\n+\/\/            log.log(\"\");\n+\/\/            log.log(\"Hosts\");\n+\/\/            hostCounts.forEach((h, n) -> log.log(\"%6d %s\", n, h));\n+\/\/        }\n+\n+\n+        for (String message : log.getErrors()) {\n+            System.err.println(message);\n+        }\n+\n+    }\n+\n+    private void reportMissingFile(Path file) {\n+        log.log(log.relativize(file).toString());\n+        IDTable table = allFiles.get(file);\n+        Set<Path> refs = new TreeSet<>();\n+        for (IDInfo id : table.map.values()) {\n+            if (id.references != null) {\n+                for (Position ref : id.references) {\n+                    refs.add(ref.path);\n+                }\n+            }\n+        }\n+        int n = 0;\n+        int MAX_REFS = 10;\n+        for (Path ref : refs) {\n+            log.log(\"    in \" + log.relativize(ref));\n+            if (++n == MAX_REFS) {\n+                log.log(\"    ... and %d more\", refs.size() - n);\n+                break;\n+            }\n+        }\n+        missingFiles++;\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return duplicateIds == 0\n+                && missingIds == 0\n+                && missingFiles == 0\n+                && badSchemes == 0;\n+    }\n+\n+    @Override\n+    public void close() {\n+        report();\n+        if (!isOK()) {\n+            throw new RuntimeException(\n+                    \"LinkChecker encountered errors. Duplicate IDs: \"\n+                            + duplicateIds + \", Missing IDs: \" + missingIds\n+                            + \", Missing Files: \" + missingFiles + \", Bad Schemes: \" + badSchemes);\n+        }\n+    }\n+\n+    private void foundAnchor(int line, String name) {\n+        currTable.addID(line, name);\n+    }\n+\n+    private void foundReference(int line, String ref) {\n+        links++;\n+        try {\n+            String uriPath = ref;\n+            String fragment = null;\n+\n+            \/\/ The checker runs into a problem with links that have more than one hash character.\n+            \/\/ You cannot create a URI unless the second hash is escaped.\n+\n+            int firstHashIndex = ref.indexOf('#');\n+            int lastHashIndex = ref.lastIndexOf('#');\n+            if (firstHashIndex != -1 && firstHashIndex != lastHashIndex) {\n+                uriPath = ref.substring(0, firstHashIndex);\n+                fragment = ref.substring(firstHashIndex + 1).replace(\"#\", \"%23\");\n+            } else if (firstHashIndex != -1) {\n+                uriPath = ref.substring(0, firstHashIndex);\n+                fragment = ref.substring(firstHashIndex + 1);\n+            }\n+\n+            URI uri = new URI(uriPath);\n+            if (fragment != null) {\n+                uri = new URI(uri + \"#\" + fragment);\n+            }\n+\n+            if (uri.isAbsolute()) {\n+                foundReference(line, uri);\n+            } else {\n+                Path p;\n+                String resolvedUriPath = uri.getPath();\n+                if (resolvedUriPath == null || resolvedUriPath.isEmpty()) {\n+                    p = currFile;\n+                } else {\n+                    p = currFile.getParent().resolve(resolvedUriPath).normalize();\n+                }\n+\n+                if (fragment != null && !fragment.isEmpty()) {\n+                    foundReference(line, p, fragment);\n+                }\n+            }\n+        } catch (URISyntaxException e) {\n+            System.err.println(\"Failed to create URI: \" + ref);\n+            log.log(currFile, line, \"invalid URI: \" + e);\n+        }\n+    }\n+\n+\n+    private void foundReference(int line, Path p, String fragment) {\n+        IDTable t = allFiles.computeIfAbsent(p, key -> new IDTable(log.relativize(key)));\n+        t.addReference(fragment, currFile, line);\n+    }\n+\n+    private void foundReference(int line, URI uri) {\n+        if (!isSchemeOK(uri.getScheme()) && !checkInwardReferencesOnly) {\n+            log.log(currFile, line, \"bad scheme in URI\");\n+            badSchemes++;\n+        }\n+\n+        String fragment = uri.getRawFragment();\n+        if (fragment != null && !fragment.isEmpty()) {\n+            try {\n+                URI noFrag = new URI(uri.toString().replaceAll(\"#\\\\Q\" + fragment + \"\\\\E$\", \"\"));\n+                IDTable t = allURIs.computeIfAbsent(noFrag, IDTable::new);\n+                t.addReference(fragment, currFile, line);\n+            } catch (URISyntaxException e) {\n+                throw new Error(e);\n+            }\n+        }\n+    }\n+\n+    private boolean isSchemeOK(String uriScheme) {\n+        if (uriScheme == null) {\n+            return true;\n+        }\n+\n+        return switch (uriScheme) {\n+            case \"ftp\", \"http\", \"https\", \"javascript\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static class Position implements Comparable<Position> {\n+        Path path;\n+        int line;\n+\n+        Position(Path path, int line) {\n+            this.path = path;\n+            this.line = line;\n+        }\n+\n+        @Override\n+        public int compareTo(Position o) {\n+            int v = path.compareTo(o.path);\n+            return v != 0 ? v : Integer.compare(line, o.line);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            } else if (obj == null || getClass() != obj.getClass()) {\n+                return false;\n+            } else {\n+                final Position other = (Position) obj;\n+                return Objects.equals(this.path, other.path)\n+                        && this.line == other.line;\n+            }\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(path) * 37 + line;\n+        }\n+    }\n+\n+    static class IDInfo {\n+        boolean declared;\n+        Set<Position> references;\n+\n+        Set<Position> getReferences() {\n+            return references == null ? Collections.emptySet() : references;\n+        }\n+    }\n+\n+    static class HostComparator implements Comparator<String> {\n+        @Override\n+        public int compare(String h1, String h2) {\n+            List<String> l1 = new ArrayList<>(Arrays.asList(h1.split(\"\\\\.\")));\n+            Collections.reverse(l1);\n+            String r1 = String.join(\".\", l1);\n+            List<String> l2 = new ArrayList<>(Arrays.asList(h2.split(\"\\\\.\")));\n+            Collections.reverse(l2);\n+            String r2 = String.join(\".\", l2);\n+            return r1.compareTo(r2);\n+        }\n+    }\n+\n+    class IDTable {\n+        private final Map<String, IDInfo> map = new HashMap<>();\n+        private final String pathOrURI;\n+        private boolean checked;\n+\n+        IDTable(Path path) {\n+            this.pathOrURI = path.toString();\n+        }\n+\n+        IDTable(URI uri) {\n+            this.pathOrURI = uri.toString();\n+        }\n+\n+        void addID(int line, String name) {\n+            if (checked) {\n+                throw new IllegalStateException(\"Adding ID after file has been\");\n+            }\n+            Objects.requireNonNull(name);\n+            IDInfo info = map.computeIfAbsent(name, _ -> new IDInfo());\n+            if (info.declared) {\n+                if (info.references != null || !checkInwardReferencesOnly) {\n+                    \/\/ don't report error if we're only checking inbound references\n+                    \/\/ and there are no references to this ID.\n+                    log.log(log.relativize(currFile), line, \"name already declared: \" + name);\n+                    duplicateIds++;\n+                }\n+            } else {\n+                info.declared = true;\n+            }\n+        }\n+\n+        void addReference(String name, Path from, int line) {\n+            if (checked) {\n+                if (name != null) {\n+                    IDInfo id = map.get(name);\n+                    if (id == null || !id.declared) {\n+                        log.log(log.relativize(from), line, \"id not found: \" + this.pathOrURI + \"#\" + name);\n+                    }\n+                }\n+            } else {\n+                IDInfo id = map.computeIfAbsent(name, x -> new IDInfo());\n+                if (id.references == null) {\n+                    id.references = new TreeSet<>();\n+                }\n+                id.references.add(new Position(from, line));\n+            }\n+        }\n+\n+        void check() {\n+            map.forEach((name, id) -> {\n+                if (name != null && !id.declared) {\n+                    for (Position ref : id.references) {\n+                        log.log(log.relativize(ref.path), ref.line, \"id not found: \" + this.pathOrURI + \"#\" + name);\n+                    }\n+                    missingIds++;\n+                }\n+            });\n+            checked = true;\n+        }\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/checkers\/LinkChecker.java","additions":440,"deletions":0,"binary":false,"changes":440,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package doccheckutils.checkers;\n+\n+\n+import doccheckutils.FileChecker;\n+import doccheckutils.Log;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class TidyChecker implements FileChecker, AutoCloseable {\n+    private final Path TIDY;\n+    final Map<Pattern, Integer> counts = new HashMap<>();\n+    final Pattern okPattern = Pattern.compile(\"No warnings or errors were found.\");\n+    final Pattern countPattern = Pattern.compile(\"([0-9]+) warnings, ([0-9]+) errors were found!.*?(Not all warnings\/errors were shown.)?\");\n+    final Pattern countPattern2 = Pattern.compile(\"Tidy found ([0-9]+) warning[s]? and ([0-9]+) error[s]?!.*?(Not all warnings\/errors were shown.)?\");\n+    final Pattern cssPattern = Pattern.compile(\"You are recommended to use CSS.*\");\n+    final Pattern guardPattern = Pattern.compile(\"(line [0-9]+ column [0-9]+ - |[^:]+:[0-9]+:[0-9]+: )(Error|Warning):.*\");\n+\n+    final Pattern[] patterns = {\n+            Pattern.compile(\".*Error: <.*> is not recognized!\"),\n+            Pattern.compile(\".*Error: missing quote mark for attribute value\"),\n+            Pattern.compile(\".*Warning: '<' \\\\+ '\/' \\\\+ letter not allowed here\"),\n+            Pattern.compile(\".*Warning: <.*> anchor \\\".*\\\" already defined\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" has invalid value \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" lacks value\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" lacks value\"),\n+            Pattern.compile(\".*Warning: <.*> attribute with missing trailing quote mark\"),\n+            Pattern.compile(\".*Warning: <.*> dropping value \\\".*\\\" for repeated attribute \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: <.*> inserting \\\".*\\\" attribute\"),\n+            Pattern.compile(\".*Warning: <.*> is probably intended as <\/.*>\"),\n+            Pattern.compile(\".*Warning: <.*> isn't allowed in <.*> elements\"),\n+            Pattern.compile(\".*Warning: <.*> lacks \\\".*\\\" attribute\"),\n+            Pattern.compile(\".*Warning: <.*> missing '>' for end of tag\"),\n+            Pattern.compile(\".*Warning: <.*> proprietary attribute \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: <.*> unexpected or duplicate quote mark\"),\n+            Pattern.compile(\".*Warning: <a> id and name attribute value mismatch\"),\n+            Pattern.compile(\".*Warning: <a> cannot copy name attribute to id\"),\n+            Pattern.compile(\".*Warning: <a> escaping malformed URI reference\"),\n+            Pattern.compile(\".*Warning: <blockquote> proprietary attribute \\\"pre\\\"\"),\n+            Pattern.compile(\".*Warning: discarding unexpected <.*>\"),\n+            Pattern.compile(\".*Warning: discarding unexpected <\/.*>\"),\n+            Pattern.compile(\".*Warning: entity \\\".*\\\" doesn't end in ';'\"),\n+            Pattern.compile(\".*Warning: inserting implicit <.*>\"),\n+            Pattern.compile(\".*Warning: inserting missing 'title' element\"),\n+            Pattern.compile(\".*Warning: missing <!DOCTYPE> declaration\"),\n+            Pattern.compile(\".*Warning: missing <.*>\"),\n+            Pattern.compile(\".*Warning: missing <\/.*> before <.*>\"),\n+            Pattern.compile(\".*Warning: nested emphasis <.*>\"),\n+            Pattern.compile(\".*Warning: plain text isn't allowed in <.*> elements\"),\n+            Pattern.compile(\".*Warning: removing whitespace preceding XML Declaration\"),\n+            Pattern.compile(\".*Warning: replacing <p> (by|with) <br>\"),\n+            Pattern.compile(\".*Warning: replacing invalid numeric character reference .*\"),\n+            Pattern.compile(\".*Warning: replacing obsolete element <xmp> with <pre>\"),\n+            Pattern.compile(\".*Warning: replacing unexpected .* (by|with) <\/.*>\"),\n+            Pattern.compile(\".*Warning: trimming empty <.*>\"),\n+            Pattern.compile(\".*Warning: unescaped & or unknown entity \\\".*\\\"\"),\n+            Pattern.compile(\".*Warning: unescaped & which should be written as &amp;\"),\n+            Pattern.compile(\".*Warning: using <br> in place of <p>\"),\n+            Pattern.compile(\".*Warning: <.*> element removed from HTML5\"),\n+            Pattern.compile(\".*Warning: <.*> attribute \\\".*\\\" not allowed for HTML5\"),\n+            Pattern.compile(\".*Warning: The summary attribute on the <table> element is obsolete in HTML5\"),\n+            Pattern.compile(\".*Warning: replacing invalid UTF-8 bytes \\\\(char. code U\\\\+.*\\\\)\")\n+    };\n+    private final Log errors;\n+    private int files = 0;\n+    private int ok;\n+    private int warns;\n+    private int errs;\n+    private int css;\n+    private int overflow;\n+\n+    public TidyChecker() {\n+        TIDY = initTidy();\n+        errors = new Log();\n+    }\n+\n+    @Override\n+    public void checkFiles(List<Path> sb) {\n+        files += sb.size();\n+        try {\n+            for (int i = 0; i < sb.size(); i += 1024) {\n+                List<String> command = new ArrayList<>();\n+                command.add(TIDY.toString());\n+                command.add(\"-q\");\n+                command.add(\"-e\");\n+                command.add(\"--gnu-emacs\");\n+                command.add(\"true\");\n+                List<Path> sublist = sb.subList(i, Math.min(i + 1024, sb.size()));\n+                for (Path p : sublist) {\n+                    command.add(p.toString());\n+                }\n+                Process p = new ProcessBuilder()\n+                        .command(command)\n+                        .redirectErrorStream(true)\n+                        .start();\n+                try (BufferedReader r =\n+                             new BufferedReader(new InputStreamReader(p.getInputStream(), StandardCharsets.UTF_8))) {\n+                    String line;\n+                    while ((line = r.readLine()) != null) {\n+                        checkLine(line);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private Path initTidy() {\n+        Path tidyExePath;\n+        String tidyProperty = System.getProperty(\"tidy\");\n+        if (tidyProperty != null) {\n+            tidyExePath = Path.of(tidyProperty);\n+            if (!Files.exists(tidyExePath)) {\n+                System.err.println(\"tidy not found: \" + tidyExePath);\n+            }\n+            if (!Files.isExecutable(tidyExePath)) {\n+                System.err.println(\"tidy not executable: \" + tidyExePath);\n+            }\n+        } else {\n+            boolean isWindows = System.getProperty(\"os.name\")\n+                    .toLowerCase(Locale.US)\n+                    .startsWith(\"windows\");\n+            String tidyExe = isWindows ? \"tidy.exe\" : \"tidy\";\n+            Optional<Path> p = Stream.of(System.getenv(\"PATH\")\n+                            .split(File.pathSeparator))\n+                    .map(Path::of)\n+                    .map(d -> d.resolve(tidyExe))\n+                    .filter(Files::exists)\n+                    .filter(Files::isExecutable)\n+                    .findFirst();\n+            if (p.isPresent()) {\n+                tidyExePath = p.get();\n+            } else {\n+                System.err.println(\"tidy not found on PATH\");\n+                return Path.of(\"tidy\"); \/\/non-null placeholder return; exception would be better\n+            }\n+        }\n+\n+        try {\n+            Process p = new ProcessBuilder()\n+                    .command(tidyExePath.toString(), \"-version\")\n+                    .redirectErrorStream(true)\n+                    .start();\n+            try (BufferedReader r =\n+                         new BufferedReader(new InputStreamReader(p.getInputStream(), StandardCharsets.UTF_8))) {\n+                List<String> lines = r.lines().collect(Collectors.toList());\n+                \/\/ Look for a line containing \"version\" and a dotted identifier beginning 5.\n+                \/\/ If not found, look for known old\/bad versions, to report in error message\n+                Pattern version = Pattern.compile(\"version.* [5678]\\\\.\\\\d+(\\\\.\\\\d+)\");\n+                if (lines.stream().noneMatch(line -> version.matcher(line).find())) {\n+                    Pattern oldVersion = Pattern.compile(\"2006\");  \/\/ 2006 implies old macOS version\n+                    String lineSep = System.lineSeparator();\n+                    String message = lines.stream().anyMatch(line -> oldVersion.matcher(line).find())\n+                            ? \"old version of 'tidy' found on the PATH\\n\"\n+                            : \"could not determine the version of 'tidy' on the PATH\\n\";\n+                    System.err.println(message + String.join(lineSep, lines));\n+                }\n+            }\n+        } catch (IOException e) {\n+            System.err.println(\"Could not execute 'tidy -version': \" + e);\n+        }\n+\n+        return tidyExePath;\n+    }\n+\n+    @Override\n+    public void report() {\n+        if (files > 0) {\n+            System.err.println(\"Tidy found errors in the generated HTML\");\n+            if (!errors.noErrors()) {\n+                for (String s : errors.getErrors()) {\n+                    System.err.println(s);\n+                }\n+                System.err.println(\"Tidy output end.\");\n+                System.err.println();\n+                System.err.println();\n+                throw new RuntimeException(\"Tidy found errors in the generated HTML\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOK() {\n+        return (ok == files)\n+                && (overflow == 0)\n+                && (errs == 0)\n+                && (warns == 0)\n+                && (css == 0);\n+    }\n+\n+    void checkLine(String line) {\n+        Matcher m;\n+        if (okPattern.matcher(line).matches()) {\n+            ok++;\n+        } else if ((m = countPattern.matcher(line)).matches() || (m = countPattern2.matcher(line)).matches()) {\n+            warns += Integer.parseInt(m.group(1));\n+            errs += Integer.parseInt(m.group(2));\n+            if (m.group(3) != null)\n+                overflow++;\n+        } else if (guardPattern.matcher(line).matches()) {\n+            boolean found = false;\n+            for (Pattern p : patterns) {\n+                if (p.matcher(line).matches()) {\n+                    errors.log(\"%s\", line);\n+                    found = true;\n+                    count(p);\n+                    break;\n+                }\n+            }\n+            if (!found)\n+                errors.log(\"unrecognized line: \" + line);\n+        } else if (cssPattern.matcher(line).matches()) {\n+            css++;\n+        }\n+    }\n+\n+    void count(Pattern p) {\n+        Integer i = counts.get(p);\n+        counts.put(p, (i == null) ? 1 : i + 1);\n+    }\n+\n+    @Override\n+    public void close() {\n+        report();\n+    }\n+}\n","filename":"test\/docs\/jdk\/javadoc\/doccheck\/doccheckutils\/checkers\/TidyChecker.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -292,0 +292,3 @@\n+\n+  \/\/ Check all platforms print this compatibly without leading 0x.\n+  check_format(UINT64_FORMAT_0,        (u8)0x123,         \"0000000000000123\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+runtime\/classFileParserBug\/TestEmptyBootstrapMethodsAttr.java JDK-8346442 generic-all\n@@ -108,0 +109,1 @@\n+runtime\/logging\/LoaderConstraintsTest.java JDK-8346442 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-Virtual.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,0 @@\n-vmTestbase\/gc\/memory\/Nio\/Nio.java 8340728 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+        \"-XX:-SegmentedCodeCache\",\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.verify;\n+\n+import java.util.Optional;\n+import java.lang.foreign.*;\n+\n+\/**\n+ * The {@link Verify} class provides a single {@link Verify#checkEQ} static method, which recursively\n+ * compares the two {@link Object}s by value. It deconstructs {@link Object[]}, compares boxed primitive\n+ * types, and compares the content of arrays and {@link MemorySegment}s.\n+ *\n+ * When a comparison fail, then methods print helpful messages, before throwing a {@link VerifyException}.\n+ *\/\n+public final class Verify {\n+\n+    private Verify() {}\n+\n+    \/**\n+     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     *\n+     * @param a First object to be recursively compared with the second.\n+     * @param b Second object to be recursively compared with the first.\n+     * @throws VerifyException If the comparison fails.\n+     *\/\n+    public static void checkEQ(Object a, Object b) {\n+        checkEQ(a, b, \"\");\n+    }\n+\n+    \/**\n+     * Verify the content of two Objects, possibly recursively. Only limited types are implemented.\n+     *\/\n+    private static void checkEQ(Object a, Object b, String context) {\n+        \/\/ Both null\n+        if (a == null && b == null) {\n+            return;\n+        }\n+\n+        \/\/ Null mismatch\n+        if (a == null || b == null) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: null mismatch\");\n+            print(a, \"a \" + context);\n+            print(b, \"b \" + context);\n+            throw new VerifyException(\"Object array null mismatch.\");\n+        }\n+\n+        \/\/ Class mismatch\n+        Class ca = a.getClass();\n+        Class cb = b.getClass();\n+        if (ca != cb) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: class mismatch.\");\n+            System.err.println(\"       \" + ca.getName() + \" vs \" + cb.getName());\n+            print(a, \"a \" + context);\n+            print(b, \"b \" + context);\n+            throw new VerifyException(\"Object class mismatch.\");\n+        }\n+\n+        switch (a) {\n+            case Object[]  x -> checkEQimpl(x, (Object[])b,                context);\n+            case Byte      x -> checkEQimpl(x, ((Byte)b).byteValue(),      context);\n+            case Character x -> checkEQimpl(x, ((Character)b).charValue(), context);\n+            case Short     x -> checkEQimpl(x, ((Short)b).shortValue(),    context);\n+            case Integer   x -> checkEQimpl(x, ((Integer)b).intValue(),    context);\n+            case Long      x -> checkEQimpl(x, ((Long)b).longValue(),      context);\n+            case Float     x -> checkEQimpl(x, ((Float)b).floatValue(),    context);\n+            case Double    x -> checkEQimpl(x, ((Double)b).doubleValue(),  context);\n+            case byte[]    x -> checkEQimpl(x, (byte[])b,                  context);\n+            case char[]    x -> checkEQimpl(x, (char[])b,                  context);\n+            case short[]   x -> checkEQimpl(x, (short[])b,                 context);\n+            case int[]     x -> checkEQimpl(x, (int[])b,                   context);\n+            case long[]    x -> checkEQimpl(x, (long[])b,                  context);\n+            case float[]   x -> checkEQimpl(x, (float[])b,                 context);\n+            case double[]  x -> checkEQimpl(x, (double[])b,                context);\n+            case MemorySegment x -> checkEQimpl(x, (MemorySegment) b,      context);\n+            default -> {\n+                System.err.println(\"ERROR: Verify.checkEQ failed: type not supported: \" + ca.getName());\n+                print(a, \"a \" + context);\n+                print(b, \"b \" + context);\n+                throw new VerifyException(\"Object array type not supported: \" + ca.getName());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two bytes are identical.\n+     *\/\n+    private static void checkEQimpl(byte a, byte b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two chars are identical.\n+     *\/\n+    private static void checkEQimpl(char a, char b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two shorts are identical.\n+     *\/\n+    private static void checkEQimpl(short a, short b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + (int)a + \" vs \" + (int)b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + (int)a + \" vs \" + (int)b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two ints are identical.\n+     *\/\n+    private static void checkEQimpl(int a, int b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two longs are identical.\n+     *\/\n+    private static void checkEQimpl(long a, long b, String context) {\n+        if (a != b) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch: \" + a + \" vs \" + b + \" for \" + context);\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two floats have identical bits.\n+     *\/\n+    private static void checkEQimpl(float a, float b, String context) {\n+        if (Float.floatToRawIntBits(a) != Float.floatToRawIntBits(b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+            System.err.println(\"       Values: \" + a + \" vs \" + b);\n+            System.err.println(\"       Values: \" + Float.floatToRawIntBits(a) + \" vs \" + Float.floatToRawIntBits(b));\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that two doubles have identical bits.\n+     *\/\n+    private static void checkEQimpl(double a, double b, String context) {\n+        if (Double.doubleToRawLongBits(a) != Double.doubleToRawLongBits(b)) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: value mismatch for \" + context);\n+            System.err.println(\"       Values: \" + a + \" vs \" + b);\n+            System.err.println(\"       Values: \" + Double.doubleToRawLongBits(a) + \" vs \" + Double.doubleToRawLongBits(b));\n+            throw new VerifyException(\"Value mismatch: \" + a + \" vs \" + b);\n+        }\n+    }\n+\n+    \/**\n+     * Verify that the content of two MemorySegments is identical. Note: we do not check the\n+     * backing type, only the size and content.\n+     *\/\n+    private static void checkEQimpl(MemorySegment a, MemorySegment b, String context) {\n+        long offset = a.mismatch(b);\n+        if (offset == -1) { return; }\n+\n+        \/\/ Print some general info\n+        System.err.println(\"ERROR: Verify.checkEQ failed for: \" + context);\n+\n+        printMemorySegment(a, \"a \" + context);\n+        printMemorySegment(b, \"b \" + context);\n+\n+        \/\/ (1) Mismatch on size\n+        if (a.byteSize() != b.byteSize()) {\n+            throw new VerifyException(\"MemorySegment byteSize mismatch.\");\n+        }\n+\n+        \/\/ (2) Value mismatch\n+        System.err.println(\"  Value mismatch at byte offset: \" + offset);\n+        printMemorySegmentValue(a, offset, 16);\n+        printMemorySegmentValue(b, offset, 16);\n+        throw new VerifyException(\"MemorySegment value mismatch.\");\n+    }\n+\n+    \/**\n+     * Verify that the content of two byte arrays is identical.\n+     *\/\n+    private static void checkEQimpl(byte[] a, byte[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two char arrays is identical.\n+     *\/\n+    private static void checkEQimpl(char[] a, char[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two short arrays is identical.\n+     *\/\n+    private static void checkEQimpl(short[] a, short[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two int arrays is identical.\n+     *\/\n+    private static void checkEQimpl(int[] a, int[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two long arrays is identical.\n+     *\/\n+    private static void checkEQimpl(long[] a, long[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two float arrays is identical.\n+     *\/\n+    private static void checkEQimpl(float[] a, float[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two double arrays is identical.\n+     *\/\n+    private static void checkEQimpl(double[] a, double[] b, String context) {\n+        checkEQimpl(MemorySegment.ofArray(a), MemorySegment.ofArray(b), context);\n+    }\n+\n+    \/**\n+     * Verify that the content of two Object arrays is identical, recursively:\n+     * every element is compared with checkEQimpl for the corresponding type.\n+     *\/\n+    private static void checkEQimpl(Object[] a, Object[] b, String context) {\n+        \/\/ (1) Length mismatch\n+        if (a.length != b.length) {\n+            System.err.println(\"ERROR: Verify.checkEQ failed: length mismatch: \" + a.length + \" vs \" + b.length);\n+            throw new VerifyException(\"Object array length mismatch.\");\n+        }\n+\n+        for (int i = 0; i < a.length; i++) {\n+            \/\/ Recursive checkEQ call.\n+            checkEQ(a[i], b[i], \"[\" + i + \"]\" + context);\n+        }\n+    }\n+\n+    private static void print(Object a, String context) {\n+        if (a == null) {\n+            System.err.println(\"  \" + context + \": null\");\n+        } else {\n+            System.err.println(\"  \" + context + \": \" + a);\n+        }\n+    }\n+\n+    private static void printMemorySegment(MemorySegment a, String context) {\n+        Optional<Object> maybeBase = a.heapBase();\n+        System.err.println(\"  \" + context + \" via MemorySegment:\");\n+        if (maybeBase.isEmpty()) {\n+            System.err.println(\"    no heap base (native).\");\n+        } else {\n+            Object base = maybeBase.get();\n+            System.err.println(\"    heap base: \" + base);\n+        }\n+        System.err.println(\"    address: \" + a.address());\n+        System.err.println(\"    byteSize: \" + a.byteSize());\n+    }\n+\n+    private static void printMemorySegmentValue(MemorySegment a, long offset, int range) {\n+        long start = Long.max(offset - range, 0);\n+        long end   = Long.min(offset + range, a.byteSize());\n+        for (long i = start; i < end; i++) {\n+            byte b = a.get(ValueLayout.JAVA_BYTE, i);\n+            System.err.print(String.format(\"%02x \", b));\n+        }\n+        System.err.println(\"\");\n+        for (long i = start; i < end; i++) {\n+            if (i == offset) {\n+                System.err.print(\"^^ \");\n+            } else {\n+                System.err.print(\"   \");\n+            }\n+        }\n+        System.err.println(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.verify;\n+\n+\/**\n+ * Exception thrown in verification.\n+ *\/\n+public class VerifyException extends RuntimeException {\n+\n+    \/**\n+     * Creates a new verification exception.\n+     *\n+     * @param message Exception message for context when debugging.\n+     *\/\n+    public VerifyException(String message) {\n+        super(\"Value verification failed:\" + System.lineSeparator() + message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/VerifyException.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ *\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n+    private static int intField;\n+    private static long longField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(9, 10, 1, true);\n+            test1(9, 10, 1, false);\n+            test2(9, 10, 1, true);\n+            test2(9, 10, 1, false);\n+            test3(9, 10, 1, true);\n+            test3(9, 10, 1, false);\n+            test4(9, 10, 1, true);\n+            test4(9, 10, 1, false);\n+            test5(9, 10, 1, true);\n+            test5(9, 10, 1, false);\n+            test6(9, 10, 1, true);\n+            test6(9, 10, 1, false);\n+            test7(9, 10, 1, true);\n+            test7(9, 10, 1, false);\n+            test8(9, 10, 1, true);\n+            test8(9, 10, 1, false);\n+            test9(9, 10, 1, true);\n+            test9(9, 10, 1, false);\n+            test10(9, 10, 1, true);\n+            test10(9, 10, 1, false);\n+            test11(9, 10, 1, true);\n+            test11(9, 10, 1, false);\n+            test12(9, 10, 1, true);\n+            test12(9, 10, 1, false);\n+            test13(9, 10, 1, true);\n+            test13(9, 10, 1, false);\n+        }\n+        try {\n+            test1(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test3(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test4(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test5(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test6(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test7(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test8(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test9(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test10(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test11(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test12(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test13(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static void test1(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test2(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test3(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test4(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test5(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test6(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test7(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+    private static void test8(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test9(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test10(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test11(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test12(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test13(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void notInlined(int[] array) {\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestRangeCheckCastIISplitThruPhi\n+ * @run main TestRangeCheckCastIISplitThruPhi\n+ *\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestRangeCheckCastIISplitThruPhi {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        int[] baseline = null;\n+        for (int i = 0; i < 20_000; i++) {\n+            Arrays.fill(array, 0);\n+            test1(array);\n+            if (baseline == null) {\n+                baseline = array.clone();\n+            } else {\n+                boolean failures = false;\n+                for (int j = 0; j < array.length; j++) {\n+                    if (array[j] != baseline[j]) {\n+                        System.out.println(\"XXX @\" + j + \" \" + array[j] + \" != \" + baseline[j]);\n+                       failures = true;\n+                    }\n+                }\n+                if (failures) {\n+                    throw new RuntimeException();\n+                }\n+            }\n+            test2(array, true);\n+            test2(array, false);\n+        }\n+    }\n+\n+    private static void test1(int[] array) {\n+        int[] array2 = new int[100];\n+        int j = 4;\n+        int i = 3;\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int stride = k \/ 2;\n+        do {\n+            synchronized (new Object()) {\n+            }\n+            array2[j-1] = 42;\n+            array[j+1] = 42;\n+            j = i;\n+            i -= stride;\n+        } while (i >= 0);\n+    }\n+\n+    private static void test2(int[] array, boolean flag) {\n+        int[] array2 = new int[100];\n+        int j = 4;\n+        int i = 3;\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int stride = k \/ 2;\n+        if (flag) {\n+            volatileField = 42;\n+            array[0] = 42;\n+        } else {\n+            do {\n+                synchronized (new Object()) {\n+                }\n+                array2[j - 1] = 42;\n+                array[j + 1] = 42;\n+                j = i;\n+                i -= stride;\n+            } while (i >= 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckCastIISplitThruPhi.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n- * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @requires os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/sharedstubs\/SharedTrampolineTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+ * @requires os.arch != \"riscv64\" | vm.cpu.features ~= \".*rvv.*\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8332827\n+ * @summary [REDO] C2: crash in compiled code because of dependency on removed range check CastIIs\n+ * @requires os.arch != \"riscv64\" | vm.cpu.features ~= \".*rvv.*\"\n+ * @library \/test\/lib \/\n+ * @run driver TestVectorizationNegativeScale\n+ *\n+ *\/\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Arrays;\n+\n+public class TestVectorizationNegativeScale {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    static byte[] array = new byte[1000];\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR , \">= 1\"})\n+    private static void test1(byte[] array, int start) {\n+        for (int i = start; i < array.length; i++) {\n+            array[array.length - i - 1] = 0x42;\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private static void test1Runner() {\n+        Arrays.fill(array, (byte)0);\n+        test1(array, 0);\n+        for (int j = 0; j < array.length; j++) {\n+            if (array[j] != 0x42) {\n+                throw new RuntimeException(\"For index \" + j + \": \" + array[j]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorizationNegativeScale.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @test TestPLABAdaptToMinTLABSize\n+ * @test TestPLABAdaptToMinTLABSizeG1\n@@ -30,1 +30,1 @@\n- * @requires vm.gc.Parallel | vm.gc.G1\n+ * @requires vm.gc.G1\n@@ -34,1 +34,12 @@\n- * @run driver gc.TestPLABAdaptToMinTLABSize\n+ * @run driver gc.TestPLABAdaptToMinTLABSize -XX:+UseG1GC\n+ *\/\n+\n+\/*\n+ * @test TestPLABAdaptToMinTLABSizeParallel\n+ * @bug 8289137\n+ * @summary Make sure that Young\/OldPLABSize adapt to MinTLABSize setting.\n+ * @requires vm.gc.Parallel\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver gc.TestPLABAdaptToMinTLABSize -XX:+UseParallelGC\n@@ -38,0 +49,1 @@\n+import java.util.Arrays;\n@@ -71,1 +83,2 @@\n-        runTest(true, \"-XX:MinTLABSize=100k\");\n+        String gc = args[0];\n+        runTest(true, gc, \"-XX:MinTLABSize=100k\");\n@@ -73,2 +86,2 @@\n-        runTest(false, \"-XX:MinTLABSize=100k\", \"-XX:OldPLABSize=5k\");\n-        runTest(false, \"-XX:MinTLABSize=100k\", \"-XX:YoungPLABSize=5k\");\n+        runTest(false, gc, \"-XX:MinTLABSize=100k\", \"-XX:OldPLABSize=5k\");\n+        runTest(false, gc, \"-XX:MinTLABSize=100k\", \"-XX:YoungPLABSize=5k\");\n","filename":"test\/hotspot\/jtreg\/gc\/TestPLABAdaptToMinTLABSize.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- *      -XX:VerifyGCType=full -XX:+VerifyDuringGC -XX:+VerifyAfterGC -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *      -XX:VerifyGCType=full -XX:+VerifyDuringGC -XX:+VerifyAfterGC -XX:+WhiteBoxAPI -XX:+UseG1GC -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedHumongousFragmentation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. -XX:+ZapUnusedHeapArea -Xlog:gc,gc+ergo+cset=trace gc.g1.pinnedobjs.TestPinnedObjectContents\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC\n+ *      -Xbootclasspath\/a:. -XX:+ZapUnusedHeapArea -Xlog:gc,gc+ergo+cset=trace gc.g1.pinnedobjs.TestPinnedObjectContents\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedObjectContents.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,9 +88,2 @@\n-            if (CDS) {\n-                output.shouldNotContain(tryReserveForZeroBased);\n-                \/\/ bits 32..44\n-                output.shouldContain(\"reserve_between (range [0x0000000100000000-0x0000100000000000)\");\n-            } else {\n-                output.shouldContain(tryReserveForZeroBased);\n-                \/\/ bits 32..44, but not lower than zero-based limit\n-                output.shouldContain(\"reserve_between (range [0x0000000800000000-0x0000100000000000)\");\n-            }\n+            \/\/ bits 32..44\n+            output.shouldContain(\"reserve_between (range [0x0000000100000000-0x0000100000000000)\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8346457\n+ * @summary VM should not crash during AOT cache creation when encountering a\n+ *          class with VerifyError.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @compile test-classes\/BadLookupSwitch.jcod\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar badlookupswitch.jar BadLookupSwitch\n+ * @run driver CreateAOTCacheVerifyError\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class CreateAOTCacheVerifyError {\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"badlookupswitch.jar\");\n+        String classList[] = { BadLookupSwitch.class.getName() };\n+        OutputAnalyzer out = TestCommon.testDump(appJar, classList);\n+        out.shouldContain(\"Preload Warning: Verification failed for BadLookupSwitch\");\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CreateAOTCacheVerifyError.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+class BadLookupSwitch {\n+  0xCAFEBABE;\n+  0;\n+  50;\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    class #12; \/\/ #1 at 0x0A\n+    class #15; \/\/ #2 at 0x0D\n+    Method #2 #4; \/\/ #3 at 0x10\n+    NameAndType #6 #5; \/\/ #4 at 0x15\n+    Utf8 \"()V\"; \/\/ #5 at 0x1A\n+    Utf8 \"<init>\"; \/\/ #6 at 0x20\n+    Utf8 \"Code\"; \/\/ #7 at 0x29\n+    Utf8 \"ConstantValue\"; \/\/ #8 at 0x30\n+    Utf8 \"Exceptions\"; \/\/ #9 at 0x40\n+    Utf8 \"LineNumberTable\"; \/\/ #10 at 0x4D\n+    Utf8 \"LocalVariables\"; \/\/ #11 at 0x5F\n+    Utf8 \"BadLookupSwitch\"; \/\/ #12 at 0x70\n+    Utf8 \"SourceFile\"; \/\/ #13 at 0x76\n+    Utf8 \"f.java\"; \/\/ #14 at 0x83\n+    Utf8 \"java\/lang\/Object\"; \/\/ #15 at 0x8C\n+    Utf8 \"m\"; \/\/ #16 at 0x9F\n+    Utf8 \"StackMapTable\"; \/\/ #17    \n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #1;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [0] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [0] { \/\/ fields\n+  } \/\/ fields\n+\n+  [2] { \/\/ methods\n+    { \/\/ Member at 0xAF\n+      0x0001; \/\/ access\n+      #16; \/\/ name_cpx\n+      #5; \/\/ sig_cpx\n+      [] {  \/\/ Attributes\n+        Attr(#7) { \/\/ Code at 0xB7\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[29] {\n+            0x04AB00000000001B; \/\/ iconst_1;\n+\/* right:\n+            0x0000000200000001; \/\/ lookupswitch 27 2 1 27 2 27;\n+            0x0000001B00000002;\n+            0x0000001B;\n+end right *\/\n+\/\/ wrong:\n+            0x0000000200000002; \/\/ lookupswitch 27 2 2 27 1 27;\n+            0x0000001B00000001;\n+            0x0000001B;\n+\/\/ end wrong\n+            0xB1;               \/\/ return\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] {  \/\/ Attributes\n+            Attr(#17) { \/\/ StackMap\n+              [] { \/\/ \n+                255b,  28, []{O,1}, []{};\n+              }\n+            } \/\/ end StackMap\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+    ;\n+    { \/\/ Member at 0xD6\n+      0x0000; \/\/ access\n+      #6; \/\/ name_cpx\n+      #5; \/\/ sig_cpx\n+      [1] {  \/\/ Attributes\n+        Attr(#7) { \/\/ Code at 0xDE\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[5] {\n+            0x2AB70003B1;\n+          };\n+          [0] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] {  \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [] {  \/\/ Attributes\n+  } \/\/ Attributes\n+} \/\/ end class\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/BadLookupSwitch.jcod","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-    -maxdepth 1 -name '*.java'))\n+    -maxdepth 1 -name '*.java')\n@@ -56,0 +56,1 @@\n+\t--add-exports java.base\/jdk.internal.module=ALL-UNNAMED \\\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/Makefile","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Example test to show Verify.checkEQ with IR framework.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver verify.examples.TestVerifyInCheckMethod\n+ *\/\n+\n+package verify.examples;\n+\n+import compiler.lib.verify.*;\n+import compiler.lib.ir_framework.*;\n+\n+\/**\n+ * Example to show the use of Verify.checkEQ in @Check method.\n+ *\/\n+public class TestVerifyInCheckMethod {\n+    public static int[] INPUT_A = new int[100];\n+    static {\n+        for (int i = 0; i < INPUT_A.length; i++) {\n+            INPUT_A[i] = i;\n+        }\n+    }\n+    public static float INPUT_B = 42;\n+\n+    \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+    public static Object GOLD = test(INPUT_A.clone(), INPUT_B);;\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Setup\n+    public static Object[] setup() {\n+        \/\/ Must make sure to clone input arrays, if it is mutated in the test.\n+        return new Object[] {INPUT_A.clone(), INPUT_B};\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    public static Object test(int[] a, float b) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (int)(a[i] * b);\n+        }\n+        \/\/ Since we have more than one value, we wrap them in an Object[].\n+        return new Object[] {a, b};\n+    }\n+\n+    @Check(test = \"test\")\n+    public static void check(Object result) {\n+        Verify.checkEQ(result, GOLD);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/examples\/TestVerifyInCheckMethod.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,419 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test functionality of IntGenerator implementations.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver verify.tests.TestVerify\n+ *\/\n+\n+package verify.tests;\n+\n+import java.lang.foreign.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.verify.*;\n+\n+public class TestVerify {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        \/\/ Test consecutive memory: array, MemorySegment, etc.\n+        testArrayByte();\n+        testArrayChar();\n+        testArrayShort();\n+        testArrayInt();\n+        testArrayLong();\n+        testArrayFloat();\n+        testArrayDouble();\n+        testNativeMemorySegment();\n+\n+        \/\/ Test recursive data: Object array of values, etc.\n+        testRecursive();\n+    }\n+\n+    public static void testArrayByte() {\n+        byte[] a = new byte[1000];\n+        byte[] b = new byte[1001];\n+        byte[] c = new byte[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayShort() {\n+        short[] a = new short[1000];\n+        short[] b = new short[1001];\n+        short[] c = new short[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayChar() {\n+        char[] a = new char[1000];\n+        char[] b = new char[1001];\n+        char[] c = new char[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayInt() {\n+        int[] a = new int[1000];\n+        int[] b = new int[1001];\n+        int[] c = new int[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayLong() {\n+        long[] a = new long[1000];\n+        long[] b = new long[1001];\n+        long[] c = new long[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayFloat() {\n+        float[] a = new float[1000];\n+        float[] b = new float[1001];\n+        float[] c = new float[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+\n+    public static void testArrayDouble() {\n+        double[] a = new double[1000];\n+        double[] b = new double[1001];\n+        double[] c = new double[1000];\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(a));\n+        Verify.checkEQ(MemorySegment.ofArray(b), MemorySegment.ofArray(b));\n+        Verify.checkEQ(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+        Verify.checkEQ(MemorySegment.ofArray(c), MemorySegment.ofArray(a));\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        \/\/ Size mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(b));\n+\n+        c[RANDOM.nextInt(c.length)] = 1;\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+\n+        \/\/ Value mismatch\n+        checkNE(MemorySegment.ofArray(a), MemorySegment.ofArray(c));\n+    }\n+\n+    public static void testNativeMemorySegment() {\n+        MemorySegment a = Arena.ofAuto().allocate(1000, 1);\n+        MemorySegment b = Arena.ofAuto().allocate(1001, 1);\n+        MemorySegment c = Arena.ofAuto().allocate(1000, 1);\n+\n+        Verify.checkEQ(a, a);\n+        Verify.checkEQ(b, b);\n+        Verify.checkEQ(a, c);\n+        Verify.checkEQ(c, a);\n+\n+        \/\/ Size mismatch\n+        checkNE(a, b);\n+\n+        c.set(ValueLayout.JAVA_BYTE, RANDOM.nextLong(c.byteSize()), (byte)1);\n+\n+        \/\/ Value mismatch\n+        checkNE(a, c);\n+    }\n+\n+    public static void testRecursive() {\n+        Verify.checkEQ(null, null);\n+\n+        \/\/ Null mismatch\n+        checkNE(42, null);\n+\n+        byte[] a = new byte[1000];\n+        int[]  b = new int[1000];\n+        int[]  c = new int[1001];\n+        int[]  d = new int[1000];\n+\n+        Object[] o1 = new Object[]{a, a};\n+        Object[] o2 = new Object[]{a, a, a};\n+        Object[] o3 = new Object[]{a, a, null};\n+        Object[] o4 = new Object[]{a, a, b};\n+        Object[] o5 = new Object[]{a, a, c};\n+        Object[] o6 = new Object[]{a, a, d};\n+\n+        Verify.checkEQ(o1, o1);\n+        Verify.checkEQ(o2, o2);\n+        Verify.checkEQ(o3, o3);\n+        Verify.checkEQ(o4, o6);\n+\n+        \/\/ Size mismatch\n+        checkNE(o1, o2);\n+\n+        \/\/ First level value mismatch: a vs null on position 2\n+        checkNE(o2, o3);\n+\n+        \/\/ First level class mismatch: byte[] vs int[]\n+        checkNE(o2, o4);\n+\n+        \/\/ Second level length mismatch on arrays b and c.\n+        checkNE(o4, o5);\n+\n+        d[RANDOM.nextInt(d.length)] = 1;\n+\n+        \/\/ Second level value mismatch between b and d.\n+        checkNE(o4, o6);\n+\n+        \/\/ Now test all primitive array types.\n+        byte[]   aB = new byte[100];\n+        char[]   aC = new char[100];\n+        short[]  aS = new short[100];\n+        int[]    aI = new int[100];\n+        long[]   aL = new long[100];\n+        float[]  aF = new float[100];\n+        double[] aD = new double[100];\n+\n+        Verify.checkEQ(new Object[] {aB, aC, aS, aI, aL, aF, aD}, new Object[] {aB, aC, aS, aI, aL, aF, aD});\n+\n+        \/\/ First level class mismatch: char[] vs short[]\n+        checkNE(new Object[] {aC}, new Object[] {aS});\n+\n+        \/\/ Verify MemorySegment\n+        MemorySegment mC = MemorySegment.ofArray(aC);\n+        MemorySegment mS = MemorySegment.ofArray(aS);\n+        Verify.checkEQ(new Object[] {mC}, new Object[] {mC});\n+        Verify.checkEQ(new Object[] {mS}, new Object[] {mS});\n+\n+        \/\/ Second level type mismatch: backing type short[] vs char[]\n+        checkNE(new Object[] {mC}, new Object[] {mS});\n+\n+        \/\/ Second level type mismatch: backing type int[] vs char[]\n+        MemorySegment mI = MemorySegment.ofArray(aI);\n+        checkNE(new Object[] {mI}, new Object[] {mC});\n+\n+        \/\/ Verify boxed primitives:\n+        Byte bb1 = 42;\n+        Byte bb2 = 42;\n+        Byte bb3 = 11;\n+\n+        Verify.checkEQ(new Object[] {(byte)42}, new Object[] {(byte)42});\n+        Verify.checkEQ(new Object[] {(byte)42}, new Object[] {bb1});\n+        Verify.checkEQ(new Object[] {bb1},      new Object[] {bb2});\n+\n+        \/\/ Second level value mismatch: 42 vs 11\n+        checkNE(new Object[] {bb1},      new Object[] {bb3});\n+\n+        Verify.checkEQ((byte)42,   (byte)42);\n+        Verify.checkEQ((short)42,  (short)42);\n+        Verify.checkEQ((char)42,   (char)42);\n+        Verify.checkEQ((int)42,    (int)42);\n+        Verify.checkEQ((long)42,   (long)42);\n+        Verify.checkEQ((float)42,  (float)42);\n+        Verify.checkEQ((double)42, (double)42);\n+\n+        \/\/ Boxed type mismatch: float vs int\n+        checkNE((int)42, (float)42);\n+\n+        \/\/ Boxed value mismatch.\n+        for (int i = 0; i < 10; i++) {\n+            byte v1 = (byte)RANDOM.nextInt();\n+            byte v2 = (byte)(v1 ^ (1 << RANDOM.nextInt(8)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            char v1 = (char)RANDOM.nextInt();\n+            char v2 = (char)(v1 ^ (1 << RANDOM.nextInt(16)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            char v1 = (char)RANDOM.nextInt();\n+            char v2 = (char)(v1 ^ (1 << RANDOM.nextInt(16)));\n+            checkNE(v1, v2);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            int v1 = (int)RANDOM.nextInt();\n+            int v2 = (int)(v1 ^ (1 << RANDOM.nextInt(32)));\n+            checkNE(v1, v2);\n+            checkNE(Float.intBitsToFloat(v1), Float.intBitsToFloat(v2));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            long v1 = (long)RANDOM.nextLong();\n+            long v2 = (long)(v1 ^ (1L << RANDOM.nextInt(64)));\n+            checkNE(v1, v2);\n+            checkNE(Double.longBitsToDouble(v1), Double.longBitsToDouble(v2));\n+        }\n+    }\n+\n+    public static void checkNE(Object a, Object b) {\n+         try {\n+            Verify.checkEQ(a, b);\n+            throw new RuntimeException(\"Should have thrown\");\n+        } catch (VerifyException e) {}\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/verify\/tests\/TestVerify.java","additions":419,"deletions":0,"binary":false,"changes":419,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,1 @@\n- *      -Xms64m\n- *      -Xmx64m\n- *      -XX:MaxMetaspaceSize=9m\n- *      -XX:-UseGCOverheadLimit\n+ *      -XX:MaxMetaspaceSize=20m\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted003\/TestDescription.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-java\/util\/concurrent\/locks\/StampedLock\/OOMEInStampedLock.java 8345266 generic-all\n-\n","filename":"test\/jdk\/ProblemList-Virtual.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -589,2 +589,0 @@\n-java\/nio\/channels\/AsynchronousSocketChannel\/StressLoopback.java 8211851 aix-ppc64\n-\n@@ -733,0 +731,2 @@\n+com\/sun\/jdi\/ProcessAttachTest.java         8346827 linux-all\n+com\/sun\/jdi\/ReattachStressTest.java        8346827 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        Asserts.assertEqualsByteArray(prk.getEncoded(), expectedPrk,\n+        Asserts.assertEqualsByteArray(expectedPrk, prk.getEncoded(),\n@@ -58,1 +58,1 @@\n-        Asserts.assertEqualsByteArray(okm1.getEncoded(), expectedOkm,\n+        Asserts.assertEqualsByteArray(expectedOkm, okm1.getEncoded(),\n@@ -62,1 +62,1 @@\n-        Asserts.assertEqualsByteArray(okm2.getEncoded(), expectedOkm,\n+        Asserts.assertEqualsByteArray(expectedOkm, okm2.getEncoded(),\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KDF\/HKDFBasicFunctionsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n@@ -35,4 +34,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n@@ -48,0 +43,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n@@ -68,1 +66,1 @@\n-    private static class TestClassLoader extends ClassLoader implements Opcodes {\n+    private static class TestClassLoader extends ClassLoader {\n@@ -70,10 +68,5 @@\n-            ClassWriter cw = new ClassWriter(0);\n-\n-            cw.visit(52, ACC_SUPER | ACC_PUBLIC, name, null, \"java\/lang\/Object\", null);\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            return ClassFile.of().build(ClassDesc.of(name), clb ->\n+                clb.withVersion(52, 0)\n+                   .withFlags(ClassFile.ACC_SUPER | ClassFile.ACC_PUBLIC)\n+                   .withMethodBody(\"m\", ConstantDescs.MTD_void, ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob ->\n+                           cob.return_()));\n","filename":"test\/jdk\/com\/sun\/jdi\/ClassUnloadEventTest.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 6968351\n- * @summary  tcp no delay not required for small payloads\n- * @requires vm.compMode != \"Xcomp\"\n- * @library \/test\/lib\n- * @run main\/othervm\/timeout=5 -Dsun.net.httpserver.nodelay=false  TcpNoDelayNotRequired\n- *\/\n-\n-import com.sun.net.httpserver.Headers;\n-import com.sun.net.httpserver.HttpContext;\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpServer;\n-\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n-import jdk.test.lib.net.SimpleSSLContext;\n-import jdk.test.lib.net.URIBuilder;\n-\n-import javax.net.ssl.SSLContext;\n-import java.io.IOException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.nio.charset.StandardCharsets;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import java.util.logging.SimpleFormatter;\n-import java.util.logging.StreamHandler;\n-\n-public class TcpNoDelayNotRequired {\n-\n-    public static final Logger LOGGER = Logger.getLogger(\"sun.net.www.protocol.http\");\n-\n-    public static void main (String[] args) throws Exception {\n-\n-        java.util.logging.Handler outHandler = new StreamHandler(System.out,\n-                new SimpleFormatter());\n-        outHandler.setLevel(Level.FINEST);\n-        LOGGER.setLevel(Level.FINEST);\n-        LOGGER.addHandler(outHandler);\n-\n-        InetAddress loopback = InetAddress.getLoopbackAddress();\n-        InetSocketAddress addr = new InetSocketAddress (loopback, 0);\n-\n-        SSLContext sslContext = new SimpleSSLContext().get();\n-\n-        HttpServer httpServer = HttpServer.create (addr, 0);\n-        testHttpServer(\"http\",httpServer,sslContext);\n-\n-        HttpsServer httpsServer = HttpsServer.create (addr, 0);\n-        httpsServer.setHttpsConfigurator(new HttpsConfigurator(sslContext));\n-\n-        testHttpServer(\"https\",httpsServer,sslContext);\n-    }\n-\n-    private static void testHttpServer(String scheme,HttpServer server,SSLContext sslContext) throws Exception {\n-        HttpContext ctx = server.createContext (\"\/test\", new Handler());\n-        HttpContext ctx2 = server.createContext (\"\/chunked\", new ChunkedHandler());\n-        ExecutorService executor = Executors.newCachedThreadPool();\n-        server.setExecutor (executor);\n-        server.start ();\n-        try {\n-            try (HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build()) {\n-                long start = System.currentTimeMillis();\n-                for (int i = 0; i < 1000; i++) {\n-                    var uri = URIBuilder.newBuilder().scheme(scheme).loopback().port(server.getAddress().getPort()).path(\"\/test\").build();\n-                    var response = client.send(HttpRequest.newBuilder(uri).build(), HttpResponse.BodyHandlers.ofString());\n-                    if (!response.body().equals(\"hello\"))\n-                        throw new IllegalStateException(\"incorrect body \" + response.body());\n-                }\n-                for (int i = 0; i < 1000; i++) {\n-                    var uri = URIBuilder.newBuilder().scheme(scheme).loopback().port(server.getAddress().getPort()).path(\"\/chunked\").build();\n-                    var response = client.send(HttpRequest.newBuilder(uri).build(), HttpResponse.BodyHandlers.ofString());\n-                    if (!response.body().equals(\"hello\"))\n-                        throw new IllegalStateException(\"incorrect body \" + response.body());\n-                }\n-                long time = System.currentTimeMillis() - start;\n-                System.out.println(\"time \" + time);\n-            }\n-        } finally {\n-            server.stop(0);\n-        }\n-        executor.shutdown();\n-    }\n-\n-    static class Handler implements HttpHandler {\n-        public void handle (HttpExchange t)\n-                throws IOException\n-        {\n-            Headers rmap = t.getResponseHeaders();\n-            try (var is = t.getRequestBody()) {\n-                is.readAllBytes();\n-            }\n-            rmap.add(\"content-type\",\"text\/plain\");\n-            t.sendResponseHeaders(200,5);\n-            try (var os = t.getResponseBody()) {\n-                os.write(\"hello\".getBytes(StandardCharsets.ISO_8859_1));\n-            }\n-        }\n-    }\n-    static class ChunkedHandler implements HttpHandler {\n-        public void handle (HttpExchange t)\n-                throws IOException\n-        {\n-            Headers rmap = t.getResponseHeaders();\n-            try (var is = t.getRequestBody()) {\n-                is.readAllBytes();\n-            }\n-            rmap.add(\"content-type\",\"text\/plain\");\n-            t.sendResponseHeaders(200,0);\n-            try (var os = t.getResponseBody()) {\n-                os.write(\"hello\".getBytes(StandardCharsets.ISO_8859_1));\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/TcpNoDelayNotRequired.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    final static ByteBuffer requestBuf = ByteBuffer.allocate(64).put(request.getBytes());\n+    final static ByteBuffer requestBuf = ByteBuffer.wrap(request.getBytes());\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/bugs\/B6361557.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6360339\n+ * @bug 6360339 8343224\n@@ -32,4 +32,10 @@\n-import java.awt.print.*;\n-import javax.print.*;\n-import javax.print.attribute.*;\n-import javax.print.attribute.standard.*;\n+import javax.print.PrintService;\n+import javax.print.attribute.HashPrintRequestAttributeSet;\n+import javax.print.attribute.PrintRequestAttributeSet;\n+import javax.print.attribute.Size2DSyntax;\n+import javax.print.attribute.standard.MediaSize;\n+import javax.print.attribute.standard.MediaSizeName;\n+import javax.print.attribute.standard.OrientationRequested;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Paper;\n+import java.awt.print.PrinterJob;\n","filename":"test\/jdk\/java\/awt\/print\/Dialog\/PaperSizeError.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -263,0 +263,1 @@\n+            assertTrue(segment.toString().contains(\"mapped\"));\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -237,0 +237,1 @@\n+            assertFalse(s.contains(\"native\"));\n@@ -239,0 +240,1 @@\n+            assertTrue(s.contains(\"native\"));\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    private static final Pattern DF_PATTERN = Pattern.compile(\"([^\\\\s]+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+(\\\\d+)\\\\s+\\\\d+%\\\\s+([^\\\\s].*)\\n\");\n+\n@@ -107,2 +109,11 @@\n-            if (getSpace0(name, sizes))\n-                System.err.println(\"WARNING: total space is estimated\");\n+            if (Platform.isWindows() & isCDDrive(name)) {\n+                try {\n+                    getCDDriveSpace(name, sizes);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    throw new RuntimeException(\"can't get CDDrive sizes\");\n+                }\n+            } else {\n+                if (getSpace0(name, sizes))\n+                    System.err.println(\"WARNING: total space is estimated\");\n+            }\n@@ -170,1 +181,2 @@\n-        out.format(fmt, \"getSpace0\", s.total(), s.free(), s.available());\n+        String method = Platform.isWindows() & isCDDrive(s.name()) ? \"getCDDriveSpace\" : \"getSpace0\";\n+        out.format(fmt, method, s.total(), s.free(), s.available());\n@@ -327,1 +339,1 @@\n-        \/\/ returned by File::getXSpace are equivalent to those from getSpace0\n+        \/\/ returned by File::getXSpace are equivalent to those from getSpace0 or getCDDriveSpace\n@@ -400,0 +412,36 @@\n+\n+    private static native boolean isCDDrive(String root);\n+\n+    private static void getCDDriveSpace(String root, long[] sizes)\n+        throws IOException {\n+        String[] cmd = new String[] {\"df\", \"-k\", \"-P\", root};\n+        Process p = Runtime.getRuntime().exec(cmd);\n+        StringBuilder sb = new StringBuilder();\n+\n+        try (BufferedReader in = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+            String s;\n+            int i = 0;\n+            while ((s = in.readLine()) != null) {\n+                \/\/ skip header\n+                if (i++ == 0) continue;\n+                sb.append(s).append(\"\\n\");\n+            }\n+        }\n+        out.println(sb);\n+\n+        Matcher m = DF_PATTERN.matcher(sb);\n+        int j = 0;\n+        while (j < sb.length()) {\n+            if (m.find(j)) {\n+                sizes[0] = Long.parseLong(m.group(2)) * 1024;\n+                sizes[1] = Long.parseLong(m.group(3)) * 1024;\n+                sizes[2] = sizes[0] - sizes[1];\n+                sizes[3] = Long.parseLong(m.group(4)) * 1024;\n+                j = m.end();\n+            } else {\n+                throw new RuntimeException(\"unrecognized df output format: \"\n+                                           + \"charAt(\" + j + \") = '\"\n+                                           + sb.charAt(j) + \"'\");\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/io\/File\/GetXSpace.java","additions":52,"deletions":4,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -162,0 +162,27 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_GetXSpace_isCDDrive\n+    (JNIEnv *env, jclass cls, jstring root)\n+{\n+#ifdef WINDOWS\n+    const jchar* strchars = (*env)->GetStringChars(env, root, NULL);\n+    if (strchars == NULL) {\n+        JNU_ThrowByNameWithLastError(env, \"java\/lang\/RuntimeException\",\n+                                     \"GetStringChars\");\n+        return JNI_FALSE;\n+    }\n+\n+    LPCWSTR path = (LPCWSTR)strchars;\n+    UINT driveType = GetDriveTypeW(path);\n+\n+    (*env)->ReleaseStringChars(env, root, strchars);\n+\n+    if (driveType != DRIVE_CDROM) {\n+        return JNI_FALSE;\n+    }\n+\n+    return JNI_TRUE;\n+#else\n+    return JNI_FALSE;\n+#endif\n+}\n","filename":"test\/jdk\/java\/io\/File\/libGetXSpace.c","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=monitorenter\n+ * @bug 8345266\n+ * @summary Test OOM while trying to unmount vthread on monitorenter\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME false\n+ *\/\n+\n+\/*\n+ * @test id=timedwait\n+ * @summary Test OOM while trying to unmount vthread on Object.wait\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME true 5\n+ *\/\n+\n+\/*\n+ * @test id=untimedwait\n+ * @summary Test OOM while trying to unmount vthread on Object.wait\n+ * @requires vm.continuations & vm.gc.G1 & vm.opt.DisableExplicitGC != \"true\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UseG1GC -Xmx48M MonitorEnterWaitOOME true 0\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class MonitorEnterWaitOOME {\n+    static volatile Object data;\n+    static Thread.State dummyState = Thread.State.RUNNABLE; \/\/ load java.lang.Thread$State\n+\n+    public static void main(String[] args) throws Throwable {\n+        final boolean testWait = args.length >= 1 ? Boolean.parseBoolean(args[0]) : false;\n+        final long timeout = testWait && args.length == 2 ? Long.parseLong(args[1]) : 0L;\n+\n+        VThreadRunner.ensureParallelism(2);\n+\n+        Thread vthread;\n+        var lock = new Object();\n+        var canFillHeap = new AtomicBoolean();\n+        var heapFilled = new AtomicBoolean();\n+        var heapCollected = new AtomicBoolean();\n+        var exRef = new AtomicReference<Throwable>();\n+        synchronized (lock) {\n+            vthread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    awaitTrue(canFillHeap);\n+                    data = fillHeap();\n+                    heapFilled.set(true);\n+                    synchronized (lock) {\n+                        if (testWait) {\n+                            lock.wait(timeout);\n+                        }\n+                    }\n+                    data = null;\n+                    System.gc();\n+                    heapCollected.set(true);\n+                } catch (Throwable e) {\n+                    data = null;\n+                    System.gc(); \/\/ avoid nested OOME\n+                    exRef.set(e);\n+                }\n+            });\n+            canFillHeap.set(true);\n+            awaitTrue(heapFilled);\n+            awaitState(vthread, Thread.State.BLOCKED);\n+        }\n+        if (testWait && timeout == 0) {\n+            awaitState(vthread, Thread.State.WAITING);\n+            synchronized (lock) {\n+                lock.notify();\n+            }\n+        }\n+        joinVThread(vthread, heapCollected, exRef);\n+        assert exRef.get() == null;\n+    }\n+\n+    private static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+\n+    private static void awaitTrue(AtomicBoolean ready) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        while (!ready.get()) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    private static void awaitState(Thread thread, Thread.State expectedState) {\n+        \/\/ Don't call anything that might allocate from the Java heap.\n+        while (thread.getState() != expectedState) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    private static void joinVThread(Thread vthread, AtomicBoolean ready, AtomicReference<Throwable> exRef) throws Throwable {\n+        \/\/ Don't call anything that might allocate from the Java heap until ready is set.\n+        while (!ready.get()) {\n+            Throwable ex = exRef.get();\n+            if (ex != null) {\n+                throw ex;\n+            }\n+            Thread.onSpinWait();\n+        }\n+        vthread.join();\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterWaitOOME.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -86,1 +87,1 @@\n-                    Path.of(System.getProperty(\"user.home\"), \".mime.types\");\n+                    Path.of(StaticProperty.userHome(), \".mime.types\");\n@@ -191,1 +192,2 @@\n-        \/\/ extensions with content type that differs on Windows 11+\n+        \/\/ extensions with content type that differs on Windows 11+ and\n+        \/\/ Windows Server 2025\n@@ -193,1 +195,1 @@\n-            (System.getProperty(\"os.name\").endsWith(\"11\") ||\n+            (StaticProperty.osName().matches(\"^.*[11|2025]$\") ||\n","filename":"test\/jdk\/java\/nio\/file\/Files\/probeContentType\/Basic.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+\n+\/**\n+ * Use by tests in SetDefaultProvider to test startup with a custom default file system\n+ * provider and a custom system class loader.\n+ *\/\n+\n+public class CustomSystemClassLoader extends ClassLoader {\n+    public CustomSystemClassLoader(ClassLoader parent) {\n+        super(parent);\n+\n+        \/\/ use default file system\n+        FileSystem fs = FileSystems.getDefault();\n+        var path = fs.getPath(\"foo\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/nio\/file\/spi\/CustomSystemClassLoader.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4313887 7006126 8142968 8178380 8183320 8210112 8266345 8263940\n+ * @bug 4313887 7006126 8142968 8178380 8183320 8210112 8266345 8263940 8331467 8346573\n@@ -29,1 +29,1 @@\n- * @build testfsp\/* testapp\/*\n+ * @build testfsp\/* testapp\/* CustomSystemClassLoader\n@@ -48,1 +48,0 @@\n-import org.junit.jupiter.api.Disabled;\n@@ -127,1 +126,0 @@\n-    @Disabled\n@@ -209,0 +207,13 @@\n+    \/**\n+     * Test file system provider on class path in conjunction with a custom system\n+     * class loader that uses the file system API during its initialization.\n+     *\/\n+    @Test\n+    void testCustomSystemClassLoader() throws Exception {\n+        String testClasses = System.getProperty(\"test.classes\");\n+        exec(SET_DEFAULT_FSP,\n+                \"-Djava.system.class.loader=CustomSystemClassLoader\",\n+                \"-cp\", ofClasspath(testClasses, TESTFSP_CLASSES, TESTAPP_CLASSES),\n+                TESTAPP_MAIN);\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/file\/spi\/SetDefaultProvider.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n-\tsolar87 solar88 solar89 southamerica \\\n-\tbackward\n+\tsouthamerica backward\n","filename":"test\/jdk\/java\/util\/TimeZone\/tools\/share\/Makefile","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +51,3 @@\n+\n+    private static final String MAIN_CLASS_MSG = \"foo bar hello world Main\";\n+\n@@ -52,1 +56,1 @@\n-            System.out.print(\"Main\");\n+            System.out.println(MAIN_CLASS_MSG);\n@@ -165,1 +169,4 @@\n-        a.stdoutShouldMatch(\"\\\\AMain\\\\Z\");\n+        \/\/ expect the message from the application on stdout\n+        a.stdoutContains(MAIN_CLASS_MSG);\n+        \/\/ nothing is expected on stderr (apart from any probable deprecation\n+        \/\/ warnings from the launcher\/JVM)\n","filename":"test\/jdk\/java\/util\/zip\/EntryCount64k.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+        int drained = 1;\n+        while (drained < appData.length) {\n+            drained += sslIS.read(appData, drained, appData.length - drained);\n+        }\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSocket\/Tls13PacketSize.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.print.attribute.standard.PageRanges;\n+\n+\/*\n+ * @test\n+ * @bug 4433126 4433096\n+ * @key printer\n+ * @summary  The line \"ERROR: <message>\" should NOT appear.\n+ * @run main PageRangesException\n+ *\/\n+\n+public class PageRangesException {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ test 4433126\n+        try {\n+            PageRanges pr = new PageRanges(\"0:22\");\n+            throw new RuntimeException(\"ERROR: no exceptions\");\n+        } catch (IllegalArgumentException ie) {\n+            System.out.println(\"OKAY: IllegalArgumentException \" + ie);\n+        }\n+\n+        \/\/ test 4433096\n+        try {\n+            int[][] m = null;\n+            PageRanges pr = new PageRanges(m);\n+            throw new RuntimeException(\"ERROR: NullPointerException expected\");\n+        } catch (IllegalArgumentException ie) {\n+            throw new RuntimeException(\"ERROR: IllegalArgumentException\", ie);\n+        } catch (NullPointerException e) {\n+            System.out.println(\"OKAY: NullPointerException\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/print\/attribute\/PageRangesException.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4174551\n+ * @bug 4174551 8346260\n","filename":"test\/jdk\/javax\/swing\/JOptionPane\/bug4174551.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,3 @@\n-        \"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java\"})\n+        \"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/snippet-files\/PackageSnippets.java\",\n+        \"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java\"\n+    })\n","filename":"test\/jdk\/jdk\/classfile\/SnippetsTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,3 +5,1 @@\n-    java.base\/jdk.internal.classfile.impl.verifier \\\n-    java.base\/jdk.internal.org.objectweb.asm \\\n-    java.base\/jdk.internal.org.objectweb.asm.tree\n\\ No newline at end of file\n+    java.base\/jdk.internal.classfile.impl.verifier\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/classfile\/TEST.properties","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,13 +46,0 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n-import jdk.internal.org.objectweb.asm.TypePath;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n@@ -65,2 +52,0 @@\n-    static int ASM9 = 9 << 16 | 0 << 8;\n-\n@@ -131,32 +116,0 @@\n-        ASM_1(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_UNSHARED_1(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_3(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new CustomClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_UNSHARED_3(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new CustomClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_TREE(bytes -> {\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            node.accept(cw);\n-            return cw.toByteArray();\n-        }),\n@@ -166,1 +119,1 @@\n-        \/\/ Need ASM, LOW_UNSHARED\n+        \/\/ Need LOW_UNSHARED\n@@ -205,6 +158,0 @@\n-        ASM_NOP_SHARED(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new NopClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n@@ -245,7 +192,0 @@\n-        ASM_ADD_FIELD(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            cw.visitField(0, \"argleBargleWoogaWooga\", \"I\", null, null);\n-            return cw.toByteArray();\n-        }),\n@@ -276,14 +216,0 @@\n-        ASM_DEL_METHOD(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            ClassVisitor v = new ClassVisitor(ASM9, cw) {\n-                @Override\n-                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-                    return (name.equals(\"hashCode\") && descriptor.equals(\"()Z\"))\n-                           ? null\n-                           : super.visitMethod(access, name, descriptor, signature, exceptions);\n-                }\n-            };\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n@@ -322,273 +248,0 @@\n-    static class CustomClassVisitor extends ClassVisitor {\n-\n-        public CustomClassVisitor(ClassVisitor writer) {\n-            super(ASM9, writer);\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            super.visit(version, access, name, signature, superName, interfaces);\n-        }\n-\n-        @Override\n-        public void visitSource(String source, String debug) {\n-            super.visitSource(source, debug);\n-        }\n-\n-        @Override\n-        public ModuleVisitor visitModule(String name, int access, String version) {\n-            return super.visitModule(name, access, version);\n-        }\n-\n-        @Override\n-        public void visitNestHost(String nestHost) {\n-            super.visitNestHost(nestHost);\n-        }\n-\n-        @Override\n-        public void visitOuterClass(String owner, String name, String descriptor) {\n-            super.visitOuterClass(owner, name, descriptor);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAttribute(Attribute attribute) {\n-            super.visitAttribute(attribute);\n-        }\n-\n-        @Override\n-        public void visitNestMember(String nestMember) {\n-            super.visitNestMember(nestMember);\n-        }\n-\n-        @Override\n-        public void visitInnerClass(String name, String outerName, String innerName, int access) {\n-            super.visitInnerClass(name, outerName, innerName, access);\n-        }\n-\n-        @Override\n-        public RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {\n-            return super.visitRecordComponent(name, descriptor, signature);\n-        }\n-\n-        @Override\n-        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-            return super.visitField(access, name, descriptor, signature, value);\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n-            return new CustomMethodVisitor(mv);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            super.visitEnd();\n-        }\n-    };\n-\n-\n-    static class CustomMethodVisitor extends MethodVisitor {\n-\n-        public CustomMethodVisitor(MethodVisitor methodVisitor) {\n-            super(ASM9, methodVisitor);\n-        }\n-\n-        @Override\n-        public void visitParameter(String name, int access) {\n-            super.visitParameter(name, access);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotationDefault() {\n-            return super.visitAnnotationDefault();\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAnnotableParameterCount(int parameterCount, boolean visible) {\n-            super.visitAnnotableParameterCount(parameterCount, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {\n-            return super.visitParameterAnnotation(parameter, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAttribute(Attribute attribute) {\n-            super.visitAttribute(attribute);\n-        }\n-\n-        @Override\n-        public void visitCode() {\n-            super.visitCode();\n-        }\n-\n-        @Override\n-        public void visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack) {\n-            super.visitFrame(type, numLocal, local, numStack, stack);\n-        }\n-\n-        @Override\n-        public void visitInsn(int opcode) {\n-            super.visitInsn(opcode);\n-        }\n-\n-        @Override\n-        public void visitIntInsn(int opcode, int operand) {\n-            super.visitIntInsn(opcode, operand);\n-        }\n-\n-        @Override\n-        public void visitVarInsn(int opcode, int var) {\n-            super.visitVarInsn(opcode, var);\n-        }\n-\n-        @Override\n-        public void visitTypeInsn(int opcode, String type) {\n-            super.visitTypeInsn(opcode, type);\n-        }\n-\n-        @Override\n-        public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {\n-            super.visitFieldInsn(opcode, owner, name, descriptor);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"deprecation\")\n-        public void visitMethodInsn(int opcode, String owner, String name, String descriptor) {\n-            super.visitMethodInsn(opcode, owner, name, descriptor);\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n-            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n-        }\n-\n-        @Override\n-        public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {\n-            super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n-        }\n-\n-        @Override\n-        public void visitJumpInsn(int opcode, Label label) {\n-            super.visitJumpInsn(opcode, label);\n-        }\n-\n-        @Override\n-        public void visitLabel(Label label) {\n-            super.visitLabel(label);\n-        }\n-\n-        @Override\n-        public void visitLdcInsn(Object value) {\n-            super.visitLdcInsn(value);\n-        }\n-\n-        @Override\n-        public void visitIincInsn(int var, int increment) {\n-            super.visitIincInsn(var, increment);\n-        }\n-\n-        @Override\n-        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {\n-            super.visitTableSwitchInsn(min, max, dflt, labels);\n-        }\n-\n-        @Override\n-        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n-            super.visitLookupSwitchInsn(dflt, keys, labels);\n-        }\n-\n-        @Override\n-        public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {\n-            super.visitMultiANewArrayInsn(descriptor, numDimensions);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n-            super.visitTryCatchBlock(start, end, handler, type);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {\n-            super.visitLocalVariable(name, descriptor, signature, start, end, index);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String descriptor, boolean visible) {\n-            return super.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitLineNumber(int line, Label start) {\n-            super.visitLineNumber(line, start);\n-        }\n-\n-        @Override\n-        public void visitMaxs(int maxStack, int maxLocals) {\n-            super.visitMaxs(maxStack, maxLocals);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            super.visitEnd();\n-        }\n-    };\n-\n-    static class NopClassVisitor extends CustomClassVisitor {\n-\n-        public NopClassVisitor(ClassVisitor writer) {\n-            super(writer);\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n-            return new NopMethodVisitor(mv);\n-        }\n-    }\n-\n-    static class NopMethodVisitor extends CustomMethodVisitor {\n-\n-        public NopMethodVisitor(MethodVisitor methodVisitor) {\n-            super(methodVisitor);\n-        }\n-\n-        @Override\n-        public void visitCode() {\n-            super.visitCode();\n-            visitInsn(Opcodes.NOP);\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/Transforms.java","additions":2,"deletions":349,"binary":false,"changes":351,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,2 @@\n-               \"java.base\/jdk.internal.javac\");\n+               \"java.base\/jdk.internal.javac\",\n+               \"java.base\/jdk.internal.misc\");\n","filename":"test\/jdk\/jdk\/modules\/etc\/JdkQualifiedExportTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-        Asserts.assertEqualsByteArray(secret, expectedSecret, \"Incorrect secret value\");\n+        Asserts.assertEqualsByteArray(expectedSecret, secret, \"Incorrect secret value\");\n@@ -144,1 +144,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/sun\/security\/ec\/ECDHPrimitive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-                Asserts.assertEqualsByteArray(pk, toByteArray(c.get(\"pk\").asString()));\n-                Asserts.assertEqualsByteArray(sk, toByteArray(c.get(\"sk\").asString()));\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"pk\").asString()), pk);\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()), sk);\n@@ -107,1 +107,1 @@\n-                        sig, toByteArray(c.get(\"signature\").asString()));\n+                        toByteArray(c.get(\"signature\").asString()), sig);\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-                Asserts.assertEqualsByteArray(pk, toByteArray(c.get(\"ek\").asString()));\n-                Asserts.assertEqualsByteArray(sk, toByteArray(c.get(\"dk\").asString()));\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"ek\").asString()), pk);\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"dk\").asString()), sk);\n@@ -100,1 +100,1 @@\n-                            enc.encapsulation(), toByteArray(c.get(\"c\").asString()));\n+                            toByteArray(c.get(\"c\").asString()), enc.encapsulation());\n@@ -102,1 +102,1 @@\n-                            enc.key().getEncoded(), toByteArray(c.get(\"k\").asString()));\n+                            toByteArray(c.get(\"k\").asString()), enc.key().getEncoded());\n@@ -115,1 +115,1 @@\n-                    Asserts.assertEqualsByteArray(k.getEncoded(), toByteArray(c.get(\"k\").asString()));\n+                    Asserts.assertEqualsByteArray(toByteArray(c.get(\"k\").asString()), k.getEncoded());\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_KEM_Test.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-                            Asserts.assertEqualsByteArray(md.digest(msg),\n-                                    toByteArray(c.get(\"md\").asString()));\n+                            Asserts.assertEqualsByteArray(\n+                                    toByteArray(c.get(\"md\").asString()), md.digest(msg));\n@@ -73,2 +73,2 @@\n-                                    Asserts.assertEqualsByteArray(MD,\n-                                            toByteArray(r.get(\"md\").asString()));\n+                                    Asserts.assertEqualsByteArray(\n+                                            toByteArray(r.get(\"md\").asString()), MD);\n@@ -91,2 +91,2 @@\n-                                    Asserts.assertEqualsByteArray(MD,\n-                                            toByteArray(r.get(\"md\").asString()));\n+                                    Asserts.assertEqualsByteArray(\n+                                            toByteArray(r.get(\"md\").asString()), MD);\n@@ -113,2 +113,2 @@\n-                        Asserts.assertEqualsByteArray(md.digest(),\n-                                toByteArray(c.get(\"md\").asString()));\n+                        Asserts.assertEqualsByteArray(\n+                                toByteArray(c.get(\"md\").asString()), md.digest());\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/SHA_Test.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * <code>BackEnd<\/code> is an abstract base class for a back-end of compiling\n- * Olson's zoneinfo database and generating Java zoneinfo database.\n- *\n- * @since 1.4\n- *\/\n-abstract class BackEnd {\n-\n-    \/**\n-     * Receives each zone's TimeZone information which was created by\n-     * {@link Zoneinfo#parse} in class <code>Zoneinfo<\/code>,\n-     * and processes it.\n-     *\n-     * @param tz Timezone object for each zone\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    abstract int processZoneinfo(Timezone tz);\n-\n-    \/**\n-     * Receives whole information which is generated by JavaZic's front-end\n-     * in the form of Mapping object and generates all Java zone information\n-     * files.\n-     *\n-     * @param m Mappings object which is generated by\n-     *          {@link Main#compile() Main.compile()}.\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    abstract int generateSrc(Mappings m);\n-\n-    \/**\n-     * Decides which backend class should be used and returns its instance.\n-     * @return an instance of backend class\n-     *\/\n-    static BackEnd getBackEnd() {\n-        if (Zoneinfo.isYearForTimeZoneDataSpecified) {\n-            return new Simple();\n-        } else if (Main.outputDoc) {\n-            return new GenDoc();\n-        } else {\n-            return new Gen();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/BackEnd.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8073446 8262110\n- * @summary Tests DST related beyond the year 2037\n- * @run testng Beyond2037\n- *\/\n-\n-import java.text.SimpleDateFormat;\n-import java.util.TimeZone;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-\n-@Test\n-public class Beyond2037 {\n-\n-    @DataProvider\n-    Object[][] dstTransition() {\n-        return new Object[][] {\n-            {\"2037\/03\/08 01:59:59:999\", \"2037\/03\/08 01:59:59:999\"},\n-            {\"2037\/03\/08 02:00:00:000\", \"2037\/03\/08 03:00:00:000\"},\n-            {\"2038\/03\/14 01:59:59:999\", \"2038\/03\/14 01:59:59:999\"},\n-            {\"2038\/03\/14 02:00:00:000\", \"2038\/03\/14 03:00:00:000\"},\n-            {\"2099\/03\/08 01:59:59:999\", \"2099\/03\/08 01:59:59:999\"},\n-            {\"2099\/03\/08 02:00:00:000\", \"2099\/03\/08 03:00:00:000\"},\n-            {\"2100\/03\/14 01:59:59:999\", \"2100\/03\/14 01:59:59:999\"},\n-            {\"2100\/03\/14 02:00:00:000\", \"2100\/03\/14 03:00:00:000\"},\n-            {\"8000\/03\/12 01:59:59:999\", \"8000\/03\/12 01:59:59:999\"},\n-            {\"8000\/03\/12 02:00:00:000\", \"8000\/03\/12 03:00:00:000\"},\n-        };\n-    }\n-\n-    @Test(dataProvider=\"dstTransition\")\n-    public void testDstTransition(String source, String expected) throws Exception {\n-        var timeZone = TimeZone.getTimeZone(\"America\/New_York\");\n-        var sdf = new SimpleDateFormat(\"yyyy\/MM\/dd HH:mm:ss:SSS\" );\n-        sdf.setTimeZone(timeZone);\n-        assertEquals(sdf.format(sdf.parse(source)), expected);\n-    }\n-\n-    @Test\n-    public void testGetOffset() throws Exception {\n-        var timeZone = TimeZone.getTimeZone(\"PST8PDT\");\n-        var df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n-        df.setTimeZone(timeZone);\n-        var tMilli = df.parse(\"7681-03-09 03:20:49\").getTime();\n-        assertEquals(timeZone.getOffset(tMilli), -25200000);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Beyond2037.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.zip.CRC32;\n-\n-\/**\n- * Checksum provides methods for calculating a CRC32 value for a\n- * transitions table.\n- *\n- * @since 1.4\n- *\/\n-public class Checksum extends CRC32\n-{\n-    \/**\n-     * Updates the CRC32 value from each byte of the given int\n-     * value. The bytes are used in the big endian order.\n-     * @param val the int value\n-     *\/\n-    public void update(int val) {\n-        byte[] b = new byte[4];\n-        b[0] = (byte)((val >>> 24) & 0xff);\n-        b[1] = (byte)((val >>> 16) & 0xff);\n-        b[2] = (byte)((val >>> 8) & 0xff);\n-        b[3] = (byte)(val & 0xff);\n-        update(b);\n-    }\n-\n-    \/**\n-     * Updates the CRC32 value from each byte of the given long\n-     * value. The bytes are used in the big endian order.\n-     * @param val the long value\n-     *\/\n-    void update(long val) {\n-        byte[] b = new byte[8];\n-        b[0] = (byte)((val >>> 56) & 0xff);\n-        b[1] = (byte)((val >>> 48) & 0xff);\n-        b[2] = (byte)((val >>> 40) & 0xff);\n-        b[3] = (byte)((val >>> 32) & 0xff);\n-        b[4] = (byte)((val >>> 24) & 0xff);\n-        b[5] = (byte)((val >>> 16) & 0xff);\n-        b[6] = (byte)((val >>> 8) & 0xff);\n-        b[7] = (byte)(val & 0xff);\n-        update(b);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Checksum.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Day of week enum.\n- *\n- * @since 1.6\n- *\/\n-\n-enum DayOfWeek {\n-    SUNDAY(\"Sun\"),\n-    MONDAY(\"Mon\"),\n-    TUESDAY(\"Tue\"),\n-    WEDNESDAY(\"Wed\"),\n-    THURSDAY(\"Thu\"),\n-    FRIDAY(\"Fri\"),\n-    SATURDAY(\"Sat\");\n-\n-    private final String abbr;\n-\n-    private DayOfWeek(String abbr) {\n-        this.abbr = abbr;\n-    }\n-\n-    String getAbbr() {\n-        return abbr;\n-    }\n-\n-    int value() {\n-        return ordinal() + 1;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/DayOfWeek.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,342 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.IOException;\n-import  java.io.File;\n-import  java.io.FileOutputStream;\n-import  java.io.DataOutputStream;\n-import  java.io.RandomAccessFile;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-\n-\/**\n- * <code>Gen<\/code> is one of back-end classes of javazic, and generates\n- * ZoneInfoMappings and zone-specific file for each zone.\n- *\/\n-class Gen extends BackEnd {\n-\n-    \/**\n-     * Generates datafile in binary TLV format for each time zone.\n-     * Regarding contents of output files, see {@link ZoneInfoFile}.\n-     *\n-     * @param Timezone\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        try {\n-            int size;\n-            String outputDir = Main.getOutputDir();\n-            String zonefile = ZoneInfoFile.getFileName(tz.getName());\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-\n-            \/* If zonefile includes file-separator, it's treated as part of\n-             * pathname. And make directory if necessary.\n-             *\/\n-            int index = zonefile.lastIndexOf(File.separatorChar);\n-            if (index != -1) {\n-                outputDir += zonefile.substring(0, index+1);\n-            }\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            FileOutputStream fos =\n-                new FileOutputStream(outputDir + zonefile.substring(index+1));\n-            DataOutputStream dos = new DataOutputStream(fos);\n-\n-            \/* Output Label *\/\n-            dos.write(ZoneInfoFile.JAVAZI_LABEL, 0,\n-                      ZoneInfoFile.JAVAZI_LABEL.length);\n-\n-            \/* Output Version of ZoneInfoFile *\/\n-            dos.writeByte(ZoneInfoFile.JAVAZI_VERSION);\n-\n-            List<Long> transitions = tz.getTransitions();\n-            if (transitions != null) {\n-                List<Integer> dstOffsets = tz.getDstOffsets();\n-                List<Integer> offsets = tz.getOffsets();\n-\n-                if ((dstOffsets == null && offsets != null) ||\n-                    (dstOffsets != null && offsets == null)) {\n-                    Main.panic(\"Data not exist. (dstOffsets or offsets)\");\n-                    return 1;\n-                }\n-\n-                \/* Output Transition records *\/\n-                dos.writeByte(ZoneInfoFile.TAG_Transition);\n-                size = transitions.size();\n-                dos.writeShort((size * 8) & 0xFFFF);\n-                int dstoffset;\n-                for (int i = 0; i < size; i++) {\n-                    \/* if DST offset is 0, this means DST isn't used.\n-                     * (NOT: offset's index is 0.)\n-                     *\/\n-                    if ((dstoffset = dstOffsets.get(i).intValue()) == -1) {\n-                        dstoffset = 0;\n-                    }\n-\n-                    dos.writeLong((transitions.get(i).longValue() << 12)\n-                                  | (dstoffset << 4)\n-                                  | offsets.get(i).intValue());\n-\n-                }\n-\n-                \/* Output data for GMTOffset *\/\n-                List<Integer> gmtoffset = tz.getGmtOffsets();\n-                dos.writeByte(ZoneInfoFile.TAG_Offset);\n-                size = gmtoffset.size();\n-                dos.writeShort((size * 4) & 0xFFFF);\n-                for (int i = 0; i < size; i++) {\n-                    dos.writeInt(gmtoffset.get(i));\n-                }\n-            }\n-\n-            \/* Output data for SimpleTimeZone *\/\n-            List<RuleRec> stz = tz.getLastRules();\n-            if (stz != null) {\n-                RuleRec[] rr = new RuleRec[2];\n-                boolean wall = true;\n-\n-                rr[0] = stz.get(0);\n-                rr[1] = stz.get(1);\n-\n-                dos.writeByte(ZoneInfoFile.TAG_SimpleTimeZone);\n-                wall = rr[0].getTime().isWall() && rr[1].getTime().isWall();\n-                if (wall) {\n-                    dos.writeShort(32);\n-                } else {\n-                    dos.writeShort(40);\n-                }\n-\n-                for (int i = 0; i < 2; i++) {\n-                    dos.writeInt(rr[i].getMonthNum() - 1); \/\/ 0-based month number\n-                    dos.writeInt(rr[i].getDay().getDayForSimpleTimeZone());\n-                    dos.writeInt(rr[i].getDay().getDayOfWeekForSimpleTimeZoneInt());\n-                    dos.writeInt((int)rr[i].getTime().getTime());\n-                    if (!wall) {\n-                        dos.writeInt((rr[i].getTime().getType() & 0xFF) - 1);\n-                    }\n-                }\n-            }\n-\n-            \/* Output RawOffset *\/\n-            dos.writeByte(ZoneInfoFile.TAG_RawOffset);\n-            dos.writeShort(4);\n-            dos.writeInt(tz.getRawOffset());\n-\n-            \/* Output willGMTOffsetChange flag *\/\n-            if (tz.willGMTOffsetChange()) {\n-                dos.writeByte(ZoneInfoFile.TAG_GMTOffsetWillChange);\n-                dos.writeShort(1);\n-                dos.writeByte(1);\n-            }\n-\n-            \/* Output LastDSTSaving *\/\n-            dos.writeByte(ZoneInfoFile.TAG_LastDSTSaving);\n-            dos.writeShort(2);\n-            dos.writeShort(tz.getLastDSTSaving()\/1000);\n-\n-            \/* Output checksum *\/\n-            dos.writeByte(ZoneInfoFile.TAG_CRC32);\n-            dos.writeShort(4);\n-            dos.writeInt(tz.getCRC32());\n-\n-            fos.close();\n-            dos.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates ZoneInfoMappings in binary TLV format for each zone.\n-     * Regarding contents of output files, see {@link ZoneInfoFile}.\n-     *\n-     * @param Mappings\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            int index;\n-            int block_size;\n-            int roi_size;\n-            long fp;\n-            String outputDir = Main.getOutputDir();\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* Open ZoneInfoMapping file to write. *\/\n-            RandomAccessFile raf =\n-                new RandomAccessFile(outputDir + ZoneInfoFile.JAVAZM_FILE_NAME, \"rw\");\n-\n-            \/* Whether rawOffsetIndex list exists or not. *\/\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            if (roi == null) {\n-                Main.panic(\"Data not exist. (rawOffsetsIndex)\");\n-                return 1;\n-            }\n-            roi_size = roi.size();\n-\n-            \/* Whether rawOffsetIndexTable list exists or not. *\/\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-            if (roit == null || roit.size() != roi_size) {\n-                Main.panic(\"Data not exist. (rawOffsetsIndexTable) Otherwise, Invalid size\");\n-                return 1;\n-            }\n-\n-            \/* Output Label *\/\n-            raf.write(ZoneInfoFile.JAVAZM_LABEL, 0,\n-                      ZoneInfoFile.JAVAZM_LABEL.length);\n-\n-            \/* Output Version *\/\n-            raf.writeByte(ZoneInfoFile.JAVAZM_VERSION);\n-\n-            index = ZoneInfoFile.JAVAZM_LABEL.length + 2;\n-\n-            \/* Output Version of Olson's tzdata *\/\n-            byte[] b = Main.getVersionName().getBytes(\"UTF-8\");\n-            raf.writeByte(ZoneInfoFile.TAG_TZDataVersion);\n-            raf.writeShort((b.length+1) & 0xFFFF);\n-            raf.write(b);\n-            raf.writeByte(0x00);\n-            index += b.length + 4;\n-\n-            \/* Output ID list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_ZoneIDs);\n-            block_size = 2;\n-            raf.writeShort(block_size & 0xFFFF);\n-            short nID = 0;\n-            raf.writeShort(nID & 0xFFFF);\n-            for (int i = 0; i < roi_size; i++) {\n-                for (String key : roit.get(i)) {\n-                    byte size = (byte)key.getBytes(\"UTF-8\").length;\n-                    raf.writeByte(size & 0xFF);\n-                    raf.write(key.getBytes(\"UTF-8\"), 0, size);\n-                    block_size += 1 + size;\n-                    nID++;\n-                }\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.writeShort(nID & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Output sorted rawOffset list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_RawOffsets);\n-            index += 3 + block_size;\n-            block_size = roi_size * 4;\n-            raf.writeShort(block_size & 0xFFFF);\n-            for (int i = 0; i < roi_size; i++) {\n-                raf.writeInt(Integer.parseInt(roi.get(i).toString()));\n-            }\n-\n-            \/* Output sorted rawOffsetIndex list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_RawOffsetIndices);\n-            index += 3 + block_size;\n-            block_size = 0;\n-            raf.writeShort(block_size & 0xFFFF);\n-            int num;\n-            for (int i = 0; i < roi_size; i++) {\n-                num = roit.get(i).size();\n-                block_size += num;\n-                for (int j = 0; j < num; j++) {\n-                    raf.writeByte(i);\n-                }\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Whether alias list exists or not. *\/\n-            Map<String,String> a = map.getAliases();\n-            if (a == null) {\n-                Main.panic(\"Data not exist. (aliases)\");\n-                return 0;\n-            }\n-\n-            \/* Output ID list. *\/\n-            raf.writeByte(ZoneInfoFile.TAG_ZoneAliases);\n-            index += 3 + block_size;\n-            block_size = 2;\n-            raf.writeShort(block_size & 0xFFFF);\n-            raf.writeShort(a.size() & 0xFFFF);\n-            for (String key : a.keySet()) {\n-                String alias = a.get(key);\n-                byte key_size = (byte)key.length();\n-                byte alias_size = (byte)alias.length();\n-                raf.writeByte(key_size & 0xFF);\n-                raf.write(key.getBytes(\"UTF-8\"), 0, key_size);\n-                raf.writeByte(alias_size & 0xFF);\n-                raf.write(alias.getBytes(\"UTF-8\"), 0, alias_size);\n-                block_size += 2 + key_size + alias_size;\n-            }\n-            fp = raf.getFilePointer();\n-            raf.seek(index);\n-            raf.writeShort((block_size) & 0xFFFF);\n-            raf.seek(fp);\n-\n-            \/* Output the exclude list if it exists. *\/\n-            List<String> excludedZones = map.getExcludeList();\n-            if (excludedZones != null) {\n-                raf.writeByte(ZoneInfoFile.TAG_ExcludedZones);\n-                index += 3 + block_size;\n-                block_size = 2;\n-                raf.writeShort(block_size & 0xFFFF);  \/\/ place holder\n-                raf.writeShort(excludedZones.size()); \/\/ the number of excluded zones\n-                for (String name : excludedZones) {\n-                    byte size = (byte) name.length();\n-                    raf.writeByte(size);                 \/\/ byte length\n-                    raf.write(name.getBytes(\"UTF-8\"), 0, size); \/\/ zone name\n-                    block_size += 1 + size;\n-                }\n-                fp = raf.getFilePointer();\n-                raf.seek(index);\n-                raf.writeShort(block_size & 0xFFFF);\n-                raf.seek(fp);\n-            }\n-\n-            \/* Close ZoneInfoMapping file. *\/\n-            raf.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Gen.java","additions":0,"deletions":342,"binary":false,"changes":342,"status":"deleted"},{"patch":"@@ -1,776 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.BufferedReader;\n-import  java.io.BufferedWriter;\n-import  java.io.File;\n-import  java.io.FileReader;\n-import  java.io.FileWriter;\n-import  java.io.IOException;\n-import  java.util.Date;\n-import  java.util.HashMap;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.SortedMap;\n-import  java.util.StringTokenizer;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>GenDoc<\/code> is one of back-end classes of javazic, and generates\n- * index.html and other html files which prints the detailed time zone\n- * information for each zone.\n- *\/\n-class GenDoc extends BackEnd {\n-\n-    private static final String docDir = \"doc\";\n-\n-    private static final String header1 =\n-        \"<!DOCTYPE HTML PUBLIC \\\"-\/\/W3C\/\/DTD HTML 4.0 Frameset\/\/EN\\\"\" +\n-        \"\\\"http:\/\/www.w3.org\/TR\/REC-html40\/frameset.dtd\\\">\\n\" +\n-        \"<HTML>\\n<HEAD>\\n<!-- Generated by javazic on \";\n-    private static final String header2 =\n-        \"-->\\n<TITLE>\\n\" +\n-        \"Java Platform, Standard Edition - TimeZone information based on \";\n-    private static final String header3 =\n-        \"-->\\n<TITLE>\\n\" +\n-        \"Java Platform, Standard Edition  TimeZone - \";\n-    private static final String header4 =\n-        \"<\/TITLE>\\n\" +\n-        \"<\/HEAD>\\n\\n\";\n-\n-    private static final String body1 =\n-        \"<BODY BGCOLOR=\\\"white\\\">\\n\";\n-    private static final String body2 =\n-        \"<\/BODY>\\n\";\n-\n-    private static final String footer =\n-        \"<\/HTML>\\n\";\n-\n-\n-    \/\/ list of time zone name and zonefile name\/real time zone name\n-    \/\/   e.g.\n-    \/\/      key (String)       : value (String)\n-    \/\/      \"America\/Denver\"   : \"America\/Denver.html\" (real time zone)\n-    \/\/      \"America\/Shiprock\" : \"America\/Denver\"      (alias)\n-    TreeMap<String,String> timezoneList = new TreeMap<String,String>();\n-\n-    \/\/ list of time zone's display name and time zone name\n-    \/\/   e.g.\n-    \/\/      key (String)                : value (String)\n-    \/\/      \"Tokyo, Asia\"               : \"Asia\/Tokyo\"\n-    \/\/      \"Marengo, Indiana, America\" : \"America\/Indiana\/Marengo\"\n-    \/\/          (aliases included)\n-    TreeMap<String,String> displayNameList = new TreeMap<String,String>();\n-\n-    \/\/ list of top level regions\n-    \/\/   e.g.\n-    \/\/      key (String) : value (String)\n-    \/\/      \"America\"    : \"America.html\"\n-    \/\/          (including entries in America\/Indiana\/, America\/Kentucky\/, ...)\n-    TreeMap<String,String> regionList = new TreeMap<String,String>();\n-\n-    \/\/ mapping list from zone name to latitude & longitude\n-    \/\/   This list is generated from zone.tab.\n-    \/\/   e.g.\n-    \/\/      key (String) : value (LatitudeAndLongitude object)\n-    \/\/      \"Asia\/Tokyo\" : latitude=35.3916, longitude=13.9444\n-    \/\/          (aliases not included)\n-    HashMap<String,LatitudeAndLongitude> mapList = null;\n-\n-    \/\/ SortedMap of zone IDs sorted by their GMT offsets. If zone's GMT\n-    \/\/ offset will change in the future, its last known offset is\n-    \/\/ used.\n-    SortedMap<Integer, Set<String>> zonesByOffset = new TreeMap<Integer, Set<String>>();\n-\n-    \/**\n-     * Generates HTML document for each zone.\n-     * @param Timezone\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        try {\n-            int size;\n-            int index;\n-            String outputDir = Main.getOutputDir();\n-            String zonename = tz.getName();\n-            String zonefile = ZoneInfoFile.getFileName(zonename) + \".html\";\n-            List<RuleRec> stz = tz.getLastRules();\n-            timezoneList.put(zonename, zonefile);\n-            displayNameList.put(transform(zonename), zonename);\n-\n-            \/\/ Populate zonesByOffset. (Zones that will change their\n-            \/\/ GMT offsets are also added to zonesByOffset here.)\n-            int lastKnownOffset = tz.getRawOffset();\n-            Set<String> set = zonesByOffset.get(lastKnownOffset);\n-            if (set == null) {\n-                set = new TreeSet<String>();\n-                zonesByOffset.put(lastKnownOffset, set);\n-            }\n-            set.add(zonename);\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-            outputDir += docDir + File.separatorChar;\n-\n-            index = zonename.indexOf('\/');\n-            if (index != -1) {\n-                regionList.put(zonename.substring(0, index),\n-                               zonename.substring(0, index) + \".html\");\n-            }\n-\n-            \/* If zonefile includes file-separator, it's treated as part of\n-             * pathname. And make directory if necessary.\n-             *\/\n-            index = zonefile.lastIndexOf('\/');\n-            if (index != -1) {\n-                zonefile.replace('\/', File.separatorChar);\n-                outputDir += zonefile.substring(0, index+1);\n-            }\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* If mapfile is available, add a link to the appropriate map *\/\n-            if (mapList == null && Main.getMapFile() != null) {\n-                mapList = new HashMap<String, LatitudeAndLongitude>();\n-                FileReader fr = new FileReader(Main.getMapFile());\n-                BufferedReader in = new BufferedReader(fr);\n-                String line;\n-                while ((line = in.readLine()) != null) {\n-                    \/\/ skip blank and comment lines\n-                    if (line.length() == 0 || line.charAt(0) == '#') {\n-                        continue;\n-                    }\n-                    StringTokenizer tokens = new StringTokenizer(line);\n-                    String token = tokens.nextToken();  \/* We don't use the first token. *\/\n-                    token = tokens.nextToken();\n-                    LatitudeAndLongitude location = new LatitudeAndLongitude(token);\n-                    token = tokens.nextToken();\n-                    mapList.put(token, location);\n-                }\n-                in.close();\n-            }\n-\n-            \/* Open zoneinfo file to write. *\/\n-            FileWriter fw = new FileWriter(outputDir + zonefile.substring(index+1));\n-            BufferedWriter out = new BufferedWriter(fw);\n-\n-            out.write(header1 + new Date() + header3 + zonename + header4);\n-            out.write(body1 + \"<FONT size=\\\"+2\\\"><B>\" + zonename + \"<\/B><\/FONT>\");\n-            LatitudeAndLongitude location = (mapList != null ? mapList.get(zonename) : null);\n-            if (location != null) {\n-                int deg, min, sec;\n-\n-                deg = location.getLatDeg();\n-                min = location.getLatMin();\n-                sec = location.getLatSec();\n-                if (deg < 0) {\n-                    min = -min;\n-                    sec = -sec;\n-                } else if (min < 0) {\n-                    sec = -sec;\n-                }\n-                out.write(\"&nbsp;&nbsp;&nbsp;\" +\n-                          \"<A HREF=\\\"http:\/\/www.mapquest.com\/maps\/map.adp?\" +\n-                          \"latlongtype=degrees\" +\n-                          \"&latdeg=\" + deg +\n-                          \"&latmin=\" + min +\n-                          \"&latsec=\" + sec);\n-\n-                deg = location.getLongDeg();\n-                min = location.getLongMin();\n-                sec = location.getLongSec();\n-                if (deg < 0) {\n-                    min = -min;\n-                    sec = -sec;\n-                } else if (min < 0) {\n-                    sec = -sec;\n-                }\n-                out.write(\"&longdeg=\" + deg +\n-                          \"&longmin=\" + min +\n-                          \"&longsec=\" + sec +\n-                          \"\\\" target=\\\"_blank\\\">[map]<\/A>\");\n-            }\n-            out.write(\"\\n<P>\\n\");\n-\n-            List<ZoneRec> zone = tz.getZones();\n-            List<RuleRec> rule = tz.getRules();\n-            if (rule != null && zone != null) {\n-                out.write(\"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"1\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR>\\n\" +\n-                          \"<TD BGCOLOR=\\\"#EEEEFF\\\" WIDTH=\\\"50%\\\" ALIGN=\\\"CENTER\\\"><BR>\" +\n-                          \"<A HREF=\\\"#Rules\\\">Rules<\/A><BR><\/TD>\\n\" +\n-                          \"<TD BGCOLOR=\\\"#EEEEFF\\\" WIDTH=\\\"50%\\\" ALIGN=\\\"CENTER\\\">\" +\n-                          \"<A HREF=\\\"#Zone\\\"><BR>Zone<BR><\/A><\/TD>\\n\" +\n-                          \"<\/TR>\\n<\/TABLE>\\n\");\n-            }\n-\n-            \/* Output Rule records. *\/\n-            if (rule != null) {\n-                size = rule.size();\n-                out.write(\"<P>\\n<A NAME=\\\"Rules\\\">\" +\n-                          \"<FONT SIZE=\\\"+1\\\"><B>Rules<\/B><\/FONT><\/A>\\n\" +\n-                          \"<TABLE BORDER=\\\"1\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"3\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR BGCOLOR=\\\"#CCCCFF\\\">\\n\" +\n-                          \"<TD>NAME<\/TD><TD>FROM<\/TD><TD>TO<\/TD><TD>TYPE<\/TD>\" +\n-                          \"<TD>IN<\/TD><TD>ON<\/TD><TD>AT<\/TD><TD>SAVE<\/TD>\" +\n-                          \"<TD>LETTER\/S<\/TD><TD>NOTES<\/TD>\\n<\/TR>\\n\");\n-                for (int i = 0; i < size; i++) {\n-                    out.write(\"<TR BGCOLOR=\\\"#FFFFFF\\\">\\n\");\n-                    StringTokenizer st = new StringTokenizer(rule.get(i).getLine());\n-                    String s;\n-                    if (st.hasMoreTokens()) {   \/* RULE - truncated *\/\n-                        st.nextToken();\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* NAME *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* FROM *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* TO *\/\n-                        s = st.nextToken();\n-                        if (s.equals(\"min\") || s.equals(\"max\")) {\n-                            out.write(\"<TD><FONT COLOR=\\\"red\\\">\" + s + \"<\/FONT><\/TD>\");\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");\n-                        }\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* TYPE *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* IN *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* ON *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* AT *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* SAVE *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* LETTER\/S *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* NOTES *\/\n-                        s = st.nextToken();\n-                        while (st.hasMoreTokens()) {\n-                            s += \" \" + st.nextToken();\n-                        }\n-                        index = s.indexOf('#');\n-                        out.write(\"<TD>\" + s.substring(index+1) + \"<\/TD>\\n\");\n-                    } else {\n-                        out.write(\"<TD>&nbsp;<\/TD>\\n\");\n-                    }\n-                    out.write(\"<\/TR>\\n\");\n-                }\n-                out.write(\"<\/TABLE>\\n<P>&nbsp;<P>\\n\");\n-            }\n-\n-            \/* Output Zone records. *\/\n-            if (zone != null) {\n-                size = zone.size();\n-                out.write(\"<P>\\n<A NAME=\\\"Zone\\\">\" +\n-                          \"<FONT SIZE=\\\"+1\\\"><B>Zone<\/B><\/FONT><\/A>\\n\" +\n-                          \"<TABLE BORDER=\\\"1\\\" WIDTH=\\\"100%\\\" CELLPADDING=\\\"3\\\" CELLSPACING=\\\"0\\\">\\n\" +\n-                          \"<TR BGCOLOR=\\\"#CCCCFF\\\">\\n<TD>GMTOFF<\/TD>\" +\n-                          \"<TD>RULES<\/TD><TD>FORMAT<\/TD><TD>UNTIL<\/TD>\" +\n-                          \"<TD>NOTES<\/TD>\\n<\/TR>\\n\");\n-                for (int i = 0; i < size; i++) {\n-                    out.write(\"<TR>\\n\");\n-                    StringTokenizer st = new StringTokenizer(zone.get(i).getLine());\n-                    String s = st.nextToken();\n-                    if (s.equals(\"Zone\")) {     \/* NAME *\/\n-                        s = st.nextToken();\n-                        s = st.nextToken();\n-                    }\n-                    out.write(\"<TD>\" + s + \"<\/TD>\");    \/* GMTOFFSET *\/\n-                    if (st.hasMoreTokens()) {   \/* RULES *\/\n-                        out.write(\"<TD>\" + st.nextToken() + \"<\/TD>\");\n-                    }\n-                    if (st.hasMoreTokens()) {   \/* FORMAT *\/\n-                        s = st.nextToken();\n-                        index = s.indexOf('#');\n-                        if (index != -1) {\n-                            if (index != 0) {\n-                                out.write(\"<TD>\" + s.substring(0, index-1) +\n-                                          \"<\/TD>\");     \/* FORMAT *\/\n-                                s = s.substring(index+1);\n-                            } else {\n-                                out.write(\"<TD>&nbsp;<\/TD>\");   \/* FORMAT *\/\n-                            }\n-                            while (st.hasMoreTokens()) {\n-                                s += \" \" + st.nextToken();\n-                            }\n-                            out.write(\"<TD>&nbsp;<\/TD>\");       \/* UNTIL *\/\n-                            out.write(\"<TD>\" + s + \"<\/TD>\\n<\/TR>\\n\");   \/* NOTES *\/\n-                            continue;\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");    \/* FORMAT *\/\n-                        }\n-                    }\n-\n-                    if (st.hasMoreTokens()) {   \/* UNTIL *\/\n-                        s = st.nextToken();\n-                        while (st.hasMoreTokens()) {\n-                            s += \" \" + st.nextToken();\n-                        }\n-                        index = s.indexOf('#');\n-                        if (index != -1) {\n-                            if (index != 0) {\n-                                out.write(\"<TD>\" + s.substring(0, index-1) +\n-                                          \"<\/TD>\");     \/* UNTIL *\/\n-                            } else {\n-                                out.write(\"<TD>&nbsp;<\/TD>\");   \/* UNTIL *\/\n-                            }\n-                            out.write(\"<TD>\" + s.substring(index+1) +\n-                                      \"<\/TD>\\n\");       \/* NOTES *\/\n-                        } else {\n-                            out.write(\"<TD>\" + s + \"<\/TD>\");    \/* UNTIL *\/\n-                            out.write(\"<TD>&nbsp;<\/TD>\\n\");     \/* NOTES *\/\n-                        }\n-                    } else {\n-                        out.write(\"<TD>&nbsp;<\/TD>\");           \/* UNTIL *\/\n-                        out.write(\"<TD>&nbsp;<\/TD>\\n\");         \/* NOTES *\/\n-                    }\n-                    out.write(\"<\/TR>\\n\");\n-                }\n-                out.write(\"<\/TABLE>\\n\");\n-            }\n-            out.write(body2 + footer);\n-\n-            out.close();\n-            fw.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates index.html and other top-level frame files.\n-     * @param Mappings\n-     * @return 0 if no errors, or 1 if error occurred.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            int len;\n-            Object o[];\n-            String outputDir = Main.getOutputDir();\n-            FileWriter fw1, fw2;\n-            BufferedWriter out1, out2;\n-\n-            \/* Whether alias list exists or not. *\/\n-            Map<String,String> a = map.getAliases();\n-            if (a == null) {\n-                Main.panic(\"Data not exist. (aliases)\");\n-                return 1;\n-            }\n-\n-            timezoneList.putAll(a);\n-\n-            \/* If outputDir doesn't end with file-separator, adds it. *\/\n-            if (!outputDir.endsWith(File.separator)) {\n-                outputDir += File.separatorChar;\n-            }\n-            outputDir += docDir + File.separatorChar;\n-\n-            File outD = new File(outputDir);\n-            outD.mkdirs();\n-\n-            \/* Creates index.html *\/\n-            fw1 = new FileWriter(outputDir + \"index.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 +\n-                       \"<FRAMESET cols=\\\"20%,80%\\\">\\n\" +\n-                       \"<FRAMESET rows=\\\"30%,70%\\\">\\n\" +\n-                       \"<FRAME src=\\\"overview-frame.html\\\" name=\\\"TimeZoneListFrame\\\">\\n\" +\n-                       \"<FRAME src=\\\"allTimeZone-frame1.html\\\" name=\\\"allTimeZoneFrame\\\">\\n\" +\n-                       \"<\/FRAMESET>\" +\n-                       \"<FRAME src=\\\"overview-summary.html\\\" name=\\\"rightFrame\\\">\\n\" +\n-                       \"<\/FRAMESET>\\n\" +\n-                       \"<NOFRAMES>\\n\" +\n-                       \"<H2>\\nFrame Alert\\n<\/H2>\\n\\n\" +\n-                       \"<P>\\n\\n\" +\n-                       \"This document is designed to be viewed using the frames feature. If you see this\\n\" +\n-                       \"message, you are using a non-frame-capable web client.\\n\" +\n-                       \"<BR>\\n\" +\n-                       \"Link to<A HREF=\\\"overview-summary.html\\\">Non-frame version.<\/A>\\n\" +\n-                       \"<\/NOFRAMES>\\n\" + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates overview-frame.html *\/\n-            fw1 = new FileWriter(outputDir + \"overview-frame.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n<TR>\\n\" +\n-                       \"<TD NOWRAP><FONT size=\\\"+1\\\">\\n\" +\n-                       \"<B>Java<sup><font size=-2>TM<\/font><\/sup>&nbsp;Platform<br>Standard&nbsp;Ed.<\/B><\/FONT><\/TD>\\n\" +\n-                       \"<\/TR>\\n<\/TABLE>\\n\\n\" +\n-                       \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n<TR>\\n<TD NOWRAP>\" +\n-                       \"<P>\\n<FONT size=\\\"+1\\\">\\nAll Time Zones Sorted By:<\/FONT>\\n<BR>\\n\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame1.html\\\" TARGET=\\\"allTimeZoneFrame\\\">GMT offsets<\/A><\/FONT>\\n<BR>\\n\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame2.html\\\" TARGET=\\\"allTimeZoneFrame\\\">Zone names<\/A><\/FONT>\\n<BR>\" +\n-                       \"&nbsp;&nbsp;<A HREF=\\\"allTimeZone-frame3.html\\\" TARGET=\\\"allTimeZoneFrame\\\">City names<\/A><\/FONT>\\n\" +\n-                       \"<P>\\n<FONT size=\\\"+1\\\">\\nContinents and Oceans<\/FONT>\\n<BR>\\n\");\n-\n-            for (String regionKey : regionList.keySet()) {\n-                out1.write(\"&nbsp;&nbsp;<A HREF=\\\"\" + regionList.get(regionKey) +\n-                           \"\\\" TARGET=\\\"allTimeZoneFrame\\\">\" + regionKey +\n-                           \"<\/A><BR>\\n\");\n-\n-                fw2 = new FileWriter(outputDir + regionList.get(regionKey),\n-                                     false);\n-                out2 = new BufferedWriter(fw2);\n-\n-                out2.write(header1 + new Date() + header3 + regionKey +\n-                           header4 + body1 + \"<FONT size=\\\"+1\\\"><B>\" +\n-                           regionKey + \"<\/B><\/FONT>\\n<BR>\\n<TABLE>\\n<TR>\\n<TD>\");\n-\n-                boolean found = false;\n-                for (String timezoneKey : timezoneList.keySet()) {\n-                    int regionIndex = timezoneKey.indexOf('\/');\n-                    if (regionIndex == -1 ||\n-                        !regionKey.equals(timezoneKey.substring(0, regionIndex))) {\n-                        if (found) {\n-                            break;\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-\n-                    found = true;\n-                    if (a.containsKey(timezoneKey)) {\n-                        Object realName = a.get(timezoneKey);\n-                        while (a.containsKey(realName)) {\n-                            realName = a.get(realName);\n-                        }\n-                        out2.write(timezoneKey +\n-                                   \" (alias for \" + \"<A HREF=\\\"\" +\n-                                   timezoneList.get(realName) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" +\n-                                   realName + \"<\/A>)\");\n-                    } else {\n-                        out2.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                                   \"<\/A>\");\n-                    }\n-                    out2.write(\"<BR>\\n\");\n-                }\n-                out2.write(\"<\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-                out2.close();\n-                fw2.close();\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR><\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates allTimeZone-frame1.html (Sorted by GMT offsets) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame1.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by GMT offsets<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-\n-            int index = 0;\n-            for (Integer offset : zonesByOffset.keySet()) {\n-                int off = roi.get(index);\n-                Set<String> perRO = zonesByOffset.get(offset);\n-                if (offset == off) {\n-                    \/\/ Merge aliases into zonesByOffset\n-                    perRO.addAll(roit.get(index));\n-                }\n-                index++;\n-\n-                for (String timezoneKey : perRO) {\n-                    out1.write(\"<TR>\\n<TD><FONT SIZE=\\\"-1\\\">(\" +\n-                               Time.toGMTFormat(offset.toString()) +\n-                               \")<\/FONT><\/TD>\\n<TD>\");\n-\n-                    if (a.containsKey(timezoneKey)) {\n-                        Object realName = a.get(timezoneKey);\n-                        while (a.containsKey(realName)) {\n-                            realName = a.get(realName);\n-                        }\n-                        out1.write(timezoneKey +\n-                                   \" (alias for \" + \"<A HREF=\\\"\" +\n-                                   timezoneList.get(realName) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                                   \"<\/A>)\");\n-                    } else {\n-                        out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                                   \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                                   \"<\/A>\");\n-                    }\n-                    out1.write(\"<\/TD>\\n<\/TR>\\n\");\n-                }\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-\n-            \/* Creates allTimeZone-frame2.html (Sorted by zone names) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame2.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by zone names<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-            o = timezoneList.keySet().toArray();\n-            len = timezoneList.size();\n-            for (int i = 0; i < len; i++) {\n-                Object timezoneKey = o[i];\n-                if (a.containsKey(timezoneKey)) {\n-                    Object realName = a.get(timezoneKey);\n-                    while (a.containsKey(realName)) {\n-                        realName = a.get(realName);\n-                    }\n-                    out1.write(timezoneKey +\n-                               \" (alias for \" +\n-                               \"<A HREF=\\\"\" + timezoneList.get(realName) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                               \"<\/A>)\");\n-                } else {\n-                    out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + timezoneKey +\n-                               \"<\/A>\");\n-                }\n-                out1.write(\"<BR> \\n\");\n-            }\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-            \/* Creates allTimeZone-frame3.html (Sorted by city names) *\/\n-            fw1 = new FileWriter(outputDir + \"allTimeZone-frame3.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<FONT size=\\\"+1\\\"><B>Sorted by city names<\/B><\/FONT>\\n\" +\n-                       \"<BR>\\n\\n\" + \"<TABLE BORDER=\\\"0\\\" WIDTH=\\\"100%\\\">\\n\" +\n-                       \"<TR>\\n<TD NOWRAP>\\n\");\n-\n-            Set<String> aliasSet = a.keySet();\n-            len = aliasSet.size();\n-            String aliasNames[] = aliasSet.toArray(new String[0]);\n-            for (int i = 0; i < len; i++) {\n-                displayNameList.put(transform(aliasNames[i]),\n-                                    aliasNames[i]);\n-            }\n-\n-            o = displayNameList.keySet().toArray();\n-            len = displayNameList.size();\n-            for (int i = 0; i < len; i++) {\n-                Object displayName = o[i];\n-                Object timezoneKey = displayNameList.get(o[i]);\n-                if (a.containsKey(timezoneKey)) {\n-                    Object realName = a.get(timezoneKey);\n-                    while (a.containsKey(realName)) {\n-                        realName = a.get(realName);\n-                    }\n-                    out1.write(displayName +\n-                               \" (alias for \" +\n-                               \"<A HREF=\\\"\" + timezoneList.get(realName) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + realName +\n-                               \"<\/A>)\");\n-                } else {\n-                    out1.write(\"<A HREF=\\\"\" + timezoneList.get(timezoneKey) +\n-                               \"\\\" TARGET=\\\"rightFrame\\\">\" + displayName +\n-                               \"<\/A>\");\n-                }\n-                out1.write(\"<BR> \\n\");\n-            }\n-\n-            out1.write(\"<\/FONT><\/TD>\\n<\/TR>\\n<\/TABLE>\\n\" + body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-\n-            \/* Creates overview-summary.html *\/\n-            fw1 = new FileWriter(outputDir + \"overview-summary.html\", false);\n-            out1 = new BufferedWriter(fw1);\n-\n-            out1.write(header1 + new Date() + header2 + Main.getVersionName() +\n-                       header4 + body1 +\n-                       \"<p>This is the list of time zones generated from <B>\" +\n-                       Main.getVersionName() + \"<\/B> for Java Platform, \" +\n-                       \"Standard Edition. The source code can be obtained \" +\n-                       \"from ftp site <a href=\\\"ftp:\/\/elsie.nci.nih.gov\/pub\/\\\">\" +\n-                       \"ftp:\/\/elsie.nci.nih.gov\/pub\/<\/a>. A total of <B>\" +\n-                       len +\n-                       \"<\/B> time zones and aliases are supported \" +\n-                       \"in this edition. For the \" +\n-                       \"format of rules and zones, refer to the zic \" +\n-                       \"(zoneinfo compiler) man page on \" +\n-                       \"Solaris or Linux.<\/p>\\n\" +\n-                       \"<p>Note that the time zone data is not \" +\n-                       \"a public interface of the Java Platform. No \" +\n-                       \"applications should rely on the time zone data of \" +\n-                       \"this document. Time zone names and data \" +\n-                       \"may change without any prior notice.<\/p>\\n\" +\n-                       body2 + footer);\n-\n-            out1.close();\n-            fw1.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-\n-    String transform(String s) {\n-        int index = s.lastIndexOf(\"\/\");\n-\n-        \/* If the string doesn't include any delimiter, return *\/\n-        if (index == -1) {\n-            return s;\n-        }\n-\n-        int lastIndex = index;\n-        String str = s.substring(index+1);\n-        do {\n-            index = s.substring(0, lastIndex).lastIndexOf('\/');\n-            str += \", \" + s.substring(index+1, lastIndex);\n-            lastIndex = index;\n-        } while (index > -1);\n-\n-        return str;\n-    }\n-\n-    static class LatitudeAndLongitude {\n-\n-        private int latDeg, latMin, latSec, longDeg, longMin, longSec;\n-\n-        LatitudeAndLongitude(String s) {\n-            try {\n-                \/\/ First of all, check the string has the correct format:\n-                \/\/    either +-DDMM+-DDDMM or +-DDMMSS+-DDDMMSS\n-\n-                if (!s.startsWith(\"+\") && !s.startsWith(\"-\")) {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                int index;\n-                if (((index = s.lastIndexOf(\"+\")) <= 0) &&\n-                    ((index = s.lastIndexOf(\"-\")) <= 0)) {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-\n-                if (index == 5) {\n-                    latDeg = Integer.parseInt(s.substring(1, 3));\n-                    latMin = Integer.parseInt(s.substring(3, 5));\n-                    latSec = 0;\n-                } else if (index == 7) {\n-                    latDeg = Integer.parseInt(s.substring(1, 3));\n-                    latMin = Integer.parseInt(s.substring(3, 5));\n-                    latSec = Integer.parseInt(s.substring(5, 7));\n-                } else {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                if (s.startsWith(\"-\")){\n-                        latDeg = -latDeg;\n-                        latMin = -latMin;\n-                        latSec = -latSec;\n-                }\n-\n-                int len = s.length();\n-                if (index == 5 && len == 11) {\n-                    longDeg = Integer.parseInt(s.substring(index+1, index+4));\n-                    longMin = Integer.parseInt(s.substring(index+4, index+6));\n-                    longSec = 0;\n-                } else if (index == 7 && len == 15) {\n-                    longDeg = Integer.parseInt(s.substring(index+1, index+4));\n-                    longMin = Integer.parseInt(s.substring(index+4, index+6));\n-                    longSec = Integer.parseInt(s.substring(index+6, index+8));\n-                } else {\n-                    Main.warning(\"Wrong latitude&longitude data: \" + s);\n-                    return;\n-                }\n-                if (s.charAt(index) == '-'){\n-                        longDeg = -longDeg;\n-                        longMin = -longMin;\n-                        longSec = -longSec;\n-                }\n-            } catch(Exception e) {\n-                Main.warning(\"LatitudeAndLongitude() Parse error: \" + s);\n-            }\n-        }\n-\n-        int getLatDeg() {\n-            return latDeg;\n-        }\n-\n-        int getLatMin() {\n-            return latMin;\n-        }\n-\n-        int getLatSec() {\n-            return latSec;\n-        }\n-\n-        int getLongDeg() {\n-            return longDeg;\n-        }\n-\n-        int getLongMin() {\n-            return longMin;\n-        }\n-\n-        int getLongSec() {\n-            return longSec;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/GenDoc.java","additions":0,"deletions":776,"binary":false,"changes":776,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Main class for the javazic time zone data compiler.\n- *\n- * @since 1.4\n- *\/\n-public class Main {\n-\n-    private static boolean verbose = false;\n-    static boolean outputDoc = false;\n-\n-    private List<String> ziFiles = new ArrayList<String>();\n-    private static String zoneNamesFile = null;\n-    private static String versionName = \"unknown\";\n-    private static String outputDir = \"zoneinfo\";\n-    private static String mapFile = null;\n-\n-    \/**\n-     * Parses the specified arguments and sets up the variables.\n-     * @param argv the arguments\n-     *\/\n-    void processArgs(String[] argv) {\n-        for (int i = 0; i < argv.length; i++) {\n-            String arg = argv[i];\n-            if (arg.startsWith(\"-h\")) {\n-                usage();\n-                System.exit(0);\n-            } else if (arg.equals(\"-d\")) {\n-                outputDir = argv[++i];\n-            } else if (arg.equals(\"-v\")) {\n-                verbose = true;\n-            } else if (arg.equals(\"-V\")) {\n-                versionName = argv[++i];\n-            } else if (arg.equals(\"-doc\")) {\n-                outputDoc = true;\n-            } else if (arg.equals(\"-map\")) {\n-                outputDoc = true;\n-                mapFile = argv[++i];\n-            } else if (arg.equals(\"-f\")) {\n-                zoneNamesFile = argv[++i];\n-            } else if (arg.equals(\"-S\")) {\n-                try {\n-                    Zoneinfo.setYear(Integer.parseInt(argv[++i]));\n-                } catch (Exception e) {\n-                    error(\"invalid year: \" + argv[i]);\n-                    usage();\n-                    System.exit(1);\n-                }\n-            } else {\n-                boolean isStartYear = arg.equals(\"-s\");\n-                if (isStartYear || arg.equals(\"-e\")) {\n-                    try {\n-                        int year = Integer.parseInt(argv[++i]);\n-                        if (isStartYear) {\n-                            Zoneinfo.setStartYear(year);\n-                        } else {\n-                            Zoneinfo.setEndYear(year);\n-                        }\n-                    } catch (Exception e) {\n-                        error(\"invalid year: \" + argv[i]);\n-                        usage();\n-                        System.exit(1);\n-                    }\n-                } else {\n-                    \/\/ the rest of args are zoneinfo source files\n-                    while (i < argv.length) {\n-                        ziFiles.add(argv[i++]);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Parses zoneinfo source files\n-     *\/\n-    int compile() {\n-        int nFiles = ziFiles.size();\n-        int status = 0;\n-        Mappings maps = new Mappings();\n-        BackEnd backend = BackEnd.getBackEnd();\n-\n-        for (int i = 0; i < nFiles; i++) {\n-            Zoneinfo frontend = Zoneinfo.parse(ziFiles.get(i));\n-\n-            for (String key : frontend.getZones().keySet()) {\n-                info(key);\n-\n-                Timezone tz = frontend.phase2(key);\n-                status |= backend.processZoneinfo(tz);\n-            }\n-\n-            maps.add(frontend);\n-        }\n-\n-        \/\/ special code for dealing with the conflicting name \"MET\"\n-        Zone.addMET();\n-\n-        maps.resolve();\n-\n-        status |= backend.generateSrc(maps);\n-\n-        return status;\n-    }\n-\n-    public static void main(String[] argv) {\n-        Main zic = new Main();\n-\n-        \/*\n-         * Parse args\n-         *\/\n-        zic.processArgs(argv);\n-\n-        \/*\n-         * Read target zone names\n-         *\/\n-        if (zoneNamesFile != null) {\n-            Zone.readZoneNames(zoneNamesFile);\n-        }\n-\n-        zic.compile();\n-    }\n-\n-    void usage() {\n-        System.err.println(\"Usage: javazic [options] file...\\n\"+\n-                           \"         -f namefile  file containing zone names\\n\"+\n-                           \"                      to be generated (ie, generating subset)\\n\"+\n-                           \"         -d dir       output directory\\n\"+\n-                           \"         -v           verbose\\n\"+\n-                           \"         -V datavers  specifies the tzdata version string\\n\"+\n-                           \"                      (eg, \\\"tzdata2000g\\\")\"+\n-                           \"         -S year      output only SimleTimeZone data of that year\\n\"+\n-                           \"         -s year      start year (default: 1900)\\n\"+\n-                           \"         -e year      end year (default: 2037)\\n\"+\n-                           \"         -doc         generates HTML documents\\n\"+\n-                           \"         -map mapfile generates HTML documents with map information\\n\"+\n-                           \"         file...      zoneinfo source file(s)\");\n-    }\n-\n-    \/**\n-     * @return the output directory path name\n-     *\/\n-    static String getOutputDir() {\n-        return outputDir;\n-    }\n-\n-    \/**\n-     * @return the map file's path and name\n-     *\/\n-    static String getMapFile() {\n-        return mapFile;\n-    }\n-\n-    \/**\n-     * Returns the time zone data version string specified by the -V\n-     * option. If it is not specified, \"unknown\" is returned.\n-     * @return the time zone data version string\n-     *\/\n-    static String getVersionName() {\n-        return versionName;\n-    }\n-\n-    \/**\n-     * Prints out the specified fatal error message and calls {@link\n-     * java.lang.System#exit System.exit(1)}.\n-     * @param msg the fatal error message\n-     *\/\n-    static void panic(String msg) {\n-        printMessage(\"fatal error\", msg);\n-        System.exit(1);\n-    }\n-\n-    \/**\n-     * Prints out the specified error message.\n-     * @param msg the error message\n-     *\/\n-    static void error(String msg) {\n-        printMessage(\"error\", msg);\n-    }\n-\n-    \/**\n-     * Prints out the specified warning message.\n-     * @param msg the warning message\n-     *\/\n-    static void warning(String msg) {\n-        printMessage(\"warning\", msg);\n-    }\n-\n-    \/**\n-     * Prints out the informative message.\n-     * @param msg the informative message\n-     *\/\n-    static void info(String msg) {\n-        if (verbose) {\n-            printMessage(null, msg);\n-        }\n-    }\n-\n-    private static void printMessage(String type, String msg) {\n-        if (type != null) {\n-            type += \": \";\n-        } else {\n-            type = \"\";\n-        }\n-        System.err.println(\"javazic: \" + type + msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Main.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,193 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.util.ArrayList;\n-import  java.util.HashMap;\n-import  java.util.LinkedList;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>Mappings<\/code> generates two Maps and a List which are used by\n- * javazic BackEnd.\n- *\n- * @since 1.4\n- *\/\n-class Mappings {\n-    \/\/ All aliases specified by Link statements. It's alias name to\n-    \/\/ real name mappings.\n-    private Map<String,String> aliases;\n-\n-    private List<Integer> rawOffsetsIndex;\n-\n-    private List<Set<String>> rawOffsetsIndexTable;\n-\n-    \/\/ Zone names to be excluded from rawOffset table. Those have GMT\n-    \/\/ offsets to change some future time.\n-    private List<String> excludeList;\n-\n-    \/**\n-     * Constructor creates some necessary instances.\n-     *\/\n-    Mappings() {\n-        aliases = new TreeMap<String,String>();\n-        rawOffsetsIndex = new LinkedList<Integer>();\n-        rawOffsetsIndexTable = new LinkedList<Set<String>>();\n-    }\n-\n-    \/**\n-     * Generates aliases and rawOffsets tables.\n-     * @param zi a Zoneinfo containing Zones\n-     *\/\n-    void add(Zoneinfo zi) {\n-        Map<String,Zone> zones = zi.getZones();\n-\n-        for (String zoneName : zones.keySet()) {\n-            Zone zone = zones.get(zoneName);\n-            String zonename = zone.getName();\n-            int rawOffset = zone.get(zone.size()-1).getGmtOffset();\n-\n-            \/\/ If the GMT offset of this Zone will change in some\n-            \/\/ future time, this Zone is added to the exclude list.\n-            boolean isExcluded = false;\n-            for (int i = 0; i < zone.size(); i++) {\n-                ZoneRec zrec = zone.get(i);\n-                if ((zrec.getGmtOffset() != rawOffset)\n-                    && (zrec.getUntilTime(0) > Time.getCurrentTime())) {\n-                    if (excludeList == null) {\n-                        excludeList = new ArrayList<String>();\n-                    }\n-                    excludeList.add(zone.getName());\n-                    isExcluded = true;\n-                    break;\n-                }\n-            }\n-\n-            if (!rawOffsetsIndex.contains(new Integer(rawOffset))) {\n-                \/\/ Find the index to insert this raw offset zones\n-                int n = rawOffsetsIndex.size();\n-                int i;\n-                for (i = 0; i < n; i++) {\n-                    if (rawOffsetsIndex.get(i) > rawOffset) {\n-                        break;\n-                    }\n-                }\n-                rawOffsetsIndex.add(i, rawOffset);\n-\n-                Set<String> perRawOffset = new TreeSet<String>();\n-                if (!isExcluded) {\n-                    perRawOffset.add(zonename);\n-                }\n-                rawOffsetsIndexTable.add(i, perRawOffset);\n-            } else if (!isExcluded) {\n-                int i = rawOffsetsIndex.indexOf(new Integer(rawOffset));\n-                Set<String> perRawOffset = rawOffsetsIndexTable.get(i);\n-                perRawOffset.add(zonename);\n-            }\n-        }\n-\n-        Map<String,String> a = zi.getAliases();\n-        \/\/ If there are time zone names which refer to any of the\n-        \/\/ excluded zones, add those names to the excluded list.\n-        if (excludeList != null) {\n-            for (String zoneName : a.keySet()) {\n-                String realname = a.get(zoneName);\n-                if (excludeList.contains(realname)) {\n-                    excludeList.add(zoneName);\n-                }\n-            }\n-        }\n-        aliases.putAll(a);\n-    }\n-\n-    \/**\n-     * Adds valid aliases to one of per-RawOffset table and removes\n-     * invalid aliases from aliases List. Aliases referring to\n-     * excluded zones are not added to a per-RawOffset table.\n-     *\/\n-    void resolve() {\n-        int index = rawOffsetsIndexTable.size();\n-        List<String> toBeRemoved = new ArrayList<String>();\n-        for (String key : aliases.keySet()) {\n-            boolean validname = false;\n-            for (int j = 0; j < index; j++) {\n-                Set<String> perRO = rawOffsetsIndexTable.get(j);\n-                boolean isExcluded = (excludeList == null) ?\n-                                        false : excludeList.contains(key);\n-\n-                if ((perRO.contains(aliases.get(key)) || isExcluded)\n-                    && Zone.isTargetZone(key)) {\n-                    validname = true;\n-                    if (!isExcluded) {\n-                        perRO.add(key);\n-                        Main.info(\"Alias <\"+key+\"> added to the list.\");\n-                    }\n-                    break;\n-                }\n-            }\n-\n-            if (!validname) {\n-                Main.info(\"Alias <\"+key+\"> removed from the list.\");\n-                toBeRemoved.add(key);\n-            }\n-        }\n-\n-        \/\/ Remove zones, if any, from the list.\n-        for (String key : toBeRemoved) {\n-            aliases.remove(key);\n-        }\n-        \/\/ Eliminate any alias-to-alias mappings. For example, if\n-        \/\/ there are A->B and B->C, A->B is changed to A->C.\n-        Map<String, String> newMap = new HashMap<String, String>();\n-        for (String key : aliases.keySet()) {\n-            String realid = aliases.get(key);\n-            String leaf = realid;\n-            while (aliases.get(leaf) != null) {\n-                leaf = aliases.get(leaf);\n-            }\n-            if (!realid.equals(leaf)) {\n-                newMap.put(key, leaf);\n-            }\n-        }\n-        aliases.putAll(newMap);\n-    }\n-\n-    Map<String,String> getAliases() {\n-        return(aliases);\n-    }\n-\n-    List<Integer> getRawOffsetsIndex() {\n-        return(rawOffsetsIndex);\n-    }\n-\n-    List<Set<String>> getRawOffsetsIndexTable() {\n-        return(rawOffsetsIndexTable);\n-    }\n-\n-    List<String> getExcludeList() {\n-        return excludeList;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Mappings.java","additions":0,"deletions":193,"binary":false,"changes":193,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Month enum handles month related manipulation.\n- *\n- * @since 1.4\n- *\/\n-enum Month {\n-    JANUARY(\"Jan\"),\n-    FEBRUARY(\"Feb\"),\n-    MARCH(\"Mar\"),\n-    APRIL(\"Apr\"),\n-    MAY(\"May\"),\n-    JUNE(\"Jun\"),\n-    JULY(\"Jul\"),\n-    AUGUST(\"Aug\"),\n-    SEPTEMBER(\"Sep\"),\n-    OCTOBER(\"Oct\"),\n-    NOVEMBER(\"Nov\"),\n-    DECEMBER(\"Dec\");\n-\n-    private final String abbr;\n-\n-    private Month(String abbr) {\n-        this.abbr = abbr;\n-    }\n-\n-    int value() {\n-        return ordinal() + 1;\n-    }\n-\n-    \/**\n-     * Parses the specified string as a month abbreviation.\n-     * @param name the month abbreviation\n-     * @return the Month value\n-     *\/\n-    static Month parse(String name) {\n-        int len = name.length();\n-\n-        if (name.regionMatches(true, 0, \"January\", 0, len)) return Month.JANUARY;\n-        if (name.regionMatches(true, 0, \"February\", 0, len)) return Month.FEBRUARY;\n-        if (name.regionMatches(true, 0, \"March\", 0, len)) return Month.MARCH;\n-        if (name.regionMatches(true, 0, \"April\", 0, len)) return Month.APRIL;\n-        if (name.regionMatches(true, 0, \"May\", 0, len)) return Month.MAY;\n-        if (name.regionMatches(true, 0, \"June\", 0, len)) return Month.JUNE;\n-        if (name.regionMatches(true, 0, \"July\", 0, len)) return Month.JULY;\n-        if (name.regionMatches(true, 0, \"August\", 0, len)) return Month.AUGUST;\n-        if (name.regionMatches(true, 0, \"September\", 0, len)) return Month.SEPTEMBER;\n-        if (name.regionMatches(true, 0, \"October\", 0, len)) return Month.OCTOBER;\n-        if (name.regionMatches(true, 0, \"November\", 0, len)) return Month.NOVEMBER;\n-        if (name.regionMatches(true, 0, \"December\", 0, len)) return Month.DECEMBER;\n-\n-        throw new IllegalArgumentException(\"Unknown month: \" + name);\n-    }\n-\n-    \/**\n-     * @param month the nunmth number (1-based)\n-     * @return the month name in uppercase of the specified month\n-     *\/\n-    static String toString(int month) {\n-        if (month >= JANUARY.value() && month <= DECEMBER.value()) {\n-            return \"Calendar.\" + Month.values()[month - 1];\n-        }\n-        throw new IllegalArgumentException(\"wrong month number: \" + month);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Month.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Comparator;\n-import java.util.List;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Rule manipulates Rule records.\n- *\n- * @since 1.4\n- *\/\n-class Rule {\n-\n-    private List<RuleRec> list;\n-    private String name;\n-\n-    \/**\n-     * Constructs a Rule which consists of a Rule record list. The\n-     * specified name is given to this Rule.\n-     * @param name the Rule name\n-     *\/\n-    Rule(String name) {\n-        this.name = name;\n-        list = new ArrayList<RuleRec>();\n-    }\n-\n-    \/**\n-     * Added a RuleRec to the Rule record list.\n-     *\/\n-    void add(RuleRec rec) {\n-        list.add(rec);\n-    }\n-\n-    \/**\n-     * @return the Rule name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Gets all rule records that cover the given year.\n-     *\n-     * @param year the year number for which the rule is applicable.\n-     * @return rules in List that are collated in time. If no rule is found, an empty\n-     * List is returned.\n-     *\/\n-    List<RuleRec> getRules(int year) {\n-        List<RuleRec> rules = new ArrayList<RuleRec>(3);\n-        for (RuleRec rec : list) {\n-            if (year >= rec.getFromYear() && year <= rec.getToYear()) {\n-                if ((rec.isOdd() && year % 2 == 0) || (rec.isEven() && year % 2 == 1))\n-                    continue;\n-                rules.add(rec);\n-            }\n-        }\n-        int n = rules.size();\n-        if (n <= 1) {\n-            return rules;\n-        }\n-        if (n == 2) {\n-            RuleRec rec1 = rules.get(0);\n-            RuleRec rec2 = rules.get(1);\n-            if (rec1.getMonthNum() > rec2.getMonthNum()) {\n-                rules.set(0, rec2);\n-                rules.set(1, rec1);\n-            } else if (rec1.getMonthNum() == rec2.getMonthNum()) {\n-                \/\/ TODO: it's not accurate to ignore time types (STD, WALL, UTC)\n-                long t1 = Time.getLocalTime(year, rec1.getMonth(),\n-                                            rec1.getDay(), rec1.getTime().getTime());\n-                long t2 = Time.getLocalTime(year, rec2.getMonth(),\n-                                            rec2.getDay(), rec2.getTime().getTime());\n-                if (t1 > t2) {\n-                    rules.set(0, rec2);\n-                    rules.set(1, rec1);\n-                }\n-            }\n-            return rules;\n-        }\n-\n-        final int y = year;\n-        RuleRec[] recs = new RuleRec[rules.size()];\n-        rules.toArray(recs);\n-\n-        Arrays.sort(recs, new Comparator<RuleRec>() {\n-                public int compare(RuleRec r1, RuleRec r2) {\n-                    int n = r1.getMonthNum() - r2.getMonthNum();\n-                    if (n != 0) {\n-                        return n;\n-                    }\n-                    \/\/ TODO: it's not accurate to ignore time types (STD, WALL, UTC)\n-                    long t1 = Time.getLocalTime(y, r1.getMonth(),\n-                                                r1.getDay(), r1.getTime().getTime());\n-                    long t2 = Time.getLocalTime(y, r2.getMonth(),\n-                                                r2.getDay(), r2.getTime().getTime());\n-                    return Long.compare(t1, t2);\n-                }\n-                public boolean equals(Object o) {\n-                    return this == o;\n-                }\n-            });\n-        rules.clear();\n-        for (int i = 0; i < n; i++) {\n-            if (i != 0 && recs[i -1].getSave() == recs[i].getSave()) {\n-                \/\/ we have two recs back to back with same saving for the same year.\n-                if (recs[i].isLastRule()) {\n-                    continue;\n-                } else if (recs[i - 1].isLastRule()) {\n-                    rules.remove(rules.size() - 1);\n-                }\n-            }\n-            rules.add(recs[i]);\n-        }\n-        return rules;\n-    }\n-\n-    \/**\n-     * Gets rule records that have either \"max\" or cover the endYear\n-     * value in its DST schedule.\n-     *\n-     * @return rules that contain last DST schedule. An empty\n-     * ArrayList is returned if no last rules are found.\n-     *\/\n-    List<RuleRec> getLastRules() {\n-        RuleRec start = null;\n-        RuleRec end = null;\n-\n-        for (int i = 0; i < list.size(); i++) {\n-            RuleRec rec = list.get(i);\n-            if (rec.isLastRule()) {\n-                if (rec.getSave() > 0) {\n-                    start = rec;\n-                } else {\n-                    end = rec;\n-                }\n-            }\n-        }\n-        if (start == null || end == null) {\n-            int endYear = Zoneinfo.getEndYear();\n-            for (int i  = 0; i < list.size(); i++) {\n-                RuleRec rec = list.get(i);\n-                if (endYear >= rec.getFromYear() && endYear <= rec.getToYear()) {\n-                    if (start == null && rec.getSave() > 0) {\n-                        start = rec;\n-                    } else {\n-                        if (end == null && rec.getSave() == 0) {\n-                            end = rec;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        List<RuleRec> r = new ArrayList<RuleRec>(2);\n-        if (start == null || end == null) {\n-            if (start != null || end != null) {\n-                Main.warning(\"found last rules for \"+name+\" inconsistent.\");\n-            }\n-            return r;\n-        }\n-\n-        r.add(start);\n-        r.add(end);\n-        return r;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Rule.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * RuleDay class represents the value of the \"ON\" field.  The day of\n- * week values start from 1 following the {@link java.util.Calendar}\n- * convention.\n- *\n- * @since 1.4\n- *\/\n-class RuleDay {\n-    private String dayName = null;\n-    private DayOfWeek dow;\n-    private boolean lastOne = false;\n-    private int soonerOrLater = 0;\n-    private int thanDayOfMonth; \/\/ day of month (e.g., 8 for \"Sun>=8\")\n-\n-    RuleDay() {\n-    }\n-\n-    RuleDay(int day) {\n-        thanDayOfMonth = day;\n-    }\n-\n-    int getDay() {\n-        return thanDayOfMonth;\n-    }\n-\n-    \/**\n-     * @return the day of week value (1-based)\n-     *\/\n-    int getDayOfWeekNum() {\n-        return dow.value();\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the last day of\n-     * week. (e.g., lastSun).\n-     *\/\n-    boolean isLast() {\n-        return lastOne;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the day of week on or\n-     * later than (after) the {@link #getDay}. (e.g., Sun>=1)\n-     *\/\n-    boolean isLater() {\n-        return soonerOrLater > 0;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents the day of week on or\n-     * earlier than (before) the {@link #getDay}. (e.g., Sun<=15)\n-     *\/\n-    boolean isEarlier() {\n-        return soonerOrLater < 0;\n-    }\n-\n-    \/**\n-     * @return true if this rule day represents an exact day.\n-     *\/\n-    boolean isExact() {\n-        return soonerOrLater == 0;\n-    }\n-\n-    \/**\n-     * Parses the \"ON\" field and constructs a RuleDay.\n-     * @param day an \"ON\" field string (e.g., \"Sun>=1\")\n-     * @return a RuleDay representing the given \"ON\" field\n-     *\/\n-    static RuleDay parse(String day) {\n-        RuleDay d = new RuleDay();\n-        if (day.startsWith(\"last\")) {\n-            d.lastOne = true;\n-            d.dayName = day.substring(4);\n-            d.dow = getDOW(d.dayName);\n-        } else {\n-            int index;\n-            if ((index = day.indexOf(\">=\")) != -1) {\n-                d.dayName = day.substring(0, index);\n-                d.dow = getDOW(d.dayName);\n-                d.soonerOrLater = 1; \/\/ greater or equal\n-                d.thanDayOfMonth = Integer.parseInt(day.substring(index+2));\n-            } else if ((index = day.indexOf(\"<=\")) != -1) {\n-                d.dayName = day.substring(0, index);\n-                d.dow = getDOW(d.dayName);\n-                d.soonerOrLater = -1; \/\/ less or equal\n-                d.thanDayOfMonth = Integer.parseInt(day.substring(index+2));\n-            } else {\n-                \/\/ it should be an integer value.\n-                d.thanDayOfMonth = Integer.parseInt(day);\n-            }\n-        }\n-        return d;\n-    }\n-\n-    \/**\n-     * Converts this RuleDay to the SimpleTimeZone day rule.\n-     * @return the converted SimpleTimeZone day rule\n-     *\/\n-    int getDayForSimpleTimeZone() {\n-        if (isLast()) {\n-            return -1;\n-        }\n-        return isEarlier() ? -getDay() : getDay();\n-    }\n-\n-    \/**\n-     * Converts this RuleDay to the SimpleTimeZone day-of-week rule.\n-     * @return the SimpleTimeZone day-of-week rule value\n-     *\/\n-    int getDayOfWeekForSimpleTimeZoneInt() {\n-        if (isEarlier() || isLater()) {\n-            return -getDayOfWeekNum();\n-        }\n-        return isLast() ? getDayOfWeekNum() : 0;\n-    }\n-\n-    \/**\n-     * @return the string representation of the {@link\n-     * #getDayOfWeekForSimpleTimeZoneInt} value\n-     *\/\n-    String getDayOfWeekForSimpleTimeZone() {\n-        int d = getDayOfWeekForSimpleTimeZoneInt();\n-        if (d == 0) {\n-            return \"0\";\n-        }\n-        String sign = \"\";\n-        if (d < 0) {\n-            sign = \"-\";\n-            d = -d;\n-        }\n-        return sign + toString(d);\n-    }\n-\n-    private static DayOfWeek getDOW(String name) {\n-        int len = name.length();\n-\n-        if (name.regionMatches(true, 0, \"Monday\", 0, len)) return DayOfWeek.MONDAY;\n-        if (name.regionMatches(true, 0, \"Tuesday\", 0, len)) return DayOfWeek.TUESDAY;\n-        if (name.regionMatches(true, 0, \"Wednesday\", 0, len)) return DayOfWeek.WEDNESDAY;\n-        if (name.regionMatches(true, 0, \"Thursday\", 0, len)) return DayOfWeek.THURSDAY;\n-        if (name.regionMatches(true, 0, \"Friday\", 0, len)) return DayOfWeek.FRIDAY;\n-        if (name.regionMatches(true, 0, \"Saturday\", 0, len)) return DayOfWeek.SATURDAY;\n-        if (name.regionMatches(true, 0, \"Sunday\", 0, len)) return DayOfWeek.SUNDAY;\n-\n-        throw new IllegalArgumentException(\"Unknown day-of-week: \" + name);\n-    }\n-\n-    \/**\n-     * Converts the specified day of week value to the day-of-week\n-     * name defined in {@link java.util.Calendar}.\n-     * @param dow 1-based day of week value\n-     * @return the Calendar day of week name with \"Calendar.\" prefix.\n-     * @throws IllegalArgumentException if the specified dow value is out of range.\n-     *\/\n-    static String toString(int dow) {\n-        if (dow >= DayOfWeek.SUNDAY.value() && dow <= DayOfWeek.SATURDAY.value()) {\n-            return \"Calendar.\" + DayOfWeek.values()[dow - 1];\n-        }\n-        throw new IllegalArgumentException(\"wrong Day_of_Week number: \" + dow);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleDay.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.StringTokenizer;\n-\n-\/**\n- * RuleRec class represents one record of the Rule set.\n- *\n- * @since 1.4\n- *\/\n-class RuleRec {\n-    private int fromYear;\n-    private int toYear;\n-    private String type;\n-    private Month inMonth;\n-    private RuleDay onDay;\n-    private Time atTime;\n-    private int save;\n-    private String letters;\n-    private String line;\n-    private boolean isLastRule;\n-\n-    int getFromYear() {\n-        return fromYear;\n-    }\n-\n-    int getToYear() {\n-        return toYear;\n-    }\n-\n-    Month getMonth() {\n-        return inMonth;\n-    }\n-\n-    int getMonthNum() {\n-        return inMonth.value();\n-    }\n-\n-    RuleDay getDay() {\n-        return onDay;\n-    }\n-\n-    Time getTime() {\n-        return atTime;\n-    }\n-\n-    int getSave() {\n-        return save;\n-    }\n-\n-    String getLine() {\n-        return line;\n-    }\n-\n-    \/**\n-     * Sets the line from the text file.\n-     * @param line the text of the line\n-     *\/\n-    void setLine(String line) {\n-        this.line = line;\n-    }\n-\n-    \/**\n-     * @return true if the rule type is \"odd\".\n-     *\/\n-    boolean isOdd() {\n-        return \"odd\".equals(type);\n-    }\n-\n-    \/**\n-     * @return true if the rule type is \"even\".\n-     *\/\n-    boolean isEven() {\n-        return \"even\".equals(type);\n-    }\n-\n-    \/**\n-     * Determines if this rule record is the last DST schedule rule.\n-     *\n-     * @return true if this rule record has \"max\" as TO (year).\n-     *\/\n-    boolean isLastRule() {\n-        return isLastRule;\n-    }\n-\n-    \/**\n-     * Determines if the unadjusted until time of the specified ZoneRec\n-     * is the same as the transition time of this rule in the same\n-     * year as the ZoneRec until year.\n-     *\n-     * @param zrec ZoneRec to compare to\n-     * @param save the amount of daylight saving in milliseconds\n-     * @param gmtOffset the GMT offset value in milliseconds\n-     * @return true if the unadjusted until time is the same as rule's\n-     * transition time.\n-     *\/\n-    boolean isSameTransition(ZoneRec zrec, int save, int gmtOffset) {\n-        long    until, transition;\n-\n-        if (zrec.getUntilTime().getType() != atTime.getType()) {\n-            until = zrec.getLocalUntilTime(save, gmtOffset);\n-            transition = Time.getLocalTime(zrec.getUntilYear(),\n-                                           getMonth(),\n-                                           getDay(),\n-                                           save,\n-                                           gmtOffset,\n-                                           atTime);\n-        } else {\n-            until = zrec.getLocalUntilTime();\n-            transition = Time.getLocalTime(zrec.getUntilYear(),\n-                                           getMonth(),\n-                                           getDay(),\n-                                           atTime.getTime());\n-        }\n-\n-        return until == transition;\n-    }\n-\n-    \/**\n-     * Parses a Rule line and returns a RuleRec object.\n-     *\n-     * @param tokens a StringTokenizer object that should contain a\n-     * token for the \"FROM\" field and the rest.\n-     * @return a RuleRec object.\n-     *\/\n-    static RuleRec parse(StringTokenizer tokens) {\n-        RuleRec rec = new RuleRec();\n-        try {\n-            \/\/ FROM\n-            String token = tokens.nextToken();\n-            try {\n-                rec.fromYear = Integer.parseInt(token);\n-            } catch (NumberFormatException e) {\n-                \/\/ it's not integer\n-                if (\"min\".equals(token) || \"minimum\".equals(token)) {\n-                    rec.fromYear = Zoneinfo.getMinYear();\n-                } else if (\"max\".equals(token) || \"maximum\".equals(token)) {\n-                    rec.fromYear = Zoneinfo.getMaxYear();\n-                } else {\n-                    Main.panic(\"invalid year value: \"+token);\n-                }\n-            }\n-\n-            \/\/ TO\n-            token = tokens.nextToken();\n-            rec.isLastRule = false;\n-            try {\n-                rec.toYear = Integer.parseInt(token);\n-            } catch (NumberFormatException e) {\n-                \/\/ it's not integer\n-                int len = token.length();\n-                if (token.regionMatches(true, 0, \"minimum\", 0, len)) {\n-                    rec.fromYear = Zoneinfo.getMinYear();\n-                } else if (token.regionMatches(true, 0, \"maximum\", 0, len)) {\n-                    rec.toYear = Integer.MAX_VALUE;\n-                    rec.isLastRule = true;\n-                } else if (token.regionMatches(true, 0, \"only\", 0, len)) {\n-                    rec.toYear = rec.fromYear;\n-                } else {\n-                    Main.panic(\"invalid year value: \"+token);\n-                }\n-            }\n-\n-            \/\/ TYPE\n-            rec.type = tokens.nextToken();\n-\n-            \/\/ IN\n-            rec.inMonth = Month.parse(tokens.nextToken());\n-\n-            \/\/ ON\n-            rec.onDay = RuleDay.parse(tokens.nextToken());\n-\n-            \/\/ AT\n-            rec.atTime = Time.parse(tokens.nextToken());\n-\n-            \/\/ SAVE\n-            rec.save = (int) Time.parse(tokens.nextToken()).getTime();\n-\n-            \/\/ LETTER\/S\n-            rec.letters = tokens.nextToken();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-        return rec;\n-    }\n-\n-    \/**\n-     * Calculates the transition time of the given year under this rule.\n-     * @param year the year value\n-     * @param gmtOffset the GMT offset value in milliseconds\n-     * @param save the amount of daylight save time\n-     * @return the transition time in milliseconds of the given year in UTC.\n-     *\/\n-    long getTransitionTime(int year, int gmtOffset, int save) {\n-        long time = Time.getLocalTime(year, getMonth(),\n-                                      getDay(), atTime.getTime());\n-        if (atTime.isSTD()) {\n-            time -= gmtOffset;\n-        } else if (atTime.isWall()) {\n-            time -= gmtOffset + save;\n-        }\n-        return time;\n-    }\n-\n-    private static int getInt(StringTokenizer tokens) {\n-        String token = tokens.nextToken();\n-        return Integer.parseInt(token);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/RuleRec.java","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import  java.io.BufferedWriter;\n-import  java.io.File;\n-import  java.io.FileWriter;\n-import  java.io.IOException;\n-import  java.util.HashMap;\n-import  java.util.List;\n-import  java.util.Map;\n-import  java.util.Set;\n-import  java.util.SortedMap;\n-import  java.util.TreeMap;\n-import  java.util.TreeSet;\n-\n-\/**\n- * <code>Simple<\/code> generates TimeZoneData, which had been used as internal\n- * data of TimeZone before J2SDK1.3.\n- * Since J2SDK1.4 doesn't need TimeZoneData, this class is for maintenance\n- * of old JDK release.\n- *\/\n-class Simple extends BackEnd {\n-\n-    \/**\n-     * Zone records which are applied for given year.\n-     *\/\n-    private static Map<String,ZoneRec> lastZoneRecs = new HashMap<>();\n-\n-    \/**\n-     * Rule records which are applied for given year.\n-     *\/\n-    private static Map<String,List<RuleRec>> lastRules = new TreeMap<>();\n-\n-    \/**\n-     * zone IDs sorted by their GMT offsets. If zone's GMT\n-     * offset will change in the future, its last known offset is\n-     * used.\n-     *\/\n-    private SortedMap<Integer, Set<String>> zonesByOffset = new TreeMap<>();\n-\n-    \/**\n-     * Sets last Rule records and Zone records for given timezone to\n-     * each Map.\n-     *\n-     * @param tz Timezone object for each zone\n-     * @return always 0\n-     *\/\n-    int processZoneinfo(Timezone tz) {\n-        String zonename = tz.getName();\n-\n-        lastRules.put(zonename, tz.getLastRules());\n-        lastZoneRecs.put(zonename, tz.getLastZoneRec());\n-\n-        \/\/ Populate zonesByOffset. (Zones that will change their\n-        \/\/ GMT offsets are also added to zonesByOffset here.)\n-        int lastKnownOffset = tz.getRawOffset();\n-        Set<String> set = zonesByOffset.get(lastKnownOffset);\n-        if (set == null) {\n-            set = new TreeSet<>();\n-            zonesByOffset.put(lastKnownOffset, set);\n-        }\n-        set.add(zonename);\n-\n-        return 0;\n-    }\n-\n-    \/**\n-     * Generates TimeZoneData to output SimpleTimeZone data.\n-     * @param map Mappings object which is generated by {@link Main#compile}.\n-     * @return 0 if no error occurred, otherwise 1.\n-     *\/\n-    int generateSrc(Mappings map) {\n-        try {\n-            File outD = new File(Main.getOutputDir());\n-            outD.mkdirs();\n-\n-            FileWriter fw =\n-                new FileWriter(new File(outD, \"TimeZoneData.java\"), false);\n-            BufferedWriter out = new BufferedWriter(fw);\n-\n-            out.write(\"import java.util.SimpleTimeZone;\\n\\n\");\n-            out.write(\"    static SimpleTimeZone zones[] = {\\n\");\n-\n-            Map<String,String> a = map.getAliases();\n-            List<Integer> roi = map.getRawOffsetsIndex();\n-            List<Set<String>> roit = map.getRawOffsetsIndexTable();\n-\n-            int index = 0;\n-            for (int offset : zonesByOffset.keySet()) {\n-                int o = roi.get(index);\n-                Set<String> set = zonesByOffset.get(offset);\n-                if (offset == o) {\n-                    \/\/ Merge aliases into zonesByOffset\n-                    set.addAll(roit.get(index));\n-                }\n-                index++;\n-\n-                for (String key : set) {\n-                    ZoneRec zrec;\n-                    String realname;\n-                    List<RuleRec> stz;\n-                    if ((realname = a.get(key)) != null) {\n-                        \/\/ if this alias is not targeted, ignore it.\n-                        if (!Zone.isTargetZone(key)) {\n-                            continue;\n-                        }\n-                        stz = lastRules.get(realname);\n-                        zrec = lastZoneRecs.get(realname);\n-                    } else {\n-                        stz = lastRules.get(key);\n-                        zrec = lastZoneRecs.get(key);\n-                    }\n-\n-                    out.write(\"\\t\/\/--------------------------------------------------------------------\\n\");\n-                    String s = Time.toFormedString(offset);\n-                    out.write(\"\\tnew SimpleTimeZone(\" +\n-                        Time.toFormedString(offset) + \", \\\"\" + key + \"\\\"\");\n-                    if (realname != null) {\n-                        out.write(\" \/* \" + realname + \" *\/\");\n-                    }\n-\n-                    if (stz == null) {\n-                        out.write(\"),\\n\");\n-                    } else {\n-                        RuleRec rr0 = stz.get(0);\n-                        RuleRec rr1 = stz.get(1);\n-\n-                        out.write(\",\\n\\t  \" + Month.toString(rr0.getMonthNum()) +\n-                                  \", \" + rr0.getDay().getDayForSimpleTimeZone() + \", \" +\n-                                  rr0.getDay().getDayOfWeekForSimpleTimeZone() + \", \" +\n-                                  Time.toFormedString((int)rr0.getTime().getTime()) + \", \" +\n-                                  rr0.getTime().getTypeForSimpleTimeZone() + \",\\n\" +\n-\n-                                  \"\\t  \" + Month.toString(rr1.getMonthNum()) + \", \" +\n-                                  rr1.getDay().getDayForSimpleTimeZone() + \", \" +\n-                                  rr1.getDay().getDayOfWeekForSimpleTimeZone() + \", \" +\n-                                  Time.toFormedString((int)rr1.getTime().getTime())+ \", \" +\n-                                  rr1.getTime().getTypeForSimpleTimeZone() + \",\\n\" +\n-\n-                                  \"\\t  \" + Time.toFormedString(rr0.getSave()) + \"),\\n\");\n-\n-                        out.write(\"\\t\/\/ \" + rr0.getLine() + \"\\n\");\n-                        out.write(\"\\t\/\/ \" + rr1.getLine() + \"\\n\");\n-                    }\n-\n-                    String zline = zrec.getLine();\n-                    if (zline.indexOf(\"Zone\") == -1) {\n-                        zline = \"Zone \" + key + \"\\t\" + zline.trim();\n-                    }\n-                    out.write(\"\\t\/\/ \" + zline + \"\\n\");\n-                }\n-            }\n-            out.write(\"    };\\n\");\n-\n-            out.close();\n-            fw.close();\n-        } catch(IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-            return 1;\n-        }\n-\n-        return 0;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Simple.java","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,283 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8007572 8008161 8157792 8212970 8224560 8324065\n- * @summary Test whether the TimeZone generated from JSR310 tzdb is the same\n- * as the one from the tz data from javazic\n- * @modules java.base\/sun.util.calendar:+open\n- * @build BackEnd Checksum DayOfWeek Gen GenDoc Main Mappings Month\n- *        Rule RuleDay RuleRec Simple TestZoneInfo310 Time Timezone\n- *        TzIDOldMapping Zone ZoneInfoFile ZoneInfoOld ZoneRec Zoneinfo\n- * @run main TestZoneInfo310\n- *\/\n-\n-import java.io.File;\n-import java.lang.reflect.*;\n-import java.nio.file.*;\n-import java.util.*;\n-import java.util.regex.*;\n-import java.time.zone.*;\n-import java.time.ZoneId;\n-\n-public class TestZoneInfo310 {\n-\n-    public static void main(String[] args) throws Throwable {\n-\n-        String TESTDIR = System.getProperty(\"test.dir\", \".\");\n-        Path tzdir = Paths.get(System.getProperty(\"test.root\"),\n-            \"..\/..\/src\/java.base\/share\/data\/tzdata\");\n-        String tzfiles = \"africa antarctica asia australasia europe northamerica southamerica backward etcetera gmt\";\n-        Path jdk_tzdir = Paths.get(System.getProperty(\"test.src\"), \"tzdata_jdk\");\n-        String jdk_tzfiles = \"jdk11_backward\";\n-        String zidir = TESTDIR + File.separator + \"zi\";\n-        File fZidir = new File(zidir);\n-        if (!fZidir.exists()) {\n-            fZidir.mkdirs();\n-        }\n-        Matcher m = Pattern.compile(\"tzdata(?<ver>[0-9]{4}[A-z])\")\n-                           .matcher(new String(Files.readAllBytes(tzdir.resolve(\"VERSION\")), \"ascii\"));\n-        String ver = m.find() ? m.group(\"ver\") : \"NULL\";\n-\n-        ArrayList<String> alist = new ArrayList<>();\n-        alist.add(\"-V\");\n-        alist.add(ver);\n-        alist.add(\"-d\");\n-        alist.add(zidir);\n-        for (String f : tzfiles.split(\" \")) {\n-            alist.add(tzdir.resolve(f).toString());\n-        }\n-        for (String f : jdk_tzfiles.split(\" \")) {\n-            alist.add(jdk_tzdir.resolve(f).toString());\n-        }\n-        System.out.println(\"Compiling tz files!\");\n-        Main.main(alist.toArray(new String[alist.size()]));\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        System.out.println(\"testing!\");\n-        ZoneInfoFile.ziDir = zidir;\n-        long t0, t1;\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/Los_Angeles\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[1]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/New_York\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[2]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        ZoneInfoOld.getTimeZone(\"America\/Denver\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getZoneInfoOld()[3]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        String[] zids_old = ZoneInfoOld.getAvailableIDs();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getAvailableIDs()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, zids_old.length);\n-        Arrays.sort(zids_old);\n-\n-        t0 = System.nanoTime();\n-        String[] alias_old = ZoneInfoOld.getAliasTable()\n-                                 .keySet().toArray(new String[0]);\n-        t1 = System.nanoTime();\n-        System.out.printf(\"OLD.getAliasTable()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, alias_old.length);\n-        Arrays.sort(alias_old);\n-\n-        t0 = System.currentTimeMillis();\n-        for (String zid : zids_old) {\n-            ZoneInfoOld.getTimeZone(zid);\n-        }\n-        t1 = System.currentTimeMillis();\n-        System.out.printf(\"OLD.TotalTZ()=%d (ms)%n\", t1 - t0);\n-\n-\/*\n-        t0 = System.nanoTime();\n-        ZoneId.of(\"America\/Los_Angeles\").getRules();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.ZoneId.of()[1]=%d%n\", (t1 - t0) \/ 1000);\n-*\/\n-        t0 = System.nanoTime();\n-        TimeZone tz = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[1]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        tz = TimeZone.getTimeZone(\"America\/New_York\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[2]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        tz = TimeZone.getTimeZone(\"America\/Denver\");\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getTimeZone()[3]=%d%n\", (t1 - t0) \/ 1000);\n-\n-        t0 = System.nanoTime();\n-        String[] zids_new = TimeZone.getAvailableIDs();\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getAvailableIDs()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, zids_new.length);\n-        Arrays.sort(zids_new);\n-\n-        t0 = System.nanoTime();\n-        String[] alias_new = sun.util.calendar.ZoneInfo.getAliasTable()\n-                                 .keySet().toArray(new String[0]);\n-        t1 = System.nanoTime();\n-        System.out.printf(\"NEW.getAliasTable()=%d, total=%d%n\",\n-                          (t1 - t0) \/ 1000, alias_new.length);\n-        Arrays.sort(alias_new);\n-\n-        t0 = System.currentTimeMillis();\n-        for (String zid : zids_new) {\n-            TimeZone.getTimeZone(zid);\n-        }\n-        t1 = System.currentTimeMillis();\n-        System.out.printf(\"NEW.TotalTZ()=%d (ms)%n\", t1 - t0);\n-\n-        if (!Arrays.equals(zids_old, zids_new)) {\n-            throw new RuntimeException(\"  FAILED:  availableIds don't match\");\n-        }\n-\n-        if (!Arrays.equals(alias_old, alias_new)) {\n-            throw new RuntimeException(\"  FAILED:  aliases don't match\");\n-        }\n-\n-        for (String zid : zids_new) {\n-            ZoneInfoOld zi = toZoneInfoOld(TimeZone.getTimeZone(zid));\n-            ZoneInfoOld ziOLD = (ZoneInfoOld)ZoneInfoOld.getTimeZone(zid);\n-            \/*\n-             * Ignoring the failing TimeZones which have negative DST\n-             * save time in IANA tzdata, as javazic\/ZoneInfoOld cannot\n-             * handle the negative DST.\n-             *\n-             * These are the zones\/rules that employ negative DST in vanguard\n-             * format (as of 2019a), Palestine added in 2022d:\n-             *\n-             *  - Rule \"Eire\"\n-             *  - Rule \"Morocco\"\n-             *  - Rule \"Namibia\"\n-             *  - Rule \"Palestine\"\n-             *  - Zone \"Europe\/Prague\"\n-             *\/\n-            if (zid.equals(\"Africa\/Casablanca\") || \/\/ uses \"Morocco\" rule\n-                zid.equals(\"Africa\/El_Aaiun\") || \/\/ uses \"Morocco\" rule\n-                zid.equals(\"Africa\/Windhoek\") || \/\/ uses \"Namibia\" rule\n-                zid.equals(\"Eire\") ||\n-                zid.equals(\"Europe\/Bratislava\") || \/\/ link to \"Europe\/Prague\"\n-                zid.equals(\"Europe\/Dublin\") || \/\/ uses \"Eire\" rule\n-                zid.equals(\"Europe\/Prague\") ||\n-                zid.equals(\"Asia\/Gaza\") || \/\/ uses \"Palestine\" rule\n-                zid.equals(\"Asia\/Hebron\")) { \/\/ uses \"Palestine\" rule\n-                    continue;\n-            }\n-            if (! zi.equalsTo(ziOLD)) {\n-                System.out.println(zi.diffsTo(ziOLD));\n-                throw new RuntimeException(\"  FAILED:  \" + zid);\n-            }\n-        }\n-        delete(fZidir);\n-\n-        \/\/ test tzdb version\n-        if (!ver.equals(sun.util.calendar.ZoneInfoFile.getVersion())) {\n-            System.out.printf(\"  FAILED:  ver=%s, expected=%s%n\",\n-                              sun.util.calendar.ZoneInfoFile.getVersion(), ver);\n-            throw new RuntimeException(\"Version test failed\");\n-        }\n-\n-        \/\/ test getAvailableIDs(raw);\n-        zids_new = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);\n-        Arrays.sort(zids_new);\n-        zids_old = ZoneInfoOld.getAvailableIDs(-8 * 60 * 60 * 1000);\n-        Arrays.sort(zids_old);\n-        if (!Arrays.equals(zids_new, zids_old)) {\n-            System.out.println(\"------------------------\");\n-            System.out.println(\"NEW.getAvailableIDs(-8:00)\");\n-            for (String zid : zids_new) {\n-                System.out.println(zid);\n-            }\n-            System.out.println(\"------------------------\");\n-            System.out.println(\"OLD.getAvailableIDs(-8:00)\");\n-            for (String zid : zids_old) {\n-                System.out.println(zid);\n-            }\n-            throw new RuntimeException(\"  FAILED:  availableIds(offset) don't match\");\n-        }\n-    }\n-\n-    private static void delete(File f) {\n-        if (f.isDirectory()) {\n-            for (File f0 : f.listFiles()) {\n-               delete(f0);\n-            }\n-        }\n-        f.delete();\n-     }\n-\n-    \/\/ to access sun.util.calendar.ZoneInfo's private fields\n-    static Class<?> ziClz;\n-    static Field rawOffset;\n-    static Field checksum;\n-    static Field dstSavings;\n-    static Field transitions;\n-    static Field offsets;\n-    static Field simpleTimeZoneParams;\n-    static Field willGMTOffsetChange;\n-    static {\n-        try {\n-            ziClz = Class.forName(\"sun.util.calendar.ZoneInfo\");\n-            rawOffset = ziClz.getDeclaredField(\"rawOffset\");\n-            checksum = ziClz.getDeclaredField(\"checksum\");\n-            dstSavings = ziClz.getDeclaredField(\"dstSavings\");\n-            transitions = ziClz.getDeclaredField(\"transitions\");\n-            offsets = ziClz.getDeclaredField(\"offsets\");\n-            simpleTimeZoneParams = ziClz.getDeclaredField(\"simpleTimeZoneParams\");\n-            willGMTOffsetChange = ziClz.getDeclaredField(\"willGMTOffsetChange\");\n-            rawOffset.setAccessible(true);\n-            checksum.setAccessible(true);\n-            dstSavings.setAccessible(true);\n-            transitions.setAccessible(true);\n-            offsets.setAccessible(true);\n-            simpleTimeZoneParams.setAccessible(true);\n-            willGMTOffsetChange.setAccessible(true);\n-        } catch (Exception x) {\n-            throw new RuntimeException(x);\n-        }\n-    }\n-\n-    private static ZoneInfoOld toZoneInfoOld(TimeZone tz) throws Exception {\n-        return new ZoneInfoOld(tz.getID(),\n-                               rawOffset.getInt(tz),\n-                               dstSavings.getInt(tz),\n-                               checksum.getInt(tz),\n-                               (long[])transitions.get(tz),\n-                               (int[])offsets.get(tz),\n-                               (int[])simpleTimeZoneParams.get(tz),\n-                               willGMTOffsetChange.getBoolean(tz));\n-    }\n-\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/TestZoneInfo310.java","additions":0,"deletions":283,"binary":false,"changes":283,"status":"deleted"},{"patch":"@@ -1,339 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Locale;\n-import sun.util.calendar.CalendarDate;\n-import sun.util.calendar.CalendarSystem;\n-import sun.util.calendar.Gregorian;\n-\n-\/**\n- * Time class represents the \"AT\" field and other time related information.\n- *\n- * @since 1.4\n- *\/\n-class Time {\n-\n-    static final Gregorian gcal = CalendarSystem.getGregorianCalendar();\n-\n-    \/\/ type is wall clock time\n-    private static final int WALL = 1;\n-\n-    \/\/ type is standard time\n-    private static final int STD = 2;\n-\n-    \/\/ type is UTC\n-    private static final int UTC = 3;\n-\n-    \/\/ type of representing time\n-    private int type;\n-\n-    \/**\n-     * Time from the EPOCH in milliseconds\n-     *\/\n-    private long time;\n-\n-    \/**\n-     * Current time in milliseconds\n-     *\/\n-    private static final long currentTime = System.currentTimeMillis();\n-\n-    Time() {\n-        time = 0L;\n-    }\n-\n-    Time(long time) {\n-        this.time = time;\n-    }\n-\n-    void setType(int type) {\n-        this.type = type;\n-    }\n-\n-    long getTime() {\n-        return time;\n-    }\n-\n-    int getType() {\n-        return type;\n-    }\n-\n-    static long getCurrentTime() {\n-        return currentTime;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in wall-clock time.\n-     *\/\n-    boolean isWall() {\n-        return type == WALL;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in standard time.\n-     *\/\n-    boolean isSTD() {\n-        return type == STD;\n-    }\n-\n-    \/**\n-     * @return true if the time is represented in UTC time.\n-     *\/\n-    boolean isUTC() {\n-        return type == UTC;\n-    }\n-\n-    \/**\n-     * Converts the type to a string that represents the type in the\n-     * SimpleTimeZone time mode. (e.g., \"SimpleTimeZone.WALL_TIME\").\n-     * @return the converted string or null if the type is undefined.\n-     *\/\n-    String getTypeForSimpleTimeZone() {\n-        String  stz = \"SimpleTimeZone.\";\n-        if (isWall()) {\n-            return stz+\"WALL_TIME\";\n-        }\n-        else if (isSTD()) {\n-            return stz+\"STANDARD_TIME\";\n-        }\n-        else if (isUTC()) {\n-            return stz+\"UTC_TIME\";\n-        }\n-        else {\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param save the amount of daylight time in milliseconds\n-     * @param gmtOffset the GMT offset in milliseconds\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, int save,\n-                             int gmtOffset, Time time) {\n-        long    t = time.getTime();\n-\n-        if (time.isSTD())\n-            t = time.getTime() + save;\n-        else if (time.isUTC())\n-            t = time.getTime() + save + gmtOffset;\n-\n-        return getLocalTime(year, month, day, t);\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day value\n-     * @param time the time of the day in milliseconds\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, int day, long time) {\n-        CalendarDate date = gcal.newCalendarDate(null);\n-        date.setDate(year, month.value(), day);\n-        long millis = gcal.getTime(date);\n-        return millis + time;\n-    }\n-\n-    \/**\n-     * Equivalent to <code>getLocalTime(year, month, day, (long)time)<\/code>.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day value\n-     * @param time the time of the day in milliseconds\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, int day, int time) {\n-        return getLocalTime(year, month, day, (long)time);\n-    }\n-\n-    \/**\n-     * Equivalent to {@link #getLocalTime(int, Month, RuleDay, int)\n-     * getLocalTime(year, month, day, (int) time)}.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, long time) {\n-        return getLocalTime(year, month, day, (int) time);\n-    }\n-\n-    \/**\n-     * Converts the given Gregorian calendar field values to local time.\n-     * Local time is represented by the amount of milliseconds from\n-     * January 1, 1970 0:00 GMT.\n-     * @param year the year value\n-     * @param month the Month value\n-     * @param day the day represented by {@link RuleDay}\n-     * @param time the time of the day represented by {@link Time}\n-     * @return local time\n-     *\/\n-    static long getLocalTime(int year, Month month, RuleDay day, int time) {\n-        CalendarDate cdate = gcal.newCalendarDate(null);\n-        int monthValue = month.value();\n-\n-        if (day.isLast()) {     \/\/ e.g., \"lastSun\"\n-            cdate.setDate(year, monthValue, 1);\n-            cdate.setDayOfMonth(gcal.getMonthLength(cdate));\n-            cdate = gcal.getNthDayOfWeek(-1, day.getDayOfWeekNum(), cdate);\n-        } else if (day.isLater()) { \/\/ e.g., \"Sun>=1\"\n-            cdate.setDate(year, monthValue, day.getDay());\n-            cdate = gcal.getNthDayOfWeek(1, day.getDayOfWeekNum(), cdate);\n-        } else if (day.isExact()) {\n-            cdate.setDate(year, monthValue, day.getDay());\n-        } else if (day.isEarlier()) {   \/\/ e.g., \"Sun<=15\"\n-            cdate.setDate(year, monthValue, day.getDay());\n-            cdate = gcal.getNthDayOfWeek(-1, day.getDayOfWeekNum(), cdate);\n-        } else {\n-            Main.panic(\"invalid day type: \" + day);\n-        }\n-        return gcal.getTime(cdate) + time;\n-    }\n-\n-    \/**\n-     * Parses the given \"AT\" field and constructs a Time object.\n-     * @param the \"AT\" field string\n-     * @return the Time object\n-     *\/\n-    static Time parse(String time) {\n-        int sign;\n-        int index = 0;\n-        Time tm;\n-\n-        if (time.charAt(0) == '-') {\n-            sign = -1;\n-            index++;\n-        } else {\n-            sign = 1;\n-        }\n-        int val = 0;\n-        int num = 0;\n-        int countDelim = 0;\n-        while (index < time.length()) {\n-            char c = time.charAt(index++);\n-            if (c == ':') {\n-                val = val * 60 + num;\n-                countDelim++;\n-                num = 0;\n-                continue;\n-            }\n-            int d = Character.digit(c, 10);\n-            if (d == -1) {\n-                --index;\n-                break;\n-            }\n-            num = num * 10 + d;\n-        }\n-        val = val * 60 + num;\n-        \/\/ convert val to second\n-        for (; countDelim < 2; countDelim++) {\n-            val *= 60;\n-        }\n-        tm = new Time((long)val * 1000 * sign);\n-        if (index < time.length()) {\n-            char c = time.charAt(index++);\n-            if (c == 's') {\n-                tm.setType(Time.STD);\n-            } else if (c == 'u' || c == 'g' || c == 'z') {\n-                tm.setType(Time.UTC);\n-            } else if (c == 'w') {\n-                tm.setType(Time.WALL);\n-            } else {\n-                Main.panic(\"unknown time mode: \"+c);\n-            }\n-        } else {\n-            tm.setType(Time.WALL);\n-        }\n-        return tm;\n-    }\n-\n-    \/**\n-     * Converts the given milliseconds string to a \"[+-]hh:mm\" string.\n-     * @param ms the milliseconds string\n-     *\/\n-    static String toGMTFormat(String ms) {\n-        long sec = Long.parseLong(ms) \/ 1000;\n-        char sign;\n-        if (sec < 0) {\n-            sign = '-';\n-            sec = -sec;\n-        } else {\n-            sign = '+';\n-        }\n-        return String.format((Locale)null, \"%c%02d:%02d\",\n-                             sign, sec\/3600, (sec%3600)\/60);\n-    }\n-\n-    \/**\n-     * Converts the given millisecond value to a string for a\n-     * SimpleTimeZone parameter.\n-     * @param ms the millisecond value\n-     * @return the string in a human readable form\n-     *\/\n-    static String toFormedString(int ms) {\n-        StringBuilder s = new StringBuilder();\n-        boolean minus = false;\n-\n-        if (ms < 0) {\n-            s.append(\"-\");\n-            minus = true;\n-            ms = -ms;\n-        } else if (ms == 0) {\n-            return \"0\";\n-        }\n-\n-        int hour = ms \/ (60 * 60 * 1000);\n-        ms %= (60 * 60 * 1000);\n-        int minute = ms \/ (60 * 1000);\n-\n-        if (hour != 0) {\n-            if (minus && minute != 0) {\n-                s.append(\"(\");\n-            }\n-            s.append(Integer.toString(hour) + \"*ONE_HOUR\");\n-        }\n-\n-        if (minute != 0) {\n-            if (hour != 0) {\n-                s.append(\"+\");\n-            }\n-            s.append(Integer.toString(minute) + \"*ONE_MINUTE\");\n-            if (minus && hour != 0) {\n-                s.append(\")\");\n-            }\n-        }\n-\n-        return s.toString();\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Time.java","additions":0,"deletions":339,"binary":false,"changes":339,"status":"deleted"},{"patch":"@@ -1,450 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * Timezone represents all information of a single point of time to\n- * generate its time zone database.\n- *\n- * @since 1.4\n- *\/\n-class Timezone {\n-    \/**\n-     * zone name of this time zone\n-     *\/\n-    private String name;\n-\n-    \/**\n-     * transition time values in UTC (millisecond)\n-     *\/\n-    private List<Long> transitions;\n-\n-    \/**\n-     * All offset values in millisecond\n-     * @see sun.util.calendar.ZoneInfo\n-     *\/\n-    private List<Integer> offsets;\n-\n-    \/**\n-     * Indices of GMT offset values (both raw and raw+saving)\n-     * at transitions\n-     *\/\n-    private List<Integer> gmtOffsets;\n-\n-    \/**\n-     * Indices of regular or \"direct\" saving time values\n-     * at transitions\n-     *\/\n-    private List<Integer> dstOffsets;\n-\n-    \/**\n-     * Zone records of this time zone\n-     *\/\n-    private List<ZoneRec> usedZoneRecs;\n-\n-    \/**\n-     * Rule records referred to by this time zone\n-     *\/\n-    private List<RuleRec> usedRuleRecs;\n-\n-    \/**\n-     * Type of DST rules in this time zone\n-     *\/\n-    private int dstType;\n-    static final int UNDEF_DST = 0;     \/\/ DST type not set yet\n-    static final int NO_DST = 1;        \/\/ never observed DST\n-    static final int LAST_DST = 2;      \/\/ last rule ends in DST (all year round DST-only)\n-    static final int X_DST = 3;         \/\/ used to observe DST\n-    static final int DST = 4;           \/\/ observing DST regularly\n-\n-    \/**\n-     * Raw GMT offset of this time zone in the last rule\n-     *\/\n-    private int rawOffset;\n-\n-    \/**\n-     * The CRC32 value of the transitions data\n-     *\/\n-    private int crc32;\n-\n-    \/**\n-     * The last ZoneRec\n-     *\/\n-    private ZoneRec lastZoneRec;\n-\n-    \/**\n-     * The last DST rules. lastRules[0] is the DST start\n-     * rule. lastRules[1] is the DST end rules.\n-     *\/\n-    private List<RuleRec> lastRules;\n-\n-    \/**\n-     * The amount of DST saving value (millisecond) in the last DST\n-     * rule.\n-     *\/\n-    private int lastSaving;\n-\n-    \/**\n-     * true if the raw offset will change in the future time.\n-     *\/\n-    private boolean willRawOffsetChange = false;\n-\n-\n-    \/**\n-     * Constracts a Timezone object with the given zone name.\n-     * @param name the zone name\n-     *\/\n-    Timezone(String name) {\n-        this.name = name;\n-    }\n-\n-    \/**\n-     * @return the number of transitions\n-     *\/\n-    int getNTransitions() {\n-        if (transitions == null) {\n-            return 0;\n-        }\n-        return transitions.size();\n-    }\n-\n-    \/**\n-     * @return the zone name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Returns the list of all rule records that have been referred to\n-     * by this time zone.\n-     * @return the rule records list\n-     *\/\n-    List<RuleRec> getRules() {\n-        return usedRuleRecs;\n-    }\n-\n-    \/**\n-     * Returns the list of all zone records that have been referred to\n-     * by this time zone.\n-     * @return the zone records list\n-     *\/\n-    List<ZoneRec> getZones() {\n-        return usedZoneRecs;\n-    }\n-\n-    \/**\n-     * @return the transition table (list)\n-     *\/\n-    List<Long> getTransitions() {\n-        return transitions;\n-    }\n-\n-    \/**\n-     * @return the offsets list\n-     *\/\n-    List<Integer> getOffsets() {\n-        return offsets;\n-    }\n-\n-    \/**\n-     * @return the DST saving offsets list\n-     *\/\n-    List<Integer> getDstOffsets() {\n-        return dstOffsets;\n-    }\n-\n-    \/**\n-     * @return the GMT offsets list\n-     *\/\n-    List<Integer> getGmtOffsets() {\n-        return gmtOffsets;\n-    }\n-\n-    \/**\n-     * @return the checksum (crc32) value of the trasition table\n-     *\/\n-    int getCRC32() {\n-        return crc32;\n-    }\n-\n-    \/**\n-     * @return true if the GMT offset of this time zone would change\n-     * after the time zone database has been generated, false, otherwise.\n-     *\/\n-    boolean willGMTOffsetChange() {\n-        return willRawOffsetChange;\n-    }\n-\n-    \/**\n-     * @return the last known GMT offset value in milliseconds\n-     *\/\n-    int getRawOffset() {\n-        return rawOffset;\n-    }\n-\n-    \/**\n-     * Sets time zone's GMT offset to <code>offset<\/code>.\n-     * @param offset the GMT offset value in milliseconds\n-     *\/\n-    void setRawOffset(int offset) {\n-        rawOffset = offset;\n-    }\n-\n-    \/**\n-     * Sets time zone's GMT offset value to <code>offset<\/code>. If\n-     * <code>startTime<\/code> is future time, then the {@link\n-     * #willRawOffsetChange} value is set to true.\n-     * @param offset the GMT offset value in milliseconds\n-     * @param startTime the UTC time at which the GMT offset is in effective\n-     *\/\n-    void setRawOffset(int offset, long startTime) {\n-        \/\/ if this rawOffset is for the future time, let the run-time\n-        \/\/ look for the current GMT offset.\n-        if (startTime > Time.getCurrentTime()) {\n-            willRawOffsetChange = true;\n-        }\n-        setRawOffset(offset);\n-    }\n-\n-    \/**\n-     * Adds the specified transition information to the end of the transition table.\n-     * @param time the UTC time at which this transition happens\n-     * @param offset the total amount of the offset from GMT in milliseconds\n-     * @param dstOffset the amount of time in milliseconds saved at this transition\n-     *\/\n-    void addTransition(long time, int offset, int dstOffset) {\n-        if (transitions == null) {\n-            transitions = new ArrayList<Long>();\n-            offsets = new ArrayList<Integer>();\n-            dstOffsets = new ArrayList<Integer>();\n-        }\n-        transitions.add(time);\n-        offsets.add(offset);\n-        dstOffsets.add(dstOffset);\n-    }\n-\n-    \/**\n-     * Sets the type of historical daylight saving time\n-     * observation. For example, China used to observed daylight\n-     * saving time, but it no longer does. Then, X_DST is set to the\n-     * China time zone.\n-     * @param type the type of daylight saving time\n-     *\/\n-    void setDSTType(int type) {\n-        dstType = type;\n-    }\n-\n-    \/**\n-     * @return the type of historical daylight saving time\n-     * observation.\n-     *\/\n-    int getDSTType() {\n-        return dstType;\n-    }\n-\n-    \/**\n-     * Adds the specified zone record to the zone records list.\n-     * @param rec the zone record\n-     *\/\n-    void addUsedRec(ZoneRec rec) {\n-        if (usedZoneRecs == null) {\n-            usedZoneRecs = new ArrayList<ZoneRec>();\n-        }\n-        usedZoneRecs.add(rec);\n-    }\n-\n-    \/**\n-     * Adds the specified rule record to the rule records list.\n-     * @param rec the rule record\n-     *\/\n-    void addUsedRec(RuleRec rec) {\n-        if (usedRuleRecs == null) {\n-            usedRuleRecs = new ArrayList<RuleRec>();\n-        }\n-        \/\/ if the last used rec is the same as the given rec, avoid\n-        \/\/ putting the same rule.\n-        int n = usedRuleRecs.size();\n-        for (int i = 0; i < n; i++) {\n-            if (usedRuleRecs.get(i).equals(rec)) {\n-                return;\n-            }\n-        }\n-        usedRuleRecs.add(rec);\n-    }\n-\n-    \/**\n-     * Sets the last zone record for this time zone.\n-     * @param the last zone record\n-     *\/\n-    void setLastZoneRec(ZoneRec zrec) {\n-        lastZoneRec = zrec;\n-    }\n-\n-    \/**\n-     * @return the last zone record for this time zone.\n-     *\/\n-    ZoneRec getLastZoneRec() {\n-        return lastZoneRec;\n-    }\n-\n-    \/**\n-     * Sets the last rule records for this time zone. Those are used\n-     * for generating SimpleTimeZone parameters.\n-     * @param rules the last rule records\n-     *\/\n-    void setLastRules(List<RuleRec> rules) {\n-        int n = rules.size();\n-        if (n > 0) {\n-            lastRules = rules;\n-            RuleRec rec = rules.get(0);\n-            int offset = rec.getSave();\n-            if (offset > 0) {\n-                setLastDSTSaving(offset);\n-            } else {\n-                System.err.println(\"\\t    No DST starting rule in the last rules.\");\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * @return the last rule records for this time zone.\n-     *\/\n-    List<RuleRec> getLastRules() {\n-        return lastRules;\n-    }\n-\n-    \/**\n-     * Sets the last daylight saving amount.\n-     * @param the daylight saving amount\n-     *\/\n-    void setLastDSTSaving(int offset) {\n-        lastSaving = offset;\n-    }\n-\n-    \/**\n-     * @return the last daylight saving amount.\n-     *\/\n-    int getLastDSTSaving() {\n-        return lastSaving;\n-    }\n-\n-    \/**\n-     * Calculates the CRC32 value from the transition table and sets\n-     * the value to <code>crc32<\/code>.\n-     *\/\n-    void checksum() {\n-        if (transitions == null) {\n-            crc32 = 0;\n-            return;\n-        }\n-        Checksum sum = new Checksum();\n-        for (int i = 0; i < transitions.size(); i++) {\n-            int offset = offsets.get(i);\n-            \/\/ adjust back to make the transition in local time\n-            sum.update(transitions.get(i) + offset);\n-            sum.update(offset);\n-            sum.update(dstOffsets.get(i));\n-        }\n-        crc32 = (int)sum.getValue();\n-    }\n-\n-    \/**\n-     * Removes unnecessary transitions for Java time zone support.\n-     *\/\n-    void optimize() {\n-        \/\/ if there is only one offset, delete all transitions. This\n-        \/\/ could happen if only time zone abbreviations changed.\n-        if (gmtOffsets.size() == 1) {\n-            transitions = null;\n-            usedRuleRecs =  null;\n-            setDSTType(NO_DST);\n-            return;\n-        }\n-        for (int i = 0; i < (transitions.size() - 2); i++) { \/\/ don't remove the last one\n-            if (transitions.get(i) == transitions.get(i+1)) {\n-                transitions.remove(i);\n-                offsets.remove(i);\n-                dstOffsets.remove(i);\n-                i--;\n-            }\n-        }\n-\n-        for (int i = 0; i < (transitions.size() - 2); i++) { \/\/ don't remove the last one\n-            if (offsets.get(i) == offsets.get(i+1)\n-                && dstOffsets.get(i) == dstOffsets.get(i+1)) {\n-                transitions.remove(i+1);\n-                offsets.remove(i+1);\n-                dstOffsets.remove(i+1);\n-                i--;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Stores the specified offset value from GMT in the GMT offsets\n-     * table and returns its index. The offset value includes the base\n-     * GMT offset and any additional daylight saving if applicable. If\n-     * the same value as the specified offset is already in the table,\n-     * its index is returned.\n-     * @param offset the offset value in milliseconds\n-     * @return the index to the offset value in the GMT offsets table.\n-     *\/\n-    int getOffsetIndex(int offset) {\n-        return getOffsetIndex(offset, 0);\n-    }\n-\n-    \/**\n-     * Stores the specified daylight saving value in the GMT offsets\n-     * table and returns its index. If the same value as the specified\n-     * offset is already in the table, its index is returned. If 0 is\n-     * specified, it's not stored in the table and -1 is returned.\n-     * @param offset the offset value in milliseconds\n-     * @return the index to the specified offset value in the GMT\n-     * offsets table, or -1 if 0 is specified.\n-     *\/\n-    int getDstOffsetIndex(int offset) {\n-        if (offset == 0) {\n-            return -1;\n-        }\n-        return getOffsetIndex(offset, 1);\n-    }\n-\n-    private int getOffsetIndex(int offset, int index) {\n-        if (gmtOffsets == null) {\n-            gmtOffsets = new ArrayList<Integer>();\n-        }\n-        for (int i = index; i < gmtOffsets.size(); i++) {\n-            if (offset == gmtOffsets.get(i)) {\n-                return i;\n-            }\n-        }\n-        if (gmtOffsets.size() < index) {\n-            gmtOffsets.add(0);\n-        }\n-        gmtOffsets.add(offset);\n-        return gmtOffsets.size() - 1;\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Timezone.java","additions":0,"deletions":450,"binary":false,"changes":450,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.Map;\n-import java.util.HashMap;\n-\n-class TzIDOldMapping {\n-    static final Map<String, String> MAP = new HashMap<String, String>();\n-    static {\n-        String[][] oldmap = {\n-            { \"ACT\", \"Australia\/Darwin\" },\n-            { \"AET\", \"Australia\/Sydney\" },\n-            { \"AGT\", \"America\/Argentina\/Buenos_Aires\" },\n-            { \"ART\", \"Africa\/Cairo\" },\n-            { \"AST\", \"America\/Anchorage\" },\n-            { \"BET\", \"America\/Sao_Paulo\" },\n-            { \"BST\", \"Asia\/Dhaka\" },\n-            { \"CAT\", \"Africa\/Harare\" },\n-            { \"CNT\", \"America\/St_Johns\" },\n-            { \"CST\", \"America\/Chicago\" },\n-            { \"CTT\", \"Asia\/Shanghai\" },\n-            { \"EAT\", \"Africa\/Addis_Ababa\" },\n-            { \"ECT\", \"Europe\/Paris\" },\n-            { \"EST\", \"America\/New_York\" },\n-            { \"HST\", \"Pacific\/Honolulu\" },\n-            { \"IET\", \"America\/Indianapolis\" },\n-            { \"IST\", \"Asia\/Calcutta\" },\n-            { \"JST\", \"Asia\/Tokyo\" },\n-            { \"MIT\", \"Pacific\/Apia\" },\n-            { \"MST\", \"America\/Denver\" },\n-            { \"NET\", \"Asia\/Yerevan\" },\n-            { \"NST\", \"Pacific\/Auckland\" },\n-            { \"PLT\", \"Asia\/Karachi\" },\n-            { \"PNT\", \"America\/Phoenix\" },\n-            { \"PRT\", \"America\/Puerto_Rico\" },\n-            { \"PST\", \"America\/Los_Angeles\" },\n-            { \"SST\", \"Pacific\/Guadalcanal\" },\n-            { \"VST\", \"Asia\/Saigon\" },\n-        };\n-        for (String[] pair : oldmap) {\n-            MAP.put(pair[0], pair[1]);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/TzIDOldMapping.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Zone holds information corresponding to a \"Zone\" part of a time\n- * zone definition file.\n- *\n- * @since 1.4\n- *\/\n-class Zone {\n-    \/\/ zone name (e.g., \"America\/Los_Angeles\")\n-    private String name;\n-\n-    \/\/ zone records\n-    private List<ZoneRec> list;\n-\n-    \/\/ target zone names for this compilation\n-    private static Set<String> targetZones;\n-\n-    \/**\n-     * Constructs a Zone with the specified zone name.\n-     * @param name the zone name\n-     *\/\n-    Zone(String name) {\n-        this.name = name;\n-        list = new ArrayList<ZoneRec>();\n-    }\n-\n-    \/**\n-     * Reads time zone names to be generated, called \"target zone\n-     * name\", from the specified text file and creats an internal hash\n-     * table to keep those names. It's assumed that one text line\n-     * contains a zone name or comments if it starts with\n-     * '#'. Comments can't follow a zone name in a single line.\n-     * @param fileName the text file name\n-     *\/\n-    static void readZoneNames(String fileName) {\n-        if (fileName == null) {\n-            return;\n-        }\n-        BufferedReader in = null;\n-        try {\n-            FileReader fr = new FileReader(fileName);\n-            in = new BufferedReader(fr);\n-        } catch (FileNotFoundException e) {\n-            Main.panic(\"can't open file: \" + fileName);\n-        }\n-        targetZones = new HashSet<String>();\n-        String line;\n-\n-        try {\n-            while ((line = in.readLine()) != null) {\n-                line = line.trim();\n-                if (line.length() == 0 || line.charAt(0) == '#') {\n-                    continue;\n-                }\n-                if (!targetZones.add(line)) {\n-                    Main.warning(\"duplicated target zone name: \" + line);\n-                }\n-            }\n-            in.close();\n-        } catch (IOException e) {\n-            Main.panic(\"IO error: \"+e.getMessage());\n-        }\n-    }\n-\n-    \/**\n-     * Determines whether the specified zone is one of the target zones.\n-     * If no target zones are specified, this method always returns\n-     * true for any zone name.\n-     * @param zoneName the zone name\n-     * @return true if the specified name is a target zone.\n-     *\/\n-    static boolean isTargetZone(String zoneName) {\n-        if (targetZones == null) {\n-            return true;\n-        }\n-        return targetZones.contains(zoneName);\n-    }\n-\n-    \/**\n-     * Forces to add \"MET\" to the target zone table. This is because\n-     * there is a conflict between Java zone name \"WET\" and Olson zone\n-     * name.\n-     *\/\n-    static void addMET() {\n-        if (targetZones != null) {\n-            targetZones.add(\"MET\");\n-        }\n-    }\n-\n-    \/**\n-     * @return the zone name\n-     *\/\n-    String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Adds the specified zone record to the zone record list.\n-     *\/\n-    void add(ZoneRec rec) {\n-        list.add(rec);\n-    }\n-\n-    \/**\n-     * @param index the index at which the zone record in the list is returned.\n-     * @return the zone record specified by the index.\n-     *\/\n-    ZoneRec get(int index) {\n-        return list.get(index);\n-    }\n-\n-    \/**\n-     * @return the size of the zone record list\n-     *\/\n-    int size() {\n-        return list.size();\n-    }\n-\n-    \/**\n-     * Resolves the reference to a rule in each zone record.\n-     * @param zi the Zoneinfo object with which the rule reference is\n-     * resolved.\n-     *\/\n-    void resolve(Zoneinfo zi) {\n-        for (int i = 0; i < list.size(); i++) {\n-            ZoneRec rec = list.get(i);\n-            rec.resolve(zi);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Zone.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -1,1049 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.lang.ref.SoftReference;\n-import java.nio.file.FileSystems;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import sun.util.calendar.*;\n-\n-\/**\n- * <code>ZoneInfoFile<\/code> reads Zone information files in the\n- * &lt;java.home&gt;\/lib\/zi directory and provides time zone\n- * information in the form of a {@link ZoneInfo} object. Also, it\n- * reads the ZoneInfoMappings file to obtain time zone IDs information\n- * that is used by the {@link ZoneInfo} class. The directory layout\n- * and data file formats are as follows.\n- *\n- * <p><strong>Directory layout<\/strong><p>\n- *\n- * All zone data files and ZoneInfoMappings are put under the\n- * &lt;java.home&gt;\/lib\/zi directory. A path name for a given time\n- * zone ID is a concatenation of &lt;java.home&gt;\/lib\/zi\/ and the\n- * time zone ID. (The file separator is replaced with the platform\n- * dependent value. e.g., '\\' for Win32.) An example layout will look\n- * like as follows.\n- * <blockquote>\n- * <pre>\n- * &lt;java.home&gt;\/lib\/zi\/Africa\/Addis_Ababa\n- *                   \/Africa\/Dakar\n- *                   \/America\/Los_Angeles\n- *                   \/Asia\/Singapore\n- *                   \/EET\n- *                   \/Europe\/Oslo\n- *                   \/GMT\n- *                   \/Pacific\/Galapagos\n- *                       ...\n- *                   \/ZoneInfoMappings\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * A zone data file has specific information of each zone.\n- * <code>ZoneInfoMappings<\/code> has global information of zone IDs so\n- * that the information can be obtained without instantiating all time\n- * zones.\n- *\n- * <p><strong>File format<\/strong><p>\n- *\n- * Two binary-file formats based on a simple Tag-Length-Value format are used\n- * to describe TimeZone information. The generic format of a data file is:\n- * <blockquote>\n- * <pre>\n- *    DataFile {\n- *      u1              magic[7];\n- *      u1              version;\n- *      data_item       data[];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * where <code>magic<\/code> is a magic number identifying a file\n- * format, <code>version<\/code> is the format version number, and\n- * <code>data<\/code> is one or more <code>data_item<\/code>s. The\n- * <code>data_item<\/code> structure is:\n- * <blockquote>\n- * <pre>\n- *    data_item {\n- *      u1              tag;\n- *      u2              length;\n- *      u1              value[length];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * where <code>tag<\/code> indicates the data type of the item,\n- * <code>length<\/code> is a byte count of the following\n- * <code>value<\/code> that is the content of item data.\n- * <p>\n- * All data is stored in the big-endian order. There is no boundary\n- * alignment between date items.\n- *\n- * <p><strong>1. ZoneInfo data file<\/strong><p>\n- *\n- * Each ZoneInfo data file consists of the following members.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    ZoneInfoDataFile {\n- *      u1              magic[7];\n- *      u1              version;\n- *      SET OF<sup>1<\/sup> {\n- *        transition            transitions<sup>2<\/sup>;\n- *        offset_table          offsets<sup>2<\/sup>;\n- *        simpletimezone        stzparams<sup>2<\/sup>;\n- *        raw_offset            rawoffset;\n- *        dstsaving             dst;\n- *        checksum              crc32;\n- *        gmtoffsetwillchange   gmtflag<sup>2<\/sup>;\n- *      }\n- *   }\n- *   1: an unordered collection of zero or one occurrences of each item\n- *   2: optional item\n- * <\/pre>\n- * <\/blockquote>\n- * <code>magic<\/code> is a byte-string constant identifying the\n- * ZoneInfo data file.  This field must be <code>\"javazi&#92;0\"<\/code>\n- * defined as {@link #JAVAZI_LABEL}.\n- * <p>\n- * <code>version<\/code> is the version number of the file format. This\n- * will be used for compatibility check. This field must be\n- * <code>0x01<\/code> in this version.\n- * <p>\n- * <code>transition<\/code>, <code>offset_table<\/code> and\n- * <code>simpletimezone<\/code> have information of time transition\n- * from the past to the future.  Therefore, these structures don't\n- * exist if the zone didn't change zone names and haven't applied DST in\n- * the past, and haven't planned to apply it.  (e.g. Asia\/Tokyo zone)\n- * <p>\n- * <code>raw_offset<\/code>, <code>dstsaving<\/code> and <code>checksum<\/code>\n- * exist in every zoneinfo file. They are used by TimeZone.class indirectly.\n- *\n- * <p><strong>1.1 <code>transition<\/code> structure<\/strong><p><a name=\"transition\"><\/a>\n- * <blockquote>\n- * <pre>\n- *    transition {\n- *      u1      tag;              \/\/ 0x04 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s8      value[length\/8];  \/\/ transitions in `long'\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#transitions ZoneInfo.transitions} about the value.\n- *\n- * <p><strong>1.2 <code>offset_table<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    offset_table {\n- *      u1      tag;              \/\/ 0x05 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ offset values in `int'\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>1.3 <code>simpletimezone<\/code> structure<\/strong><p>\n- * See {@link ZoneInfo#simpleTimeZoneParams ZoneInfo.simpleTimeZoneParams}\n- * about the value.\n- * <blockquote>\n- * <pre>\n- *    simpletimezone {\n- *      u1      tag;              \/\/ 0x06 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ SimpleTimeZone parameters\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#offsets ZoneInfo.offsets} about the value.\n- *\n- * <p><strong>1.4 <code>raw_offset<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    raw_offset {\n- *      u1      tag;              \/\/ 0x01 : constant\n- *      u2      length;           \/\/ must be 4.\n- *      s4      value;            \/\/ raw GMT offset [millisecond]\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#rawOffset ZoneInfo.rawOffset} about the value.\n- *\n- * <p><strong>1.5 <code>dstsaving<\/code> structure<\/strong><p>\n- * Value has dstSaving in seconds.\n- * <blockquote>\n- * <pre>\n- *    dstsaving {\n- *      u1      tag;              \/\/ 0x02 : constant\n- *      u2      length;           \/\/ must be 2.\n- *      s2      value;            \/\/ DST save value [second]\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#dstSavings ZoneInfo.dstSavings} about value.\n- *\n- * <p><strong>1.6 <code>checksum<\/code> structure<\/strong><p>\n- * <blockquote>\n- * <pre>\n- *    checksum {\n- *      u1      tag;              \/\/ 0x03 : constant\n- *      u2      length;           \/\/ must be 4.\n- *      s4      value;            \/\/ CRC32 value of transitions\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- * See {@link ZoneInfo#checksum ZoneInfo.checksum}.\n- *\n- * <p><strong>1.7 <code>gmtoffsetwillchange<\/code> structure<\/strong><p>\n- * This record has a flag value for {@link ZoneInfo#rawOffsetWillChange}.\n- * If this record is not present in a zoneinfo file, 0 is assumed for\n- * the value.\n- * <blockquote>\n- * <pre>\n- *    gmtoffsetwillchange {\n- *      u1      tag;             \/\/ 0x07 : constant\n- *      u2      length;          \/\/ must be 1.\n- *      u1      value;           \/\/ 1: if the GMT raw offset will change\n- *                               \/\/ in the future, 0, otherwise.\n- *     }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- *\n- * <p><strong>2. ZoneInfoMappings file<\/strong><p>\n- *\n- * The ZoneInfoMappings file consists of the following members.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    ZoneInfoMappings {\n- *      u1      magic[7];\n- *      u1      version;\n- *      SET OF {\n- *        versionName                   version;\n- *        zone_id_table                 zoneIDs;\n- *        raw_offset_table              rawoffsets;\n- *        raw_offset_index_table        rawoffsetindices;\n- *        alias_table                   aliases;\n- *        excluded_list                 excludedList;\n- *      }\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <code>magic<\/code> is a byte-string constant which has the file type.\n- * This field must be <code>\"javazm&#92;0\"<\/code> defined as {@link #JAVAZM_LABEL}.\n- * <p>\n- * <code>version<\/code> is the version number of this file\n- * format. This will be used for compatibility check. This field must\n- * be <code>0x01<\/code> in this version.\n- * <p>\n- * <code>versionName<\/code> shows which version of Olson's data has been used\n- * to generate this ZoneInfoMappings. (e.g. <code>tzdata2000g<\/code>) <br>\n- * This field is for trouble-shooting and isn't usually used in runtime.\n- * <p>\n- * <code>zone_id_table<\/code>, <code>raw_offset_index_table<\/code> and\n- * <code>alias_table<\/code> are general information of supported\n- * zones.\n- *\n- * <p><strong>2.1 <code>zone_id_table<\/code> structure<\/strong><p>\n- * The list of zone IDs included in the zi database. The list does\n- * <em>not<\/em> include zone IDs, if any, listed in excludedList.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    zone_id_table {\n- *      u1      tag;              \/\/ 0x40 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      zone_id_count;\n- *      zone_id value[zone_id_count];\n- *    }\n- *\n- *    zone_id {\n- *      u1      byte_length;      \/\/ byte length of id\n- *      u1      id[byte_length];  \/\/ zone name string\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.2 <code>raw_offset_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    raw_offset_table {\n- *      u1      tag;              \/\/ 0x41 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      s4      value[length\/4];  \/\/ raw GMT offset in milliseconds\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.3 <code>raw_offset_index_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *    raw_offset_index_table {\n- *      u1      tag;              \/\/ 0x42 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u1      value[length];\n- *    }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.4 <code>alias_table<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   alias_table {\n- *      u1      tag;              \/\/ 0x43 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      nentries;         \/\/ number of id-pairs\n- *      id_pair value[nentries];\n- *   }\n- *\n- *   id_pair {\n- *      zone_id aliasname;\n- *      zone_id ID;\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.5 <code>versionName<\/code> structure<\/strong><p>\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   versionName {\n- *      u1      tag;              \/\/ 0x44 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u1      value[length];\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * <p><strong>2.6 <code>excludeList<\/code> structure<\/strong><p>\n- * The list of zone IDs whose zones will change their GMT offsets\n- * (a.k.a. raw offsets) some time in the future. Those IDs must be\n- * added to the list of zone IDs for getAvailableIDs(). Also they must\n- * be examined for getAvailableIDs(int) to determine the\n- * <em>current<\/em> GMT offsets.\n- * <br>\n- * <blockquote>\n- * <pre>\n- *   excluded_list {\n- *      u1      tag;              \/\/ 0x45 : constant\n- *      u2      length;           \/\/ byte length of whole values\n- *      u2      nentries;         \/\/ number of zone_ids\n- *      zone_id value[nentries];  \/\/ excluded zone IDs\n- *   }\n- * <\/pre>\n- * <\/blockquote>\n- *\n- * @since 1.4\n- *\/\n-\n-public class ZoneInfoFile {\n-\n-    \/**\n-     * The magic number for the ZoneInfo data file format.\n-     *\/\n-    public static final byte[]  JAVAZI_LABEL = {\n-        (byte)'j', (byte)'a', (byte)'v', (byte)'a', (byte)'z', (byte)'i', (byte)'\\0'\n-    };\n-    private static final int    JAVAZI_LABEL_LENGTH = JAVAZI_LABEL.length;\n-\n-    \/**\n-     * The ZoneInfo data file format version number. Must increase\n-     * one when any incompatible change has been made.\n-     *\/\n-    public static final byte    JAVAZI_VERSION = 0x01;\n-\n-    \/**\n-     * Raw offset data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffset = 1;\n-\n-    \/**\n-     * Known last Daylight Saving Time save value data item tag.\n-     *\/\n-    public static final byte    TAG_LastDSTSaving = 2;\n-\n-    \/**\n-     * Checksum data item tag.\n-     *\/\n-    public static final byte    TAG_CRC32 = 3;\n-\n-    \/**\n-     * Transition data item tag.\n-     *\/\n-    public static final byte    TAG_Transition = 4;\n-\n-    \/**\n-     * Offset table data item tag.\n-     *\/\n-    public static final byte    TAG_Offset = 5;\n-\n-    \/**\n-     * SimpleTimeZone parameters data item tag.\n-     *\/\n-    public static final byte    TAG_SimpleTimeZone = 6;\n-\n-    \/**\n-     * Raw GMT offset will change in the future.\n-     *\/\n-    public static final byte    TAG_GMTOffsetWillChange = 7;\n-\n-\n-    \/**\n-     * The ZoneInfoMappings file name.\n-     *\/\n-    public static final String  JAVAZM_FILE_NAME = \"ZoneInfoMappings\";\n-\n-    \/**\n-     * The magic number for the ZoneInfoMappings file format.\n-     *\/\n-    public static final byte[]  JAVAZM_LABEL = {\n-        (byte)'j', (byte)'a', (byte)'v', (byte)'a', (byte)'z', (byte)'m', (byte)'\\0'\n-    };\n-    private static final int    JAVAZM_LABEL_LENGTH = JAVAZM_LABEL.length;\n-\n-    \/**\n-     * The ZoneInfoMappings file format version number. Must increase\n-     * one when any incompatible change has been made.\n-     *\/\n-    public static final byte    JAVAZM_VERSION = 0x01;\n-\n-    \/**\n-     * Time zone IDs data item tag.\n-     *\/\n-    public static final byte    TAG_ZoneIDs = 64;\n-\n-    \/**\n-     * Raw GMT offsets table data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffsets = 65;\n-\n-    \/**\n-     * Indices to the raw GMT offset table data item tag.\n-     *\/\n-    public static final byte    TAG_RawOffsetIndices = 66;\n-\n-    \/**\n-     * Time zone aliases table data item tag.\n-     *\/\n-    public static final byte    TAG_ZoneAliases = 67;\n-\n-    \/**\n-     * Olson's public zone information version tag.\n-     *\/\n-    public static final byte    TAG_TZDataVersion = 68;\n-\n-    \/**\n-     * Excluded zones item tag. (Added in Mustang)\n-     *\/\n-    public static final byte    TAG_ExcludedZones = 69;\n-\n-    private static Map<String, ZoneInfoOld> zoneInfoObjects = null;\n-\n-    private static final ZoneInfoOld GMT = new ZoneInfoOld(\"GMT\", 0);\n-\n-    static String ziDir;\n-\n-    \/**\n-     * Converts the given time zone ID to a platform dependent path\n-     * name. For example, \"America\/Los_Angeles\" is converted to\n-     * \"America\\Los_Angeles\" on Win32.\n-     * @return a modified ID replacing '\/' with {@link\n-     * java.io.File#separatorChar File.separatorChar} if needed.\n-     *\/\n-    public static String getFileName(String ID) {\n-        if (File.separatorChar == '\/') {\n-            return ID;\n-        }\n-        return ID.replace('\/', File.separatorChar);\n-    }\n-\n-    \/**\n-     * Gets a ZoneInfo with the given GMT offset. The object\n-     * has its ID in the format of GMT{+|-}hh:mm.\n-     *\n-     * @param originalId the given custom id (before normalized such as \"GMT+9\")\n-     * @param gmtOffset GMT offset <em>in milliseconds<\/em>\n-     * @return a ZoneInfo constructed with the given GMT offset\n-     *\/\n-    public static ZoneInfoOld getCustomTimeZone(String originalId, int gmtOffset) {\n-        String id = toCustomID(gmtOffset);\n-\n-        ZoneInfoOld zi = getFromCache(id);\n-        if (zi == null) {\n-            zi = new ZoneInfoOld(id, gmtOffset);\n-            zi = addToCache(id, zi);\n-            if (!id.equals(originalId)) {\n-                zi = addToCache(originalId, zi);\n-            }\n-        }\n-        return (ZoneInfoOld) zi.clone();\n-    }\n-\n-    public static String toCustomID(int gmtOffset) {\n-        char sign;\n-        int offset = gmtOffset \/ 60000;\n-\n-        if (offset >= 0) {\n-            sign = '+';\n-        } else {\n-            sign = '-';\n-            offset = -offset;\n-        }\n-        int hh = offset \/ 60;\n-        int mm = offset % 60;\n-\n-        char[] buf = new char[] { 'G', 'M', 'T', sign, '0', '0', ':', '0', '0' };\n-        if (hh >= 10) {\n-            buf[4] += hh \/ 10;\n-        }\n-        buf[5] += hh % 10;\n-        if (mm != 0) {\n-            buf[7] += mm \/ 10;\n-            buf[8] += mm % 10;\n-        }\n-        return new String(buf);\n-    }\n-\n-    \/**\n-     * @return a ZoneInfo instance created for the specified id, or\n-     * null if there is no time zone data file found for the specified\n-     * id.\n-     *\/\n-    public static ZoneInfoOld getZoneInfoOld(String id) {\n-        \/\/treat GMT zone as special\n-        if (\"GMT\".equals(id))\n-            return (ZoneInfoOld) GMT.clone();\n-        ZoneInfoOld zi = getFromCache(id);\n-        if (zi == null) {\n-            Map<String, String> aliases = ZoneInfoOld.getCachedAliasTable();\n-            if (aliases != null && aliases.get(id) != null) {\n-                return null;\n-            }\n-            zi = createZoneInfoOld(id);\n-            if (zi == null) {\n-                return null;\n-            }\n-            zi = addToCache(id, zi);\n-        }\n-        return (ZoneInfoOld) zi.clone();\n-    }\n-\n-    synchronized static ZoneInfoOld getFromCache(String id) {\n-        if (zoneInfoObjects == null) {\n-            return null;\n-        }\n-        return zoneInfoObjects.get(id);\n-    }\n-\n-    synchronized static ZoneInfoOld addToCache(String id, ZoneInfoOld zi) {\n-        if (zoneInfoObjects == null) {\n-            zoneInfoObjects = new HashMap<>();\n-        } else {\n-            ZoneInfoOld zone = zoneInfoObjects.get(id);\n-            if (zone != null) {\n-                return zone;\n-            }\n-        }\n-        zoneInfoObjects.put(id, zi);\n-        return zi;\n-    }\n-\n-    private static ZoneInfoOld createZoneInfoOld(String id) {\n-        byte[] buf = readZoneInfoFile(getFileName(id));\n-        if (buf == null) {\n-            return null;\n-        }\n-\n-        int index = 0;\n-        int filesize = buf.length;\n-        int rawOffset = 0;\n-        int dstSavings = 0;\n-        int checksum = 0;\n-        boolean willGMTOffsetChange = false;\n-        long[] transitions = null;\n-        int[] offsets = null;\n-        int[] simpleTimeZoneParams = null;\n-\n-        try {\n-            for (index = 0; index < JAVAZI_LABEL.length; index++) {\n-                if (buf[index] != JAVAZI_LABEL[index]) {\n-                    System.err.println(\"ZoneInfoOld: wrong magic number: \" + id);\n-                    return null;\n-                }\n-            }\n-            if (buf[index++] > JAVAZI_VERSION) {\n-                System.err.println(\"ZoneInfo: incompatible version (\"\n-                                   + buf[index - 1] + \"): \" + id);\n-                return null;\n-            }\n-\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int  len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                if (filesize < index+len) {\n-                    break;\n-                }\n-\n-                switch (tag) {\n-                case TAG_CRC32:\n-                    {\n-                        int val = buf[index++] & 0xff;\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        checksum = val;\n-                    }\n-                    break;\n-\n-                case TAG_LastDSTSaving:\n-                    {\n-                        short val = (short)(buf[index++] & 0xff);\n-                        val = (short)((val << 8) + (buf[index++] & 0xff));\n-                        dstSavings = val * 1000;\n-                    }\n-                    break;\n-\n-                case TAG_RawOffset:\n-                    {\n-                        int val = buf[index++] & 0xff;\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        val = (val << 8) + (buf[index++] & 0xff);\n-                        rawOffset = val;\n-                    }\n-                    break;\n-\n-                case TAG_Transition:\n-                    {\n-                        int n = len \/ 8;\n-                        transitions = new long[n];\n-                        for (int i = 0; i < n; i ++) {\n-                            long val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            transitions[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_Offset:\n-                    {\n-                        int n = len \/ 4;\n-                        offsets = new int[n];\n-                        for (int i = 0; i < n; i ++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            offsets[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_SimpleTimeZone:\n-                    {\n-                        if (len != 32 && len != 40) {\n-                            System.err.println(\"ZoneInfo: wrong SimpleTimeZone parameter size\");\n-                            return null;\n-                        }\n-                        int n = len \/ 4;\n-                        simpleTimeZoneParams = new int[n];\n-                        for (int i = 0; i < n; i++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            simpleTimeZoneParams[i] = val;\n-                        }\n-                    }\n-                    break;\n-\n-                case TAG_GMTOffsetWillChange:\n-                    {\n-                        if (len != 1) {\n-                            System.err.println(\"ZoneInfo: wrong byte length for TAG_GMTOffsetWillChange\");\n-                        }\n-                        willGMTOffsetChange = buf[index++] == 1;\n-                    }\n-                    break;\n-\n-                default:\n-                    System.err.println(\"ZoneInfo: unknown tag < \" + tag + \">. ignored.\");\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfo: corrupted zoneinfo file: \" + id);\n-            return null;\n-        }\n-\n-        if (index != filesize) {\n-            System.err.println(\"ZoneInfo: wrong file size: \" + id);\n-            return null;\n-        }\n-\n-        return new ZoneInfoOld(id, rawOffset, dstSavings, checksum,\n-                            transitions, offsets, simpleTimeZoneParams,\n-                            willGMTOffsetChange);\n-    }\n-\n-    private volatile static SoftReference<List<String>> zoneIDs = null;\n-\n-    static List<String> getZoneIDs() {\n-        List<String> ids = null;\n-        SoftReference<List<String>> cache = zoneIDs;\n-        if (cache != null) {\n-            ids = cache.get();\n-            if (ids != null) {\n-                return ids;\n-            }\n-        }\n-        byte[] buf = null;\n-        buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ZoneIDs:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        ids = new ArrayList<>(n);\n-\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            ids.add(new String(buf, index, m, \"UTF-8\"));\n-                            index += m;\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        zoneIDs = new SoftReference<>(ids);\n-        return ids;\n-    }\n-\n-    \/**\n-     * @return an alias table in HashMap where a key is an alias ID\n-     * (e.g., \"PST\") and its value is a real time zone ID (e.g.,\n-     * \"America\/Los_Angeles\").\n-     *\/\n-    static Map<String, String> getZoneAliases() {\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-        Map<String, String> aliases = null;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ZoneAliases:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        aliases = new HashMap<>(n);\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            String name = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            m = buf[index++];\n-                            String realName = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            aliases.put(name, realName);\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-        return aliases;\n-    }\n-\n-    private volatile static SoftReference<List<String>> excludedIDs = null;\n-    private volatile static boolean hasNoExcludeList = false;\n-\n-    \/**\n-     * @return a List of zone IDs for zones that will change their GMT\n-     * offsets in some future time.\n-     *\n-     * @since 1.6\n-     *\/\n-    static List<String> getExcludedZones() {\n-        if (hasNoExcludeList) {\n-            return null;\n-        }\n-\n-        List<String> excludeList = null;\n-\n-        SoftReference<List<String>> cache = excludedIDs;\n-        if (cache != null) {\n-            excludeList = cache.get();\n-            if (excludeList != null) {\n-                return excludeList;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-          loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_ExcludedZones:\n-                    {\n-                        int n = (buf[index++] << 8) + (buf[index++] & 0xFF);\n-                        excludeList = new ArrayList<>();\n-                        for (int i = 0; i < n; i++) {\n-                            byte m = buf[index++];\n-                            String name = new String(buf, index, m, \"UTF-8\");\n-                            index += m;\n-                            excludeList.add(name);\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-\n-        if (excludeList != null) {\n-            excludedIDs = new SoftReference<>(excludeList);\n-        } else {\n-            hasNoExcludeList = true;\n-        }\n-        return excludeList;\n-    }\n-\n-    private volatile static SoftReference<byte[]> rawOffsetIndices = null;\n-\n-    static byte[] getRawOffsetIndices() {\n-        byte[] indices = null;\n-\n-        SoftReference<byte[]> cache = rawOffsetIndices;\n-        if (cache != null) {\n-            indices = cache.get();\n-            if (indices != null) {\n-                return indices;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_RawOffsetIndices:\n-                    {\n-                        indices = new byte[len];\n-                        for (int i = 0; i < len; i++) {\n-                            indices[i] = buf[index++];\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        rawOffsetIndices = new SoftReference<>(indices);\n-        return indices;\n-    }\n-\n-    private volatile static SoftReference<int[]> rawOffsets = null;\n-\n-    static int[] getRawOffsets() {\n-        int[] offsets = null;\n-\n-        SoftReference<int[]> cache = rawOffsets;\n-        if (cache != null) {\n-            offsets = cache.get();\n-            if (offsets != null) {\n-                return offsets;\n-            }\n-        }\n-\n-        byte[] buf = getZoneInfoOldMappings();\n-        int index = JAVAZM_LABEL_LENGTH + 1;\n-        int filesize = buf.length;\n-\n-        try {\n-        loop:\n-            while (index < filesize) {\n-                byte tag = buf[index++];\n-                int     len = ((buf[index++] & 0xFF) << 8) + (buf[index++] & 0xFF);\n-\n-                switch (tag) {\n-                case TAG_RawOffsets:\n-                    {\n-                        int n = len\/4;\n-                        offsets = new int[n];\n-                        for (int i = 0; i < n; i++) {\n-                            int val = buf[index++] & 0xff;\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            val = (val << 8) + (buf[index++] & 0xff);\n-                            offsets[i] = val;\n-                        }\n-                    }\n-                    break loop;\n-\n-                default:\n-                    index += len;\n-                    break;\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            System.err.println(\"ZoneInfoOld: corrupted \" + JAVAZM_FILE_NAME);\n-        }\n-\n-        rawOffsets = new SoftReference<>(offsets);\n-        return offsets;\n-    }\n-\n-    private volatile static SoftReference<byte[]> zoneInfoMappings = null;\n-\n-    private static byte[] getZoneInfoOldMappings() {\n-        byte[] data;\n-        SoftReference<byte[]> cache = zoneInfoMappings;\n-        if (cache != null) {\n-            data = cache.get();\n-            if (data != null) {\n-                return data;\n-            }\n-        }\n-        data = readZoneInfoFile(JAVAZM_FILE_NAME);\n-        if (data == null) {\n-            throw new RuntimeException(\"ZoneInfoOldMapping \" +\n-                JAVAZM_FILE_NAME + \" either doesn't exist or doesn't have data\");\n-        }\n-\n-        int index;\n-        for (index = 0; index < JAVAZM_LABEL.length; index++) {\n-            if (data[index] != JAVAZM_LABEL[index]) {\n-                System.err.println(\"ZoneInfoOld: wrong magic number: \" + JAVAZM_FILE_NAME);\n-                return null;\n-            }\n-        }\n-        if (data[index++] > JAVAZM_VERSION) {\n-            System.err.println(\"ZoneInfoOld: incompatible version (\"\n-                               + data[index - 1] + \"): \" + JAVAZM_FILE_NAME);\n-            return null;\n-        }\n-\n-        zoneInfoMappings = new SoftReference<>(data);\n-        return data;\n-    }\n-\n-    \/**\n-     * Reads the specified file under &lt;java.home&gt;\/lib\/zi into a buffer.\n-     * @return the buffer, or null if any I\/O error occurred.\n-     *\/\n-    private static byte[] readZoneInfoFile(final String fileName) {\n-        if (fileName.indexOf(\"..\") >= 0) {\n-            return null;\n-        }\n-        byte[] buffer = null;\n-        File file = new File(ziDir, fileName);\n-        try {\n-            int filesize = (int)file.length();\n-            if (filesize > 0) {\n-                FileInputStream fis = new FileInputStream(file);\n-                buffer = new byte[filesize];\n-                try {\n-                    if (fis.read(buffer) != filesize) {\n-                        throw new IOException(\"read error on \" + fileName);\n-                    }\n-                } finally {\n-                    fis.close();\n-                }\n-            }\n-        } catch (Exception ex) {\n-            if (!(ex instanceof FileNotFoundException) || JAVAZM_FILE_NAME.equals(fileName)) {\n-                System.err.println(\"ZoneInfoOld: \" + ex.getMessage());\n-            }\n-        }\n-        return buffer;\n-    }\n-\n-    private ZoneInfoFile() {\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoFile.java","additions":0,"deletions":1049,"binary":false,"changes":1049,"status":"deleted"},{"patch":"@@ -1,1022 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.lang.ref.SoftReference;\n-import java.time.ZoneOffset;\n-import java.time.LocalDateTime;\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.SimpleTimeZone;\n-import java.util.TimeZone;\n-\n-import sun.util.calendar.CalendarSystem;\n-import sun.util.calendar.CalendarDate;\n-\n-\/**\n- * <code>ZoneInfoOld<\/code> is an implementation subclass of {@link\n- * java.util.TimeZone TimeZone} that represents GMT offsets and\n- * daylight saving time transitions of a time zone.\n- * <p>\n- * The daylight saving time transitions are described in the {@link\n- * #transitions transitions} table consisting of a chronological\n- * sequence of transitions of GMT offset and\/or daylight saving time\n- * changes. Since all transitions are represented in UTC, in theory,\n- * <code>ZoneInfoOld<\/code> can be used with any calendar systems except\n- * for the {@link #getOffset(int,int,int,int,int,int) getOffset}\n- * method that takes Gregorian calendar date fields.\n- * <p>\n- * This table covers transitions from 1900 until 2100 (as of version\n- * 23), Before 1900, it assumes that there was no daylight saving\n- * time and the <code>getOffset<\/code> methods always return the\n- * {@link #getRawOffset} value. No Local Mean Time is supported. If a\n- * specified date is beyond the transition table and this time zone is\n- * supposed to observe daylight saving time in 2100, it delegates\n- * operations to a {@link java.util.SimpleTimeZone SimpleTimeZone}\n- * object created using the daylight saving time schedule as of 2100.\n- * <p>\n- * The date items, transitions, GMT offset(s), etc. are read from a database\n- * file. See {@link ZoneInfoFile} for details.\n- * @see java.util.SimpleTimeZone\n- * @since 1.4\n- *\/\n-\n-public class ZoneInfoOld extends TimeZone {\n-\n-    \/\/ The constants assume no leap seconds support.\n-    static final int SECOND_IN_MILLIS = 1000;\n-    static final int MINUTE_IN_MILLIS = SECOND_IN_MILLIS * 60;\n-    static final int HOUR_IN_MILLIS = MINUTE_IN_MILLIS * 60;\n-    static final int DAY_IN_MILLIS = HOUR_IN_MILLIS * 24;\n-\n-    private static final int UTC_TIME = 0;\n-    private static final int STANDARD_TIME = 1;\n-    private static final int WALL_TIME = 2;\n-\n-    private static final long OFFSET_MASK = 0x0fL;\n-    private static final long DST_MASK = 0xf0L;\n-    private static final int DST_NSHIFT = 4;\n-    \/\/ this bit field is reserved for abbreviation support\n-    private static final long ABBR_MASK = 0xf00L;\n-    private static final int TRANSITION_NSHIFT = 12;\n-\n-    \/\/ IDs having conflicting data between Olson and JDK 1.1\n-    static final Map<String, String> conflictingIDs = Map.of(\n-        \"EST\", \"America\/Panama\",\n-        \"MST\", \"America\/Phoenix\");\n-\n-    private static final CalendarSystem gcal = CalendarSystem.getGregorianCalendar();\n-\n-    \/**\n-     * The raw GMT offset in milliseconds between this zone and GMT.\n-     * Negative offsets are to the west of Greenwich.  To obtain local\n-     * <em>standard<\/em> time, add the offset to GMT time.\n-     * @serial\n-     *\/\n-    int rawOffset;\n-\n-    \/**\n-     * Difference in milliseconds from the original GMT offset in case\n-     * the raw offset value has been modified by calling {@link\n-     * #setRawOffset}. The initial value is 0.\n-     * @serial\n-     *\/\n-    int rawOffsetDiff = 0;\n-\n-    \/**\n-     * A CRC32 value of all pairs of transition time (in milliseconds\n-     * in <code>long<\/code>) in local time and its GMT offset (in\n-     * seconds in <code>int<\/code>) in the chronological order. Byte\n-     * values of each <code>long<\/code> and <code>int<\/code> are taken\n-     * in the big endian order (i.e., MSB to LSB).\n-     * @serial\n-     *\/\n-    int checksum;\n-\n-    \/**\n-     * The amount of time in milliseconds saved during daylight saving\n-     * time. If <code>useDaylight<\/code> is false, this value is 0.\n-     * @serial\n-     *\/\n-    int dstSavings;\n-\n-    \/**\n-     * This array describes transitions of GMT offsets of this time\n-     * zone, including both raw offset changes and daylight saving\n-     * time changes.\n-     * A long integer consists of four bit fields.\n-     * <ul>\n-     * <li>The most significant 52-bit field represents transition\n-     * time in milliseconds from Gregorian January 1 1970, 00:00:00\n-     * GMT.<\/li>\n-     * <li>The next 4-bit field is reserved and must be 0.<\/li>\n-     * <li>The next 4-bit field is an index value to {@link #offsets\n-     * offsets[]} for the amount of daylight saving at the\n-     * transition. If this value is zero, it means that no daylight\n-     * saving, not the index value zero.<\/li>\n-     * <li>The least significant 4-bit field is an index value to\n-     * {@link #offsets offsets[]} for <em>total<\/em> GMT offset at the\n-     * transition.<\/li>\n-     * <\/ul>\n-     * If this time zone doesn't observe daylight saving time and has\n-     * never changed any GMT offsets in the past, this value is null.\n-     * @serial\n-     *\/\n-    long[] transitions;\n-\n-    \/**\n-     * This array holds all unique offset values in\n-     * milliseconds. Index values to this array are stored in the\n-     * transitions array elements.\n-     * @serial\n-     *\/\n-    int[] offsets;\n-\n-    \/**\n-     * SimpleTimeZone parameter values. It has to have either 8 for\n-     * {@link java.util.SimpleTimeZone#SimpleTimeZone(int, String,\n-     * int, int , int , int , int , int , int , int , int) the\n-     * 11-argument SimpleTimeZone constructor} or 10 for {@link\n-     * java.util.SimpleTimeZone#SimpleTimeZone(int, String, int, int,\n-     * int , int , int , int , int , int , int, int, int) the\n-     * 13-argument SimpleTimeZone constructor} parameters.\n-     * @serial\n-     *\/\n-    int[] simpleTimeZoneParams;\n-\n-    \/**\n-     * True if the raw GMT offset value would change after the time\n-     * zone data has been generated; false, otherwise. The default\n-     * value is false.\n-     * @serial\n-     *\/\n-    boolean willGMTOffsetChange = false;\n-\n-    \/**\n-     * True if the object has been modified after its instantiation.\n-     *\/\n-    transient private boolean dirty = false;\n-\n-    private static final long serialVersionUID = 2653134537216586139L;\n-\n-    \/**\n-     * A constructor.\n-     *\/\n-    public ZoneInfoOld() {\n-    }\n-\n-    \/**\n-     * A Constructor for CustomID.\n-     *\/\n-    public ZoneInfoOld(String ID, int rawOffset) {\n-        this(ID, rawOffset, 0, 0, null, null, null, false);\n-    }\n-\n-    \/**\n-     * Constructs a ZoneInfoOld instance.\n-     *\n-     * @param ID time zone name\n-     * @param rawOffset GMT offset in milliseconds\n-     * @param dstSavings daylight saving value in milliseconds or 0\n-     * (zero) if this time zone doesn't observe Daylight Saving Time.\n-     * @param checksum CRC32 value with all transitions table entry\n-     * values\n-     * @param transitions transition table\n-     * @param offsets offset value table\n-     * @param simpleTimeZoneParams parameter values for constructing\n-     * SimpleTimeZone\n-     * @param willGMTOffsetChange the value of willGMTOffsetChange\n-     *\/\n-    ZoneInfoOld(String ID,\n-             int rawOffset,\n-             int dstSavings,\n-             int checksum,\n-             long[] transitions,\n-             int[] offsets,\n-             int[] simpleTimeZoneParams,\n-             boolean willGMTOffsetChange) {\n-        setID(ID);\n-        this.rawOffset = rawOffset;\n-        this.dstSavings = dstSavings;\n-        this.checksum = checksum;\n-        this.transitions = transitions;\n-        this.offsets = offsets;\n-        this.simpleTimeZoneParams = simpleTimeZoneParams;\n-        this.willGMTOffsetChange = willGMTOffsetChange;\n-    }\n-\n-    \/**\n-     * Returns the difference in milliseconds between local time and UTC\n-     * of given time, taking into account both the raw offset and the\n-     * effect of daylight savings.\n-     *\n-     * @param date the milliseconds in UTC\n-     * @return the milliseconds to add to UTC to get local wall time\n-     *\/\n-    public int getOffset(long date) {\n-        return getOffsets(date, null, UTC_TIME);\n-    }\n-\n-    public int getOffsets(long utc, int[] offsets) {\n-        return getOffsets(utc, offsets, UTC_TIME);\n-    }\n-\n-    public int getOffsetsByStandard(long standard, int[] offsets) {\n-        return getOffsets(standard, offsets, STANDARD_TIME);\n-    }\n-\n-    public int getOffsetsByWall(long wall, int[] offsets) {\n-        return getOffsets(wall, offsets, WALL_TIME);\n-    }\n-\n-    private int getOffsets(long date, int[] offsets, int type) {\n-        \/\/ if dst is never observed, there is no transition.\n-        if (transitions == null) {\n-            int offset = getLastRawOffset();\n-            if (offsets != null) {\n-                offsets[0] = offset;\n-                offsets[1] = 0;\n-            }\n-            return offset;\n-        }\n-\n-        date -= rawOffsetDiff;\n-        int index = getTransitionIndex(date, type);\n-\n-        \/\/ prior to the transition table, returns the raw offset.\n-        \/\/ FIXME: should support LMT.\n-        if (index < 0) {\n-            int offset = getLastRawOffset();\n-            if (offsets != null) {\n-                offsets[0] = offset;\n-                offsets[1] = 0;\n-            }\n-            return offset;\n-        }\n-\n-        if (index < transitions.length) {\n-            long val = transitions[index];\n-            int offset = this.offsets[(int)(val & OFFSET_MASK)] + rawOffsetDiff;\n-            if (offsets != null) {\n-                int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                int save = (dst == 0) ? 0 : this.offsets[dst];\n-                offsets[0] = offset - save;\n-                offsets[1] = save;\n-            }\n-            return offset;\n-        }\n-\n-        \/\/ beyond the transitions, delegate to SimpleTimeZone if there\n-        \/\/ is a rule; otherwise, return rawOffset.\n-        SimpleTimeZone tz = getLastRule();\n-        if (tz != null) {\n-            int rawoffset = tz.getRawOffset();\n-            long msec = date;\n-            if (type != UTC_TIME) {\n-                msec -= rawOffset;\n-            }\n-            int dstoffset = tz.getOffset(msec) - rawOffset;\n-\n-            \/\/ Check if it's in a standard-to-daylight transition.\n-            if (dstoffset > 0 && tz.getOffset(msec - dstoffset) == rawoffset) {\n-                dstoffset = 0;\n-            }\n-\n-            if (offsets != null) {\n-                offsets[0] = rawoffset;\n-                offsets[1] = dstoffset;\n-            }\n-            return rawoffset + dstoffset;\n-        }\n-        int offset = getLastRawOffset();\n-        if (offsets != null) {\n-            offsets[0] = offset;\n-            offsets[1] = 0;\n-        }\n-        return offset;\n-    }\n-\n-    private int getTransitionIndex(long date, int type) {\n-        int low = 0;\n-        int high = transitions.length - 1;\n-\n-        while (low <= high) {\n-            int mid = (low + high) \/ 2;\n-            long val = transitions[mid];\n-            long midVal = val >> TRANSITION_NSHIFT; \/\/ sign extended\n-            if (type != UTC_TIME) {\n-                midVal += offsets[(int)(val & OFFSET_MASK)]; \/\/ wall time\n-            }\n-            if (type == STANDARD_TIME) {\n-                int dstIndex = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                if (dstIndex != 0) {\n-                    midVal -= offsets[dstIndex]; \/\/ make it standard time\n-                }\n-            }\n-\n-            if (midVal < date) {\n-                low = mid + 1;\n-            } else if (midVal > date) {\n-                high = mid - 1;\n-            } else {\n-                return mid;\n-            }\n-        }\n-\n-        \/\/ if beyond the transitions, returns that index.\n-        if (low >= transitions.length) {\n-            return low;\n-        }\n-        return low - 1;\n-    }\n-\n-   \/**\n-     * Returns the difference in milliseconds between local time and\n-     * UTC, taking into account both the raw offset and the effect of\n-     * daylight savings, for the specified date and time.  This method\n-     * assumes that the start and end month are distinct.  This method\n-     * assumes a Gregorian calendar for calculations.\n-     * <p>\n-     * <em>Note: In general, clients should use\n-     * {@link Calendar#ZONE_OFFSET Calendar.get(ZONE_OFFSET)} +\n-     * {@link Calendar#DST_OFFSET Calendar.get(DST_OFFSET)}\n-     * instead of calling this method.<\/em>\n-     *\n-     * @param era       The era of the given date. The value must be either\n-     *                  GregorianCalendar.AD or GregorianCalendar.BC.\n-     * @param year      The year in the given date.\n-     * @param month     The month in the given date. Month is 0-based. e.g.,\n-     *                  0 for January.\n-     * @param day       The day-in-month of the given date.\n-     * @param dayOfWeek The day-of-week of the given date.\n-     * @param millis    The milliseconds in day in <em>standard<\/em> local time.\n-     * @return The milliseconds to add to UTC to get local time.\n-     *\/\n-    public int getOffset(int era, int year, int month, int day,\n-                         int dayOfWeek, int milliseconds) {\n-        if (milliseconds < 0 || milliseconds >= DAY_IN_MILLIS) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (era == java.util.GregorianCalendar.BC) { \/\/ BC\n-            year = 1 - year;\n-        } else if (era != java.util.GregorianCalendar.AD) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        CalendarDate date = gcal.newCalendarDate(null);\n-        date.setDate(year, month + 1, day);\n-        if (gcal.validate(date) == false) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        \/\/ bug-for-bug compatible argument checking\n-        if (dayOfWeek < java.util.GregorianCalendar.SUNDAY\n-            || dayOfWeek > java.util.GregorianCalendar.SATURDAY) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        if (transitions == null) {\n-            return getLastRawOffset();\n-        }\n-\n-        long dateInMillis = gcal.getTime(date) + milliseconds;\n-        dateInMillis -= (long) rawOffset; \/\/ make it UTC\n-        return getOffsets(dateInMillis, null, UTC_TIME);\n-    }\n-\n-    \/**\n-     * Sets the base time zone offset from GMT. This operation\n-     * modifies all the transitions of this ZoneInfoOld object, including\n-     * historical ones, if applicable.\n-     *\n-     * @param offsetMillis the base time zone offset to GMT.\n-     * @see getRawOffset\n-     *\/\n-    public synchronized void setRawOffset(int offsetMillis) {\n-        if (offsetMillis == rawOffset + rawOffsetDiff) {\n-            return;\n-        }\n-        rawOffsetDiff = offsetMillis - rawOffset;\n-        if (lastRule != null) {\n-            lastRule.setRawOffset(offsetMillis);\n-        }\n-        dirty = true;\n-    }\n-\n-    \/**\n-     * Returns the GMT offset of the current date. This GMT offset\n-     * value is not modified during Daylight Saving Time.\n-     *\n-     * @return the GMT offset value in milliseconds to add to UTC time\n-     * to get local standard time\n-     *\/\n-    public int getRawOffset() {\n-        if (!willGMTOffsetChange) {\n-            return rawOffset + rawOffsetDiff;\n-        }\n-\n-        int[] offsets = new int[2];\n-        getOffsets(System.currentTimeMillis(), offsets, UTC_TIME);\n-        return offsets[0];\n-    }\n-\n-    public boolean isDirty() {\n-        return dirty;\n-    }\n-\n-    int getLastRawOffset() {\n-        return rawOffset + rawOffsetDiff;\n-    }\n-\n-    \/**\n-     * Queries if this time zone uses Daylight Saving Time in the last known rule.\n-     *\/\n-    public boolean useDaylightTime() {\n-        return (simpleTimeZoneParams != null);\n-    }\n-\n-    @Override\n-    public boolean observesDaylightTime() {\n-        if (simpleTimeZoneParams != null) {\n-            return true;\n-        }\n-        if (transitions == null) {\n-            return false;\n-        }\n-\n-        \/\/ Look up the transition table to see if it's in DST right\n-        \/\/ now or if there's any standard-to-daylight transition at\n-        \/\/ any future.\n-        long utc = System.currentTimeMillis() - rawOffsetDiff;\n-        int index = getTransitionIndex(utc, UTC_TIME);\n-\n-        \/\/ before transitions in the transition table\n-        if (index < 0) {\n-            return false;\n-        }\n-\n-        \/\/ the time is in the table range.\n-        for (int i = index; i < transitions.length; i++) {\n-            if ((transitions[i] & DST_MASK) != 0) {\n-                return true;\n-            }\n-        }\n-        \/\/ No further DST is observed.\n-        return false;\n-    }\n-\n-    \/**\n-     * Queries if the specified date is in Daylight Saving Time.\n-     *\/\n-    public boolean inDaylightTime(Date date) {\n-        if (date == null) {\n-            throw new NullPointerException();\n-        }\n-\n-        if (transitions == null) {\n-            return false;\n-        }\n-\n-        long utc = date.getTime() - rawOffsetDiff;\n-        int index = getTransitionIndex(utc, UTC_TIME);\n-\n-        \/\/ before transitions in the transition table\n-        if (index < 0) {\n-            return false;\n-        }\n-\n-        \/\/ the time is in the table range.\n-        if (index < transitions.length) {\n-            return (transitions[index] & DST_MASK) != 0;\n-        }\n-\n-        \/\/ beyond the transition table\n-        SimpleTimeZone tz = getLastRule();\n-        if (tz != null) {\n-            return tz.inDaylightTime(date);\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns the amount of time in milliseconds that the clock is advanced\n-     * during daylight saving time is in effect in its last daylight saving time rule.\n-     *\n-     * @return the number of milliseconds the time is advanced with respect to\n-     * standard time when daylight saving time is in effect.\n-     *\/\n-    public int getDSTSavings() {\n-        return dstSavings;\n-    }\n-\n-\/\/    \/**\n-\/\/     * @return the last year in the transition table or -1 if this\n-\/\/     * time zone doesn't observe any daylight saving time.\n-\/\/     *\/\n-\/\/    public int getMaxTransitionYear() {\n-\/\/      if (transitions == null) {\n-\/\/          return -1;\n-\/\/      }\n-\/\/      long val = transitions[transitions.length - 1];\n-\/\/      int offset = this.offsets[(int)(val & OFFSET_MASK)] + rawOffsetDiff;\n-\/\/      val = (val >> TRANSITION_NSHIFT) + offset;\n-\/\/      CalendarDate lastDate = Gregorian.getCalendarDate(val);\n-\/\/      return lastDate.getYear();\n-\/\/    }\n-\n-    \/**\n-     * Returns a string representation of this time zone.\n-     * @return the string\n-     *\/\n-    public String toString() {\n-        return getClass().getName() +\n-            \"[id=\\\"\" + getID() + \"\\\"\" +\n-            \",offset=\" + getLastRawOffset() +\n-            \",dstSavings=\" + dstSavings +\n-            \",useDaylight=\" + useDaylightTime() +\n-            \",transitions=\" + ((transitions != null) ? transitions.length : 0) +\n-            \",lastRule=\" + (lastRule == null ? getLastRuleInstance() : lastRule) +\n-            \"]\";\n-    }\n-\n-    \/**\n-     * Gets all available IDs supported in the Java run-time.\n-     *\n-     * @return an array of time zone IDs.\n-     *\/\n-    public static String[] getAvailableIDs() {\n-        List<String> idList = ZoneInfoFile.getZoneIDs();\n-        List<String> excluded = ZoneInfoFile.getExcludedZones();\n-        if (excluded != null) {\n-            \/\/ List all zones from the idList and excluded lists\n-            List<String> list = new ArrayList<>(idList.size() + excluded.size());\n-            list.addAll(idList);\n-            list.addAll(excluded);\n-            idList = list;\n-        }\n-        String[] ids = new String[idList.size()];\n-        return idList.toArray(ids);\n-    }\n-\n-    \/**\n-     * Gets all available IDs that have the same value as the\n-     * specified raw GMT offset.\n-     *\n-     * @param rawOffset the GMT offset in milliseconds. This\n-     * value should not include any daylight saving time.\n-     *\n-     * @return an array of time zone IDs.\n-     *\/\n-    public static String[] getAvailableIDs(int rawOffset) {\n-        String[] result;\n-        List<String> matched = new ArrayList<>();\n-        List<String> IDs = ZoneInfoFile.getZoneIDs();\n-        int[] rawOffsets = ZoneInfoFile.getRawOffsets();\n-\n-    loop:\n-        for (int index = 0; index < rawOffsets.length; index++) {\n-            if (rawOffsets[index] == rawOffset) {\n-                byte[] indices = ZoneInfoFile.getRawOffsetIndices();\n-                for (int i = 0; i < indices.length; i++) {\n-                    if (indices[i] == index) {\n-                        matched.add(IDs.get(i++));\n-                        while (i < indices.length && indices[i] == index) {\n-                            matched.add(IDs.get(i++));\n-                        }\n-                        break loop;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ We need to add any zones from the excluded zone list that\n-        \/\/ currently have the same GMT offset as the specified\n-        \/\/ rawOffset. The zones returned by this method may not be\n-        \/\/ correct as of return to the caller if any GMT offset\n-        \/\/ transition is happening during this GMT offset checking...\n-        List<String> excluded = ZoneInfoFile.getExcludedZones();\n-        if (excluded != null) {\n-            for (String id : excluded) {\n-                TimeZone zi = getTimeZone(id);\n-                if (zi != null && zi.getRawOffset() == rawOffset) {\n-                    matched.add(id);\n-                }\n-            }\n-        }\n-\n-        result = new String[matched.size()];\n-        matched.toArray(result);\n-        return result;\n-    }\n-\n-    \/**\n-     * Gets the ZoneInfoOld for the given ID.\n-     *\n-     * @param ID the ID for a ZoneInfoOld. See TimeZone for detail.\n-     *\n-     * @return the specified ZoneInfoOld object, or null if there is no\n-     * time zone of the ID.\n-     *\/\n-    public static TimeZone getTimeZone(String ID) {\n-        String givenID = null;\n-\n-        ZoneInfoOld zi = ZoneInfoFile.getZoneInfoOld(ID);\n-        if (zi == null) {\n-            \/\/ if we can't create an object for the ID, try aliases.\n-            try {\n-                Map<String, String> map = getAliasTable();\n-                String alias = ID;\n-                while ((alias = map.get(alias)) != null) {\n-                    zi = ZoneInfoFile.getZoneInfoOld(alias);\n-                    if (zi != null) {\n-                        zi.setID(ID);\n-                        zi = ZoneInfoFile.addToCache(ID, zi);\n-                        zi = (ZoneInfoOld) zi.clone();\n-                        break;\n-                    }\n-                }\n-            } catch (Exception e) {\n-                \/\/ ignore exceptions\n-            }\n-        }\n-\n-        if (givenID != null && zi != null) {\n-            zi.setID(givenID);\n-        }\n-        return zi;\n-    }\n-\n-    private transient SimpleTimeZone lastRule;\n-\n-    \/**\n-     * Returns a SimpleTimeZone object representing the last GMT\n-     * offset and DST schedule or null if this time zone doesn't\n-     * observe DST.\n-     *\/\n-    synchronized SimpleTimeZone getLastRule() {\n-        if (lastRule == null) {\n-            lastRule = getLastRuleInstance();\n-        }\n-        return lastRule;\n-    }\n-\n-    \/**\n-     * Returns a SimpleTimeZone object that represents the last\n-     * known daylight saving time rules.\n-     *\n-     * @return a SimpleTimeZone object or null if this time zone\n-     * doesn't observe DST.\n-     *\/\n-    public SimpleTimeZone getLastRuleInstance() {\n-        if (simpleTimeZoneParams == null) {\n-            return null;\n-        }\n-        if (simpleTimeZoneParams.length == 10) {\n-            return new SimpleTimeZone(getLastRawOffset(), getID(),\n-                                      simpleTimeZoneParams[0],\n-                                      simpleTimeZoneParams[1],\n-                                      simpleTimeZoneParams[2],\n-                                      simpleTimeZoneParams[3],\n-                                      simpleTimeZoneParams[4],\n-                                      simpleTimeZoneParams[5],\n-                                      simpleTimeZoneParams[6],\n-                                      simpleTimeZoneParams[7],\n-                                      simpleTimeZoneParams[8],\n-                                      simpleTimeZoneParams[9],\n-                                      dstSavings);\n-        }\n-        return new SimpleTimeZone(getLastRawOffset(), getID(),\n-                                  simpleTimeZoneParams[0],\n-                                  simpleTimeZoneParams[1],\n-                                  simpleTimeZoneParams[2],\n-                                  simpleTimeZoneParams[3],\n-                                  simpleTimeZoneParams[4],\n-                                  simpleTimeZoneParams[5],\n-                                  simpleTimeZoneParams[6],\n-                                  simpleTimeZoneParams[7],\n-                                  dstSavings);\n-    }\n-\n-    \/**\n-     * Returns a copy of this <code>ZoneInfoOld<\/code>.\n-     *\/\n-    public Object clone() {\n-        ZoneInfoOld zi = (ZoneInfoOld) super.clone();\n-        zi.lastRule = null;\n-        return zi;\n-    }\n-\n-    \/**\n-     * Returns a hash code value calculated from the GMT offset and\n-     * transitions.\n-     * @return a hash code of this time zone\n-     *\/\n-    public int hashCode() {\n-        return getLastRawOffset() ^ checksum;\n-    }\n-\n-    \/**\n-     * Compares the equity of two ZoneInfoOld objects.\n-     *\n-     * @param obj the object to be compared with\n-     * @return true if given object is same as this ZoneInfoOld object,\n-     * false otherwise.\n-     *\/\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        }\n-        if (!(obj instanceof ZoneInfoOld)) {\n-            return false;\n-        }\n-        ZoneInfoOld that = (ZoneInfoOld) obj;\n-        return (getID().equals(that.getID())\n-                && (getLastRawOffset() == that.getLastRawOffset())\n-                && (checksum == that.checksum));\n-    }\n-\n-    \/**\n-     * Returns true if this zone has the same raw GMT offset value and\n-     * transition table as another zone info. If the specified\n-     * TimeZone object is not a ZoneInfoOld instance, this method returns\n-     * true if the specified TimeZone object has the same raw GMT\n-     * offset value with no daylight saving time.\n-     *\n-     * @param other the ZoneInfoOld object to be compared with\n-     * @return true if the given <code>TimeZone<\/code> has the same\n-     * GMT offset and transition information; false, otherwise.\n-     *\/\n-    public boolean hasSameRules(TimeZone other) {\n-        if (this == other) {\n-            return true;\n-        }\n-        if (other == null) {\n-            return false;\n-        }\n-        if (!(other instanceof ZoneInfoOld)) {\n-            if (getRawOffset() != other.getRawOffset()) {\n-                return false;\n-            }\n-            \/\/ if both have the same raw offset and neither observes\n-            \/\/ DST, they have the same rule.\n-            if ((transitions == null)\n-                && (useDaylightTime() == false)\n-                && (other.useDaylightTime() == false)) {\n-                return true;\n-            }\n-            return false;\n-        }\n-        if (getLastRawOffset() != ((ZoneInfoOld)other).getLastRawOffset()) {\n-            return false;\n-        }\n-        return (checksum == ((ZoneInfoOld)other).checksum);\n-    }\n-\n-    private static SoftReference<Map<String, String>> aliasTable;\n-\n-    static Map<String, String> getCachedAliasTable() {\n-        Map<String, String> aliases = null;\n-\n-        SoftReference<Map<String, String>> cache = aliasTable;\n-        if (cache != null) {\n-            aliases = cache.get();\n-        }\n-        return aliases;\n-    }\n-\n-    \/**\n-     * Returns a Map from alias time zone IDs to their standard\n-     * time zone IDs.\n-     *\n-     * @return the Map that holds the mappings from alias time zone IDs\n-     *    to their standard time zone IDs, or null if\n-     *    <code>ZoneInfoOldMappings<\/code> file is not available.\n-     *\/\n-     public synchronized static Map<String, String> getAliasTable() {\n-         Map<String, String> aliases = getCachedAliasTable();\n-         if (aliases == null) {\n-             aliases = ZoneInfoFile.getZoneAliases();\n-             if (aliases != null) {\n-                 \/\/ Replace old mappings from `jdk11_backward`\n-                 aliases.putAll(conflictingIDs);\n-                 aliasTable = new SoftReference<Map<String, String>>(aliases);\n-             }\n-         }\n-         return aliases;\n-     }\n-\n-    private void readObject(ObjectInputStream stream)\n-            throws IOException, ClassNotFoundException {\n-        stream.defaultReadObject();\n-        \/\/ We don't know how this object from 1.4.x or earlier has\n-        \/\/ been mutated. So it should always be marked as `dirty'.\n-        dirty = true;\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    public boolean equalsTo(ZoneInfoOld other) {\n-        return (getID().equals(other.getID())\n-                && (getLastRawOffset() == other.getLastRawOffset())\n-                && (dstSavings == other.dstSavings)\n-                && (willGMTOffsetChange == other.willGMTOffsetChange)\n-                && (checksum == other.checksum)\n-                && equalsTransOffsets(other)\n-                && (Arrays.equals(simpleTimeZoneParams, other.simpleTimeZoneParams) ||\n-                    getLastRule().equals(other.getLastRule())));\n-    }\n-\n-    private boolean equalsTransOffsets(ZoneInfoOld other) {\n-        if (transitions == null) {\n-            return (other.transitions == null &&\n-                    Arrays.equals(offsets, other.offsets));\n-        }\n-        if (other.transitions == null ||\n-            transitions.length != other.transitions.length) {\n-            return false;\n-        }\n-        \/\/ if offsets and other.offsets have different order\n-        \/\/ the last 4-bit in trans are different.\n-        for (int i = 0; i < transitions.length; i++) {\n-            long val = transitions[i];\n-            int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-            int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-            int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-            long second = (val >> TRANSITION_NSHIFT)\/1000;\n-\n-            val = other.transitions[i];\n-            int dstO = (int)((val >>> DST_NSHIFT) & 0xfL);\n-            int saveO = (dstO == 0) ? 0 : other.offsets[dstO] \/ 1000;\n-            int offO = other.offsets[(int)(val & OFFSET_MASK)]\/1000;\n-            long secondO = (val >> TRANSITION_NSHIFT)\/1000;\n-            if ((dst == 0) != (dstO == 0) || save != saveO || off != offO || second != secondO)\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    private int transToString(long val, int off_old, int[] offsets, StringBuilder sb) {\n-        int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-        int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-        int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-        long second = (val >> TRANSITION_NSHIFT)\/1000;\n-        ZoneOffset offset_old = ZoneOffset.ofTotalSeconds(off_old);\n-        ZoneOffset offset = ZoneOffset.ofTotalSeconds(off);\n-        sb.append(\"          \" + LocalDateTime.ofEpochSecond(second, 0, offset_old));\n-\n-        sb.append(\"  [utc=\" + second +\n-                  \"   raw=\" + Long.toHexString(val >> TRANSITION_NSHIFT) +\n-                  \", offset=\" + off + \"\/\" + offset + \", saving=\" + save + \"]\");\n-        return off;\n-    }\n-\n-    public String diffsTo(ZoneInfoOld other) {\n-\n-        int rawOffset0                = other.rawOffset;\n-        int checksum0                 = other.checksum;\n-        int dstSavings0               = other.dstSavings;\n-        long[] transitions0           = other.transitions;\n-        int[] offsets0                = other.offsets;\n-        int[] simpleTimeZoneParams0   = other.simpleTimeZoneParams;\n-        boolean willGMTOffsetChange0  = other.willGMTOffsetChange;\n-\n-\n-        \/\/return getClass().getName() +\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"******************************\\n\" +\n-                  getID() + \" : \" + other.getID());\n-        \/\/ ROC is excluded by ZoneInfoOld\n-        if (\"ROC\".equals(getID())) {\n-            return sb.toString();\n-        }\n-        if (rawOffset != rawOffset0 ||\n-            dstSavings != dstSavings0 ||\n-            checksum != checksum0 ||\n-            willGMTOffsetChange != willGMTOffsetChange0 ||\n-            (simpleTimeZoneParams != null ) != (simpleTimeZoneParams0 != null) ||\n-            (transitions != null && transitions0 != null &&\n-            transitions.length != transitions0.length))\n-        {\n-            sb.append(\"\\n    offset=\" + getLastRawOffset() +\n-                  \",dstSavings=\" + dstSavings +\n-                  \",useDaylight=\" + useDaylightTime() +\n-                  \",transitions=\" + ((transitions != null) ? transitions.length : 0) +\n-                  \",offsets=\" + ((offsets != null) ? offsets.length : 0) +\n-                  \",checksum=\" + checksum +\n-                  \",gmtChanged=\" + willGMTOffsetChange)\n-              .append(\"\\n[NG]offset=\" + rawOffset0 +\n-                      \",dstSavings=\" + dstSavings0 +\n-                      \",useDaylight=\" + (simpleTimeZoneParams != null) +\n-                      \",transitions=\" + ((transitions0 != null) ? transitions0.length : 0) +\n-                      \",offsets=\" + ((offsets0 != null) ? offsets0.length : 0) +\n-                      \",checksum=\" + checksum0 +\n-                      \",gmtChanged=\" + willGMTOffsetChange0 +\n-                      \"\");\n-        }\n-        \/\/ offsets\n-        if (!Arrays.equals(offsets, offsets0)) {\n-            sb.append(\"\\n    offset.len=\" + ((offsets != null)? offsets.length : \"null\") +\n-                      \"    \" + ((offsets0 != null)? offsets0.length : \"null\"));\n-            if (offsets != null && offsets0.length != 0) {\n-                int len = Math.min(offsets.length, offsets0.length);\n-                int i = 0;\n-                for (i = 0; i < len; i++) {\n-                    sb.append(\"\\n        \" +\n-                              ZoneOffset.ofTotalSeconds(offsets[i]\/1000) + \"    \" +\n-                              ZoneOffset.ofTotalSeconds(offsets0[i]\/1000));\n-                }\n-                for (; i < offsets0.length; i++) {\n-                    sb.append(\"\\n                  \" + ZoneOffset.ofTotalSeconds(offsets0[i]\/1000));\n-                }\n-            }\n-        }\n-        \/\/ trans\n-        int offset = 0;\n-        int offset0 = 0;\n-        if (!equalsTransOffsets(other)) {\n-            sb.append(\"\\n    -------------\");\n-            if ((transitions == null) != (transitions0 == null)) {\n-                sb.append(\"\\n     (NG) Different trans(null) :\" +\n-                transitions + \", \" + transitions0);\n-                if (transitions != null) {\n-                    for (int i = 0; i < transitions.length; i++) {\n-                        sb.append(\"\\n    (NG)\");\n-                        offset = transToString(transitions[i], offset, offsets, sb);\n-                    }\n-                }\n-            } else {\n-                if (transitions.length != transitions0.length) {\n-                    sb.append(\"\\n    (NG) Different trans size :\" +\n-                              transitions.length + \", \" + transitions0.length);\n-                }\n-                int length = Math.min(transitions.length, transitions0.length);\n-                for (int i = 0; i < length; i++) {\n-                    \/\/ sb.append(\"\\n[\" + i + \"]    \");\n-                    \/\/ offset = transToString(transitions[i], offset, offsets, sb);\n-                    long val = transitions[i];\n-                    int dst = (int)((val >>> DST_NSHIFT) & 0xfL);\n-                    int save = (dst == 0) ? 0 : offsets[dst] \/ 1000;\n-                    int off = offsets[(int)(val & OFFSET_MASK)]\/1000;\n-                    long second = (val >> TRANSITION_NSHIFT)\/1000;\n-                    sb.append(\"\\n        \");\n-                    offset = transToString(transitions[i], offset, offsets, sb);\n-                    if (transitions0 == null || i >= transitions0.length) {\n-                        sb.append(\"\\n    \");\n-                        offset = transToString(transitions[i], offset, offsets, sb);\n-                        sb.append(\"\\n     (NG) trans0 is null or < trans.length\");\n-                    } else {\n-                        long val0 = transitions0[i];\n-                        int dst0 = (int)((val0 >>> DST_NSHIFT) & 0xfL);\n-                        int save0 = (dst0 == 0) ? 0 : offsets0[dst0] \/ 1000;\n-                        int off0 = offsets0[(int)(val0 & OFFSET_MASK)]\/1000;\n-                        long second0 = (val0 >> TRANSITION_NSHIFT)\/1000;\n-                        if (save != save0 || off != off0 || second != second0) {\n-                            sb.append(\"\\n    (NG)\");\n-                        } else {\n-                            sb.append(\"\\n    (OK)\");\n-                        }\n-                        offset0 = transToString(transitions0[i], offset0, offsets0, sb);\n-                        sb.append(\"\\n            -----\");\n-                    }\n-                }\n-            }\n-        }\n-        SimpleTimeZone stz = getLastRuleInstance();\n-        if (stz != null) {\n-            SimpleTimeZone stz0 = other.getLastRule();\n-            if (!stz.hasSameRules(stz0)) {\n-                sb.append(\"\\n    -------------\")\n-                  .append(\"\\n    SimpleTimeZone (NG)\")\n-                  .append(\"\\n       stz=\" + stz)\n-                  .append(\"\\n      stz0=\" + stz0);\n-            }\n-        }\n-        sb.append(\"\\n    -------------\");\n-        return sb.toString();\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneInfoOld.java","additions":0,"deletions":1022,"binary":false,"changes":1022,"status":"deleted"},{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * ZoneRec hold information of time zone corresponding to each text\n- * line of the \"Zone\" part.\n- *\n- * @since 1.4\n- *\/\n-class ZoneRec {\n-    private int gmtOffset;\n-    private String ruleName;\n-    private int directSave;\n-    private Rule ruleRef;\n-    private String format;\n-    private boolean hasUntil;\n-    private int untilYear;\n-    private Month untilMonth;\n-    private RuleDay untilDay;\n-    private Time untilTime;\n-    private long untilInMillis;\n-    private String line;\n-\n-    \/**\n-     * @return the \"UNTIL\" value in milliseconds\n-     *\/\n-    Time getUntilTime() {\n-        return untilTime;\n-    }\n-\n-    \/**\n-     * @return the GMT offset value in milliseconds\n-     *\/\n-    int getGmtOffset() {\n-        return gmtOffset;\n-    }\n-\n-    \/**\n-     * @return the rule name to which this zone record refers\n-     *\/\n-    String getRuleName() {\n-        return ruleName;\n-    }\n-\n-    \/**\n-     * @return the amount of saving time directly defined in the\n-     * \"RULES\/SAVE\" field.\n-     *\/\n-    int getDirectSave() {\n-        return directSave;\n-    }\n-\n-    \/**\n-     * @return true if this zone record has a reference to a rule\n-     *\/\n-    boolean hasRuleReference() {\n-        return ruleRef != null;\n-    }\n-\n-    \/**\n-     * Returns the \"FORMAT\" field string of this zone record. This\n-     * @return the \"FORMAT\" field\n-     *\/\n-    String getFormat() {\n-        return format;\n-    }\n-\n-    \/**\n-     * @return the year in the \"UNTIL\" field\n-     *\/\n-    int getUntilYear() {\n-        return untilYear;\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" field value in milliseconds from Janurary\n-     * 1, 1970 0:00 GMT.\n-     * @param currentSave the amount of daylight saving in\n-     * milliseconds that is used to adjust wall-clock time.\n-     * @return the milliseconds value of the \"UNTIL\" field\n-     *\/\n-    long getUntilTime(int currentSave) {\n-        if (untilTime.isWall()) {\n-            return untilInMillis - currentSave;\n-        }\n-        return untilInMillis;\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" time in milliseconds without adjusting GMT\n-     * offsets or daylight saving.\n-     * @return local \"UNTIL\" time in milliseconds\n-     *\/\n-    long getLocalUntilTime() {\n-        return Time.getLocalTime(untilYear,\n-                                 untilMonth,\n-                                 untilDay,\n-                                 untilTime.getTime());\n-    }\n-\n-    \/**\n-     * Returns the \"UNTIL\" time in milliseconds with adjusting GMT offsets and daylight saving.\n-     * @return the \"UNTIL\" time after the adjustment\n-     *\/\n-    long getLocalUntilTime(int save, int gmtOffset) {\n-        return Time.getLocalTime(untilYear,\n-                                 untilMonth,\n-                                 untilDay,\n-                                 save,\n-                                 gmtOffset,\n-                                 untilTime);\n-    }\n-\n-    \/**\n-     * @return the text line of this zone record\n-     *\/\n-    String getLine() {\n-        return line;\n-    }\n-\n-    \/**\n-     * Sets the specified text line to this zone record\n-     *\/\n-    void setLine(String line) {\n-        this.line = line;\n-    }\n-\n-    \/**\n-     * @return true if this zone record has the \"UNTIL\" field\n-     *\/\n-    boolean hasUntil() {\n-        return this.hasUntil;\n-    }\n-\n-    \/**\n-     * Adjusts the \"UNTIL\" time to GMT offset if this zone record has\n-     * it.  <code>untilTime<\/code> is not adjusted to daylight saving\n-     * in this method.\n-     *\/\n-    void adjustTime() {\n-        if (!hasUntil()) {\n-            return;\n-        }\n-        if (untilTime.isSTD() || untilTime.isWall()) {\n-            \/\/ adjust to gmt offset only here.  adjust to real\n-            \/\/ wall-clock time when tracking rules\n-            untilInMillis -= gmtOffset;\n-        }\n-    }\n-\n-    \/**\n-     * @return the reference to the Rule object\n-     *\/\n-    Rule getRuleRef() {\n-        return ruleRef;\n-    }\n-\n-    \/**\n-     * Resolves the reference to a Rule and adjusts its \"UNTIL\" time\n-     * to GMT offset.\n-     *\/\n-    void resolve(Zoneinfo zi) {\n-        if (ruleName != null && (!\"-\".equals(ruleName))) {\n-                ruleRef = zi.getRule(ruleName);\n-        }\n-        adjustTime();\n-    }\n-\n-    \/**\n-     * Parses a Zone text line that is described by a StringTokenizer.\n-     * @param tokens represents tokens of a Zone text line\n-     * @return the zone record produced by parsing the text\n-     *\/\n-    static ZoneRec parse(StringTokenizer tokens) {\n-        ZoneRec rec = new ZoneRec();\n-        try {\n-            rec.gmtOffset = (int) Time.parse(tokens.nextToken()).getTime();\n-            String token = tokens.nextToken();\n-            char c = token.charAt(0);\n-            if (c >= '0' && c <= '9') {\n-                rec.directSave = (int) Time.parse(token).getTime();\n-            } else {\n-                rec.ruleName = token;\n-            }\n-            rec.format = tokens.nextToken();\n-            if (tokens.hasMoreTokens()) {\n-                rec.hasUntil = true;\n-                rec.untilYear = Integer.parseInt(tokens.nextToken());\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilMonth = Month.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilMonth = Month.JANUARY;\n-                }\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilDay = RuleDay.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilDay = new RuleDay(1);\n-                }\n-                if (tokens.hasMoreTokens()) {\n-                    rec.untilTime = Time.parse(tokens.nextToken());\n-                } else {\n-                    rec.untilTime = Time.parse(\"0:00\");\n-                }\n-                rec.untilInMillis = rec.getLocalUntilTime();\n-            }\n-        } catch (Exception e) {\n-            \/\/ TODO: error reporting\n-            e.printStackTrace();\n-        }\n-        return rec;\n-    }\n-\n-    private static void panic(String msg) {\n-        Main.panic(msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/ZoneRec.java","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -1,579 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * Zoneinfo provides javazic compiler front-end functionality.\n- * @since 1.4\n- *\/\n-class Zoneinfo {\n-\n-    private static final int minYear = 1900;\n-    private static final int maxYear = 2100;\n-    private static final long minTime = Time.getLocalTime(minYear, Month.JANUARY, 1, 0);\n-    private static int startYear = minYear;\n-    private static int endYear = maxYear;\n-\n-    \/**\n-     * True if javazic should generate a list of SimpleTimeZone\n-     * instances for the SimpleTimeZone-based time zone support.\n-     *\/\n-    static boolean isYearForTimeZoneDataSpecified = false;\n-\n-    \/**\n-     * Zone name to Zone mappings\n-     *\/\n-    private Map<String,Zone> zones;\n-\n-    \/**\n-     * Rule name to Rule mappings\n-     *\/\n-    private Map<String,Rule> rules;\n-\n-    \/**\n-     * Alias name to real name mappings\n-     *\/\n-    private Map<String,String> aliases;\n-\n-    \/**\n-     * Constracts a Zoneinfo.\n-     *\/\n-    Zoneinfo() {\n-        zones = new HashMap<String,Zone>();\n-        rules = new HashMap<String,Rule>();\n-        aliases = new HashMap<String,String>();\n-    }\n-\n-    \/**\n-     * Adds the given zone to the list of Zones.\n-     * @param zone Zone to be added to the list.\n-     *\/\n-    void add(Zone zone) {\n-        String name = zone.getName();\n-        zones.put(name, zone);\n-    }\n-\n-    \/**\n-     * Adds the given rule to the list of Rules.\n-     * @param rule Rule to be added to the list.\n-     *\/\n-    void add(Rule rule) {\n-        String name = rule.getName();\n-        rules.put(name, rule);\n-    }\n-\n-    \/**\n-     * Puts the specifid name pair to the alias table.\n-     * @param name1 an alias time zone name\n-     * @param name2 the real time zone of the alias name\n-     *\/\n-    void putAlias(String name1, String name2) {\n-        aliases.put(name1, name2);\n-    }\n-\n-    \/**\n-     * Sets the given year for SimpleTimeZone list output.\n-     * This method is called when the -S option is specified.\n-     * @param year the year for which SimpleTimeZone list should be generated\n-     *\/\n-    static void setYear(int year) {\n-        setStartYear(year);\n-        setEndYear(year);\n-        isYearForTimeZoneDataSpecified = true;\n-    }\n-\n-    \/**\n-     * Sets the start year.\n-     * @param year the start year value\n-     * @throws IllegalArgumentException if the specified year value is\n-     * smaller than the minimum year or greater than the end year.\n-     *\/\n-    static void setStartYear(int year) {\n-        if (year < minYear || year > endYear) {\n-            throw new IllegalArgumentException(\"invalid start year specified: \" + year);\n-        }\n-        startYear = year;\n-    }\n-\n-    \/**\n-     * @return the start year value\n-     *\/\n-    static int getStartYear() {\n-        return startYear;\n-    }\n-\n-    \/**\n-     * Sets the end year.\n-     * @param year the end year value\n-     * @throws IllegalArgumentException if the specified year value is\n-     * smaller than the start year or greater than the maximum year.\n-     *\/\n-    static void setEndYear(int year) {\n-        if (year < startYear || year > maxYear) {\n-            throw new IllegalArgumentException();\n-        }\n-        endYear = year;\n-    }\n-\n-    \/**\n-     * @return the end year value\n-     *\/\n-    static int getEndYear() {\n-        return endYear;\n-    }\n-\n-    \/**\n-     * @return the minimum year value\n-     *\/\n-    static int getMinYear() {\n-        return minYear;\n-    }\n-\n-    \/**\n-     * @return the maximum year value\n-     *\/\n-    static int getMaxYear() {\n-        return maxYear;\n-    }\n-\n-    \/**\n-     * @return the alias table\n-     *\/\n-    Map<String,String> getAliases() {\n-        return aliases;\n-    }\n-\n-    \/**\n-     * @return the Zone list\n-     *\/\n-    Map<String,Zone> getZones() {\n-        return zones;\n-    }\n-\n-    \/**\n-     * @return a Zone specified by name.\n-     * @param name a zone name\n-     *\/\n-    Zone getZone(String name) {\n-        return zones.get(name);\n-    }\n-\n-    \/**\n-     * @return a Rule specified by name.\n-     * @param name a rule name\n-     *\/\n-    Rule getRule(String name) {\n-        return rules.get(name);\n-    }\n-\n-    private static String line;\n-\n-    private static int lineNum;\n-\n-    \/**\n-     * Parses the specified time zone data file and creates a Zoneinfo\n-     * that has all Rules, Zones and Links (aliases) information.\n-     * @param fname the time zone data file name\n-     * @return a Zoneinfo object\n-     *\/\n-    static Zoneinfo parse(String fname) {\n-        BufferedReader in = null;\n-        try {\n-            FileReader fr = new FileReader(fname);\n-            in = new BufferedReader(fr);\n-        } catch (FileNotFoundException e) {\n-            panic(\"can't open file: \"+fname);\n-        }\n-        Zoneinfo zi = new Zoneinfo();\n-        boolean continued = false;\n-        Zone zone = null;\n-        String l;\n-        lineNum = 0;\n-\n-        try {\n-            while ((line = in.readLine()) != null) {\n-                lineNum++;\n-                \/\/ skip blank and comment lines\n-                if (line.length() == 0 || line.charAt(0) == '#') {\n-                    continue;\n-                }\n-\n-                \/\/ trim trailing comments\n-                int rindex = line.lastIndexOf('#');\n-                if (rindex != -1) {\n-                    \/\/ take the data part of the line\n-                    l = line.substring(0, rindex);\n-                } else {\n-                    l = line;\n-                }\n-\n-                StringTokenizer tokens = new StringTokenizer(l);\n-                if (!tokens.hasMoreTokens()) {\n-                    continue;\n-                }\n-                String token = tokens.nextToken();\n-                int len = token.length();\n-\n-                if (continued || token.regionMatches(true, 0, \"Zone\", 0, len)){\n-                    if (zone == null) {\n-                        if (!tokens.hasMoreTokens()) {\n-                            panic(\"syntax error: zone no more token\");\n-                        }\n-                        token = tokens.nextToken();\n-                        \/\/ if the zone name is in \"GMT+hh\" or \"GMT-hh\"\n-                        \/\/ format, ignore it due to spec conflict.\n-                        if (token.startsWith(\"GMT+\") || token.startsWith(\"GMT-\")) {\n-                            continue;\n-                        }\n-                        zone = new Zone(token);\n-                    } else {\n-                        \/\/ no way to push the current token back...\n-                        tokens = new StringTokenizer(l);\n-                    }\n-\n-                    ZoneRec zrec = ZoneRec.parse(tokens);\n-                    zrec.setLine(line);\n-                    zone.add(zrec);\n-                    if ((continued = zrec.hasUntil()) == false) {\n-                        if (Zone.isTargetZone(zone.getName())) {\n-                            \/\/ zone.resolve(zi);\n-                            zi.add(zone);\n-                        }\n-                        zone = null;\n-                    }\n-                } else if (token.regionMatches(true, 0, \"Rule\", 0, len)) {\n-                    if (!tokens.hasMoreTokens()) {\n-                        panic(\"syntax error: rule no more token\");\n-                    }\n-                    token = tokens.nextToken();\n-                    Rule rule = zi.getRule(token);\n-                    if (rule == null) {\n-                        rule = new Rule(token);\n-                        zi.add(rule);\n-                    }\n-                    RuleRec rrec = RuleRec.parse(tokens);\n-                    rrec.setLine(line);\n-                    rule.add(rrec);\n-                } else if (token.regionMatches(true, 0, \"Link\", 0, len)) {\n-                    \/\/ Link <newname> <oldname>\n-                    try {\n-                        String name1 = tokens.nextToken();\n-                        String name2 = tokens.nextToken();\n-\n-                        \/\/ if the zone name is in \"GMT+hh\" or \"GMT-hh\"\n-                        \/\/ format, ignore it due to spec conflict with\n-                        \/\/ custom time zones. Also, ignore \"ROC\" for\n-                        \/\/ PC-ness.\n-                        if (name2.startsWith(\"GMT+\") || name2.startsWith(\"GMT-\")\n-                            || \"ROC\".equals(name2)) {\n-                            continue;\n-                        }\n-                        zi.putAlias(name2, name1);\n-                    } catch (Exception e) {\n-                        panic(\"syntax error: no more token for Link\");\n-                    }\n-                }\n-            }\n-            in.close();\n-        } catch (IOException ex) {\n-            panic(\"IO error: \" + ex.getMessage());\n-        }\n-\n-        return zi;\n-    }\n-\n-    \/**\n-     * Interprets a zone and constructs a Timezone object that\n-     * contains enough information on GMT offsets and DST schedules to\n-     * generate a zone info database.\n-     *\n-     * @param zoneName the zone name for which a Timezone object is\n-     * constructed.\n-     *\n-     * @return a Timezone object that contains all GMT offsets and DST\n-     * rules information.\n-     *\/\n-    Timezone phase2(String zoneName) {\n-        Timezone tz = new Timezone(zoneName);\n-        Zone zone = getZone(zoneName);\n-        zone.resolve(this);\n-\n-        \/\/ TODO: merge phase2's for the regular and SimpleTimeZone ones.\n-        if (isYearForTimeZoneDataSpecified) {\n-            ZoneRec zrec = zone.get(zone.size()-1);\n-            tz.setLastZoneRec(zrec);\n-            tz.setRawOffset(zrec.getGmtOffset());\n-            if (zrec.hasRuleReference()) {\n-                \/*\n-                 * This part assumes that the specified year is covered by\n-                 * the rules referred to by the last zone record.\n-                 *\/\n-                List<RuleRec> rrecs = zrec.getRuleRef().getRules(startYear);\n-\n-                if (rrecs.size() == 2) {\n-                    \/\/ make sure that one is a start rule and the other is\n-                    \/\/ an end rule.\n-                    RuleRec r0 = rrecs.get(0);\n-                    RuleRec r1 = rrecs.get(1);\n-                    if (r0.getSave() == 0 && r1.getSave() > 0) {\n-                        rrecs.set(0, r1);\n-                        rrecs.set(1, r0);\n-                    } else if (!(r0.getSave() > 0 && r1.getSave() == 0)) {\n-                        rrecs = null;\n-                        Main.error(zoneName + \": rules for \" +  startYear + \" not found.\");\n-                    }\n-                } else {\n-                    rrecs = null;\n-                }\n-                if (rrecs != null) {\n-                    tz.setLastRules(rrecs);\n-                }\n-            }\n-            return tz;\n-        }\n-\n-        int gmtOffset;\n-        int year = minYear;\n-        int fromYear = year;\n-        long fromTime = Time.getLocalTime(startYear,\n-                                          Month.JANUARY,\n-                                          1, 0);\n-\n-        \/\/ take the index 0 for the GMT offset of the last zone record\n-        ZoneRec zrec = zone.get(zone.size()-1);\n-        tz.getOffsetIndex(zrec.getGmtOffset());\n-\n-        int lastGmtOffsetValue = -1;\n-        ZoneRec prevzrec = null;\n-        int currentSave = 0;\n-        boolean usedZone;\n-        for (int zindex = 0; zindex < zone.size(); zindex++) {\n-            zrec = zone.get(zindex);\n-            usedZone = false;\n-            gmtOffset = zrec.getGmtOffset();\n-            int stdOffset = zrec.getDirectSave();\n-\n-            if (gmtOffset != lastGmtOffsetValue) {\n-                tz.setRawOffset(gmtOffset, fromTime);\n-                lastGmtOffsetValue = gmtOffset;\n-            }\n-            \/\/ If this is the last zone record, take the last rule info.\n-            if (!zrec.hasUntil()) {\n-                if (zrec.hasRuleReference()) {\n-                    tz.setLastRules(zrec.getRuleRef().getLastRules());\n-                } else if (stdOffset != 0) {\n-                    \/\/ in case the last rule is all year round DST-only\n-                    \/\/ (Asia\/Amman once announced this rule.)\n-                    tz.setLastDSTSaving(stdOffset);\n-                }\n-            }\n-            if (!zrec.hasRuleReference()) {\n-                if (!zrec.hasUntil() || zrec.getUntilTime(stdOffset) >= fromTime) {\n-                    tz.addTransition(fromTime,\n-                                     tz.getOffsetIndex(gmtOffset+stdOffset),\n-                                     tz.getDstOffsetIndex(stdOffset));\n-                    usedZone = true;\n-                }\n-                currentSave = stdOffset;\n-                \/\/ optimization in case the last rule is fixed.\n-                if (!zrec.hasUntil()) {\n-                    if (tz.getNTransitions() > 0) {\n-                        if (stdOffset == 0) {\n-                            tz.setDSTType(Timezone.X_DST);\n-                        } else {\n-                            tz.setDSTType(Timezone.LAST_DST);\n-                        }\n-                        long time = Time.getLocalTime(maxYear,\n-                                                      Month.JANUARY, 1, 0);\n-                        time -= zrec.getGmtOffset();\n-                        tz.addTransition(time,\n-                                         tz.getOffsetIndex(gmtOffset+stdOffset),\n-                                         tz.getDstOffsetIndex(stdOffset));\n-                        tz.addUsedRec(zrec);\n-                    } else {\n-                        tz.setDSTType(Timezone.NO_DST);\n-                    }\n-                    break;\n-                }\n-            } else {\n-                Rule rule = zrec.getRuleRef();\n-                boolean fromTimeUsed = false;\n-                currentSave = 0;\n-            year_loop:\n-                for (year = getMinYear(); year <= endYear; year++) {\n-                    if (zrec.hasUntil() && year > zrec.getUntilYear()) {\n-                        break;\n-                    }\n-                    List<RuleRec> rules = rule.getRules(year);\n-                    if (rules.size() > 0) {\n-                        for (int i = 0; i < rules.size(); i++) {\n-                            RuleRec rrec = rules.get(i);\n-                            long transition = rrec.getTransitionTime(year,\n-                                                                     gmtOffset,\n-                                                                     currentSave);\n-                            if (zrec.hasUntil()) {\n-                                if (transition >= zrec.getUntilTime(currentSave)) {\n-                                    \/\/ If the GMT offset changed from the previous one,\n-                                    \/\/ record fromTime as a transition.\n-                                    if (!fromTimeUsed && prevzrec != null\n-                                        && gmtOffset != prevzrec.getGmtOffset()) {\n-                                        tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                         tz.getDstOffsetIndex(currentSave));\n-                                        fromTimeUsed = true; \/\/ for consistency\n-                                    }\n-                                    break year_loop;\n-                                }\n-                            }\n-\n-                            if (fromTimeUsed == false) {\n-                                if (fromTime <= transition) {\n-                                    fromTimeUsed = true;\n-\n-                                    if (fromTime != minTime) {\n-                                        int prevsave;\n-\n-                                        \/\/ See if until time in the previous\n-                                        \/\/ ZoneRec is the same thing as the\n-                                        \/\/ local time in the next rule.\n-                                        \/\/ (examples are Asia\/Ashkhabad in 1991,\n-                                        \/\/ Europe\/Riga in 1989)\n-\n-                                        if (i > 0) {\n-                                            prevsave = rules.get(i-1).getSave();\n-                                        } else {\n-                                            List<RuleRec> prevrules = rule.getRules(year-1);\n-\n-                                            if (prevrules.size() > 0) {\n-                                                prevsave = prevrules.get(prevrules.size()-1).getSave();\n-                                            } else {\n-                                                prevsave = 0;\n-                                            }\n-                                        }\n-\n-                                        if (rrec.isSameTransition(prevzrec, prevsave, gmtOffset)) {\n-                                            currentSave = rrec.getSave();\n-                                            tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                         tz.getDstOffsetIndex(currentSave));\n-                                            tz.addUsedRec(rrec);\n-                                            usedZone = true;\n-                                            continue;\n-                                        }\n-                                        if (!prevzrec.hasRuleReference()\n-                                            || rule != prevzrec.getRuleRef()\n-                                            || (rule == prevzrec.getRuleRef()\n-                                                && gmtOffset != prevzrec.getGmtOffset())) {\n-                                            int save = (fromTime == transition) ? rrec.getSave() : currentSave;\n-                                            tz.addTransition(fromTime,\n-                                                         tz.getOffsetIndex(gmtOffset+save),\n-                                                         tz.getDstOffsetIndex(save));\n-                                            tz.addUsedRec(rrec);\n-                                            usedZone = true;\n-                                        }\n-                                    } else {  \/\/ fromTime == minTime\n-                                        int save = rrec.getSave();\n-                                        tz.addTransition(minTime,\n-                                                         tz.getOffsetIndex(gmtOffset),\n-                                                         tz.getDstOffsetIndex(0));\n-\n-                                        tz.addTransition(transition,\n-                                                         tz.getOffsetIndex(gmtOffset+save),\n-                                                         tz.getDstOffsetIndex(save));\n-\n-                                        tz.addUsedRec(rrec);\n-                                        usedZone = true;\n-                                    }\n-                                } else if (year == fromYear && i == rules.size()-1) {\n-                                    int save = rrec.getSave();\n-                                    tz.addTransition(fromTime,\n-                                                     tz.getOffsetIndex(gmtOffset+save),\n-                                                     tz.getDstOffsetIndex(save));\n-                                }\n-                            }\n-\n-                            currentSave = rrec.getSave();\n-                            if (fromTime < transition) {\n-                                tz.addTransition(transition,\n-                                                 tz.getOffsetIndex(gmtOffset+currentSave),\n-                                                 tz.getDstOffsetIndex(currentSave));\n-                                tz.addUsedRec(rrec);\n-                                usedZone = true;\n-                            }\n-                        }\n-                    } else {\n-                        if (year == fromYear) {\n-                            tz.addTransition(fromTime,\n-                                             tz.getOffsetIndex(gmtOffset+currentSave),\n-                                             tz.getDstOffsetIndex(currentSave));\n-                            fromTimeUsed = true;\n-                        }\n-                        if (year == endYear && !zrec.hasUntil()) {\n-                            if (tz.getNTransitions() > 0) {\n-                                \/\/ Assume that this Zone stopped DST\n-                                tz.setDSTType(Timezone.X_DST);\n-                                long time = Time.getLocalTime(maxYear, Month.JANUARY,\n-                                                              1, 0);\n-                                time -= zrec.getGmtOffset();\n-                                tz.addTransition(time,\n-                                                 tz.getOffsetIndex(gmtOffset),\n-                                                 tz.getDstOffsetIndex(0));\n-                                usedZone = true;\n-                            } else {\n-                                tz.setDSTType(Timezone.NO_DST);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            if (usedZone) {\n-                tz.addUsedRec(zrec);\n-            }\n-            if (zrec.hasUntil() && zrec.getUntilTime(currentSave) > fromTime) {\n-                fromTime = zrec.getUntilTime(currentSave);\n-                fromYear = zrec.getUntilYear();\n-                year = zrec.getUntilYear();\n-            }\n-            prevzrec = zrec;\n-        }\n-\n-        if (tz.getDSTType() == Timezone.UNDEF_DST) {\n-            tz.setDSTType(Timezone.DST);\n-        }\n-        tz.optimize();\n-        tz.checksum();\n-        return tz;\n-    }\n-\n-    private static void panic(String msg) {\n-        Main.panic(msg);\n-    }\n-}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Zoneinfo.java","additions":0,"deletions":579,"binary":false,"changes":579,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-#\n-# Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-# JDK 1.1.x compatible time zone IDs\n-#\n-\n-Link Australia\/Darwin ACT\n-Link Australia\/Sydney AET\n-Link America\/Argentina\/Buenos_Aires AGT\n-Link Africa\/Cairo ART\n-Link America\/Anchorage AST\n-Link America\/Sao_Paulo BET\n-Link Asia\/Dhaka BST\n-Link Africa\/Harare CAT\n-Link America\/St_Johns CNT\n-Link America\/Chicago CST\n-Link Asia\/Shanghai CTT\n-Link Africa\/Addis_Ababa EAT\n-Link Europe\/Paris ECT\n-Link America\/New_York EST\n-Link Pacific\/Honolulu HST\n-Link America\/Indianapolis IET\n-Link Asia\/Calcutta IST\n-Link Asia\/Tokyo JST\n-Link Pacific\/Apia MIT\n-Link America\/Denver MST\n-Link Asia\/Yerevan NET\n-Link Pacific\/Auckland NST\n-Link Asia\/Karachi PLT\n-Link America\/Phoenix PNT\n-Link America\/Puerto_Rico PRT\n-Link America\/Los_Angeles PST\n-Link Pacific\/Guadalcanal SST\n-Link Asia\/Saigon VST\n-\n-# Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tSystemV\tmin\t1973\t-\tApr\tlastSun\t2:00\t1:00\tD\n-Rule\tSystemV\tmin\t1973\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1974\tonly\t-\tJan\t6\t2:00\t1:00\tD\n-Rule\tSystemV\t1974\tonly\t-\tNov\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1975\tonly\t-\tFeb\t23\t2:00\t1:00\tD\n-Rule\tSystemV\t1975\tonly\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tSystemV\t1976\tmax\t-\tApr\tlastSun\t2:00\t1:00\tD\n-Rule\tSystemV\t1976\tmax\t-\tOct\tlastSun\t2:00\t0\tS\n-\n-# Zone\tNAME\t\tGMTOFF\tRULES\/SAVE\tFORMAT\t[UNTIL]\n-Zone\tSystemV\/AST4ADT\t-4:00\tSystemV\t\tA%sT\n-Zone\tSystemV\/EST5EDT\t-5:00\tSystemV\t\tE%sT\n-Zone\tSystemV\/CST6CDT\t-6:00\tSystemV\t\tC%sT\n-Zone\tSystemV\/MST7MDT\t-7:00\tSystemV\t\tM%sT\n-Zone\tSystemV\/PST8PDT\t-8:00\tSystemV\t\tP%sT\n-Zone\tSystemV\/YST9YDT\t-9:00\tSystemV\t\tY%sT\n-Zone\tSystemV\/AST4\t-4:00\t-\t\tAST\n-Zone\tSystemV\/EST5\t-5:00\t-\t\tEST\n-Zone\tSystemV\/CST6\t-6:00\t-\t\tCST\n-Zone\tSystemV\/MST7\t-7:00\t-\t\tMST\n-Zone\tSystemV\/PST8\t-8:00\t-\t\tPST\n-Zone\tSystemV\/YST9\t-9:00\t-\t\tYST\n-Zone\tSystemV\/HST10\t-10:00\t-\t\tHST\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/tzdata_jdk\/jdk11_backward","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.JarFile;\n+import java.util.spi.ToolProvider;\n+import java.util.zip.ZipEntry;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @bug 8302293\n+ * @summary verify that a JAR file creation through \"jar --create\" operation\n+ *          works fine if the JAR file name is less than 3 characters in length\n+ * @run junit JarCreateFileNameTest\n+ *\/\n+public class JarCreateFileNameTest {\n+\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    \/*\n+     * Launches \"jar --create --file\" with file names of varying lengths and verifies\n+     * that the JAR file was successfully created.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"abcd\", \"abc\", \"ab\", \"a\", \"d.jar\", \"ef.jar\"})\n+    void testCreate(final String targetJarFileName) throws Exception {\n+        final Path cwd = Path.of(\".\");\n+        final Path tmpFile = Files.createTempFile(cwd, \"8302293\", \".txt\");\n+        final String fileName = tmpFile.getFileName().toString();\n+        final int exitCode = JAR_TOOL.run(System.out, System.err,\n+                \"--create\", \"--file\", targetJarFileName, fileName);\n+        assertEquals(0, exitCode, \"jar command failed\");\n+        \/\/ verify the JAR file is created and contains the expected entry\n+        try (final JarFile jarFile = new JarFile(new File(targetJarFileName))) {\n+            final ZipEntry entry = jarFile.getEntry(fileName);\n+            assertNotNull(entry, \"missing \" + fileName + \" entry in JAR file \" + targetJarFileName);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/tools\/jar\/JarCreateFileNameTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -160,1 +160,1 @@\n-                JlinkTask.newLimitedFinder(JlinkTask.newModuleFinder(modulePaths), limits, mods),\n+                JlinkTask.limitFinder(JlinkTask.newModuleFinder(modulePaths), limits, mods),\n","filename":"test\/jdk\/tools\/jlink\/IntegrationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.nio.file.Paths;\n@@ -32,1 +31,0 @@\n-import java.util.Collections;\n@@ -39,1 +37,0 @@\n-import jdk.tools.jlink.plugin.Plugin;\n@@ -41,0 +38,1 @@\n+import jdk.tools.jlink.plugin.Plugin;\n@@ -138,1 +136,1 @@\n-            String imageDir = \"bug8189777-all-module-path\";\n+            String imageDir = \"bug8345259-all-module-path\";\n@@ -142,1 +140,1 @@\n-                    .call().assertSuccess();\n+                    .call().assertFailure();\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,10 +24,2 @@\n-\/*\n- * @test\n- * @summary jlink test of --add-module ALL-MODULE-PATH\n- * @library \/test\/lib\n- * @modules jdk.compiler\n- * @build jdk.test.lib.process.ProcessTools\n- *        jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.compiler.CompilerUtils\n- * @run testng AllModulePath\n- *\/\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n@@ -35,1 +27,1 @@\n-import java.io.File;\n+import java.io.ByteArrayOutputStream;\n@@ -41,1 +33,0 @@\n-import java.nio.file.attribute.BasicFileAttributes;\n@@ -43,1 +34,0 @@\n-import java.util.Arrays;\n@@ -47,2 +37,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -50,3 +38,1 @@\n-\n-import jdk.test.lib.compiler.CompilerUtils;\n-import jdk.test.lib.process.ProcessTools;\n+import java.util.stream.Collectors;\n@@ -56,1 +42,0 @@\n-import static org.testng.Assert.*;\n@@ -58,0 +43,20 @@\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n+import tests.Helper;\n+import tests.Result;\n+\n+\/*\n+ * @test\n+ * @bug 8345259\n+ * @summary jlink test of --add-module ALL-MODULE-PATH\n+ * @library ..\/..\/lib \/test\/lib\n+ * @modules jdk.compiler\n+ *          java.base\/jdk.internal.jimage\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build jdk.test.lib.process.ProcessTools\n+ *        jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.compiler.CompilerUtils\n+ * @run testng\/othervm -Duser.language=en -Duser.country=US AllModulePath\n+ *\/\n@@ -60,3 +65,5 @@\n-    private final Path JMODS = Paths.get(System.getProperty(\"test.jdk\")).resolve(\"jmods\");\n-    private final Path SRC = Paths.get(System.getProperty(\"test.src\")).resolve(\"src\");\n-    private final Path MODS = Paths.get(\"mods\");\n+    private static final Path JMODS = Paths.get(System.getProperty(\"test.jdk\")).resolve(\"jmods\");\n+    private static final Path SRC = Paths.get(System.getProperty(\"test.src\")).resolve(\"src\");\n+    private static final Path MODS = Paths.get(\"mods\");\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final boolean JMODS_EXIST = Files.exists(JMODS);\n@@ -70,0 +77,9 @@\n+    private static Helper HELPER;\n+\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n+        }\n+        return false;\n+    }\n@@ -73,1 +89,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -76,0 +92,1 @@\n+        HELPER = Helper.newHelper(LINKABLE_RUNTIME);\n@@ -87,0 +104,3 @@\n+    \/*\n+     * --add-modules ALL-MODULE-PATH with an existing module-path.\n+     *\/\n@@ -89,1 +109,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -93,3 +113,5 @@\n-        \/\/ create custom image\n-        Path image = Paths.get(\"image\");\n-        createImage(image, \"--add-modules\", \"ALL-MODULE-PATH\");\n+        Path image = HELPER.createNewImageDir(\"image\");\n+        List<String> opts = List.of(\"--module-path\", MODS.toString(),\n+                                    \"--output\", image.toString(),\n+                                    \"--add-modules\", \"ALL-MODULE-PATH\");\n+        createImage(image, opts, true \/* success *\/);\n@@ -98,5 +120,2 @@\n-        Files.find(JMODS, 1, (Path p, BasicFileAttributes attr) ->\n-                                p.toString().endsWith(\".jmod\"))\n-             .map(p -> JMODS.relativize(p).toString())\n-             .map(n -> n.substring(0, n.length()-5))\n-             .forEach(modules::add);\n+        \/\/ java.base is a dependency of any external module\n+        modules.add(\"java.base\");\n@@ -108,0 +127,3 @@\n+    \/*\n+     * --add-modules ALL-MODULE-PATH with --limit-modules is an error\n+     *\/\n@@ -110,1 +132,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -113,8 +135,12 @@\n-\n-        \/\/ create custom image\n-        Path image = Paths.get(\"image1\");\n-        createImage(image,\n-                    \"--add-modules\", \"ALL-MODULE-PATH\",\n-                    \"--limit-modules\", \"m1\");\n-\n-        checkModules(image, Set.of(\"m1\", \"java.base\"));\n+        Path targetPath = HELPER.createNewImageDir(\"all-mods-limit-mods\");\n+        String moduleName = \"com.baz.runtime\";\n+        Result result = HELPER.generateDefaultJModule(moduleName, \"jdk.jfr\");\n+        Path customModulePath = result.getFile().getParent();\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--limit-modules\", \"jdk.jfr\",\n+                                       \"--module-path\", customModulePath.toString(),\n+                                       \"--output\", targetPath.toString());\n+        JlinkOutput allOut = createImage(targetPath, allArgs, false \/* success *\/);\n+        String actual = allOut.stdout.trim();\n+        String expected = \"Error: --limit-modules not allowed with --add-modules ALL-MODULE-PATH\";\n+        assertEquals(actual, expected);\n@@ -123,0 +149,4 @@\n+\n+    \/*\n+     * --add-modules *includes* ALL-MODULE-PATH with an existing module path\n+     *\/\n@@ -125,1 +155,1 @@\n-        if (Files.notExists(JMODS)) {\n+        if (isExplodedJDKImage()) {\n@@ -130,5 +160,6 @@\n-        Path image = Paths.get(\"image2\");\n-        createImage(image,\n-                    \"--add-modules\", \"m1,test\",\n-                    \"--add-modules\", \"ALL-MODULE-PATH\",\n-                    \"--limit-modules\", \"java.base\");\n+        Path image = HELPER.createNewImageDir(\"image2\");\n+        List<String> opts = List.of(\"--module-path\", MODS.toString(),\n+                                    \"--output\", image.toString(),\n+                                    \"--add-modules\", \"m1\",\n+                                    \"--add-modules\", \"ALL-MODULE-PATH\");\n+        createImage(image, opts, true \/* success *\/);\n@@ -140,1 +171,41 @@\n-     * check the modules linked in the image\n+     * No --module-path with --add-modules ALL-MODULE-PATH is an error.\n+     *\/\n+    @Test\n+    public void noModulePath() throws IOException {\n+        if (isExplodedJDKImage()) {\n+            return;\n+        }\n+        Path targetPath = HELPER.createNewImageDir(\"all-mod-path-no-mod-path\");\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--output\", targetPath.toString());\n+        JlinkOutput allOut = createImage(targetPath, allArgs, false \/* expect failure *\/);\n+        String expected = \"Error: --module-path option must be specified with --add-modules ALL-MODULE-PATH\";\n+        assertEquals(allOut.stdout.trim(), expected);\n+    }\n+\n+    \/*\n+     * --module-path not-exist and --add-modules ALL-MODULE-PATH is an error.\n+     *\/\n+    @Test\n+    public void modulePathEmpty() throws IOException {\n+        if (isExplodedJDKImage()) {\n+            return;\n+        }\n+        Path targetPath = HELPER.createNewImageDir(\"all-mod-path-not-existing\");\n+        String strNotExists = \"not-exist\";\n+        Path notExists = Path.of(strNotExists);\n+        if (Files.exists(notExists)) {\n+            throw new AssertionError(\"Test setup error, path must not exist!\");\n+        }\n+        List<String> allArgs = List.of(\"--add-modules\", \"ALL-MODULE-PATH\",\n+                                       \"--module-path\", notExists.toString(),\n+                                       \"--output\", targetPath.toString());\n+\n+        JlinkOutput allOut = createImage(targetPath, allArgs, false \/* expect failure *\/);\n+        String actual = allOut.stdout.trim();\n+        assertTrue(actual.startsWith(\"Error: No module found in module path\"));\n+        assertTrue(actual.contains(strNotExists));\n+    }\n+\n+    \/*\n+     * check the modules linked in the image using m1\/p.ListModules\n@@ -167,11 +238,12 @@\n-    private void createImage(Path image, String... options) throws IOException {\n-        String modulepath = JMODS.toString() + File.pathSeparator + MODS.toString();\n-        List<String> opts = List.of(\"--module-path\", modulepath,\n-                                    \"--output\", image.toString());\n-        String[] args = Stream.concat(opts.stream(), Arrays.stream(options))\n-                              .toArray(String[]::new);\n-\n-        System.out.println(\"jlink \" + Arrays.stream(args).collect(Collectors.joining(\" \")));\n-        PrintWriter pw = new PrintWriter(System.out);\n-        int rc = JLINK_TOOL.run(pw, pw, args);\n-        assertTrue(rc == 0);\n+    private JlinkOutput createImage(Path image, List<String> args, boolean success) throws IOException {\n+        System.out.println(\"jlink \" + args.stream().collect(Collectors.joining(\" \")));\n+\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        PrintWriter out = new PrintWriter(baos);\n+        ByteArrayOutputStream berrOs = new ByteArrayOutputStream();\n+        PrintWriter err = new PrintWriter(berrOs);\n+        int rc = JLINK_TOOL.run(out, err, args.toArray(String[]::new));\n+        String stdOut = new String(baos.toByteArray());\n+        String stdErr = new String(berrOs.toByteArray());\n+        assertEquals(rc == 0, success, String.format(\"Output was: %nstdout: %s%nstderr: %s%n\", stdOut, stdErr));\n+        return new JlinkOutput(stdErr, stdOut);\n@@ -179,0 +251,2 @@\n+\n+    private static record JlinkOutput(String stderr, String stdout) {};\n","filename":"test\/jdk\/tools\/jlink\/basic\/AllModulePath.java","additions":134,"deletions":60,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,15 +24,0 @@\n-\/*\n- * @test\n- * @summary Basic test of jlink to create jmods and images\n- * @author Andrei Eremeev\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.module\n- *          jdk.jlink\n- *          jdk.compiler\n- * @build jdk.test.lib.process.ProcessTools\n- *        jdk.test.lib.process.OutputAnalyzer\n- *        jdk.test.lib.compiler.CompilerUtils\n- *        jdk.test.lib.util.JarUtils\n- * @run main BasicTest\n- *\/\n-\n@@ -53,0 +38,1 @@\n+import jdk.tools.jlink.internal.LinkableRuntimeImage;\n@@ -54,0 +40,14 @@\n+\/*\n+ * @test\n+ * @summary Basic test of jlink to create jmods and images\n+ * @author Andrei Eremeev\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.module\n+ *          jdk.jlink\/jdk.tools.jlink.internal\n+ *          jdk.compiler\n+ * @build jdk.test.lib.process.ProcessTools\n+ *        jdk.test.lib.process.OutputAnalyzer\n+ *        jdk.test.lib.compiler.CompilerUtils\n+ *        jdk.test.lib.util.JarUtils\n+ * @run main\/othervm BasicTest\n+ *\/\n@@ -65,8 +65,10 @@\n-    private final String TEST_MODULE = \"test\";\n-    private final Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n-    private final Path jdkMods = jdkHome.resolve(\"jmods\");\n-    private final Path testSrc = Paths.get(System.getProperty(\"test.src\"));\n-    private final Path src = testSrc.resolve(\"src\").resolve(TEST_MODULE);\n-    private final Path classes = Paths.get(\"classes\");\n-    private final Path jmods = Paths.get(\"jmods\");\n-    private final Path jars = Paths.get(\"jars\");\n+    private static final String TEST_MODULE = \"test\";\n+    private static final Path jdkHome = Paths.get(System.getProperty(\"test.jdk\"));\n+    private static final Path jdkMods = jdkHome.resolve(\"jmods\");\n+    private static final boolean JMODS_EXIST = Files.exists(jdkMods);\n+    private static final boolean LINKABLE_RUNTIME = LinkableRuntimeImage.isLinkableRuntime();\n+    private static final Path testSrc = Paths.get(System.getProperty(\"test.src\"));\n+    private static final Path src = testSrc.resolve(\"src\").resolve(TEST_MODULE);\n+    private static final Path classes = Paths.get(\"classes\");\n+    private static final Path jmods = Paths.get(\"jmods\");\n+    private static final Path jars = Paths.get(\"jars\");\n@@ -78,0 +80,8 @@\n+    private static boolean isExplodedJDKImage() {\n+        if (!JMODS_EXIST && !LINKABLE_RUNTIME) {\n+            System.err.println(\"Test skipped. Not a linkable runtime and no JMODs\");\n+            return true;\n+        }\n+        return false;\n+    }\n+\n@@ -79,1 +89,1 @@\n-        if (Files.notExists(jdkMods)) {\n+        if (isExplodedJDKImage()) {\n@@ -149,0 +159,2 @@\n+        String modPathArg = (JMODS_EXIST ? jdkMods + File.pathSeparator : \"\") +\n+                                jmods;\n@@ -150,1 +162,1 @@\n-                \"--module-path\", jdkMods + File.pathSeparator + jmods,\n+                \"--module-path\", modPathArg,\n","filename":"test\/jdk\/tools\/jlink\/basic\/BasicTest.java","additions":38,"deletions":26,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m AddOptionsTest\n+ * @run main\/othervm -Xmx1g AddOptionsTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/AddOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m BasicJlinkMissingJavaBase\n+ * @run main\/othervm -Xmx1g BasicJlinkMissingJavaBase\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkMissingJavaBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m BasicJlinkTest false\n+ * @run main\/othervm -Xmx1g BasicJlinkTest false\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/BasicJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m CustomModuleJlinkTest\n+ * @run main\/othervm -Xmx1g CustomModuleJlinkTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/CustomModuleJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m GenerateJLIClassesTest\n+ * @run main\/othervm -Xmx1g GenerateJLIClassesTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/GenerateJLIClassesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m JavaSEReproducibleTest\n+ * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m KeepPackagedModulesFailTest\n+ * @run main\/othervm -Xmx1g KeepPackagedModulesFailTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/KeepPackagedModulesFailTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m ModifiedFilesExitTest\n+ * @run main\/othervm -Xmx1g ModifiedFilesExitTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesExitTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xmx1400m ModifiedFilesWarningTest\n+ * @run main\/othervm -Xmx1g ModifiedFilesWarningTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/ModifiedFilesWarningTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1400m MultiHopTest\n+ * @run main\/othervm -Xmx1g MultiHopTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/MultiHopTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=1200 -Xmx1400m PackagedModulesVsRuntimeImageLinkTest\n+ * @run main\/othervm\/timeout=1200 -Xmx1g PackagedModulesVsRuntimeImageLinkTest\n@@ -79,1 +79,0 @@\n-        System.out.println(\"Now comparing jmod-less and jmod-full) images\");\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PackagedModulesVsRuntimeImageLinkTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1400m PatchedJDKModuleJlinkTest\n+ * @run main\/othervm -Xmx1g PatchedJDKModuleJlinkTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/PatchedJDKModuleJlinkTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx1400m SystemModulesTest\n+ * @run main\/othervm -Xmx1g SystemModulesTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1400m SystemModulesTest2\n+ * @run main\/othervm -Xmx1g SystemModulesTest2\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/SystemModulesTest2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+        final Path jmods = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n@@ -64,0 +65,1 @@\n+                \"--module-path\", jmods.toString(),\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimeImageSymbolicLinksTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+        final Path jmods = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n@@ -57,0 +58,1 @@\n+                \"--module-path\", jmods.toString(),\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimeImageTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,2 @@\n+            final Path jmods = Path.of(System.getProperty(\"java.home\"), \"jmods\");\n+\n@@ -115,0 +117,1 @@\n+                        \"--module-path\", jmods.toString(),\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimePackageTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.jpackage.test.Executor;\n@@ -42,0 +43,1 @@\n+ * @library \/test\/lib\n@@ -44,0 +46,1 @@\n+ * @build jtreg.SkippedException\n@@ -67,0 +70,2 @@\n+        verifyDosNamesSupported();\n+\n@@ -87,0 +92,19 @@\n+\n+    private static void verifyDosNamesSupported() throws IOException {\n+        \/\/ Pick the file's name long enough to make Windows shorten it.\n+        final var probeDosNameFile = TKit.createTempFile(Path.of(\"probeDosName\"));\n+\n+        \/\/ The output should be a DOS variant of the `probeDosNameFile` path.\n+        \/\/ The filename should differ if the volume owning `probeDosNameFile` file supports DOS names.\n+        final var dosPath = new Executor()\n+                .addArguments(\"\/c\", String.format(\"for %%P in (\\\"%s\\\") do @echo %%~sP\", probeDosNameFile))\n+                .setExecutable(\"cmd\")\n+                .dumpOutput()\n+                .executeAndGetFirstLineOfOutput();\n+\n+        if (Path.of(dosPath).getFileName().equals(probeDosNameFile.getFileName())) {\n+            TKit.throwSkippedException(String.format(\"The volume %s owning the test work directory doesn't support DOS paths\",\n+                    probeDosNameFile.toAbsolutePath().getRoot()));\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongPathTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn Y]\n@@ -5,0 +6,1 @@\n+[warn W]\n@@ -7,0 +9,1 @@\n+[warn Z]\n","filename":"test\/langtools\/tools\/javac\/6734819\/T6734819a.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn A]\n@@ -5,0 +6,1 @@\n+[warn B]\n","filename":"test\/langtools\/tools\/javac\/6734819\/T6734819b.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn Y]\n@@ -5,0 +6,1 @@\n+[warn W]\n","filename":"test\/langtools\/tools\/javac\/6734819\/T6734819c.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn Explicit]\n","filename":"test\/langtools\/tools\/javac\/implicitCompile\/SkipAttrFlowGenForImplicits.out","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,0 +7,3 @@\n+[warn A]\n+[warn A1]\n+[warn A2]\n","filename":"test\/langtools\/tools\/javac\/policy\/test1\/byfile.ABD.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -7,0 +7,3 @@\n+[warn A]\n+[warn A1]\n+[warn A2]\n","filename":"test\/langtools\/tools\/javac\/policy\/test1\/byfile.ACD.out","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn A]\n@@ -7,0 +8,1 @@\n+[warn A1]\n@@ -11,0 +13,1 @@\n+[warn A2]\n@@ -15,0 +18,1 @@\n+[warn B]\n","filename":"test\/langtools\/tools\/javac\/policy\/test1\/bytodo.ABD.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn A]\n@@ -7,0 +8,1 @@\n+[warn A1]\n@@ -11,0 +13,1 @@\n+[warn A2]\n@@ -15,0 +18,1 @@\n+[warn C]\n","filename":"test\/langtools\/tools\/javac\/policy\/test1\/bytodo.ACD.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn A]\n@@ -5,0 +6,1 @@\n+[warn B]\n","filename":"test\/langtools\/tools\/javac\/policy\/test2\/byfile.AB.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn B]\n@@ -8,0 +9,1 @@\n+[warn A]\n","filename":"test\/langtools\/tools\/javac\/policy\/test2\/byfile.BA.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn A]\n@@ -5,0 +6,1 @@\n+[warn B]\n","filename":"test\/langtools\/tools\/javac\/policy\/test2\/bytodo.AB.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+[warn B]\n@@ -8,0 +9,1 @@\n+[warn A]\n","filename":"test\/langtools\/tools\/javac\/policy\/test2\/bytodo.BA.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-        NavigableMap<Integer, AnnotationMirror> toBeFound;\n+        NavigableMap<Integer, List<AnnotationMirror>> toBeFound;\n@@ -174,1 +174,1 @@\n-            NavigableMap<Integer, AnnotationMirror> testByPos = new TreeMap<>();\n+            NavigableMap<Integer, List<AnnotationMirror>> testByPos = new TreeMap<>();\n@@ -177,1 +177,1 @@\n-                    testByPos.put(pos, test);\n+                    testByPos.computeIfAbsent(pos, ArrayList::new).add(test);\n@@ -199,9 +199,5 @@\n-                            AnnotationMirror test = toBeFound.pollFirstEntry().getValue();\n-                            String annoType = getAnnoType(test);\n-                            AnnotationMirror anno = getAnnotation(t, annoType);\n-                            if (anno == null) {\n-                                error(elem, \"annotation not found on \" + count + \": \" + t);\n-                            } else {\n-                                String v = getValue(anno, \"value\").toString();\n-                                if (v.equals(getExpect(test))) {\n-                                    out.println(\"found \" + anno + \" as expected\");\n+                            for (AnnotationMirror test : toBeFound.pollFirstEntry().getValue()) {\n+                                String annoType = getAnnoType(test);\n+                                AnnotationMirror anno = getAnnotation(t, annoType);\n+                                if (anno == null) {\n+                                    error(elem, \"annotation not found on \" + count + \": \" + t);\n@@ -209,1 +205,6 @@\n-                                    error(elem, \"Unexpected value: \" + v + \", expected: \" + getExpect(test));\n+                                    String v = getValue(anno, \"value\").toString();\n+                                    if (v.equals(getExpect(test))) {\n+                                        out.println(\"found \" + anno + \" as expected\");\n+                                    } else {\n+                                        error(elem, \"Unexpected value: \" + v + \", expected: \" + getExpect(test));\n+                                    }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/BasicAnnoTests.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-                         \"-XDshould-stop.at=FLOW\", \"-Xlint:this-escape\")\n+                         \"-XDshould-stop.at=WARN\", \"-Xlint:this-escape\")\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.HexFormat;\n@@ -34,0 +33,1 @@\n+ * @bug 8340493\n@@ -52,0 +52,23 @@\n+    \/\/ equals() always returns true\n+    public static class Bar {\n+        private final int i;\n+        public Bar(int i) {\n+            this.i = i;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return true;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Integer.toString(i);\n+        }\n+    }\n+\n@@ -65,0 +88,13 @@\n+\n+        testErrorMessages();\n+    }\n+\n+    public static void testErrorMessages() throws Exception {\n+        try {\n+            Asserts.assertNotEquals(new Bar(1), new Bar(2));\n+            throw new Exception(\"Should fail\");\n+        } catch (RuntimeException e) {\n+            if (!e.getMessage().contains(\"was 2\")) {\n+                throw new Exception(\"msg is \" + e.getMessage());\n+            }\n+        }\n@@ -219,2 +255,1 @@\n-    private static void expectPass(Assertion assertion, byte[] b1, byte[] b2)\n-            throws Exception {\n+    private static void expectPass(Assertion assertion, byte[] b1, byte[] b2) {\n","filename":"test\/lib-test\/jdk\/test\/lib\/AssertsTest.java","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        Asserts.assertEqualsByteArray(b1, new byte[] {1, 2});\n+        Asserts.assertEqualsByteArray(new byte[] {1, 2}, b1);\n@@ -41,1 +41,1 @@\n-        Asserts.assertEqualsByteArray(b1, new byte[] {3, 4});\n+        Asserts.assertEqualsByteArray(new byte[] {3, 4}, b1);\n@@ -44,1 +44,1 @@\n-        Asserts.assertEqualsByteArray(b1, new byte[] {5, 6});\n+        Asserts.assertEqualsByteArray(new byte[] {5, 6}, b1);\n","filename":"test\/lib-test\/jdk\/test\/lib\/security\/FixedSecureRandomTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} has the same content as {@code expected}.\n@@ -239,2 +239,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param expected The expected value\n+     * @param actual The actual value\n@@ -244,2 +244,2 @@\n-    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs) {\n-        assertEqualsByteArray(lhs, rhs, null);\n+    public static void assertEqualsByteArray(byte[] expected, byte[] actual) {\n+        assertEqualsByteArray(expected, actual, null);\n@@ -249,1 +249,1 @@\n-     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} does not have the same content as {@code unexpected}.\n@@ -251,2 +251,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -256,2 +256,2 @@\n-    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs) {\n-        assertNotEqualsByteArray(lhs, rhs, null);\n+    public static void assertNotEqualsByteArray(byte[] unexpected, byte[] actual) {\n+        assertNotEqualsByteArray(unexpected, actual, null);\n@@ -261,1 +261,1 @@\n-     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} is the same byte array as {@code expected}.\n@@ -263,2 +263,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param expected The expected value\n+     * @param actual The actual value\n@@ -268,2 +268,2 @@\n-    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n-        if (!Arrays.equals(lhs, rhs)) {\n+    public static void assertEqualsByteArray(byte[] expected, byte[] actual, String msg) {\n+        if (!Arrays.equals(expected, actual)) {\n@@ -271,2 +271,2 @@\n-                    + \": expected \" + HexFormat.of().formatHex(lhs)\n-                    + \" to equal \" + HexFormat.of().formatHex(rhs);\n+                    + \": expected \" + HexFormat.of().formatHex(expected)\n+                    + \" but was \" + HexFormat.of().formatHex(actual);\n@@ -278,1 +278,1 @@\n-     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     * Asserts that {@code actual} is not the same byte array as {@code unexpected}.\n@@ -280,2 +280,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -285,2 +285,2 @@\n-    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n-        if (Arrays.equals(lhs, rhs)) {\n+    public static void assertNotEqualsByteArray(byte[] unexpected, byte[] actual, String msg) {\n+        if (Arrays.equals(unexpected, actual)) {\n@@ -288,2 +288,1 @@\n-                    + \": expected \" + HexFormat.of().formatHex(lhs)\n-                    + \" to not equal \" + HexFormat.of().formatHex(rhs);\n+                    + \": expected not equals but was \" + HexFormat.of().formatHex(actual);\n@@ -407,2 +406,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -411,2 +410,2 @@\n-    public static void assertNE(Object lhs, Object rhs) {\n-        assertNotEquals(lhs, rhs);\n+    public static void assertNE(Object unexpected, Object actual) {\n+        assertNotEquals(unexpected, actual);\n@@ -418,2 +417,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -423,2 +422,2 @@\n-    public static void assertNE(Object lhs, Object rhs, String msg) {\n-        assertNotEquals(lhs, rhs, msg);\n+    public static void assertNE(Object unexpected, Object actual, String msg) {\n+        assertNotEquals(unexpected, actual, msg);\n@@ -430,2 +429,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -434,2 +433,2 @@\n-    public static void assertNotEquals(Object lhs, Object rhs) {\n-        assertNotEquals(lhs, rhs, null);\n+    public static void assertNotEquals(Object unexpected, Object actual) {\n+        assertNotEquals(unexpected, actual, null);\n@@ -439,1 +438,1 @@\n-     * Asserts that {@code lhs} is not equal to {@code rhs}.\n+     * Asserts that {@code actual} is not equal to {@code unexpected}.\n@@ -441,2 +440,2 @@\n-     * @param lhs The left hand side of the comparison.\n-     * @param rhs The right hand side of the comparison.\n+     * @param unexpected The unexpected value\n+     * @param actual The actual value\n@@ -446,2 +445,2 @@\n-    public static void assertNotEquals(Object lhs, Object rhs, String msg) {\n-        if ((lhs == rhs) || (lhs != null && lhs.equals(rhs))) {\n+    public static void assertNotEquals(Object unexpected, Object actual, String msg) {\n+        if ((unexpected == actual) || (unexpected != null && unexpected.equals(actual))) {\n@@ -449,2 +448,1 @@\n-                    + \": expected \" + Objects.toString(lhs)\n-                    + \" to not equal \" + Objects.toString(rhs);\n+                    + \": expected not equals but was \" + Objects.toString(actual);\n","filename":"test\/lib\/jdk\/test\/lib\/Asserts.java","additions":41,"deletions":43,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AbstractCorpusBenchmark.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,0 @@\n-            \"ASM_1\",\n-            \"ASM_3\",\n-            \"ASM_UNSHARED_3\",\n-\/\/            \"ASM_TREE\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdaptNull.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,6 +32,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n@@ -48,49 +42,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmStreamCountLoads(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassReader cr = new ClassReader(bytes);\n-\n-            var mv = new MethodVisitor(Opcodes.ASM9) {\n-                int count = 0;\n-\n-                @Override\n-                public void visitVarInsn(int opcode, int var) {\n-                    ++count;\n-                }\n-            };\n-\n-            var visitor = new ClassVisitor(Opcodes.ASM9) {\n-                @Override\n-                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-                    return mv;\n-                }\n-            };\n-            cr.accept(visitor, 0);\n-            bh.consume(mv.count);\n-        }\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmTreeCountLoads(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            var mv = new MethodVisitor(Opcodes.ASM9) {\n-                int count = 0;\n-\n-                @Override\n-                public void visitVarInsn(int opcode, int var) {\n-                    ++count;\n-                }\n-            };\n-\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            for (MethodNode mn : node.methods) {\n-                mn.accept(mv);\n-            }\n-            bh.consume(mv.count);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadDeep.java","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n-import jdk.internal.org.objectweb.asm.tree.*;\n@@ -37,29 +35,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmStreamReadName(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassReader cr = new ClassReader(bytes);\n-            var  visitor = new ClassVisitor(Opcodes.ASM9) {\n-                String theName;\n-\n-                @Override\n-                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-                    theName = name;\n-                }\n-            };\n-            cr.accept(visitor, 0);\n-            bh.consume(visitor.theName);\n-        }\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmTreeReadName(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            bh.consume(node.name);\n-        }\n-    }\n-\n@@ -93,37 +62,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmStreamCountFields(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassReader cr = new ClassReader(bytes);\n-            var visitor = new ClassVisitor(Opcodes.ASM9) {\n-                int count;\n-\n-                @Override\n-                public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-                    if ((access & Opcodes.ACC_PUBLIC) != 1) {\n-                        ++count;\n-                    }\n-                    return null;\n-                }\n-            };\n-            cr.accept(visitor, 0);\n-            bh.consume(visitor.count);\n-        }\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmTreeCountFields(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            int count = 0;\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            for (FieldNode fn : node.fields)\n-                if ((fn.access & Opcodes.ACC_PUBLIC) != 1) {\n-                    ++count;\n-                }\n-            bh.consume(count);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadMetadata.java","additions":1,"deletions":69,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,13 +44,0 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n-import jdk.internal.org.objectweb.asm.TypePath;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n@@ -63,2 +50,0 @@\n-    static int ASM9 = 9 << 16 | 0 << 8;\n-\n@@ -126,32 +111,0 @@\n-        ASM_1(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_UNSHARED_1(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_3(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new CustomClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_UNSHARED_3(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new CustomClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_TREE(bytes -> {\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            node.accept(cw);\n-            return cw.toByteArray();\n-        }),\n@@ -189,6 +142,0 @@\n-        ASM_NOP_SHARED(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new NopClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n@@ -229,7 +176,0 @@\n-        ASM_ADD_FIELD(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            cw.visitField(0, \"argleBargleWoogaWooga\", \"I\", null, null);\n-            return cw.toByteArray();\n-        }),\n@@ -260,14 +200,0 @@\n-        ASM_DEL_METHOD(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            ClassVisitor v = new ClassVisitor(ASM9, cw) {\n-                @Override\n-                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-                    return (name.equals(\"hashCode\") && descriptor.equals(\"()Z\"))\n-                           ? null\n-                           : super.visitMethod(access, name, descriptor, signature, exceptions);\n-                }\n-            };\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n@@ -306,273 +232,0 @@\n-    static class CustomClassVisitor extends ClassVisitor {\n-\n-        public CustomClassVisitor(ClassVisitor writer) {\n-            super(ASM9, writer);\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            super.visit(version, access, name, signature, superName, interfaces);\n-        }\n-\n-        @Override\n-        public void visitSource(String source, String debug) {\n-            super.visitSource(source, debug);\n-        }\n-\n-        @Override\n-        public ModuleVisitor visitModule(String name, int access, String version) {\n-            return super.visitModule(name, access, version);\n-        }\n-\n-        @Override\n-        public void visitNestHost(String nestHost) {\n-            super.visitNestHost(nestHost);\n-        }\n-\n-        @Override\n-        public void visitOuterClass(String owner, String name, String descriptor) {\n-            super.visitOuterClass(owner, name, descriptor);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAttribute(Attribute attribute) {\n-            super.visitAttribute(attribute);\n-        }\n-\n-        @Override\n-        public void visitNestMember(String nestMember) {\n-            super.visitNestMember(nestMember);\n-        }\n-\n-        @Override\n-        public void visitInnerClass(String name, String outerName, String innerName, int access) {\n-            super.visitInnerClass(name, outerName, innerName, access);\n-        }\n-\n-        @Override\n-        public RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {\n-            return super.visitRecordComponent(name, descriptor, signature);\n-        }\n-\n-        @Override\n-        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-            return super.visitField(access, name, descriptor, signature, value);\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n-            return new CustomMethodVisitor(mv);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            super.visitEnd();\n-        }\n-    };\n-\n-\n-    static class CustomMethodVisitor extends MethodVisitor {\n-\n-        public CustomMethodVisitor(MethodVisitor methodVisitor) {\n-            super(ASM9, methodVisitor);\n-        }\n-\n-        @Override\n-        public void visitParameter(String name, int access) {\n-            super.visitParameter(name, access);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotationDefault() {\n-            return super.visitAnnotationDefault();\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAnnotableParameterCount(int parameterCount, boolean visible) {\n-            super.visitAnnotableParameterCount(parameterCount, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {\n-            return super.visitParameterAnnotation(parameter, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAttribute(Attribute attribute) {\n-            super.visitAttribute(attribute);\n-        }\n-\n-        @Override\n-        public void visitCode() {\n-            super.visitCode();\n-        }\n-\n-        @Override\n-        public void visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack) {\n-            super.visitFrame(type, numLocal, local, numStack, stack);\n-        }\n-\n-        @Override\n-        public void visitInsn(int opcode) {\n-            super.visitInsn(opcode);\n-        }\n-\n-        @Override\n-        public void visitIntInsn(int opcode, int operand) {\n-            super.visitIntInsn(opcode, operand);\n-        }\n-\n-        @Override\n-        public void visitVarInsn(int opcode, int var) {\n-            super.visitVarInsn(opcode, var);\n-        }\n-\n-        @Override\n-        public void visitTypeInsn(int opcode, String type) {\n-            super.visitTypeInsn(opcode, type);\n-        }\n-\n-        @Override\n-        public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {\n-            super.visitFieldInsn(opcode, owner, name, descriptor);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"deprecation\")\n-        public void visitMethodInsn(int opcode, String owner, String name, String descriptor) {\n-            super.visitMethodInsn(opcode, owner, name, descriptor);\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n-            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n-        }\n-\n-        @Override\n-        public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {\n-            super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n-        }\n-\n-        @Override\n-        public void visitJumpInsn(int opcode, Label label) {\n-            super.visitJumpInsn(opcode, label);\n-        }\n-\n-        @Override\n-        public void visitLabel(Label label) {\n-            super.visitLabel(label);\n-        }\n-\n-        @Override\n-        public void visitLdcInsn(Object value) {\n-            super.visitLdcInsn(value);\n-        }\n-\n-        @Override\n-        public void visitIincInsn(int var, int increment) {\n-            super.visitIincInsn(var, increment);\n-        }\n-\n-        @Override\n-        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {\n-            super.visitTableSwitchInsn(min, max, dflt, labels);\n-        }\n-\n-        @Override\n-        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n-            super.visitLookupSwitchInsn(dflt, keys, labels);\n-        }\n-\n-        @Override\n-        public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {\n-            super.visitMultiANewArrayInsn(descriptor, numDimensions);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n-            super.visitTryCatchBlock(start, end, handler, type);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {\n-            super.visitLocalVariable(name, descriptor, signature, start, end, index);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String descriptor, boolean visible) {\n-            return super.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitLineNumber(int line, Label start) {\n-            super.visitLineNumber(line, start);\n-        }\n-\n-        @Override\n-        public void visitMaxs(int maxStack, int maxLocals) {\n-            super.visitMaxs(maxStack, maxLocals);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            super.visitEnd();\n-        }\n-    };\n-\n-    static class NopClassVisitor extends CustomClassVisitor {\n-\n-        public NopClassVisitor(ClassVisitor writer) {\n-            super(writer);\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n-            return new NopMethodVisitor(mv);\n-        }\n-    }\n-\n-    static class NopMethodVisitor extends CustomMethodVisitor {\n-\n-        public NopMethodVisitor(MethodVisitor methodVisitor) {\n-            super(methodVisitor);\n-        }\n-\n-        @Override\n-        public void visitCode() {\n-            super.visitCode();\n-            visitInsn(Opcodes.NOP);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":1,"deletions":348,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -60,2 +59,0 @@\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n@@ -73,1 +70,0 @@\n-    static String checkFileAsm = \"\/tmp\/asw\/MyClass.class\";\n@@ -75,1 +71,0 @@\n-    static boolean writeClassAsm = Files.exists(Paths.get(checkFileAsm).getParent());\n@@ -78,65 +73,0 @@\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public byte[] asmStream() {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(Opcodes.V12, Opcodes.ACC_PUBLIC, \"MyClass\", null, \"java\/lang\/Object\", null);\n-        cw.visitSource(\"MyClass.java\", null);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(0, INIT_NAME, \"()V\", null, null);\n-            mv.visitCode();\n-            Label startLabel = new Label();\n-            Label endLabel = new Label();\n-            mv.visitLabel(startLabel);\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\n-            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java\/lang\/Object\", INIT_NAME, \"()V\", false);\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitLabel(endLabel);\n-            mv.visitLocalVariable(\"this\", \"LMyClass;\", null, startLabel, endLabel, 1);\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n-        }\n-\n-        for (int xi = 0; xi < REPEATS; ++xi) {\n-            MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, METHOD_NAMES[xi], \"([Ljava\/lang\/String;)V\", null, null);\n-            mv.visitCode();\n-            Label loopTop = new Label();\n-            Label loopEnd = new Label();\n-            Label startLabel = new Label();\n-            Label endLabel = new Label();\n-            Label iStart = new Label();\n-            mv.visitLabel(startLabel);\n-            mv.visitInsn(Opcodes.ICONST_1);\n-            mv.visitVarInsn(Opcodes.ISTORE, 1);\n-            mv.visitLabel(iStart);\n-            mv.visitInsn(Opcodes.ICONST_1);\n-            mv.visitVarInsn(Opcodes.ISTORE, 2);\n-            mv.visitLabel(loopTop);\n-            mv.visitVarInsn(Opcodes.ILOAD, 2);\n-            mv.visitIntInsn(Opcodes.BIPUSH, 10);\n-            mv.visitJumpInsn(Opcodes.IF_ICMPGE, loopEnd);\n-            mv.visitVarInsn(Opcodes.ILOAD, 1);\n-            mv.visitVarInsn(Opcodes.ILOAD, 2);\n-            mv.visitInsn(Opcodes.IMUL);\n-            mv.visitVarInsn(Opcodes.ISTORE, 1);\n-            mv.visitIincInsn(2, 1);\n-            mv.visitJumpInsn(Opcodes.GOTO, loopTop);\n-            mv.visitLabel(loopEnd);\n-            mv.visitFieldInsn(Opcodes.GETSTATIC,\"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitVarInsn(Opcodes.ILOAD, 1);\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(I)V\", false);\n-            mv.visitLabel(endLabel);\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitLocalVariable(\"fac\", \"I\", null, startLabel, endLabel, 1);\n-            mv.visitLocalVariable(\"i\",   \"I\", null, iStart, loopEnd, 2);\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-\n-        byte[] bytes = cw.toByteArray();\n-        if (writeClassAsm) writeClass(bytes, checkFileAsm);\n-        return bytes;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":1,"deletions":71,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-@Fork(1)\n+@Fork(value=1, jvmArgs={\"--add-modules=jdk.incubator.vector\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/SpiltReplicate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 1, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n+public class MergeLoadBench {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    final static VarHandle\n+            INT_L  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.LITTLE_ENDIAN),\n+            INT_B  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.BIG_ENDIAN),\n+            LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN),\n+            LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN),\n+            CHAR_L = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.LITTLE_ENDIAN),\n+            CHAR_B = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.BIG_ENDIAN);\n+\n+    final static int NUMBERS = 8192;\n+\n+    final byte[] bytes4 = new byte[NUMBERS * 4];\n+    final byte[] bytes8 = new byte[NUMBERS * 8];\n+    final int [] ints   = new int [NUMBERS    ];\n+    final long[] longs  = new long[NUMBERS    ];\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random();\n+        for (int i = 0; i < ints.length; i++) {\n+            ints[i] = r.nextInt();\n+            INT_L.set(bytes4, i * 4, i);\n+        }\n+\n+        for (int i = 0; i < longs.length; i++) {\n+            longs[i] = r.nextLong();\n+            LONG_L.set(bytes8, i * 8, i);\n+        }\n+    }\n+\n+    \/*\n+     * The names of these cases have the following `B\/L\/V\/U` suffixes, which are:\n+     * ```\n+     * B BigEndian\n+     * L LittleEndian\n+     * V VarHandle\n+     * U Unsafe\n+     * R ReverseBytes\n+     * C Unsafe.getChar & putChar\n+     * S Unsafe.getShort & putShort\n+     * ```\n+     *\/\n+\n+    @Benchmark\n+    public void getIntB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntBV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_B.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntLV(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (int) INT_L.get(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRB(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRB(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRBU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRBU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRL(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRL(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRLU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += getIntRLU(bytes4, i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntRU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += Integer.reverseBytes(\n+                    UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getIntU(Blackhole BH) {\n+        int sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_B.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < ints.length; i++) {\n+            sum += (long) LONG_L.get(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRB(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRBU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRL(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += getLongRLU(bytes8, i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongRU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += Long.reverseBytes(\n+                    UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8));\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getLongU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            sum += UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8);\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharB(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharB(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharBV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = (char) CHAR_B.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharBU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharBU(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharL(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharL(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+    @Benchmark\n+    public void getCharLU(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = getCharLU(bytes4, i);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+\n+    @Benchmark\n+    public void getCharLV(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = (char) CHAR_L.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    @Benchmark\n+    public void getCharC(Blackhole BH) {\n+        long sum = 0;\n+        for (int i = 0; i < longs.length; i++) {\n+            char c = UNSAFE.getChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n+            sum += c;\n+        }\n+        BH.consume(sum);\n+    }\n+\n+    static int getIntB(byte[] array, int offset) {\n+        return ((array[offset    ] & 0xff) << 24)\n+             | ((array[offset + 1] & 0xff) << 16)\n+             | ((array[offset + 2] & 0xff) <<  8)\n+             | ((array[offset + 3] & 0xff)      );\n+    }\n+\n+    static int getIntBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff) << 24)\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff)      );\n+    }\n+\n+    static int getIntL(byte[] array, int offset) {\n+        return ((array[offset       ] & 0xff)      )\n+                | ((array[offset + 1] & 0xff) <<  8)\n+                | ((array[offset + 2] & 0xff) << 16)\n+                | ((array[offset + 3] & 0xff) << 24);\n+    }\n+\n+    static int getIntRB(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntB(array, offset));\n+    }\n+\n+    static int getIntRBU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntBU(array, offset));\n+    }\n+\n+    static int getIntRL(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntL(array, offset));\n+    }\n+\n+    static int getIntRLU(byte[] array, int offset) {\n+        return Integer.reverseBytes(getIntLU(array, offset));\n+    }\n+\n+    static long getLongB(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff) << 56)\n+             | (((long) array[offset + 1] & 0xff) << 48)\n+             | (((long) array[offset + 2] & 0xff) << 40)\n+             | (((long) array[offset + 3] & 0xff) << 32)\n+             | (((long) array[offset + 4] & 0xff) << 24)\n+             | (((long) array[offset + 5] & 0xff) << 16)\n+             | (((long) array[offset + 6] & 0xff) << 8)\n+             | (((long) array[offset + 7] & 0xff)     );\n+    }\n+\n+    static long getLongBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address)     & 0xff)) << 56)\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff))      );\n+    }\n+\n+    public static long getLongL(byte[] array, int offset) {\n+        return (((long) array[offset    ] & 0xff)      )\n+             | (((long) array[offset + 1] & 0xff) <<  8)\n+             | (((long) array[offset + 2] & 0xff) << 16)\n+             | (((long) array[offset + 3] & 0xff) << 24)\n+             | (((long) array[offset + 4] & 0xff) << 32)\n+             | (((long) array[offset + 5] & 0xff) << 40)\n+             | (((long) array[offset + 6] & 0xff) << 48)\n+             | (((long) array[offset + 7] & 0xff) << 56);\n+    }\n+\n+    static long getLongLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return (((long)(UNSAFE.getByte(array, address    ) & 0xff))      )\n+             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) <<  8)\n+             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 16)\n+             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 24)\n+             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 32)\n+             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 40)\n+             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) << 48)\n+             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff)) << 56);\n+    }\n+\n+    static long getLongRB(byte[] array, int offset) {\n+        return getLongB(array, offset);\n+    }\n+\n+    static long getLongRBU(byte[] array, int offset) {\n+        return getLongBU(array, offset);\n+    }\n+\n+    static long getLongRL(byte[] array, int offset) {\n+        return getLongL(array, offset);\n+    }\n+\n+    static long getLongRLU(byte[] array, int offset) {\n+        return getLongLU(array, offset);\n+    }\n+\n+    public static int getIntLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        return ((UNSAFE.getByte(array, address    ) & 0xff)      )\n+             | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n+             | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n+             | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n+    }\n+\n+    public static char getCharB(byte[] val, int index) {\n+        index <<= 1;\n+        return (char)(((val[index    ] & 0xff) << 8)\n+                    | ((val[index + 1] & 0xff)));\n+    }\n+\n+    public static char getCharBR(byte[] val, int index) {\n+        return Character.reverseBytes(getCharB(val, index));\n+    }\n+\n+    public static char getCharL(byte[] val, int index) {\n+        index <<= 1;\n+        return (char)(((val[index    ] & 0xff))\n+                    | ((val[index + 1] & 0xff) << 8));\n+    }\n+\n+    public static char getCharLR(byte[] val, int index) {\n+        return Character.reverseBytes(getCharL(val, index));\n+    }\n+\n+    public static char getCharBU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        return (char) (((UNSAFE.getByte(array, address    ) & 0xff) << 8)\n+                     | ((UNSAFE.getByte(array, address + 1) & 0xff)     ));\n+    }\n+\n+    public static char getCharLU(byte[] array, int offset) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+        return (char) (((UNSAFE.getByte(array, address    ) & 0xff)     )\n+                     | ((UNSAFE.getByte(array, address + 1) & 0xff) << 8));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeLoadBench.java","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n-import org.openjdk.jmh.runner.Runner;\n-import org.openjdk.jmh.runner.options.Options;\n-import org.openjdk.jmh.runner.options.OptionsBuilder;\n@@ -34,1 +31,0 @@\n-import java.lang.reflect.Field;\n@@ -44,1 +40,1 @@\n-@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n@@ -46,1 +42,1 @@\n-@Fork(value = 3, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n+@Fork(value = 1, jvmArgs = {\"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\"})\n@@ -50,6 +46,7 @@\n-    final static VarHandle INT_L  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.LITTLE_ENDIAN);\n-    final static VarHandle INT_B  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.BIG_ENDIAN);\n-    final static VarHandle LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN);\n-    final static VarHandle LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN);\n-    final static VarHandle CHAR_L = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.LITTLE_ENDIAN);\n-    final static VarHandle CHAR_B = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.BIG_ENDIAN);\n+    final static VarHandle\n+            INT_L  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.LITTLE_ENDIAN),\n+            INT_B  = MethodHandles.byteArrayViewVarHandle(int[].class , ByteOrder.BIG_ENDIAN),\n+            LONG_L = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.LITTLE_ENDIAN),\n+            LONG_B = MethodHandles.byteArrayViewVarHandle(long[].class, ByteOrder.BIG_ENDIAN),\n+            CHAR_L = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.LITTLE_ENDIAN),\n+            CHAR_B = MethodHandles.byteArrayViewVarHandle(char[].class, ByteOrder.BIG_ENDIAN);\n@@ -92,109 +89,0 @@\n-    @Benchmark\n-    public void getIntB(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntB(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntBU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntBU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntBV(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (int) INT_B.get(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntL(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntL(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntLU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntLU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntLV(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (int) INT_L.get(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRB(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRB(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRBU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRBU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRL(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRL(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRLU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += getIntRLU(bytes4, i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntRU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += Integer.reverseBytes(\n-                    UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4));\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getIntU(Blackhole BH) {\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += UNSAFE.getInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4);\n-        }\n-        BH.consume(sum);\n-    }\n-\n@@ -214,5 +102,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntBU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntBU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -220,1 +107,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -225,5 +112,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            INT_B.set(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            INT_B.set(bytes4, off, ints[i]);\n+            off += 4;\n@@ -231,1 +117,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -236,5 +122,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntL(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntL(bytes4, off, ints[i]);\n+            off += 4;\n@@ -242,1 +127,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -247,5 +132,4 @@\n-        int sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntLU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntLU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -253,1 +137,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -258,5 +142,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            INT_L.set(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            INT_L.set(bytes4, off, ints[i]);\n+            off += 4;\n@@ -264,1 +147,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -269,5 +152,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRB(bytes4, i * 4, ints[i]);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRB(bytes4, off, ints[i]);\n+            off += 4;\n@@ -275,1 +157,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -280,5 +162,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRBU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRBU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -286,1 +167,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -291,5 +172,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRL(bytes4, i * 4, ints[i]);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRL(bytes4, off, ints[i]);\n+            off += 4;\n@@ -297,1 +177,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -302,5 +182,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            setIntRLU(bytes4, i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            setIntRLU(bytes4, off, ints[i]);\n+            off += 4;\n@@ -308,1 +187,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -313,6 +192,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            v = Integer.reverseBytes(v);\n-            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, Integer.reverseBytes(ints[i]));\n+            off += 4;\n@@ -320,1 +197,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -325,59 +202,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            int v = ints[i];\n-            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 4, v);\n-            sum += v;\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongB(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongB(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongBU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongBU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongBV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (long) LONG_B.get(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongL(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongL(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongLU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongLU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongLV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < ints.length; i++) {\n-            sum += (long) LONG_L.get(bytes8, i * 8);\n+        int off = 0;\n+        for (int i = ints.length - 1; i >= 0; i--) {\n+            UNSAFE.putInt(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, ints[i]);\n+            off += 4;\n@@ -385,56 +207,1 @@\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRB(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRB(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRBU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRBU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRL(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRL(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRLU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += getLongRLU(bytes8, i * 8);\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongRU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += Long.reverseBytes(\n-                    UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8));\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getLongU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            sum += UNSAFE.getLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8);\n-        }\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -445,5 +212,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongB(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongB(bytes8, off, longs[i]);\n+            off += 8;\n@@ -451,1 +217,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -456,5 +222,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongBU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongBU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -462,1 +227,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -467,5 +232,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            LONG_B.set(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            LONG_B.set(bytes8, off, longs[i]);\n+            off += 8;\n@@ -473,1 +237,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -478,5 +242,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongL(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongL(bytes8, off, longs[i]);\n+            off += 8;\n@@ -484,1 +247,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -489,5 +252,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongLU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongLU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -495,1 +257,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -500,5 +262,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            LONG_L.set(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            LONG_L.set(bytes8, off, longs[i]);\n+            off += 8;\n@@ -506,1 +267,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -511,5 +272,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRB(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRB(bytes8, off, longs[i]);\n+            off += 8;\n@@ -517,1 +277,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -522,5 +282,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRBU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRBU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -528,1 +287,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -533,5 +292,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRL(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRL(bytes8, off, longs[i]);\n+            off += 8;\n@@ -539,1 +297,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -544,5 +302,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            setLongRLU(bytes8, i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            setLongRLU(bytes8, off, longs[i]);\n+            off += 8;\n@@ -550,1 +307,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -555,6 +312,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            v = Long.reverseBytes(v);\n-            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n-            sum += v;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, Long.reverseBytes(longs[i]));\n+            off += 8;\n@@ -562,1 +317,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -567,15 +322,4 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            long v = longs[i];\n-            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 8, v);\n-            sum += v;\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getCharB(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharB(bytes4, i);\n-            sum += c;\n+        int off = 0;\n+        for (int i = longs.length - 1; i >= 0; i--) {\n+            UNSAFE.putLong(bytes8, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, longs[i]);\n+            off += 8;\n@@ -583,1 +327,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -587,15 +331,5 @@\n-    public void getCharBV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = (char) CHAR_B.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n-            sum += c;\n-        }\n-        BH.consume(sum);\n-    }\n-\n-    @Benchmark\n-    public void getCharBU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharBU(bytes4, i);\n-            sum += c;\n+    public void setCharBS(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            putShortB(bytes4, off, chars[i]);\n+            off += 2;\n@@ -603,1 +337,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -607,14 +341,5 @@\n-    public void getCharL(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharL(bytes4, i);\n-            sum += c;\n-        }\n-        BH.consume(sum);\n-    }\n-    @Benchmark\n-    public void getCharLU(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = getCharLU(bytes4, i);\n-            sum += c;\n+    public void setCharBV(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            CHAR_B.set(bytes4, off, chars[i]);\n+            off += 2;\n@@ -622,1 +347,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -625,1 +350,0 @@\n-\n@@ -627,5 +351,5 @@\n-    public void getCharLV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = (char) CHAR_L.get(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n-            sum += c;\n+    public void setCharLS(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            putShortL(bytes4, off, chars[i]);\n+            off += 2;\n@@ -633,1 +357,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -637,5 +361,5 @@\n-    public void getCharC(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            char c = UNSAFE.getChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2);\n-            sum += c;\n+    public void setCharLV(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            CHAR_L.set(bytes4, off, chars[i]);\n+            off += 2;\n@@ -643,1 +367,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -647,6 +371,5 @@\n-    public void setCharBS(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            putShortB(bytes4, i * 2, c);\n-            sum += c;\n+    public void setCharC(Blackhole BH) {\n+        int off = 0;\n+        for (int i = chars.length - 1; i >= 0; i--) {\n+            UNSAFE.putChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + off, chars[i]);\n+            off += 2;\n@@ -654,1 +377,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -657,0 +380,4 @@\n+    \/*\n+     * putChars4 and putBytes4 Test whether four constant chars can be MergeStored\n+     *\n+     *\/\n@@ -658,6 +385,4 @@\n-    public void setCharBV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            CHAR_B.set(bytes4, i * 2, c);\n-            sum += c;\n+    public void putBytes4(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putBytes4(bytes4, off, 'n', 'u', 'l', 'l');\n@@ -665,1 +390,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -669,6 +394,4 @@\n-    public void setCharLS(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            putShortL(bytes4, i * 2, c);\n-            sum += c;\n+    public void putBytes4X(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putBytes4X(bytes4, off, 'n', 'u', 'l', 'l');\n@@ -676,1 +399,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -680,6 +403,4 @@\n-    public void setCharLV(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            CHAR_L.set(bytes4, i * 2, c);\n-            sum += c;\n+    public void putBytes4U(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putBytes4U(bytes4, off, 'n', 'u', 'l', 'l');\n@@ -687,1 +408,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -691,6 +412,6 @@\n-    public void setCharC(Blackhole BH) {\n-        long sum = 0;\n-        for (int i = 0; i < chars.length; i++) {\n-            char c = chars[i];\n-            UNSAFE.putChar(bytes4, Unsafe.ARRAY_BYTE_BASE_OFFSET + i * 2, c);\n-            sum += c;\n+    @SuppressWarnings(\"deprecation\")\n+    public void putBytes4GetBytes(Blackhole BH) {\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            \"null\".getBytes(0, 4, bytes4, off);\n+            off += 4;\n@@ -698,1 +419,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -701,4 +422,0 @@\n-    \/*\n-     * putChars4 Test whether four constant chars can be MergeStored\n-     *\n-     *\/\n@@ -707,4 +424,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4B(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4B(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -712,1 +428,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -717,4 +433,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4BU(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4BU(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -722,1 +437,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -727,4 +442,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4BV(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4BV(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -732,1 +446,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -737,4 +451,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4L(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4L(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -742,1 +455,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -747,4 +460,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4LU(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4LU(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -752,1 +464,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -757,4 +469,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4LV(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4LV(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -762,1 +473,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -767,4 +478,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4C(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4C(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -772,1 +482,1 @@\n-        BH.consume(sum);\n+        BH.consume(off);\n@@ -777,4 +487,3 @@\n-        long sum = 0;\n-        for (int i = 0; i < longs.length; i++) {\n-            putChars4S(bytes8, i * 4);\n-            sum += longs[i];\n+        int off = 0;\n+        for (int i = 0; i < NUMBERS; i++) {\n+            off = putChars4S(bytes8, off, 'n', 'u', 'l', 'l');\n@@ -782,39 +491,1 @@\n-        BH.consume(sum);\n-    }\n-\n-    static int getIntB(byte[] array, int offset) {\n-        return ((array[offset    ] & 0xff) << 24)\n-             | ((array[offset + 1] & 0xff) << 16)\n-             | ((array[offset + 2] & 0xff) <<  8)\n-             | ((array[offset + 3] & 0xff)      );\n-    }\n-\n-    static int getIntBU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return ((UNSAFE.getByte(array, address    ) & 0xff) << 24)\n-             | ((UNSAFE.getByte(array, address + 1) & 0xff) << 16)\n-             | ((UNSAFE.getByte(array, address + 2) & 0xff) <<  8)\n-             | ((UNSAFE.getByte(array, address + 3) & 0xff)      );\n-    }\n-\n-    static int getIntL(byte[] array, int offset) {\n-        return ((array[offset       ] & 0xff)      )\n-                | ((array[offset + 1] & 0xff) <<  8)\n-                | ((array[offset + 2] & 0xff) << 16)\n-                | ((array[offset + 3] & 0xff) << 24);\n-    }\n-\n-    static int getIntRB(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntB(array, offset));\n-    }\n-\n-    static int getIntRBU(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntBU(array, offset));\n-    }\n-\n-    static int getIntRL(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntL(array, offset));\n-    }\n-\n-    static int getIntRLU(byte[] array, int offset) {\n-        return Integer.reverseBytes(getIntLU(array, offset));\n+        BH.consume(off);\n@@ -873,62 +544,0 @@\n-    static long getLongB(byte[] array, int offset) {\n-        return (((long) array[offset    ] & 0xff) << 56)\n-             | (((long) array[offset + 1] & 0xff) << 48)\n-             | (((long) array[offset + 2] & 0xff) << 40)\n-             | (((long) array[offset + 3] & 0xff) << 32)\n-             | (((long) array[offset + 4] & 0xff) << 24)\n-             | (((long) array[offset + 5] & 0xff) << 16)\n-             | (((long) array[offset + 6] & 0xff) << 8)\n-             | (((long) array[offset + 7] & 0xff)     );\n-    }\n-\n-    static long getLongBU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return (((long)(UNSAFE.getByte(array, address)     & 0xff)) << 56)\n-             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) << 48)\n-             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 40)\n-             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 32)\n-             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 24)\n-             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 16)\n-             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) <<  8)\n-             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff))      );\n-    }\n-\n-    public static long getLongL(byte[] array, int offset) {\n-        return (((long) array[offset    ] & 0xff)      )\n-             | (((long) array[offset + 1] & 0xff) <<  8)\n-             | (((long) array[offset + 2] & 0xff) << 16)\n-             | (((long) array[offset + 3] & 0xff) << 24)\n-             | (((long) array[offset + 4] & 0xff) << 32)\n-             | (((long) array[offset + 5] & 0xff) << 40)\n-             | (((long) array[offset + 6] & 0xff) << 48)\n-             | (((long) array[offset + 7] & 0xff) << 56);\n-    }\n-\n-    static long getLongLU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return (((long)(UNSAFE.getByte(array, address    ) & 0xff))      )\n-             | (((long)(UNSAFE.getByte(array, address + 1) & 0xff)) <<  8)\n-             | (((long)(UNSAFE.getByte(array, address + 2) & 0xff)) << 16)\n-             | (((long)(UNSAFE.getByte(array, address + 3) & 0xff)) << 24)\n-             | (((long)(UNSAFE.getByte(array, address + 4) & 0xff)) << 32)\n-             | (((long)(UNSAFE.getByte(array, address + 5) & 0xff)) << 40)\n-             | (((long)(UNSAFE.getByte(array, address + 6) & 0xff)) << 48)\n-             | (((long)(UNSAFE.getByte(array, address + 7) & 0xff)) << 56);\n-    }\n-\n-    static long getLongRB(byte[] array, int offset) {\n-        return getLongB(array, offset);\n-    }\n-\n-    static long getLongRBU(byte[] array, int offset) {\n-        return getLongBU(array, offset);\n-    }\n-\n-    static long getLongRL(byte[] array, int offset) {\n-        return getLongL(array, offset);\n-    }\n-\n-    static long getLongRLU(byte[] array, int offset) {\n-        return getLongLU(array, offset);\n-    }\n-\n@@ -1001,22 +610,6 @@\n-    public static int getIntLU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n-        return ((UNSAFE.getByte(array, address    ) & 0xff)      )\n-             | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n-             | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n-             | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n-    }\n-\n-    public static char getCharB(byte[] val, int index) {\n-        index <<= 1;\n-        return (char)(((val[index    ] & 0xff) << 8)\n-                    | ((val[index + 1] & 0xff)));\n-    }\n-\n-    public static char getCharBR(byte[] val, int index) {\n-        return Character.reverseBytes(getCharB(val, index));\n-    }\n-\n-    public static char getCharL(byte[] val, int index) {\n-        index <<= 1;\n-        return (char)(((val[index    ] & 0xff))\n-                    | ((val[index + 1] & 0xff) << 8));\n+    public int putBytes4(byte[] bytes, int offset, int c0, int c1, int c2, int c3) {\n+        bytes[offset    ] = (byte) c0;\n+        bytes[offset + 1] = (byte) c1;\n+        bytes[offset + 2] = (byte) c2;\n+        bytes[offset + 3] = (byte) c3;\n+        return offset + 4;\n@@ -1025,2 +618,6 @@\n-    public static char getCharLR(byte[] val, int index) {\n-        return Character.reverseBytes(getCharL(val, index));\n+    public int putBytes4X(byte[] bytes, int offset, int c0, int c1, int c2, int c3) {\n+        bytes[offset++] = (byte) c0;\n+        bytes[offset++] = (byte) c1;\n+        bytes[offset++] = (byte) c2;\n+        bytes[offset++] = (byte) c3;\n+        return offset;\n@@ -1029,10 +626,7 @@\n-    public static char getCharBU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n-        return (char) (((UNSAFE.getByte(array, address    ) & 0xff) << 8)\n-                     | ((UNSAFE.getByte(array, address + 1) & 0xff)     ));\n-    }\n-\n-    public static char getCharLU(byte[] array, int offset) {\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n-        return (char) (((UNSAFE.getByte(array, address    ) & 0xff)     )\n-                     | ((UNSAFE.getByte(array, address + 1) & 0xff) << 8));\n+    public int putBytes4U(byte[] bytes, int offset, int c0, int c1, int c2, int c3) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n+        UNSAFE.putByte(bytes, address    , (byte) c0);\n+        UNSAFE.putByte(bytes, address + 1, (byte) c1);\n+        UNSAFE.putByte(bytes, address + 2, (byte) c2);\n+        UNSAFE.putByte(bytes, address + 3, (byte) c3);\n+        return offset + 4;\n@@ -1041,2 +635,1 @@\n-    public void putChars4B(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4B(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1047,0 +640,1 @@\n+        return offset + 4;\n@@ -1049,2 +643,1 @@\n-    public void putChars4BU(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4BU(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1055,0 +648,1 @@\n+        return offset + 4;\n@@ -1057,4 +651,2 @@\n-    public void putChars4BV(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        offset <<= 1;\n-        CHAR_B.set(bytes, offset    , c0);\n+    public int putChars4BV(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n+        CHAR_B.set(bytes, offset     , c0);\n@@ -1064,0 +656,1 @@\n+        return offset + 8;\n@@ -1066,2 +659,1 @@\n-    public void putChars4L(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4L(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1072,0 +664,1 @@\n+        return offset + 4;\n@@ -1074,3 +667,1 @@\n-    public void putChars4LV(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        offset <<= 1;\n+    public int putChars4LV(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1081,0 +672,1 @@\n+        return offset + 8;\n@@ -1083,2 +675,1 @@\n-    public void putChars4LU(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n+    public int putChars4LU(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n@@ -1089,0 +680,1 @@\n+        return offset + 4;\n@@ -1091,3 +683,2 @@\n-    public void putChars4C(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+    public int putChars4C(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n@@ -1098,0 +689,1 @@\n+        return offset + 8;\n@@ -1100,3 +692,2 @@\n-    public void putChars4S(byte[] bytes, int offset) {\n-        char c0 = 'n', c1 = 'u', c2 = 'l', c3 = 'l';\n-        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + (offset << 1);\n+    public int putChars4S(byte[] bytes, int offset, char c0, char c1, char c2, char c3) {\n+        final long address = Unsafe.ARRAY_BYTE_BASE_OFFSET + offset;\n@@ -1107,0 +698,1 @@\n+        return offset + 8;\n@@ -1132,0 +724,5 @@\n+\n+    @Fork(value = 1, jvmArgs = {\n+            \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-MergeStores\"\n+    })\n+    public static class MergeStoresDisabled extends MergeStoreBench {}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MergeStoreBench.java","additions":255,"deletions":658,"binary":false,"changes":913,"status":"modified"}]}