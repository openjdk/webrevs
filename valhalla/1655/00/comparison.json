{"files":[{"patch":"@@ -2376,3 +2376,0 @@\n-    \/\/ Read the klass before the copying, since it might destroy the klass (i.e. overlapping copy)\n-    \/\/ and if partial copy, the destination klass may not be copied yet\n-    Klass* klass = cast_to_oop(source())->klass();\n@@ -2380,1 +2377,1 @@\n-    cast_to_oop(copy_destination())->set_mark(Klass::default_prototype_header(klass));\n+    cast_to_oop(copy_destination())->reinit_mark();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-    oopDesc::release_set_mark(mem, Klass::default_prototype_header(_klass));\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n@@ -389,1 +389,1 @@\n-      oopDesc::set_mark(mem, Klass::default_prototype_header(_klass));\n+      oopDesc::set_mark(mem, _klass->prototype_header());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -745,1 +745,0 @@\n-  static inline markWord default_prototype_header(Klass* k);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,5 +93,0 @@\n-\/\/ May no longer be required (was used to avoid a bootstrapping problem...\n-inline markWord Klass::default_prototype_header(Klass* k) {\n-  return (k == nullptr) ? markWord::prototype() : k->prototype_header();\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -309,1 +309,2 @@\n-    return (!is_unlocked() || !has_no_hash() || (EnableValhalla && is_larval_state()));\n+    return (!is_unlocked() || !has_no_hash() ||\n+      (EnableValhalla && (is_larval_state() || is_inline_type() || is_flat_array() || is_null_free_array())));\n@@ -414,1 +415,0 @@\n-#ifdef _LP64 \/\/ 64 bit encodings only\n@@ -416,0 +416,1 @@\n+#ifdef _LP64 \/\/ 64 bit encodings only\n@@ -418,0 +419,3 @@\n+#else\n+    return false;\n+#endif\n@@ -421,0 +425,1 @@\n+#ifdef _LP64 \/\/ 64 bit encodings only\n@@ -422,1 +427,0 @@\n-  }\n@@ -424,2 +428,0 @@\n-  bool is_flat_array() const {\n-    fatal(\"Should not ask this for mark word, ask oopDesc\");\n@@ -427,0 +429,1 @@\n+#endif\n@@ -429,5 +432,0 @@\n-  bool is_null_free_array() const {\n-    fatal(\"Should not ask this for mark word, ask oopDesc\");\n-    return false;\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+  inline void reinit_mark(); \/\/ special for parallelGC\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,0 +98,11 @@\n+\/\/ This is for parallel gc, which doesn't always have the klass.\n+\/\/ markWord::must_be_preserved preserves the original prototype header bits for EnableValhalla,\n+\/\/ I don't know why serial gc doesn't work the same.\n+void oopDesc::reinit_mark() {\n+  if (UseCompactObjectHeaders) {\n+    set_mark(klass()->prototype_header());\n+  } else {\n+    set_mark(markWord::prototype());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}