{"files":[{"patch":"@@ -2463,1 +2463,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2048+pad, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 2048+pad, 1024);\n@@ -2847,1 +2848,3 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n+\n@@ -2853,1 +2856,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 2048, 1024);\n@@ -2859,2 +2863,2 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n-  RegisterSaver reg_save(poll_type == POLL_AT_VECTOR_LOOP \/* save_vectors *\/);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  RegisterSaver reg_save(id == SharedStubId::polling_page_vectors_safepoint_handler_id \/* save_vectors *\/);\n@@ -2972,1 +2976,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -2974,0 +2978,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -2978,0 +2983,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -3182,1 +3188,5 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n@@ -3291,1 +3301,2 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n@@ -3310,1 +3321,1 @@\n-    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n@@ -3329,1 +3340,2 @@\n-  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n@@ -3348,1 +3360,1 @@\n-    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1862,1 +1862,1 @@\n-    __ call_c_with_frame_resize(copyfunc_addr, \/*stub does not need resized frame*\/ 0);\n+    __ call_c(copyfunc_addr, relocInfo::runtime_call_type);\n@@ -2060,1 +2060,1 @@\n-        __ call_c_with_frame_resize(copyfunc_addr, \/*stub does not need resized frame*\/ 0);\n+        __ call_c(copyfunc_addr, relocInfo::runtime_call_type);\n@@ -2184,1 +2184,1 @@\n-  __ call_c_with_frame_resize(entry, \/*stub does not need resized frame*\/ 0);\n+  __ call_c(entry, relocInfo::runtime_call_type);\n@@ -2865,1 +2865,1 @@\n-  __ call_c_with_frame_resize(dest, \/*no resizing*\/ 0);\n+  __ call_c(dest, relocInfo::runtime_call_type);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -138,9 +138,1 @@\n-#if defined(ABI_ELFv2)\n-    call_c(CAST_FROM_FN_PTR(address,\n-                            Interpreter::remove_activation_preserving_args_entry),\n-           relocInfo::none);\n-#else\n-    call_c(CAST_FROM_FN_PTR(FunctionDescriptor*,\n-                            Interpreter::remove_activation_preserving_args_entry),\n-           relocInfo::none);\n-#endif\n+    call_c(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_preserving_args_entry));\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2080,1 +2080,2 @@\n-  CodeBuffer   buffer(\"deopt_blob\", 1536, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer   buffer(name, 1536, 1024);\n@@ -2421,1 +2422,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -2428,0 +2429,1 @@\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n@@ -2435,1 +2437,2 @@\n-  CodeBuffer   buffer(\"handler_blob\", 2048, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer   buffer(name, 2048, 1024);\n@@ -2441,2 +2444,2 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n-  bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool save_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n@@ -2574,1 +2577,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -2576,0 +2579,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -2580,0 +2584,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -2685,1 +2690,4 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -2799,1 +2807,2 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n@@ -2818,1 +2827,1 @@\n-    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n@@ -2840,1 +2849,2 @@\n-  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, insts_size, locs_size);\n@@ -2858,1 +2868,1 @@\n-    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+    RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2900,1 +2900,2 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2560+pad, 1024);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::deopt_id);\n+  CodeBuffer buffer(name, 2560+pad, 1024);\n@@ -3258,1 +3259,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -3261,0 +3262,1 @@\n+  assert(is_polling_page_id(id), \"expected a polling page stub id\");\n@@ -3267,1 +3269,2 @@\n-  CodeBuffer buffer(\"handler_blob\", 2348, 1024);\n+  const char* name = SharedRuntime::stub_name(id);\n+  CodeBuffer buffer(name, 2348, 1024);\n@@ -3273,2 +3276,2 @@\n-  bool cause_return = (poll_type == POLL_AT_RETURN);\n-  bool save_wide_vectors = (poll_type == POLL_AT_VECTOR_LOOP);\n+  bool cause_return = (id == SharedStubId::polling_page_return_handler_id);\n+  bool save_wide_vectors = (id == SharedStubId::polling_page_vectors_safepoint_handler_id);\n@@ -3417,1 +3420,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -3419,0 +3422,1 @@\n+  assert(is_resolve_id(id), \"expected a resolve stub id\");\n@@ -3423,0 +3427,1 @@\n+  const char* name = SharedRuntime::stub_name(id);\n@@ -3509,1 +3514,5 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n+  assert(is_throw_id(id), \"expected a throw stub id\");\n+\n+  const char* name = SharedRuntime::stub_name(id);\n+\n@@ -3979,1 +3988,2 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_write_checkpoint_id);\n+  CodeBuffer code(name, 1024, 64);\n@@ -4004,1 +4014,1 @@\n-    RuntimeStub::new_runtime_stub(code.name(),\n+    RuntimeStub::new_runtime_stub(name,\n@@ -4023,1 +4033,2 @@\n-  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n+  const char* name = SharedRuntime::stub_name(SharedStubId::jfr_return_lease_id);\n+  CodeBuffer code(name, 1024, 64);\n@@ -4045,1 +4056,1 @@\n-    RuntimeStub::new_runtime_stub(code.name(),\n+    RuntimeStub::new_runtime_stub(name,\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {\n+SafepointBlob* SharedRuntime::generate_handler_blob(SharedStubId id, address call_ptr) {\n@@ -135,1 +135,1 @@\n-RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {\n+RuntimeStub* SharedRuntime::generate_resolve_blob(SharedStubId id, address destination) {\n@@ -139,1 +139,1 @@\n-RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+RuntimeStub* SharedRuntime::generate_throw_exception(SharedStubId id, address runtime_entry) {\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1360,94 +1360,0 @@\n-\/\/ Field allocation types. Used for computing field offsets.\n-\n-enum FieldAllocationType {\n-  STATIC_OOP,           \/\/ Oops\n-  STATIC_BYTE,          \/\/ Boolean, Byte, char\n-  STATIC_SHORT,         \/\/ shorts\n-  STATIC_WORD,          \/\/ ints\n-  STATIC_DOUBLE,        \/\/ aligned long or double\n-  STATIC_INLINE,        \/\/ inline type field\n-  NONSTATIC_OOP,\n-  NONSTATIC_BYTE,\n-  NONSTATIC_SHORT,\n-  NONSTATIC_WORD,\n-  NONSTATIC_DOUBLE,\n-  NONSTATIC_INLINE,\n-  MAX_FIELD_ALLOCATION_TYPE,\n-  BAD_ALLOCATION_TYPE = -1\n-};\n-\n-static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {\n-  BAD_ALLOCATION_TYPE, \/\/ 0\n-  BAD_ALLOCATION_TYPE, \/\/ 1\n-  BAD_ALLOCATION_TYPE, \/\/ 2\n-  BAD_ALLOCATION_TYPE, \/\/ 3\n-  NONSTATIC_BYTE ,     \/\/ T_BOOLEAN     =  4,\n-  NONSTATIC_SHORT,     \/\/ T_CHAR        =  5,\n-  NONSTATIC_WORD,      \/\/ T_FLOAT       =  6,\n-  NONSTATIC_DOUBLE,    \/\/ T_DOUBLE      =  7,\n-  NONSTATIC_BYTE,      \/\/ T_BYTE        =  8,\n-  NONSTATIC_SHORT,     \/\/ T_SHORT       =  9,\n-  NONSTATIC_WORD,      \/\/ T_INT         = 10,\n-  NONSTATIC_DOUBLE,    \/\/ T_LONG        = 11,\n-  NONSTATIC_OOP,       \/\/ T_OBJECT      = 12,\n-  NONSTATIC_OOP,       \/\/ T_ARRAY       = 13,\n-  NONSTATIC_OOP,       \/\/ T_PRIMITIVE_OBJECT = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20,\n-  BAD_ALLOCATION_TYPE, \/\/ 0\n-  BAD_ALLOCATION_TYPE, \/\/ 1\n-  BAD_ALLOCATION_TYPE, \/\/ 2\n-  BAD_ALLOCATION_TYPE, \/\/ 3\n-  STATIC_BYTE ,        \/\/ T_BOOLEAN     =  4,\n-  STATIC_SHORT,        \/\/ T_CHAR        =  5,\n-  STATIC_WORD,         \/\/ T_FLOAT       =  6,\n-  STATIC_DOUBLE,       \/\/ T_DOUBLE      =  7,\n-  STATIC_BYTE,         \/\/ T_BYTE        =  8,\n-  STATIC_SHORT,        \/\/ T_SHORT       =  9,\n-  STATIC_WORD,         \/\/ T_INT         = 10,\n-  STATIC_DOUBLE,       \/\/ T_LONG        = 11,\n-  STATIC_OOP,          \/\/ T_OBJECT      = 12,\n-  STATIC_OOP,          \/\/ T_ARRAY       = 13,\n-  STATIC_OOP,          \/\/ T_PRIMITIVE_OBJECT = 14,\n-  BAD_ALLOCATION_TYPE, \/\/ T_VOID        = 15,\n-  BAD_ALLOCATION_TYPE, \/\/ T_ADDRESS     = 16,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWOOP   = 17,\n-  BAD_ALLOCATION_TYPE, \/\/ T_METADATA    = 18,\n-  BAD_ALLOCATION_TYPE, \/\/ T_NARROWKLASS = 19,\n-  BAD_ALLOCATION_TYPE, \/\/ T_CONFLICT    = 20\n-};\n-\n-static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_inline_type) {\n-  assert(type >= T_BOOLEAN && type < T_VOID, \"only allowable values\");\n-  FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];\n-  assert(result != BAD_ALLOCATION_TYPE, \"bad type\");\n-  if (is_inline_type) {\n-    result = is_static ? STATIC_INLINE : NONSTATIC_INLINE;\n-  }\n-  return result;\n-}\n-\n-class ClassFileParser::FieldAllocationCount : public ResourceObj {\n- public:\n-  u2 count[MAX_FIELD_ALLOCATION_TYPE];\n-\n-  FieldAllocationCount() {\n-    for (int i = 0; i < MAX_FIELD_ALLOCATION_TYPE; i++) {\n-      count[i] = 0;\n-    }\n-  }\n-\n-  void update(bool is_static, BasicType type, bool is_inline_type) {\n-    FieldAllocationType atype = basic_type_to_atype(is_static, type, is_inline_type);\n-    if (atype != BAD_ALLOCATION_TYPE) {\n-      \/\/ Make sure there is no overflow with injected fields.\n-      assert(count[atype] < 0xFFFF, \"More than 65535 fields\");\n-      count[atype]++;\n-    }\n-  }\n-};\n-\n@@ -1458,1 +1364,0 @@\n-                                   FieldAllocationCount* const fac,\n@@ -1465,1 +1370,0 @@\n-  assert(fac != nullptr, \"invariant\");\n@@ -1581,1 +1485,3 @@\n-    const BasicType type = cp->basic_type_for_signature_at(signature_index);\n+    if (is_null_restricted) {\n+      fieldFlags.update_null_free_inline_type(true);\n+    }\n@@ -1583,3 +1489,1 @@\n-    \/\/ Update FieldAllocationCount for this kind of field\n-    \/\/ This use of T_PRIMITIVE_OBJECT is not valid anymore => FIXME (relate to cleanup (removal?) of FiedAllocationCount\n-    fac->update(is_static, type, type == T_PRIMITIVE_OBJECT);\n+    const BasicType type = cp->basic_type_for_signature_at(signature_index);\n@@ -1587,1 +1491,4 @@\n-    if (is_null_restricted) fieldFlags.update_null_free_inline_type(true);\n+    \/\/ Update number of static oop fields.\n+    if (is_static && is_reference_type(type)) {\n+      _static_oop_count++;\n+    }\n@@ -1632,4 +1539,0 @@\n-\n-      \/\/ Update FieldAllocationCount for this kind of field\n-      const BasicType type = Signature::basic_type(injected[n].signature());\n-      fac->update(false, type, false);\n@@ -1650,5 +1553,3 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n-\n-    const BasicType type = Signature::basic_type(vmSymbols::object_signature());\n-    fac->update(true, type, false);\n+    fi.set_index(index);\n+    _temp_field_info->append(fi);\n+    _static_oop_count++;\n@@ -1673,2 +1574,0 @@\n-    const BasicType type = Signature::basic_type(vmSymbols::byte_signature());\n-    fac->update(false, type, false);\n@@ -5416,2 +5315,1 @@\n-  assert(_fac != nullptr, \"invariant\");\n-  ik->set_static_oop_field_count(_fac->count[STATIC_OOP] + _fac->count[STATIC_INLINE]);\n+  ik->set_static_oop_field_count(_static_oop_count);\n@@ -5698,0 +5596,1 @@\n+  _static_oop_count(0),\n@@ -5720,1 +5619,0 @@\n-  _fac(nullptr),\n@@ -6080,1 +5978,0 @@\n-  _fac = new FieldAllocationCount();\n@@ -6082,1 +5979,0 @@\n-               _fac,\n@@ -6332,1 +6228,0 @@\n-  assert(_fac != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":13,"deletions":118,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  class FieldAllocationCount;\n@@ -122,0 +121,1 @@\n+  unsigned int _static_oop_count;\n@@ -149,1 +149,0 @@\n-  FieldAllocationCount* _fac;\n@@ -285,1 +284,0 @@\n-                    FieldAllocationCount* const fac,\n@@ -596,0 +594,1 @@\n+  bool is_abstract() const { return _access_flags.is_abstract(); }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -628,0 +628,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -646,1 +646,1 @@\n-      constantTag tag = cp->tag_at(cp_index);\n+      constantTag tag = cp->constant_tag_at(cp_index);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,4 @@\n+void* ArrayKlass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {\n+  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, true, THREAD);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,2 @@\n+  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -454,0 +454,5 @@\n+void* InstanceKlass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size,\n+                                  bool use_class_space, TRAPS) throw() {\n+  return Metaspace::allocate(loader_data, word_size, ClassType, use_class_space, THREAD);\n+}\n+\n@@ -467,0 +472,1 @@\n+  const bool use_class_space = !parser.is_interface() && !parser.is_abstract();\n@@ -471,1 +477,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceRefKlass(parser);\n@@ -474,1 +480,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceMirrorKlass(parser);\n@@ -477,1 +483,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceStackChunkKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceStackChunkKlass(parser);\n@@ -480,1 +486,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceClassLoaderKlass(parser);\n@@ -483,1 +489,1 @@\n-    ik = new (loader_data, size, THREAD) InlineKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InlineKlass(parser);\n@@ -486,1 +492,1 @@\n-    ik = new (loader_data, size, THREAD) InstanceKlass(parser);\n+    ik = new (loader_data, size, use_class_space, THREAD) InstanceKlass(parser);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -169,0 +170,2 @@\n+  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, bool use_class_space, TRAPS) throw();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,4 +250,0 @@\n-void* Klass::operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw() {\n-  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,2 +212,0 @@\n-  void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -770,1 +770,1 @@\n-      init_start(s);\n+      verify_start(s);\n@@ -777,1 +777,1 @@\n-      init_start(s);\n+      verify_start(s);\n@@ -1136,6 +1136,4 @@\n-\/\/---------------------------init_start----------------------------------------\n-\/\/ Install the StartNode on this compile object.\n-void Compile::init_start(StartNode* s) {\n-  if (failing())\n-    return; \/\/ already failing\n-  assert(s == start(), \"\");\n+#ifdef ASSERT\n+\/\/ Verify that the current StartNode is valid.\n+void Compile::verify_start(StartNode* s) const {\n+  assert(failing() || s == start(), \"should be StartNode\");\n@@ -1143,0 +1141,1 @@\n+#endif\n@@ -5750,1 +5749,14 @@\n-    ss.print(\": %d %s \", n->_idx, NodeClassNames[n->Opcode()]);\n+    ss.print(\": %d %s\", n->_idx, NodeClassNames[n->Opcode()]);\n+    if (n->is_Call()) {\n+      CallNode* call = n->as_Call();\n+      if (call->_name != nullptr) {\n+        \/\/ E.g. uncommon traps etc.\n+        ss.print(\" - %s\", call->_name);\n+      } else if (call->is_CallJava()) {\n+        CallJavaNode* call_java = call->as_CallJava();\n+        if (call_java->method() != nullptr) {\n+          ss.print(\" -\");\n+          call_java->method()->print_short_name(&ss);\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -893,1 +893,1 @@\n-  void         init_start(StartNode* s);\n+  void         verify_start(StartNode* s) const NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  C->init_start(start);\n+  C->verify_start(start);\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -974,4 +974,0 @@\n-#ifdef ASSERT\n-  bool only_has_infinite_loops();\n-#endif\n-\n@@ -1084,1 +1080,1 @@\n-  int build_loop_tree_impl( Node *n, int pre_order );\n+  int build_loop_tree_impl(Node* n, int pre_order);\n@@ -1192,0 +1188,10 @@\n+  Node* dominated_node(Node* c1, Node* c2) {\n+    assert(is_dominator(c1, c2) || is_dominator(c2, c1), \"nodes must be related\");\n+    return is_dominator(c1, c2) ? c2 : c1;\n+  }\n+\n+  \/\/ Return control node that's dominated by the 2 others\n+  Node* dominated_node(Node* c1, Node* c2, Node* c3) {\n+    return dominated_node(c1, dominated_node(c2, c3));\n+  }\n+\n@@ -1798,0 +1804,2 @@\n+\n+  Node* ensure_node_and_inputs_are_above_pre_end(CountedLoopEndNode* pre_end, Node* node);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -609,0 +609,63 @@\n+template<typename IntegerType>\n+static const IntegerType* and_value(const IntegerType* r0, const IntegerType* r1) {\n+  typedef typename IntegerType::NativeType NativeType;\n+  static_assert(std::is_signed<NativeType>::value, \"Native type of IntegerType must be signed!\");\n+\n+  int widen = MAX2(r0->_widen, r1->_widen);\n+\n+  \/\/ If both types are constants, we can calculate a constant result.\n+  if (r0->is_con() && r1->is_con()) {\n+    return IntegerType::make(r0->get_con() & r1->get_con());\n+  }\n+\n+  \/\/ If both ranges are positive, the result will range from 0 up to the hi value of the smaller range. The minimum\n+  \/\/ of the two constrains the upper bound because any higher value in the other range will see all zeroes, so it will be masked out.\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+    return IntegerType::make(0, MIN2(r0->_hi, r1->_hi), widen);\n+  }\n+\n+  \/\/ If only one range is positive, the result will range from 0 up to that range's maximum value.\n+  \/\/ For the operation 'x & C' where C is a positive constant, the result will be in the range [0..C]. With that observation,\n+  \/\/ we can say that for any integer c such that 0 <= c <= C will also be in the range [0..C]. Therefore, 'x & [c..C]'\n+  \/\/ where c >= 0 will be in the range [0..C].\n+  if (r0->_lo >= 0) {\n+    return IntegerType::make(0, r0->_hi, widen);\n+  }\n+\n+  if (r1->_lo >= 0) {\n+    return IntegerType::make(0, r1->_hi, widen);\n+  }\n+\n+  \/\/ At this point, all positive ranges will have already been handled, so the only remaining cases will be negative ranges\n+  \/\/ and constants.\n+\n+  assert(r0->_lo < 0 && r1->_lo < 0, \"positive ranges should already be handled!\");\n+\n+  \/\/ As two's complement means that both numbers will start with leading 1s, the lower bound of both ranges will contain\n+  \/\/ the common leading 1s of both minimum values. In order to count them with count_leading_zeros, the bits are inverted.\n+  NativeType sel_val = ~MIN2(r0->_lo, r1->_lo);\n+\n+  NativeType min;\n+  if (sel_val == 0) {\n+    \/\/ Since count_leading_zeros is undefined at 0, we short-circuit the condition where both ranges have a minimum of -1.\n+    min = -1;\n+  } else {\n+    \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n+    int shift_bits = count_leading_zeros(sel_val) - 1;\n+    min = std::numeric_limits<NativeType>::min() >> shift_bits;\n+  }\n+\n+  NativeType max;\n+  if (r0->_hi < 0 && r1->_hi < 0) {\n+    \/\/ If both ranges are negative, then the same optimization as both positive ranges will apply, and the smaller hi\n+    \/\/ value will mask off any bits set by higher values.\n+    max = MIN2(r0->_hi, r1->_hi);\n+  } else {\n+    \/\/ In the case of ranges that cross zero, negative values can cause the higher order bits to be set, so the maximum\n+    \/\/ positive value can be as high as the larger hi value.\n+    max = MAX2(r0->_hi, r1->_hi);\n+  }\n+\n+  return IntegerType::make(min, max, widen);\n+}\n+\n@@ -616,14 +679,2 @@\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeInt::INT;        \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeInt::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeInt::make(0, r0->get_con(), widen);\n+  const TypeInt* r0 = t0->is_int();\n+  const TypeInt* r1 = t1->is_int();\n@@ -631,8 +682,1 @@\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeInt::make(0, r1->get_con(), widen);\n-\n-  if( r0 == TypeInt::BOOL || r1 == TypeInt::BOOL ) {\n-    return TypeInt::BOOL;\n-  }\n-\n-  return TypeInt::INT;          \/\/ No constants to be had\n+  return and_value<TypeInt>(r0, r1);\n@@ -766,17 +810,2 @@\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeLong::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r0->get_con(), widen);\n-\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r1->get_con(), widen);\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n@@ -784,1 +813,1 @@\n-  return TypeLong::LONG;        \/\/ No constants to be had\n+  return and_value<TypeLong>(r0, r1);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":69,"deletions":40,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -1731,1 +1731,1 @@\n-  if (target_bci < bci()) {\n+  if (target_bci <= bci()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2588,0 +2588,7 @@\n+\/\/ Available cpus of the host machine, Linux only.\n+\/\/ Used in container testing.\n+WB_ENTRY(jint, WB_HostCPUs(JNIEnv* env, jobject o))\n+  LINUX_ONLY(return os::Linux::active_processor_count();)\n+  return -1; \/\/ Not used\/implemented on other platforms\n+WB_END\n+\n@@ -3035,0 +3042,1 @@\n+  {CC\"hostCPUs\",                  CC\"()I\",            (void*)&WB_HostCPUs },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,21 +100,4 @@\n-RuntimeStub*        SharedRuntime::_wrong_method_blob;\n-RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;\n-RuntimeStub*        SharedRuntime::_ic_miss_blob;\n-RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;\n-RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;\n-RuntimeStub*        SharedRuntime::_resolve_static_call_blob;\n-\n-DeoptimizationBlob* SharedRuntime::_deopt_blob;\n-SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;\n-SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;\n-SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;\n-\n-RuntimeStub*        SharedRuntime::_throw_AbstractMethodError_blob;\n-RuntimeStub*        SharedRuntime::_throw_IncompatibleClassChangeError_blob;\n-RuntimeStub*        SharedRuntime::_throw_NullPointerException_at_call_blob;\n-RuntimeStub*        SharedRuntime::_throw_StackOverflowError_blob;\n-RuntimeStub*        SharedRuntime::_throw_delayed_StackOverflowError_blob;\n-#if INCLUDE_JFR\n-RuntimeStub*        SharedRuntime::_jfr_write_checkpoint_blob = nullptr;\n-RuntimeStub*        SharedRuntime::_jfr_return_lease_blob = nullptr;\n-#endif\n+#define SHARED_STUB_FIELD_DEFINE(name, type) \\\n+  type        SharedRuntime::BLOB_FIELD_NAME(name);\n+  SHARED_STUBS_DO(SHARED_STUB_FIELD_DEFINE)\n+#undef SHARED_STUB_FIELD_DEFINE\n@@ -125,0 +108,5 @@\n+#define SHARED_STUB_NAME_DECLARE(name, type) \"Shared Runtime \" # name \"_blob\",\n+const char *SharedRuntime::_stub_names[] = {\n+  SHARED_STUBS_DO(SHARED_STUB_NAME_DECLARE)\n+};\n+\n@@ -129,1 +117,1 @@\n-    generate_throw_exception(\"StackOverflowError throw_exception\",\n+    generate_throw_exception(SharedStubId::throw_StackOverflowError_id,\n@@ -134,6 +122,18 @@\n-  _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          \"wrong_method_stub\");\n-  _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), \"wrong_method_abstract_stub\");\n-  _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  \"ic_miss_stub\");\n-  _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   \"resolve_opt_virtual_call\");\n-  _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       \"resolve_virtual_call\");\n-  _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        \"resolve_static_call\");\n+  _wrong_method_blob =\n+    generate_resolve_blob(SharedStubId::wrong_method_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method));\n+  _wrong_method_abstract_blob =\n+    generate_resolve_blob(SharedStubId::wrong_method_abstract_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract));\n+  _ic_miss_blob =\n+    generate_resolve_blob(SharedStubId::ic_miss_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss));\n+  _resolve_opt_virtual_call_blob =\n+    generate_resolve_blob(SharedStubId::resolve_opt_virtual_call_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C));\n+  _resolve_virtual_call_blob =\n+    generate_resolve_blob(SharedStubId::resolve_virtual_call_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C));\n+  _resolve_static_call_blob =\n+    generate_resolve_blob(SharedStubId::resolve_static_call_id,\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C));\n@@ -142,1 +142,1 @@\n-    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n+    generate_throw_exception(SharedStubId::throw_delayed_StackOverflowError_id,\n@@ -146,1 +146,1 @@\n-    generate_throw_exception(\"AbstractMethodError throw_exception\",\n+    generate_throw_exception(SharedStubId::throw_AbstractMethodError_id,\n@@ -150,1 +150,1 @@\n-    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n+    generate_throw_exception(SharedStubId::throw_IncompatibleClassChangeError_id,\n@@ -154,1 +154,1 @@\n-    generate_throw_exception(\"NullPointerException at call throw_exception\",\n+    generate_throw_exception(SharedStubId::throw_NullPointerException_at_call_id,\n@@ -163,1 +163,3 @@\n-    _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);\n+    _polling_page_vectors_safepoint_handler_blob =\n+      generate_handler_blob(SharedStubId::polling_page_vectors_safepoint_handler_id,\n+                            CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception));\n@@ -166,2 +168,6 @@\n-  _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);\n-  _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);\n+  _polling_page_safepoint_handler_blob =\n+    generate_handler_blob(SharedStubId::polling_page_safepoint_handler_id,\n+                          CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception));\n+  _polling_page_return_handler_blob =\n+    generate_handler_blob(SharedStubId::polling_page_return_handler_id,\n+                          CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":41,"deletions":35,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/stubDeclarations.hpp\"\n@@ -48,0 +49,10 @@\n+\/\/ define SharedStubId enum tags: wrong_method_id, etc\n+\n+#define SHARED_STUB_ID_ENUM_DECLARE(name, type) STUB_ID_NAME(name),\n+enum class SharedStubId :int {\n+  NO_STUBID = -1,\n+  SHARED_STUBS_DO(SHARED_STUB_ID_ENUM_DECLARE)\n+  NUM_STUBIDS\n+};\n+#undef SHARED_STUB_ID_ENUM_DECLARE\n+\n@@ -52,14 +63,28 @@\n-  \/\/ Shared stub locations\n-\n-  static RuntimeStub*        _wrong_method_blob;\n-  static RuntimeStub*        _wrong_method_abstract_blob;\n-  static RuntimeStub*        _ic_miss_blob;\n-  static RuntimeStub*        _resolve_opt_virtual_call_blob;\n-  static RuntimeStub*        _resolve_virtual_call_blob;\n-  static RuntimeStub*        _resolve_static_call_blob;\n-\n-  static DeoptimizationBlob* _deopt_blob;\n-\n-  static SafepointBlob*      _polling_page_vectors_safepoint_handler_blob;\n-  static SafepointBlob*      _polling_page_safepoint_handler_blob;\n-  static SafepointBlob*      _polling_page_return_handler_blob;\n+  \/\/ Declare shared stub fields\n+#define SHARED_STUB_FIELD_DECLARE(name, type) \\\n+  static type        BLOB_FIELD_NAME(name);\n+  SHARED_STUBS_DO(SHARED_STUB_FIELD_DECLARE)\n+#undef SHARED_STUB_FIELD_DECLARE\n+\n+#ifdef ASSERT\n+  static bool is_resolve_id(SharedStubId id) {\n+    return (id == SharedStubId::wrong_method_id ||\n+            id == SharedStubId::wrong_method_abstract_id ||\n+            id == SharedStubId::ic_miss_id ||\n+            id == SharedStubId::resolve_opt_virtual_call_id ||\n+            id == SharedStubId::resolve_virtual_call_id ||\n+            id == SharedStubId::resolve_static_call_id);\n+  }\n+  static bool is_polling_page_id(SharedStubId id) {\n+    return (id == SharedStubId::polling_page_vectors_safepoint_handler_id ||\n+            id == SharedStubId::polling_page_safepoint_handler_id ||\n+            id == SharedStubId::polling_page_return_handler_id);\n+  }\n+  static bool is_throw_id(SharedStubId id) {\n+    return (id == SharedStubId::throw_AbstractMethodError_id ||\n+            id == SharedStubId::throw_IncompatibleClassChangeError_id ||\n+            id == SharedStubId::throw_NullPointerException_at_call_id ||\n+            id == SharedStubId::throw_StackOverflowError_id ||\n+            id == SharedStubId::throw_delayed_StackOverflowError_id);\n+  }\n+#endif\n@@ -67,0 +92,4 @@\n+  \/\/ cont_doYieldStub is not yet folded into the general model for\n+  \/\/ shared stub\/blob handling. It is actually a specially generated\n+  \/\/ native wrapper for a specific native method, as also is it's\n+  \/\/ counterpart the continuation do_enter method.\n@@ -69,10 +98,2 @@\n-  static RuntimeStub*        _throw_AbstractMethodError_blob;\n-  static RuntimeStub*        _throw_IncompatibleClassChangeError_blob;\n-  static RuntimeStub*        _throw_NullPointerException_at_call_blob;\n-  static RuntimeStub*        _throw_StackOverflowError_blob;\n-  static RuntimeStub*        _throw_delayed_StackOverflowError_blob;\n-\n-#if INCLUDE_JFR\n-  static RuntimeStub*        _jfr_write_checkpoint_blob;\n-  static RuntimeStub*        _jfr_return_lease_blob;\n-#endif\n+  \/\/ Stub names indexed by SharedStubId\n+  static const char *_stub_names[];\n@@ -86,4 +107,3 @@\n-  enum { POLL_AT_RETURN,  POLL_AT_LOOP, POLL_AT_VECTOR_LOOP };\n-  static SafepointBlob* generate_handler_blob(address call_ptr, int poll_type);\n-  static RuntimeStub*   generate_resolve_blob(address destination, const char* name);\n-  static RuntimeStub*   generate_throw_exception(const char* name, address runtime_entry);\n+  static SafepointBlob* generate_handler_blob(SharedStubId id, address call_ptr);\n+  static RuntimeStub*   generate_resolve_blob(SharedStubId id, address destination);\n+  static RuntimeStub*   generate_throw_exception(SharedStubId id, address runtime_entry);\n@@ -103,0 +123,5 @@\n+  static const char *stub_name(SharedStubId id) {\n+    assert(id > SharedStubId::NO_STUBID && id < SharedStubId::NUM_STUBIDS, \"stub id out of range\");\n+    return _stub_names[(int)id];\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":53,"deletions":28,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -568,0 +568,6 @@\n+  \/*****************************************************\/                                                                            \\\n+  \/* UpcallStubs (NOTE: incomplete, but only a little) *\/                                                                            \\\n+  \/*****************************************************\/                                                                            \\\n+                                                                                                                                     \\\n+  nonstatic_field(UpcallStub,                  _frame_data_offset,                            ByteSize)                              \\\n+                                                                                                                                     \\\n@@ -1017,1 +1023,3 @@\n-  nonstatic_field(InvocationCounter,           _counter,                                      unsigned int)\n+  nonstatic_field(InvocationCounter,           _counter,                                      unsigned int)                          \\\n+                                                                                                                                     \\\n+  nonstatic_field(UpcallStub::FrameData,       jfa,                                           JavaFrameAnchor)\n@@ -1313,0 +1321,1 @@\n+  declare_type(UpcallStub,               RuntimeBlob)                     \\\n@@ -1908,0 +1917,1 @@\n+  declare_integer_type(ByteSize)                                          \\\n@@ -1956,0 +1966,1 @@\n+  declare_toplevel_type(UpcallStub::FrameData)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1289,1 +1289,1 @@\n-     * @jls 6.7 Fully Qualified Names\n+     * @jls 6.7 Fully Qualified Names and Canonical Names\n@@ -1503,1 +1503,1 @@\n-     * @jls 9.1.1. Interface Modifiers\n+     * @jls 9.1.1 Interface Modifiers\n@@ -2047,1 +2047,1 @@\n-     * @jls 14.3 Local Class Declarations\n+     * @jls 14.3 Local Class and Interface Declarations\n@@ -2060,1 +2060,1 @@\n-     * @jls 8.5 Member Type Declarations\n+     * @jls 8.5 Member Class and Interface Declarations\n@@ -2597,1 +2597,1 @@\n-     * @jls 8.5 Member Type Declarations\n+     * @jls 8.5 Member Class and Interface Declarations\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -348,2 +348,2 @@\n- * @jls 4.2.3 Floating-Point Types, Formats, and Values\n- * @jls 4.2.4. Floating-Point Operations\n+ * @jls 4.2.3 Floating-Point Types and Values\n+ * @jls 4.2.4 Floating-Point Operations\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n- * @jls 8.10 Record Types\n+ * @jls 8.10 Record Classes\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Record.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import java.util.concurrent.Executor;\n@@ -74,0 +75,1 @@\n+import jdk.internal.loader.NativeLibraries;\n@@ -2573,0 +2575,3 @@\n+            public int countNonZeroAscii(String s) {\n+                return StringCoding.countNonZeroAscii(s);\n+            }\n@@ -2642,0 +2647,8 @@\n+            public byte stringInitCoder() {\n+                return String.COMPACT_STRINGS ? String.LATIN1 : String.UTF16;\n+            }\n+\n+            public byte stringCoder(String str) {\n+                return str.coder();\n+            }\n+\n@@ -2663,2 +2676,2 @@\n-            public long findNative(ClassLoader loader, String entry) {\n-                return ClassLoader.findNativeInternal(loader, entry);\n+            public NativeLibraries nativeLibrariesFor(ClassLoader loader) {\n+                return ClassLoader.nativeLibrariesFor(loader);\n@@ -2762,0 +2775,4 @@\n+            public Executor virtualThreadDefaultScheduler() {\n+                return VirtualThread.defaultScheduler();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -109,1 +109,2 @@\n-    private final ClassDesc lambdaClassDesc;         \/\/ Type descriptor for the generated class \"X$$Lambda$1\"\n+    private final ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+    private final ClassEntry lambdaClassEntry;       \/\/ Class entry for the generated class \"X$$Lambda$1\"\n@@ -169,2 +170,1 @@\n-        constructorTypeDesc = methodDesc(constructorType);\n-        lambdaClassDesc = ClassDesc.ofInternalName(lambdaClassName);\n+        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n@@ -195,0 +195,1 @@\n+        constructorTypeDesc = MethodTypeDescImpl.ofValidated(CD_void, argDescs);\n@@ -203,1 +204,1 @@\n-        return name.replace('.', '\/') + \"$$Lambda\";\n+        return name.replace('.', '\/').concat(\"$$Lambda\");\n@@ -233,1 +234,1 @@\n-                    Object inst = mh.asType(methodType(Object.class)).invokeExact();\n+                    Object inst = mh.invokeBasic();\n@@ -315,1 +316,1 @@\n-        final byte[] classBytes = ClassFile.of().build(lambdaClassDesc, new Consumer<ClassBuilder>() {\n+        final byte[] classBytes = ClassFile.of().build(lambdaClassEntry, pool, new Consumer<ClassBuilder>() {\n@@ -388,1 +389,1 @@\n-                cob.new_(lambdaClassDesc)\n+                cob.new_(lambdaClassEntry)\n@@ -390,2 +391,2 @@\n-                   .invokespecial(lambdaClassDesc, INIT_NAME, constructorTypeDesc)\n-                   .putstatic(lambdaClassDesc, LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)\n+                   .invokespecial(pool.methodRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(INIT_NAME, constructorTypeDesc)))\n+                   .putstatic(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor)))\n@@ -413,1 +414,1 @@\n-                            cob.putfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                            cob.putfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -465,1 +466,1 @@\n-                               .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                               .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n@@ -524,1 +525,1 @@\n-                       .getfield(lambdaClassDesc, argNames[i], argDescs[i]);\n+                       .getfield(pool.fieldRefEntry(lambdaClassEntry, pool.nameAndTypeEntry(argNames[i], argDescs[i])));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1562,0 +1562,1 @@\n+            Object[] arguments = this.arguments;\n@@ -1569,15 +1570,0 @@\n-        \/** Return the number of occurrences of n in the argument array.\n-         *  Return 0 if the name is not used.\n-         *\/\n-        int useCount(Name n) {\n-            int count = 0;\n-            if (arguments != null) {\n-                for (Object argument : arguments) {\n-                    if (argument == n) {\n-                        count++;\n-                    }\n-                }\n-            }\n-            return count;\n-        }\n-\n@@ -1625,0 +1611,1 @@\n+        Name[] names = this.names;\n@@ -1626,1 +1613,8 @@\n-            count += names[i++].useCount(n);\n+            Object[] arguments = names[i++].arguments;\n+            if (arguments != null) {\n+                for (Object argument : arguments) {\n+                    if (argument == n) {\n+                        count++;\n+                    }\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2209,1 +2209,1 @@\n-         * @jls 12.7 Unloading of Classes and Interface\n+         * @jls 12.7 Unloading of Classes and Interfaces\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -627,1 +627,1 @@\n-         * @jvms 4.6 Method\n+         * @jvms 4.6 Methods\n@@ -639,1 +639,1 @@\n-         * @jvms 4.7.24. The MethodParameters Attribute\n+         * @jvms 4.7.24 The MethodParameters Attribute\n@@ -645,1 +645,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n@@ -651,1 +651,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n@@ -657,1 +657,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n@@ -663,1 +663,1 @@\n-         * @jvms 4.7.25. The Module Attribute\n+         * @jvms 4.7.25 The Module Attribute\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -59,3 +57,1 @@\n-    private static final MethodType DESCRIPTOR_MT = MethodType.methodType(MethodType.class);\n-    private static final MethodType NAMES_MT = MethodType.methodType(List.class);\n-    private static final MethodHandle FALSE = MethodHandles.constant(boolean.class, false);\n+    private static final MethodHandle FALSE = MethodHandles.zero(boolean.class);\n@@ -63,1 +59,1 @@\n-    private static final MethodHandle ZERO = MethodHandles.constant(int.class, 0);\n+    private static final MethodHandle ZERO = MethodHandles.zero(int.class);\n@@ -65,1 +61,0 @@\n-    private static final MethodHandle OBJECT_EQUALS;\n@@ -70,3 +65,0 @@\n-    private static final MethodHandle OBJECT_HASHCODE;\n-    private static final MethodHandle OBJECT_TO_STRING;\n-    private static final MethodHandle STRING_FORMAT;\n@@ -87,5 +79,0 @@\n-            @SuppressWarnings(\"removal\")\n-            ClassLoader loader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n-                @Override public ClassLoader run() { return ClassLoader.getPlatformClassLoader(); }\n-            });\n-\n@@ -94,8 +81,0 @@\n-            OBJECT_EQUALS = publicLookup.findVirtual(Object.class, \"equals\",\n-                                                     MethodType.methodType(boolean.class, Object.class));\n-            OBJECT_HASHCODE = publicLookup.findVirtual(Object.class, \"hashCode\",\n-                                                       MethodType.fromMethodDescriptorString(\"()I\", loader));\n-            OBJECT_TO_STRING = publicLookup.findVirtual(Object.class, \"toString\",\n-                                                        MethodType.methodType(String.class));\n-            STRING_FORMAT = publicLookup.findStatic(String.class, \"format\",\n-                                                    MethodType.methodType(String.class, String.class, Object[].class));\n@@ -112,1 +91,1 @@\n-                                              MethodType.fromMethodDescriptorString(\"(II)I\", loader));\n+                                              MethodType.methodType(int.class, int.class, int.class));\n@@ -115,1 +94,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(BB)Z\", loader)));\n+                                                              MethodType.methodType(boolean.class, byte.class, byte.class)));\n@@ -117,1 +96,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(SS)Z\", loader)));\n+                                                               MethodType.methodType(boolean.class, short.class, short.class)));\n@@ -119,1 +98,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(CC)Z\", loader)));\n+                                                              MethodType.methodType(boolean.class, char.class, char.class)));\n@@ -121,1 +100,1 @@\n-                                                             MethodType.fromMethodDescriptorString(\"(II)Z\", loader)));\n+                                                             MethodType.methodType(boolean.class, int.class, int.class)));\n@@ -123,1 +102,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(JJ)Z\", loader)));\n+                                                              MethodType.methodType(boolean.class, long.class, long.class)));\n@@ -125,1 +104,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(FF)Z\", loader)));\n+                                                               MethodType.methodType(boolean.class, float.class, float.class)));\n@@ -127,1 +106,1 @@\n-                                                                MethodType.fromMethodDescriptorString(\"(DD)Z\", loader)));\n+                                                                MethodType.methodType(boolean.class, double.class, double.class)));\n@@ -129,1 +108,1 @@\n-                                                                 MethodType.fromMethodDescriptorString(\"(ZZ)Z\", loader)));\n+                                                                 MethodType.methodType(boolean.class, boolean.class, boolean.class)));\n@@ -132,1 +111,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(B)I\", loader)));\n+                                                               MethodType.methodType(int.class, byte.class)));\n@@ -134,1 +113,1 @@\n-                                                                MethodType.fromMethodDescriptorString(\"(S)I\", loader)));\n+                                                                MethodType.methodType(int.class, short.class)));\n@@ -136,1 +115,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(C)I\", loader)));\n+                                                               MethodType.methodType(int.class, char.class)));\n@@ -138,1 +117,1 @@\n-                                                              MethodType.fromMethodDescriptorString(\"(I)I\", loader)));\n+                                                              MethodType.methodType(int.class, int.class)));\n@@ -140,1 +119,1 @@\n-                                                               MethodType.fromMethodDescriptorString(\"(J)I\", loader)));\n+                                                               MethodType.methodType(int.class, long.class)));\n@@ -142,1 +121,1 @@\n-                                                                MethodType.fromMethodDescriptorString(\"(F)I\", loader)));\n+                                                                MethodType.methodType(int.class, float.class)));\n@@ -144,1 +123,1 @@\n-                                                                 MethodType.fromMethodDescriptorString(\"(D)I\", loader)));\n+                                                                 MethodType.methodType(int.class, double.class)));\n@@ -146,1 +125,1 @@\n-                                                                  MethodType.fromMethodDescriptorString(\"(Z)I\", loader)));\n+                                                                  MethodType.methodType(int.class, boolean.class)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":19,"deletions":40,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -47,0 +48,1 @@\n+import java.util.concurrent.Executor;\n@@ -50,0 +52,1 @@\n+import jdk.internal.loader.NativeLibraries;\n@@ -322,0 +325,5 @@\n+    \/**\n+     * Count the number of leading non-zero ascii chars in the String.\n+     *\/\n+    int countNonZeroAscii(String s);\n+\n@@ -456,0 +464,10 @@\n+    \/**\n+     * Get the string initial coder, When COMPACT_STRINGS is on, it returns 0, and when it is off, it returns 1.\n+     *\/\n+    byte stringInitCoder();\n+\n+    \/**\n+     * Get the Coder of String, which is used by StringConcatFactory to calculate the initCoder of constants\n+     *\/\n+    byte stringCoder(String str);\n+\n@@ -477,1 +495,5 @@\n-    long findNative(ClassLoader loader, String entry);\n+    \/**\n+     * Returns the {@link NativeLibraries} object associated with the provided class loader.\n+     * This is used by {@link SymbolLookup#loaderLookup()}.\n+     *\/\n+    NativeLibraries nativeLibrariesFor(ClassLoader loader);\n@@ -589,0 +611,5 @@\n+    \/**\n+     * Returns the virtual thread default scheduler.\n+     *\/\n+    Executor virtualThreadDefaultScheduler();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-    public final void writeAttribute(BufWriter buf, T attr) {\n+    public final void writeAttribute(BufWriter writer, T attr) {\n+        BufWriterImpl buf = (BufWriterImpl) writer;\n@@ -67,2 +68,1 @@\n-        buf.writeInt(0);\n-        int start = buf.size();\n+        int lengthIndex = buf.skip(4);\n@@ -70,2 +70,2 @@\n-        int written = buf.size() - start;\n-        buf.patchInt(start - 4, 4, written);\n+        int written = buf.size() - lengthIndex - 4;\n+        buf.patchInt(lengthIndex, written);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -869,2 +869,1 @@\n-            b.writeInt(0);\n-            int start = b.size();\n+            int lengthIndex = b.skip(4);\n@@ -872,2 +871,2 @@\n-            int written = b.size() - start;\n-            b.patchInt(start - 4, 4, written);\n+            int written = b.size() - lengthIndex - 4;\n+            b.patchInt(lengthIndex, written);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+        jdk.management,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -228,0 +228,6 @@\n+    \/**\n+     * A table to hold the access flags of the method parameters,\n+     * for all parameters including synthetic and mandated ones.\n+     *\/\n+    int[] allParameterAccessFlags;\n+\n@@ -1160,0 +1166,1 @@\n+                        allParameterAccessFlags = new int[numEntries];\n@@ -1162,0 +1169,1 @@\n+                        int allParamIndex = 0;\n@@ -1166,0 +1174,1 @@\n+                            allParameterAccessFlags[allParamIndex++] = flags;\n@@ -1620,1 +1629,10 @@\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", meth);\n+            \/\/the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations\n+            \/\/provide annotations for a different number of parameters, ignore:\n+            if (lintClassfile) {\n+                log.warning(LintCategory.CLASSFILE, Warnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            }\n+            for (int pnum = 0; pnum < numParameters; pnum++) {\n+                readAnnotations();\n+            }\n+            parameterAnnotations = null;\n+            return ;\n@@ -2650,1 +2668,2 @@\n-        Type type = poolReader.getType(nextChar());\n+        Type descriptorType = poolReader.getType(nextChar());\n+        Type type = descriptorType;\n@@ -2667,0 +2686,1 @@\n+        boolean forceLocal = false;\n@@ -2674,1 +2694,2 @@\n-            boolean local = !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);\n+            boolean local = forceLocal =\n+                    !currentOwner.owner.members().includes(currentOwner, LookupKind.NON_RECURSIVE);\n@@ -2695,0 +2716,1 @@\n+        adjustParameterAnnotations(m, descriptorType, forceLocal);\n@@ -2822,3 +2844,2 @@\n-        if (parameterAnnotations != null && parameterAnnotations.length != annotationIndex) {\n-            throw badClassFile(\"bad.runtime.invisible.param.annotations\", sym);\n-        }\n+        Assert.check(parameterAnnotations == null ||\n+                     parameterAnnotations.length == annotationIndex);\n@@ -2830,0 +2851,1 @@\n+        allParameterAccessFlags = null;\n@@ -2833,0 +2855,124 @@\n+    void adjustParameterAnnotations(MethodSymbol sym, Type methodDescriptor,\n+                                    boolean forceLocal) {\n+        if (parameterAnnotations == null) {\n+            return ;\n+        }\n+\n+        \/\/the specification for Runtime(In)VisibleParameterAnnotations does not\n+        \/\/enforce any mapping between the method parameters and the recorded\n+        \/\/parameter annotation. Attempt a number of heuristics to adjust the\n+        \/\/adjust parameterAnnotations to the percieved number of parameters:\n+\n+        int methodParameterCount = sym.type.getParameterTypes().size();\n+\n+        if (methodParameterCount == parameterAnnotations.length) {\n+            \/\/we've got exactly as many parameter annotations as are parameters\n+            \/\/of the method (after considering a possible Signature attribute),\n+            \/\/no need to do anything. the parameter creation code will use\n+            \/\/the 1-1 mapping to restore the annotations:\n+            return ;\n+        }\n+\n+        if (allParameterAccessFlags != null) {\n+            \/\/MethodParameters attribute present, use it:\n+\n+            \/\/count the number of non-synthetic and non-mandatory parameters:\n+            int realParameters = 0;\n+\n+            for (int i = 0; i < allParameterAccessFlags.length; i++) {\n+                if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                    realParameters++;\n+                }\n+            }\n+\n+            int methodDescriptorParameterCount = methodDescriptor.getParameterTypes().size();\n+\n+            if (realParameters == parameterAnnotations.length &&\n+                allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if we have parameter annotations for each non-synthetic\/mandatory parameter,\n+                \/\/and if Signature was not present, expand the parameterAnnotations to cover\n+                \/\/all the method descriptor's parameters:\n+                if (sym.type == methodDescriptor) {\n+                    ParameterAnnotations[] newParameterAnnotations =\n+                            new ParameterAnnotations[methodParameterCount];\n+                    int srcIndex = 0;\n+\n+                    for (int i = 0; i < methodParameterCount; i++) {\n+                        if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                            newParameterAnnotations[i] = parameterAnnotations[srcIndex++];\n+                        }\n+                    }\n+\n+                    parameterAnnotations = newParameterAnnotations;\n+                } else {\n+                    dropParameterAnnotations();\n+                }\n+            } else if (realParameters == methodParameterCount &&\n+                       methodDescriptorParameterCount == parameterAnnotations.length &&\n+                       allParameterAccessFlags.length == methodDescriptorParameterCount) {\n+                \/\/if there are as many parameter annotations as parameters in\n+                \/\/the method descriptor, and as many real parameters as parameters\n+                \/\/in the method's type (after accounting for Signature), shrink\n+                \/\/the parameterAnnotations to only cover the parameters from\n+                \/\/the method's type:\n+                ParameterAnnotations[] newParameterAnnotations =\n+                        new ParameterAnnotations[methodParameterCount];\n+                int targetIndex = 0;\n+\n+                for (int i = 0; i < parameterAnnotations.length; i++) {\n+                    if ((allParameterAccessFlags[i] & (SYNTHETIC | MANDATED)) == 0) {\n+                        newParameterAnnotations[targetIndex++] = parameterAnnotations[i];\n+                    }\n+                }\n+\n+                parameterAnnotations = newParameterAnnotations;\n+            } else {\n+                dropParameterAnnotations();\n+            }\n+            return ;\n+        }\n+\n+        if (!sym.isConstructor()) {\n+            \/\/if the number of parameter annotations and the number of parameters\n+            \/\/don't match, we don't have any heuristics to map one to the other\n+            \/\/unless the method is a constructor:\n+            dropParameterAnnotations();\n+            return ;\n+        }\n+\n+        if (sym.owner.isEnum()) {\n+            if (methodParameterCount == parameterAnnotations.length + 2 &&\n+                sym.type == methodDescriptor) {\n+                \/\/handle constructors of enum types without the Signature attribute -\n+                \/\/there are the two synthetic parameters (name and ordinal) in the\n+                \/\/constructor, but there may be only parameter annotations for the\n+                \/\/real non-synthetic parameters:\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[parameterAnnotations.length + 2];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 2, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        } else if (sym.owner.isDirectlyOrIndirectlyLocal() || forceLocal) {\n+            \/\/local class may capture the enclosing instance (as the first parameter),\n+            \/\/and local variables (as trailing parameters)\n+            \/\/if there are less parameter annotations than parameters, put the existing\n+            \/\/ones starting with offset:\n+            if (methodParameterCount > parameterAnnotations.length &&\n+                sym.type == methodDescriptor) {\n+                ParameterAnnotations[] newParameterAnnotations = new ParameterAnnotations[methodParameterCount];\n+                System.arraycopy(parameterAnnotations, 0, newParameterAnnotations, 1, parameterAnnotations.length);\n+                parameterAnnotations = newParameterAnnotations;\n+                return ;\n+            }\n+        }\n+\n+        \/\/no heuristics worked, drop the annotations:\n+        dropParameterAnnotations();\n+    }\n+\n+    private void dropParameterAnnotations() {\n+        parameterAnnotations = null;\n+        if (lintClassfile) {\n+            log.warning(LintCategory.CLASSFILE, Warnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":152,"deletions":6,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2556,2 +2556,11 @@\n-compiler.misc.bad.runtime.invisible.param.annotations=\\\n-    bad RuntimeInvisibleParameterAnnotations attribute: {0}\n+# 0: file name\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch=\\\n+    the length of parameters in RuntimeVisibleParameterAnnotations attribute and \\\n+    RuntimeInvisibleParameterAnnotations attribute in: {0} \\\n+    do not match, ignoring both attributes\n+\n+# 0: file name\n+compiler.warn.runtime.invisible.parameter.annotations=\\\n+    the RuntimeVisibleParameterAnnotations and RuntimeInvisibleParameterAnnotations attributes \\\n+    in: {0} \\\n+    cannot be mapped to the method''s parameters\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+serviceability\/sa\/TestJhsdbJstackUpcall.java                  8307393   generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-generational-zgc.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,1 +125,0 @@\n-runtime\/ErrorHandling\/TestDwarf.java#checkDecoder 8305489 linux-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -273,0 +273,1 @@\n+    jdk\/management \\\n@@ -298,0 +299,1 @@\n+    jdk\/management\/VirtualThreadSchedulerMXBean \\\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+        map.put(\"systemd.support\", this::systemdSupport);\n@@ -614,1 +615,1 @@\n-              isSupported = checkDockerSupport();\n+              isSupported = checkProgramSupport(\"checkDockerSupport()\", Container.ENGINE_COMMAND);\n@@ -624,0 +625,21 @@\n+    \/**\n+     * A simple check for systemd support\n+     *\n+     * @return true if systemd is supported in a given environment\n+     *\/\n+    protected String systemdSupport() {\n+        log(\"Entering systemdSupport()\");\n+\n+        boolean isSupported = Platform.isLinux();\n+        if (isSupported) {\n+           try {\n+              isSupported = checkProgramSupport(\"checkSystemdSupport()\", \"systemd-run\");\n+           } catch (Exception e) {\n+              isSupported = false;\n+           }\n+         }\n+\n+        log(\"systemdSupport(): returning isSupported = \" + isSupported);\n+        return \"\" + isSupported;\n+    }\n+\n@@ -658,3 +680,3 @@\n-    private boolean checkDockerSupport() throws IOException, InterruptedException {\n-        log(\"checkDockerSupport(): entering\");\n-        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+    private boolean checkProgramSupport(String logString, String cmd) throws IOException, InterruptedException {\n+        log(logString + \": entering\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", cmd);\n@@ -662,2 +684,2 @@\n-            redirectOutputToLogFile(\"checkDockerSupport(): which \" + Container.ENGINE_COMMAND,\n-                                                      pb, \"which-container\");\n+            redirectOutputToLogFile(logString + \": which \" + cmd,\n+                                                      pb, \"which-cmd\");\n@@ -668,1 +690,1 @@\n-        log(String.format(\"checkDockerSupport(): exitValue = %s, pid = %s\", exitValue, p.pid()));\n+        log(String.format(\"%s: exitValue = %s, pid = %s\", logString, exitValue, p.pid()));\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-tools\/javac\/patterns\/Exhaustiveness.java \t\t\t\t\t8326616    generic-all    intermittently timeout\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-compiler.misc.bad.runtime.invisible.param.annotations   # bad class file\n+compiler.warn.runtime.invisible.parameter.annotations   # bad class file\n+compiler.warn.runtime.visible.invisible.param.annotations.mismatch   # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -786,0 +786,1 @@\n+  public native int hostCPUs();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}