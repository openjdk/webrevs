{"files":[{"patch":"@@ -4858,2 +4858,0 @@\n-        } else if (is_abstract && !is_identity_class && !is_static) {\n-          is_illegal = true;\n@@ -6361,14 +6359,0 @@\n-\n-    if (EnableValhalla && !_access_flags.is_identity_class()) {\n-      const InstanceKlass* k = _super_klass;\n-      int inherited_instance_fields = 0;\n-      while (k != nullptr) {\n-        for (AllFieldStream fs(k); !fs.done(); fs.next()) {\n-          if (!fs.access_flags().is_static()) inherited_instance_fields++;\n-        }\n-        k = k->super() == nullptr ? nullptr :  InstanceKlass::cast(k->super());\n-      }\n-      if (inherited_instance_fields > 0) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), \"Value classes don't support inherited non-static fields yet\");\n-      }\n-    }\n@@ -6568,0 +6552,1 @@\n+      access_flags().is_abstract() && !access_flags().is_identity_class(),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -152,0 +152,4 @@\n+  _super_first_field_offset(-1),\n+  _super_alignment(-1),\n+  _super_min_align_required(-1),\n+  _super_has_fields(false),\n@@ -177,1 +181,1 @@\n-    bool has_fields = reconstruct_layout(super_klass);\n+    _super_has_fields = reconstruct_layout(super_klass);\n@@ -179,1 +183,1 @@\n-    if ((UseEmptySlotsInSupers && !super_klass->has_contended_annotations()) || !has_fields) {\n+    if ((UseEmptySlotsInSupers && !super_klass->has_contended_annotations()) || !_super_has_fields) {\n@@ -264,1 +268,1 @@\n-      assert(slot->size() >= block->offset() + block->size() ,\"Matching slot must be big enough\");\n+      assert(slot->size() >= block->offset() - slot->offset() + block->size() ,\"Matching slot must be big enough\");\n@@ -274,1 +278,3 @@\n-      _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+      if (block->kind() == LayoutRawBlock::REGULAR || block->kind() == LayoutRawBlock::FLAT) {\n+        _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+      }\n@@ -329,0 +335,1 @@\n+  assert(block->size() >= block->size(), \"Enough space must remain afte adjustment\");\n@@ -346,0 +353,3 @@\n+  if (ik->is_abstract() && !ik->is_identity_class()) {\n+    _super_alignment = type2aelembytes(BasicType::T_LONG);\n+  }\n@@ -353,0 +363,1 @@\n+      if (_super_first_field_offset == -1 || fs.offset() < _super_first_field_offset) _super_first_field_offset = fs.offset();\n@@ -358,0 +369,2 @@\n+        assert(_super_alignment == -1 || _super_alignment >=  vk->get_alignment(), \"Invalid value alignment\");\n+        _super_min_align_required = _super_min_align_required > vk->get_alignment() ? _super_min_align_required : vk->get_alignment();\n@@ -369,0 +382,3 @@\n+        \/\/ For primitive types, the alignment is equal to the size\n+        assert(_super_alignment == -1 || _super_alignment >=  size, \"Invalid value alignment\");\n+        _super_min_align_required = _super_min_align_required > size ? _super_min_align_required : size;\n@@ -589,1 +605,1 @@\n-                                       GrowableArray<FieldInfo>* field_info, bool is_contended, bool is_inline_type,\n+                                       GrowableArray<FieldInfo>* field_info, bool is_contended, bool is_inline_type,bool is_abstract_value,\n@@ -614,0 +630,1 @@\n+  _is_abstract_value(is_abstract_value),\n@@ -764,1 +781,1 @@\n-  assert(_is_inline_type, \"Should only be used for inline classes\");\n+  assert(_is_inline_type || _is_abstract_value, \"Should only be used for inline classes\");\n@@ -857,1 +874,1 @@\n-  assert(_has_nonstatic_fields, \"Empty value instances should have an injected field to have a non-zero size\");\n+  assert(_has_nonstatic_fields || _is_abstract_value, \"Concrete value types do not support zero instance size yet\");\n@@ -965,3 +982,1 @@\n-  \/\/ Inline types are not polymorphic, so they cannot inherit fields.\n-  \/\/ By consequence, at this stage, the layout must be composed of a RESERVED\n-  \/\/ block, followed by an EMPTY block.\n+\n@@ -969,6 +984,45 @@\n-  assert(_layout->start()->next_block()->kind() == LayoutRawBlock::EMPTY, \"Unexpected\");\n-  LayoutRawBlock* first_empty = _layout->start()->next_block();\n-  if (first_empty->offset() % _alignment != 0) {\n-    LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, _alignment - (first_empty->offset() % _alignment));\n-    _layout->insert(first_empty, padding);\n-    _layout->set_start(padding->next_block());\n+\n+  if (_layout->super_has_fields() && !_is_abstract_value) {  \/\/ non-static field layout\n+    if (!_has_nonstatic_fields) {\n+      assert(_is_abstract_value, \"Concrete value types have at least one field\");\n+      \/\/ Nothing to do\n+    } else {\n+      \/\/ decide which alignment to use, then set first allowed field offset\n+\n+      assert(_layout->super_alignment() >= _alignment, \"Incompatible alignment\");\n+      assert(_layout->super_alignment() % _alignment == 0, \"Incompatible alignment\");\n+\n+      if (_alignment < _layout->super_alignment()) {\n+        int new_alignment = _alignment > _layout->super_min_align_required() ? _alignment : _layout->super_min_align_required();\n+        assert(new_alignment % _alignment == 0, \"Must be\");\n+        assert(new_alignment % _layout->super_min_align_required() == 0, \"Must be\");\n+        _alignment = new_alignment;\n+      }\n+      if (_layout->first_empty_block()->offset() < _layout->first_field_block()->offset()) {\n+        LayoutRawBlock* first_empty = _layout->start()->next_block();\n+        if (first_empty->offset() % _alignment != 0) {\n+          int size =  _alignment - (first_empty->offset() % _alignment);\n+          LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, size);\n+          _layout->insert(first_empty, padding);\n+          _layout->set_start(padding);\n+        } else {\n+          _layout->set_start( _layout->start());\n+        }\n+      } else {\n+        _layout->set_start(_layout->first_field_block());\n+      }\n+    }\n+  } else {\n+    if (_is_abstract_value && _has_nonstatic_fields) {\n+      _alignment = type2aelembytes(BasicType::T_LONG);\n+    }\n+    assert(_layout->start()->next_block()->kind() == LayoutRawBlock::EMPTY, \"Unexpected\");\n+    LayoutRawBlock* first_empty = _layout->start()->next_block();\n+    if (first_empty->offset() % _alignment != 0) {\n+      LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, _alignment - (first_empty->offset() % _alignment));\n+      _layout->insert(first_empty, padding);\n+      if (first_empty->size() == 0) {\n+        _layout->remove(first_empty);\n+      }\n+      _layout->set_start(padding);\n+    }\n@@ -986,9 +1040,14 @@\n-   if (first_field != nullptr) {\n-     _first_field_offset = _layout->first_field_block()->offset();\n-     _payload_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n-   } else {\n-     \/\/ special case for empty value types\n-     _first_field_offset = _layout->blocks()->size();\n-     _payload_size_in_bytes = 0;\n-   }\n-  _payload_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+  if (first_field != nullptr) {\n+    _first_field_offset = _layout->first_field_block()->offset();\n+    _payload_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+  } else {\n+    \/\/ special case for empty value types\n+    _first_field_offset = _layout->blocks()->size();\n+    _payload_size_in_bytes = 0;\n+  }\n+  if (_layout->first_field_block() == nullptr) {\n+    assert(_is_abstract_value, \"Concrete inline types must have at least one field\");\n+    _payload_size_in_bytes = 0;\n+  } else {\n+    _payload_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+  }\n@@ -998,3 +1057,6 @@\n-  while (b != _layout->last_block()) {\n-    if (b->kind() == LayoutRawBlock::EMPTY) {\n-      break;\n+  if (b != nullptr) {\n+    while (b != _layout->last_block()) {\n+      if (b->kind() == LayoutRawBlock::EMPTY) {\n+        break;\n+      }\n+      b = b->next_block();\n@@ -1002,5 +1064,6 @@\n-    b = b->next_block();\n-  }\n-  if (b != _layout->last_block()) {\n-    \/\/ found an empty slot, register its offset from the beginning of the payload\n-    _internal_null_marker_offset = b->offset();\n+    if (b != _layout->last_block()) {\n+      \/\/ found an empty slot, register its offset from the beginning of the payload\n+      _internal_null_marker_offset = b->offset();\n+    }\n+  } else {\n+    assert(_is_abstract_value, \"Only abstract value can have no fields\");\n@@ -1160,1 +1223,1 @@\n-  if (_is_inline_type) {\n+  if (_is_inline_type || _is_abstract_value) {\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":97,"deletions":34,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -201,0 +201,4 @@\n+  int _super_first_field_offset;\n+  int _super_alignment;\n+  int _super_min_align_required;\n+  bool _super_has_fields;\n@@ -220,1 +224,5 @@\n-  LayoutRawBlock* last_block() const { return _last; }\n+  LayoutRawBlock* last_block() const  { return _last; }\n+  int super_first_field_offset() const { return _super_first_field_offset; }\n+  int super_alignment() const { return _super_alignment; }\n+  int super_min_align_required() const { return _super_min_align_required; }\n+  bool super_has_fields() const { return _super_has_fields; }\n@@ -284,0 +292,1 @@\n+  bool _is_abstract_value;\n@@ -293,2 +302,2 @@\n-                     GrowableArray<FieldInfo>* field_info, bool is_contended, bool is_inline_type, FieldLayoutInfo* info,\n-                     Array<InlineKlass*>* inline_type_field_klasses);\n+                     GrowableArray<FieldInfo>* field_info, bool is_contended, bool is_inline_type, bool is_abstract_value,\n+                     FieldLayoutInfo* info, Array<InlineKlass*>* inline_type_field_klasses);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -312,0 +312,20 @@\n+  void checkOffsetOnFields(ArrayList<FieldBlock> fields) {\n+    HashMap<Integer, FieldBlock> map = new HashMap<Integer, FieldBlock>();\n+    for (FieldBlock fb : fields) {\n+      Asserts.assertFalse(map.containsKey(fb.offset()), \"Duplicate offset at \" + fb.offset());\n+      map.put(fb.offset(), fb);\n+    }\n+  }\n+\n+  void checkOffsets() {\n+    for (ClassLayout layout : layouts) {\n+      try {\n+        checkOffsetOnFields(layout.staticFields);\n+        checkOffsetOnFields(layout.nonStaticFields);\n+      } catch(Throwable t) {\n+        System.out.println(\"Unexpection exception when checking offsets in class \" + layout.name);\n+        throw t;\n+      }\n+    }\n+  }\n+\n@@ -325,1 +345,0 @@\n-    System.out.println(\"Checking for overlap\");\n@@ -327,1 +346,0 @@\n-      System.out.println(\"\\t\" + layout.name);\n@@ -332,1 +350,2 @@\n-        throw new RuntimeException(\"Unexpection exception when checking for overlaps\/holes in class \" + layout.name);\n+        System.out.println(\"Unexpection exception when checking for overlaps\/holes in class \" + layout.name);\n+        throw t;\n@@ -338,0 +357,1 @@\n+    Asserts.assertTrue(block.size() > 0);\n@@ -389,1 +409,0 @@\n-    System.out.println(\"Checking size and alignment\");\n@@ -391,3 +410,7 @@\n-      System.out.println(\"\\t\" + layout.name);\n-      for (FieldBlock block : layout.staticFields) {\n-        checkSizeAndAlignmentForField(block);\n+      try {\n+        for (FieldBlock block : layout.staticFields) {\n+          checkSizeAndAlignmentForField(block);\n+        }\n+      } catch(Throwable t) {\n+        System.out.println(\"Unexpected exception when checking size and alignment in static fields of class \" + layout.name);\n+        throw t;\n@@ -395,2 +418,7 @@\n-      for (FieldBlock block : layout.nonStaticFields) {\n-        checkSizeAndAlignmentForField(block);\n+      try {\n+        for (FieldBlock block : layout.nonStaticFields) {\n+          checkSizeAndAlignmentForField(block);\n+        }\n+      } catch(Throwable t) {\n+        System.out.println(\"Unexpected exception when checking size and alignment in non-static fields of class \" + layout.name);\n+        throw t;\n@@ -403,1 +431,0 @@\n-    System.out.println(\"Checking Inherited Fields\");\n@@ -405,18 +432,26 @@\n-      System.out.println(\"\\t\" + layout.name);\n-      \/\/ Preparing the list of ClassLayout of super classes\n-      ArrayList<ClassLayout> supers = new ArrayList<ClassLayout>();\n-      String className = layout.superName;\n-      while (className != null) {\n-        ClassLayout cl = getClassLayout(className);\n-        supers.add(cl);\n-        className = cl.superName;\n-      }\n-      for (FieldBlock field : layout.nonStaticFields) {\n-        if (field.type == BlockType.INHERITED) {\n-          int i = 0;\n-          boolean found = false;\n-          FieldBlock b = null;\n-          while(i < supers.size() && !found) {\n-            b = supers.get(i).getFieldAtOffset(field.offset, false);\n-            if (b.type != BlockType.INHERITED) found = true;\n-            i++;\n+      try {\n+        \/\/ Preparing the list of ClassLayout of super classes\n+        ArrayList<ClassLayout> supers = new ArrayList<ClassLayout>();\n+        String className = layout.superName;\n+        while (className != null) {\n+          ClassLayout cl = getClassLayout(className);\n+          supers.add(cl);\n+          className = cl.superName;\n+        }\n+        for (FieldBlock field : layout.nonStaticFields) {\n+          if (field.type == BlockType.INHERITED) {\n+            int i = 0;\n+            boolean found = false;\n+            FieldBlock b = null;\n+            while(i < supers.size() && !found) {\n+              b = supers.get(i).getFieldAtOffset(field.offset, false);\n+              if (b.type != BlockType.INHERITED) found = true;\n+              i++;\n+            }\n+            String location = new String(\" at \" + layout.name + \" offset \" + field.offset());\n+            Asserts.assertTrue(found, \"No declaration found for an inherited field \" + location);\n+            Asserts.assertNotEquals(field.type, BlockType.EMPTY, location);\n+            Asserts.assertEquals(field.size, b.size, location);\n+            Asserts.assertEquals(field.alignment, b.alignment, location );\n+            Asserts.assertEquals(field.name(), b.name(), location);\n+            Asserts.assertEquals(field.signature(), b.signature(), location);\n@@ -424,7 +459,0 @@\n-          String location = new String(\" at \" + layout.name + \" offset \" + field.offset());\n-          Asserts.assertTrue(found, \"No declaration found for an inherited field \" + location);\n-          Asserts.assertNotEquals(field.type, BlockType.EMPTY, location);\n-          Asserts.assertEquals(field.size, b.size, location);\n-          Asserts.assertEquals(field.alignment, b.alignment, location );\n-          Asserts.assertEquals(field.name(), b.name(), location);\n-          Asserts.assertEquals(field.signature(), b.signature(), location);\n@@ -432,0 +460,2 @@\n+      } catch(Throwable t) {\n+        System.out.println(\"Unexpexted exception when checking inherited fields in class \" + layout.name);\n@@ -444,1 +474,0 @@\n-    System.out.println(\"Checking sub-classes\");\n@@ -448,16 +477,19 @@\n-      if (layout.name.contains(\"$$Lambda@0\")) continue; \/\/ Skipping lambda classes\n-      Node current = nodes.get(layout.name);\n-      if (current == null) {\n-        current = new Node();\n-        nodes.put(layout.name, current);\n-      }\n-      if (current.classLayout == null) {\n-        current.classLayout = layout;\n-      } else {\n-        System.out.println(current.classLayout.name + \" vs \" + layout.name);\n-        Asserts.assertEQ(current.classLayout, layout);\n-      }\n-      if (layout.superName != null) {\n-        Node superNode = nodes.get(layout.superName);\n-        if (superNode == null) {\n-          superNode = new Node();\n+      try {\n+        if (layout.name.contains(\"$$Lambda@0\")) continue; \/\/ Skipping lambda classes\n+        Node current = nodes.get(layout.name);\n+        if (current == null) {\n+          current = new Node();\n+          nodes.put(layout.name, current);\n+        }\n+        if (current.classLayout == null) {\n+          current.classLayout = layout;\n+        } else {\n+          Asserts.assertEQ(current.classLayout, layout);\n+        }\n+        if (layout.superName != null) {\n+          Node superNode = nodes.get(layout.superName);\n+          if (superNode == null) {\n+            superNode = new Node();\n+            superNode.subClasses.add(current);\n+            nodes.put(layout.superName, superNode);\n+          }\n@@ -465,1 +497,0 @@\n-          nodes.put(layout.superName, superNode);\n@@ -467,1 +498,3 @@\n-        superNode.subClasses.add(current);\n+      } catch(Throwable t) {\n+        System.out.println(\"Unexpected exception when generating list of sub-classes of class \" + layout.name);\n+        throw t;\n@@ -473,1 +506,0 @@\n-      System.out.println(\"\\t\" + layout.name);\n@@ -477,0 +509,1 @@\n+        if (block.type() == BlockType.PADDING) continue; \/\/ PADDING should have a finer inspection, preserved for @Contended and other imperative padding, and relaxed for abstract value conservative padding\n@@ -479,1 +512,6 @@\n-          checkFieldInClass(block, subnode);\n+          try {\n+            checkFieldInClass(block, subnode);\n+          } catch(Throwable t) {\n+            System.out.println(\"Unexpected exception when checking subclass \" + subnode.classLayout.name + \" of class \" + layout.name);\n+            throw t;\n+          }\n@@ -499,1 +537,0 @@\n-    System.out.println(\"Checking null markers\");\n@@ -501,12 +538,13 @@\n-      System.out.println(\"\\t\" + layout.name);\n-      BlockType last_type = BlockType.RESERVED;\n-      boolean has_empty_slot = false;\n-      for (FieldBlock block : layout.nonStaticFields) {\n-        last_type = block.type;\n-        if (block.type() == BlockType.FLAT && block.nullMarkerOffset() != -1) {\n-          if (block.hasInternalNullMarker()) {\n-            Asserts.assertTrue(block.nullMarkerOffset() > block.offset());\n-            Asserts.assertTrue(block.nullMarkerOffset() < block.offset() + block.size());\n-          } else {\n-            FieldBlock marker = layout.getFieldAtOffset(block.nullMarkerOffset(), false);\n-            Asserts.assertEquals(block.nullMarkerOffset(), marker.offset());\n+      try {\n+        BlockType last_type = BlockType.RESERVED;\n+        boolean has_empty_slot = false;\n+        for (FieldBlock block : layout.nonStaticFields) {\n+          last_type = block.type;\n+          if (block.type() == BlockType.FLAT && block.nullMarkerOffset() != -1) {\n+            if (block.hasInternalNullMarker()) {\n+              Asserts.assertTrue(block.nullMarkerOffset() > block.offset());\n+              Asserts.assertTrue(block.nullMarkerOffset() < block.offset() + block.size());\n+            } else {\n+              FieldBlock marker = layout.getFieldAtOffset(block.nullMarkerOffset(), false);\n+              Asserts.assertEquals(block.nullMarkerOffset(), marker.offset());\n+            }\n@@ -514,0 +552,6 @@\n+          if (block.type() == BlockType.NULL_MARKER) {\n+            FieldBlock flatField = layout.getFieldAtOffset(block.referenceFieldOffset(), false);\n+            Asserts.assertEquals(flatField.type(), BlockType.FLAT);\n+            Asserts.assertEquals(flatField.nullMarkerOffset(), block.offset());\n+          }\n+          if (block.type() == BlockType.EMPTY) has_empty_slot = true;\n@@ -515,15 +559,9 @@\n-        if (block.type() == BlockType.NULL_MARKER) {\n-          FieldBlock flatField = layout.getFieldAtOffset(block.referenceFieldOffset(), false);\n-          Asserts.assertEquals(flatField.type(), BlockType.FLAT);\n-          Asserts.assertEquals(flatField.nullMarkerOffset(), block.offset());\n-        }\n-        if (block.type() == BlockType.EMPTY) has_empty_slot = true;\n-      }\n-      \/\/ null marker should not be added at the end of the layout if there's an empty slot\n-      Asserts.assertTrue(last_type != BlockType.NULL_MARKER || has_empty_slot == false,\n-                         \"Problem detected in layout of class \" + layout.name);\n-      \/\/ static layout => must not have NULL_MARKERS because static fields are never flat\n-      for (FieldBlock block : layout.staticFields) {\n-        Asserts.assertNotEquals(block.type(), BlockType.NULL_MARKER);\n-        if (block.type() == BlockType.FLAT) {\n-          Asserts.assertEquals(block.nullMarkerOffset(), -1); \/\/ -1 means no null marker\n+        \/\/ null marker should not be added at the end of the layout if there's an empty slot\n+        Asserts.assertTrue(last_type != BlockType.NULL_MARKER || has_empty_slot == false,\n+                          \"Problem detected in layout of class \" + layout.name);\n+        \/\/ static layout => must not have NULL_MARKERS because static fields are never flat\n+        for (FieldBlock block : layout.staticFields) {\n+          Asserts.assertNotEquals(block.type(), BlockType.NULL_MARKER);\n+          if (block.type() == BlockType.FLAT) {\n+            Asserts.assertEquals(block.nullMarkerOffset(), -1); \/\/ -1 means no null marker\n+          }\n@@ -531,0 +569,3 @@\n+      } catch(Throwable t) {\n+        System.out.println(\"Unexpected exception while checking null markers in class \" + layout.name);\n+        throw t;\n@@ -536,0 +577,1 @@\n+    checkOffsets();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldLayoutAnalyzer.java","additions":126,"deletions":84,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+  \/*\n+ * @test id=32bits\n+ * @requires vm.bits == 32\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java ValueFieldInheritanceTest.java\n+ * @run main\/othervm -Xint ValueFieldInheritanceTest 0\n+ *\/\n+\n+\/*\n+ * @test id=64bitsCompressedOops\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java ValueFieldInheritanceTest.java\n+ * @run main\/othervm -Xint ValueFieldInheritanceTest 1\n+ *\/\n+\n+\/*\n+ * @test id=64bitsNoCompressedOops\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java ValueFieldInheritanceTest.java\n+ * @run main\/othervm -Xint ValueFieldInheritanceTest 2\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.w3c.dom.views.AbstractView;\n+\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\n+public class ValueFieldInheritanceTest {\n+\n+  static abstract value class AbstractNoField { };\n+\n+  static abstract value class AbstractOneField { byte b = 0; }\n+\n+  static abstract value class SubAbstractOne extends AbstractNoField { }\n+\n+  static abstract value class SubAbstractTwo extends AbstractOneField { }\n+\n+  static abstract value class SubAbstractThree extends AbstractNoField  { int i = 0; }\n+\n+  static abstract value class SubAbstractFour extends AbstractOneField { int i = 0; }\n+\n+  static class Identity0 extends AbstractNoField { }\n+\n+  static class Identity1 extends AbstractNoField { short s; }\n+\n+  static class Identity2 extends SubAbstractOne { }\n+\n+  static class Identity3 extends SubAbstractOne { char c; }\n+\n+  static class Identity4 extends SubAbstractTwo { }\n+\n+  static class Identity5 extends SubAbstractTwo { int i; }\n+\n+  static class Identity6 extends SubAbstractThree { }\n+\n+  static class Identity7 extends SubAbstractThree { int i; }\n+\n+  static class Identity8 extends SubAbstractFour { }\n+\n+  static class Identity9 extends SubAbstractFour { int i; }\n+\n+  static class ConcreteValue0 extends AbstractNoField { }\n+\n+  static class ConcreteValue1 extends AbstractNoField { short s; }\n+\n+  static class ConcreteValue2 extends SubAbstractOne { }\n+\n+  static class ConcreteValue3 extends SubAbstractOne { char c; }\n+\n+  static class ConcreteValue4 extends SubAbstractTwo { }\n+\n+  static class ConcreteValue5 extends SubAbstractTwo { int i; }\n+\n+  static class ConcreteValue6 extends SubAbstractThree { }\n+\n+  static class ConcreteValue7 extends SubAbstractThree { int i; }\n+\n+  static class ConcreteValue8 extends SubAbstractFour { }\n+\n+  static class ConcreteValue9 extends SubAbstractFour { int i; }\n+\n+  static public void test_0() {\n+    var i0 = new Identity0();\n+    var i1 = new Identity1();\n+    var i2 = new Identity2();\n+    var i3 = new Identity3();\n+    var i4 = new Identity4();\n+    var i5 = new Identity5();\n+    var i6 = new Identity6();\n+    var i7 = new Identity7();\n+    var i8 = new Identity8();\n+    var i9 = new Identity9();\n+    var c0 = new ConcreteValue0();\n+    var c1 = new ConcreteValue1();\n+    var c2 = new ConcreteValue2();\n+    var c3 = new ConcreteValue3();\n+    var c4 = new ConcreteValue4();\n+    var c5 = new ConcreteValue5();\n+    var c6 = new ConcreteValue6();\n+    var c7 = new ConcreteValue7();\n+    var c8 = new ConcreteValue8();\n+    var c9 = new ConcreteValue9();\n+  }\n+\n+  static class TestRunner {\n+    public static void main(String[] args) throws Exception {\n+      Class testClass = Class.forName(\"ValueFieldInheritanceTest\");\n+      Asserts.assertNotNull(testClass);\n+      Method[] testMethods = testClass.getMethods();\n+      for (Method test : testMethods) {\n+        if (test.getName().startsWith(\"test_\")) {\n+          Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+          Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+          System.out.println(\"Running \" + test.getName());\n+          test.invoke(null);\n+        }\n+      }\n+    }\n+  }\n+\n+  static ProcessBuilder exec(String compressedOopsArg, String... args) throws Exception {\n+    List<String> argsList = new ArrayList<>();\n+    Collections.addAll(argsList, \"--enable-preview\");\n+    Collections.addAll(argsList, \"-XX:+UnlockDiagnosticVMOptions\");\n+    Collections.addAll(argsList, \"-XX:+PrintFieldLayout\");\n+    if (compressedOopsArg != null) {\n+      Collections.addAll(argsList, compressedOopsArg);\n+    }\n+    Collections.addAll(argsList, \"-Xmx256m\");\n+    Collections.addAll(argsList, \"-cp\", System.getProperty(\"java.class.path\") + \":.\");\n+    Collections.addAll(argsList, args);\n+    return ProcessTools.createTestJavaProcessBuilder(argsList);\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    String compressedOopsArg;\n+\n+    switch(args[0]) {\n+      case \"0\": compressedOopsArg = null;\n+                break;\n+      case \"1\": compressedOopsArg = \"-XX:+UseCompressedOops\";\n+                break;\n+      case \"2\": compressedOopsArg = \"-XX:-UseCompressedOops\";\n+                break;\n+      default: throw new RuntimeException(\"Unrecognized configuration\");\n+    }\n+\n+    \/\/ Generate test classes\n+    \/\/ NullMarkersTest fat = new NullMarkersTest();\n+\n+    \/\/ Execute the test runner in charge of loading all test classes\n+    ProcessBuilder pb = exec(compressedOopsArg, \"ValueFieldInheritanceTest$TestRunner\");\n+    OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+\n+    if (out.getExitValue() != 0) {\n+      out.outputTo(System.out);\n+    }\n+    Asserts.assertEquals(out.getExitValue(), 0, \"Something went wrong while running the tests\");\n+\n+    \/\/ Get and parse the test output\n+    System.out.print(out.getOutput());\n+    FieldLayoutAnalyzer.LogOutput lo = new FieldLayoutAnalyzer.LogOutput(out.asLines());\n+    FieldLayoutAnalyzer fla =  FieldLayoutAnalyzer.createFieldLayoutAnalyzer(lo);\n+\n+    \/\/ Running tests verification method (check that tests produced the right configuration)\n+    Class testClass = ValueFieldInheritanceTest.class;\n+      Method[] testMethods = testClass.getMethods();\n+      for (Method test : testMethods) {\n+        if (test.getName().startsWith(\"check_\")) {\n+          Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+          Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+          test.invoke(null, fla);\n+        }\n+      }\n+\n+    \/\/ Verify that all layouts are correct\n+    fla.check();\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/ValueFieldInheritanceTest.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"}]}