{"files":[{"patch":"@@ -828,2 +828,3 @@\n-        \/\/ a temporay below to avoid the result being clobbered by\n-        \/\/ restore_live_registers.\n+        \/\/ a temporary below to avoid the result being clobbered by\n+        \/\/ restore_live_registers. It's saved and restored by\n+        \/\/ StubAssembler::prologue and epilogue anyway.\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -492,0 +492,1 @@\n+      \/\/ TODO 8284443 Can't we do that by not passing 'dont_gc_arguments' in case 'C1StubId::buffer_inline_args_id' in 'Runtime1::generate_code_for'?\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  assert_different_registers(value, temp1, temp2);\n@@ -182,5 +183,0 @@\n-  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n-    if (tosca_live) saved += RegSet::of(r0);\n-    if (obj != noreg) saved += RegSet::of(obj);\n-    saved += RegSet::of(j_rarg0, j_rarg1, j_rarg2, j_rarg3);\n-    saved += RegSet::of(j_rarg4, j_rarg5, j_rarg6, j_rarg7);\n@@ -188,8 +184,5 @@\n-    fsaved += FloatRegSet::of(j_farg0, j_farg1, j_farg2, j_farg3);\n-    fsaved += FloatRegSet::of(j_farg4, j_farg5, j_farg6, j_farg7);\n-\n-    __ push(saved, sp);\n-    __ push_fp(fsaved, sp);\n-  } else {\n-    __ push_call_clobbered_registers();\n-  }\n+  \/\/ TODO 8366717 This came with 8284161: Implementation of Virtual Threads (Preview) later in May 2022\n+  \/\/ Check if it's sufficient\n+  \/\/__ push_call_clobbered_registers();\n+  assert_different_registers(rscratch1, pre_val); \/\/ push_CPU_state trashes rscratch1\n+  __ push_CPU_state(true);\n@@ -216,6 +209,1 @@\n-  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n-  __ pop_fp(fsaved, sp);\n-  __ pop(saved, sp);\n-  } else {\n-    __ pop_call_clobbered_registers();\n-  }\n+  __ pop_CPU_state(true);\n@@ -300,7 +288,5 @@\n-  if (EnableValhalla && InlineTypePassFieldsAsArgs) {\n-    saved += RegSet::of(j_rarg0, j_rarg1, j_rarg2, j_rarg3);\n-    saved += RegSet::of(j_rarg4, j_rarg5, j_rarg6, j_rarg7);\n-\n-    fsaved += FloatRegSet::of(j_farg0, j_farg1, j_farg2, j_farg3);\n-    fsaved += FloatRegSet::of(j_farg4, j_farg5, j_farg6, j_farg7);\n-  }\n+  \/\/ TODO 8366717 Without this, r11 is corrupted below and it holds the array of pre-allocated value objects in the C2I adapter...\n+  \/\/ Check if__ push_call_clobbered_registers() is sufficient\n+  assert_different_registers(rscratch1, tmp1); \/\/ push_CPU_state trashes rscratch1\n+  __ enter();\n+  __ push_CPU_state(true);\n@@ -308,2 +294,0 @@\n-  __ push(saved, sp);\n-  __ push_fp(fsaved, sp);\n@@ -311,2 +295,3 @@\n-  __ pop_fp(fsaved, sp);\n-  __ pop(saved, sp);\n+\n+  __ pop_CPU_state(true);\n+  __ leave();\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1BarrierSetAssembler_aarch64.cpp","additions":15,"deletions":30,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+\n@@ -92,0 +93,1 @@\n+        \/\/ TODO This change is from before the 'tmp3' arg was added to mainline, check if it's still needed. Same on x64. Also, this should be a __ lea\n@@ -99,1 +101,0 @@\n-\n@@ -105,1 +106,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/cardTableBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6124,3 +6124,11 @@\n-    \/\/ There are two copies of FP and LR on the stack. They will be identical\n-    \/\/ unless the caller has been deoptimized, in which case LR #1 will be patched\n-    \/\/ to point at the deopt blob, and LR #2 will still point into the old method.\n+    \/\/ There are two copies of FP and LR on the stack. They will be identical at\n+    \/\/ first, but that can change.\n+    \/\/ If the caller has been deoptimized, LR #1 will be patched to point at the\n+    \/\/ deopt blob, and LR #2 will still point into the old method.\n+    \/\/ If the saved FP (x29) was not used as the frame pointer, but to store an\n+    \/\/ oop, the GC will be aware only of FP #2 as the spilled location of x29 and\n+    \/\/ will fix only this one.\n+    \/\/\n+    \/\/ When restoring, one must then load FP #2 into x29, and LR #1 into x30,\n+    \/\/ while keeping in mind that from the scalarized entry point, there will be\n+    \/\/ only one copy of each.\n@@ -6129,1 +6137,2 @@\n-    \/\/ extension space minus two words for the saved FP and LR.\n+    \/\/ extension space minus two words for the saved FP and LR. That is how to\n+    \/\/ find LR #1. FP #2 is always located just after sp_inc.\n@@ -6133,1 +6142,1 @@\n-    ldr(rscratch1, Address(sp, sp_inc_offset));\n+    ldp(rscratch1, rfp, Address(sp, sp_inc_offset));\n@@ -6135,1 +6144,2 @@\n-    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+    ldr(lr, Address(sp, wordSize));\n+    add(sp, sp, 2 * wordSize);\n@@ -7293,0 +7303,1 @@\n+  \/\/ TODO 8366717 We need to make sure that r14 (and potentially other long-life regs) are kept live in slowpath runtime calls in GC barriers\n@@ -7397,0 +7408,1 @@\n+  \/\/ TODO This is probably okay but looks fishy because stream is reset in the \"Set null marker to zero\" case just above. Same on x64.\n@@ -7477,1 +7489,0 @@\n-\n@@ -7507,1 +7518,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -483,30 +483,30 @@\n-     for (int i = 0; i < sig_extended->length(); i++) {\n-       BasicType bt = sig_extended->at(i)._bt;\n-       if (bt == T_METADATA) {\n-         \/\/ In sig_extended, an inline type argument starts with:\n-         \/\/ T_METADATA, followed by the types of the fields of the\n-         \/\/ inline type and T_VOID to mark the end of the value\n-         \/\/ type. Inline types are flattened so, for instance, in the\n-         \/\/ case of an inline type with an int field and an inline type\n-         \/\/ field that itself has 2 fields, an int and a long:\n-         \/\/ T_METADATA T_INT T_METADATA T_INT T_LONG T_VOID (second\n-         \/\/ slot for the T_LONG) T_VOID (inner inline type) T_VOID\n-         \/\/ (outer inline type)\n-         total_args_passed++;\n-         int vt = 1;\n-         do {\n-           i++;\n-           BasicType bt = sig_extended->at(i)._bt;\n-           BasicType prev_bt = sig_extended->at(i-1)._bt;\n-           if (bt == T_METADATA) {\n-             vt++;\n-           } else if (bt == T_VOID &&\n-                      prev_bt != T_LONG &&\n-                      prev_bt != T_DOUBLE) {\n-             vt--;\n-           }\n-         } while (vt != 0);\n-       } else {\n-         total_args_passed++;\n-       }\n-     }\n+    for (int i = 0; i < sig_extended->length(); i++) {\n+      BasicType bt = sig_extended->at(i)._bt;\n+      if (bt == T_METADATA) {\n+        \/\/ In sig_extended, an inline type argument starts with:\n+        \/\/ T_METADATA, followed by the types of the fields of the\n+        \/\/ inline type and T_VOID to mark the end of the value\n+        \/\/ type. Inline types are flattened so, for instance, in the\n+        \/\/ case of an inline type with an int field and an inline type\n+        \/\/ field that itself has 2 fields, an int and a long:\n+        \/\/ T_METADATA T_INT T_METADATA T_INT T_LONG T_VOID (second\n+        \/\/ slot for the T_LONG) T_VOID (inner inline type) T_VOID\n+        \/\/ (outer inline type)\n+        total_args_passed++;\n+        int vt = 1;\n+        do {\n+          i++;\n+          BasicType bt = sig_extended->at(i)._bt;\n+          BasicType prev_bt = sig_extended->at(i-1)._bt;\n+          if (bt == T_METADATA) {\n+            vt++;\n+          } else if (bt == T_VOID &&\n+                     prev_bt != T_LONG &&\n+                     prev_bt != T_DOUBLE) {\n+            vt--;\n+          }\n+        } while (vt != 0);\n+      } else {\n+        total_args_passed++;\n+      }\n+    }\n@@ -516,1 +516,0 @@\n-\n@@ -624,0 +623,1 @@\n+  \/\/ TODO 8366717 Is the comment about r13 correct? Isn't that r19_sender_sp?\n@@ -628,0 +628,1 @@\n+  \/\/ TODO 8366717 We need to make sure that buf_array, buf_oop (and potentially other long-life regs) are kept live in slowpath runtime calls in GC barriers\n@@ -644,1 +645,2 @@\n-      RegisterSaver reg_save(false \/* save_vectors *\/);\n+      \/\/ TODO 8366717 Do we need to save vectors here? They could be used as arg registers, right? Same on x64.\n+      RegisterSaver reg_save(true \/* save_vectors *\/);\n@@ -964,1 +966,0 @@\n-\n@@ -1014,2 +1015,1 @@\n-\n-  \/\/ The c2i adapter might safepoint and trigger a GC. The caller must make sure that\n+  \/\/ The c2i adapters might safepoint and trigger a GC. The caller must make sure that\n@@ -3129,0 +3129,1 @@\n+  \/\/ TODO this would need to go to pack_fields_jobject_off as well ...\n@@ -3229,1 +3230,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-    __ test_flat_array_oop(r0, r8 \/*temp*\/, is_flat_array);\n+    __ test_flat_array_oop(r0, rscratch1 \/*temp*\/, is_flat_array);\n@@ -1185,1 +1185,1 @@\n-      __ test_flat_array_oop(r3, r8, is_flat_array);\n+      __ test_flat_array_oop(r3, rscratch1, is_flat_array);\n@@ -1189,1 +1189,1 @@\n-    __ test_null_free_array_oop(r3, r8, is_null_into_value_array_npe);\n+    __ test_null_free_array_oop(r3, rscratch1, is_null_into_value_array_npe);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -472,0 +472,1 @@\n+      \/\/ TODO 8284443 Can't we do that by not passing 'dont_gc_arguments' in case 'C1StubId::buffer_inline_args_id' in 'Runtime1::generate_code_for'?\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-    \/\/ TODO: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64 )\n+    \/\/ TODO 8366717: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64 )\n@@ -334,1 +334,1 @@\n-  \/\/ TODO: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64)\n+  \/\/ TODO 8366717: use push_set() (see JDK-8283327 push\/pop_call_clobbered_registers & aarch64)\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6332,0 +6332,1 @@\n+    \/\/ Pack the scalarized field into the value object.\n@@ -6372,0 +6373,1 @@\n+    \/\/ TODO 8284443 Add a comment drawing the frame like in Aarch64's version of MacroAssembler::remove_frame\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @summary When needing some stack extension for unpacking arguments from the non-scalarized entry point,\n+ *          on Aarch64, LR (x30) and RFP (x29) are duplicated on the stack. But x29 can be used as an ordinary\n+ *          register, and hold an oop whose value can be updated by the GC, which is aware of only one copy\n+ *          of x29 on the stack. When returning, one must correctly restore x29 using the value known by the GC.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch\n+ *                   -XX:CompileCommand=dontinline,*::*\n+ *                   -XX:CompileCommand=printcompilation,*::*\n+ *                   -XX:CompileCommand=compileonly,compiler.valhalla.inlinetypes.CorrectlyRestoreRfp*::compile_me_*\n+ *                   compiler.valhalla.inlinetypes.CorrectlyRestoreRfp\n+ **\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.concurrent.CountDownLatch;\n+\n+public class CorrectlyRestoreRfp {\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final int COMP_LEVEL_SIMPLE = 1; \/\/ C1\n+    static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+\n+    static value class SmallValue {\n+        int x1;\n+        int x2;\n+\n+        public SmallValue(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2;\n+        }\n+    }\n+\n+    \/\/ Large value class with oops (and different number of fields) that requires stack extension\/repair\n+    static value class LargeValueWithOops {\n+        Object x1;\n+        Object x2;\n+        Object x3;\n+        Object x4;\n+        Object x5;\n+\n+        public LargeValueWithOops(Object obj) {\n+            this.x1 = obj;\n+            this.x2 = obj;\n+            this.x3 = obj;\n+            this.x4 = obj;\n+            this.x5 = obj;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5;\n+        }\n+\n+        public void verify(String loc, Object obj) {\n+            if (x1 != obj || x2 != obj || x3 != obj || x4 != obj || x5 != obj) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for obj = \" + obj + \": \" + this);\n+            }\n+        }\n+\n+        public static void compile_me_C2_verify(LargeValueWithOops val, String loc, Object obj, boolean useNull) {\n+            val.verify(loc, obj);\n+        }\n+    }\n+\n+    public static void dontInline() { }\n+\n+    public static LargeValueWithOops testLargeValueWithOops(LargeValueWithOops val) {\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        return val;\n+    }\n+\n+    public static LargeValueWithOops compile_me_C1_testLargeValueWithOopsHelper(Object obj) {\n+        LargeValueWithOops val = new LargeValueWithOops(obj);\n+        val = testLargeValueWithOops(val);\n+        LargeValueWithOops.compile_me_C2_verify(val, \"helper\", obj, false);\n+        return val;\n+    }\n+\n+    static class GarbageProducerThread extends Thread {\n+        public void run() {\n+            for (;;) {\n+                \/\/ Produce some garbage and then let the GC do its work\n+                Object[] arrays = new Object[1024];\n+                for (int i = 0; i < arrays.length; i++) {\n+                    arrays[i] = new int[1024];\n+                }\n+                System.gc();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Method compile_me_C2_verify = LargeValueWithOops.class.getMethod(\"compile_me_C2_verify\", LargeValueWithOops.class, String.class, Object.class, boolean.class);\n+        WHITE_BOX.makeMethodNotCompilable(compile_me_C2_verify, COMP_LEVEL_SIMPLE, false);\n+        Method compile_me_C1_testLargeValueWithOopsHelper = CorrectlyRestoreRfp.class.getMethod(\"compile_me_C1_testLargeValueWithOopsHelper\", Object.class);\n+        WHITE_BOX.makeMethodNotCompilable(compile_me_C1_testLargeValueWithOopsHelper, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+\n+        \/\/ Start another thread that does some allocations and calls System.gc()\n+        \/\/ to trigger GCs while virtual threads are parked.\n+        Thread garbage_producer = new GarbageProducerThread();\n+        garbage_producer.setDaemon(true);\n+        garbage_producer.start();\n+\n+        CountDownLatch cdl = new CountDownLatch(1);\n+        Thread.ofPlatform().start(() -> {\n+            try {\n+                \/\/ Trigger compilation\n+                for (int i = 0; i < 500_000; i++) {\n+                    Object val = new SmallValue(i);\n+                    var v = compile_me_C1_testLargeValueWithOopsHelper(val);\n+                    LargeValueWithOops.compile_me_C2_verify(v, \"return\", val, false);\n+                }\n+                cdl.countDown();\n+            } catch (Exception e) {\n+                System.out.println(\"Exception thrown: \" + e);\n+                e.printStackTrace(System.out);\n+                System.exit(1);\n+            }\n+        });\n+        cdl.await();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/CorrectlyRestoreRfp.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -1193,2 +1193,0 @@\n-            \/\/ TODO 8355277 Re-enable\n-            \/*\n@@ -1198,1 +1196,0 @@\n-            *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @requires vm.simpleArch == \"x64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOopsInReturnConvention.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}