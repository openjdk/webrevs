{"files":[{"patch":"@@ -67,1 +67,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -73,1 +73,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -80,1 +80,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -86,1 +86,1 @@\n-            debian-version: bookworm\n+            debian-version: trixie\n@@ -92,2 +92,2 @@\n-            debian-version: sid\n-            tolerate-sysroot-errors: true\n+            debian-version: trixie\n+            tolerate-sysroot-errors: false\n","filename":".github\/workflows\/build-cross-compile.yml","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -212,0 +212,10 @@\n+<h4 id=\"conventions-for-lock-free-code\">Conventions for Lock-free\n+Code<\/h4>\n+<p>Sometimes variables are accessed concurrently without appropriate\n+synchronization context, such as a held mutex or at a safepoint. In such\n+cases the variable should be declared <code>volatile<\/code> and it\n+should NOT be accessed as a normal C++ lvalue. Rather, access should be\n+performed via functions from <code>Atomic<\/code>, such as\n+<code>Atomic::load<\/code>, <code>Atomic::store<\/code>, etc.<\/p>\n+<p>This special formulation makes it more clear to maintainers that the\n+variable is accessed concurrently in a lock-free manner.<\/p>\n","filename":"doc\/hotspot-style.html","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -138,0 +138,11 @@\n+#### Conventions for Lock-free Code\n+\n+Sometimes variables are accessed concurrently without appropriate synchronization\n+context, such as a held mutex or at a safepoint. In such cases the variable should\n+be declared `volatile` and it should NOT be accessed as a normal C++ lvalue. Rather,\n+access should be performed via functions from `Atomic`, such as `Atomic::load`,\n+`Atomic::store`, etc.\n+\n+This special formulation makes it more clear to maintainers that the variable is\n+accessed concurrently in a lock-free manner.\n+\n","filename":"doc\/hotspot-style.md","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -401,1 +401,2 @@\n-<p>Currently only applies to JTReg.<\/p>\n+<p>Currently only applies to <a href=\"#timeout_factor-1\">JTReg\n+-timeoutFactor<\/a>.<\/p>\n@@ -447,2 +448,6 @@\n-<p>The timeout factor (<code>-timeoutFactor<\/code>).<\/p>\n-<p>Defaults to 4.<\/p>\n+<p>The <code>TIMEOUT_FACTOR<\/code> is forwarded to JTReg framework\n+itself (<code>-timeoutFactor<\/code>). Also, some test cases that\n+programmatically wait a certain amount of time will apply this factor.\n+If we run in forced compilation mode (<code>-Xcomp<\/code>), the build\n+system will automatically adjust this factor to compensate for less\n+performance. Defaults to 1.<\/p>\n","filename":"doc\/testing.html","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-Currently only applies to JTReg.\n+Currently only applies to [JTReg -timeoutFactor](#timeout_factor-1).\n@@ -386,3 +386,5 @@\n-The timeout factor (`-timeoutFactor`).\n-\n-Defaults to 4.\n+The `TIMEOUT_FACTOR` is forwarded to JTReg framework itself\n+(`-timeoutFactor`). Also, some test cases that programmatically wait a\n+certain amount of time will apply this factor. If we run in forced\n+compilation mode (`-Xcomp`), the build system will automatically\n+adjust this factor to compensate for less performance. Defaults to 1.\n","filename":"doc\/testing.md","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -949,1 +949,2 @@\n-  JTREG_AUTO_TIMEOUT_FACTOR := 4\n+  # Please reach consensus before changing this. It was not easy changing it to a `1`.\n+  JTREG_AUTO_TIMEOUT_FACTOR := 1\n","filename":"make\/RunTests.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,0 +224,3 @@\n+# Setup static analyzer\n+JDKOPT_SETUP_STATIC_ANALYZER\n+\n","filename":"make\/autoconf\/configure.ac","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -323,0 +323,3 @@\n+    if test \"x$OPENJDK_TARGET_CPU\" != xaarch64; then\n+      AS_NON_ASM_EXTENSION_OPTION=-Ta\n+    fi\n@@ -329,0 +332,1 @@\n+  AC_SUBST(AS_NON_ASM_EXTENSION_OPTION)\n","filename":"make\/autoconf\/flags.m4","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -482,0 +482,25 @@\n+################################################################################\n+#\n+# Static analyzer\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_STATIC_ANALYZER],\n+[\n+  UTIL_ARG_ENABLE(NAME: static-analyzer, DEFAULT: false, RESULT: STATIC_ANALYZER_ENABLED,\n+      DESC: [enable the GCC static analyzer],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if static analyzer is available])\n+        if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+          AC_MSG_RESULT([yes])\n+        else\n+          AC_MSG_RESULT([no])\n+          AVAILABLE=false\n+        fi\n+      ],\n+      IF_ENABLED: [\n+        STATIC_ANALYZER_CFLAGS=\"-fanalyzer -Wno-analyzer-fd-leak\"\n+        CFLAGS_JDKLIB=\"$CFLAGS_JDKLIB $STATIC_ANALYZER_CFLAGS\"\n+        CFLAGS_JDKEXE=\"$CFLAGS_JDKEXE $STATIC_ANALYZER_CFLAGS\"\n+      ])\n+  AC_SUBST(STATIC_ANALYZER_ENABLED)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -495,0 +495,1 @@\n+AS_NON_ASM_EXTENSION_OPTION := @AS_NON_ASM_EXTENSION_OPTION@\n","filename":"make\/autoconf\/spec.gmk.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,6 +158,0 @@\n-      else ifeq ($(TOOLCHAIN_TYPE), microsoft)\n-        ifeq ($(OPENJDK_TARGET_CPU), aarch64)\n-          $1_NON_ASM_EXTENSION_FLAG :=\n-        else\n-          $1_NON_ASM_EXTENSION_FLAG := \"-Ta\"\n-        endif\n@@ -245,1 +239,1 @@\n-\t        $(CC_OUT_OPTION)$$($1_OBJ) $$($1_NON_ASM_EXTENSION_FLAG) $$($1_SRC_FILE))) \\\n+\t        $(CC_OUT_OPTION)$$($1_OBJ) $(AS_NON_ASM_EXTENSION_OPTION) $$($1_SRC_FILE))) \\\n","filename":"make\/common\/native\/CompileFile.gmk","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    invalid-offsetof \\\n@@ -104,1 +105,2 @@\n-DISABLED_WARNINGS_clang := delete-non-abstract-non-virtual-dtor missing-braces \\\n+DISABLED_WARNINGS_clang := delete-non-abstract-non-virtual-dtor \\\n+    invalid-offsetof missing-braces \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    LIBS_linux := $(LIBDL), \\\n+    LIBS_linux := $(LIBDL) $(LIBPTHREAD), \\\n@@ -100,1 +100,1 @@\n-      LIBS_linux := $(LIBDL), \\\n+      LIBS_linux := $(LIBDL) $(LIBPTHREAD), \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  echo \"-b     Specifies the base reference for change set lookup.\"\n@@ -66,1 +67,1 @@\n-  echo \"       as specified by -y.\"\n+  echo \"       as specified by -y. Overrides -b flag.\"\n@@ -72,0 +73,1 @@\n+base_reference=master\n@@ -74,1 +76,1 @@\n-while getopts \"c:fhy:\" option; do\n+while getopts \"b:c:fhy:\" option; do\n@@ -76,0 +78,3 @@\n+    b) # supplied base reference\n+      base_reference=${OPTARG}\n+      ;;\n@@ -114,1 +119,1 @@\n-    vcs_list_changesets=(git log --no-merges 'master..HEAD' --since=\"${year}-01-01T00:00:00Z\" --until=\"${year}-12-31T23:59:59Z\" --pretty=tformat:\"%H\")\n+    vcs_list_changesets=(git log --no-merges \"${base_reference}..HEAD\" --since=\"${year}-01-01T00:00:00Z\" --until=\"${year}-12-31T23:59:59Z\" --pretty=tformat:\"%H\")\n","filename":"make\/scripts\/update_copyright_year.sh","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+#!\/bin\/sh\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+# The output of this script may require some degree of human curation:\n+# - Redundant headers, e.g. both x.hpp, x.inline.hpp are included;\n+# - Headers relative to a non-default feature should be protected by an\n+#   appropriate 'if' clause to make sure all variants can build without \n+#   errors.\n+\n+# Time threshold for header compilation, if the time exceeds the\n+# threshold the header will be precompiled.\n+if [ -z \"$MIN_MS\" ]; then\n+  MIN_MS=100000\n+fi\n+\n+if [ -z \"$CLEAN\" ]; then\n+  CLEAN=true\n+elif [ \"$CLEAN\" != \"true\" ] && [ \"$CLEAN\" != \"false\" ]; then\n+  echo \"Expected either 'true' or 'false' for CLEAN\"\n+fi\n+\n+# CBA_PATH should point to a valid ClangBuildAnalyzer executable.\n+# Build steps:\n+# git clone --depth 1 git@github.com:aras-p\/ClangBuildAnalyzer.git\n+# cd ClangBuildAnalyzer\n+# make -f projects\/make\/Makefile\n+if [ -z \"$CBA_PATH\" ]; then\n+  CBA_PATH=\".\/ClangBuildAnalyzer\/build\/ClangBuildAnalyzer\"\n+fi\n+\n+set -eux\n+\n+PRECOMPILED_HPP=\"src\/hotspot\/share\/precompiled\/precompiled.hpp\"\n+CBA_CONFIG=\"ClangBuildAnalyzer.ini\"\n+TIMESTAMP=\"$(date +%Y%m%d-%H%M)\"\n+RUN_NAME=\"pch_update_$TIMESTAMP\"\n+CBA_OUTPUT=\"cba_out_$TIMESTAMP\"\n+\n+if [ \"$CLEAN\" = \"true\" ]; then\n+  trap 'rm -rf \"build\/'\"$RUN_NAME\"'\" \"$CBA_OUTPUT\" \"$CBA_CONFIG\"' EXIT\n+fi\n+\n+sh configure --with-toolchain-type=clang \\\n+             --with-conf-name=\"$RUN_NAME\" \\\n+             --disable-precompiled-headers \\\n+             --with-extra-cxxflags=\"-ftime-trace\" \\\n+             --with-extra-cflags=\"-ftime-trace\"\n+\n+make clean CONF_NAME=\"$RUN_NAME\"\n+make hotspot CONF_NAME=\"$RUN_NAME\"\n+\"$CBA_PATH\" --all \".\/build\/$RUN_NAME\/hotspot\/variant-server\/libjvm\/objs\" \\\n+  \"$CBA_OUTPUT\"\n+\n+# Preserve license and comments on top\n+cat \"$PRECOMPILED_HPP\" | awk '\/^#include\/ {exit} {print}' > \"$PRECOMPILED_HPP.tmp\"\n+\n+if [ ! -f \"$CBA_CONFIG\" ]; then\n+cat <<EOF > \"$CBA_CONFIG\"\n+[counts]\n+header=100\n+headerChain=0\n+template=0\n+function=0\n+fileCodegen=0\n+fileParse=0\n+\n+[misc]\n+onlyRootHeaders=true\n+EOF\n+fi\n+\n+\"$CBA_PATH\" --analyze \"$CBA_OUTPUT\" | \\\n+  grep \" ms: \" | \\\n+  # Keep the headers more expensive than ${1}ms\n+  awk -v x=\"$MIN_MS\" '$1 < x { exit } { print $3 }' | \\\n+  # Filter away non-hotspot headers\n+  grep hotspot\/share | \\\n+  awk -F \"hotspot\/share\/\" '{ printf \"#include \\\"%s\\\"\\n\", $2 }' \\\n+  >> \"$PRECOMPILED_HPP.tmp\"\n+mv \"$PRECOMPILED_HPP.tmp\" \"$PRECOMPILED_HPP\"\n+\n+java test\/hotspot\/jtreg\/sources\/SortIncludes.java --update \"$PRECOMPILED_HPP\"\n","filename":"make\/scripts\/update_pch.sh","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -141,0 +141,1 @@\n+      LIBS := $(LIBPTHREAD), \\\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4437,1 +4437,1 @@\n-operand immI8_shift8()\n+operand immIDupV()\n@@ -4439,2 +4439,1 @@\n-  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n-            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->get_int()));\n@@ -4449,1 +4448,1 @@\n-operand immL8_shift8()\n+operand immLDupV()\n@@ -4451,2 +4450,1 @@\n-  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n-            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate(n->get_long()));\n@@ -4460,0 +4458,11 @@\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immHDupV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->geth()));\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -7102,3 +7111,0 @@\n-\/\/ The \"ldr\" instruction loads a 32-bit word from the constant pool into a\n-\/\/ 32-bit register but only the bottom half will be populated and the top\n-\/\/ 16 bits are zero.\n@@ -7107,3 +7113,3 @@\n-  format %{\n-    \"ldrs $dst, [$constantaddress]\\t# load from constant table: half float=$con\\n\\t\"\n-  %}\n+  format %{ \"mov    rscratch1, $con\\n\\t\"\n+            \"fmov   $dst, rscratch1\"\n+         %}\n@@ -7111,1 +7117,2 @@\n-    __ ldrs(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    __ movw(rscratch1, (uint32_t)$con$$constant);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n@@ -7113,1 +7120,1 @@\n-  ins_pipe(fp_load_constant_s);\n+  ins_pipe(pipe_class_default);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -4878,1 +4878,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -4901,1 +4901,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -4912,2 +4912,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -4915,1 +4916,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -4917,1 +4918,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -4919,6 +4919,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3110,1 +3110,1 @@\n-instruct replicateI_imm8_gt128b(vReg dst, immI8_shift8 con) %{\n+instruct replicateI_imm8_gt128b(vReg dst, immIDupV con) %{\n@@ -3133,1 +3133,1 @@\n-instruct replicateL_imm8_gt128b(vReg dst, immL8_shift8 con) %{\n+instruct replicateL_imm8_gt128b(vReg dst, immLDupV con) %{\n@@ -3144,2 +3144,3 @@\n-\/\/ Replicate a 16-bit half precision float value\n-instruct replicateHF_imm(vReg dst, immH con) %{\n+\/\/ Replicate an immediate 16-bit half precision float value\n+instruct replicateHF_imm_le128b(vReg dst, immH con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) <= 16);\n@@ -3147,1 +3148,1 @@\n-  format %{ \"replicateHF_imm $dst, $con\\t# replicate immediate half-precision float\" %}\n+  format %{ \"replicateHF_imm_le128b $dst, $con\\t# vector <= 128 bits\" %}\n@@ -3149,1 +3150,0 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n@@ -3151,6 +3151,14 @@\n-    if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-      __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n-    } else { \/\/ length_in_bytes must be > 16 and SVE should be enabled\n-      assert(UseSVE > 0, \"must be sve\");\n-      __ sve_dup($dst$$FloatRegister, __ H, imm);\n-    }\n+    __ mov($dst$$FloatRegister, get_arrangement(this), imm);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Replicate a 16-bit half precision float which is within the limits\n+\/\/ for the operand - immHDupV\n+instruct replicateHF_imm8_gt128b(vReg dst, immHDupV con) %{\n+  predicate(Matcher::vector_length_in_bytes(n) > 16);\n+  match(Set dst (Replicate con));\n+  format %{ \"replicateHF_imm8_gt128b $dst, $con\\t# vector > 128 bits\" %}\n+  ins_encode %{\n+    assert(UseSVE > 0, \"must be sve\");\n+    __ sve_dup($dst$$FloatRegister, __ H, (int)($con$$constant));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -437,0 +437,5 @@\n+bool Assembler::operand_valid_for_sve_dup_immediate(int64_t imm) {\n+  return ((imm >= -128 && imm <= 127) ||\n+          (((imm & 0xff) == 0) && imm >= -32768 && imm <= 32512));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4327,0 +4327,1 @@\n+  static bool operand_valid_for_sve_dup_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -711,1 +711,1 @@\n-    snprintf(buf, sizeof buf, \"(bad)\");\n+    os::snprintf_checked(buf, sizeof buf, \"(bad)\");\n@@ -714,1 +714,1 @@\n-    snprintf(buf, sizeof buf, \"%d\", bci);\n+    os::snprintf_checked(buf, sizeof buf, \"%d\", bci);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2367,1 +2367,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n@@ -2425,1 +2425,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n@@ -2538,1 +2538,1 @@\n-      snprintf(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n@@ -3010,1 +3010,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n@@ -3012,1 +3012,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n@@ -3014,1 +3014,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n@@ -3122,1 +3122,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n@@ -3124,1 +3124,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n@@ -3126,1 +3126,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n@@ -6267,1 +6267,1 @@\n-    snprintf(comment, sizeof comment, \"array_equals%c{\", kind);\n+    os::snprintf_checked(comment, sizeof comment, \"array_equals%c{\", kind);\n@@ -6465,1 +6465,1 @@\n-    snprintf(comment, sizeof comment, \"{string_equalsL\");\n+    os::snprintf_checked(comment, sizeof comment, \"{string_equalsL\");\n@@ -6613,1 +6613,1 @@\n-      snprintf(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n+      os::snprintf_checked(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -724,1 +724,1 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n@@ -726,1 +726,1 @@\n-  int desc_len = snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n+  int desc_len = os::snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n@@ -729,1 +729,1 @@\n-  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -842,1 +842,1 @@\n-    snprintf(buffer, sizeof(buffer), \"verify_oop at %d\", offset());\n+    os::snprintf_checked(buffer, sizeof(buffer), \"verify_oop at %d\", offset());\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -365,2 +365,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -628,2 +628,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2682,1 +2682,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIx64, uimm64);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -496,2 +496,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"RISCV64\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"RISCV64\");\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"RISCV64 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1552,2 +1552,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", cpu_info_string());\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4561,1 +4561,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n@@ -4564,1 +4564,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -245,2 +245,2 @@\n-    snprintf(fieldbuf, buflen, \"word[%d]\", offset);\n-    snprintf(valuebuf, buflen, PTR_FORMAT, *addr);\n+    os::snprintf_checked(fieldbuf, buflen, \"word[%d]\", offset);\n+    os::snprintf_checked(valuebuf, buflen, PTR_FORMAT, *addr);\n@@ -303,1 +303,1 @@\n-    snprintf(fieldbuf, buflen, \"local[%d]\", offset - 3);\n+    os::snprintf_checked(fieldbuf, buflen, \"local[%d]\", offset - 3);\n@@ -324,3 +324,3 @@\n-        snprintf(valuebuf, buflen, PTR_FORMAT \" (bci %d)\",\n-                 (intptr_t) istate->bcp(),\n-                 istate->method()->bci_from(istate->bcp()));\n+        os::snprintf_checked(valuebuf, buflen, PTR_FORMAT \" (bci %d)\",\n+                             (intptr_t) istate->bcp(),\n+                             istate->method()->bci_from(istate->bcp()));\n@@ -328,2 +328,2 @@\n-      snprintf(fieldbuf, buflen, \"%sistate->%s\",\n-               field[strlen(field) - 1] == ')' ? \"(\": \"\", field);\n+      os::snprintf_checked(fieldbuf, buflen, \"%sistate->%s\",\n+                           field[strlen(field) - 1] == ')' ? \"(\": \"\", field);\n@@ -361,1 +361,1 @@\n-          snprintf(fieldbuf, buflen, \"parameter[%d]%s\", param, desc);\n+          os::snprintf_checked(fieldbuf, buflen, \"parameter[%d]%s\", param, desc);\n@@ -367,1 +367,1 @@\n-            snprintf(fieldbuf, buflen, \"unboxed parameter[%d]\", i);\n+            os::snprintf_checked(fieldbuf, buflen, \"unboxed parameter[%d]\", i);\n@@ -399,1 +399,1 @@\n-      snprintf(fieldbuf, buflen, \"monitor[%d]->_obj\", index);\n+      os::snprintf_checked(fieldbuf, buflen, \"monitor[%d]->_obj\", index);\n@@ -401,1 +401,1 @@\n-      snprintf(fieldbuf, buflen, \"monitor[%d]->_lock\", index);\n+      os::snprintf_checked(fieldbuf, buflen, \"monitor[%d]->_lock\", index);\n@@ -408,3 +408,3 @@\n-    snprintf(fieldbuf, buflen, \"%s[%d]\",\n-             frame_index == 0 ? \"stack_word\" : \"local\",\n-             (int) (stack_base - addr - 1));\n+    os::snprintf_checked(fieldbuf, buflen, \"%s[%d]\",\n+                         frame_index == 0 ? \"stack_word\" : \"local\",\n+                         (int) (stack_base - addr - 1));\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n+  os::snprintf_checked(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n+  os::snprintf_checked(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _cpu_info_string);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,2 +212,2 @@\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n+  int n = os::snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -215,1 +215,1 @@\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+    n = os::snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n@@ -352,3 +352,2 @@\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+  os::snprintf_checked(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -422,2 +421,2 @@\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n-             os::get_temp_directory(), os::current_process_id());\n+    os::snprintf_checked(fn, sizeof(fn), \"%s\/.attach_pid%d\",\n+                         os::get_temp_directory(), os::current_process_id());\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-julong    os::Aix::_physical_memory = 0;\n+size_t    os::Aix::_physical_memory = 0;\n@@ -257,2 +257,2 @@\n-julong os::free_memory() {\n-  return Aix::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return Aix::available_memory(value);\n@@ -261,2 +261,2 @@\n-julong os::available_memory() {\n-  return Aix::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Aix::available_memory(value);\n@@ -265,1 +265,1 @@\n-julong os::Aix::available_memory() {\n+bool os::Aix::available_memory(size_t& value) {\n@@ -268,1 +268,2 @@\n-    return mi.real_free;\n+    value = static_cast<size_t>(mi.real_free);\n+    return true;\n@@ -270,1 +271,1 @@\n-    return ULONG_MAX;\n+    return false;\n@@ -274,1 +275,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -277,1 +278,1 @@\n-    return -1;\n+    return false;\n@@ -279,1 +280,2 @@\n-  return (jlong)(memory_info.pgsp_total * 4 * K);\n+  value = static_cast<size_t>(memory_info.pgsp_total * 4 * K);\n+  return true;\n@@ -282,1 +284,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -285,1 +287,1 @@\n-    return -1;\n+    return false;\n@@ -287,1 +289,2 @@\n-  return (jlong)(memory_info.pgsp_free * 4 * K);\n+  value = static_cast<size_t>(memory_info.pgsp_free * 4 * K);\n+  return true;\n@@ -290,1 +293,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -329,1 +332,1 @@\n-  _physical_memory = (julong) mi.real_total;\n+  _physical_memory = static_cast<size_t>(mi.real_total);\n@@ -1054,2 +1057,2 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n-               filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s, LIBPATH=%s, LD_LIBRARY_PATH=%s : %s\",\n+                           filename, ::getenv(\"LIBPATH\"), ::getenv(\"LD_LIBRARY_PATH\"), error_report);\n@@ -1080,1 +1083,1 @@\n-      os::snprintf(tmp_path + prefix_size, sizeof(old_extension), \"%s\", new_extension);\n+      os::snprintf_checked(tmp_path + prefix_size, sizeof(old_extension), \"%s\", new_extension);\n@@ -1097,1 +1100,1 @@\n-  snprintf(buf, buflen, \"%s %s\", name.release, name.version);\n+  os::snprintf_checked(buf, buflen, \"%s %s\", name.release, name.version);\n@@ -2196,1 +2199,1 @@\n-  trcVerbose(\"physical memory: %lu\", Aix::_physical_memory);\n+  trcVerbose(\"physical memory: %zu\", Aix::_physical_memory);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -57,3 +57,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -939,1 +939,1 @@\n-  snprintf(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n+  os::snprintf_checked(buffer, 100, \"\/proc\/%ld\/object\/a.out\", (long)getpid());\n@@ -1157,1 +1157,1 @@\n-        snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+        os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n@@ -1192,1 +1192,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/porting_aix.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-        snprintf(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n+        os::snprintf_checked(buffer, sizeof(buffer), \"user_tag=0x%x(%d)\", user_tag, user_tag);\n","filename":"src\/hotspot\/os\/bsd\/memMapPrinter_macosx.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-julong os::Bsd::_physical_memory = 0;\n+size_t os::Bsd::_physical_memory = 0;\n@@ -136,2 +136,2 @@\n-julong os::available_memory() {\n-  return Bsd::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Bsd::available_memory(value);\n@@ -140,2 +140,2 @@\n-julong os::free_memory() {\n-  return Bsd::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return Bsd::available_memory(value);\n@@ -147,2 +147,2 @@\n-julong os::Bsd::available_memory() {\n-  uint64_t available = physical_memory() >> 2;\n+bool os::Bsd::available_memory(size_t& value) {\n+  uint64_t available = static_cast<uint64_t>(physical_memory() >> 2);\n@@ -159,0 +159,2 @@\n+  } else {\n+    return false;\n@@ -161,1 +163,2 @@\n-  return available;\n+  value = static_cast<size_t>(available);\n+  return true;\n@@ -180,1 +183,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -185,1 +188,1 @@\n-    return -1;\n+    return false;\n@@ -187,1 +190,2 @@\n-  return (jlong)vmusage.xsu_total;\n+  value = static_cast<size_t>(vmusage.xsu_total);\n+  return true;\n@@ -189,1 +193,1 @@\n-  return -1;\n+  return false;\n@@ -193,1 +197,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -198,1 +202,1 @@\n-    return -1;\n+    return false;\n@@ -200,1 +204,2 @@\n-  return (jlong)vmusage.xsu_avail;\n+  value = static_cast<size_t>(vmusage.xsu_avail);\n+  return true;\n@@ -202,1 +207,1 @@\n-  return -1;\n+  return false;\n@@ -206,1 +211,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -284,1 +289,1 @@\n-    _physical_memory = mem_val;\n+    _physical_memory = static_cast<size_t>(mem_val);\n@@ -295,1 +300,1 @@\n-    _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);\n+    _physical_memory = MIN2(_physical_memory, static_cast<size_t>(limits.rlim_cur));\n@@ -525,1 +530,1 @@\n-          user_home_dir, Arguments::get_java_home());\n+                       user_home_dir, Arguments::get_java_home());\n@@ -1245,1 +1250,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: endianness mismatch)\");\n@@ -1251,1 +1256,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\" (Possible cause: architecture word width mismatch)\");\n@@ -1258,3 +1263,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n-                 lib_arch.name, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load %s-bit .so on a %s-bit platform)\",\n+                           lib_arch.name, arch_array[running_arch_index].name);\n@@ -1262,4 +1267,4 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n-                 lib_arch.code,\n-                 arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load this .so (machine code=0x%x) on a %s-bit platform)\",\n+                           lib_arch.code,\n+                           arch_array[running_arch_index].name);\n@@ -1367,1 +1372,1 @@\n-      snprintf(buf, buflen, \"%s %s, macOS %s\", os, release, osproductversion);\n+      os::snprintf_checked(buf, buflen, \"%s %s, macOS %s\", os, release, osproductversion);\n@@ -1369,1 +1374,1 @@\n-      snprintf(buf, buflen, \"%s %s, macOS %s (%s)\", os, release, osproductversion, build);\n+      os::snprintf_checked(buf, buflen, \"%s %s, macOS %s (%s)\", os, release, osproductversion, build);\n@@ -1373,1 +1378,1 @@\n-  snprintf(buf, buflen, \"%s %s\", os, release);\n+  os::snprintf_checked(buf, buflen, \"%s %s\", os, release);\n@@ -1450,1 +1455,1 @@\n-    snprintf(buf, buflen, \"\\\"%s\\\" %s (EMULATED) %d MHz\", model, machine, mhz);\n+    os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s (EMULATED) %d MHz\", model, machine, mhz);\n@@ -1452,1 +1457,1 @@\n-    NOT_AARCH64(snprintf(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz));\n+    NOT_AARCH64(os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz));\n@@ -1454,1 +1459,1 @@\n-    AARCH64_ONLY(snprintf(buf, buflen, \"\\\"%s\\\" %s\", model, machine));\n+    AARCH64_ONLY(os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s\", model, machine));\n@@ -1457,1 +1462,1 @@\n-  snprintf(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz);\n+  os::snprintf_checked(buf, buflen, \"\\\"%s\\\" %s %d MHz\", model, machine, mhz);\n@@ -1467,5 +1472,7 @@\n-\n-  st->print(\", physical \" UINT64_FORMAT \"k\",\n-            os::physical_memory() >> 10);\n-  st->print(\"(\" UINT64_FORMAT \"k free)\",\n-            os::available_memory() >> 10);\n+  size_t phys_mem = os::physical_memory();\n+  st->print(\", physical %zuk\",\n+            phys_mem >> 10);\n+  size_t avail_mem = 0;\n+  (void)os::available_memory(avail_mem);\n+  st->print(\"(%zuk free)\",\n+            avail_mem >> 10);\n@@ -2159,1 +2166,1 @@\n-    snprintf(buf, sizeof(buf), \"Java: %s\", name);\n+    (void) os::snprintf(buf, sizeof(buf), \"Java: %s\", name);\n@@ -2493,1 +2500,1 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":50,"deletions":43,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -48,3 +48,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -673,2 +673,2 @@\n-  jlong phys_mem = os::Linux::physical_memory();\n-  log_trace(os, container)(\"total physical memory: \" JLONG_FORMAT, phys_mem);\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n+  log_trace(os, container)(\"total physical memory: \" JULONG_FORMAT, phys_mem);\n@@ -844,1 +844,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -850,1 +850,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -856,1 +856,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n@@ -897,1 +897,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  julong phys_mem = os::Linux::physical_memory();\n+  julong phys_mem = static_cast<julong>(os::Linux::physical_memory());\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  sigevent_t sev;\n+  struct sigevent sev;\n","filename":"src\/hotspot\/os\/linux\/compilerThreadTimeout_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  snprintf(filename, sizeof(filename), \"%s%s\", name, ZLargePages::is_explicit() ? \".hugetlb\" : \"\");\n+  os::snprintf_checked(filename, sizeof(filename), \"%s%s\", name, ZLargePages::is_explicit() ? \".hugetlb\" : \"\");\n@@ -265,1 +265,1 @@\n-  snprintf(filename, sizeof(filename), \"%s\/%s.%d\", mountpoint.get(), name, os::current_process_id());\n+  os::snprintf_checked(filename, sizeof(filename), \"%s\/%s.%d\", mountpoint.get(), name, os::current_process_id());\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-julong os::Linux::_physical_memory = 0;\n+size_t os::Linux::_physical_memory = 0;\n@@ -235,2 +235,2 @@\n-julong os::available_memory() {\n-  return Linux::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return Linux::available_memory(value);\n@@ -239,1 +239,1 @@\n-julong os::Linux::available_memory() {\n+bool os::Linux::available_memory(size_t& value) {\n@@ -243,1 +243,2 @@\n-    return avail_mem;\n+    value = static_cast<size_t>(avail_mem);\n+    return true;\n@@ -258,1 +259,5 @@\n-    avail_mem = free_memory();\n+    size_t free_mem = 0;\n+    if (!free_memory(free_mem)) {\n+      return false;\n+    }\n+    avail_mem = static_cast<julong>(free_mem);\n@@ -261,1 +266,2 @@\n-  return avail_mem;\n+  value = static_cast<size_t>(avail_mem);\n+  return true;\n@@ -264,2 +270,2 @@\n-julong os::free_memory() {\n-  return Linux::free_memory();\n+bool os::free_memory(size_t& value) {\n+  return Linux::free_memory(value);\n@@ -268,1 +274,1 @@\n-julong os::Linux::free_memory() {\n+bool os::Linux::free_memory(size_t& value) {\n@@ -274,1 +280,2 @@\n-    return free_mem;\n+    value = static_cast<size_t>(free_mem);\n+    return true;\n@@ -277,1 +284,4 @@\n-  sysinfo(&si);\n+  int ret = sysinfo(&si);\n+  if (ret != 0) {\n+    return false;\n+  }\n@@ -280,1 +290,2 @@\n-  return free_mem;\n+  value = static_cast<size_t>(free_mem);\n+  return true;\n@@ -283,1 +294,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -285,2 +296,5 @@\n-    if (OSContainer::memory_limit_in_bytes() > 0) {\n-      return (jlong)(OSContainer::memory_and_swap_limit_in_bytes() - OSContainer::memory_limit_in_bytes());\n+    jlong memory_and_swap_limit_in_bytes = OSContainer::memory_and_swap_limit_in_bytes();\n+    jlong memory_limit_in_bytes = OSContainer::memory_limit_in_bytes();\n+    if (memory_limit_in_bytes > 0 && memory_and_swap_limit_in_bytes > 0) {\n+      value = static_cast<size_t>(memory_and_swap_limit_in_bytes - memory_limit_in_bytes);\n+      return true;\n@@ -288,1 +302,1 @@\n-  }\n+  } \/\/ fallback to the host swap space if the container did return the unbound value of -1\n@@ -292,1 +306,2 @@\n-    return -1;\n+    assert(false, \"sysinfo failed in total_swap_space(): %s\", os::strerror(errno));\n+    return false;\n@@ -294,1 +309,2 @@\n-  return  (jlong)(si.totalswap * si.mem_unit);\n+  value = static_cast<size_t>(si.totalswap * si.mem_unit);\n+  return true;\n@@ -297,1 +313,1 @@\n-static jlong host_free_swap() {\n+static bool host_free_swap_f(size_t& value) {\n@@ -301,1 +317,2 @@\n-    return -1;\n+    assert(false, \"sysinfo failed in host_free_swap_f(): %s\", os::strerror(errno));\n+    return false;\n@@ -303,1 +320,2 @@\n-  return (jlong)(si.freeswap * si.mem_unit);\n+  value = static_cast<size_t>(si.freeswap * si.mem_unit);\n+  return true;\n@@ -306,1 +324,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -309,2 +327,6 @@\n-  jlong host_free_swap_val = MIN2(os::total_swap_space(), host_free_swap());\n-  assert(host_free_swap_val >= 0, \"sysinfo failed?\");\n+  size_t total_swap_space = 0;\n+  size_t host_free_swap = 0;\n+  if (!os::total_swap_space(total_swap_space) || !host_free_swap_f(host_free_swap)) {\n+    return false;\n+  }\n+  size_t host_free_swap_val = MIN2(total_swap_space, host_free_swap);\n@@ -317,1 +339,2 @@\n-        return 0;\n+        value = 0;\n+        return true;\n@@ -325,1 +348,2 @@\n-          return free_swap >= 0 ? free_swap : 0;\n+          value = free_swap >= 0 ? static_cast<size_t>(free_swap) : 0;\n+          return true;\n@@ -331,1 +355,1 @@\n-                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: \" JLONG_FORMAT,\n+                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: %zu\",\n@@ -334,1 +358,2 @@\n-  return host_free_swap_val;\n+  value = host_free_swap_val;\n+  return true;\n@@ -337,2 +362,1 @@\n-julong os::physical_memory() {\n-  jlong phys_mem = 0;\n+size_t os::physical_memory() {\n@@ -343,1 +367,1 @@\n-      return mem_limit;\n+      return static_cast<size_t>(mem_limit);\n@@ -347,2 +371,2 @@\n-  phys_mem = Linux::physical_memory();\n-  log_trace(os)(\"total system memory: \" JLONG_FORMAT, phys_mem);\n+  size_t phys_mem = Linux::physical_memory();\n+  log_trace(os)(\"total system memory: %zu\", phys_mem);\n@@ -523,1 +547,1 @@\n-  _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);\n+  _physical_memory = static_cast<size_t>(sysconf(_SC_PHYS_PAGES)) * static_cast<size_t>(sysconf(_SC_PAGESIZE));\n@@ -1851,3 +1875,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load %s .so on a %s platform)\",\n-                 lib_arch.name, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load %s .so on a %s platform)\",\n+                           lib_arch.name, arch_array[running_arch_index].name);\n@@ -1855,3 +1879,3 @@\n-      ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-                 \" (Possible cause: can't load this .so (machine code=0x%x) on a %s platform)\",\n-                 lib_arch.code, arch_array[running_arch_index].name);\n+      os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                           \" (Possible cause: can't load this .so (machine code=0x%x) on a %s platform)\",\n+                           lib_arch.code, arch_array[running_arch_index].name);\n@@ -1863,1 +1887,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: endianness mismatch)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: endianness mismatch)\");\n@@ -1869,1 +1893,1 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: invalid ELF file class)\");\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1, \" (Possible cause: invalid ELF file class)\");\n@@ -1874,3 +1898,3 @@\n-    ::snprintf(diag_msg_buf, diag_msg_max_length-1,\n-               \" (Possible cause: architecture word width mismatch, can't load %d-bit .so on a %d-bit platform)\",\n-               (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);\n+    os::snprintf_checked(diag_msg_buf, diag_msg_max_length-1,\n+                         \" (Possible cause: architecture word width mismatch, can't load %d-bit .so on a %d-bit platform)\",\n+                         (int) lib_arch.elf_class * 32, arch_array[running_arch_index].elf_class * 32);\n@@ -2551,5 +2575,7 @@\n-\n-  st->print(\", physical \" UINT64_FORMAT \"k\",\n-            os::physical_memory() >> 10);\n-  st->print(\"(\" UINT64_FORMAT \"k free)\",\n-            os::available_memory() >> 10);\n+  size_t phys_mem = physical_memory();\n+  st->print(\", physical %zuk\",\n+            phys_mem >> 10);\n+  size_t avail_mem = 0;\n+  (void)os::available_memory(avail_mem);\n+  st->print(\"(%zuk free)\",\n+            avail_mem >> 10);\n@@ -2616,4 +2642,4 @@\n-      snprintf(hbuf_level, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/level\", i);\n-      snprintf(hbuf_type, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/type\", i);\n-      snprintf(hbuf_size, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/size\", i);\n-      snprintf(hbuf_coherency_line_size, 80, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/coherency_line_size\", i);\n+      os::snprintf_checked(hbuf_level, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/level\", i);\n+      os::snprintf_checked(hbuf_type, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/type\", i);\n+      os::snprintf_checked(hbuf_size, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/size\", i);\n+      os::snprintf_checked(hbuf_coherency_line_size, 80, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/coherency_line_size\", i);\n@@ -4220,1 +4246,1 @@\n-  snprintf(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n+  os::snprintf_checked(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n@@ -4800,1 +4826,1 @@\n-    snprintf(buf, sizeof(buf), \"%s\", name);\n+    (void) os::snprintf(buf, sizeof(buf), \"%s\", name);\n@@ -5011,1 +5037,1 @@\n-  snprintf(proc_name, 64, \"\/proc\/self\/task\/%d\/stat\", tid);\n+  os::snprintf_checked(proc_name, 64, \"\/proc\/self\/task\/%d\/stat\", tid);\n@@ -5397,1 +5423,1 @@\n-      snprintf(ebuf, ebuflen - 1, \"%s\", error_report);\n+      os::snprintf_checked(ebuf, ebuflen - 1, \"%s\", error_report);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":85,"deletions":59,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -56,2 +56,2 @@\n-  static julong available_memory();\n-  static julong free_memory();\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n@@ -120,1 +120,1 @@\n-  static julong physical_memory() { return _physical_memory; }\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-  snprintf(buf, sizeof(buf), \"\/sys\/class\/net\/%s\/statistics\/%s\", iface, counter);\n+  os::snprintf_checked(buf, sizeof(buf), \"\/sys\/class\/net\/%s\/statistics\/%s\", iface, counter);\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-  int n = snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-                   os::get_temp_directory(), os::current_process_id());\n+  int n = os::snprintf(path, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -201,1 +201,1 @@\n-    n = snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n+    n = os::snprintf(initial_path, UNIX_PATH_MAX, \"%s.tmp\", path);\n@@ -349,3 +349,2 @@\n-  int n = snprintf(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n-           os::get_temp_directory(), os::current_process_id());\n-  assert(n < (int)UNIX_PATH_MAX, \"java_pid file name buffer overflow\");\n+  os::snprintf_checked(fn, UNIX_PATH_MAX, \"%s\/.java_pid%d\",\n+                       os::get_temp_directory(), os::current_process_id());\n@@ -421,2 +420,2 @@\n-    snprintf(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n-             os::current_process_id());\n+    os::snprintf_checked(fn, sizeof(fn), \"%s\/.attach_pid%d\", os::get_temp_directory(),\n+                         os::current_process_id());\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-    int n = snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n+    int n = os::snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  snprintf(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf_checked(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n@@ -664,1 +664,1 @@\n-  snprintf(name, nbytes, \"%s\/%d\", dirname, pid);\n+  os::snprintf_checked(name, nbytes, \"%s\/%d\", dirname, pid);\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-        if (MetaspaceShared::is_in_shared_metaspace(fault_addr)) {\n+        if (MetaspaceShared::in_aot_cache(fault_addr)) {\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -851,2 +851,2 @@\n-julong os::available_memory() {\n-  return win32::available_memory();\n+bool os::available_memory(size_t& value) {\n+  return win32::available_memory(value);\n@@ -855,2 +855,2 @@\n-julong os::free_memory() {\n-  return win32::available_memory();\n+bool os::free_memory(size_t& value) {\n+  return win32::available_memory(value);\n@@ -859,1 +859,1 @@\n-julong os::win32::available_memory() {\n+bool os::win32::available_memory(size_t& value) {\n@@ -864,3 +864,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-\n-  return (julong)ms.ullAvailPhys;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullAvailPhys);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::win32::available_memory(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -869,1 +874,1 @@\n-jlong os::total_swap_space() {\n+bool os::total_swap_space(size_t& value) {\n@@ -872,2 +877,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-  return (jlong) ms.ullTotalPageFile;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullTotalPageFile);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::total_swap_space(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -876,1 +887,1 @@\n-jlong os::free_swap_space() {\n+bool os::free_swap_space(size_t& value) {\n@@ -879,2 +890,8 @@\n-  GlobalMemoryStatusEx(&ms);\n-  return (jlong) ms.ullAvailPageFile;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res == TRUE) {\n+    value = static_cast<size_t>(ms.ullAvailPageFile);\n+    return true;\n+  } else {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::free_swap_space(): %lu\", ::GetLastError());\n+    return false;\n+  }\n@@ -883,1 +900,1 @@\n-julong os::physical_memory() {\n+size_t os::physical_memory() {\n@@ -1414,1 +1431,1 @@\n-    snprintf(name, MAX_PATH, \"<not available>\");\n+    os::snprintf_checked(name, MAX_PATH, \"<not available>\");\n@@ -1430,1 +1447,1 @@\n-      os::snprintf(buf, sizeof(buf), \"Attempt to unload dll failed (error code %d)\", (int) errcode);\n+      os::snprintf_checked(buf, sizeof(buf), \"Attempt to unload dll failed (error code %d)\", (int) errcode);\n@@ -1827,3 +1844,3 @@\n-    os::snprintf(ebuf, ebuflen - 1,\n-                 \"Can't load %s-bit .dll on a %s-bit platform\",\n-                 lib_arch_str, running_arch_str);\n+    os::snprintf_checked(ebuf, ebuflen - 1,\n+                         \"Can't load %s-bit .dll on a %s-bit platform\",\n+                         lib_arch_str, running_arch_str);\n@@ -1832,3 +1849,3 @@\n-    os::snprintf(ebuf, ebuflen - 1,\n-                 \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n-                 lib_arch, running_arch_str);\n+    os::snprintf_checked(ebuf, ebuflen - 1,\n+                         \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n+                         lib_arch, running_arch_str);\n@@ -3201,1 +3218,1 @@\n-  int n = snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n+  int n = os::snprintf(fullname, fullname_len + 1, \"%s%s\", dir, name_template);\n@@ -3951,1 +3968,1 @@\n-julong os::win32::_physical_memory           = 0;\n+size_t os::win32::_physical_memory           = 0;\n@@ -4181,2 +4198,5 @@\n-  GlobalMemoryStatusEx(&ms);\n-  _physical_memory = ms.ullTotalPhys;\n+  BOOL res = GlobalMemoryStatusEx(&ms);\n+  if (res != TRUE) {\n+    assert(false, \"GlobalMemoryStatusEx failed in os::win32::initialize_system_info(): %lu\", ::GetLastError());\n+  }\n+  _physical_memory = static_cast<size_t>(ms.ullTotalPhys);\n@@ -4683,2 +4703,2 @@\n-      errno = ::GetLastError();\n-      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%ld.\", errno);\n+      DWORD errcode = ::GetLastError();\n+      log_debug(os)(\"is_symbolic_link() failed to FindClose: GetLastError->%lu.\", errcode);\n@@ -4688,2 +4708,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"is_symbolic_link() failed to FindFirstFileW: GetLastError->%lu.\", errcode);\n@@ -4699,2 +4719,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CreateFileW: GetLastError->%lu.\", errcode);\n@@ -4708,2 +4728,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%lu.\", errcode);\n@@ -4719,2 +4739,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to GetFinalPathNameByHandleW: GetLastError->%lu.\", errcode);\n@@ -4725,2 +4745,2 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"get_path_to_target() failed to CloseHandle: GetLastError->%lu.\", errcode);\n@@ -4807,3 +4827,2 @@\n-      \/\/ it is a symbolic link, but we failed to resolve it,\n-      \/\/ errno has been set in the call to get_path_to_target(),\n-      \/\/ no need to overwrite it\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = ENOENT;\n@@ -4820,2 +4839,7 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%ld.\", errno);\n+    DWORD errcode = ::GetLastError();\n+    if (errcode == ERROR_FILE_NOT_FOUND || errcode == ERROR_PATH_NOT_FOUND) {\n+      errno = ENOENT;\n+    } else {\n+      errno = 0;\n+    }\n+    log_debug(os)(\"os::stat() failed to GetFileAttributesExW: GetLastError->%lu.\", errcode);\n@@ -5021,3 +5045,2 @@\n-      \/\/ it is a symbolic link, but we failed to resolve it,\n-      \/\/ errno has been set in the call to get_path_to_target(),\n-      \/\/ no need to overwrite it\n+      \/\/ it is a symbolic link, but we failed to resolve it\n+      errno = ENOENT;\n@@ -5031,1 +5054,1 @@\n-  \/\/ if opening files failed, GetLastError should be called immediately after that\n+  \/\/ if opening files failed, errno has been set to indicate the problem\n@@ -5033,2 +5056,1 @@\n-    errno = ::GetLastError();\n-    log_debug(os)(\"os::open() failed to _wopen: GetLastError->%ld.\", errno);\n+    log_debug(os)(\"os::open() failed to _wopen: errno->%s.\", strerror(errno));\n@@ -5102,1 +5124,2 @@\n-    errno = ::GetLastError();\n+    DWORD errcode = ::GetLastError();\n+    log_debug(os)(\"os::dir_is_empty() failed to FindFirstFileW: GetLastError->%lu.\", errcode);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":74,"deletions":51,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  static julong _physical_memory;\n+  static size_t _physical_memory;\n@@ -105,3 +105,3 @@\n-  static julong available_memory();\n-  static julong free_memory();\n-  static julong physical_memory() { return _physical_memory; }\n+  static bool available_memory(size_t& value);\n+  static bool free_memory(size_t& value);\n+  static size_t physical_memory() { return _physical_memory; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  os::snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf_checked(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n@@ -457,1 +457,1 @@\n-  os::snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n+  os::snprintf_checked(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n@@ -473,1 +473,1 @@\n-  os::snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+  os::snprintf_checked(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        if (MetaspaceShared::is_in_shared_metaspace(fault_addr)) {\n+        if (MetaspaceShared::in_aot_cache(fault_addr)) {\n","filename":"src\/hotspot\/os\/windows\/vmError_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    snprintf(buf, sizeof(buf)\/2, \"%s \", uarch);\n+    os::snprintf_checked(buf, sizeof(buf)\/2, \"%s \", uarch);\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/asm\/assembler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"utilities\/resizableHashTable.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"utilities\/resizableHashTable.hpp\"\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/macros.hpp\"\n","filename":"src\/hotspot\/share\/asm\/macroAssembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jvm.h\"\n@@ -29,0 +28,1 @@\n+#include \"jvm.h\"\n@@ -30,1 +30,0 @@\n-#include \"runtime\/signature_cc.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n","filename":"src\/hotspot\/share\/asm\/macroAssembler_common.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-      InstanceKlass* s = ik->java_super();\n+      InstanceKlass* s = ik->super();\n@@ -227,1 +227,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared()) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && ik->in_aot_cache()) {\n@@ -239,1 +239,1 @@\n-    InstanceKlass* s = ik->java_super();\n+    InstanceKlass* s = ik->super();\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    InstanceKlass* super = ik->java_super();\n+    InstanceKlass* super = ik->super();\n@@ -154,1 +154,1 @@\n-  InstanceKlass* s = ik->java_super();\n+  InstanceKlass* s = ik->super();\n@@ -215,1 +215,1 @@\n-    if (ik->is_shared() && CDSConfig::is_dumping_dynamic_archive()) {\n+    if (ik->in_aot_cache() && CDSConfig::is_dumping_dynamic_archive()) {\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -244,6 +244,0 @@\n-#ifdef _WINDOWS\n-  } else if (errno == ERROR_FILE_NOT_FOUND || errno == ERROR_PATH_NOT_FOUND) {\n-    \/\/ On Windows, the errno could be ERROR_PATH_NOT_FOUND (3) in case the directory\n-    \/\/ path doesn't exist.\n-    type = FileType::NOT_EXIST;\n-#endif\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-    if (!ik->is_shared() && SystemDictionaryShared::is_excluded_class(ik)) {\n+    if (!ik->in_aot_cache() && SystemDictionaryShared::is_excluded_class(ik)) {\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-      assert(ik->java_super()->is_loaded(), \"must be\");\n+      assert(ik->super()->is_loaded(), \"must be\");\n@@ -438,1 +438,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -368,2 +368,2 @@\n-    _mapped_static_archive_bottom = (address)MetaspaceObj::shared_metaspace_base();\n-    _mapped_static_archive_top  = (address)MetaspaceObj::shared_metaspace_top();\n+    _mapped_static_archive_bottom = (address)MetaspaceObj::aot_metaspace_base();\n+    _mapped_static_archive_top  = (address)MetaspaceObj::aot_metaspace_top();\n@@ -543,1 +543,1 @@\n-    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_shared_static(bottom)) {\n+    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::in_aot_cache_static_region(bottom)) {\n@@ -556,1 +556,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(obj)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::in_aot_cache(obj)) {\n@@ -566,6 +566,1 @@\n-    if (CDSConfig::is_dumping_adapters()) {\n-      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)ref->obj();\n-      return AdapterHandlerLibrary::is_abstract_method_adapter(entry) ? set_to_null : make_a_copy;\n-    } else {\n-      return set_to_null;\n-    }\n+    return CDSConfig::is_dumping_adapters() ? make_a_copy : set_to_null;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-  \/\/ the range of the mapped CDS archive (e.g., Metaspace::is_in_shared_metaspace()).\n+  \/\/ the range of the mapped CDS archive (e.g., Metaspace::in_aot_cache()).\n@@ -290,1 +290,1 @@\n-    assert(Metaspace::is_in_shared_metaspace(p), \"must be\");\n+    assert(Metaspace::in_aot_cache(p), \"must be\");\n@@ -306,1 +306,1 @@\n-    assert(Metaspace::is_in_shared_metaspace(p), \"must be\");\n+    assert(Metaspace::in_aot_cache(p), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        if (is_dynamic_dump && MetaspaceShared::is_in_shared_metaspace(ptr)) {\n+        if (is_dynamic_dump && MetaspaceShared::in_aot_cache(ptr)) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  if (CDSConfig::is_using_full_module_graph() && ik->is_shared() && pkg_entry != nullptr) {\n-    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n+  if (CDSConfig::is_using_full_module_graph() && ik->in_aot_cache() && pkg_entry != nullptr) {\n+    assert(MetaspaceShared::in_aot_cache(pkg_entry), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-  if (k->java_super() != specified_super) {\n+  if (k->super() != specified_super) {\n@@ -567,1 +567,1 @@\n-          k->java_super()->external_name());\n+          k->super()->external_name());\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    if (!k->is_shared()) {\n+    if (!k->in_aot_cache()) {\n@@ -142,1 +142,1 @@\n-    InstanceKlass* super = k->java_super();\n+    InstanceKlass* super = k->super();\n@@ -168,1 +168,1 @@\n-    InstanceKlass* super = k->java_super();\n+    InstanceKlass* super = k->super();\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  assert(MetaspaceShared::is_in_shared_metaspace(m), \"must be\");\n+  assert(MetaspaceShared::in_aot_cache(m), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  assert(CDSConfig::is_dumping_final_static_archive() || !k->is_shared(), \"Do not call with shared classes\");\n+  assert(CDSConfig::is_dumping_final_static_archive() || !k->in_aot_cache(), \"Do not call with shared classes\");\n@@ -154,1 +154,1 @@\n-  assert(CDSConfig::is_dumping_final_static_archive() || !k->is_shared(), \"Do not call with shared classes\");\n+  assert(CDSConfig::is_dumping_final_static_archive() || !k->in_aot_cache(), \"Do not call with shared classes\");\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-      assert(MetaspaceShared::is_shared_static((void*)k),\n+      assert(MetaspaceShared::in_aot_cache_static_region((void*)k),\n@@ -193,1 +193,1 @@\n-      while (ak != nullptr && ak->is_shared()) {\n+      while (ak != nullptr && ak->in_aot_cache()) {\n@@ -256,1 +256,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(ik)) {\n+  if (MetaspaceShared::in_aot_cache(ik)) {\n@@ -279,1 +279,1 @@\n-  sort_methods(ik->java_super());\n+  sort_methods(ik->super());\n@@ -290,1 +290,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache(name) || is_in_buffer_space(name), \"must be\");\n@@ -296,1 +296,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache(name) || is_in_buffer_space(name), \"must be\");\n@@ -373,1 +373,1 @@\n-      if (MetaspaceShared::is_shared_static(elem)) {\n+      if (MetaspaceShared::in_aot_cache_static_region(elem)) {\n@@ -380,1 +380,1 @@\n-        assert(!MetaspaceShared::is_shared_static(oak),\n+        assert(!MetaspaceShared::in_aot_cache_static_region(oak),\n@@ -441,1 +441,1 @@\n-      assert(MetaspaceShared::is_shared_static((void*)elm), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache_static_region((void*)elm), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1220,1 +1220,1 @@\n-        \/\/ regions, or else it would mess up the simple comparison in MetaspaceObj::is_shared().\n+        \/\/ regions, or else it would mess up the simple comparison in MetaspaceObj::in_aot_cache().\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    klass = klass->java_super();\n+    klass = klass->super();\n@@ -1224,1 +1224,1 @@\n-  if (!k->is_shared()) {\n+  if (!k->in_aot_cache()) {\n@@ -1278,1 +1278,1 @@\n-        if (!klass->is_shared()) {\n+        if (!klass->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-      if (!klass->is_shared() && klass->shared_classpath_index() < 0) {\n+      if (!klass->in_aot_cache() && klass->shared_classpath_index() < 0) {\n@@ -226,1 +226,1 @@\n-  if (!klass->is_shared()) {\n+  if (!klass->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -250,6 +250,6 @@\n-  if (!caller_ik->is_shared()     ||\n-      !invoked_name->is_shared()  ||\n-      !invoked_type->is_shared()  ||\n-      !method_type->is_shared()   ||\n-      (member_method != nullptr && !member_method->is_shared()) ||\n-      !instantiated_method_type->is_shared()) {\n+  if (!caller_ik->in_aot_cache()     ||\n+      !invoked_name->in_aot_cache()  ||\n+      !invoked_type->in_aot_cache()  ||\n+      !method_type->in_aot_cache()   ||\n+      (member_method != nullptr && !member_method->in_aot_cache()) ||\n+      !instantiated_method_type->in_aot_cache()) {\n@@ -328,1 +328,1 @@\n-  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n+  assert(shared_nest_host->in_aot_cache(), \"nest host must be in aot metaspace\");\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-void* MetaspaceShared::_shared_metaspace_static_top = nullptr;\n+void* MetaspaceShared::_aot_metaspace_static_top = nullptr;\n@@ -196,2 +196,2 @@\n-    if (ik->java_super()) {\n-      dump(ik->java_super());\n+    if (ik->super()) {\n+      dump(ik->super());\n@@ -1213,1 +1213,1 @@\n-  if (ik->is_shared() && !CDSConfig::is_dumping_final_static_archive()) {\n+  if (ik->in_aot_cache() && !CDSConfig::is_dumping_final_static_archive()) {\n@@ -1262,1 +1262,1 @@\n-void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {\n+void MetaspaceShared::set_aot_metaspace_range(void* base, void *static_top, void* top) {\n@@ -1264,2 +1264,2 @@\n-  _shared_metaspace_static_top = static_top;\n-  MetaspaceObj::set_shared_metaspace_range(base, top);\n+  _aot_metaspace_static_top = static_top;\n+  MetaspaceObj::set_aot_metaspace_range(base, top);\n@@ -1268,3 +1268,3 @@\n-bool MetaspaceShared::is_shared_dynamic(void* p) {\n-  if ((p < MetaspaceObj::shared_metaspace_top()) &&\n-      (p >= _shared_metaspace_static_top)) {\n+bool MetaspaceShared::in_aot_cache_dynamic_region(void* p) {\n+  if ((p < MetaspaceObj::aot_metaspace_top()) &&\n+      (p >= _aot_metaspace_static_top)) {\n@@ -1277,2 +1277,2 @@\n-bool MetaspaceShared::is_shared_static(void* p) {\n-  if (is_in_shared_metaspace(p) && !is_shared_dynamic(p)) {\n+bool MetaspaceShared::in_aot_cache_static_region(void* p) {\n+  if (in_aot_cache(p) && !in_aot_cache_dynamic_region(p)) {\n@@ -1378,1 +1378,1 @@\n-    set_shared_metaspace_range(cds_base, static_mapinfo->mapped_end(), cds_end);\n+    set_aot_metaspace_range(cds_base, static_mapinfo->mapped_end(), cds_end);\n@@ -1386,1 +1386,1 @@\n-    set_shared_metaspace_range(nullptr, nullptr, nullptr);\n+    set_aot_metaspace_range(nullptr, nullptr, nullptr);\n@@ -1476,1 +1476,1 @@\n-    \/\/ archives, or else it would mess up the simple comparison in MetaspaceObj::is_shared().\n+    \/\/ archives, or else it would mess up the simple comparison in MetaspaceObj::in_aot_cache().\n@@ -2085,3 +2085,3 @@\n-    address base = (address)MetaspaceObj::shared_metaspace_base();\n-    address static_top = (address)_shared_metaspace_static_top;\n-    address top = (address)MetaspaceObj::shared_metaspace_top();\n+    address base = (address)MetaspaceObj::aot_metaspace_base();\n+    address static_top = (address)_aot_metaspace_static_top;\n+    address top = (address)MetaspaceObj::aot_metaspace_top();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  static void* _shared_metaspace_static_top;\n+  static void* _aot_metaspace_static_top;\n@@ -104,2 +104,2 @@\n-  static bool is_in_shared_metaspace(const void* p) {\n-    return MetaspaceObj::is_shared((const MetaspaceObj*)p);\n+  static bool in_aot_cache(const void* p) {\n+    return MetaspaceObj::in_aot_cache((const MetaspaceObj*)p);\n@@ -108,1 +108,1 @@\n-  static void set_shared_metaspace_range(void* base, void *static_top, void* top) NOT_CDS_RETURN;\n+  static void set_aot_metaspace_range(void* base, void *static_top, void* top) NOT_CDS_RETURN;\n@@ -110,2 +110,5 @@\n-  static bool is_shared_dynamic(void* p) NOT_CDS_RETURN_(false);\n-  static bool is_shared_static(void* p) NOT_CDS_RETURN_(false);\n+  \/\/ inside the metaspace of the AOT cache, or the static CDS archive\n+  static bool in_aot_cache_static_region(void* p) NOT_CDS_RETURN_(false);\n+\n+  \/\/ inside the metaspace of the dynamic static CDS archive\n+  static bool in_aot_cache_dynamic_region(void* p) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(this)) {\n+  if (MetaspaceShared::in_aot_cache(this)) {\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-    assert(klass->is_shared(), \"don't call for non-shared class\");\n+    assert(klass->in_aot_cache(), \"don't call for non-shared class\");\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    os::vsnprintf(e, m - e, fmt, args);\n+    (void) os::vsnprintf(e, m - e, fmt, args);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1683,1 +1683,1 @@\n-      ik = ik->java_super();\n+      ik = ik->super();\n@@ -1702,1 +1702,1 @@\n-    ik = ik->java_super();\n+    ik = ik->super();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4117,1 +4117,1 @@\n-  const InstanceKlass* const super = ik->java_super();\n+  const InstanceKlass* const super = ik->super();\n@@ -4260,1 +4260,1 @@\n-  const Klass* const super = this_klass->super();\n+  const InstanceKlass* const super = this_klass->super();\n@@ -4263,2 +4263,0 @@\n-    const InstanceKlass* super_ik = InstanceKlass::cast(super);\n-\n@@ -4266,1 +4264,1 @@\n-      classfile_icce_error(\"class %s cannot inherit from final class %s\", super_ik, THREAD);\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", super, THREAD);\n@@ -4270,1 +4268,1 @@\n-    if (super_ik->is_sealed()) {\n+    if (super->is_sealed()) {\n@@ -4273,1 +4271,1 @@\n-      if (!super_ik->has_as_permitted_subclass(this_klass, ss)) {\n+      if (!super->has_as_permitted_subclass(this_klass, ss)) {\n@@ -4283,3 +4281,3 @@\n-        super_ik->name() != vmSymbols::java_lang_Object() &&\n-        super_ik->is_identity_class()) {\n-      classfile_icce_error(\"value class %s cannot inherit from class %s\", super_ik, THREAD);\n+        super->name() != vmSymbols::java_lang_Object() &&\n+        super->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super, THREAD);\n@@ -4290,1 +4288,1 @@\n-      Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);\n+      Reflection::verify_class_access(this_klass, super, false);\n@@ -4294,1 +4292,1 @@\n-                                                      InstanceKlass::cast(super),\n+                                                      super,\n@@ -4390,1 +4388,1 @@\n-      const InstanceKlass* k = this_klass->java_super();\n+      const InstanceKlass* k = this_klass->super();\n@@ -4396,1 +4394,1 @@\n-          super_m = InstanceKlass::cast(k)->lookup_method(name, signature);\n+          super_m = k->lookup_method(name, signature);\n@@ -4422,1 +4420,1 @@\n-          k = super_m->method_holder()->java_super();\n+          k = super_m->method_holder()->super();\n@@ -4426,1 +4424,1 @@\n-        k = k->java_super();\n+        k = k->super();\n@@ -5566,1 +5564,1 @@\n-      if (ik->java_super() != nullptr) {\n+      if (ik->super() != nullptr) {\n@@ -5569,1 +5567,1 @@\n-                   ik->java_super()->external_name());\n+                   ik->super()->external_name());\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -419,1 +419,1 @@\n-    } else if (k->is_shared() && k->is_objArray_klass()) {\n+    } else if (k->in_aot_cache() && k->is_objArray_klass()) {\n@@ -884,1 +884,1 @@\n-  if (!m->is_shared()) {\n+  if (!m->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    InstanceKlass* next_super() { return _class->java_super(); }\n+    InstanceKlass* next_super() { return _class->super(); }\n@@ -639,1 +639,1 @@\n-  InstanceKlass* super = klass->java_super();\n+  InstanceKlass* super = klass->super();\n@@ -671,1 +671,1 @@\n-    super = super->java_super();\n+    super = super->super();\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-    ik = ik->super() == nullptr ? nullptr : InstanceKlass::cast(ik->super());\n+    ik = ik->super() == nullptr ? nullptr : ik->super();\n@@ -698,1 +698,1 @@\n-        ik = ik->java_super();\n+        ik = ik->super();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -944,1 +944,1 @@\n-  if (!k->is_shared()) {\n+  if (!k->in_aot_cache()) {\n@@ -982,1 +982,1 @@\n-  if (k->is_shared() && k->has_archived_mirror_index()) {\n+  if (k->in_aot_cache() && k->has_archived_mirror_index()) {\n@@ -2650,2 +2650,2 @@\n-  size_t buf_off = os::snprintf_checked(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n-\n+  int buf_off = os::snprintf(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n+  assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2655,1 +2655,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2657,1 +2658,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2672,1 +2674,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2675,1 +2678,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2678,1 +2682,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  assert(ik->is_shared(), \"expecting a shared class\");\n+  assert(ik->in_aot_cache(), \"expecting a shared class\");\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-      InstanceKlass* superk = klassk->java_super();\n+      InstanceKlass* superk = klassk->super();\n@@ -1044,1 +1044,1 @@\n-  assert(super_type->is_shared(), \"must be\");\n+  assert(super_type->in_aot_cache(), \"must be\");\n@@ -1079,1 +1079,1 @@\n-    bool check_super = check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n+    bool check_super = check_shared_class_super_type(ik, ik->super(),\n@@ -1176,1 +1176,1 @@\n-  assert(ik->is_shared(), \"sanity\");\n+  assert(ik->in_aot_cache(), \"sanity\");\n@@ -1866,1 +1866,1 @@\n-        !klass_being_linked->is_shared()) {\n+        !klass_being_linked->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(k)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::in_aot_cache(k)) {\n@@ -241,1 +241,1 @@\n-    k = k->java_super();\n+    k = k->super();\n@@ -253,1 +253,1 @@\n-      && k->is_shared()) {\n+      && k->in_aot_cache()) {\n@@ -332,1 +332,1 @@\n-  InstanceKlass* super = k->java_super();\n+  InstanceKlass* super = k->super();\n@@ -486,1 +486,1 @@\n-  precond(klass->is_shared());\n+  precond(klass->in_aot_cache());\n@@ -574,1 +574,1 @@\n-  if (k->java_super() != nullptr && has_been_redefined(k->java_super())) {\n+  if (k->super() != nullptr && has_been_redefined(k->super())) {\n@@ -668,1 +668,1 @@\n-    if (CDSConfig::is_dumping_dynamic_archive() && ik->is_shared()) {\n+    if (CDSConfig::is_dumping_dynamic_archive() && ik->in_aot_cache()) {\n@@ -1021,1 +1021,1 @@\n-        if (MetaspaceObj::is_shared((const MetaspaceObj*)ptr)) {\n+        if (MetaspaceObj::in_aot_cache((const MetaspaceObj*)ptr)) {\n@@ -1109,1 +1109,1 @@\n-  if (!CDSConfig::is_using_archive() || !name->is_shared()) {\n+  if (!CDSConfig::is_using_archive() || !name->in_aot_cache()) {\n@@ -1127,1 +1127,1 @@\n-  if (!MetaspaceShared::is_shared_dynamic(name)) {\n+  if (!MetaspaceShared::in_aot_cache_dynamic_region(name)) {\n@@ -1166,1 +1166,1 @@\n-  assert(k->is_shared(), \"Must be\");\n+  assert(k->in_aot_cache(), \"Must be\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-      if (_klass->is_shared()) {\n+      if (_klass->in_aot_cache()) {\n@@ -300,1 +300,1 @@\n-    assert(MetaspaceObj::is_shared((const MetaspaceObj*)ptr), \"must be\");\n+    assert(MetaspaceObj::in_aot_cache((const MetaspaceObj*)ptr), \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    !(klass->is_shared() && klass->is_rewritten()));\n+    !(klass->in_aot_cache() && klass->is_rewritten()));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    assert(Object_klass()->is_shared(), \"must be\");\n+    assert(Object_klass()->in_aot_cache(), \"must be\");\n@@ -207,1 +207,1 @@\n-      assert(k->is_shared(), \"must not be replaced by JVMTI class file load hook\");\n+      assert(k->in_aot_cache(), \"must not be replaced by JVMTI class file load hook\");\n@@ -222,1 +222,1 @@\n-  assert(klass->is_shared(), \"Must be shared class\");\n+  assert(klass->in_aot_cache(), \"Must be shared class\");\n@@ -228,1 +228,1 @@\n-  Klass* super = klass->super();\n+  InstanceKlass* super = klass->super();\n@@ -231,1 +231,1 @@\n-    resolve_shared_class(InstanceKlass::cast(super), loader_data, domain, CHECK);\n+    resolve_shared_class(super, loader_data, domain, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  _mutable_data(nullptr),\n+  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n@@ -163,0 +163,3 @@\n+  } else {\n+    \/\/ We need unique and valid not null address\n+    assert(_mutable_data == blob_end(), \"sanity\");\n@@ -164,1 +167,0 @@\n-  assert(_mutable_data != nullptr || _mutable_data_size == 0, \"No mutable data => mutable data size is 0\");\n@@ -173,1 +175,1 @@\n-  _mutable_data(nullptr),\n+  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n@@ -187,1 +189,0 @@\n-  assert(_mutable_data == nullptr && _mutable_data_size == 0, \"invariant\");\n@@ -190,0 +191,1 @@\n+  assert(_mutable_data == blob_end(), \"sanity\");\n@@ -200,1 +202,1 @@\n-    _mutable_data = nullptr;\n+    _mutable_data = blob_end(); \/\/ default value\n@@ -209,7 +211,11 @@\n-  os::free(_mutable_data);\n-  _mutable_data = nullptr;\n-  _mutable_data_size = 0;\n-  delete _oop_maps;\n-  _oop_maps = nullptr;\n-  _relocation_size = 0;\n-\n+  assert(_mutable_data != nullptr, \"should never be null\");\n+  if (_mutable_data != blob_end()) {\n+    os::free(_mutable_data);\n+    _mutable_data = blob_end(); \/\/ Valid not null address\n+    _mutable_data_size = 0;\n+    _relocation_size = 0;\n+  }\n+  if (_oop_maps != nullptr) {\n+    delete _oop_maps;\n+    _oop_maps = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -742,1 +742,1 @@\n-              os::snprintf(new_blob_name, size, \"%s jvmci_name=%s\", blob_name, jvmci_name);\n+              os::snprintf_checked(new_blob_name, size, \"%s jvmci_name=%s\", blob_name, jvmci_name);\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1345,2 +1345,2 @@\n-    \/\/ native wrapper does not have read-only data\n-    _immutable_data          = nullptr;\n+    \/\/ native wrapper does not have read-only data but we need unique not null address\n+    _immutable_data          = blob_end();\n@@ -1532,1 +1532,2 @@\n-      _immutable_data     = nullptr;\n+      \/\/ We need unique not null address\n+      _immutable_data     = blob_end();\n@@ -2168,2 +2169,3 @@\n-\n-  delete _pc_desc_container;\n+  if (_pc_desc_container != nullptr) {\n+    delete _pc_desc_container;\n+  }\n@@ -2172,4 +2174,4 @@\n-  os::free(_immutable_data);\n-  _immutable_data = nullptr;\n-  _immutable_data_size = 0;\n-\n+  if (_immutable_data != blob_end()) {\n+    os::free(_immutable_data);\n+    _immutable_data = blob_end(); \/\/ Valid not null address\n+  }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+\/\/ A static dummy to serve as a safe pointer when there is no relocation info.\n+static relocInfo dummy_relocInfo = relocInfo(relocInfo::none, 0);\n+\n@@ -130,3 +133,8 @@\n-  _base = nm->relocation_begin();\n-  _current = -1;\n-  _len = nm->relocation_end() - _base;\n+  if (nm->relocation_size() == 0) {\n+    _current = &dummy_relocInfo - 1;\n+    _end = &dummy_relocInfo;\n+  } else {\n+    assert(((nm->relocation_begin() != nullptr) && (nm->relocation_end() != nullptr)), \"valid start and end pointer\");\n+    _current = nm->relocation_begin() - 1;\n+    _end     = nm->relocation_end();\n+  }\n@@ -151,9 +159,0 @@\n-RelocIterator::RelocIterator(relocInfo& ri) {\n-  initialize_misc();\n-  _base = &ri;\n-  _len = 1;\n-  _current = -1;\n-  _limit = nullptr;\n-  _addr = 0;\n-}\n-\n@@ -163,3 +162,2 @@\n-  _base = cs->locs_start();\n-  _len = cs->locs_end() - _base;\n-  _current = -1;\n+  _current = cs->locs_start() - 1;\n+  _end     = cs->locs_end();\n@@ -191,3 +189,2 @@\n-  _base = cb->relocation_begin();\n-  _len = cb->relocation_end() - _base;\n-  _current = -1;\n+  _current = cb->relocation_begin() - 1;\n+  _end     = cb->relocation_end();\n@@ -222,1 +219,1 @@\n-    int backup;\n+    relocInfo* backup;\n@@ -244,3 +241,3 @@\n-  if (current()->is_datalen()) {\n-    _data    = (short*) current()->data();\n-    _datalen =          current()->datalen();\n+  if (_current->is_datalen()) {\n+    _data    = (short*) _current->data();\n+    _datalen =          _current->datalen();\n@@ -249,1 +246,1 @@\n-    _databuf = current()->immediate();\n+    _databuf = _current->immediate();\n@@ -356,3 +353,3 @@\n-  relocInfo ri(rtype, 0);\n-  RelocIterator itr(ri);\n-  itr.next();\n+  relocInfo ri = relocInfo(rtype, 0);\n+  RelocIterator itr;\n+  itr.set_current(ri);\n@@ -845,1 +842,1 @@\n-            p2i(current()), type(), relocInfo::type_name((relocInfo::relocType) type()), p2i(_addr), current()->addr_offset());\n+             p2i(_current), type(), relocInfo::type_name((relocInfo::relocType) type()), p2i(_addr), _current->addr_offset());\n@@ -996,1 +993,1 @@\n-  relocInfo* scan = current_no_check();\n+  relocInfo* scan = _current;\n@@ -1006,1 +1003,1 @@\n-    relocInfo* newscan = current_no_check()+1;\n+    relocInfo* newscan = _current+1;\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":26,"deletions":29,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -565,3 +565,2 @@\n-  relocInfo*      _base;    \/\/ base pointer into relocInfo array\n-  int             _current; \/\/ current index\n-  int             _len;     \/\/ length\n+  relocInfo*      _current; \/\/ the current relocation information\n+  relocInfo*      _end;     \/\/ end marker; we're done iterating when _current == _end\n@@ -570,1 +569,0 @@\n-  short*          _data;    \/\/ pointer to the relocation's data\n@@ -572,0 +570,1 @@\n+  short*          _data;    \/\/ pointer to the relocation's data\n@@ -582,0 +581,4 @@\n+  void set_current(relocInfo& ri) {\n+    _current = &ri;\n+    set_has_current(true);\n+  }\n@@ -585,5 +588,2 @@\n-  relocInfo* current_no_check() const { return &_base[_current]; }\n-  relocInfo* current() const {\n-    assert(has_current(), \"must have current\");\n-    return current_no_check();\n-  }\n+  relocInfo* current() const { assert(has_current(), \"must have current\");\n+                               return _current; }\n@@ -600,1 +600,0 @@\n-  RelocIterator(relocInfo& ri);\n@@ -611,2 +610,2 @@\n-    assert(_current <= _len, \"must not overrun relocInfo\");\n-    if (_current == _len) {\n+    assert(_current <= _end, \"must not overrun relocInfo\");\n+    if (_current == _end) {\n@@ -618,1 +617,1 @@\n-    if (current()->is_prefix()) {\n+    if (_current->is_prefix()) {\n@@ -623,1 +622,1 @@\n-    _addr += current()->addr_offset();\n+    _addr += _current->addr_offset();\n@@ -629,0 +628,1 @@\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-      os::snprintf(tmp, sizeof(tmp), \"%9zu (%+zd)\", e._bytes.cur, e._bytes.end_delta());\n+      os::snprintf_checked(tmp, sizeof(tmp), \"%9zu (%+zd)\", e._bytes.cur, e._bytes.end_delta());\n@@ -164,1 +164,1 @@\n-      os::snprintf(tmp, sizeof(tmp), \"%6u (%+d)\", e._live_nodes.cur, e._live_nodes.end_delta());\n+      os::snprintf_checked(tmp, sizeof(tmp), \"%6u (%+d)\", e._live_nodes.cur, e._live_nodes.end_delta());\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-void CompilationPolicy::replay_training_at_init_impl(InstanceKlass* klass, TRAPS) {\n+void CompilationPolicy::replay_training_at_init_impl(InstanceKlass* klass, JavaThread* current) {\n@@ -153,1 +153,1 @@\n-          if (ctd->init_deps_left() == 0) {\n+          if (ctd->init_deps_left_acquire() == 0) {\n@@ -156,2 +156,2 @@\n-              const methodHandle mh(THREAD, const_cast<Method*>(mtd->holder()));\n-              CompilationPolicy::maybe_compile_early(mh, THREAD);\n+              const methodHandle mh(current, const_cast<Method*>(mtd->holder()));\n+              CompilationPolicy::maybe_compile_early(mh, current);\n@@ -166,1 +166,1 @@\n-void CompilationPolicy::replay_training_at_init(InstanceKlass* klass, TRAPS) {\n+void CompilationPolicy::replay_training_at_init(InstanceKlass* klass, JavaThread* current) {\n@@ -168,2 +168,2 @@\n-  if (TrainingData::have_data() && klass->is_shared()) {\n-    _training_replay_queue.push(klass, TrainingReplayQueue_lock, THREAD);\n+  if (TrainingData::have_data() && klass->in_aot_cache()) {\n+    _training_replay_queue.push(klass, TrainingReplayQueue_lock, current);\n@@ -184,1 +184,1 @@\n-void CompilationPolicy::replay_training_at_init_loop(TRAPS) {\n+void CompilationPolicy::replay_training_at_init_loop(JavaThread* current) {\n@@ -186,1 +186,1 @@\n-    InstanceKlass* ik = _training_replay_queue.pop(TrainingReplayQueue_lock, THREAD);\n+    InstanceKlass* ik = _training_replay_queue.pop(TrainingReplayQueue_lock, current);\n@@ -188,1 +188,1 @@\n-      replay_training_at_init_impl(ik, THREAD);\n+      replay_training_at_init_impl(ik, current);\n@@ -449,1 +449,1 @@\n-      st->print(\"%d\", ctd->init_deps_left());\n+      st->print(\"%d\", ctd->init_deps_left_acquire());\n@@ -1175,1 +1175,1 @@\n-  if (SkipTier2IfPossible && ctd->init_deps_left() == 0) {\n+  if (SkipTier2IfPossible && ctd->init_deps_left_acquire() == 0) {\n@@ -1203,1 +1203,1 @@\n-  if (ctd != nullptr && ctd->init_deps_left() == 0) {\n+  if (ctd != nullptr && ctd->init_deps_left_acquire() == 0) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  void push(T* value, Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n+  void push(T* value, Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n@@ -85,3 +85,3 @@\n-  T* pop(Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n-    while(is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n+  T* pop(Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n+    while (is_empty_unlocked() && !CompileBroker::is_compilation_disabled_forever()) {\n@@ -94,6 +94,3 @@\n-  T* try_pop(Monitor* lock, TRAPS) {\n-    MonitorLocker locker(THREAD, lock);\n-    T* value = nullptr;\n-    if (!is_empty_unlocked()) {\n-      value = pop_unlocked();\n-    }\n+  T* try_pop(Monitor* lock, JavaThread* current) {\n+    MonitorLocker locker(current, lock);\n+    T* value = pop_unlocked();\n@@ -102,1 +99,0 @@\n-\n@@ -345,1 +341,1 @@\n-  static void replay_training_at_init_impl(InstanceKlass* klass, TRAPS);\n+  static void replay_training_at_init_impl(InstanceKlass* klass, JavaThread* current);\n@@ -355,2 +351,2 @@\n-  static void replay_training_at_init(InstanceKlass* klass, TRAPS);\n-  static void replay_training_at_init_loop(TRAPS);\n+  static void replay_training_at_init(InstanceKlass* klass, JavaThread* current);\n+  static void replay_training_at_init_loop(JavaThread* current);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1064,1 +1064,3 @@\n-  julong free_memory = os::free_memory();\n+  size_t free_memory = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::free_memory(free_memory);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,0 +624,5 @@\n+  if (UseAutoVectorizationSpeculativeAliasingChecks && !LoopMultiversioning && !UseAutoVectorizationPredicate) {\n+    warning(\"Disabling UseAutoVectorizationSpeculativeAliasingChecks, because neither of the following is enabled:\"\n+            \"  LoopMultiversioning UseAutoVectorizationPredicate\");\n+    UseAutoVectorizationSpeculativeAliasingChecks = false;\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+  assert(short_interval_ms != 0.0, \"short_interval_ms should not be zero, calculated from %f and %f\", end_time_sec,  most_recent_gc_end_time_sec());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -786,1 +786,1 @@\n-    assert(!r->rem_set()->is_added_to_cset_group() ||\n+    assert(!r->rem_set()->has_cset_group() ||\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2444,0 +2444,6 @@\n+  \/\/ Clear current young cset group to allow adding.\n+  \/\/ It is fine to clear it this late - evacuation does not add any remembered sets\n+  \/\/ by itself, but only marks cards.\n+  \/\/ The regions had their association to this group already removed earlier.\n+  young_regions_cset_group()->clear();\n+\n@@ -2800,0 +2806,2 @@\n+\n+  young_regions_cset_group()->clear(true \/* uninstall_group_cardset *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  assert(!hr->rem_set()->is_added_to_cset_group(), \"Should have already uninstalled group remset\");\n+  assert(!hr->rem_set()->has_cset_group(), \"Should have already uninstalled group remset\");\n@@ -326,1 +326,4 @@\n-  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, _g1h->young_regions_cardset()->occupied());\n+  size_t num_young_cards = _g1h->young_regions_cardset()->occupied();\n+  _policy->record_card_rs_length(num_young_cards);\n+\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, num_young_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3057,1 +3057,1 @@\n-  if (r->rem_set()->is_added_to_cset_group()) {\n+  if (r->rem_set()->has_cset_group()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,5 +247,0 @@\n-  \/\/ We clear remembered sets for young regions this late in the full GC because\n-  \/\/ G1HeapVerifier expects the remembered sets for all young regions to be complete\n-  \/\/ throughout most of the collection process (e.g. G1FullCollector::verify_after_marking).\n-  _heap->young_regions_cset_group()->clear();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCResetMetadataTask.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  assert(!is_added_to_cset_group(), \"Still assigned to a CSet group\");\n+  assert(!has_cset_group(), \"Still assigned to a CSet group\");\n@@ -79,1 +79,1 @@\n-  if (is_added_to_cset_group()) {\n+  if (has_cset_group()) {\n@@ -93,1 +93,1 @@\n-  if (is_added_to_cset_group()) {\n+  if (has_cset_group()) {\n@@ -99,1 +99,1 @@\n-  assert(is_added_to_cset_group(), \"pre-condition\");\n+  assert(has_cset_group(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n@@ -65,1 +65,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n@@ -74,1 +74,1 @@\n-    return !is_added_to_cset_group() || card_set()->is_empty();\n+    return !has_cset_group() || card_set()->is_empty();\n@@ -86,1 +86,1 @@\n-  bool is_added_to_cset_group() const {\n+  bool has_cset_group() const {\n@@ -99,1 +99,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n@@ -121,1 +121,1 @@\n-    assert(is_added_to_cset_group(), \"pre-condition\");\n+    assert(has_cset_group(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  assert(is_added_to_cset_group(), \"pre-condition\");\n+  assert(has_cset_group(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,0 +238,2 @@\n+  bool is_in_full_gc() const { return G1CollectedHeap::heap()->collector_state()->in_full_gc(); }\n+\n@@ -249,1 +251,1 @@\n-    guarantee(!r->is_young() || r->rem_set()->is_complete(), \"Remembered set for Young region %u must be complete, is %s\", r->hrm_index(), r->rem_set()->get_state_str());\n+    guarantee(is_in_full_gc() || !r->is_young() || r->rem_set()->is_complete(), \"Remembered set for Young region %u must be complete outside full gc, is %s\", r->hrm_index(), r->rem_set()->get_state_str());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,2 +132,2 @@\n-  void record_card_rs_length(size_t card_rs_length) {\n-    _card_rs_length = card_rs_length;\n+  void record_card_rs_length(size_t num_cards) {\n+    _card_rs_length = num_cards;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1443,10 +1443,0 @@\n-  {\n-    size_t young_rs_length = g1h->young_regions_cardset()->occupied();\n-    \/\/ We only use young_rs_length statistics to estimate young regions length.\n-    g1h->policy()->record_card_rs_length(young_rs_length);\n-\n-    \/\/ Clear current young only collection set. Survivor regions will be added\n-    \/\/ to the set during evacuation.\n-    g1h->young_regions_cset_group()->clear();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-    if (hrrs->is_added_to_cset_group() && hrrs->cset_group()->length() == 1) {\n+    if (hrrs->has_cset_group() && hrrs->cset_group()->length() == 1) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-    if (r->rem_set()->is_added_to_cset_group() &&\n+    if (r->rem_set()->has_cset_group() &&\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,6 +84,6 @@\n-      snprintf(evacuation_failed_string,\n-               ARRAY_SIZE(evacuation_failed_string),\n-               \" (Evacuation Failure: %s%s%s)\",\n-               _collector->evacuation_alloc_failed() ? \"Allocation\" : \"\",\n-               _collector->evacuation_alloc_failed() && _collector->evacuation_pinned() ? \" \/ \" : \"\",\n-               _collector->evacuation_pinned() ? \"Pinned\" : \"\");\n+      os::snprintf_checked(evacuation_failed_string,\n+                           ARRAY_SIZE(evacuation_failed_string),\n+                           \" (Evacuation Failure: %s%s%s)\",\n+                           _collector->evacuation_alloc_failed() ? \"Allocation\" : \"\",\n+                           _collector->evacuation_alloc_failed() && _collector->evacuation_pinned() ? \" \/ \" : \"\",\n+                           _collector->evacuation_pinned() ? \"Pinned\" : \"\");\n@@ -91,6 +91,6 @@\n-    snprintf(_young_gc_name_data,\n-             MaxYoungGCNameLength,\n-             \"Pause Young (%s) (%s)%s\",\n-             G1GCPauseTypeHelper::to_string(_pause_type),\n-             GCCause::to_string(_pause_cause),\n-             evacuation_failed_string);\n+    os::snprintf_checked(_young_gc_name_data,\n+                         MaxYoungGCNameLength,\n+                         \"Pause Young (%s) (%s)%s\",\n+                         G1GCPauseTypeHelper::to_string(_pause_type),\n+                         GCCause::to_string(_pause_cause),\n+                         evacuation_failed_string);\n@@ -522,1 +522,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -106,2 +106,1 @@\n-                                          max_gc_pause_sec,\n-                                          GCTimeRatio);\n+                                          max_gc_pause_sec);\n@@ -283,1 +282,2 @@\n-  {\n+  for (uint loop_count = 0; \/* empty *\/; ++loop_count) {\n+    \/\/ Try young-gen first.\n@@ -288,1 +288,0 @@\n-  }\n@@ -290,2 +289,9 @@\n-  uint loop_count = 0;\n-  uint gc_count = 0;\n+    \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n+    if (!is_tlab) {\n+      if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n+        result = old_gen()->cas_allocate_noexpand(size);\n+        if (result != nullptr) {\n+          return result;\n+        }\n+      }\n+    }\n@@ -293,1 +299,0 @@\n-  while (true) {\n@@ -305,0 +310,1 @@\n+    uint gc_count;\n@@ -308,15 +314,0 @@\n-\n-      HeapWord* result = young_gen()->allocate(size);\n-      if (result != nullptr) {\n-        return result;\n-      }\n-\n-      \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n-      if (!is_tlab) {\n-        if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n-          result = old_gen()->cas_allocate_noexpand(size);\n-          if (result != nullptr) {\n-            return result;\n-          }\n-        }\n-      }\n@@ -329,3 +320,0 @@\n-      \/\/ Did the VM operation execute? If so, return the result directly.\n-      \/\/ This prevents us from looping until time out on requests that can\n-      \/\/ not be satisfied.\n@@ -334,1 +322,0 @@\n-\n@@ -337,4 +324,0 @@\n-      \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator should return null as well for global consistency.\n-      if (_gc_overhead_counter >= GCOverheadLimitThreshold) {\n-        return nullptr;\n-      }\n@@ -343,1 +326,6 @@\n-    loop_count++;\n+    \/\/ Was the gc-overhead reached inside the safepoint? If so, this mutator\n+    \/\/ should return null as well for global consistency.\n+    if (_gc_overhead_counter >= GCOverheadLimitThreshold) {\n+      return nullptr;\n+    }\n+\n@@ -346,2 +334,1 @@\n-      log_warning(gc)(\"ParallelScavengeHeap::mem_allocate retries %d times\", loop_count);\n-      log_warning(gc)(\"\\tsize=%zu\", size);\n+      log_warning(gc)(\"ParallelScavengeHeap::mem_allocate retries %d times, size=%zu\", loop_count, size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":20,"deletions":33,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -39,4 +39,2 @@\n-                                           double gc_pause_goal_sec,\n-                                           uint gc_cost_ratio) :\n-     AdaptiveSizePolicy(gc_pause_goal_sec,\n-                        gc_cost_ratio),\n+                                           double gc_pause_goal_sec) :\n+     AdaptiveSizePolicy(gc_pause_goal_sec),\n@@ -76,0 +74,10 @@\n+\/\/ The throughput goal is implemented as\n+\/\/      _throughput_goal = 1 - (1 \/ (1 + gc_cost_ratio))\n+\/\/ gc_cost_ratio is the ratio\n+\/\/      application cost \/ gc cost\n+\/\/ For example a gc_cost_ratio of 4 translates into a\n+\/\/ throughput goal of .80\n+static double calculate_throughput_goal(double gc_cost_ratio) {\n+  return 1.0 - (1.0 \/ (1.0 + gc_cost_ratio));\n+}\n+\n@@ -81,1 +89,5 @@\n-  if (mutator_time_percent() < _throughput_goal) {\n+  \/\/ Get a local copy and use it inside gc-pause in case the global var gets updated externally.\n+  const uint local_GCTimeRatio = Atomic::load(&GCTimeRatio);\n+  const double throughput_goal = calculate_throughput_goal(local_GCTimeRatio);\n+\n+  if (mutator_time_percent() < throughput_goal) {\n@@ -83,1 +95,1 @@\n-    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * GCTimeRatio;\n+    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * local_GCTimeRatio;\n@@ -93,1 +105,1 @@\n-      mutator_time_percent(), _throughput_goal, (new_eden - cur_eden)\/K);\n+      mutator_time_percent(), throughput_goal, (new_eden - cur_eden)\/K);\n@@ -121,1 +133,1 @@\n-    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * GCTimeRatio,\n+    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * local_GCTimeRatio,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-                       double gc_pause_goal_sec,\n-                       uint gc_time_ratio);\n+                       double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  \/\/ Invoked by mutators and GC-workers.\n+  \/\/ Used by GC-workers during GC or for CDS at startup.\n@@ -123,1 +123,0 @@\n-    assert_locked_or_safepoint(Heap_lock);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+  assert(ref_processor() != nullptr, \"Sanity\");\n@@ -977,9 +978,0 @@\n-  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs);\n-}\n-\n-\/\/ This method contains no policy. You should probably\n-\/\/ be calling invoke() instead.\n-bool PSParallelCompact::invoke_no_policy(bool clear_all_soft_refs) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-  assert(ref_processor() != nullptr, \"Sanity\");\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -765,1 +765,0 @@\n-  static bool invoke_no_policy(bool clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -116,0 +116,7 @@\n+  inline HeapWord* allocate_in_young_gen(Klass* klass,\n+                                         size_t obj_size,\n+                                         uint age);\n+  inline HeapWord* allocate_in_old_gen(Klass* klass,\n+                                       size_t obj_size,\n+                                       uint age);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,74 @@\n+inline HeapWord* PSPromotionManager::allocate_in_young_gen(Klass* klass,\n+                                                           size_t obj_size,\n+                                                           uint age) {\n+  HeapWord* result = _young_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_young_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (YoungPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = young_space()->cas_allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _young_lab.flush();\n+\n+    HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n+    if (lab_base != nullptr) {\n+      _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n+      \/\/ Try the young lab allocation again.\n+      result = _young_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, &_young_lab);\n+    } else {\n+      _young_gen_is_full = true;\n+    }\n+  }\n+  if (result == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n+    _young_gen_has_alloc_failure = true;\n+  }\n+  return result;\n+}\n+\n+inline HeapWord* PSPromotionManager::allocate_in_old_gen(Klass* klass,\n+                                                         size_t obj_size,\n+                                                         uint age) {\n+#ifndef PRODUCT\n+  if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    return nullptr;\n+  }\n+#endif  \/\/ #ifndef PRODUCT\n+\n+  HeapWord* result = _old_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_old_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (OldPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = old_gen()->allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _old_lab.flush();\n+\n+    HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n+    if (lab_base != nullptr) {\n+      _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n+      \/\/ Try the old lab allocation again.\n+      result = _old_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, &_old_lab);\n+    }\n+  }\n+  if (result == nullptr) {\n+    _old_gen_is_full = true;\n+  }\n+  return result;\n+}\n+\n@@ -189,25 +263,1 @@\n-      new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-      if (new_obj == nullptr && !_young_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (YoungPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(young_space()->cas_allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, false, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _young_lab.flush();\n-\n-          HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n-          if (lab_base != nullptr) {\n-            _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n-            \/\/ Try the young lab allocation again.\n-            new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, false, &_young_lab);\n-          } else {\n-            _young_gen_is_full = true;\n-          }\n-        }\n-        if (new_obj == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n-          _young_gen_has_alloc_failure = true;\n-        }\n-      }\n+      new_obj = cast_to_oop(allocate_in_young_gen(klass, new_obj_size, age));\n@@ -219,2 +269,2 @@\n-#ifndef PRODUCT\n-    if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    new_obj = cast_to_oop(allocate_in_old_gen(klass, new_obj_size, age));\n+    if (new_obj == nullptr) {\n@@ -223,3 +273,0 @@\n-#endif  \/\/ #ifndef PRODUCT\n-\n-    new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n@@ -227,33 +274,0 @@\n-\n-    if (new_obj == nullptr) {\n-      if (!_old_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (OldPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(old_gen()->allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, true, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _old_lab.flush();\n-\n-          HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n-          if(lab_base != nullptr) {\n-            _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n-            \/\/ Try the old lab allocation again.\n-            new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, true, &_old_lab);\n-          }\n-        }\n-      }\n-\n-      \/\/ This is the promotion failed test, and code handling.\n-      \/\/ The code belongs here for two reasons. It is slightly\n-      \/\/ different than the code below, and cannot share the\n-      \/\/ CAS testing code. Keeping the code here also minimizes\n-      \/\/ the impact on the common case fast path code.\n-\n-      if (new_obj == nullptr) {\n-        _old_gen_is_full = true;\n-        return oop_promotion_failed(o, test_mark);\n-      }\n-    }\n@@ -290,1 +304,1 @@\n-    \/\/ So, the is->objArray() test would be very infrequent.\n+    \/\/ So, the objArray test would be very infrequent.\n@@ -292,1 +306,1 @@\n-        new_obj->is_refArray() &&\n+        klass->is_refArray_klass() &&\n@@ -299,2 +313,1 @@\n-      if (StringDedup::is_enabled() &&\n-          java_lang_String::is_instance(new_obj) &&\n+      if (StringDedup::is_enabled_string(klass) &&\n@@ -308,1 +321,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":80,"deletions":68,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-  _pretenure_size_threshold_words = PretenureSizeThreshold >> LogHeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,2 +58,0 @@\n-  \/\/ Size of object to pretenure in words; command line provides bytes\n-  size_t      _pretenure_size_threshold_words;\n@@ -188,18 +186,0 @@\n-  \/\/ Allocation support\n-  bool should_allocate(size_t word_size, bool is_tlab) {\n-    assert(UseTLAB || !is_tlab, \"Should not allocate tlab\");\n-    assert(word_size != 0, \"precondition\");\n-\n-    size_t overflow_limit    = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-\n-    const bool overflows     = word_size >= overflow_limit;\n-    const bool check_too_big = _pretenure_size_threshold_words > 0;\n-    const bool not_too_big   = word_size < _pretenure_size_threshold_words;\n-    const bool size_ok       = is_tlab || !check_too_big || not_too_big;\n-\n-    bool result = !overflows &&\n-                  size_ok;\n-\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-#include \"runtime\/handles.hpp\"\n@@ -286,4 +285,2 @@\n-  HeapWord* result = nullptr;\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    result = _old_gen->expand_and_allocate(size);\n-  }\n+  HeapWord* result = _young_gen->allocate(size);\n+\n@@ -291,4 +288,1 @@\n-    if (_young_gen->should_allocate(size, is_tlab)) {\n-      \/\/ Young-gen is not expanded.\n-      result = _young_gen->allocate(size);\n-    }\n+    result = _old_gen->expand_and_allocate(size);\n@@ -296,0 +290,1 @@\n+\n@@ -304,5 +299,3 @@\n-    if (_young_gen->should_allocate(size, is_tlab)) {\n-      result = _young_gen->par_allocate(size);\n-      if (result != nullptr) {\n-        break;\n-      }\n+    result = _young_gen->par_allocate(size);\n+    if (result != nullptr) {\n+      break;\n@@ -345,19 +338,0 @@\n-HeapWord* SerialHeap::attempt_allocation(size_t size,\n-                                         bool is_tlab,\n-                                         bool first_only) {\n-  HeapWord* res = nullptr;\n-\n-  if (_young_gen->should_allocate(size, is_tlab)) {\n-    res = _young_gen->allocate(size);\n-    if (res != nullptr || first_only) {\n-      return res;\n-    }\n-  }\n-\n-  if (_old_gen->should_allocate(size, is_tlab)) {\n-    res = _old_gen->allocate(size);\n-  }\n-\n-  return res;\n-}\n-\n@@ -462,1 +436,1 @@\n-  bool should_run_young_gc = _young_gen->should_allocate(size, is_tlab);\n+  bool should_run_young_gc = is_tlab || size <= _young_gen->eden()->capacity();\n@@ -465,6 +439,1 @@\n-  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n-  if (result != nullptr) {\n-    return result;\n-  }\n-\n-  \/\/ OK, collection failed, try expansion.\n+  \/\/ Just finished a GC, try to satisfy this allocation, using expansion if needed.\n@@ -487,4 +456,0 @@\n-  result = attempt_allocation(size, is_tlab, false \/* first_only *\/);\n-  if (result != nullptr) {\n-    return result;\n-  }\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":9,"deletions":44,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -105,5 +105,0 @@\n-  \/\/ Helper functions for allocation\n-  HeapWord* attempt_allocation(size_t size,\n-                               bool   is_tlab,\n-                               bool   first_only);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -138,9 +138,0 @@\n-  bool should_allocate(size_t word_size, bool is_tlab) {\n-    bool result = false;\n-    size_t overflow_limit = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-    if (!is_tlab) {\n-      result = (word_size > 0) && (word_size < overflow_limit);\n-    }\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,10 +34,1 @@\n-\/\/ The throughput goal is implemented as\n-\/\/      _throughput_goal = 1 - ( 1 \/ (1 + gc_cost_ratio))\n-\/\/ gc_cost_ratio is the ratio\n-\/\/      application cost \/ gc cost\n-\/\/ For example a gc_cost_ratio of 4 translates into a\n-\/\/ throughput goal of .80\n-\n-AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                                       uint gc_cost_ratio) :\n-  _throughput_goal(1.0 - double(1.0 \/ (1.0 + (double) gc_cost_ratio))),\n+AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec) :\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,4 +50,0 @@\n-  \/\/ Goal for the fraction of the total time during which application\n-  \/\/ threads run\n-  const double _throughput_goal;\n-\n@@ -173,2 +169,1 @@\n-  AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                     uint gc_cost_ratio);\n+  AdaptiveSizePolicy(double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,3 +65,2 @@\n-  julong memory = os::physical_memory();\n-  log_info_p(gc, init)(\"Memory: \" JULONG_FORMAT \"%s\",\n-                       byte_size_in_proper_unit(memory), proper_unit_for_byte_size(memory));\n+  size_t memory = os::physical_memory();\n+  log_info_p(gc, init)(\"Memory: \" PROPERFMT, PROPERFMTARGS(memory));\n","filename":"src\/hotspot\/share\/gc\/shared\/gcInitLogger.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -487,5 +487,0 @@\n-  product(size_t, PretenureSizeThreshold, 0,                                \\\n-          \"Maximum size in bytes of objects allocated in DefNew \"           \\\n-          \"generation; zero means no maximum\")                              \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-  os::snprintf(name, sizeof(name), \"%s %s lock\", storage_name, kind);\n+  os::snprintf_checked(name, sizeof(name), \"%s %s lock\", storage_name, kind);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-    os::snprintf(buffer, SATB_PRINTER_BUFFER_SIZE, \"Enqueued: %d\", i);\n+    os::snprintf_checked(buffer, SATB_PRINTER_BUFFER_SIZE, \"Enqueued: %d\", i);\n@@ -324,1 +324,1 @@\n-      os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, \"Thread: %s\", t->name());\n+      (void) os::snprintf(_buffer, SATB_PRINTER_BUFFER_SIZE, \"Thread: %s\", t->name());\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,0 +197,7 @@\n+  \/\/ Gen shen does not support any ShenandoahGCHeuristics value except for the default \"adaptive\"\n+  if ((strcmp(ShenandoahGCMode, \"generational\") == 0)\n+      && strcmp(ShenandoahGCHeuristics, \"adaptive\") != 0) {\n+    log_warning(gc)(\"Ignoring -XX:ShenandoahGCHeuristics input: %s, because generational shenandoah only\"\n+      \" supports adaptive heuristics\", ShenandoahGCHeuristics);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shenandoah\/shenandoahSimpleBitMap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/shared\/gc_globals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -144,1 +144,2 @@\n-          \"Possible values are:\"                                            \\\n+          \"When -XX:ShenandoahGCMode is generational, the only supported \"  \\\n+          \"option is the default, adaptive. Possible values are:\"           \\\n@@ -147,1 +148,2 @@\n-          \" static -  trigger GC when free heap falls below the threshold;\" \\\n+          \" static - trigger GC when free heap falls below a specified \"    \\\n+          \"threshold;\"                                                      \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/z\/zAddress.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"gc\/z\/zAddress.hpp\"\n@@ -37,1 +37,0 @@\n-#include \"utilities\/debug.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/debug.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"oops\/refArrayOop.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zIterator.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-  log_info_p(gc, init)(\"Memory: \" JULONG_FORMAT \"M\", os::physical_memory() \/ M);\n+  const size_t memory = os::physical_memory();\n+  log_info_p(gc, init)(\"Memory: \" PROPERFMT, PROPERFMTARGS(memory));\n","filename":"src\/hotspot\/share\/gc\/z\/zLargePages.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1095,1 +1095,2 @@\n-  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\");\n+  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\"\n+         \" %zu + %zu == %zu\", allocation->harvested(), allocation->committed_capacity(), freed);\n@@ -1912,0 +1913,1 @@\n+  assert(allocation->partial_vmems()->is_empty(), \"Invariant for single partition commit failure\");\n@@ -1913,4 +1915,7 @@\n-  const size_t committed = allocation->committed_capacity();\n-  const ZVirtualMemory non_harvested_vmem = vmem.last_part(allocation->harvested());\n-  const ZVirtualMemory committed_vmem = non_harvested_vmem.first_part(committed);\n-  const ZVirtualMemory non_committed_vmem = non_harvested_vmem.last_part(committed);\n+  \/\/ For a single partition we have unmapped the harvested memory before we\n+  \/\/ started committing, and moved its physical memory association to the start\n+  \/\/ of the vmem. As such, the partial_vmems is empty. All the harvested and\n+  \/\/ partially successfully committed memory is mapped in the first part of vmem.\n+  const size_t harvested_and_committed_capacity = allocation->harvested() + allocation->committed_capacity();\n+  const ZVirtualMemory succeeded_vmem = vmem.first_part(harvested_and_committed_capacity);\n+  const ZVirtualMemory failed_vmem = vmem.last_part(harvested_and_committed_capacity);\n@@ -1918,1 +1923,1 @@\n-  if (committed_vmem.size() > 0) {\n+  if (succeeded_vmem.size() > 0) {\n@@ -1922,1 +1927,1 @@\n-    allocation->partial_vmems()->append(committed_vmem);\n+    allocation->partial_vmems()->append(succeeded_vmem);\n@@ -1927,2 +1932,2 @@\n-  partition.free_physical(non_committed_vmem);\n-  partition.free_virtual(non_committed_vmem);\n+  partition.free_physical(failed_vmem);\n+  partition.free_virtual(failed_vmem);\n@@ -1944,1 +1949,1 @@\n-    const ZVirtualMemory non_harvested_vmem = vmem.last_part(allocation->harvested());\n+    const ZVirtualMemory non_harvested_vmem = partial_vmem.last_part(allocation->harvested());\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -217,0 +217,9 @@\n+static size_t inject_commit_limit(const ZVirtualMemory& vmem) {\n+  \/\/ To facilitate easier interoperability with multi partition allocations we\n+  \/\/ divide by ZNUMA::count(). Users of ZFailLargerCommits need to be aware of\n+  \/\/ this when writing tests. In the future we could probe the VirtualMemoryManager\n+  \/\/ and condition this division on whether the vmem is in the multi partition\n+  \/\/ address space.\n+  return align_up(MIN2(ZFailLargerCommits \/ ZNUMA::count(), vmem.size()), ZGranuleSize);\n+}\n+\n@@ -219,1 +228,3 @@\n-  const size_t size = vmem.size();\n+  const size_t size = ZFailLargerCommits > 0\n+      ? inject_commit_limit(vmem)\n+      : vmem.size();\n","filename":"src\/hotspot\/share\/gc\/z\/zPhysicalMemoryManager.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/z\/zBarrier.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zUncoloredRoot.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,0 +121,5 @@\n+  develop(size_t, ZFailLargerCommits, 0,                                    \\\n+          \"Commits larger than ZFailLargerCommits will be truncated, \"      \\\n+          \"used to stress page allocation commit failure paths \"            \\\n+          \"(0: Disabled)\")                                                  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/z\/z_globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"jni.h\"\n@@ -33,0 +32,1 @@\n+#include \"jni.h\"\n","filename":"src\/hotspot\/share\/include\/jvm_io.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-                           resolved_iklass->is_shared() ? \"is_shared\" : \"\",\n+                           resolved_iklass->in_aot_cache() ? \"in_aot_cache\" : \"\",\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-    if (_pool->pool_holder()->is_shared()) {\n+    if (_pool->pool_holder()->in_aot_cache()) {\n@@ -570,2 +570,2 @@\n-  if (klass->is_shared()) {\n-    assert(!klass->is_rewritten(), \"rewritten shared classes cannot be rewritten again\");\n+  if (klass->in_aot_cache()) {\n+    assert(!klass->is_rewritten(), \"rewritten classes in the AOT cache cannot be rewritten again\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  InstanceKlass* const super = InstanceKlass::cast(ik->super());\n+  InstanceKlass* const super = ik->super();\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  return os::Linux::physical_memory();\n+  return static_cast<jlong>(os::Linux::physical_memory());\n@@ -417,1 +417,1 @@\n-  return os::physical_memory();\n+  return static_cast<jlong>(os::physical_memory());\n@@ -426,1 +426,4 @@\n-  return os::total_swap_space();\n+  size_t total_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::total_swap_space(total_swap_space);\n+  return static_cast<jlong>(total_swap_space);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    ik = (const InstanceKlass*)ik->super();\n+    ik = ik->super();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -531,1 +531,1 @@\n-  u8 totalPhysicalMemory = os::physical_memory();\n+  u8 totalPhysicalMemory = static_cast<u8>(os::physical_memory());\n@@ -534,1 +534,4 @@\n-  event.set_usedSize(totalPhysicalMemory - os::available_memory());\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  event.set_usedSize(totalPhysicalMemory - static_cast<u8>(avail_mem));\n@@ -540,2 +543,8 @@\n-  event.set_totalSize(os::total_swap_space());\n-  event.set_freeSize(os::free_swap_space());\n+  size_t total_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::total_swap_space(total_swap_space);\n+  event.set_totalSize(static_cast<s8>(total_swap_space));\n+  size_t free_swap_space = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::free_swap_space(free_swap_space);\n+  event.set_freeSize(static_cast<s8>(free_swap_space));\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2015,1 +2015,1 @@\n-    Klass* k = iklass->local_interfaces()->at(index);\n+    InstanceKlass* k = iklass->local_interfaces()->at(index);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -937,1 +937,1 @@\n-  os::vsnprintf(msg, max_msg_size, format, ap);\n+  (void) os::vsnprintf(msg, max_msg_size, format, ap);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -69,2 +68,2 @@\n-void* MetaspaceObj::_shared_metaspace_base = nullptr;\n-void* MetaspaceObj::_shared_metaspace_top  = nullptr;\n+void* MetaspaceObj::_aot_metaspace_base = nullptr;\n+void* MetaspaceObj::_aot_metaspace_top  = nullptr;\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  \/\/ When CDS is enabled, all shared metaspace objects are mapped\n+  \/\/ All metsapce objects in the AOT cache (CDS archive) are mapped\n@@ -266,5 +266,5 @@\n-  \/\/ two pointers to quickly determine if something is in the\n-  \/\/ shared metaspace.\n-  \/\/ When CDS is not enabled, both pointers are set to null.\n-  static void* _shared_metaspace_base;  \/\/ (inclusive) low address\n-  static void* _shared_metaspace_top;   \/\/ (exclusive) high address\n+  \/\/ two pointers to quickly determine if a MetaspaceObj is in the\n+  \/\/ AOT cache.\n+  \/\/ When AOT\/CDS is not enabled, both pointers are set to null.\n+  static void* _aot_metaspace_base;  \/\/ (inclusive) low address\n+  static void* _aot_metaspace_top;   \/\/ (exclusive) high address\n@@ -276,1 +276,1 @@\n-  \/\/ non-shared or shared metaspace.\n+  \/\/ regular- or aot metaspace.\n@@ -280,2 +280,2 @@\n-  static bool is_shared(const MetaspaceObj* p) {\n-    \/\/ If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will\n+  static bool in_aot_cache(const MetaspaceObj* p) {\n+    \/\/ If no shared metaspace regions are mapped, _aot_metaspace_{base,top} will\n@@ -283,2 +283,2 @@\n-    return (((void*)p) < _shared_metaspace_top &&\n-            ((void*)p) >= _shared_metaspace_base);\n+    return (((void*)p) < _aot_metaspace_top &&\n+            ((void*)p) >= _aot_metaspace_base);\n@@ -286,1 +286,1 @@\n-  bool is_shared() const { return MetaspaceObj::is_shared(this); }\n+  bool in_aot_cache() const { return MetaspaceObj::in_aot_cache(this); }\n@@ -288,2 +288,2 @@\n-  static bool is_shared(const MetaspaceObj* p) { return false; }\n-  bool is_shared() const { return false; }\n+  static bool in_aot_cache(const MetaspaceObj* p) { return false; }\n+  bool in_aot_cache() const { return false; }\n@@ -294,3 +294,3 @@\n-  static void set_shared_metaspace_range(void* base, void* top) {\n-    _shared_metaspace_base = base;\n-    _shared_metaspace_top = top;\n+  static void set_aot_metaspace_range(void* base, void* top) {\n+    _aot_metaspace_base = base;\n+    _aot_metaspace_top = top;\n@@ -299,2 +299,2 @@\n-  static void* shared_metaspace_base() { return _shared_metaspace_base; }\n-  static void* shared_metaspace_top()  { return _shared_metaspace_top;  }\n+  static void* aot_metaspace_base() { return _aot_metaspace_base; }\n+  static void* aot_metaspace_top()  { return _aot_metaspace_top;  }\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/metaspaceUtils.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -40,0 +39,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -41,1 +41,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -43,0 +42,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -371,0 +371,1 @@\n+        assert(cie->klass()->is_instance_klass(), \"elements array contains only instance klasses\");\n@@ -409,1 +410,1 @@\n-  Klass* super = ((InstanceKlass*)cie->klass())->java_super();\n+  InstanceKlass* super = InstanceKlass::cast(cie->klass())->super();\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/annotations.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"oops\/annotations.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"oops\/klass.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -39,1 +39,0 @@\n-#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"oops\/klass.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"oops\/typeArrayKlass.inline.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"oops\/typeArrayKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/memory\/memRegion.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+                                             size_t page_size,\n@@ -118,1 +119,1 @@\n-    return ReservedSpace(base, size, alignment, os::vm_page_size(), exec, false \/* special *\/);\n+    return ReservedSpace(base, size, alignment, page_size, exec, false \/* special *\/);\n@@ -191,1 +192,1 @@\n-  return reserve_memory(requested_address, size, alignment, executable, mem_tag);\n+  return reserve_memory(requested_address, size, alignment, page_size, executable, mem_tag);\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+                                      size_t page_size,\n","filename":"src\/hotspot\/share\/memory\/memoryReserver.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+\n@@ -61,1 +62,1 @@\n-      assert(!data->is_shared(), \"cannot deallocate array in shared spaces\");\n+      assert(!data->in_aot_cache(), \"cannot deallocate array in aot metaspace spaces\");\n@@ -75,1 +76,1 @@\n-      assert(!md->is_shared(), \"cannot deallocate if in shared spaces\");\n+      assert(!md->in_aot_cache(), \"cannot deallocate if in aot metaspace spaces\");\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1039,2 +1039,2 @@\n-bool Metaspace::is_in_shared_metaspace(const void* ptr) {\n-  return MetaspaceShared::is_in_shared_metaspace(ptr);\n+bool Metaspace::in_aot_cache(const void* ptr) {\n+  return MetaspaceShared::in_aot_cache(ptr);\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-    return is_in_shared_metaspace(ptr) || \/\/ in cds\n+    return in_aot_cache(ptr) || \/\/ in cds\n@@ -145,1 +145,1 @@\n-  static bool is_in_shared_metaspace(const void* ptr);\n+  static bool in_aot_cache(const void* ptr);\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"memory\/metaspace\/chunklevel.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"memory\/metaspace\/chunklevel.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -32,1 +32,0 @@\n-#include \"utilities\/ostream.hpp\"\n@@ -34,0 +33,2 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metablock.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    if (k->is_shared()) {\n+    if (k->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/memory\/metaspace\/printCLDMetaspaceInfoClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  \/\/ Print a 's' for shared classes\n-  _out->put(k->is_shared() ? 's': ' ');\n+  \/\/ Print a 's' for classes in the aot metaspace (used to be called shared classes)\n+  _out->put(k->in_aot_cache() ? 's': ' ');\n","filename":"src\/hotspot\/share\/memory\/metaspace\/printMetaspaceInfoKlassClosure.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"memory\/metaspace\/metaspaceContext.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"memory\/metaspace\/metaspaceContext.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -39,1 +39,0 @@\n-#include \"oops\/objArrayOop.inline.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/resourceArea.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/arrayWithFreeList.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/java.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -32,1 +32,0 @@\n-#include \"utilities\/parseInteger.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocLimit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -46,1 +47,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/mallocLimit.hpp\"\n@@ -31,0 +30,2 @@\n+\n+#include \"nmt\/mallocLimit.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -33,0 +32,2 @@\n+#include \"memory\/universe.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"nmt\/memMapPrinter.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memTag.hpp\"\n+#include \"nmt\/memoryFileTracker.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -32,2 +33,0 @@\n-#include \"nmt\/memoryFileTracker.hpp\"\n-#include \"nmt\/regionsTree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memReporter.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/nmtCommon.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/nmtCommon.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"nmt\/memTracker.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"nmt\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"nmt\/vmatree.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"nmt\/vmatree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"nmt\/regionsTree.hpp\"\n@@ -30,0 +28,1 @@\n+#include \"nmt\/virtualMemoryTracker.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/vmatree.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"nmt\/vmatree.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/memTag.hpp\"\n@@ -35,0 +34,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-    if (MetaspaceShared::is_shared_dynamic((void*)k)) {\n+    if (MetaspaceShared::in_aot_cache_dynamic_region((void*)k)) {\n@@ -289,1 +289,1 @@\n-    } else if (MetaspaceShared::is_shared_static((void*)k)) {\n+    } else if (MetaspaceShared::in_aot_cache_static_region((void*)k)) {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,4 +81,4 @@\n-  os::snprintf(tmp, sizeof(tmp), \"klass range: \" RANGE2FMT \",\"\n-      \" base \" PTR_FORMAT \", shift %d, lowest\/highest valid narrowKlass %u\/%u\",\n-      RANGE2FMTARGS(_klass_range_start, _klass_range_end),\n-      p2i(_base), _shift, _lowest_valid_narrow_klass_id, _highest_valid_narrow_klass_id);\n+  os::snprintf_checked(tmp, sizeof(tmp), \"klass range: \" RANGE2FMT \",\"\n+                       \" base \" PTR_FORMAT \", shift %d, lowest\/highest valid narrowKlass %u\/%u\",\n+                       RANGE2FMTARGS(_klass_range_start, _klass_range_end),\n+                       p2i(_base), _shift, _lowest_valid_narrow_klass_id, _highest_valid_narrow_klass_id);\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -388,2 +388,2 @@\n-  assert(on_stack(), \"should always be set for shared constant pools\");\n-  assert(is_shared(), \"should always be set for shared constant pools\");\n+  assert(on_stack(), \"should always be set for constant pools in AOT cache\");\n+  assert(in_aot_cache(), \"should always be set for constant pools in AOT cache\");\n@@ -433,1 +433,1 @@\n-  \/\/ Shared ConstantPools are in the RO region, so the _flags cannot be modified.\n+  \/\/ ConstantPools in AOT cache are in the RO region, so the _flags cannot be modified.\n@@ -435,1 +435,1 @@\n-  \/\/ class redefinition. Since shared ConstantPools cannot be deallocated anyway,\n+  \/\/ class redefinition. Since such ConstantPools cannot be deallocated anyway,\n@@ -437,1 +437,1 @@\n-  _flags |= (_on_stack | _is_shared);\n+  _flags |= (_on_stack | _in_aot_cache);\n@@ -2290,1 +2290,1 @@\n-      assert(!is_shared(), \"should always be set for shared constant pools\");\n+      assert(!in_aot_cache(), \"should always be set for constant pools in AOT cache\");\n@@ -2296,1 +2296,1 @@\n-    if (!is_shared()) {\n+    if (!in_aot_cache()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    _is_shared            = 4,\n+    _in_aot_cache         = 4,\n@@ -215,1 +215,1 @@\n-    assert(!is_shared(), \"should never be called on shared ConstantPools\");\n+    assert(!in_aot_cache(), \"should never be called on ConstantPools in AOT cache\");\n@@ -251,2 +251,2 @@\n-  \/\/ Faster than MetaspaceObj::is_shared() - used by set_on_stack()\n-  bool is_shared() const                     { return (_flags & _is_shared) != 0; }\n+  \/\/ Shadows MetaspaceObj::in_aot_cache(). It's faster and is used by set_on_stack()\n+  bool in_aot_cache() const               { return (_flags & _in_aot_cache) != 0; }\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-  assert(!is_shared(), \"shared caches are not deallocated\");\n+  assert(!in_aot_cache(), \"objects in aot metaspace are not deallocated\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-        result = result->java_super();\n+        result = result->super();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2157,1 +2157,1 @@\n-  os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n+  (void) os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n@@ -2160,1 +2160,1 @@\n-  os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n+  (void) os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-      !methods->is_shared()) {\n+      !methods->in_aot_cache()) {\n@@ -638,1 +638,1 @@\n-                                          const Klass* super_klass,\n+                                          const InstanceKlass* super_klass,\n@@ -647,2 +647,2 @@\n-                    InstanceKlass::cast(super_klass)->transitive_interfaces();\n-    if (ti != sti && ti != nullptr && !ti->is_shared()) {\n+                    super_klass->transitive_interfaces();\n+    if (ti != sti && ti != nullptr && !ti->in_aot_cache()) {\n@@ -655,1 +655,1 @@\n-      local_interfaces != nullptr && !local_interfaces->is_shared()) {\n+      local_interfaces != nullptr && !local_interfaces->in_aot_cache()) {\n@@ -662,1 +662,1 @@\n-  if (record_components != nullptr && !record_components->is_shared()) {\n+  if (record_components != nullptr && !record_components->in_aot_cache()) {\n@@ -706,1 +706,1 @@\n-      !method_ordering()->is_shared()) {\n+      !method_ordering()->in_aot_cache()) {\n@@ -714,1 +714,1 @@\n-      !default_methods()->is_shared()) {\n+      !default_methods()->in_aot_cache()) {\n@@ -722,1 +722,1 @@\n-      !default_vtable_indices()->is_shared()) {\n+      !default_vtable_indices()->in_aot_cache()) {\n@@ -735,1 +735,1 @@\n-      !secondary_supers()->is_shared()) {\n+      !secondary_supers()->in_aot_cache()) {\n@@ -744,1 +744,1 @@\n-  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->is_shared()) {\n+  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->in_aot_cache()) {\n@@ -749,1 +749,1 @@\n-  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->in_aot_cache()) {\n@@ -754,1 +754,1 @@\n-  if (fields_status() != nullptr && !fields_status()->is_shared()) {\n+  if (fields_status() != nullptr && !fields_status()->in_aot_cache()) {\n@@ -768,1 +768,1 @@\n-    if (!constants()->is_shared()) {\n+    if (!constants()->in_aot_cache()) {\n@@ -779,1 +779,1 @@\n-      !inner_classes()->is_shared()) {\n+      !inner_classes()->in_aot_cache()) {\n@@ -786,1 +786,1 @@\n-      !nest_members()->is_shared()) {\n+      !nest_members()->in_aot_cache()) {\n@@ -793,1 +793,1 @@\n-      !permitted_subclasses()->is_shared()) {\n+      !permitted_subclasses()->in_aot_cache()) {\n@@ -800,1 +800,1 @@\n-      !loadable_descriptors()->is_shared()) {\n+      !loadable_descriptors()->in_aot_cache()) {\n@@ -806,1 +806,1 @@\n-  if (annotations() != nullptr && !annotations()->is_shared()) {\n+  if (annotations() != nullptr && !annotations()->in_aot_cache()) {\n@@ -823,1 +823,1 @@\n-         java_super() == vmClasses::Record_klass();\n+         super() == vmClasses::Record_klass();\n@@ -838,1 +838,1 @@\n-  InstanceKlass* s = java_super();\n+  InstanceKlass* s = super();\n@@ -840,1 +840,1 @@\n-          (s != nullptr && s->java_super() == vmClasses::Enum_klass()));\n+          (s != nullptr && s->super() == vmClasses::Enum_klass()));\n@@ -904,1 +904,1 @@\n-  InstanceKlass* s = java_super();\n+  InstanceKlass* s = super();\n@@ -1055,1 +1055,1 @@\n-  Klass* super_klass = super();\n+  InstanceKlass* super_klass = super();\n@@ -1070,2 +1070,1 @@\n-    InstanceKlass* ik_super = InstanceKlass::cast(super_klass);\n-    ik_super->link_class_impl(CHECK_false);\n+    super_klass->link_class_impl(CHECK_false);\n@@ -1115,1 +1114,1 @@\n-        if (is_shared()) {\n+        if (in_aot_cache()) {\n@@ -1134,1 +1133,1 @@\n-      } else if (is_shared()) {\n+      } else if (in_aot_cache()) {\n@@ -1152,1 +1151,1 @@\n-      if (is_shared() && verified_at_dump_time() &&\n+      if (in_aot_cache() && verified_at_dump_time() &&\n@@ -1194,1 +1193,1 @@\n-    assert(is_shared(), \"rewriting an unshared class?\");\n+    assert(in_aot_cache(), \"rewriting an unshared class?\");\n@@ -1704,1 +1703,1 @@\n-  InstanceKlass* super_ik = ik->java_super();\n+  InstanceKlass* super_ik = ik->super();\n@@ -1915,1 +1914,1 @@\n-    assert(is_shared(), \"must be\");\n+    assert(in_aot_cache(), \"must be\");\n@@ -2030,1 +2029,1 @@\n-    Klass* intf1 = local_interfaces()->at(i);\n+    InstanceKlass* intf1 = local_interfaces()->at(i);\n@@ -2033,1 +2032,1 @@\n-    if (InstanceKlass::cast(intf1)->find_local_field(name, sig, fd)) {\n+    if (intf1->find_local_field(name, sig, fd)) {\n@@ -2038,1 +2037,1 @@\n-    Klass* intf2 = InstanceKlass::cast(intf1)->find_interface_field(name, sig, fd);\n+    Klass* intf2 = intf1->find_interface_field(name, sig, fd);\n@@ -2057,2 +2056,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n+  { InstanceKlass* supr = super();\n+    if (supr != nullptr) return supr->find_field(name, sig, fd);\n@@ -2077,2 +2076,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n+  { InstanceKlass* supr = super();\n+    if (supr != nullptr) return supr->find_field(name, sig, is_static, fd);\n@@ -2106,1 +2105,1 @@\n-  Klass* klass = const_cast<InstanceKlass*>(this);\n+  const InstanceKlass* klass = this;\n@@ -2108,1 +2107,1 @@\n-    if (InstanceKlass::cast(klass)->find_local_field_from_offset(offset, is_static, fd)) {\n+    if (klass->find_local_field_from_offset(offset, is_static, fd)) {\n@@ -2154,1 +2153,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = this->super();\n@@ -2171,1 +2170,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = this->super();\n@@ -2466,1 +2465,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2468,5 +2467,5 @@\n-    Method* const method = InstanceKlass::cast(klass)->find_method_impl(name,\n-                                                                        signature,\n-                                                                        overpass_local_mode,\n-                                                                        StaticLookupMode::find,\n-                                                                        private_mode);\n+    Method* const method = klass->find_method_impl(name,\n+                                                   signature,\n+                                                   overpass_local_mode,\n+                                                   StaticLookupMode::find,\n+                                                   private_mode);\n@@ -2489,1 +2488,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2491,1 +2490,1 @@\n-    if (InstanceKlass::cast(klass)->has_been_redefined()) {\n+    if (klass->has_been_redefined()) {\n@@ -2568,1 +2567,1 @@\n-    if (ik->is_shared()) buf[i++] = 'S';\n+    if (ik->in_aot_cache()) buf[i++] = 'S';\n@@ -3003,1 +3002,1 @@\n-             MetaspaceShared::is_in_shared_metaspace(_package_entry)) {\n+             MetaspaceShared::in_aot_cache(_package_entry)) {\n@@ -3095,1 +3094,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(this)) {\n+  if (MetaspaceShared::in_aot_cache(this)) {\n@@ -3103,1 +3102,1 @@\n-  if (java_super() != nullptr && !java_super()->can_be_verified_at_dumptime()) {\n+  if (super() != nullptr && !super()->can_be_verified_at_dumptime()) {\n@@ -3338,1 +3337,1 @@\n-  if (!is_shared()) {\n+  if (!in_aot_cache()) {\n@@ -3342,1 +3341,1 @@\n-  if (is_shared() && _package_entry != nullptr) {\n+  if (in_aot_cache() && _package_entry != nullptr) {\n@@ -3345,1 +3344,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache(_package_entry), \"must be\");\n@@ -4270,2 +4269,2 @@\n-    assert(this->is_shared(), \"must be\");\n-    if (MetaspaceShared::is_shared_dynamic((void*)this)) {\n+    assert(this->in_aot_cache(), \"must be\");\n+    if (MetaspaceShared::in_aot_cache_dynamic_region((void*)this)) {\n@@ -4285,1 +4284,1 @@\n-                       p2i(this),  p2i(superklass()));\n+                       p2i(this),  p2i(super()));\n@@ -4293,1 +4292,1 @@\n-                           p2i(InstanceKlass::cast(local_interfaces()->at(i))));\n+                           p2i(local_interfaces()->at(i)));\n@@ -4506,1 +4505,0 @@\n-\n@@ -4511,1 +4509,1 @@\n-JNIid::JNIid(Klass* holder, int offset, JNIid* next) {\n+JNIid::JNIid(InstanceKlass* holder, int offset, JNIid* next) {\n@@ -4518,1 +4516,0 @@\n-\n@@ -4536,2 +4533,1 @@\n-\n-void JNIid::verify(Klass* holder) {\n+void JNIid::verify(InstanceKlass* holder) {\n@@ -4540,1 +4536,1 @@\n-  end_field_offset = first_field_offset + (InstanceKlass::cast(holder)->static_field_size() * wordSize);\n+  end_field_offset = first_field_offset + (holder->static_field_size() * wordSize);\n@@ -4557,1 +4553,1 @@\n-  bool good_state = is_shared() ? (_init_state <= state)\n+  bool good_state = in_aot_cache() ? (_init_state <= state)\n@@ -4658,1 +4654,1 @@\n-      if (pvcp->is_shared()) {\n+      if (pvcp->in_aot_cache()) {\n@@ -4770,1 +4766,1 @@\n-  if (cp_ref->is_shared()) {\n+  if (cp_ref->in_aot_cache()) {\n@@ -4853,1 +4849,1 @@\n-    _current = _current->superklass(); \/\/ backtrack; no more sibling subclasses left\n+    _current = _current->java_super(); \/\/ backtrack; no more sibling subclasses left\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":68,"deletions":72,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -1028,0 +1028,6 @@\n+  \/\/ This hides Klass::super(). The _super of an InstanceKlass is\n+  \/\/ always an InstanceKlass (or nullptr)\n+  InstanceKlass* super() const {\n+    return (Klass::super() == nullptr) ? nullptr : InstanceKlass::cast(Klass::super());\n+  }\n+\n@@ -1029,1 +1035,1 @@\n-    return (super() == nullptr) ? nullptr : cast(super());\n+    return InstanceKlass::super();\n@@ -1120,1 +1126,1 @@\n-                                    const Klass* super_klass,\n+                                    const InstanceKlass* super_klass,\n@@ -1339,1 +1345,1 @@\n-  Klass*             _holder;\n+  InstanceKlass*     _holder;\n@@ -1348,1 +1354,1 @@\n-  Klass* holder() const           { return _holder; }\n+  InstanceKlass* holder() const   { return _holder; }\n@@ -1352,1 +1358,1 @@\n-  JNIid(Klass* holder, int offset, JNIid* next);\n+  JNIid(InstanceKlass* holder, int offset, JNIid* next);\n@@ -1366,1 +1372,1 @@\n-  void verify(Klass* holder);\n+  void verify(InstanceKlass* holder);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-      assert(klass->is_shared(), \"Must be\");\n+      assert(klass->in_aot_cache(), \"Must be\");\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -597,6 +597,0 @@\n-\/\/ superklass links\n-InstanceKlass* Klass::superklass() const {\n-  assert(super() == nullptr || super()->is_instance_klass(), \"must be instance klass\");\n-  return _super == nullptr ? nullptr : InstanceKlass::cast(_super);\n-}\n-\n@@ -665,2 +659,2 @@\n-  \/\/ add ourselves to superklass' subklass list\n-  InstanceKlass* super = superklass();\n+  \/\/ add ourselves to super' subklass list\n+  InstanceKlass* super = java_super();\n@@ -669,1 +663,1 @@\n-          && (super->superklass() == nullptr || !is_interface())),\n+          && (super->java_super() == nullptr || !is_interface())),\n@@ -678,1 +672,1 @@\n-      \/\/ set our sibling to be the superklass' previous first subklass\n+      \/\/ set our sibling to be the super' previous first subklass\n@@ -797,1 +791,1 @@\n-  set_is_shared();\n+  set_in_aot_cache();\n@@ -850,1 +844,1 @@\n-  assert(is_shared(), \"must be set\");\n+  assert(in_aot_cache(), \"must be set\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  u2     _shared_class_flags;\n+  u2 _shared_class_flags;\n@@ -183,1 +183,1 @@\n-    _is_shared_class                       = 1 << 0,  \/\/ shadows MetaspaceObj::is_shared\n+    _in_aot_cache                          = 1 << 0,\n@@ -224,1 +224,3 @@\n-  \/\/ If this is not what your code expects, you're probably looking for Klass::java_super().\n+  \/\/ If this is not what your code expects, you're probably looking for:\n+  \/\/ - Klass::java_super() - if you have a Klass*\n+  \/\/ - InstanceKlass::super() - if you have an InstanceKlass* ik, ik->super() returns InstanceKlass*.\n@@ -304,1 +306,0 @@\n-  InstanceKlass* superklass() const;\n@@ -384,2 +385,2 @@\n-  bool is_shared() const                { \/\/ shadows MetaspaceObj::is_shared)()\n-    CDS_ONLY(return (_shared_class_flags & _is_shared_class) != 0;)\n+  bool in_aot_cache() const                { \/\/ shadows MetaspaceObj::in_aot_cache)()\n+    CDS_ONLY(return (_shared_class_flags & _in_aot_cache) != 0;)\n@@ -389,2 +390,2 @@\n-  void set_is_shared() {\n-    CDS_ONLY(_shared_class_flags |= _is_shared_class;)\n+  void set_in_aot_cache() {\n+    CDS_ONLY(_shared_class_flags |= _in_aot_cache;)\n@@ -634,1 +635,1 @@\n-    assert(is_shared(), \"use this for shared classes only\");\n+    assert(in_aot_cache(), \"use this for shared classes only\");\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  return _klass->is_shared() && !MetaspaceShared::remapped_readwrite() && _klass->verified_at_dump_time();\n+  return _klass->in_aot_cache() && !MetaspaceShared::remapped_readwrite() && _klass->verified_at_dump_time();\n@@ -68,1 +68,1 @@\n-    GrowableArray<Method*>* all_mirandas, const Klass* super,\n+    GrowableArray<Method*>* all_mirandas, const InstanceKlass* super,\n@@ -166,1 +166,1 @@\n-  bool is_shared = _klass->is_shared();\n+  bool in_aot_cache = _klass->in_aot_cache();\n@@ -181,1 +181,1 @@\n-    assert(!is_shared, \"sanity\");\n+    assert(!in_aot_cache, \"sanity\");\n@@ -349,1 +349,1 @@\n-    superk = superk->super() == nullptr ? nullptr : InstanceKlass::cast(superk->super());\n+    superk = superk->super();\n@@ -634,1 +634,1 @@\n-                                         const Klass* super,\n+                                         const InstanceKlass* super,\n@@ -686,1 +686,1 @@\n-  const Klass* k = super;\n+  const InstanceKlass* ik = super;\n@@ -691,1 +691,1 @@\n-  while (k != nullptr) {\n+  while (ik != nullptr) {\n@@ -693,1 +693,1 @@\n-    super_method = InstanceKlass::cast(k)->lookup_method(name, signature);\n+    super_method = ik->lookup_method(name, signature);\n@@ -725,1 +725,1 @@\n-      k = superk->super(); \/\/ haven't found an override match yet; continue to look\n+      ik = superk->super(); \/\/ haven't found an override match yet; continue to look\n@@ -744,3 +744,2 @@\n-  const InstanceKlass *sk = InstanceKlass::cast(super);\n-  if (sk->has_miranda_methods()) {\n-    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n+  if (super->has_miranda_methods()) {\n+    if (super->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n@@ -840,1 +839,1 @@\n-                             Array<Method*>* default_methods, const Klass* super,\n+                             Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -869,6 +868,5 @@\n-  for (const Klass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super())\n-  {\n-     Method* found_mth = InstanceKlass::cast(cursuper)->find_local_method(name, signature,\n-                                                                          Klass::OverpassLookupMode::find,\n-                                                                          Klass::StaticLookupMode::skip,\n-                                                                          Klass::PrivateLookupMode::skip);\n+  for (const InstanceKlass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super()) {\n+     Method* found_mth = cursuper->find_local_method(name, signature,\n+                                                     Klass::OverpassLookupMode::find,\n+                                                     Klass::StaticLookupMode::skip,\n+                                                     Klass::PrivateLookupMode::skip);\n@@ -896,1 +894,1 @@\n-    Array<Method*>* default_methods, const Klass* super, bool is_interface) {\n+    Array<Method*>* default_methods, const InstanceKlass* super, bool is_interface) {\n@@ -916,1 +914,0 @@\n-        const InstanceKlass *sk = InstanceKlass::cast(super);\n@@ -918,1 +915,1 @@\n-        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n+        if (super->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n@@ -931,1 +928,1 @@\n-                               const Klass* super,\n+                               const InstanceKlass* super,\n@@ -1095,1 +1092,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace((void*)&_method) &&\n+  if (MetaspaceShared::in_aot_cache((void*)&_method) &&\n@@ -1281,1 +1278,1 @@\n-               m->is_shared(),\n+               m->in_aot_cache(),\n@@ -1589,2 +1586,1 @@\n-    InstanceKlass* sk = InstanceKlass::cast(super);\n-    klassVtable vt = sk->vtable();\n+    klassVtable vt = super->vtable();\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                                                   const Klass* super,\n+                                                   const InstanceKlass* super,\n@@ -119,1 +119,1 @@\n-                                     const Klass* super,\n+                                     const InstanceKlass* super,\n@@ -138,1 +138,1 @@\n-                         Array<Method*>* default_methods, const Klass* super,\n+                         Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -146,1 +146,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n@@ -151,1 +151,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -155,0 +155,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::throw_AbstractMethodError_entry();\n+  }\n@@ -160,0 +163,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  }\n@@ -455,1 +461,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n+  if (in_aot_cache() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n@@ -466,1 +472,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n+  if (in_aot_cache() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n@@ -1239,1 +1245,1 @@\n-  if (!CDSConfig::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+  if (!CDSConfig::is_dumping_adapters()) {\n@@ -1292,1 +1298,1 @@\n-    if (adapter()->is_shared()) {\n+    if (adapter()->in_aot_cache()) {\n@@ -1327,1 +1333,6 @@\n-  if (_adapter == nullptr) {\n+  if (is_abstract()) {\n+    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+    h_method->_from_compiled_entry = wrong_method_abstract;\n+    h_method->_from_compiled_inline_entry = wrong_method_abstract;\n+    h_method->_from_compiled_inline_ro_entry = wrong_method_abstract;\n+  } else if (_adapter == nullptr) {\n@@ -1330,0 +1341,3 @@\n+    h_method->_from_compiled_entry = adapter()->get_c2i_entry();\n+    h_method->_from_compiled_inline_entry = adapter()->get_c2i_inline_entry();\n+    h_method->_from_compiled_inline_ro_entry = adapter()->get_c2i_inline_ro_entry();\n@@ -1350,0 +1364,1 @@\n+  assert(!mh->is_abstract(), \"abstract methods do not have adapters\");\n@@ -1368,3 +1383,0 @@\n-  mh->_from_compiled_entry = adapter->get_c2i_entry();\n-  mh->_from_compiled_inline_entry = adapter->get_c2i_inline_entry();\n-  mh->_from_compiled_inline_ro_entry = adapter->get_c2i_inline_ro_entry();\n@@ -2234,1 +2246,1 @@\n-  } else if (m->is_shared()) {\n+  } else if (m->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,27 @@\n+  \/\/ Notes on copy constructor, copy assignment operator, and copy_from().\n+  \/\/ These are necessary for generating deterministic CDS archives.\n+  \/\/\n+  \/\/ We have some unused padding on 64-bit platforms (4 bytes at the tail end).\n+  \/\/\n+  \/\/ When ResolvedFieldEntries in a ConstantPoolCache are allocated from the metaspace,\n+  \/\/ their entire content (including the padding) is filled with zeros. They are\n+  \/\/ then initialized with initialize_resolved_entries_array() in cpCache.cpp from a\n+  \/\/ GrowableArray.\n+  \/\/\n+  \/\/ The GrowableArray is initialized in rewriter.cpp, using ResolvedFieldEntries that\n+  \/\/ are originally allocated from the C++ stack. Functions like GrowableArray::expand_to()\n+  \/\/ will also allocate ResolvedFieldEntries from the stack. These may have random bits\n+  \/\/ in the padding as the C++ compiler is allowed to leave the padding in uninitialized\n+  \/\/ states.\n+  \/\/\n+  \/\/ If we use the default copy constructor and\/or default copy assignment operator,\n+  \/\/ the random padding will be copied into the GrowableArray, from there\n+  \/\/ to the ConstantPoolCache, and eventually to the CDS archive. As a result, the\n+  \/\/ CDS archive will contain random bits, causing failures in\n+  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java (usually on Windows).\n+  \/\/\n+  \/\/ By using copy_from(), we can prevent the random padding from being copied,\n+  \/\/ ensuring that the ResolvedFieldEntries in a ConstantPoolCache (and thus the\n+  \/\/ CDS archive) will have all zeros in the padding.\n+\n+  \/\/ Copy constructor\n@@ -87,0 +114,1 @@\n+  \/\/ Copy assignment operator\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,3 @@\n+  \/\/ The copy_from() pattern in resolvedFieldEntry.hpp is not necessary\n+  \/\/ as we have no unused padding (on 32- or 64-bit platforms).\n+\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,2 @@\n+  \/\/ See comments in resolvedFieldEntry.hpp about copy_from and padding.\n+  \/\/ We have unused padding on debug builds.\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  if (TrainingData::have_data()) {\n+  if (TrainingData::have_data() && !TrainingData::assembling_data()) {\n@@ -101,3 +101,15 @@\n-        mtd->verify();\n-      } else if (td->is_CompileTrainingData()) {\n-        td->as_CompileTrainingData()->verify();\n+        mtd->verify(\/*verify_dep_counter*\/true);\n+      }\n+    });\n+  }\n+  if (TrainingData::need_data()) {\n+    TrainingDataLocker l;\n+    training_data_set()->iterate([&](TrainingData* td) {\n+      if (td->is_KlassTrainingData()) {\n+        KlassTrainingData* ktd = td->as_KlassTrainingData();\n+        ktd->verify();\n+      } else if (td->is_MethodTrainingData()) {\n+        MethodTrainingData* mtd = td->as_MethodTrainingData();\n+        \/\/ During the training run init deps tracking is not setup yet,\n+        \/\/ don't verify it.\n+        mtd->verify(\/*verify_dep_counter*\/false);\n@@ -232,1 +244,1 @@\n-void CompileTrainingData::dec_init_deps_left(KlassTrainingData* ktd) {\n+void CompileTrainingData::dec_init_deps_left_release(KlassTrainingData* ktd) {\n@@ -453,1 +465,1 @@\n-    comp_dep(i)->dec_init_deps_left(this);\n+    comp_dep(i)->dec_init_deps_left_release(this);\n@@ -479,0 +491,1 @@\n+  }\n@@ -480,3 +493,2 @@\n-    if (AOTVerifyTrainingData) {\n-      training_data_set()->verify();\n-    }\n+  if (AOTVerifyTrainingData) {\n+    TrainingData::verify();\n@@ -595,12 +607,3 @@\n-void MethodTrainingData::verify() {\n-  iterate_compiles([](CompileTrainingData* ctd) {\n-    ctd->verify();\n-\n-    int init_deps_left1 = ctd->init_deps_left();\n-    int init_deps_left2 = ctd->compute_init_deps_left();\n-\n-    if (init_deps_left1 != init_deps_left2) {\n-      ctd->print_on(tty); tty->cr();\n-    }\n-    guarantee(init_deps_left1 == init_deps_left2, \"mismatch: %d %d %d\",\n-              init_deps_left1, init_deps_left2, ctd->init_deps_left());\n+void MethodTrainingData::verify(bool verify_dep_counter) {\n+  iterate_compiles([&](CompileTrainingData* ctd) {\n+    ctd->verify(verify_dep_counter);\n@@ -610,1 +613,1 @@\n-void CompileTrainingData::verify() {\n+void CompileTrainingData::verify(bool verify_dep_counter) {\n@@ -627,0 +630,12 @@\n+\n+  if (verify_dep_counter) {\n+    int init_deps_left1 = init_deps_left_acquire();\n+    int init_deps_left2 = compute_init_deps_left();\n+\n+    bool invariant = (init_deps_left1 >= init_deps_left2);\n+    if (!invariant) {\n+      print_on(tty);\n+      tty->cr();\n+    }\n+    guarantee(invariant, \"init deps invariant violation: %d >= %d\", init_deps_left1, init_deps_left2);\n+  }\n@@ -693,1 +708,1 @@\n-  return k->meta() == nullptr || MetaspaceObj::is_shared(k->meta());\n+  return k->meta() == nullptr || MetaspaceObj::in_aot_cache(k->meta());\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":38,"deletions":23,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  \/\/ It is also a part of the TD collection termination protocol (see the \"spanshot\" field).\n+  \/\/ It is also a part of the TD collection termination protocol (see the \"snapshot\" field).\n@@ -108,1 +108,1 @@\n-        TrainingData_lock->lock();\n+        TrainingData_lock->lock_without_safepoint_check();\n@@ -676,3 +676,3 @@\n-  void dec_init_deps_left(KlassTrainingData* ktd);\n-  int init_deps_left() const {\n-    return Atomic::load(&_init_deps_left);\n+  void dec_init_deps_left_release(KlassTrainingData* ktd);\n+  int init_deps_left_acquire() const {\n+    return Atomic::load_acquire(&_init_deps_left);\n@@ -710,1 +710,1 @@\n-  void verify();\n+  void verify(bool verify_dep_counter);\n@@ -831,1 +831,1 @@\n-  void verify();\n+  void verify(bool verify_dep_counter);\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -362,0 +362,9 @@\n+  product(bool, UseAutoVectorizationPredicate, true, DIAGNOSTIC,            \\\n+          \"Use AutoVectorization predicate (for speculative compilation)\")  \\\n+                                                                            \\\n+  product(bool, UseAutoVectorizationSpeculativeAliasingChecks, true, DIAGNOSTIC, \\\n+          \"Allow the use Multiversioning or Predicate to add aliasing\"      \\\n+          \"runtime checks. Runtime checks will only be inserted if either\"  \\\n+          \"LoopMultiversioning or UseAutoVectorizationPredicate are\"        \\\n+          \"enabled.\")                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4648,1 +4648,3 @@\n-  add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  if (UseAutoVectorizationPredicate) {\n+    add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -643,2 +643,2 @@\n-        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), \"%d\", value);\n-        if (written_chars <= 4) {\n+        int written_chars = os::snprintf(buffer, sizeof(buffer), \"%d\", value);\n+        if (written_chars > 0 && written_chars <= 4) {\n@@ -657,2 +657,2 @@\n-        int written_chars = os::snprintf_checked(buffer, sizeof(buffer), JLONG_FORMAT, value);\n-        if (written_chars <= 4) {\n+        int written_chars = os::snprintf(buffer, sizeof(buffer), JLONG_FORMAT, value);\n+        if (written_chars > 0 && written_chars <= 4) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -665,0 +665,2 @@\n+\/\/ For more descriptions on multiversioning:\n+\/\/ See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/c2_globals.hpp\"\n@@ -1136,5 +1137,7 @@\n-    \/\/ We only want to use the auto-vectorization check as a trap once per bci. And\n-    \/\/ PhaseIdealLoop::add_parse_predicate only checks trap limits per method, so\n-    \/\/ we do a custom check here.\n-    if (!C->too_many_traps(cloned_sfpt->jvms()->method(), cloned_sfpt->jvms()->bci(), Deoptimization::Reason_auto_vectorization_check)) {\n-      add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, inner_head, outer_ilt, cloned_sfpt);\n+    if (UseAutoVectorizationPredicate) {\n+      \/\/ We only want to use the auto-vectorization check as a trap once per bci. And\n+      \/\/ PhaseIdealLoop::add_parse_predicate only checks trap limits per method, so\n+      \/\/ we do a custom check here.\n+      if (!C->too_many_traps(cloned_sfpt->jvms()->method(), cloned_sfpt->jvms()->bci(), Deoptimization::Reason_auto_vectorization_check)) {\n+        add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, inner_head, outer_ilt, cloned_sfpt);\n+      }\n@@ -4645,0 +4648,3 @@\n+  if (UseAutoVectorizationPredicate && predicates.auto_vectorization_check_block()->is_non_empty()) {\n+    tty->print(\" auto_vectorization_check_predicate\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  assert(_raw_summands.is_empty(), \"no prior parsing\");\n@@ -49,0 +50,8 @@\n+#ifndef PRODUCT\n+  if (trace.is_trace_parsing()) {\n+    tty->print_cr(\"MemPointerParser::parse: size=%d\", size);\n+    tty->print(\"  mem:     \"); _mem->dump();\n+    tty->print(\"  pointer: \"); pointer->dump();\n+  }\n+#endif\n+\n@@ -50,1 +59,1 @@\n-  _worklist.push(MemPointerSummand(pointer, NoOverflowInt(1)));\n+  _worklist.push(MemPointerRawSummand::make_trivial(pointer));\n@@ -63,3 +72,61 @@\n-  \/\/ Bail out if there is a constant overflow.\n-  if (_con.is_NaN()) {\n-    return MemPointer::make_trivial(pointer, size NOT_PRODUCT(COMMA trace));\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerRawSummand::print_on(tty, _raw_summands); } )\n+  canonicalize_raw_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerRawSummand::print_on(tty, _raw_summands); } )\n+\n+  create_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerSummand::print_on(tty, _con, _summands); } )\n+  canonicalize_summands();\n+  NOT_PRODUCT( if (trace.is_trace_parsing()) { MemPointerSummand::print_on(tty, _con, _summands); } )\n+\n+  return MemPointer::make(pointer, _raw_summands, _con, _summands, size NOT_PRODUCT(COMMA trace));\n+}\n+\n+void MemPointerParser::canonicalize_raw_summands() {\n+  \/\/ We sort by:\n+  \/\/  - int group id\n+  \/\/  - variable idx\n+  \/\/ This means that summands of the same int group with the same variable are consecutive.\n+  \/\/ This simplifies the combining of summands below.\n+  _raw_summands.sort(MemPointerRawSummand::cmp_by_int_group_and_variable_idx);\n+\n+  \/\/ Combine summands of the same int group with the same variable, adding up the scales.\n+  int pos_put = 0;\n+  int pos_get = 0;\n+  while (pos_get < _raw_summands.length()) {\n+    const MemPointerRawSummand& summand = _raw_summands.at(pos_get++);\n+    Node* variable      = summand.variable();\n+    NoOverflowInt scaleI = summand.scaleI();\n+    NoOverflowInt scaleL = summand.scaleL();\n+    int int_group = summand.int_group();\n+    \/\/ Add up scale of all summands with the same variable.\n+    while (pos_get < _raw_summands.length() &&\n+           _raw_summands.at(pos_get).int_group() == int_group &&\n+           _raw_summands.at(pos_get).variable() == variable) {\n+      MemPointerRawSummand s = _raw_summands.at(pos_get++);\n+      if (int_group == 0) {\n+        assert(scaleI.is_one() && s.scaleI().is_one(), \"no ConvI2L\");\n+        scaleL = scaleL + s.scaleL();\n+      } else {\n+        assert(scaleL.value() == s.scaleL().value(), \"same ConvI2L, same scaleL\");\n+        scaleI = scaleI + s.scaleI();\n+      }\n+    }\n+    \/\/ Keep summands with non-zero scale.\n+    if (!scaleI.is_zero() && !scaleL.is_NaN()) {\n+      _raw_summands.at_put(pos_put++, MemPointerRawSummand(variable, scaleI, scaleL, int_group));\n+    }\n+  }\n+  _raw_summands.trunc_to(pos_put);\n+}\n+\n+void MemPointerParser::create_summands() {\n+  assert(_con.is_zero(), \"no prior parsing\");\n+  assert(_summands.is_empty(), \"no prior parsing\");\n+\n+  for (int i = 0; i < _raw_summands.length(); i++) {\n+    const MemPointerRawSummand& raw_summand = _raw_summands.at(i);\n+    if (raw_summand.is_con()) {\n+      _con = _con + raw_summand.to_con();\n+    } else {\n+      _summands.push(raw_summand.to_summand());\n+    }\n@@ -67,0 +134,1 @@\n+}\n@@ -68,0 +136,1 @@\n+void MemPointerParser::canonicalize_summands() {\n@@ -84,4 +153,0 @@\n-    \/\/ Bail out if scale is NaN.\n-    if (scale.is_NaN()) {\n-      return MemPointer::make_trivial(pointer, size NOT_PRODUCT(COMMA trace));\n-    }\n@@ -94,2 +159,0 @@\n-\n-  return MemPointer::make(pointer, _summands, _con, size NOT_PRODUCT(COMMA trace));\n@@ -101,1 +164,1 @@\n-void MemPointerParser::parse_sub_expression(const MemPointerSummand& summand, MemPointerParserCallback& callback) {\n+void MemPointerParser::parse_sub_expression(const MemPointerRawSummand& summand, MemPointerParserCallback& callback) {\n@@ -103,1 +166,3 @@\n-  const NoOverflowInt scale = summand.scale();\n+  const NoOverflowInt scaleI = summand.scaleI();\n+  const NoOverflowInt scaleL = summand.scaleL();\n+  const int int_group = summand.int_group();\n@@ -107,1 +172,1 @@\n-  if (is_safe_to_decompose_op(opc, scale)) {\n+  if (is_safe_to_decompose_op(opc, scaleI * scaleL)) {\n@@ -112,1 +177,1 @@\n-        \/\/ Terminal: add to constant.\n+        \/\/ Terminal summand.\n@@ -115,1 +180,3 @@\n-        _con = _con + scale * con;\n+        NoOverflowInt conI = (int_group == 0) ? scaleI : scaleI * con;\n+        NoOverflowInt conL = (int_group == 0) ? scaleL * con : scaleL;\n+        _raw_summands.push(MemPointerRawSummand::make_con(conI, conL, int_group));\n@@ -125,2 +192,2 @@\n-        _worklist.push(MemPointerSummand(a, scale));\n-        _worklist.push(MemPointerSummand(b, scale));\n+        _worklist.push(MemPointerRawSummand(a, scaleI, scaleL, int_group));\n+        _worklist.push(MemPointerRawSummand(b, scaleI, scaleL, int_group));\n@@ -137,1 +204,3 @@\n-        NoOverflowInt sub_scale = NoOverflowInt(-1) * scale;\n+        \/\/                   int_group  x.scaleI  x.scaleL  y.scaleI  y.scaleL\n+        \/\/ 2L * (x - y)      0          1         2         1         -2\n+        \/\/ ConvI2L(x - y)    1          1         1         -1        1\n@@ -139,2 +208,5 @@\n-        _worklist.push(MemPointerSummand(a, scale));\n-        _worklist.push(MemPointerSummand(b, sub_scale));\n+        NoOverflowInt sub_scaleI = (int_group == 0) ? scaleI : scaleI * NoOverflowInt(-1);\n+        NoOverflowInt sub_scaleL = (int_group == 0) ? scaleL * NoOverflowInt(-1) : scaleL;\n+\n+        _worklist.push(MemPointerRawSummand(a,     scaleI,     scaleL, int_group));\n+        _worklist.push(MemPointerRawSummand(b, sub_scaleI, sub_scaleL, int_group));\n@@ -172,2 +244,6 @@\n-        \/\/ Accumulate scale.\n-        NoOverflowInt new_scale = scale * factor;\n+        \/\/                         int_group  x.scaleI  x.scaleL\n+        \/\/ 2L * (4L * x)           0          1         8\n+        \/\/ 2L * ConvI2L(4 * x)     1          4         2\n+\n+        NoOverflowInt mul_scaleI = (int_group == 0) ? scaleI : scaleI * factor;\n+        NoOverflowInt mul_scaleL = (int_group == 0) ? scaleL * factor : scaleL;\n@@ -175,1 +251,1 @@\n-        _worklist.push(MemPointerSummand(variable, new_scale));\n+        _worklist.push(MemPointerRawSummand(variable, mul_scaleI, mul_scaleL, int_group));\n@@ -203,1 +279,10 @@\n-          _worklist.push(MemPointerSummand(a, scale));\n+\n+          int cast_int_group = int_group;\n+#ifdef _LP64\n+          if (opc == Op_ConvI2L) {\n+            assert(int_group == 0, \"only find ConvI2L once\");\n+            \/\/ We just discovered a new ConvI2L, and this creates a new \"int group\".\n+            cast_int_group = _next_int_group++;\n+          }\n+#endif\n+          _worklist.push(MemPointerRawSummand(a, scaleI, scaleL, cast_int_group));\n@@ -215,1 +300,1 @@\n-  _summands.push(summand);\n+  _raw_summands.push(summand);\n@@ -621,0 +706,52 @@\n+\/\/ Examples:\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 17]\n+\/\/   -> Always at distance 1\n+\/\/   -> Can never overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 16]\n+\/\/   -> Always at distance 0\n+\/\/   -> Always have exact overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=4, x + y + z + 4L * i + 56]\n+\/\/   -> Always at distance 40\n+\/\/   -> Can never overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=8, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=8, x + y + z + 4L * i + 20]\n+\/\/   -> Always at distance 4\n+\/\/   -> Always have partial overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, base1 + 4L * i1 + 16]\n+\/\/   p2 = MemPointer[size=4, base2 + 4L * i2 + 20]\n+\/\/   -> Have differing summands, distance is unknown\n+\/\/   -> Unknown if overlap at runtime -> return false\n+bool MemPointer::always_overlaps_with(const MemPointer& other) const {\n+  const MemPointerAliasing aliasing = get_aliasing_with(other NOT_PRODUCT( COMMA _trace ));\n+\n+  \/\/ The aliasing tries to compute:\n+  \/\/   distance = other - this\n+  \/\/\n+  \/\/ We know that we have an overlap if we can prove:\n+  \/\/   this < other + other.size       &&  this + this.size > other\n+  \/\/\n+  \/\/ Which we can restate as:\n+  \/\/   distance > -other.size          &&  this.size > distance\n+  \/\/\n+  const jint distance_lo = -other.size();\n+  const jint distance_hi = size();\n+  bool is_always_overlap = aliasing.is_always_in_distance_range(distance_lo, distance_hi);\n+\n+#ifndef PRODUCT\n+  if (_trace.is_trace_overlap()) {\n+    tty->print(\"Always Overlap: %s, distance_lo: %d, distance_hi: %d, aliasing: \",\n+               is_always_overlap ? \"true\" : \"false\", distance_lo, distance_hi);\n+    aliasing.print_on(tty);\n+    tty->cr();\n+  }\n+#endif\n+\n+  return is_always_overlap;\n+}\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":162,"deletions":25,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+\/\/ A more advanced use case of MemPointers is speculative aliasing analysis. If we can prove that\n+\/\/ the MemPointer has a linear form in the loop induction variable (iv), we can formulate runtime\n+\/\/ checks to establish that two MemPointer never overlap for all iterations, i.e. for all iv values.\n+\/\/\n@@ -161,1 +165,1 @@\n-\/\/   Where each summand_i in summands has the form:\n+\/\/   Where each summand_i in summands has the MemPointerSummand form:\n@@ -270,0 +274,4 @@\n+\/\/   Even further down, we prove the \"MemPointer Linearity Corrolary\", where we show that\n+\/\/   (under reasonable restrictions) both the MemPointer and the corresponding pointer\n+\/\/   can be considered linear functions.\n+\/\/\n@@ -388,1 +396,97 @@\n-\n+\/\/\n+\/\/\n+\/\/ Having proven the \"MemPointer Lemma\", we can now derive an interesting corrolary.\n+\/\/\n+\/\/ With the \"Linearity Corrolary\" below, we can prove that some MemPointers can be treated as\n+\/\/ linear in some summand variable v over some range r. This is useful when MemPointers are\n+\/\/ used in loops, where v=iv scale_v=scale_iv and the range is the iv range from some initial\n+\/\/ iv value to the last iv value just before the limit.\n+\/\/ For an application, see: VPointer::make_speculative_aliasing_check_with\n+\/\/\n+\/\/ MemPointer Linearity Corrolary:\n+\/\/   Given:\n+\/\/     (C0) pointer p and its MemPointer mp, which is constructed with safe decompositions.\n+\/\/     (C1) a specific summand \"scale_v * v\" that occurs in mp.\n+\/\/     (C2) a strided range r = [lo, lo + stride_v, .. hi] for v (lo and hi are inclusive in the range).\n+\/\/     (C3) for all v in this strided range r we know that p is within bounds of its memory object.\n+\/\/     (C4) abs(scale_v * stride_v) < 2^31\n+\/\/            Required for (S2) in application of MemPointer Lemma below, it is essencial in\n+\/\/            establishing linearity of mp.\n+\/\/\n+\/\/   Then:\n+\/\/     Both p and mp have a linear form for v in r:\n+\/\/       p(v)  = p(lo)  - lo * scale_v + v * scale_v              (Corrolary P)\n+\/\/       mp(v) = mp(lo) - lo * scale_v + v * scale_v              (Corrolary MP)\n+\/\/\n+\/\/     Note: the calculations are done in long, and hence there can be no int overflow.\n+\/\/           Thus, p(v) and mp(v) can be considered linear functions for v in r.\n+\/\/\n+\/\/   It can be useful to \"anchor\" at hi instead of lo:\n+\/\/     p(hi) = p(lo) - lo * scale_v + hi * scale_v\n+\/\/\n+\/\/     p(v) = p(lo) - lo * scale_v + v * scale_v\n+\/\/            --------------------\n+\/\/          = p(hi) - hi * scale_v + v * scale_v             (Alternative Corrolary P)\n+\/\/\n+\/\/\n+\/\/ Proof of \"MemPointer Linearity Corrolary\":\n+\/\/   We state the form of mp:\n+\/\/\n+\/\/     mp = summand_rest + scale_v * v + con\n+\/\/\n+\/\/   We prove the Corrolary by induction over v:\n+\/\/   Base Case: v = lo\n+\/\/     p(lo)  = p(lo)  - lo * scale_v + lo * scale_v\n+\/\/     mp(lo) = mp(lo) - lo * scale_v + lo * scale_v\n+\/\/\n+\/\/   Step Case: v0 and v1 in r, v1 = v0 + stride_v\n+\/\/     Assume:\n+\/\/       p(v0)  = p(lo)  - lo * scale_v + v * scale_v          (Induction Hypothesis IH-P)\n+\/\/       mp(v0) = mp(lo) - lo * scale_v + v * scale_v          (Induction Hypothesis IH-MP)\n+\/\/\n+\/\/     We take the form of mp, and further apply SAFE1 decompositions, i.e. long addition,\n+\/\/     subtraction and multiplication:\n+\/\/       mp(v1) = summand_rest + scale_v * v1                                   + con\n+\/\/              = summand_rest + scale_v * (v0 + stride_v)                      + con\n+\/\/              = summand_rest + scale_v * v0              + scale_v * stride_v + con\n+\/\/              = mp(v0)                                   + scale_v * stride_v\n+\/\/\n+\/\/     From this it follows that we can see mp(v0) and mp(v1) as two MemPointer with the\n+\/\/     same summands, and only their constants differ by exactly \"scale_v * stride_v\":\n+\/\/       mp(v0) = summand_rest + scale_v * v0 + con\n+\/\/       mp(v1) = summand_rest + scale_v * v0 + con + scale_v * stride_v            (MP-DIFF)\n+\/\/\n+\/\/     We continue by applying the Induction Hypothesis IH-MP\n+\/\/       mp(v1) = mp(v0)                                + scale_v * stride_v\n+\/\/                -------- apply (IH-MP) -------------\n+\/\/              = mp(lo) - lo * scale_v + v0 * scale_v  + scale_v * stride_v\n+\/\/              = mp(lo) - lo * scale_v + (v0 + stride_v) * scale_v\n+\/\/              = mp(lo) - lo * scale_v + v1 * scale_v\n+\/\/\n+\/\/     This proves the Corrolary MP.\n+\/\/\n+\/\/     To prove the Corrolary P, we now apply the MemPointer Lemma:\n+\/\/       (S0) Let p(v0) and p(v1) be the pointers corresponding to v0 and v1, and mp(v0) and mp(v1)\n+\/\/            their MemPointer. (C0) provides the safe deconstruction, and reformulation of terms\n+\/\/            happens with long addition, subtraction and multiplication only, and is hence SAFE\n+\/\/            as well.\n+\/\/       (S1) According to (C3), p is in bounds of its memory object for all v in r. Since v0 and\n+\/\/            v1 are in r, it follows that p(v0) and p(v1) are in bounds of the same memory object.\n+\/\/       (S2) The difference of constants of mp(v0) and mp(v1) is exactly \"scale_v * stride_v\" (MP-DIFF).\n+\/\/            Given (C4), this difference is not too large.\n+\/\/       (S3) All summands of mp0 and mp1 are the same (only the constants differ), given (MP-DIFF).\n+\/\/\n+\/\/     It follows:\n+\/\/       p(v1) - p(v0) = mp(v1) - mp(v0)\n+\/\/\n+\/\/     Reformulating and applying (MP-DIFF) and (IH-P):\n+\/\/       p(v1) = p(v0)                                  + mp(v1) - mp(v1)\n+\/\/                                                        apply (MP-DIFF)\n+\/\/             = p(v0)                                  + scale_v * stride_v\n+\/\/               ------------ apply (IH-P) ------------\n+\/\/             = p(lo) - lo * scale_v + v0 * scale_v    + scale_v * stride_v\n+\/\/             = p(lo) - lo * scale_v + (v0 + stride_v) * scale_v\n+\/\/             = p(lo) - lo * scale_v + v1 * scale_v\n+\/\/\n+\/\/     This proves Corrolary P.\n+\/\/\n@@ -469,0 +573,7 @@\n+  \/\/ Use case: overlap.\n+  \/\/ Note: the bounds are exclusive: lo < element < hi\n+  bool is_always_in_distance_range(const jint distance_lo, const jint distance_hi) const {\n+    return _aliasing == AlwaysAtDistance &&\n+           (distance_lo < _distance && _distance < distance_hi);\n+  }\n+\n@@ -543,1 +654,161 @@\n-    tty->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+    st->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+  }\n+\n+  static void print_on(outputStream* st, NoOverflowInt con, const GrowableArray<MemPointerSummand>& summands) {\n+    st->print(\"Summands (%d): con(\", summands.length());\n+    con.print_on(st);\n+    st->print(\")\");\n+    for (int i = 0; i < summands.length(); i++) {\n+      st->print(\" + \");\n+      summands.at(i).print_on(tty);\n+    }\n+    st->cr();\n+  }\n+#endif\n+};\n+\n+\/\/ We need two different ways of tracking the summands:\n+\/\/ - MemPointerRawSummand: designed to keep track of the original form of\n+\/\/                         the pointer, preserving its overflow behavior.\n+\/\/ - MemPointerSummand:    designed to allow simplification of the MemPointer\n+\/\/                         form, does not preserve the original form and\n+\/\/                         ignores overflow from ConvI2L.\n+\/\/\n+\/\/ The MemPointerSummand is designed to allow the simplification of\n+\/\/ the MemPointer form as much as possible, to allow aliasing checks\n+\/\/ to be as simple as possible. For example, the C2 IR pointer:\n+\/\/\n+\/\/   pointer = AddP(\n+\/\/               AddP(\n+\/\/                 base,\n+\/\/                 LShiftL(\n+\/\/                   ConvI2L(\n+\/\/                     AddI(AddI(i, LShiftI(j, 2)), con1)\n+\/\/                   ),\n+\/\/                   1\n+\/\/                 )\n+\/\/               ),\n+\/\/               con2\n+\/\/             )\n+\/\/\n+\/\/ and more readable:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i + 4 * j + con1) + con2\n+\/\/\n+\/\/ is simplified to this MemPointer form, using only MemPointerSummands,\n+\/\/ which ignore the possible overflow in ConvI2L:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i) + 8L * ConvI2L(j) + con\n+\/\/   con = 2L * con1 + con2\n+\/\/\n+\/\/ This is really convenient, because this way we are able to ignore\n+\/\/ the ConvI2L in the aliasing anaylsis computation, and we can collect\n+\/\/ all constants to a single constant. Even with this simplicication,\n+\/\/ we are able to prove the correctness of the aliasing checks.\n+\/\/\n+\/\/ However, there is one thing we are not able to do with this simplification:\n+\/\/ we cannot reconstruct the original pointer expression, because the\n+\/\/ simplification ignores overflows that could happen inside the ConvI2L:\n+\/\/\n+\/\/   2L * ConvI2L(i + 4 * j + con1) != 2L * ConvI2L(i) + 8L * ConvI2L(j) + 2L * con1\n+\/\/\n+\/\/ The MemPointerRawSummand is designed to keep track of the original form\n+\/\/ of the pointer, preserving its overflow behaviour. We observe that the\n+\/\/ only critical point for overflows is at the ConvI2L. Thus, we give each\n+\/\/ ConvI2L a \"int group\" id > 0, and all raw summands belonging to that ConvI2L\n+\/\/ have that id. This allows us to reconstruct which raw summands need to\n+\/\/ be added together before the ConvI2L. Any raw summands that do not belong\n+\/\/ to a ConvI2L (i.e. the summands with long variables) have \"int group\"\n+\/\/ id = 0, since they do not belong to any such \"int group\" and can be\n+\/\/ directly added together. For raw summands belonging to an \"int group\",\n+\/\/ we need to track the scale inside (scaleI) and outside (scaleL) the\n+\/\/ ConvI2L. With the example from above:\n+\/\/\n+\/\/   pointer = base + 2L * ConvI2L(i + 4 * j + con1) + con2\n+\/\/\n+\/\/   _variable  = base  _variable  = i  _variable  = j  _variable  = null  _variable  = null\n+\/\/   _scaleI    = 1     _scaleI    = 1  _scaleI    = 4  _scaleI    = con1  _scaleI    = 1\n+\/\/   _scaleL    = 1     _scaleL    = 2  _scaleL    = 2  _scaleL    = 2     _scaleL    = con2\n+\/\/   _int_group = 0     _int_group = 1  _int_group = 1  _int_group = 1     _int_group = 0\n+\/\/\n+\/\/ Note: we also need to track constants as separate raw summands. For\n+\/\/       this, we say that a raw summand tracks a constant iff _variable == null,\n+\/\/       and we store the constant value in _scaleI (for int constant) and in\n+\/\/       _scaleL (for long constants).\n+\/\/\n+class MemPointerRawSummand : public StackObj {\n+private:\n+  Node* _variable;\n+  NoOverflowInt _scaleI;\n+  NoOverflowInt _scaleL;\n+  int _int_group;\n+\n+public:\n+  MemPointerRawSummand(Node* variable, NoOverflowInt scaleI, NoOverflowInt scaleL, int int_group) :\n+    _variable(variable), _scaleI(scaleI), _scaleL(scaleL), _int_group(int_group) {}\n+\n+  MemPointerRawSummand() :\n+    MemPointerRawSummand(nullptr, NoOverflowInt::make_NaN(), NoOverflowInt::make_NaN(), -1) {}\n+\n+  static MemPointerRawSummand make_trivial(Node* variable) {\n+    assert(variable != nullptr, \"must have variable\");\n+    return MemPointerRawSummand(variable, NoOverflowInt(1), NoOverflowInt(1), 0);\n+  }\n+\n+  static MemPointerRawSummand make_con(NoOverflowInt scaleI, NoOverflowInt scaleL, int int_group) {\n+    return MemPointerRawSummand(nullptr, scaleI, scaleL, int_group);\n+  }\n+\n+  bool is_valid() const { return _int_group >= 0; }\n+  bool is_con() const { assert(is_valid(), \"\"); return _variable == nullptr; }\n+  Node* variable() const { assert(is_valid(), \"\"); return _variable; }\n+  NoOverflowInt scaleI() const { assert(is_valid(), \"\"); return _scaleI; }\n+  NoOverflowInt scaleL() const { assert(is_valid(), \"\"); return _scaleL; }\n+  int int_group() const { assert(is_valid(), \"\"); return _int_group; }\n+\n+  MemPointerSummand to_summand() const {\n+    assert(!is_con(), \"must be variable\");\n+    return MemPointerSummand(variable(), scaleL() * scaleI());\n+  }\n+\n+  NoOverflowInt to_con() const {\n+    assert(is_con(), \"must be constant\");\n+    return scaleL() * scaleI();\n+  }\n+\n+  static int cmp_by_int_group_and_variable_idx(MemPointerRawSummand* p1, MemPointerRawSummand* p2) {\n+    int int_group_diff = p1->int_group() - p2->int_group();\n+    if (int_group_diff != 0) { return int_group_diff; }\n+\n+    if (p1->is_con()) {\n+      return p2->is_con() ? 0 : 1;\n+    }\n+    if (p2->is_con()) {\n+      return -1;\n+    }\n+    return p1->variable()->_idx - p2->variable()->_idx;\n+  }\n+\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const {\n+    if (!is_valid()) {\n+      st->print(\"<invalid>\");\n+    } else {\n+      st->print(\"<%d: \", _int_group);\n+      _scaleL.print_on(st);\n+      st->print(\" * \");\n+      _scaleI.print_on(st);\n+      if (!is_con()) {\n+        st->print(\" * [%d %s]\", _variable->_idx, _variable->Name());\n+      }\n+      st->print(\">\");\n+    }\n+  }\n+\n+  static void print_on(outputStream* st, const GrowableArray<MemPointerRawSummand>& summands) {\n+    st->print(\"Raw Summands (%d): \", summands.length());\n+    for (int i = 0; i < summands.length(); i++) {\n+      if (i > 0) { st->print(\" + \"); }\n+      summands.at(i).print_on(tty);\n+    }\n+    st->cr();\n@@ -585,4 +856,7 @@\n-  \/\/ We limit the number of summands to 10. This is just a best guess, and not at this\n-  \/\/ point supported by evidence. But I think it is reasonable: usually, a pointer\n-  \/\/ contains a base pointer (e.g. array pointer or null for native memory) and a few\n-  \/\/ variables. It should be rare that we have more than 9 variables.\n+  \/\/ We limit the number of summands to 10, and the raw summands to 16. This is just a\n+  \/\/ best guess, and not at this point supported by evidence. But I think it is reasonable:\n+  \/\/ usually, a pointer contains a base pointer (e.g. array pointer or null for native memory)\n+  \/\/ and a few variables. It should be rare that we have more than 9 variables. We need\n+  \/\/ a few more raw summands, especially because there can be multiple constants, one\n+  \/\/ per ConvI2L \"int group\".\n+  static const int RAW_SUMMANDS_SIZE = 16;\n@@ -640,0 +914,7 @@\n+  \/\/ Raw summands: represent the pointer form exactly, allowing the reconstruction of the\n+  \/\/               pointer expression. Overflows inside the \"int groups\" (i.e. ConvI2L)\n+  \/\/               are preserved, and there may be multiple constants.\n+  MemPointerRawSummand _raw_summands[RAW_SUMMANDS_SIZE];\n+\n+  \/\/ Summands:     Simplified form, with only a single constant. Makes aliasing analysis\n+  \/\/               much simpler.\n@@ -643,0 +924,2 @@\n+\n+  \/\/ Size in bytes for the referenced memory region: [pointer, pointer + size)\n@@ -644,0 +927,1 @@\n+\n@@ -662,0 +946,1 @@\n+             const GrowableArray<MemPointerRawSummand>& raw_summands,\n@@ -673,0 +958,1 @@\n+    assert(raw_summands.length() <= RAW_SUMMANDS_SIZE, \"raw summands must fit\");\n@@ -679,0 +965,5 @@\n+    for (int i = 0; i < raw_summands.length(); i++) {\n+      const MemPointerRawSummand& s = raw_summands.at(i);\n+      assert(!s.scaleI().is_NaN(), \"non-NaN scale\");\n+      assert(!s.scaleL().is_NaN(), \"non-NaN scale\");\n+    }\n@@ -681,0 +972,5 @@\n+    \/\/ Copy raw summands in the same order.\n+    for (int i = 0; i < raw_summands.length(); i++) {\n+      _raw_summands[i] = raw_summands.at(i);\n+    }\n+\n@@ -711,0 +1007,5 @@\n+\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      _raw_summands[i] = old.raw_summands_at(i);\n+    }\n+\n@@ -736,0 +1037,2 @@\n+                         const GrowableArray<MemPointerRawSummand>& raw_summands,\n+                         const NoOverflowInt con,\n@@ -737,1 +1040,0 @@\n-                         const NoOverflowInt& con,\n@@ -740,2 +1042,4 @@\n-    if (summands.length() <= SUMMANDS_SIZE) {\n-      return MemPointer(pointer, summands, con, size NOT_PRODUCT(COMMA trace));\n+    if (raw_summands.length() <= RAW_SUMMANDS_SIZE &&\n+        summands.length() <= SUMMANDS_SIZE &&\n+        has_no_NaN_in_con_and_summands(con, summands)) {\n+      return MemPointer(pointer, raw_summands, summands, con, size NOT_PRODUCT(COMMA trace));\n@@ -747,0 +1051,9 @@\n+  static bool has_no_NaN_in_con_and_summands(const NoOverflowInt con,\n+                                             const GrowableArray<MemPointerSummand>& summands) {\n+    if (con.is_NaN()) { return false; }\n+    for (int i = 0; i < summands.length(); i++) {\n+      if (summands.at(i).scale().is_NaN()) { return false; }\n+    }\n+    return true;\n+  }\n+\n@@ -778,0 +1091,5 @@\n+  const MemPointerRawSummand& raw_summands_at(const uint i) const {\n+    assert(i < RAW_SUMMANDS_SIZE, \"in bounds\");\n+    return _raw_summands[i];\n+  }\n+\n@@ -782,0 +1100,19 @@\n+  int max_int_group() const {\n+    int n = 0;\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      const MemPointerRawSummand& s = _raw_summands[i];\n+      if (!s.is_valid()) { continue; }\n+      n = MAX2(n, s.int_group());\n+    }\n+    return n;\n+  }\n+\n+  template<typename Callback>\n+  void for_each_raw_summand_of_int_group(int int_group, Callback callback) const {\n+    for (int i = 0; i < RAW_SUMMANDS_SIZE; i++) {\n+      const MemPointerRawSummand& s = _raw_summands[i];\n+      if (!s.is_valid() || s.int_group() != int_group) { continue; }\n+      callback(s);\n+    }\n+  }\n+\n@@ -804,0 +1141,1 @@\n+  bool always_overlaps_with(const MemPointer& other) const;\n@@ -821,1 +1159,1 @@\n-  void print_on(outputStream* st, bool end_with_cr = true) const {\n+  void print_on(outputStream* st) const {\n@@ -827,1 +1165,42 @@\n-    if (end_with_cr) { st->cr(); }\n+    st->cr();\n+\n+    st->print(\"  raw: \");\n+\n+    int long_count = 0;\n+    for_each_raw_summand_of_int_group(0, [&] (const MemPointerRawSummand& s) {\n+      if (long_count > 0) { st->print(\" + \"); }\n+      long_count++;\n+      if (s.is_con()) {\n+        \/\/ Long constant.\n+        NoOverflowInt con = s.scaleI() * s.scaleL();\n+        con.print_on(st);\n+        st->print(\"L\");\n+      } else {\n+        \/\/ Long variable.\n+        assert(s.scaleI().is_one(), \"must be long variable\");\n+        s.scaleL().print_on(st);\n+        st->print(\"L * [%d %s]\", s.variable()->_idx, s.variable()->Name());\n+      }\n+    });\n+\n+    \/\/ Int groups, i.e. \"ConvI2L(...)\"\n+    for (int int_group = 1; int_group <= max_int_group(); int_group++) {\n+      if (long_count > 0) { st->print(\" + \"); }\n+      long_count++;\n+      int int_count = 0;\n+      for_each_raw_summand_of_int_group(int_group, [&] (const MemPointerRawSummand& s) {\n+        if (int_count == 0) {\n+          s.scaleL().print_on(st);\n+          st->print(\"L * ConvI2L(\");\n+        } else {\n+          st->print(\" + \");\n+        }\n+        int_count++;\n+        s.scaleI().print_on(st);\n+        if (!s.is_con()) {\n+          st->print(\" * [%d %s]\", s.variable()->_idx, s.variable()->Name());\n+        }\n+      });\n+      st->print(\")\");\n+    }\n+    st->cr();\n@@ -841,3 +1220,7 @@\n-  \/\/ Internal data-structures for parsing.\n-  NoOverflowInt _con;\n-  GrowableArray<MemPointerSummand> _worklist;\n+  \/\/ Internal data-structures for parsing raw summands.\n+  int _next_int_group = 1;\n+  GrowableArray<MemPointerRawSummand> _worklist;\n+  GrowableArray<MemPointerRawSummand> _raw_summands;\n+\n+  \/\/ Internal data-structures for parsing \"regular\" summands.\n+  NoOverflowInt _con = NoOverflowInt(0);\n@@ -853,1 +1236,0 @@\n-    _con(NoOverflowInt(0)),\n@@ -884,1 +1266,1 @@\n-  void parse_sub_expression(const MemPointerSummand& summand, MemPointerParserCallback& callback);\n+  void parse_sub_expression(const MemPointerRawSummand& summand, MemPointerParserCallback& callback);\n@@ -888,0 +1270,4 @@\n+\n+  void canonicalize_raw_summands();\n+  void create_summands();\n+  void canonicalize_summands();\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":403,"deletions":17,"binary":false,"changes":420,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/c2_globals.hpp\"\n@@ -47,4 +48,6 @@\n- *                    There are initially three Parse Predicates for each loop:\n- *                    - Loop Parse Predicate:             The Parse Predicate added for Loop Predicates.\n- *                    - Profiled Loop Parse Predicate:    The Parse Predicate added for Profiled Loop Predicates.\n- *                    - Loop Limit Check Parse Predicate: The Parse Predicate added for a Loop Limit Check Predicate.\n+ *                    There are initially five Parse Predicates for each loop:\n+ *                    - Loop Parse Predicate:               The Parse Predicate added for Loop Predicates.\n+ *                    - Profiled Loop Parse Predicate:      The Parse Predicate added for Profiled Loop Predicates.\n+ *                    - Loop Limit Check Parse Predicate:   The Parse Predicate added for a Loop Limit Check Predicate.\n+ *                    - Short Running Loop Parse Predicate: The Parse Predicate added for the short running long loop check.\n+ *                    - AutoVectorization Parse Predicate:  The Parse Predicate added for AutoVectorization runtime checks.\n@@ -52,1 +55,2 @@\n- *                      Loop Predicate) or a Loop Limit Check Predicate. These predicates will be checked at runtime while\n+ *                      Loop Predicate), a Loop Limit Check Predicate, a Short Running Long Loop Predicate, or a\n+ *                      AutoVectorization Runtime Check Predicate. These predicates will be checked at runtime while\n@@ -84,0 +88,15 @@\n+ *     - AutoVectorization:  This predicate is used for speculative runtime checks required for AutoVectorization.\n+ *       Runtime Check       There are multiple reasons why we need a runtime check to allow vectorization:\n+ *       Predicate           - Unknown aliasing:\n+ *                             An important compoinent of AutoVectorization is proving that memory addresses do not\n+ *                             alias, and can therefore be reordered. In some cases, this cannot be done statically\n+ *                             and a runtime check is necessary.\n+ *                           - Unknown alignment of native memory:\n+ *                             While heap objects have 8-byte alignment, off-heap (native) memory often has no alignment\n+ *                             guarantees. On platforms that require vectors to be aligned, we need to prove alignment.\n+ *                             We cannot do that statically with native memory, hence we need a runtime check.\n+ *                           The benefit of using a predicate is that we only have to compile the vectorized loop. If\n+ *                           the runtime check fails, we simply deoptimize. Should we eventually recompile, then the\n+ *                           predicate is not available any more, and we instead use a multiversioning approach with\n+ *                           both a vectorized and a scalar loop, where the runtime determines which loop is taken.\n+ *                           See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n@@ -160,1 +179,3 @@\n- *                    There are three different Predicate Blocks:\n+ *                    There are five different Predicate Blocks:\n+ *                    - Short Running Long    Groups the Short Running Long Loop Predicate (if created), and the\n+ *                      Loop Predicate Block: Short Running Long Loop Parse Predicate together.\n@@ -166,0 +187,3 @@\n+ *                    - AutoVectorization     Groups the AutoVectorization Runtime Check Predicates (if any), and the\n+ *                      Runtime Check         AutoVectorization Runtime Check Parse Predicate together.\n+ *                      Predicate Block:\n@@ -172,1 +196,4 @@\n- * (predicates inside square brackets [] do not need to exist if there are no checks to hoist):\n+ * (predicates inside square brackets [] do not need to exist if there are no checks to hoist \/ insert):\n+ *\n+ *   [Short Running Long Loop Predicate] (at most one)                 \\ Short Running Long\n+ * Short Running Long Loop Parse Predicate                             \/ Loop Predicate Block\n@@ -186,0 +213,6 @@\n+ *   [AutoVectorization Runtime Check Predicate 1]                     \\\n+ *   [AutoVectorization Runtime Check Predicate 2]                     | AutoVectorization\n+ *   ...                                                               | Runtime Check\n+ *   [AutoVectorization Runtime Check Predicate l]                     | Predicate Block\n+ * AutoVectorization Runtime Check Parse Predicate                     \/\n+ *\n@@ -785,2 +818,4 @@\n-    PredicateBlockIterator auto_vectorization_check_iterator(current_node, Deoptimization::Reason_auto_vectorization_check);\n-    current_node = auto_vectorization_check_iterator.for_each(predicate_visitor);\n+    if (UseAutoVectorizationPredicate) {\n+      PredicateBlockIterator auto_vectorization_check_iterator(current_node, Deoptimization::Reason_auto_vectorization_check);\n+      current_node = auto_vectorization_check_iterator.for_each(predicate_visitor);\n+    }\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -464,0 +464,3 @@\n+\/\/ Runtime Checks:\n+\/\/   Some required properties cannot be proven statically, and require a\n+\/\/   runtime check. See VTransform::add_speculative_check\n@@ -835,0 +838,5 @@\n+  \/\/ If we can speculate (using the aliasing runtime check), we can drop the weak edges,\n+  \/\/ and later insert a runtime check.\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool speculate_away_weak_edges = _vloop.use_speculative_aliasing_checks();\n+\n@@ -841,0 +849,1 @@\n+      if (speculate_away_weak_edges && preds.is_current_weak_memory_edge()) { continue; }\n@@ -872,0 +881,6 @@\n+\n+  \/\/ If we can speculate (using the aliasing runtime check), we can drop the weak edges,\n+  \/\/ and later insert a runtime check.\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool speculate_away_weak_edges = _vloop.use_speculative_aliasing_checks();\n+\n@@ -875,0 +890,1 @@\n+      if (speculate_away_weak_edges && preds.is_current_weak_memory_edge()) { continue; }\n@@ -1635,0 +1651,2 @@\n+    } else if (VectorNode::is_reinterpret_opcode(opc)) {\n+      retValue = Matcher::match_rule_supported_auto_vectorization(Op_VectorReinterpret, size, velt_basic_type(p0));\n@@ -1939,0 +1957,1 @@\n+                        _vloop.is_trace_speculative_aliasing_analysis(),\n@@ -1992,1 +2011,2 @@\n-  apply_speculative_runtime_checks();\n+  apply_speculative_alignment_runtime_checks();\n+  apply_speculative_aliasing_runtime_checks();\n@@ -2093,5 +2113,1 @@\n-  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n-  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n-  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n-  int length = _vtnodes.length();\n-  GrowableArray<Node*> vtnode_idx_to_transformed_node(length, length, nullptr);\n+  VTransformApplyState apply_state(_vloop_analyzer, _vtnodes.length());\n@@ -2101,2 +2117,1 @@\n-    VTransformApplyResult result = vtn->apply(_vloop_analyzer,\n-                                              vtnode_idx_to_transformed_node);\n+    VTransformApplyResult result = vtn->apply(apply_state);\n@@ -2105,1 +2120,1 @@\n-    vtnode_idx_to_transformed_node.at_put(vtn->_idx, result.node());\n+    apply_state.set_transformed_node(vtn, result.node());\n@@ -3059,1 +3074,1 @@\n-  Node* xbic = igvn().intcon(is_sub ? -con : con);\n+  Node* xbic = phase()->intcon(is_sub ? -con : con);\n@@ -3076,1 +3091,1 @@\n-    Node* invar_scale_con = igvn().intcon(invar_scale);\n+    Node* invar_scale_con = phase()->intcon(invar_scale);\n@@ -3128,1 +3143,1 @@\n-  Node* log2_abs_iv_scale = igvn().intcon(exact_log2(abs(iv_scale)));\n+  Node* log2_abs_iv_scale = phase()->intcon(exact_log2(abs(iv_scale)));\n@@ -3153,1 +3168,1 @@\n-  Node* mask_AW = igvn().intcon(AW-1);\n+  Node* mask_AW = phase()->intcon(AW-1);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -58,0 +58,2 @@\n+\/\/\n+\/\/ For more documentation, see: SuperWord::SLP_extract\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,13 @@\n-    VTransformScalarNode* vtn = new (_vtransform.arena()) VTransformScalarNode(_vtransform, n);\n+\n+    VTransformNode* vtn = nullptr;\n+    if (n->is_Load() || n->is_Store()) {\n+      MemNode* mem = n->as_Mem();\n+      const VPointer& mem_p = _vloop_analyzer.vpointers().vpointer(mem);\n+      vtn = new (_vtransform.arena()) VTransformMemopScalarNode(_vtransform, mem, mem_p);\n+    } else if (n->is_Phi()) {\n+      vtn = new (_vtransform.arena()) VTransformLoopPhiNode(_vtransform, n->as_Phi());\n+    } else if (n->is_CFG()) {\n+      vtn = new (_vtransform.arena()) VTransformCFGNode(_vtransform, n);\n+    } else {\n+      vtn = new (_vtransform.arena()) VTransformDataScalarNode(_vtransform, n);\n+    }\n@@ -71,1 +83,1 @@\n-      set_req_with_scalar(p0,   vtn, MemNode::Address);\n+      init_req_with_scalar(p0,   vtn, MemNode::Address);\n@@ -76,2 +88,2 @@\n-      set_req_with_scalar(p0,   vtn, MemNode::Address);\n-      set_req_with_vector(pack, vtn, MemNode::ValueIn);\n+      init_req_with_scalar(p0,   vtn, MemNode::Address);\n+      init_req_with_vector(pack, vtn, MemNode::ValueIn);\n@@ -82,2 +94,2 @@\n-      set_req_with_scalar(p0,   vtn, 1); \/\/ scalar init\n-      set_req_with_vector(pack, vtn, 2); \/\/ vector\n+      init_req_with_scalar(p0,   vtn, 1); \/\/ scalar init\n+      init_req_with_vector(pack, vtn, 2); \/\/ vector\n@@ -89,2 +101,2 @@\n-        set_req_with_vector(pack, vtn, 1);\n-        set_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n+        init_req_with_vector(pack, vtn, 1);\n+        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rotation\n@@ -92,2 +104,2 @@\n-        set_req_with_vector(pack, vtn, 1);\n-        set_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n+        init_req_with_vector(pack, vtn, 1);\n+        init_req_with_scalar(p0,   vtn, 2); \/\/ constant rounding mode\n@@ -97,1 +109,1 @@\n-        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n+        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in_req(1)->isa_BoolVector();\n@@ -111,2 +123,2 @@\n-    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n-    if (vtn == nullptr) { continue; }\n+    VTransformNode* vtn = get_vtnode(n);\n+    if (vtn->isa_Vector() != nullptr) { continue; }\n@@ -116,1 +128,1 @@\n-      set_req_with_scalar(n, vtn, MemNode::Address);\n+      init_req_with_scalar(n, vtn, MemNode::Address);\n@@ -119,2 +131,2 @@\n-      set_req_with_scalar(n, vtn, MemNode::Address);\n-      set_req_with_scalar(n, vtn, MemNode::ValueIn);\n+      init_req_with_scalar(n, vtn, MemNode::Address);\n+      init_req_with_scalar(n, vtn, MemNode::ValueIn);\n@@ -127,1 +139,1 @@\n-      set_req_with_scalar(n, vtn, 0);\n+      init_req_with_scalar(n, vtn, 0);\n@@ -180,3 +192,3 @@\n-void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, const int index) {\n-  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n-  vtn->set_req(index, req);\n+void SuperWordVTransformBuilder::init_req_with_scalar(Node* n, VTransformNode* vtn, const int index) {\n+  VTransformNode* req = get_vtnode_or_wrap_as_outer(n->in(index));\n+  vtn->init_req(index, req);\n@@ -213,1 +225,1 @@\n-    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_outer(_vloop.iv());\n@@ -220,1 +232,1 @@\n-    populate_index->set_req(1, iv_vtn);\n+    populate_index->init_req(1, iv_vtn);\n@@ -225,1 +237,1 @@\n-    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_outer(same_input);\n@@ -233,1 +245,1 @@\n-      shift_count->set_req(1, same_input_vtn);\n+      shift_count->init_req(1, same_input_vtn);\n@@ -248,1 +260,1 @@\n-        conv->set_req(1, same_input_vtn);\n+        conv->init_req(1, same_input_vtn);\n@@ -252,1 +264,1 @@\n-      replicate->set_req(1, same_input_vtn);\n+      replicate->init_req(1, same_input_vtn);\n@@ -267,1 +279,1 @@\n-VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_outer(Node* n) {\n@@ -272,1 +284,1 @@\n-  vtn = new (_vtransform.arena()) VTransformInputScalarNode(_vtransform, n);\n+  vtn = new (_vtransform.arena()) VTransformOuterNode(_vtransform, n);\n@@ -277,1 +289,1 @@\n-void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, int j) {\n+void SuperWordVTransformBuilder::init_req_with_vector(const Node_List* pack, VTransformNode* vtn, int j) {\n@@ -279,1 +291,1 @@\n-  vtn->set_req(j, req);\n+  vtn->init_req(j, req);\n@@ -287,1 +299,1 @@\n-    set_req_with_scalar(n, vtn, j);\n+    init_req_with_scalar(n, vtn, j);\n@@ -298,1 +310,1 @@\n-    set_req_with_vector(pack, vtn, j);\n+    init_req_with_vector(pack, vtn, j);\n@@ -302,1 +314,4 @@\n-void SuperWordVTransformBuilder::add_memory_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_memory_dependencies) {\n+void SuperWordVTransformBuilder::add_memory_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_memory_dependencies) {\n+  \/\/ If we cannot speculate, then all dependencies must be strong edges, i.e. scheduling must respect them.\n+  bool are_speculative_checks_possible = _vloop.are_speculative_checks_possible();\n+\n@@ -307,0 +322,1 @@\n+    assert(n->is_Mem() && pred->is_Mem(), \"only memory edges\");\n@@ -312,2 +328,5 @@\n-    assert(n->is_Mem() && pred->is_Mem(), \"only memory edges\");\n-    vtn->add_memory_dependency(dependency); \/\/ Add every dependency only once per vtn.\n+    if (are_speculative_checks_possible && preds.is_current_weak_memory_edge()) {\n+      vtn->add_weak_memory_edge(dependency);\n+    } else {\n+      vtn->add_strong_memory_edge(dependency);\n+    }\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":54,"deletions":35,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -79,3 +79,3 @@\n-  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n-  void set_req_with_scalar(Node* n, VTransformNode* vtn, const int index);\n-  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, const int index);\n+  VTransformNode* get_vtnode_or_wrap_as_outer(Node* n);\n+  void init_req_with_scalar(Node* n, VTransformNode* vtn, const int index);\n+  void init_req_with_vector(const Node_List* pack, VTransformNode* vtn, const int index);\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  flags(SPECULATIVE_ALIASING_ANALYSIS, \"Trace Speculative Aliasing Analysis\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -28,0 +29,2 @@\n+#include \"opto\/divnode.hpp\"\n+#include \"opto\/movenode.hpp\"\n@@ -29,0 +32,2 @@\n+#include \"opto\/noOverflowInt.hpp\"\n+#include \"opto\/phaseX.hpp\"\n@@ -260,0 +265,3 @@\n+\/\/    - Strong edge: must be respected.\n+\/\/    - Weak edge:   if we add a speculative aliasing check, we can violate\n+\/\/                   the edge, i.e. spaw the order.\n@@ -266,1 +274,2 @@\n-  GrowableArray<int> memory_pred_edges;\n+  GrowableArray<int> strong_memory_edges;\n+  GrowableArray<int> weak_memory_edges;\n@@ -278,1 +287,2 @@\n-      memory_pred_edges.clear();\n+      strong_memory_edges.clear();\n+      weak_memory_edges.clear();\n@@ -289,0 +299,2 @@\n+\n+        \/\/ If we can prove that they will never overlap -> drop edge.\n@@ -290,2 +302,5 @@\n-          \/\/ Possibly overlapping memory\n-          memory_pred_edges.append(_body.bb_idx(n2));\n+          if (p1.can_make_speculative_aliasing_check_with(p2)) {\n+            weak_memory_edges.append(_body.bb_idx(n2));\n+          } else {\n+            strong_memory_edges.append(_body.bb_idx(n2));\n+          }\n@@ -294,1 +309,1 @@\n-      if (memory_pred_edges.is_nonempty()) {\n+      if (strong_memory_edges.is_nonempty() || weak_memory_edges.is_nonempty()) {\n@@ -297,1 +312,1 @@\n-        add_node(n1, memory_pred_edges);\n+        add_node(n1, strong_memory_edges, weak_memory_edges);\n@@ -308,1 +323,1 @@\n-void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& memory_pred_edges) {\n+void VLoopDependencyGraph::add_node(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges) {\n@@ -310,2 +325,1 @@\n-  assert(!memory_pred_edges.is_empty(), \"no need to create a node without edges\");\n-  DependencyNode* dn = new (_arena) DependencyNode(n, memory_pred_edges, _arena);\n+  DependencyNode* dn = new (_arena) DependencyNode(n, strong_memory_edges, weak_memory_edges, _arena);\n@@ -318,0 +332,3 @@\n+    \/\/ We must compute the dependence graph depth with all edges (including the weak edges), so that\n+    \/\/ the independence queries work correctly, no matter if we check independence with or without\n+    \/\/ weak edges.\n@@ -361,2 +378,7 @@\n-      for (uint j = 0; j < dn->memory_pred_edges_length(); j++) {\n-        Node* pred = _body.body().at(dn->memory_pred_edge(j));\n+      for (uint j = 0; j < dn->num_strong_memory_edges(); j++) {\n+        Node* pred = _body.body().at(dn->strong_memory_edge(j));\n+        tty->print(\"  %d %s\", pred->_idx, pred->Name());\n+      }\n+      tty->print(\" | weak:\");\n+      for (uint j = 0; j < dn->num_weak_memory_edges(); j++) {\n+        Node* pred = _body.body().at(dn->weak_memory_edge(j));\n@@ -370,1 +392,7 @@\n-  tty->print_cr(\" Complete dependency graph:\");\n+  \/\/ If we cannot speculate (aliasing analysis runtime checks), we need to respect all edges.\n+  bool with_weak_memory_edges = !_vloop.use_speculative_aliasing_checks();\n+  if (with_weak_memory_edges) {\n+    tty->print_cr(\" Complete dependency graph (with weak edges, because we cannot speculate):\");\n+  } else {\n+    tty->print_cr(\" Dependency graph without weak edges (because we can speculate):\");\n+  }\n@@ -375,0 +403,1 @@\n+      if (!with_weak_memory_edges && it.is_current_weak_memory_edge()) { continue; }\n@@ -384,1 +413,2 @@\n-                                                     GrowableArray<int>& memory_pred_edges,\n+                                                     GrowableArray<int>& strong_memory_edges,\n+                                                     GrowableArray<int>& weak_memory_edges,\n@@ -387,2 +417,3 @@\n-    _memory_pred_edges_length(memory_pred_edges.length()),\n-    _memory_pred_edges(nullptr)\n+    _num_strong_memory_edges(strong_memory_edges.length()),\n+    _num_weak_memory_edges(weak_memory_edges.length()),\n+    _memory_edges(nullptr)\n@@ -390,4 +421,11 @@\n-  assert(memory_pred_edges.is_nonempty(), \"not empty\");\n-  uint bytes = memory_pred_edges.length() * sizeof(int);\n-  _memory_pred_edges = (int*)arena->Amalloc(bytes);\n-  memcpy(_memory_pred_edges, memory_pred_edges.adr_at(0), bytes);\n+  assert(strong_memory_edges.is_nonempty() || weak_memory_edges.is_nonempty(), \"only generate DependencyNode if there are pred edges\");\n+  uint bytes_strong = strong_memory_edges.length() * sizeof(int);\n+  uint bytes_weak = weak_memory_edges.length() * sizeof(int);\n+  uint bytes_total = bytes_strong + bytes_weak;\n+  _memory_edges = (int*)arena->Amalloc(bytes_total);\n+  if (strong_memory_edges.length() > 0) {\n+    memcpy(_memory_edges, strong_memory_edges.adr_at(0), bytes_strong);\n+  }\n+  if (weak_memory_edges.length() > 0) {\n+    memcpy(_memory_edges + strong_memory_edges.length(), weak_memory_edges.adr_at(0), bytes_weak);\n+  }\n@@ -403,4 +441,7 @@\n-    _next_pred(0),\n-    _end_pred(node->req()),\n-    _next_memory_pred(0),\n-    _end_memory_pred((_dependency_node != nullptr) ? _dependency_node->memory_pred_edges_length() : 0)\n+    _is_current_weak_memory_edge(false),\n+    _next_data_edge(0),\n+    _end_data_edge(node->req()),\n+    _next_strong_memory_edge(0),\n+    _end_strong_memory_edge((_dependency_node != nullptr) ? _dependency_node->num_strong_memory_edges() : 0),\n+    _next_weak_memory_edge(0),\n+    _end_weak_memory_edge((_dependency_node != nullptr) ? _dependency_node->num_weak_memory_edges() : 0)\n@@ -409,3 +450,5 @@\n-    \/\/ Load: address\n-    \/\/ Store: address, value\n-    _next_pred = MemNode::Address;\n+    \/\/ Ignore ctrl and memory, only address and value are data dependencies.\n+    \/\/ Memory edges are already covered by the strong and weak memory edges.\n+    \/\/ Load:  [ctrl, memory] address\n+    \/\/ Store: [ctrl, memory] address, value\n+    _next_data_edge = MemNode::Address;\n@@ -414,1 +457,1 @@\n-    _next_pred = 1; \/\/ skip control\n+    _next_data_edge = 1; \/\/ skip control\n@@ -420,2 +463,2 @@\n-  if (_next_pred < _end_pred) {\n-    _current = _node->in(_next_pred++);\n+  if (_next_data_edge < _end_data_edge) {\n+    _current = _node->in(_next_data_edge++);\n@@ -423,2 +466,8 @@\n-  } else if (_next_memory_pred < _end_memory_pred) {\n-    int pred_bb_idx = _dependency_node->memory_pred_edge(_next_memory_pred++);\n+    _is_current_weak_memory_edge = false;\n+  } else if (_next_strong_memory_edge < _end_strong_memory_edge) {\n+    int pred_bb_idx = _dependency_node->strong_memory_edge(_next_strong_memory_edge++);\n+    _current = _dependency_graph._body.body().at(pred_bb_idx);\n+    _is_current_memory_edge = true;\n+    _is_current_weak_memory_edge = false;\n+  } else if (_next_weak_memory_edge < _end_weak_memory_edge) {\n+    int pred_bb_idx = _dependency_node->weak_memory_edge(_next_weak_memory_edge++);\n@@ -427,0 +476,1 @@\n+    _is_current_weak_memory_edge = true;\n@@ -430,0 +480,591 @@\n+    _is_current_weak_memory_edge = false;\n+  }\n+}\n+\n+\/\/ Computing aliasing runtime check using init and last of main-loop\n+\/\/ -----------------------------------------------------------------\n+\/\/\n+\/\/ We have two VPointer vp1 and vp2, and would like to create a runtime check that\n+\/\/ guarantees that the corresponding pointers p1 and p2 do not overlap (alias) for\n+\/\/ any iv value in the strided range r = [init, init + iv_stride, .. limit).\n+\/\/ Remember that vp1 and vp2 both represent a region in memory, starting at a\n+\/\/ \"pointer\", and extending for \"size\" bytes:\n+\/\/\n+\/\/   vp1(iv) = [p1(iv), size1)\n+\/\/   vp2(iv) = [p2(iv), size2)\n+\/\/\n+\/\/       |---size1--->           |-------size2------->\n+\/\/       |                       |\n+\/\/     p1(iv)                  p2(iv)\n+\/\/\n+\/\/ In each iv value (intuitively: for each iteration), we check that there is no\n+\/\/ overlap:\n+\/\/\n+\/\/   for all iv in r: p1(iv) + size1 <= p2(iv) OR p2(iv) + size2 <= p1(iv)\n+\/\/\n+\/\/ This would allow situations where for some iv p1 is lower than p2, and for\n+\/\/ other iv p1 is higher than p2. This is not very useful in practice. We can\n+\/\/ strengthen the condition, which will make the check simpler later:\n+\/\/\n+\/\/   for all iv in r: p1(iv) + size1 <= p2(iv)                    (P1-BEFORE-P2)\n+\/\/   OR\n+\/\/   for all iv in r: p2(iv) + size2 <= p1(iv)                    (P1-AFTER-P2)\n+\/\/\n+\/\/ Note: apart from this strengthening, the checks we derive below are byte accurate,\n+\/\/       i.e. they are equivalent to the conditions above. This means we have NO case\n+\/\/       where:\n+\/\/       1) The check passes (predicts no overlap) but the pointers do actually overlap.\n+\/\/          This would be bad because we would wrongly vectorize, possibly leading to\n+\/\/          wrong results.\n+\/\/       2) The check does not pass (predicts overlap) but the pointers do not overlap.\n+\/\/          This would be suboptimal, as we would not be able to vectorize, and either\n+\/\/          trap (with predicate), or go into the slow-loop (with multiversioning).\n+\/\/\n+\/\/\n+\/\/ We apply the \"MemPointer Linearity Corrolary\" to VPointer vp and the corresponding\n+\/\/ pointer p:\n+\/\/   (C0) is given by the construction of VPointer vp, which simply wraps a MemPointer mp.\n+\/\/   (c1) with v = iv and scale_v = iv_scale\n+\/\/   (C2) with r = [init, init + iv_stride, .. last - stride_v, last], which is the set\n+\/\/        of possible iv values in the loop, with \"init\" the first iv value, and \"last\"\n+\/\/        the last iv value which is closest to limit.\n+\/\/        Note: iv_stride > 0  ->  limit - iv_stride <= last < limit\n+\/\/              iv_stride < 0  ->  limit < last <= limit - iv_stride\n+\/\/        We have to be a little careful, and cannot just use \"limit\" instead of \"last\" as\n+\/\/        the last value in r, because the iv never reaches limit in the main-loop, and\n+\/\/        so we are not sure if the memory access at p(limit) is still in bounds.\n+\/\/        For now, we just assume that we can compute init and limit, and we will derive\n+\/\/        the computation of these values later on.\n+\/\/   (C3) the memory accesses for every iv value in the loop must be in bounds, otherwise\n+\/\/        the program has undefined behaviour already.\n+\/\/   (C4) abs(iv_scale * iv_stride) < 2^31 is given by the checks in\n+\/\/        VPointer::init_are_scale_and_stride_not_too_large.\n+\/\/\n+\/\/ Hence, it follows that we can see p and vp as linear functions of iv in r, i.e. for\n+\/\/ all iv values in the loop:\n+\/\/   p(iv)  = p(init)  - init * iv_scale + iv * iv_scale\n+\/\/   vp(iv) = vp(init) - init * iv_scale + iv * iv_scale\n+\/\/\n+\/\/ Hence, p1 and p2 have the linear form:\n+\/\/   p1(iv)  = p1(init) - init * iv_scale1 + iv * iv_scale1             (LINEAR-FORM-INIT)\n+\/\/   p2(iv)  = p2(init) - init * iv_scale2 + iv * iv_scale2\n+\/\/\n+\/\/ With the (Alternative Corrolary P) we get the alternative linar form:\n+\/\/   p1(iv)  = p1(last) - last * iv_scale1 + iv * iv_scale1             (LINEAR-FORM-LAST)\n+\/\/   p2(iv)  = p2(last) - last * iv_scale2 + iv * iv_scale2\n+\/\/\n+\/\/\n+\/\/ We can now use this linearity to construct aliasing runtime checks, depending on the\n+\/\/ different \"geometry\" of the two VPointer over their iv, i.e. the \"slopes\" of the linear\n+\/\/ functions. In the following graphs, the x-axis denotes the values of iv, from init to\n+\/\/ last. And the y-axis denotes the pointer position p(iv). Intuitively, this problem\n+\/\/ can be seen as having two bands that should not overlap.\n+\/\/\n+\/\/       Case 1                     Case 2                     Case 3\n+\/\/       parallel lines             same sign slope            different sign slope\n+\/\/                                  but not parallel\n+\/\/\n+\/\/       +---------+                +---------+                +---------+\n+\/\/       |         |                |        #|                |#        |\n+\/\/       |         |                |       # |                |  #      |\n+\/\/       |        #|                |      #  |                |    #    |\n+\/\/       |      #  |                |     #   |                |      #  |\n+\/\/       |    #    |                |    #    |                |        #|\n+\/\/       |  # ^    |                |   #     |                |        ^|\n+\/\/       |#   |   #|                |  #      |                |        ||\n+\/\/       |    v #  |                | #       |                |        v|\n+\/\/       |    #    |                |#       #|                |        #|\n+\/\/       |  #      |                |^     #  |                |      #  |\n+\/\/       |#        |                ||   #    |                |    #    |\n+\/\/       |         |                |v #      |                |  #      |\n+\/\/       |         |                |#        |                |#        |\n+\/\/       +---------+                +---------+                +---------+\n+\/\/\n+\/\/\n+\/\/ Case 1: parallel lines, i.e. iv_scale = iv_scale1 = iv_scale2\n+\/\/\n+\/\/   p1(iv)  = p1(init)  - init * iv_scale + iv * iv_scale\n+\/\/   p2(iv)  = p2(init)  - init * iv_scale + iv * iv_scale\n+\/\/\n+\/\/   Given this, it follows:\n+\/\/     p1(iv) + size1 <= p2(iv)      <==>      p1(init) + size1 <= p2(init)\n+\/\/     p2(iv) + size2 <= p1(iv)      <==>      p2(init) + size2 <= p1(init)\n+\/\/\n+\/\/   Hence, we do not have to check the condition for every iv, but only for init.\n+\/\/\n+\/\/   p1(init) + size1 <= p2(init)  OR  p2(init) + size2 <= p1(init)\n+\/\/   ----- is equivalent to -----      ---- is equivalent to ------\n+\/\/          (P1-BEFORE-P2)         OR         (P1-AFTER-P2)\n+\/\/\n+\/\/\n+\/\/ Case 2 and 3: different slopes, i.e. iv_scale1 != iv_scale2\n+\/\/\n+\/\/   Without loss of generality, we assume iv_scale1 < iv_scale2.\n+\/\/   (Otherwise, we just swap p1 and p2).\n+\/\/\n+\/\/   If iv_stride >= 0, i.e. init <= iv <= last:\n+\/\/     (iv - init) * iv_scale1 <= (iv - init) * iv_scale2\n+\/\/     (iv - last) * iv_scale1 >= (iv - last) * iv_scale2                 (POS-STRIDE)\n+\/\/   If iv_stride <= 0, i.e. last <= iv <= init:\n+\/\/     (iv - init) * iv_scale1 >= (iv - init) * iv_scale2\n+\/\/     (iv - last) * iv_scale1 <= (iv - last) * iv_scale2                 (NEG-STRIDE)\n+\/\/\n+\/\/   Below, we show that these conditions are equivalent:\n+\/\/\n+\/\/       p1(init) + size1 <= p2(init)       (if iv_stride >= 0)  |    p2(last) + size2 <= p1(last)      (if iv_stride >= 0)   |\n+\/\/       p1(last) + size1 <= p2(last)       (if iv_stride <= 0)  |    p2(init) + size2 <= p1(init)      (if iv_stride <= 0)   |\n+\/\/       ---- are equivalent to -----                            |    ---- are equivalent to -----                            |\n+\/\/              (P1-BEFORE-P2)                                   |           (P1-AFTER-P2)                                    |\n+\/\/                                                               |                                                            |\n+\/\/   Proof:                                                      |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: (P1-BEFORE-P2)                                    |  Assume: (P1-AFTER-P2)                                     |\n+\/\/       for all iv in r: p1(iv) + size1 <= p2(iv)               |    for all iv in r: p2(iv) + size2 <= p1(iv)               |\n+\/\/       => And since init and last in r =>                      |    => And since init and last in r =>                      |\n+\/\/       p1(init) + size1 <= p2(init)                            |    p2(init) + size2 <= p1(init)                            |\n+\/\/       p1(last) + size1 <= p2(last)                            |    p2(last) + size2 <= p1(last)                            |\n+\/\/                                                               |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: p1(init) + size1 <= p2(init)                      |  Assume: p2(last) + size2 <= p1(last)                      |\n+\/\/        and: iv_stride >= 0                                    |     and: iv_stride >= 0                                    |\n+\/\/                                                               |                                                            |\n+\/\/          size1 + p1(iv)                                       |       size2 + p2(iv)                                       |\n+\/\/                  --------- apply (LINEAR-FORM-INIT) --------- |               --------- apply (LINEAR-FORM-LAST) --------- |\n+\/\/        = size1 + p1(init) - init * iv_scale1 + iv * iv_scale1 |     = size2 + p2(last) - last * iv_scale2 + iv * iv_scale2 |\n+\/\/                           ------ apply (POS-STRIDE) --------- |                        ------ apply (POS-STRIDE) --------- |\n+\/\/       <= size1 + p1(init) - init * iv_scale2 + iv * iv_scale2 |    <= size2 + p2(last) - last * iv_scale1 + iv * iv_scale1 |\n+\/\/          -- assumption --                                     |       -- assumption --                                     |\n+\/\/       <=         p2(init) - init * iv_scale2 + iv * iv_scale2 |    <=         p1(last) - last * iv_scale1 + iv * iv_scale1 |\n+\/\/                  --------- apply (LINEAR-FORM-INIT) --------- |               --------- apply (LINEAR-FORM-LAST) --------- |\n+\/\/        =         p2(iv)                                       |     =         p1(iv)                                       |\n+\/\/                                                               |                                                            |\n+\/\/                                                               |                                                            |\n+\/\/     Assume: p1(last) + size1 <= p2(last)                      |  Assume: p2(init) + size2 <= p1(init)                      |\n+\/\/        and: iv_stride <= 0                                    |     and: iv_stride <= 0                                    |\n+\/\/                                                               |                                                            |\n+\/\/          size1 + p1(iv)                                       |       size2 + p2(iv)                                       |\n+\/\/                  --------- apply (LINEAR-FORM-LAST) --------- |               --------- apply (LINEAR-FORM-INIT) --------- |\n+\/\/        = size1 + p1(last) - last * iv_scale1 + iv * iv_scale1 |     = size2 + p2(init) - init * iv_scale2 + iv * iv_scale2 |\n+\/\/                           ------ apply (NEG-STRIDE) --------- |                        ------ apply (NEG-STRIDE) --------- |\n+\/\/       <= size1 + p1(last) - last * iv_scale2 + iv * iv_scale2 |    <= size2 + p2(init) - init * iv_scale1 + iv * iv_scale1 |\n+\/\/          -- assumption --                                     |       -- assumption --                                     |\n+\/\/       <=         p2(last) - last * iv_scale2 + iv * iv_scale2 |    <=         p1(init) - init * iv_scale1 + iv * iv_scale1 |\n+\/\/                  --------- apply (LINEAR-FORM-LAST) --------- |               --------- apply (LINEAR-FORM-INIT) --------- |\n+\/\/        =         p2(iv)                                       |     =         p1(iv)                                       |\n+\/\/                                                               |                                                            |\n+\/\/\n+\/\/   The obtained conditions already look very simple. However, we would like to avoid\n+\/\/   computing 4 addresses (p1(init), p1(last), p2(init), p2(last)), and would instead\n+\/\/   prefer to only compute 2 addresses, and derive the other two from the distance (span)\n+\/\/   between the pointers at init and last. Using (LINEAR-FORM-INIT), we get:\n+\/\/\n+\/\/     p1(last) = p1(init) - init * iv_scale1 + last * iv_scale1                 (SPAN-1)\n+\/\/                         --------------- defines -------------\n+\/\/                p1(init) + span1\n+\/\/\n+\/\/     p2(last) = p2(init) - init * iv_scale2 + last * iv_scale2                 (SPAN-2)\n+\/\/                         --------------- defines -------------\n+\/\/                p1(init) + span2\n+\/\/\n+\/\/     span1 = - init * iv_scale1 + last * iv_scale1 = (last - init) * iv_scale1\n+\/\/     span2 = - init * iv_scale2 + last * iv_scale2 = (last - init) * iv_scale2\n+\/\/\n+\/\/   Thus, we can use the conditions below:\n+\/\/     p1(init)         + size1 <= p2(init)          OR  p2(init) + span2 + size2 <= p1(init) + span1    (if iv_stride >= 0)\n+\/\/     p1(init) + span1 + size1 <= p2(init) + span2  OR  p2(init)         + size2 <= p1(init)            (if iv_stride <= 0)\n+\/\/\n+\/\/   Below, we visualize the conditions, so that the reader can gain an intuitiion.\n+\/\/   For simplicity, we only show the case with iv_stride > 0. Also, remember that\n+\/\/   iv_scale1 < iv_scale2.\n+\/\/\n+\/\/                             +---------+                     +---------+\n+\/\/                             |        #|                     |        #| <-- p1(init) + span1\n+\/\/                             |       # |  ^ span2    span1 ^ |      # ^|\n+\/\/                             |      #  |  |                | |    #   ||\n+\/\/                             |     #   |  |                | |  #     v| <-- p2(init) + span2 + size2\n+\/\/                             |    #    |  |                v |#       #|\n+\/\/                             |   #     |  |          span2 ^ |       # |\n+\/\/                             |  #      |  |                | |      #  |\n+\/\/                             | #       |  |                | |     #   |\n+\/\/        p2(init)         --> |#       #|  v                | |    #    |\n+\/\/                             |^     #  |  ^ span1          | |   #     |\n+\/\/                             ||   #    |  |                | |  #      |\n+\/\/        p1(init) + size1 --> |v #      |  |                | | #       |\n+\/\/                             |#        |  v                v |#        |\n+\/\/                             +---------+                     +---------+\n+\/\/\n+\/\/ -------------------------------------------------------------------------------------------------------------------------\n+\/\/\n+\/\/ Computing the last iv value in a loop\n+\/\/ -------------------------------------\n+\/\/\n+\/\/ Let us define a helper function, that computes the last iv value in a loop,\n+\/\/ given variable init and limit values, and a constant stride. If the loop\n+\/\/ is never entered, we just return the init value.\n+\/\/\n+\/\/   LAST(init, stride, limit), where stride > 0:   |  LAST(init, stride, limit), where stride < 0:\n+\/\/     last = init                                  |  last = init\n+\/\/     for (iv = init; iv < limit; iv += stride)    |  for (iv = init; iv > limit; iv += stride)\n+\/\/       last = iv                                  |    last = iv\n+\/\/\n+\/\/ It follows that for some k:\n+\/\/    last = init + k * stride\n+\/\/\n+\/\/ If the loop is not entered, we can set k=0.\n+\/\/\n+\/\/ If the loop is entered:\n+\/\/   last is very close to limit:\n+\/\/     stride > 0  ->  limit - stride <= last < limit\n+\/\/     stride < 0  ->  limit < last <= limit - stride\n+\/\/\n+\/\/     If stride > 0:\n+\/\/         limit        - stride                   <= last              <   limit\n+\/\/         limit        - stride                   <= init + k * stride <   limit\n+\/\/         limit - init - stride                   <=        k * stride <   limit - init\n+\/\/         limit - init - stride - 1               <         k * stride <=  limit - init - 1\n+\/\/        (limit - init - stride - 1) \/ stride     <         k          <= (limit - init - 1) \/ stride\n+\/\/        (limit - init          - 1) \/ stride - 1 <         k          <= (limit - init - 1) \/ stride\n+\/\/     -> k = (limit - init - 1) \/ stride\n+\/\/     -> dividend \"limit - init - 1\" is >=0. So a regular round to zero division can be used.\n+\/\/        Note: to incorporate the case where the loop is not entered (init >= limit), we see\n+\/\/              that the divident is zero or negative, and so the result will be zero or\n+\/\/              negative. Thus, we can just clamp k to zero, or last to init, so that we get\n+\/\/              a solution that also works when the loop is not entered:\n+\/\/\n+\/\/              k = (limit - init - 1) \/ abs(stride)\n+\/\/              last = MAX(init, init + k * stride)\n+\/\/\n+\/\/     If stride < 0:\n+\/\/         limit                               <  last              <=   limit        - stride\n+\/\/         limit                               <  init + k * stride <=   limit        - stride\n+\/\/         limit - init                        <         k * stride <=   limit - init - stride\n+\/\/         limit - init + 1                    <=        k * stride <    limit - init - stride + 1\n+\/\/        (limit - init + 1) \/     stride      >=        k          >   (limit - init - stride + 1) \/     stride\n+\/\/       -(limit - init + 1) \/ abs(stride)     >=        k          >  -(limit - init - stride + 1) \/ abs(stride)\n+\/\/       -(limit - init + 1) \/ abs(stride)     >=        k          >  -(limit - init          + 1) \/ abs(stride) - 1\n+\/\/        (init - limit - 1) \/ abs(stride)     >=        k          >   (init - limit          - 1) \/ abs(stride) - 1\n+\/\/        (init - limit - 1) \/ abs(stride)     >=        k          >   (init - limit          - 1) \/ abs(stride) - 1\n+\/\/     -> k = (init - limit - 1) \/ abs(stride)\n+\/\/     -> dividend \"init - limit\" is >=0. So a regular round to zero division can be used.\n+\/\/        Note: to incorporate the case where the loop is not entered (init <= limit), we see\n+\/\/              that the divident is zero or negative, and so the result will be zero or\n+\/\/              negative. Thus, we can just clamp k to zero, or last to init, so that we get\n+\/\/              a solution that also works when the loop is not entered:\n+\/\/\n+\/\/              k = (init - limit - 1) \/ abs(stride)\n+\/\/              last = MIN(init, init + k * stride)\n+\/\/\n+\/\/ Now we can put it all together:\n+\/\/   LAST(init, stride, limit)\n+\/\/     If stride > 0:\n+\/\/       k = (limit - init - 1) \/ abs(stride)\n+\/\/       last = MAX(init, init + k * stride)\n+\/\/     If stride < 0:\n+\/\/       k = (init - limit - 1) \/ abs(stride)\n+\/\/       last = MIN(init, init + k * stride)\n+\/\/\n+\/\/ We will have to consider the implications of clamping to init when the loop is not entered\n+\/\/ at the use of LAST further down.\n+\/\/\n+\/\/ -------------------------------------------------------------------------------------------------------------------------\n+\/\/\n+\/\/ Computing init and last for the main-loop\n+\/\/ -----------------------------------------\n+\/\/\n+\/\/ As we have seen above, we always need the \"init\" of the main-loop. And if \"iv_scale1 != iv_scale2\", then we\n+\/\/ also need the \"last\" of the main-loop. These values need to be pre-loop invariant, because the check is\n+\/\/ to be performed before the pre-loop (at the predicate or multiversioning selector_if). It will be helpful\n+\/\/ to recall the iv structure in the pre and main-loop:\n+\/\/\n+\/\/                  | iv = pre_init\n+\/\/                  |\n+\/\/   Pre-Loop       | +----------------+\n+\/\/                  phi                |\n+\/\/                   |                 |  -> pre_last: last iv value in pre-loop\n+\/\/                   + pre_iv_stride   |\n+\/\/                   |-----------------+\n+\/\/                   | exit check: < pre_limit\n+\/\/                   |\n+\/\/                   | iv = main_init = init\n+\/\/                   |\n+\/\/   Main-Loop       | +------------------------------+\n+\/\/                   phi                              |\n+\/\/                    |                               | -> last: last iv value in main-loop\n+\/\/                    + main_iv_stride = iv_stride    |\n+\/\/                    |-------------------------------+\n+\/\/                    | exit check: < main_limit = limit\n+\/\/\n+\/\/ Unfortunately, the init (aka. main_init) is not pre-loop invariant, rather it is only available\n+\/\/ after the pre-loop. We will have to compute:\n+\/\/\n+\/\/   pre_last = LAST(pre_init, pre_iv_stride, pre_limit)\n+\/\/   init = pre_last + pre_iv_stride\n+\/\/\n+\/\/ If we need \"last\", we unfortunately must compute it as well:\n+\/\/\n+\/\/   last = LAST(init, iv_stride, limit)\n+\/\/\n+\/\/\n+\/\/ These computations assume that we indeed do enter the main-loop - otherwise\n+\/\/ it does not make sense to talk about the \"last main iteration\". Of course\n+\/\/ entering the main-loop implies that we entered the pre-loop already. But\n+\/\/ what happens if we check the aliasing runtime check, but later would never\n+\/\/ enter the main-loop?\n+\/\/\n+\/\/ First: no matter if we pass or fail the aliasing runtime check, we will\n+\/\/ not get wrong results. If we fail the check, we end up in the less optimized\n+\/\/ slow-loop. If we pass the check, and we don't enter the main-loop, we\n+\/\/ never rely on the aliasing check, after all only the vectorized main-loop\n+\/\/ (and the vectorized post-loop) rely on the aliasing check.\n+\/\/\n+\/\/ But: The worry is that we may fail the aliasing runtime check \"spuriously\",\n+\/\/ i.e. even though we would never enter the main-loop, and that this could have\n+\/\/ unfortunate side-effects (for example deopting unnecessarily). Let's\n+\/\/ look at the two possible cases:\n+\/\/  1) We would never even enter the pre-loop.\n+\/\/     There are only predicates between the aliasing runtime check and the pre-loop,\n+\/\/     so a predicate would have to fail. These are rather rare cases. If we\n+\/\/     are using multiversioning for the aliasing runtime check, we would\n+\/\/     immediately fail the predicate in either the slow or fast loop, so\n+\/\/     the decision of the aliasing runtime check does not matter. But if\n+\/\/     we are using a predicate for the aliaing runtime check, then we may\n+\/\/     end up deopting twice: once for the aliasing runtime check, and then\n+\/\/     again for the other predicate. This would not be great, but again,\n+\/\/     failing predicates are rare in the first place.\n+\/\/\n+\/\/  2) We would enter the pre-loop, but not the main-loop.\n+\/\/     The pre_last must be accurate, because we are entering the pre-loop.\n+\/\/     But then we fail the zero-trip guard of the main-loop. Thus, for the\n+\/\/     main-loop, the init lies \"after\" the limit. Thus, the computed last\n+\/\/     for the main-loop equals the init. This means that span1 and span2\n+\/\/     are zero. Hence, p1(init) and p2(init) would have to alias for the\n+\/\/     aliasing runtime check to fail. Hence, it would not be surprising\n+\/\/     at all if we deopted because of the aliasing runtime check.\n+\/\/\n+bool VPointer::can_make_speculative_aliasing_check_with(const VPointer& other) const {\n+  const VPointer& vp1 = *this;\n+  const VPointer& vp2 = other;\n+\n+  if (!_vloop.use_speculative_aliasing_checks()) { return false; }\n+\n+  \/\/ Both pointers need a nice linear form, otherwise we cannot formulate the check.\n+  if (!vp1.is_valid() || !vp2.is_valid()) { return false; }\n+\n+  \/\/ The pointers always overlap -> a speculative check would always fail.\n+  if (vp1.always_overlaps_with(vp2)) { return false; }\n+\n+  \/\/ The pointers never overlap -> a speculative check would always succeed.\n+  assert(!vp1.never_overlaps_with(vp2), \"ensured by caller\");\n+\n+  \/\/ The speculative aliasing check happens either at the AutoVectorization predicate\n+  \/\/ or at the multiversion_if. That is before the pre-loop. From the construction of\n+  \/\/ VPointer, we already know that all its variables (except iv) are pre-loop invariant.\n+  \/\/\n+  \/\/ For the computation of main_init, we also need the pre_limit, and so we need\n+  \/\/ to check that this value is pre-loop invariant. In the case of non-equal iv_scales,\n+  \/\/ we also need the main_limit in the aliasing check, and so this value must then\n+  \/\/ also be pre-loop invariant.\n+  Opaque1Node* pre_limit_opaq = _vloop.pre_loop_end()->limit()->as_Opaque1();\n+  Node* pre_limit = pre_limit_opaq->in(1);\n+  Node* main_limit = _vloop.cl()->limit();\n+\n+  if (!_vloop.is_pre_loop_invariant(pre_limit)) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis()) {\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: pre_limit is not pre-loop independent!\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  if (vp1.iv_scale() != vp2.iv_scale() && !_vloop.is_pre_loop_invariant(main_limit)) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis()) {\n+      tty->print_cr(\"VPointer::can_make_speculative_aliasing_check_with: main_limit is not pre-loop independent!\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+\/\/ For description and derivation see \"Computing the last iv value in a loop\".\n+\/\/ Note: the iv computations here should not overflow. But out of an abundance\n+\/\/       of caution, we compute everything in long anyway.\n+Node* make_last(Node* initL, jint stride, Node* limitL, PhaseIdealLoop* phase) {\n+  PhaseIterGVN& igvn = phase->igvn();\n+\n+  Node* abs_strideL = igvn.longcon(abs(stride));\n+  Node* strideL = igvn.longcon(stride);\n+\n+  \/\/ If in some rare case the limit is \"before\" init, then\n+  \/\/ this subtraction could overflow. Doing the calculations\n+  \/\/ in long prevents this. Below, we clamp the \"last\" value\n+  \/\/ back to init, which gets us back into the safe int range.\n+  Node* diffL = (stride > 0) ? new SubLNode(limitL, initL)\n+                             : new SubLNode(initL, limitL);\n+  Node* diffL_m1 = new AddLNode(diffL, igvn.longcon(-1));\n+  Node* k = new DivLNode(nullptr, diffL_m1, abs_strideL);\n+\n+  \/\/ Compute last = init + k * iv_stride\n+  Node* k_mul_stride = new MulLNode(k, strideL);\n+  Node* last = new AddLNode(initL, k_mul_stride);\n+\n+  \/\/ Make sure that the last does not lie \"before\" init.\n+  Node* last_clamped = MaxNode::build_min_max_long(&igvn, initL, last, stride > 0);\n+\n+  phase->register_new_node_with_ctrl_of(diffL,        initL);\n+  phase->register_new_node_with_ctrl_of(diffL_m1,     initL);\n+  phase->register_new_node_with_ctrl_of(k,            initL);\n+  phase->register_new_node_with_ctrl_of(k_mul_stride, initL);\n+  phase->register_new_node_with_ctrl_of(last,         initL);\n+  phase->register_new_node_with_ctrl_of(last_clamped, initL);\n+\n+  return last_clamped;\n+}\n+\n+BoolNode* make_a_plus_b_leq_c(Node* a, Node* b, Node* c, PhaseIdealLoop* phase) {\n+  Node* a_plus_b = new AddLNode(a, b);\n+  Node* cmp = CmpNode::make(a_plus_b, c, T_LONG, true);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::le);\n+  phase->register_new_node_with_ctrl_of(a_plus_b, a);\n+  phase->register_new_node_with_ctrl_of(cmp, a);\n+  phase->register_new_node_with_ctrl_of(bol, a);\n+  return bol;\n+}\n+\n+BoolNode* VPointer::make_speculative_aliasing_check_with(const VPointer& other, Node* ctrl) const {\n+  \/\/ Ensure iv_scale1 <= iv_scale2.\n+  const VPointer& vp1 = (this->iv_scale() <= other.iv_scale()) ? *this : other;\n+  const VPointer& vp2 = (this->iv_scale() <= other.iv_scale()) ? other :*this ;\n+  assert(vp1.iv_scale() <= vp2.iv_scale(), \"ensured by swapping if necessary\");\n+\n+  assert(vp1.can_make_speculative_aliasing_check_with(vp2), \"sanity\");\n+\n+  PhaseIdealLoop* phase = _vloop.phase();\n+  PhaseIterGVN& igvn = phase->igvn();\n+\n+  \/\/ init (aka main_init): compute it from the the pre-loop structure.\n+  \/\/ As described above, we cannot just take the _vloop.cl().init_trip(), because that\n+  \/\/ value is pre-loop dependent, and we need a pre-loop independent value, so we can\n+  \/\/ have it available at the predicate \/ multiversioning selector_if.\n+  \/\/ For this, we need to be sure that the pre_limit is pre-loop independent as well,\n+  \/\/ see can_make_speculative_aliasing_check_with.\n+  Node* pre_init = _vloop.pre_loop_end()->init_trip();\n+  jint pre_iv_stride = _vloop.pre_loop_end()->stride_con();\n+  Opaque1Node* pre_limit_opaq = _vloop.pre_loop_end()->limit()->as_Opaque1();\n+  Node* pre_limit = pre_limit_opaq->in(1);\n+  assert(_vloop.is_pre_loop_invariant(pre_init),  \"needed for aliasing check before pre-loop\");\n+  assert(_vloop.is_pre_loop_invariant(pre_limit), \"needed for aliasing check before pre-loop\");\n+\n+  Node* pre_initL = new ConvI2LNode(pre_init);\n+  Node* pre_limitL = new ConvI2LNode(pre_limit);\n+  phase->register_new_node_with_ctrl_of(pre_initL, pre_init);\n+  phase->register_new_node_with_ctrl_of(pre_limitL, pre_init);\n+\n+  Node* pre_lastL = make_last(pre_initL, pre_iv_stride, pre_limitL, phase);\n+\n+  Node* main_initL = new AddLNode(pre_lastL, igvn.longcon(pre_iv_stride));\n+  phase->register_new_node_with_ctrl_of(main_initL, pre_init);\n+\n+  Node* main_init = new ConvL2INode(main_initL);\n+  phase->register_new_node_with_ctrl_of(main_init, pre_init);\n+\n+  Node* p1_init = vp1.make_pointer_expression(main_init, ctrl);\n+  Node* p2_init = vp2.make_pointer_expression(main_init, ctrl);\n+  Node* size1 = igvn.longcon(vp1.size());\n+  Node* size2 = igvn.longcon(vp2.size());\n+\n+#ifdef ASSERT\n+  if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+    tty->print_cr(\"\\nVPointer::make_speculative_aliasing_check_with:\");\n+    tty->print(\"pre_init:  \"); pre_init->dump();\n+    tty->print(\"pre_limit: \"); pre_limit->dump();\n+    tty->print(\"pre_lastL: \"); pre_lastL->dump();\n+    tty->print(\"main_init: \"); main_init->dump();\n+    tty->print_cr(\"p1_init:\");\n+    p1_init->dump_bfs(5, nullptr, \"\");\n+    tty->print_cr(\"p2_init:\");\n+    p2_init->dump_bfs(5, nullptr, \"\");\n+  }\n+#endif\n+\n+  BoolNode* condition1 = nullptr;\n+  BoolNode* condition2 = nullptr;\n+  if (vp1.iv_scale() == vp2.iv_scale()) {\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print_cr(\"  Same iv_scale(%d) -> parallel lines -> simple conditions:\", vp1.iv_scale());\n+      tty->print_cr(\"  p1(init) + size1 <= p2(init)  OR  p2(init) + size2 <= p1(init)\");\n+      tty->print_cr(\"  -------- condition1 --------      ------- condition2 ---------\");\n+    }\n+#endif\n+    condition1 = make_a_plus_b_leq_c(p1_init, size1, p2_init, phase);\n+    condition2 = make_a_plus_b_leq_c(p2_init, size2, p1_init, phase);\n+  } else {\n+    assert(vp1.iv_scale() < vp2.iv_scale(), \"assumed in proof, established above by swapping\");\n+\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print_cr(\"  Different iv_scale -> lines with different slopes -> more complex conditions:\");\n+      tty->print_cr(\"  p1(init)         + size1 <= p2(init)          OR  p2(init) + span2 + size2 <= p1(init) + span1  (if iv_stride >= 0)\");\n+      tty->print_cr(\"  p1(init) + span1 + size1 <= p2(init) + span2  OR  p2(init)         + size2 <= p1(init)          (if iv_stride <= 0)\");\n+      tty->print_cr(\"  ---------------- condition1 ----------------      --------------- condition2 -----------------\");\n+    }\n+#endif\n+\n+    \/\/ last (aka main_last): compute from main-loop structure.\n+    jint main_iv_stride = _vloop.iv_stride();\n+    Node* main_limit = _vloop.cl()->limit();\n+    assert(_vloop.is_pre_loop_invariant(main_limit), \"needed for aliasing check before pre-loop\");\n+\n+    Node* main_limitL = new ConvI2LNode(main_limit);\n+    phase->register_new_node_with_ctrl_of(main_limitL, pre_init);\n+\n+    Node* main_lastL = make_last(main_initL, main_iv_stride, main_limitL, phase);\n+\n+    \/\/ Compute span1 = (last - init) * iv_scale1\n+    \/\/         span2 = (last - init) * iv_scale2\n+    Node* last_minus_init = new SubLNode(main_lastL, main_initL);\n+    Node* iv_scale1 = igvn.longcon(vp1.iv_scale());\n+    Node* iv_scale2 = igvn.longcon(vp2.iv_scale());\n+    Node* span1 = new MulLNode(last_minus_init, iv_scale1);\n+    Node* span2 = new MulLNode(last_minus_init, iv_scale2);\n+\n+    phase->register_new_node_with_ctrl_of(last_minus_init, pre_init);\n+    phase->register_new_node_with_ctrl_of(span1,           pre_init);\n+    phase->register_new_node_with_ctrl_of(span2,           pre_init);\n+\n+#ifdef ASSERT\n+    if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+      tty->print(\"main_limitL: \"); main_limitL->dump();\n+      tty->print(\"main_lastL: \"); main_lastL->dump();\n+      tty->print(\"p1_init: \"); p1_init->dump();\n+      tty->print(\"p2_init: \"); p2_init->dump();\n+      tty->print(\"size1: \"); size1->dump();\n+      tty->print(\"size2: \"); size2->dump();\n+      tty->print_cr(\"span1: \"); span1->dump_bfs(5, nullptr, \"\");\n+      tty->print_cr(\"span2: \"); span2->dump_bfs(5, nullptr, \"\");\n+    }\n+#endif\n+\n+    Node* p1_init_plus_span1 = new AddLNode(p1_init, span1);\n+    Node* p2_init_plus_span2 = new AddLNode(p2_init, span2);\n+    phase->register_new_node_with_ctrl_of(p1_init_plus_span1, pre_init);\n+    phase->register_new_node_with_ctrl_of(p2_init_plus_span2, pre_init);\n+    if (_vloop.iv_stride() >= 0) {\n+      condition1 = make_a_plus_b_leq_c(p1_init,            size1, p2_init,            phase);\n+      condition2 = make_a_plus_b_leq_c(p2_init_plus_span2, size2, p1_init_plus_span1, phase);\n+    } else {\n+      condition1 = make_a_plus_b_leq_c(p1_init_plus_span1, size1, p2_init_plus_span2, phase);\n+      condition2 = make_a_plus_b_leq_c(p2_init,            size2, p1_init,            phase);\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  if (_vloop.is_trace_speculative_aliasing_analysis() || _vloop.is_trace_speculative_runtime_checks()) {\n+    tty->print_cr(\"condition1:\");\n+    condition1->dump_bfs(5, nullptr, \"\");\n+    tty->print_cr(\"condition2:\");\n+    condition2->dump_bfs(5, nullptr, \"\");\n@@ -431,0 +1072,94 @@\n+#endif\n+\n+  \/\/ Construct \"condition1 OR condition2\". Convert the bol value back to an int value\n+  \/\/ that we can \"OR\" to create a single bol value. On x64, the two CMove are converted\n+  \/\/ to two setbe instructions which capture the condition bits to a register, meaning\n+  \/\/ we only have a single branch in the end.\n+  Node* zero = igvn.intcon(0);\n+  Node* one  = igvn.intcon(1);\n+  Node* cmov1 = new CMoveINode(condition1, zero, one, TypeInt::INT);\n+  Node* cmov2 = new CMoveINode(condition2, zero, one, TypeInt::INT);\n+  phase->register_new_node_with_ctrl_of(cmov1, main_initL);\n+  phase->register_new_node_with_ctrl_of(cmov2, main_initL);\n+\n+  Node* c1_or_c2 = new OrINode(cmov1, cmov2);\n+  Node* cmp = CmpNode::make(c1_or_c2, zero, T_INT);\n+  BoolNode* bol = new BoolNode(cmp, BoolTest::ne);\n+  phase->register_new_node_with_ctrl_of(c1_or_c2, main_initL);\n+  phase->register_new_node_with_ctrl_of(cmp, main_initL);\n+  phase->register_new_node_with_ctrl_of(bol, main_initL);\n+\n+  return bol;\n+}\n+\n+\/\/ Creates the long pointer expression, evaluated with iv = iv_value.\n+\/\/ Since we are casting pointers to long with CastP2X, we must be careful\n+\/\/ that the values do not cross SafePoints, where the oop could be moved\n+\/\/ by GC, and the already cast value would not be updated, as it is not in\n+\/\/ the oop-map. For this, we must set a ctrl that is late enough, so that we\n+\/\/ cannot cross a SafePoint.\n+Node* VPointer::make_pointer_expression(Node* iv_value, Node* ctrl) const {\n+  assert(is_valid(), \"must be valid\");\n+\n+  PhaseIdealLoop* phase = _vloop.phase();\n+  PhaseIterGVN& igvn = phase->igvn();\n+  Node* iv = _vloop.iv();\n+\n+  auto maybe_add = [&] (Node* n1, Node* n2, BasicType bt) {\n+    if (n1 == nullptr) { return n2; }\n+    Node* add = AddNode::make(n1, n2, bt);\n+    phase->register_new_node(add, ctrl);\n+    return add;\n+  };\n+\n+  Node* expression = nullptr;\n+  mem_pointer().for_each_raw_summand_of_int_group(0, [&] (const MemPointerRawSummand& s) {\n+    Node* node = nullptr;\n+    if (s.is_con()) {\n+      \/\/ Long constant.\n+      NoOverflowInt con = s.scaleI() * s.scaleL();\n+      node = igvn.longcon(con.value());\n+    } else {\n+      \/\/ Long variable.\n+      assert(s.scaleI().is_one(), \"must be long variable\");\n+      Node* scaleL = igvn.longcon(s.scaleL().value());\n+      Node* variable = (s.variable() == iv) ? iv_value : s.variable();\n+      if (variable->bottom_type()->isa_ptr() != nullptr) {\n+        \/\/ Use a ctrl that is late enough, so that we do not\n+        \/\/ evaluate the cast before a SafePoint.\n+        variable = new CastP2XNode(ctrl, variable);\n+        phase->register_new_node(variable, ctrl);\n+      }\n+      node = new MulLNode(scaleL, variable);\n+      phase->register_new_node(node, ctrl);\n+    }\n+    expression = maybe_add(expression, node, T_LONG);\n+  });\n+\n+  int max_int_group = mem_pointer().max_int_group();\n+  for (int int_group = 1; int_group <= max_int_group; int_group++) {\n+    Node* int_expression = nullptr;\n+    NoOverflowInt int_group_scaleL;\n+    mem_pointer().for_each_raw_summand_of_int_group(int_group, [&] (const MemPointerRawSummand& s) {\n+      Node* node = nullptr;\n+      if (s.is_con()) {\n+        node = igvn.intcon(s.scaleI().value());\n+      } else {\n+        Node* scaleI = igvn.intcon(s.scaleI().value());\n+        Node* variable = (s.variable() == iv) ? iv_value : s.variable();\n+        node = new MulINode(scaleI, variable);\n+        phase->register_new_node(node, ctrl);\n+      }\n+      int_group_scaleL = s.scaleL(); \/\/ remember for multiplication after ConvI2L\n+      int_expression = maybe_add(int_expression, node, T_INT);\n+    });\n+    assert(int_expression != nullptr, \"no empty int group\");\n+    int_expression = new ConvI2LNode(int_expression);\n+    phase->register_new_node(int_expression, ctrl);\n+    Node* scaleL = igvn.longcon(int_group_scaleL.value());\n+    int_expression = new MulLNode(scaleL, int_expression);\n+    phase->register_new_node(int_expression, ctrl);\n+    expression = maybe_add(expression, int_expression, T_LONG);\n+  }\n+\n+  return expression;\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":766,"deletions":31,"binary":false,"changes":797,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -164,0 +165,4 @@\n+  bool use_speculative_aliasing_checks() const {\n+    return are_speculative_checks_possible() && UseAutoVectorizationSpeculativeAliasingChecks;\n+  }\n+\n@@ -206,0 +211,4 @@\n+\n+  bool is_trace_speculative_aliasing_analysis() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::SPECULATIVE_ALIASING_ANALYSIS);\n+  }\n@@ -225,0 +234,1 @@\n+    \/\/ Usually the ctrl of n is already before the pre-loop.\n@@ -226,4 +236,2 @@\n-\n-    \/\/ Quick test: is it in the main-loop?\n-    if (lpt()->is_member(phase()->get_loop(ctrl))) {\n-      return false;\n+    if (is_before_pre_loop(ctrl)) {\n+      return true;\n@@ -232,2 +240,6 @@\n-    \/\/ Is it before the pre-loop?\n-    return phase()->is_dominator(ctrl, pre_loop_head());\n+    \/\/ But in some cases, the ctrl of n is between the pre and\n+    \/\/ main loop, but the early ctrl is before the pre-loop.\n+    \/\/ As long as the early ctrl is before the pre-loop, we can\n+    \/\/ compute n before the pre-loop.\n+    Node* early = phase()->compute_early_ctrl(n, ctrl);\n+    return is_before_pre_loop(early);\n@@ -242,0 +254,10 @@\n+\n+  bool is_before_pre_loop(Node* ctrl) const {\n+    \/\/ Quick test: is it in the main-loop?\n+    if (lpt()->is_member(phase()->get_loop(ctrl))) {\n+      return false;\n+    }\n+\n+    \/\/ Is it before the pre-loop?\n+    return phase()->is_dominator(ctrl, pre_loop_head());\n+  }\n@@ -572,0 +594,3 @@\n+\/\/    - Strong edge: must be respected.\n+\/\/    - Weak edge:   if we add a speculative aliasing check, we can violate\n+\/\/                   the edge, i.e. swap the order.\n@@ -614,1 +639,1 @@\n-  void add_node(MemNode* n, GrowableArray<int>& memory_pred_edges);\n+  void add_node(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges);\n@@ -628,2 +653,3 @@\n-    const uint _memory_pred_edges_length;\n-    int* _memory_pred_edges; \/\/ memory pred-edges, mapping to bb_idx\n+    const uint _num_strong_memory_edges;\n+    const uint _num_weak_memory_edges;\n+    int* _memory_edges; \/\/ memory pred-edges, mapping to bb_idx\n@@ -631,1 +657,1 @@\n-    DependencyNode(MemNode* n, GrowableArray<int>& memory_pred_edges, Arena* arena);\n+    DependencyNode(MemNode* n, GrowableArray<int>& strong_memory_edges, GrowableArray<int>& weak_memory_edges, Arena* arena);\n@@ -633,1 +659,7 @@\n-    uint memory_pred_edges_length() const { return _memory_pred_edges_length; }\n+    uint num_strong_memory_edges() const { return _num_strong_memory_edges; }\n+    uint num_weak_memory_edges() const { return _num_weak_memory_edges; }\n+\n+    int strong_memory_edge(uint i) const {\n+      assert(i < _num_strong_memory_edges, \"bounds check\");\n+      return _memory_edges[i];\n+    }\n@@ -635,3 +667,3 @@\n-    int memory_pred_edge(uint i) const {\n-      assert(i < _memory_pred_edges_length, \"bounds check\");\n-      return _memory_pred_edges[i];\n+    int weak_memory_edge(uint i) const {\n+      assert(i < _num_weak_memory_edges, \"bounds check\");\n+      return _memory_edges[_num_strong_memory_edges + i];\n@@ -652,0 +684,9 @@\n+    bool _is_current_weak_memory_edge;\n+\n+    \/\/ Iterate in data edges, i.e. iterate node->in(i), excluding control and memory edges.\n+    int _next_data_edge;\n+    int _end_data_edge;\n+\n+    \/\/ Iterate in dependency_node->strong_memory_edges()\n+    int _next_strong_memory_edge;\n+    int _end_strong_memory_edge;\n@@ -653,3 +694,3 @@\n-    \/\/ Iterate in node->in(i)\n-    int _next_pred;\n-    int _end_pred;\n+    \/\/ Iterate in dependency_node->weak_memory_edge()\n+    int _next_weak_memory_edge;\n+    int _end_weak_memory_edge;\n@@ -657,3 +698,0 @@\n-    \/\/ Iterate in dependency_node->memory_pred_edge(i)\n-    int _next_memory_pred;\n-    int _end_memory_pred;\n@@ -665,0 +703,1 @@\n+\n@@ -669,0 +708,1 @@\n+\n@@ -673,0 +713,5 @@\n+\n+    bool is_current_weak_memory_edge() const {\n+      assert(!done(), \"not done yet\");\n+      return _is_current_weak_memory_edge;\n+    }\n@@ -937,0 +982,37 @@\n+  \/\/ Delegate to MemPointer::always_overlaps_with, but guard for invalid cases\n+  \/\/ where we must return a conservative answer: unknown overlap, return false.\n+  bool always_overlaps_with(const VPointer& other) const {\n+    if (!is_valid() || !other.is_valid()) {\n+#ifndef PRODUCT\n+      if (_vloop.mptrace().is_trace_overlap()) {\n+        tty->print_cr(\"VPointer::always_overlaps_with: invalid VPointer, overlap unknown.\");\n+      }\n+#endif\n+      return false;\n+    }\n+    return mem_pointer().always_overlaps_with(other.mem_pointer());\n+  }\n+\n+  static int cmp_summands(const VPointer& vp1, const VPointer& vp2) {\n+    return MemPointer::cmp_summands(vp1.mem_pointer(), vp2.mem_pointer());\n+  }\n+\n+  static int cmp_con(const VPointer& vp1, const VPointer& vp2) {\n+    \/\/ We use two comparisons, because a subtraction could underflow.\n+    jint con1 = vp1.con();\n+    jint con2 = vp2.con();\n+    if (con1 < con2) { return -1; }\n+    if (con1 > con2) { return  1; }\n+    return 0;\n+  }\n+\n+  static int cmp_summands_and_con(const VPointer& vp1, const VPointer& vp2) {\n+    int cmp = cmp_summands(vp1, vp2);\n+    if (cmp != 0) { return cmp; }\n+    return cmp_con(vp1, vp2);\n+  }\n+\n+  bool can_make_speculative_aliasing_check_with(const VPointer& other) const;\n+  Node* make_pointer_expression(Node* iv_value, Node* ctrl) const;\n+  BoolNode* make_speculative_aliasing_check_with(const VPointer& other, Node* ctrl) const;\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":102,"deletions":20,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -995,0 +995,4 @@\n+    case Op_MoveF2I:\n+    case Op_MoveD2L:\n+    case Op_MoveL2D:\n+    case Op_MoveI2F:\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/vectorization.hpp\"\n@@ -60,1 +61,1 @@\n-  collect_nodes_without_req_or_dependency(stack);\n+  collect_nodes_without_strong_in_edges(stack);\n@@ -75,2 +76,5 @@\n-      for (int i = 0; i < vtn->outs(); i++) {\n-        VTransformNode* use = vtn->out(i);\n+      \/\/ We only need to respect the strong edges (data edges and strong memory edges).\n+      \/\/ Violated weak memory edges are allowed, but require a speculative aliasing\n+      \/\/ runtime check, see VTransform::apply_speculative_aliasing_runtime_checks.\n+      for (uint i = 0; i < vtn->out_strong_edges(); i++) {\n+        VTransformNode* use = vtn->out_strong_edge(i);\n@@ -112,2 +116,2 @@\n-\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n-void VTransformGraph::collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+\/\/ Push all \"root\" nodes, i.e. those that have no strong input edges (data edges and strong memory edges):\n+void VTransformGraph::collect_nodes_without_strong_in_edges(GrowableArray<VTransformNode*>& stack) const {\n@@ -116,1 +120,1 @@\n-    if (!vtn->has_req_or_dependency()) {\n+    if (!vtn->has_strong_in_edge()) {\n@@ -147,1 +151,1 @@\n-void VTransform::apply_speculative_runtime_checks() {\n+void VTransform::apply_speculative_alignment_runtime_checks() {\n@@ -151,1 +155,1 @@\n-      tty->print_cr(\"\\nVTransform::apply_speculative_runtime_checks: native memory alignment\");\n+      tty->print_cr(\"\\nVTransform::apply_speculative_alignment_runtime_checks: native memory alignment\");\n@@ -202,1 +206,1 @@\n-  Node* mask_alignment = igvn().intcon(alignment-1);\n+  Node* mask_alignment = phase()->intcon(alignment-1);\n@@ -208,1 +212,1 @@\n-  Node* zero = igvn().intcon(0);\n+  Node* zero = phase()->intcon(0);\n@@ -216,1 +220,1 @@\n-  add_speculative_check(bol_alignment);\n+  add_speculative_check([&] (Node* ctrl) { return bol_alignment; });\n@@ -219,1 +223,208 @@\n-void VTransform::add_speculative_check(BoolNode* bol) {\n+class VPointerWeakAliasingPair : public StackObj {\n+private:\n+  \/\/ Using references instead of pointers would be preferrable, but GrowableArray\n+  \/\/ requires a default constructor, and we do not have a default constructor for\n+  \/\/ VPointer.\n+  const VPointer* _vp1 = nullptr;\n+  const VPointer* _vp2 = nullptr;\n+\n+  VPointerWeakAliasingPair(const VPointer& vp1, const VPointer& vp2) : _vp1(&vp1), _vp2(&vp2) {\n+    assert(vp1.is_valid(), \"sanity\");\n+    assert(vp2.is_valid(), \"sanity\");\n+    assert(!vp1.never_overlaps_with(vp2), \"otherwise no aliasing\");\n+    assert(!vp1.always_overlaps_with(vp2), \"otherwise must be strong\");\n+    assert(VPointer::cmp_summands_and_con(vp1, vp2) <= 0, \"must be sorted\");\n+  }\n+\n+public:\n+  \/\/ Default constructor to make GrowableArray happy.\n+  VPointerWeakAliasingPair() : _vp1(nullptr), _vp2(nullptr) {}\n+\n+  static VPointerWeakAliasingPair make(const VPointer& vp1, const VPointer& vp2) {\n+    if (VPointer::cmp_summands_and_con(vp1, vp2) <= 0) {\n+      return VPointerWeakAliasingPair(vp1, vp2);\n+    } else {\n+      return VPointerWeakAliasingPair(vp2, vp1);\n+    }\n+  }\n+\n+  const VPointer& vp1() const { return *_vp1; }\n+  const VPointer& vp2() const { return *_vp2; }\n+\n+  \/\/ Sort by summands, so that pairs with same summands (summand1, summands2) are adjacent.\n+  static int cmp_for_sort(VPointerWeakAliasingPair* pair1, VPointerWeakAliasingPair* pair2) {\n+    int cmp_summands1 = VPointer::cmp_summands(pair1->vp1(), pair2->vp1());\n+    if (cmp_summands1 != 0) { return cmp_summands1; }\n+    return VPointer::cmp_summands(pair1->vp2(), pair2->vp2());\n+  }\n+};\n+\n+void VTransform::apply_speculative_aliasing_runtime_checks() {\n+\n+  if (_vloop.use_speculative_aliasing_checks()) {\n+\n+#ifdef ASSERT\n+    if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+      tty->print_cr(\"\\nVTransform::apply_speculative_aliasing_runtime_checks: speculative aliasing analysis runtime checks\");\n+    }\n+#endif\n+\n+    \/\/ It would be nice to add a ResourceMark here. But it would collide with resource allocation\n+    \/\/ in PhaseIdealLoop::set_idom for _idom and _dom_depth. See also JDK-8337015.\n+    VectorSet visited;\n+    GrowableArray<VPointerWeakAliasingPair> weak_aliasing_pairs;\n+\n+    const GrowableArray<VTransformNode*>& schedule = _graph.get_schedule();\n+    for (int i = 0; i < schedule.length(); i++) {\n+      VTransformNode* vtn = schedule.at(i);\n+      for (uint i = 0; i < vtn->out_weak_edges(); i++) {\n+        VTransformNode* use = vtn->out_weak_edge(i);\n+        if (visited.test(use->_idx)) {\n+          \/\/ The use node was already visited, i.e. is higher up in the schedule.\n+          \/\/ The \"out\" edge thus points backward, i.e. it is violated.\n+          const VPointer& vp1 = vtn->vpointer();\n+          const VPointer& vp2 = use->vpointer();\n+#ifdef ASSERT\n+          if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+            tty->print_cr(\"\\nViolated Weak Edge:\");\n+            vtn->print();\n+            vp1.print_on(tty);\n+            use->print();\n+            vp2.print_on(tty);\n+          }\n+#endif\n+\n+          \/\/ We could generate checks for the pair (vp1, vp2) directly. But in\n+          \/\/ some graphs, this generates quadratically many checks. Example:\n+          \/\/\n+          \/\/   set1: a[i+0] a[i+1] a[i+2] a[i+3]\n+          \/\/   set2: b[i+0] b[i+1] b[i+2] b[i+3]\n+          \/\/\n+          \/\/ We may have a weak memory edge between every memory access from\n+          \/\/ set1 to every memory access from set2. In this example, this would\n+          \/\/ be 4 * 4 = 16 checks. But instead, we can create a union VPointer\n+          \/\/ for set1 and set2 each, and only create a single check.\n+          \/\/\n+          \/\/   set1: a[i+0, size = 4]\n+          \/\/   set1: b[i+0, size = 4]\n+          \/\/\n+          \/\/ For this, we add all pairs to an array, and process it below.\n+          weak_aliasing_pairs.push(VPointerWeakAliasingPair::make(vp1, vp2));\n+        }\n+      }\n+      visited.set(vtn->_idx);\n+    }\n+\n+    \/\/ Sort so that all pairs with the same summands (summands1, summands2)\n+    \/\/ are consecutive, i.e. in the same group. This allows us to do a linear\n+    \/\/ walk over all pairs of a group and create the union VPointers.\n+    weak_aliasing_pairs.sort(VPointerWeakAliasingPair::cmp_for_sort);\n+\n+    int group_start = 0;\n+    while (group_start < weak_aliasing_pairs.length()) {\n+      \/\/ New group: pick the first pair as the reference.\n+      const VPointer* vp1 = &weak_aliasing_pairs.at(group_start).vp1();\n+      const VPointer* vp2 = &weak_aliasing_pairs.at(group_start).vp2();\n+      jint size1 = vp1->size();\n+      jint size2 = vp2->size();\n+      int group_end = group_start + 1;\n+      while (group_end < weak_aliasing_pairs.length()) {\n+        const VPointer* vp1_next = &weak_aliasing_pairs.at(group_end).vp1();\n+        const VPointer* vp2_next = &weak_aliasing_pairs.at(group_end).vp2();\n+        jint size1_next = vp1_next->size();\n+        jint size2_next = vp2_next->size();\n+\n+        \/\/ Different summands -> different group.\n+        if (VPointer::cmp_summands(*vp1, *vp1_next) != 0) { break; }\n+        if (VPointer::cmp_summands(*vp2, *vp2_next) != 0) { break; }\n+\n+        \/\/ Pick the one with the lower con as the reference.\n+        if (vp1->con() > vp1_next->con()) {\n+          swap(vp1, vp1_next);\n+          swap(size1, size1_next);\n+        }\n+        if (vp2->con() > vp2_next->con()) {\n+          swap(vp2, vp2_next);\n+          swap(size2, size2_next);\n+        }\n+\n+        \/\/ Compute the distance from vp1 to vp1_next + size, to get a size that would include vp1_next.\n+        NoOverflowInt new_size1 = NoOverflowInt(vp1_next->con()) + NoOverflowInt(size1_next) - NoOverflowInt(vp1->con());\n+        NoOverflowInt new_size2 = NoOverflowInt(vp2_next->con()) + NoOverflowInt(size2_next) - NoOverflowInt(vp2->con());\n+        if (new_size1.is_NaN() || new_size2.is_NaN()) { break; \/* overflow -> new group *\/ }\n+\n+        \/\/ The \"next\" VPointer indeed belong to the group.\n+        \/\/\n+        \/\/ vp1:       |-------------->\n+        \/\/ vp1_next:            |---------------->\n+        \/\/ result:    |-------------------------->\n+        \/\/\n+        \/\/ vp1:       |-------------------------->\n+        \/\/ vp1_next:            |------->\n+        \/\/ result:    |-------------------------->\n+        \/\/\n+        size1 = MAX2(size1, new_size1.value());\n+        size2 = MAX2(size2, new_size2.value());\n+        group_end++;\n+      }\n+      \/\/ Create \"union\" VPointer that cover all VPointer from the group.\n+      const VPointer vp1_union = vp1->make_with_size(size1);\n+      const VPointer vp2_union = vp2->make_with_size(size2);\n+\n+#ifdef ASSERT\n+      if (_trace._speculative_aliasing_analysis || _trace._speculative_runtime_checks) {\n+        tty->print_cr(\"\\nUnion of %d weak aliasing edges:\", group_end - group_start);\n+        vp1_union.print_on(tty);\n+        vp2_union.print_on(tty);\n+      }\n+\n+      \/\/ Verification - union must contain all VPointer of the group.\n+      for (int i = group_start; i < group_end; i++) {\n+        const VPointer& vp1_i = weak_aliasing_pairs.at(i).vp1();\n+        const VPointer& vp2_i = weak_aliasing_pairs.at(i).vp2();\n+        assert(vp1_union.con() <= vp1_i.con(), \"must start before\");\n+        assert(vp2_union.con() <= vp2_i.con(), \"must start before\");\n+        assert(vp1_union.size() >= vp1_i.size(), \"must end after\");\n+        assert(vp2_union.size() >= vp2_i.size(), \"must end after\");\n+      }\n+#endif\n+\n+      add_speculative_check([&] (Node* ctrl) {\n+        return vp1_union.make_speculative_aliasing_check_with(vp2_union, ctrl);\n+      });\n+\n+      group_start = group_end;\n+    }\n+  }\n+}\n+\n+\/\/ Runtime Checks:\n+\/\/   Some required properties cannot be proven statically, and require a\n+\/\/   runtime check:\n+\/\/   - Alignment:\n+\/\/       See VTransform::add_speculative_alignment_check\n+\/\/   - Aliasing:\n+\/\/       See VTransform::apply_speculative_aliasing_runtime_checks\n+\/\/   There is a two staged approach for compilation:\n+\/\/   - AutoVectorization Predicate:\n+\/\/       See VM flag UseAutoVectorizationPredicate and documentation in predicates.hpp\n+\/\/       We speculate that the checks pass, and only compile a vectorized  loop.\n+\/\/       We expect the checks to pass in almost all cases, and so we only need\n+\/\/       to compile and cache the vectorized loop.\n+\/\/       If the predicate ever fails, we deoptimize, and eventually compile\n+\/\/       without predicate. This means we will recompile with multiversioning.\n+\/\/    - Multiversioning:\n+\/\/       See VM Flag LoopMultiversioning and documentaiton in loopUnswitch.cpp\n+\/\/       If the predicate is not available or previously failed, then we compile\n+\/\/       a vectorized and a scalar loop. If the runtime check passes we take the\n+\/\/       vectorized loop, else the scalar loop.\n+\/\/       Multiversioning takes more compile time and code cache, but it also\n+\/\/       produces fast code for when the runtime check passes (vectorized) and\n+\/\/       when it fails (scalar performance).\n+\/\/\n+\/\/ Callback:\n+\/\/   In some cases, we require the ctrl just before the check iff_speculate to\n+\/\/   generate the values required in the check. We pass this ctrl into the\n+\/\/   callback, which is expected to produce the check, i.e. a BoolNode.\n+template<typename Callback>\n+void VTransform::add_speculative_check(Callback callback) {\n@@ -231,0 +442,4 @@\n+\n+  \/\/ Create the check, given the ctrl just before the iff.\n+  BoolNode* bol = callback(iff_speculate->in(0));\n+\n@@ -429,1 +644,1 @@\n-        const VPointer& p = vtn->vpointer(vloop_analyzer);\n+        const VPointer& p = vtn->vpointer();\n@@ -496,3 +711,8 @@\n-Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n-  assert(n != nullptr, \"must find input IR node\");\n+void VTransformApplyState::set_transformed_node(VTransformNode* vtn, Node* n) {\n+  assert(_vtnode_idx_to_transformed_node.at(vtn->_idx) == nullptr, \"only set once\");\n+  _vtnode_idx_to_transformed_node.at_put(vtn->_idx, n);\n+}\n+\n+Node* VTransformApplyState::transformed_node(const VTransformNode* vtn) const {\n+  Node* n = _vtnode_idx_to_transformed_node.at(vtn->_idx);\n+  assert(n != nullptr, \"must find IR node for vtnode\");\n@@ -502,2 +722,6 @@\n-VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                  const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformMemopScalarNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformDataScalarNode::apply(VTransformApplyState& apply_state) const {\n@@ -508,3 +732,17 @@\n-VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                     const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformLoopPhiNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformCFGNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformOuterNode::apply(VTransformApplyState& apply_state) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformReplicateNode::apply(VTransformApplyState& apply_state) const {\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -512,1 +750,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  register_new_node_from_vectorization(apply_state, vn, val);\n@@ -516,3 +754,2 @@\n-VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                   const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformConvI2LNode::apply(VTransformApplyState& apply_state) const {\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -520,1 +757,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, n, val);\n+  register_new_node_from_vectorization(apply_state, n, val);\n@@ -524,4 +761,3 @@\n-VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformShiftCountNode::apply(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* shift_count_in = apply_state.transformed_node(in_req(1));\n@@ -532,2 +768,2 @@\n-  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n-  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n+  Node* shift_count_masked = new AndINode(shift_count_in, phase->intcon(_mask));\n+  register_new_node_from_vectorization(apply_state, shift_count_masked, shift_count_in);\n@@ -536,1 +772,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n+  register_new_node_from_vectorization(apply_state, vn, shift_count_in);\n@@ -541,4 +777,3 @@\n-VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                         const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+VTransformApplyResult VTransformPopulateIndexNode::apply(VTransformApplyState& apply_state) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  Node* val = apply_state.transformed_node(in_req(1));\n@@ -548,2 +783,2 @@\n-  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  VectorNode* vn = new PopulateIndexNode(val, phase->intcon(1), vt);\n+  register_new_node_from_vectorization(apply_state, vn, val);\n@@ -553,2 +788,1 @@\n-VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                             const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformElementWiseVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -558,1 +792,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -568,3 +802,3 @@\n-  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n-  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n+  Node* in1 =                apply_state.transformed_node(in_req(1));\n+  Node* in2 = (req() >= 3) ? apply_state.transformed_node(in_req(2)) : nullptr;\n+  Node* in3 = (req() >= 4) ? apply_state.transformed_node(in_req(3)) : nullptr;\n@@ -590,1 +824,1 @@\n-    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n+    register_new_node_from_vectorization(apply_state, long_vn, first);\n@@ -608,1 +842,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -612,2 +846,1 @@\n-VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformBoolVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -616,1 +849,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -619,1 +852,1 @@\n-  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n+  VTransformElementWiseVectorNode* vtn_cmp = in_req(1)->isa_ElementWiseVector();\n@@ -623,2 +856,2 @@\n-  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n+  Node* cmp_in1 = apply_state.transformed_node(vtn_cmp->in_req(1));\n+  Node* cmp_in2 = apply_state.transformed_node(vtn_cmp->in_req(2));\n@@ -627,2 +860,2 @@\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n+  PhaseIdealLoop* phase = apply_state.phase();\n+  ConINode* mask_node  = phase->intcon((int)mask);\n@@ -631,1 +864,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -635,2 +868,1 @@\n-VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                           const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformReductionVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -642,2 +874,2 @@\n-  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n+  Node* init = apply_state.transformed_node(in_req(1));\n+  Node* vec  = apply_state.transformed_node(in_req(2));\n@@ -646,1 +878,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -650,2 +882,1 @@\n-VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformLoadVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -659,1 +890,1 @@\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+  BasicType bt = apply_state.vloop_analyzer().types().velt_basic_type(first);\n@@ -664,1 +895,1 @@\n-  const VPointer& load_p = vpointer(vloop_analyzer);\n+  const VPointer& load_p = vpointer();\n@@ -666,1 +897,1 @@\n-    VPointer store_p(mem->as_Mem(), vloop_analyzer.vloop());\n+    VPointer store_p(mem->as_Mem(), apply_state.vloop());\n@@ -677,1 +908,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -681,2 +912,1 @@\n-VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer,\n-                                                       const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+VTransformApplyResult VTransformStoreVectorNode::apply(VTransformApplyState& apply_state) const {\n@@ -691,1 +921,1 @@\n-  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n+  Node* value = apply_state.transformed_node(in_req(MemNode::ValueIn));\n@@ -694,1 +924,1 @@\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(apply_state, vn);\n@@ -698,2 +928,2 @@\n-void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(VTransformApplyState& apply_state, Node* vn) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n@@ -702,1 +932,1 @@\n-  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n+  register_new_node_from_vectorization(apply_state, vn, first);\n@@ -710,2 +940,2 @@\n-void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+void VTransformNode::register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const {\n+  PhaseIdealLoop* phase = apply_state.phase();\n@@ -753,2 +983,8 @@\n-    tty->print(\" |\");\n-    for (int i = _req; i < _in.length(); i++) {\n+    tty->print(\" | strong:\");\n+    for (uint i = _req; i < _in_end_strong_memory_edges; i++) {\n+      print_node_idx(_in.at(i));\n+    }\n+  }\n+  if ((uint)_in.length() > _in_end_strong_memory_edges) {\n+    tty->print(\" | weak:\");\n+    for (uint i = _in_end_strong_memory_edges; i < (uint)_in.length(); i++) {\n@@ -759,1 +995,1 @@\n-  for (int i = 0; i < _out.length(); i++) {\n+  for (uint i = 0; i < _out_end_strong_edges; i++) {\n@@ -762,0 +998,6 @@\n+  if ((uint)_out.length() > _out_end_strong_edges) {\n+    tty->print(\" | weak:\");\n+    for (uint i = _out_end_strong_edges; i < (uint)_out.length(); i++) {\n+      print_node_idx(_out.at(i));\n+    }\n+  }\n@@ -775,1 +1017,18 @@\n-void VTransformScalarNode::print_spec() const {\n+void VTransformMemopScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s] \", _node->_idx, _node->Name());\n+  _vpointer.print_on(tty, false);\n+}\n+\n+void VTransformDataScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformLoopPhiNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformCFGNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformOuterNode::print_spec() const {\n@@ -803,0 +1062,4 @@\n+  if (is_load_or_store_in_loop()) {\n+    tty->print(\" \");\n+    vpointer().print_on(tty, false);\n+  }\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":343,"deletions":80,"binary":false,"changes":423,"status":"modified"},{"patch":"@@ -63,2 +63,5 @@\n-class VTransformScalarNode;\n-class VTransformInputScalarNode;\n+class VTransformMemopScalarNode;\n+class VTransformDataScalarNode;\n+class VTransformLoopPhiNode;\n+class VTransformCFGNode;\n+class VTransformOuterNode;\n@@ -112,0 +115,1 @@\n+  const bool _speculative_aliasing_analysis;\n@@ -118,0 +122,1 @@\n+                  const bool is_trace_speculative_aliasing_analysis,\n@@ -121,4 +126,5 @@\n-    _rejections                (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n-    _align_vector              (_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n-    _speculative_runtime_checks(_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_runtime_checks),\n-    _info                      (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n+    _rejections                    (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n+    _align_vector                  (_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n+    _speculative_aliasing_analysis (_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_aliasing_analysis),\n+    _speculative_runtime_checks    (_verbose | is_trace_vtransform(vtrace) | is_trace_speculative_runtime_checks),\n+    _info                          (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n@@ -164,0 +170,1 @@\n+  const GrowableArray<VTransformNode*>& get_schedule() const { return _schedule; }\n@@ -176,1 +183,1 @@\n-  void collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+  void collect_nodes_without_strong_in_edges(GrowableArray<VTransformNode*>& stack) const;\n@@ -251,1 +258,2 @@\n-  void apply_speculative_runtime_checks();\n+  void apply_speculative_alignment_runtime_checks();\n+  void apply_speculative_aliasing_runtime_checks();\n@@ -253,1 +261,3 @@\n-  void add_speculative_check(BoolNode* bol);\n+\n+  template<typename Callback>\n+  void add_speculative_check(Callback callback);\n@@ -258,0 +268,26 @@\n+\/\/ Keeps track of the state during \"VTransform::apply\"\n+\/\/ -> keep track of the already transformed nodes\n+class VTransformApplyState : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+\n+  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n+  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n+  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n+  GrowableArray<Node*> _vtnode_idx_to_transformed_node;\n+\n+public:\n+  VTransformApplyState(const VLoopAnalyzer& vloop_analyzer, int num_vtnodes) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vtnode_idx_to_transformed_node(num_vtnodes, num_vtnodes, nullptr)\n+  {\n+  }\n+\n+  const VLoop& vloop() const { return _vloop_analyzer.vloop(); }\n+  PhaseIdealLoop* phase() const { return vloop().phase(); }\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+\n+  void set_transformed_node(VTransformNode* vtn, Node* n);\n+  Node* transformed_node(const VTransformNode* vtn) const;\n+};\n+\n@@ -262,0 +298,20 @@\n+\/\/\n+\/\/ There are 3 tyes of edges:\n+\/\/ - data edges (req):           corresponding to C2 IR Node data edges, except control\n+\/\/                               and memory.\n+\/\/ - strong memory edges:        memory edges that must be respected when scheduling.\n+\/\/ - weak memory edges:          memory edges that can be violated, but if violated then\n+\/\/                               corresponding aliasing analysis runtime checks must be\n+\/\/                               inserted.\n+\/\/\n+\/\/ Strong edges: union of data edges and strong memory edges.\n+\/\/               These must be respected by scheduling in all cases.\n+\/\/\n+\/\/ The C2 IR Node memory edges essentially define a linear order of all memory operations\n+\/\/ (only Loads with the same memory input can be executed in an arbitrary order). This is\n+\/\/ efficient, because it means every Load and Store has exactly one input memory edge,\n+\/\/ which keeps the memory edge count linear. This is approach is too restrictive for\n+\/\/ vectorization, for example, we could never vectorize stores, since they are all in a\n+\/\/ dependency chain. Instead, we model the memory edges between all memory nodes, which\n+\/\/ could be quadratic in the worst case. For vectorization, we must essentially reorder the\n+\/\/ instructions in the graph. For this we must model all memory dependencies.\n@@ -267,2 +323,4 @@\n-  \/\/ _in is split into required inputs (_req, i.e. all data dependencies),\n-  \/\/ and memory dependencies.\n+  \/\/ We split _in into 3 sections:\n+  \/\/ - data edges (req):     _in[0                           .. _req-1]\n+  \/\/ - strong memory edges:  _in[_req                        .. _in_end_strong_memory_edges-1]\n+  \/\/ - weak memory edges:    _in[_in_end_strong_memory_edges .. ]\n@@ -270,0 +328,1 @@\n+  uint _in_end_strong_memory_edges;\n@@ -271,0 +330,5 @@\n+\n+  \/\/ We split _out into 2 sections:\n+  \/\/ - strong edges:         _out[0                     .. _out_end_strong_edges-1]\n+  \/\/ - weak memory edges:    _out[_out_end_strong_edges .. _len-1]\n+  uint _out_end_strong_edges;\n@@ -277,0 +341,1 @@\n+    _in_end_strong_memory_edges(req),\n@@ -278,0 +343,1 @@\n+    _out_end_strong_edges(0),\n@@ -283,1 +349,1 @@\n-  void set_req(uint i, VTransformNode* n) {\n+  void init_req(uint i, VTransformNode* n) {\n@@ -287,1 +353,1 @@\n-    n->add_out(this);\n+    n->add_out_strong_edge(this);\n@@ -298,1 +364,16 @@\n-  void add_memory_dependency(VTransformNode* n) {\n+  void add_strong_memory_edge(VTransformNode* n) {\n+    assert(n != nullptr, \"no need to add nullptr\");\n+    if (_in_end_strong_memory_edges < (uint)_in.length()) {\n+      \/\/ Put n in place of first weak memory edge, and move\n+      \/\/ the weak memory edge to the end.\n+      VTransformNode* first_weak = _in.at(_in_end_strong_memory_edges);\n+      _in.at_put(_in_end_strong_memory_edges, n);\n+      _in.push(first_weak);\n+    } else {\n+      _in.push(n);\n+    }\n+    _in_end_strong_memory_edges++;\n+    n->add_out_strong_edge(this);\n+  }\n+\n+  void add_weak_memory_edge(VTransformNode* n) {\n@@ -301,1 +382,15 @@\n-    n->add_out(this);\n+    n->add_out_weak_memory_edge(this);\n+  }\n+\n+private:\n+  void add_out_strong_edge(VTransformNode* n) {\n+    if (_out_end_strong_edges < (uint)_out.length()) {\n+      \/\/ Put n in place of first weak memory edge, and move\n+      \/\/ the weak memory edge to the end.\n+      VTransformNode* first_weak = _out.at(_out_end_strong_edges);\n+      _out.at_put(_out_end_strong_edges, n);\n+      _out.push(first_weak);\n+    } else {\n+      _out.push(n);\n+    }\n+    _out_end_strong_edges++;\n@@ -304,1 +399,1 @@\n-  void add_out(VTransformNode* n) {\n+  void add_out_weak_memory_edge(VTransformNode* n) {\n@@ -308,0 +403,1 @@\n+public:\n@@ -309,3 +405,2 @@\n-  VTransformNode* in(int i) const { return _in.at(i); }\n-  int outs() const { return _out.length(); }\n-  VTransformNode* out(int i) const { return _out.at(i); }\n+  uint out_strong_edges() const { return _out_end_strong_edges; }\n+  uint out_weak_edges() const { return _out.length() - _out_end_strong_edges; }\n@@ -313,2 +408,17 @@\n-  bool has_req_or_dependency() const {\n-    for (int i = 0; i < _in.length(); i++) {\n+  VTransformNode* in_req(uint i) const {\n+    assert(i < _req, \"must be a req\");\n+    return _in.at(i);\n+  }\n+\n+  VTransformNode* out_strong_edge(uint i) const {\n+    assert(i < out_strong_edges(), \"must be a strong memory edge or data edge\");\n+    return _out.at(i);\n+  }\n+\n+  VTransformNode* out_weak_edge(uint i) const {\n+    assert(i < out_weak_edges(), \"must be a strong memory edge\");\n+    return _out.at(_out_end_strong_edges + i);\n+  }\n+\n+  bool has_strong_in_edge() const {\n+    for (uint i = 0; i < _in_end_strong_memory_edges; i++) {\n@@ -320,2 +430,2 @@\n-  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n-  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() { return nullptr; }\n+  virtual VTransformOuterNode* isa_Outer() { return nullptr; }\n@@ -332,1 +442,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const { ShouldNotReachHere(); }\n+  virtual const VPointer& vpointer() const { ShouldNotReachHere(); }\n@@ -334,2 +444,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const = 0;\n@@ -339,1 +448,1 @@\n-  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n+  void register_new_node_from_vectorization(VTransformApplyState& apply_state, Node* vn, Node* old_node) const;\n@@ -347,2 +456,2 @@\n-\/\/ Identity transform for scalar nodes.\n-class VTransformScalarNode : public VTransformNode {\n+\/\/ Identity transform for scalar loads and stores.\n+class VTransformMemopScalarNode : public VTransformNode {\n@@ -350,1 +459,2 @@\n-  Node* _node;\n+  MemNode* _node;\n+  const VPointer _vpointer;\n@@ -352,4 +462,9 @@\n-  VTransformScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformNode(vtransform, n->req()), _node(n) {}\n-  Node* node() const { return _node; }\n-  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  VTransformMemopScalarNode(VTransform& vtransform, MemNode* n, const VPointer& vpointer) :\n+    VTransformNode(vtransform, n->req()), _node(n), _vpointer(vpointer)\n+  {\n+    assert(node()->is_Load() || node()->is_Store(), \"must be memop\");\n+  }\n+\n+  MemNode* node() const { return _node; }\n+  virtual VTransformMemopScalarNode* isa_MemopScalar() override { return this; }\n+\n@@ -357,5 +472,53 @@\n-  virtual bool is_load_or_store_in_loop() const override { return _node->is_Load() || _node->is_Store(); }\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return vloop_analyzer.vpointers().vpointer(node()->as_Mem()); }\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  virtual bool is_load_or_store_in_loop() const override { return true; }\n+\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"MemopScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for scalar data nodes.\n+class VTransformDataScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformDataScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(!_node->is_Mem() && !_node->is_Phi() && !_node->is_CFG(), \"must be data node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"DataScalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for loop head phi nodes.\n+class VTransformLoopPhiNode : public VTransformNode {\n+private:\n+  PhiNode* _node;\n+public:\n+  VTransformLoopPhiNode(VTransform& vtransform, PhiNode* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->in(0)->is_Loop(), \"phi ctrl must be Loop: %s\", _node->in(0)->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoopPhi\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Identity transform for CFG nodes.\n+class VTransformCFGNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformCFGNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n)\n+  {\n+    assert(_node->is_CFG(), \"must be CFG node: %s\", _node->Name());\n+  }\n+\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"CFG\"; };)\n@@ -368,1 +531,3 @@\n-class VTransformInputScalarNode : public VTransformScalarNode {\n+class VTransformOuterNode : public VTransformNode {\n+private:\n+  Node* _node;\n@@ -370,6 +535,7 @@\n-  VTransformInputScalarNode(VTransform& vtransform, Node* n) :\n-    VTransformScalarNode(vtransform, n) {}\n-  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n-  virtual bool is_load_in_loop() const override { return false; }\n-  virtual bool is_load_or_store_in_loop() const override { return false; }\n-  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+  VTransformOuterNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n) {}\n+\n+  virtual VTransformOuterNode* isa_Outer() override { return this; }\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Outer\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n@@ -386,2 +552,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -396,2 +561,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -411,2 +575,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -425,2 +588,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -447,1 +609,1 @@\n-  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n+  void register_new_node_from_vectorization_and_replace_scalar_nodes(VTransformApplyState& apply_state, Node* vn) const;\n@@ -457,2 +619,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -478,2 +639,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -489,2 +649,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -505,1 +664,1 @@\n-  virtual const VPointer& vpointer(const VLoopAnalyzer& vloop_analyzer) const override { return _vpointer; }\n+  virtual const VPointer& vpointer() const override { return _vpointer; }\n@@ -516,2 +675,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -528,2 +686,1 @@\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  virtual VTransformApplyResult apply(VTransformApplyState& apply_state) const override;\n@@ -541,2 +698,2 @@\n-    \/\/ We can ignore input nodes, they are outside the loop.\n-    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+    \/\/ We must ignore nodes outside the loop.\n+    if (vtn->isa_Outer() != nullptr) { continue; }\n@@ -544,3 +701,3 @@\n-    VTransformScalarNode* scalar = vtn->isa_Scalar();\n-    if (scalar != nullptr && scalar->node()->is_Mem()) {\n-      callback(scalar->node()->as_Mem());\n+    VTransformMemopScalarNode* scalar = vtn->isa_MemopScalar();\n+    if (scalar != nullptr) {\n+      callback(scalar->node());\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":228,"deletions":71,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-\/\/ These header files are included in at least 130 C++ files, as of\n-\/\/ measurements made in November 2018. This list excludes files named\n-\/\/ *.inline.hpp, since including them decreased build performance.\n+\/\/ These header files are selected using the output of Clang\n+\/\/ '-ftime-trace' as a measure of how much time we spend\n+\/\/ compiling them.\n@@ -32,6 +32,1 @@\n-#include \"classfile\/classLoaderData.hpp\"\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"gc\/shared\/collectedHeap.hpp\"\n-#include \"gc\/shared\/gcCause.hpp\"\n-#include \"logging\/log.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -39,36 +34,1 @@\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"nmt\/memTracker.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/method.hpp\"\n-#include \"oops\/objArrayKlass.hpp\"\n-#include \"oops\/objArrayOop.hpp\"\n-#include \"oops\/oop.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/handles.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/orderAccess.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/timer.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/bitMap.hpp\"\n-#include \"utilities\/copy.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/ostream.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-#ifdef TARGET_COMPILER_visCPP\n-\/\/ For Visual Studio, including the *.inline.hpp files actually\n-\/\/ increased performance.\n-#include \"memory\/allocation.inline.hpp\"\n-#ifdef JDK_8254007_IS_FIXED\n+#include \"memory\/iterator.inline.hpp\"\n@@ -76,0 +36,2 @@\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -77,0 +39,12 @@\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#if INCLUDE_SHENANDOAHGC\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#endif\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrier.inline.hpp\"\n+#include \"gc\/z\/zGeneration.inline.hpp\"\n+#include \"gc\/z\/zHeap.inline.hpp\"\n@@ -78,2 +52,0 @@\n-#include \"runtime\/handles.inline.hpp\"\n-#endif \/\/ TARGET_COMPILER_visCPP\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":19,"deletions":47,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"foreignGlobals.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n@@ -48,1 +47,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"classfile\/classLoaderData.hpp\"\n@@ -65,1 +64,0 @@\n-#include \"oops\/recordComponent.hpp\"\n@@ -69,0 +67,1 @@\n+#include \"oops\/recordComponent.hpp\"\n@@ -78,0 +77,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -80,0 +80,1 @@\n+#include \"runtime\/handshake.hpp\"\n@@ -82,2 +83,0 @@\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/handshake.hpp\"\n@@ -97,1 +96,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -99,0 +97,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -1357,2 +1356,1 @@\n-      InstanceKlass* ik = InstanceKlass::cast(klass);\n-      Klass* k = ik->local_interfaces()->at(index);\n+      InstanceKlass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n@@ -3610,1 +3608,1 @@\n-  if (!caller_ik->is_shared()) {\n+  if (!caller_ik->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -39,1 +40,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -26,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"classfile\/stringTable.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/stringTable.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"oops\/oopHandle.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -44,1 +43,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -46,0 +44,1 @@\n+#include \"runtime\/vmThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -64,1 +63,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"runtime\/mutexLocker.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/klassFactory.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"classfile\/klassFactory.hpp\"\n@@ -58,1 +58,0 @@\n-#include \"prims\/resolvedMethodTable.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -1360,1 +1360,3 @@\n-\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1362,2 +1364,2 @@\n-      (\"loading name=%s kind=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), _class_load_kind, os::available_memory() >> 10);\n+      (\"loading name=%s kind=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), _class_load_kind, avail_mem >> 10);\n@@ -1527,1 +1529,2 @@\n-\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1529,1 +1532,1 @@\n-      (\"loaded name=%s (avail_mem=\" UINT64_FORMAT \"K)\", the_class->external_name(), os::available_memory() >> 10);\n+      (\"loaded name=%s (avail_mem=%zuK)\", the_class->external_name(), avail_mem >> 10);\n@@ -4487,0 +4490,3 @@\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -4488,2 +4494,2 @@\n-      (\"redefined name=%s, count=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), os::available_memory() >> 10);\n+      (\"redefined name=%s, count=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), avail_mem >> 10);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -64,1 +63,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -66,0 +64,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -67,1 +66,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -69,1 +67,1 @@\n-#include \"utilities\/objectBitSet.inline.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -71,0 +69,1 @@\n+#include \"utilities\/objectBitSet.inline.hpp\"\n@@ -698,1 +697,1 @@\n-  for (InstanceKlass* super_klass = ik->java_super(); super_klass != nullptr; super_klass = super_klass->java_super()) {\n+  for (InstanceKlass* super_klass = ik->super(); super_klass != nullptr; super_klass = super_klass->super()) {\n@@ -725,1 +724,1 @@\n-  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->super()) {\n@@ -730,1 +729,1 @@\n-  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->super()) {\n@@ -2969,4 +2968,4 @@\n-    InstanceKlass* java_super = ik->java_super();\n-    if (java_super != nullptr && java_super != vmClasses::Object_klass()) {\n-      oop super = java_super->java_mirror();\n-      if (!CallbackInvoker::report_superclass_reference(mirror, super)) {\n+    InstanceKlass* super_klass = ik->super();\n+    if (super_klass != nullptr && super_klass != vmClasses::Object_klass()) {\n+      oop super_oop = super_klass->java_mirror();\n+      if (!CallbackInvoker::report_superclass_reference(mirror, super_oop)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/handles.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiUtil.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/frame.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/frame.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -31,1 +30,0 @@\n-#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -33,1 +31,1 @@\n-#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -35,0 +33,2 @@\n+#include \"prims\/foreignGlobals.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"prims\/jvmtiAgentList.hpp\"\n@@ -41,0 +40,1 @@\n+#include \"prims\/jvmtiAgentList.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"prims\/unsafe.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"prims\/unsafe.hpp\"\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -37,2 +39,0 @@\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n@@ -62,1 +62,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -64,0 +63,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#include <cstdint>\n-\n@@ -34,0 +32,2 @@\n+#include <cstdint>\n+\n","filename":"src\/hotspot\/share\/prims\/vmstorage.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"prims\/whitebox.inline.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"prims\/whitebox.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/wbtestmethods\/parserTests.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -55,1 +56,0 @@\n-#include \"memory\/iterator.inline.hpp\"\n@@ -73,1 +73,0 @@\n-#include \"oops\/objArrayOop.inline.hpp\"\n@@ -134,1 +133,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -136,0 +134,1 @@\n+#include \"osContainer_linux.hpp\"\n@@ -2265,1 +2264,1 @@\n-  return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n+  return (jboolean)MetaspaceShared::in_aot_cache(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n@@ -2616,2 +2615,2 @@\n-  LINUX_ONLY(return os::Linux::physical_memory();)\n-  return os::physical_memory();\n+  LINUX_ONLY(return static_cast<jlong>(os::Linux::physical_memory());)\n+  return static_cast<jlong>(os::physical_memory());\n@@ -2622,1 +2621,4 @@\n-  return os::available_memory();\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  return static_cast<jlong>(avail_mem);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -274,0 +274,12 @@\n+      #elif _MSC_VER == 1939\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.9 (VS2022)\"\n+      #elif _MSC_VER == 1940\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.10 (VS2022)\"\n+      #elif _MSC_VER == 1941\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.11 (VS2022)\"\n+      #elif _MSC_VER == 1942\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.12 (VS2022)\"\n+      #elif _MSC_VER == 1943\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.13 (VS2022)\"\n+      #elif _MSC_VER == 1944\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 17.14 (VS2022)\"\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -583,0 +583,2 @@\n+  { \"PretenureSizeThreshold\",       JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+\n@@ -1533,1 +1535,1 @@\n-      phys_mem = os::physical_memory();\n+      phys_mem = static_cast<julong>(os::physical_memory());\n@@ -1539,1 +1541,1 @@\n-    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)\n+    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(static_cast<julong>(os::physical_memory()), (julong)MaxRAM)\n@@ -1661,1 +1663,2 @@\n-  julong total_memory = os::physical_memory();\n+  size_t phys_mem = os::physical_memory();\n+  julong total_memory = static_cast<julong>(phys_mem);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/barrierSet.hpp\"\n@@ -42,1 +42,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -60,1 +60,0 @@\n-#include \"runtime\/smallRegisterMap.inline.hpp\"\n@@ -62,0 +61,1 @@\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"compiler\/oopMap.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"oops\/oop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/cpuTimeCounters.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"runtime\/cpuTimeCounters.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"interpreter\/bytecode.hpp\"\n@@ -53,0 +52,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -55,1 +55,1 @@\n-#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -60,1 +60,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -74,1 +73,0 @@\n-#include \"runtime\/fieldDescriptor.hpp\"\n@@ -97,1 +95,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -99,0 +96,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n@@ -1554,1 +1552,1 @@\n-  InstanceKlass* super = klass->superklass();\n+  InstanceKlass* super = klass->super();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -32,2 +34,0 @@\n-#include \"oops\/fieldStreams.inline.hpp\"\n-#include \"oops\/inlineKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -32,0 +32,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"oops\/metadata.hpp\"\n-#include \"runtime\/os.hpp\"\n@@ -31,0 +29,1 @@\n+#include \"oops\/metadata.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"runtime\/os.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n@@ -27,0 +26,2 @@\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -33,2 +34,0 @@\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLookup.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -42,1 +43,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n@@ -54,1 +54,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n@@ -56,0 +55,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"oops\/stackChunkOop.inline.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"oops\/stackChunkOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,4 +198,1 @@\n-  \/\/ Initialize TrainingData only we're recording\/replaying\n-  if (TrainingData::have_data() || TrainingData::need_data()) {\n-   TrainingData::initialize();\n-  }\n+  TrainingData::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -78,0 +79,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -80,1 +82,0 @@\n-#include \"runtime\/vm_version.hpp\"\n@@ -506,0 +507,6 @@\n+  #if INCLUDE_CDS\n+  if (AOTVerifyTrainingData) {\n+    TrainingData::verify();\n+  }\n+  #endif\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n@@ -423,1 +423,1 @@\n-              entry_point = method->adapter()->get_i2c_entry();\n+              entry_point = method->get_i2c_entry();\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -92,1 +92,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -94,1 +93,1 @@\n-#include \"runtime\/vmThread.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n@@ -96,0 +95,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -1144,1 +1144,1 @@\n-                         InstanceKlass::cast(exception->klass())->external_name());\n+                         exception->klass()->external_name());\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -43,0 +42,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"runtime\/keepStackGCProcessed.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/keepStackGCProcessed.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-  MUTEX_DEFL(TrainingData_lock               , PaddedMutex  , MethodCompileQueue_lock);\n+  MUTEX_DEFN(TrainingData_lock               , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -70,0 +69,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -92,1 +92,0 @@\n-# include <signal.h>\n@@ -94,0 +93,1 @@\n+# include <signal.h>\n@@ -111,1 +111,1 @@\n-int os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n+void os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n@@ -116,1 +116,0 @@\n-  assert(result >= 0, \"os::snprintf error\");\n@@ -118,1 +117,0 @@\n-  return result;\n@@ -122,0 +120,2 @@\n+  assert(buf != nullptr || len == 0, \"Valid buffer and length must be given\");\n+  assert(fmt != nullptr, \"Missing format string\");\n@@ -123,1 +123,1 @@\n-  \/\/ If an encoding error occurred (result < 0) then it's not clear\n+  \/\/ If an error occurred (result < 0) then it's not clear\n@@ -125,1 +125,1 @@\n-  if ((result < 0) && (len > 0)) {\n+  if ((result < 0) && (len > 0) && (buf != nullptr)) {\n@@ -128,0 +128,1 @@\n+  assert(result >= 0, \"os::vsnprintf error: %s\", strerror(errno));\n@@ -461,1 +462,1 @@\n-            InstanceKlass::cast(PENDING_EXCEPTION->klass())->\n+            PENDING_EXCEPTION->klass()->\n@@ -1186,1 +1187,2 @@\n-  size_t mem = physical_memory()\/G;\n+  size_t phys_mem = physical_memory();\n+  size_t mem = phys_mem\/G;\n@@ -1188,1 +1190,1 @@\n-    mem = physical_memory()\/M;\n+    mem = phys_mem\/M;\n@@ -1943,1 +1945,1 @@\n-\n+  size_t phys_mem = os::physical_memory();\n@@ -1946,1 +1948,1 @@\n-      (os::physical_memory() >= (server_memory - missing_memory))) {\n+      (phys_mem >= (server_memory - missing_memory))) {\n@@ -2205,1 +2207,1 @@\n-julong os::used_memory() {\n+bool os::used_memory(size_t& value) {\n@@ -2210,1 +2212,4 @@\n-      return mem_usage;\n+      value = static_cast<size_t>(mem_usage);\n+      return true;\n+    } else {\n+      return false;\n@@ -2214,1 +2219,6 @@\n-  return os::physical_memory() - os::available_memory();\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  size_t phys_mem = os::physical_memory();\n+  value = phys_mem - avail_mem;\n+  return true;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -335,3 +335,3 @@\n-  static julong available_memory();\n-  static julong used_memory();\n-  static julong free_memory();\n+  [[nodiscard]] static bool available_memory(size_t& value);\n+  [[nodiscard]] static bool used_memory(size_t& value);\n+  [[nodiscard]] static bool free_memory(size_t& value);\n@@ -339,2 +339,2 @@\n-  static jlong total_swap_space();\n-  static jlong free_swap_space();\n+  [[nodiscard]] static bool total_swap_space(size_t& value);\n+  [[nodiscard]] static bool free_swap_space(size_t& value);\n@@ -342,1 +342,1 @@\n-  static julong physical_memory();\n+  static size_t physical_memory();\n@@ -807,2 +807,0 @@\n-  static int vsnprintf(char* buf, size_t len, const char* fmt, va_list args) ATTRIBUTE_PRINTF(3, 0);\n-  static int snprintf(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);\n@@ -810,3 +808,13 @@\n-  \/\/ Performs snprintf and asserts the result is non-negative (so there was not\n-  \/\/ an encoding error) and that the output was not truncated.\n-  static int snprintf_checked(char* buf, size_t len, const char* fmt, ...) ATTRIBUTE_PRINTF(3, 4);\n+  \/\/ Performs vsnprintf and asserts the result is non-negative (so there was not\n+  \/\/ an encoding error or any other kind of usage error).\n+  [[nodiscard]]\n+  ATTRIBUTE_PRINTF(3, 0)\n+  static int vsnprintf(char* buf, size_t len, const char* fmt, va_list args);\n+  \/\/ Delegates to vsnprintf.\n+  [[nodiscard]]\n+  ATTRIBUTE_PRINTF(3, 4)\n+  static int snprintf(char* buf, size_t len, const char* fmt, ...);\n+\n+  \/\/ Delegates to snprintf and asserts that the output was not truncated.\n+  ATTRIBUTE_PRINTF(3, 4)\n+  static void snprintf_checked(char* buf, size_t len, const char* fmt, ...);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"jvm.h\"\n@@ -47,0 +46,1 @@\n+#include \"jvm.h\"\n@@ -51,0 +51,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -53,1 +54,1 @@\n-#include \"metaprogramming\/primitiveConversions.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -59,1 +60,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -2585,1 +2585,0 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = nullptr;\n@@ -2621,14 +2620,0 @@\n-void AdapterHandlerLibrary::create_abstract_method_handler() {\n-  assert_lock_strong(AdapterHandlerLibrary_lock);\n-  \/\/ Create a special handler for abstract methods.  Abstract methods\n-  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-  \/\/ throw AbstractMethodError just in case.\n-  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-  \/\/ AbstractMethodError for invalid invocations.\n-  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-  _abstract_method_handler = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(nullptr));\n-  _abstract_method_handler->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n-                                             wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n-                                             wrong_method_abstract, wrong_method_abstract);\n-}\n-\n@@ -2638,1 +2623,0 @@\n-    MutexLocker mu(AdapterHandlerLibrary_lock);\n@@ -2641,1 +2625,0 @@\n-    create_abstract_method_handler();\n@@ -2713,3 +2696,0 @@\n-  if (method->is_abstract()) {\n-    return nullptr;\n-  }\n@@ -3138,0 +3118,1 @@\n+  assert(!method->is_abstract(), \"abstract methods do not have adapters\");\n@@ -3164,2 +3145,0 @@\n-  } else if (method->is_abstract()) {\n-    return _abstract_method_handler;\n@@ -3190,1 +3169,1 @@\n-      if (!entry->is_shared() && VerifyAdapterSharing) {\n+      if (!entry->in_aot_cache() && VerifyAdapterSharing) {\n@@ -3979,7 +3958,0 @@\n-bool AdapterHandlerLibrary::is_abstract_method_adapter(AdapterHandlerEntry* entry) {\n-  if (entry == _abstract_method_handler) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":33,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -835,1 +835,0 @@\n-  static AdapterHandlerEntry* _abstract_method_handler;\n@@ -853,1 +852,0 @@\n-  static void create_abstract_method_handler();\n@@ -883,2 +881,0 @@\n-  static bool is_abstract_method_adapter(AdapterHandlerEntry* adapter);\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -44,1 +44,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -605,1 +605,0 @@\n-  OrderAccess::fence();      \/\/ guarantee at least release consistency.\n@@ -613,4 +612,3 @@\n-  \/\/ Conceptually we need a #loadstore|#storestore \"release\" MEMBAR before\n-  \/\/ the ST of 0 into the lock-word which releases the lock, so fence\n-  \/\/ more than covers this on all platforms.\n-  *adr = 0;\n+  \/\/ So we need a #loadstore|#storestore \"release\" memory barrier before\n+  \/\/ the ST of 0 into the lock-word which releases the lock.\n+  Atomic::release_store(adr, 0);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"runtime\/atomic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-#include \"compiler\/compileTask.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"compiler\/compileTask.hpp\"\n@@ -94,1 +94,0 @@\n-#include \"runtime\/threadSMR.inline.hpp\"\n@@ -96,0 +95,1 @@\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -99,1 +99,0 @@\n-#include \"runtime\/vmOperations.hpp\"\n@@ -101,0 +100,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n@@ -54,1 +53,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -56,0 +54,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframeArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"runtime\/vframeArray.hpp\"\n@@ -47,0 +46,1 @@\n+#include \"runtime\/vframeArray.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"logging\/logStream.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"logging\/logStream.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/vmOperation.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -59,1 +58,0 @@\n-#include \"oops\/constMethod.hpp\"\n@@ -61,0 +59,1 @@\n+#include \"oops\/constMethod.hpp\"\n@@ -104,1 +103,0 @@\n-#include \"runtime\/vmStructs.hpp\"\n@@ -106,0 +104,1 @@\n+#include \"runtime\/vmStructs.hpp\"\n@@ -326,1 +325,1 @@\n-  nonstatic_field(JNIid,                       _holder,                                       Klass*)                                \\\n+  nonstatic_field(JNIid,                       _holder,                                       InstanceKlass*)                        \\\n@@ -353,2 +352,2 @@\n-     static_field(MetaspaceObj,                _shared_metaspace_base,                        void*)                                 \\\n-     static_field(MetaspaceObj,                _shared_metaspace_top,                         void*)                                 \\\n+     static_field(MetaspaceObj,                _aot_metaspace_base,                           void*)                                 \\\n+     static_field(MetaspaceObj,                _aot_metaspace_top,                            void*)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -871,1 +871,1 @@\n-  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_class(AbstractDumpWriter* writer, InstanceKlass* ik);\n@@ -1396,3 +1396,1 @@\n-void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-\n+void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, InstanceKlass* ik) {\n@@ -1419,2 +1417,2 @@\n-  InstanceKlass* java_super = ik->java_super();\n-  if (java_super == nullptr) {\n+  InstanceKlass* super = ik->super();\n+  if (super == nullptr) {\n@@ -1423,1 +1421,1 @@\n-    writer->write_classID(java_super);\n+    writer->write_classID(super);\n@@ -2009,1 +2007,1 @@\n-      DumperSupport::dump_instance_class(writer(), k);\n+      DumperSupport::dump_instance_class(writer(), InstanceKlass::cast(k));\n@@ -2621,1 +2619,1 @@\n-  os::snprintf(path, buf_size, \"%s.p%d\", base_path, seq);\n+  os::snprintf_checked(path, buf_size, \"%s.p%d\", base_path, seq);\n@@ -3135,1 +3133,4 @@\n-    julong max_threads = os::free_memory() \/ (20 * M);\n+    size_t free_memory = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::free_memory(free_memory);\n+    julong max_threads = free_memory \/ (20 * M);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -978,1 +978,1 @@\n-    return os::physical_memory();\n+    return static_cast<jlong>(os::physical_memory());\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+FORBID_C_FUNCTION(int snprintf(char*, size_t, const char*, ...), \"use os::snprintf\");\n","filename":"src\/hotspot\/share\/utilities\/forbiddenFunctions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+\/\/ offset_of was a workaround for UB with offsetof uses that are no longer an\n+\/\/ issue.  This can be removed once all uses have been converted.\n+#define offset_of(klass, field) offsetof(klass, field)\n@@ -653,8 +656,0 @@\n-\/\/ the fancy casts are a hopefully portable way\n-\/\/ to do unsigned 32 to 64 bit type conversion\n-inline void set_low (jlong* value, jint low )    { *value &= (jlong)0xffffffff << 32;\n-                                                   *value |= (jlong)(julong)(juint)low; }\n-\n-inline void set_high(jlong* value, jint high)    { *value &= (jlong)(julong)(juint)0xffffffff;\n-                                                   *value |= (jlong)high       << 32; }\n-\n@@ -662,4 +657,4 @@\n-  jlong result = 0; \/\/ initialization to avoid warning\n-  set_high(&result, h);\n-  set_low(&result,  l);\n-  return result;\n+  \/\/ First cast jint values to juint, so cast to julong will zero-extend.\n+  julong high = (julong)(juint)h << 32;\n+  julong low = (julong)(juint)l;\n+  return (jlong)(high | low);\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -87,18 +87,0 @@\n-\n-\/\/ gcc warns about applying offsetof() to non-POD object or calculating\n-\/\/ offset directly when base address is null. The -Wno-invalid-offsetof\n-\/\/ option could be used to suppress this warning, but we instead just\n-\/\/ avoid the use of offsetof().\n-\/\/\n-\/\/ FIXME: This macro is complex and rather arcane. Perhaps we should\n-\/\/ use offsetof() instead, with the invalid-offsetof warning\n-\/\/ temporarily disabled.\n-#define offset_of(klass,field)                          \\\n-([]() {                                                 \\\n-  alignas(16) char space[sizeof (klass)];               \\\n-  klass* dummyObj = (klass*)space;                      \\\n-  char* c = (char*)(void*)&dummyObj->field;             \\\n-  return (size_t)(c - space);                           \\\n-}())\n-\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -88,2 +88,0 @@\n-#define offset_of(klass,field) offsetof(klass,field)\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/ostream.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-\/\/ ALLOCATOR must check for oom and exit, as RBTree does not handle the allocation failing.\n@@ -471,1 +470,3 @@\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n@@ -477,1 +478,3 @@\n-    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    if (node_place == nullptr) {\n+      return nullptr;\n+    }\n@@ -488,1 +491,2 @@\n-  void upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n+  \/\/ Returns false if and only if allocation of a new node failed.\n+  bool upsert(const K& key, const V& val, const RBNode<K, V>* hint_node = nullptr) {\n@@ -493,1 +497,1 @@\n-      return;\n+      return true;\n@@ -497,0 +501,3 @@\n+    if (node == nullptr) {\n+      return false;\n+    }\n@@ -498,0 +505,1 @@\n+    return true;\n@@ -548,1 +556,1 @@\n-template <MemTag mem_tag>\n+template <MemTag mem_tag, AllocFailType strategy>\n@@ -553,1 +561,1 @@\n-    if (allocation == nullptr) {\n+    if (allocation == nullptr && strategy == AllocFailStrategy::EXIT_OOM) {\n@@ -563,2 +571,2 @@\n-template <typename K, typename V, typename COMPARATOR, MemTag mem_tag>\n-using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mem_tag>>;\n+template <typename K, typename V, typename COMPARATOR, MemTag mem_tag, AllocFailType strategy = AllocFailStrategy::EXIT_OOM>\n+using RBTreeCHeap = RBTree<K, V, COMPARATOR, RBTreeCHeapAllocator<mem_tag, strategy>>;\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      os::snprintf(extended_resource_info_at_startup, sizeof(extended_resource_info_at_startup), \"%s\", result_info);\n+      os::snprintf_checked(extended_resource_info_at_startup, sizeof(extended_resource_info_at_startup), \"%s\", result_info);\n@@ -76,1 +76,1 @@\n-      os::snprintf(host_information, sizeof(host_information), \"%s\", result_info);\n+      os::snprintf_checked(host_information, sizeof(host_information), \"%s\", result_info);\n","filename":"src\/hotspot\/share\/utilities\/virtualizationSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,3 @@\n-     * Constructs an UnsupportedOperationException with no detail message.\n+     * Constructs a new {@code UnsupportedOperationException} with {@code null}\n+     * as its detail message. The cause is not initialized, and may subsequently\n+     * be initialized by a call to {@link #initCause(Throwable)}.\n@@ -46,2 +48,3 @@\n-     * Constructs an UnsupportedOperationException with the specified\n-     * detail message.\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * detail message. The cause is not initialized, and may subsequently be\n+     * initialized by a call to {@link #initCause(Throwable)}.\n@@ -56,2 +59,2 @@\n-     * Constructs a new exception with the specified detail message and\n-     * cause.\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * detail message and cause.\n@@ -76,2 +79,3 @@\n-     * Constructs a new exception with the specified cause and a detail\n-     * message of {@code (cause==null ? null : cause.toString())} (which\n+     * Constructs a new {@code UnsupportedOperationException} with the specified\n+     * cause and a detail message of\n+     * {@code (cause==null ? null : cause.toString())} (which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/UnsupportedOperationException.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-     * {@return the access flags, as a bit mask}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the access flags, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AccessFlags.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -109,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -129,0 +135,2 @@\n+     * @throws IllegalArgumentException if the number of pairs exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -212,0 +212,2 @@\n+     * @throws IllegalArgumentException if the number of associated values\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -676,0 +676,2 @@\n+     * @throws IllegalArgumentException if the length of array exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -689,0 +691,2 @@\n+     * @throws IllegalArgumentException if the length of array exceeds the limit\n+     *         of {@link java.lang.classfile##u2 u2}\n@@ -702,1 +706,2 @@\n-     *         an enum constant, or an array of one of these.\n+     *         an enum constant, or an array of one of these; or any array has\n+     *         length over the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+     * @throws IllegalArgumentException if {@code major} or {@code minor} is not\n+     *         {@link java.lang.classfile##u2 u2}; {@code minor} may be {@code\n+     *         -1} to indicate {@value ClassFile#PREVIEW_MINOR_VERSION}\n@@ -80,0 +83,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -129,0 +134,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -140,0 +147,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -151,1 +160,3 @@\n-     * @throws IllegalArgumentException if any element of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -163,1 +174,3 @@\n-     * @throws IllegalArgumentException if any element of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -191,0 +204,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -224,0 +239,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -263,0 +280,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -287,0 +306,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -307,0 +328,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -336,0 +359,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-     * {@return the major version}  It is in the range of unsigned short, {@code\n-     * [0, 65535]}.\n+     * {@return the major version}  It is a {@link java.lang.classfile##u2 u2}\n+     * value.\n@@ -74,2 +74,2 @@\n-     * {@return the minor version}  It is in the range of unsigned short, {@code\n-     * [0, 65535]}.\n+     * {@return the minor version}  It is a {@link java.lang.classfile##u2 u2}\n+     * value.\n@@ -80,1 +80,3 @@\n-     * {@return a {@link ClassFileVersion} element}\n+     * {@return a {@link ClassFileVersion} element}  The minor version number\n+     * may be {@code -1} to represent {@value ClassFile#PREVIEW_MINOR_VERSION}.\n+     *\n@@ -83,0 +85,3 @@\n+     * @throws IllegalArgumentException if the major version or the minor\n+     *         version is not {@link java.lang.classfile##u2 u2}; the minor\n+     *         version may be {@code -1}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileVersion.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-     * {@return the major version of this class}  It is in the range of unsigned\n-     * short, {@code [0, 65535]}.\n+     * {@return the major version of this class}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -95,2 +95,2 @@\n-     * {@return the minor version of this class}  It is in the range of unsigned\n-     * short, {@code [0, 65535]}.\n+     * {@return the minor version of this class}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -156,2 +156,3 @@\n-     * {@return the unsigned short at the specified offset within the {@code\n-     * class} file}  Reads a 2-byte value and zero-extends it to an {@code int}.\n+     * {@return the {@link java.lang.classfile##u2 u2} at the specified offset\n+     * within the {@code class} file}  Reads a 2-byte value and zero-extends it\n+     * to an {@code int}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassReader.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -468,1 +468,1 @@\n-     *         void} or {@code slot} is out of range\n+     *         void} or {@code slot} is not {@link java.lang.classfile##u2 u2}\n@@ -482,1 +482,2 @@\n-     *         void} or {@code slot} is out of range\n+     *         void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -814,0 +815,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -910,0 +913,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -929,1 +934,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -949,1 +955,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -977,1 +984,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1002,1 +1010,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1061,1 +1070,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1131,1 +1141,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1387,1 +1398,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1452,1 +1464,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1699,1 +1712,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -1764,1 +1778,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -2390,2 +2405,2 @@\n-     * {@code slot} exceeds {@code 255} or {@code val} exceeds the range of\n-     * {@link TypeKind#BYTE byte}.\n+     * {@code slot} exceeds the limit of {@link java.lang.classfile##u1 u1} or\n+     * {@code val} exceeds the range of {@link TypeKind#BYTE byte}.\n@@ -2396,1 +2411,3 @@\n-     * @throws IllegalArgumentException if {@code slot} or {@code val} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2} or {@code val} is out of range of\n+     *         {@link TypeKind#SHORT short}\n@@ -2413,1 +2430,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -2766,1 +2784,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -3004,1 +3023,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -3106,1 +3126,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":40,"deletions":19,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -72,0 +74,2 @@\n+     * @throws IllegalArgumentException if any flag cannot be applied to the\n+     *         {@link AccessFlag.Location#FIELD} location\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -65,0 +67,2 @@\n+     * @throws IllegalArgumentException if the number of interfaces\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -73,1 +77,3 @@\n-     * @throws IllegalArgumentException if any of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -82,1 +88,3 @@\n-     * @throws IllegalArgumentException if any of {@code interfaces} is primitive\n+     * @throws IllegalArgumentException if any of {@code interfaces} is primitive,\n+     *         or if the number of interfaces exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Interfaces.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-     * @throws IllegalArgumentException if the {@link ClassFile#ACC_STATIC\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}, or the {@link ClassFile#ACC_STATIC\n@@ -77,1 +78,2 @@\n-     *         ACC_STATIC} flag is modified\n+     *         ACC_STATIC} flag is modified, or if any flag cannot be applied to\n+     *         the {@link AccessFlag.Location#METHOD} location\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodBuilder.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -184,0 +185,2 @@\n+     * @throws IllegalArgumentException if the size of {@code targetPath}\n+     *         exceeds the limit of {@link java.lang.classfile##u1 u1}\n@@ -355,0 +358,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -363,0 +368,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -371,0 +378,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -379,0 +388,2 @@\n+         * @throws IllegalArgumentException if {@code supertypeIndex} is not\n+         *         {@link java.lang.classfile##u2 u2}\n@@ -390,0 +401,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -400,0 +413,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -410,0 +425,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         *         {@code boundIndex} is not {@link java.lang.classfile##u1 u1}\n@@ -451,0 +468,2 @@\n+         * @throws IllegalArgumentException if {@code formalParameterIndex} is\n+         *         not {@link java.lang.classfile##u1 u1}\n@@ -460,0 +479,2 @@\n+         * @throws IllegalArgumentException if {@code throwsTargetIndex} is\n+         *         not {@link java.lang.classfile##u2 u2}\n@@ -470,0 +491,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -478,0 +501,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -487,0 +512,2 @@\n+         * @throws IllegalArgumentException if the size of the list of targets\n+         *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -495,0 +522,2 @@\n+         * @throws IllegalArgumentException if {@code exceptionTableIndex} is\n+         *         not {@link java.lang.classfile##u2 u2}\n@@ -555,0 +584,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -564,0 +595,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -574,0 +607,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -584,0 +619,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -594,0 +631,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -604,0 +643,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -772,1 +813,0 @@\n-\n@@ -795,0 +835,2 @@\n+         * @throws IllegalArgumentException if {@code index} is not {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -962,0 +1004,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         *         {@link java.lang.classfile##u1 u1}\n@@ -964,1 +1008,1 @@\n-\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -169,0 +170,2 @@\n+     * @throws IllegalArgumentException if {@code startPc}, {@code endPc}, or\n+     *         {@code flags} is not {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CharacterRangeInfo.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,2 @@\n+     * @throws IllegalArgumentException if the number of ranges exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CharacterRangeTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -88,0 +90,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -96,0 +100,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -104,0 +110,2 @@\n+     * @throws IllegalArgumentException if the number of exceptions exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ExceptionsAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-     * of the inner class}  It is in the range of unsigned short, {@code [0,\n-     * 0xFFFF]}.\n+     * of the inner class}  It is a {@link java.lang.classfile##u2 u2} value.\n@@ -108,0 +107,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -120,1 +121,3 @@\n-     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass} represents a primitive type\n+     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass}\n+     *         represents a primitive type, or if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassInfo.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,0 +68,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -76,0 +78,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassesAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+     * @throws IllegalArgumentException if {@code startPc} or {@code lineNumber}\n+     *         is not {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-     * {@return the access flags, as a bit mask}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the access flags, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -88,0 +88,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -108,0 +110,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParameterInfo.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}\n@@ -79,0 +81,2 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParametersAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-     * {@return the module flags of the module, as a bit mask}  It is in the\n-     * range of unsigned short, {@code [0, 0xFFFF]}.\n+     * {@return the module flags of the module, as a bit mask}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -173,0 +173,3 @@\n+     * @throws IllegalArgumentException if {@code moduleFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or any of the collections has a size\n+     *         over the limit of {@link java.lang.classfile##u2 u2}\n@@ -189,0 +192,3 @@\n+     * @throws IllegalArgumentException if the information from the handler exceeds\n+     *         the {@code class} file format limit, such as a list with size\n+     *         over the limit of {@link java.lang.classfile##u2 u2}\n@@ -233,0 +239,2 @@\n+         * @throws IllegalArgumentException if {@code flagsMask} is not {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -295,0 +303,2 @@\n+         * @throws IllegalArgumentException if the number of modules exceeds\n+         *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -306,1 +316,3 @@\n-         *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+         *         {@link AccessFlag.Location#MODULE_EXPORTS} location or the\n+         *         number of modules exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -332,0 +344,2 @@\n+         * @throws IllegalArgumentException if the number of modules exceeds the\n+         *         limit of {@link java.lang.classfile##u2 u2}\n@@ -348,1 +362,3 @@\n-         *         {@link AccessFlag.Location#MODULE_OPENS} location\n+         *         {@link AccessFlag.Location#MODULE_OPENS} location, or if the\n+         *         number of modules exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n@@ -390,1 +406,4 @@\n-         * @throws IllegalArgumentException if {@code service} or any of the {@code implClasses} represents a primitive type\n+         * @throws IllegalArgumentException if {@code service} or any of the\n+         *         {@code implClasses} represents a primitive type, or the\n+         *         number of implementations exceeds the limit of {@link\n+         *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -106,0 +106,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -120,1 +123,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -134,0 +139,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -149,1 +157,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -164,0 +174,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -180,1 +193,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -194,0 +209,3 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -209,1 +227,3 @@\n-     *         {@link AccessFlag.Location#MODULE_EXPORTS} location\n+     *         {@link AccessFlag.Location#MODULE_EXPORTS} location, or if the\n+     *         number of modules exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleExportInfo.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -99,0 +99,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -109,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -129,0 +135,2 @@\n+     * @throws IllegalArgumentException if the number of descriptions exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleHashesAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -112,0 +112,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -126,1 +129,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -140,0 +144,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -155,1 +162,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -169,0 +177,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -184,1 +195,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -197,0 +209,3 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not {@link\n+     *         java.lang.classfile##u2 u2} or if the number of modules exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -211,1 +226,2 @@\n-     *         {@link AccessFlag.Location#MODULE_OPENS} location\n+     *         {@link AccessFlag.Location#MODULE_OPENS} location, or the number\n+     *         of modules exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleOpenInfo.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -85,0 +87,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -93,0 +97,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -105,0 +111,2 @@\n+     * @throws IllegalArgumentException if the number of packages exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModulePackagesAttribute.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+     * @throws IllegalArgumentException if the number of implementations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -77,0 +79,2 @@\n+     * @throws IllegalArgumentException if the number of implementations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -88,1 +92,2 @@\n-     *         providesWith} represents a primitive type\n+     *         providesWith} represents a primitive type, or the number of\n+     *         implementations exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -100,1 +105,2 @@\n-     *         providesWith} represents a primitive type\n+     *         providesWith} represents a primitive type, or the number of\n+     *         implementations exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleProvideInfo.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-     * It is in the range of unsigned short, {@code [0, 0xFFFF]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -100,0 +100,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -124,0 +126,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleRequireInfo.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-     * {@return the module resolution flags}  It is in the range of unsigned\n-     * short, {@code [0, 0xFFFF]}.\n+     * {@return the module resolution flags}  It is a {@link\n+     * java.lang.classfile##u2 u2} value.\n@@ -102,0 +102,2 @@\n+     * @throws IllegalArgumentException if {@code resolutionFlags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleResolutionAttribute.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+     * @throws IllegalArgumentException if the number of member classes exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -84,0 +86,2 @@\n+     * @throws IllegalArgumentException if the number of member classes exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -93,1 +97,3 @@\n-     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive\n+     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive,\n+     *         or if the number of member classes exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -103,1 +109,3 @@\n-     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive\n+     * @throws IllegalArgumentException if any of {@code nestMembers} is primitive,\n+     *         or if the number of member classes exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestMembersAttribute.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+     * @throws IllegalArgumentException if the number of permitted subclasses\n+     *         or subinterfaces exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -89,0 +91,2 @@\n+     * @throws IllegalArgumentException if the number of permitted subclasses\n+     *         or subinterfaces exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -98,1 +102,3 @@\n-     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive\n+     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive,\n+     *         or if the number of permitted subclasses or subinterfaces exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -108,1 +114,3 @@\n-     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive\n+     * @throws IllegalArgumentException if any of {@code permittedSubclasses} is primitive,\n+     *         or if the number of permitted subclasses or subinterfaces exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -71,0 +71,2 @@\n+     * @throws IllegalArgumentException if the number of record components\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n@@ -80,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of record components\n+     *         exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -106,0 +108,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -119,0 +123,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -134,0 +140,2 @@\n+     * @throws IllegalArgumentException if the number of attributes exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordComponentInfo.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n@@ -85,0 +87,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds\n+     *         the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}, or the number of\n+     *         annotations on any parameter exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -91,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -83,0 +85,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,4 @@\n+     * @throws IllegalArgumentException if the number of parameters exceeds the\n+     *         limit of {@link java.lang.classfile##u1 u1}, or the number of\n+     *         annotations on any parameter exceeds the limit of {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -91,0 +93,2 @@\n+     * @throws IllegalArgumentException if the number of annotations exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+     * @throws IllegalArgumentException if the number of types in {@code locals}\n+     *         or {@code stack} exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+     * @throws IllegalArgumentException if the number of frames exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapTableAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-     * referring to a {@link MemberRefEntry}}  The reference kind must be\n+     * referring to a {@link MemberRefEntry}}  The reference kind is\n@@ -406,0 +406,2 @@\n+     * @throws IllegalArgumentException if {@code refKind} is not {@link\n+     *         java.lang.classfile##u1 u1}\n@@ -572,0 +574,2 @@\n+     * @throws IllegalArgumentException if the number of arguments exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n@@ -587,0 +591,2 @@\n+     * @throws IllegalArgumentException if the number of arguments exceeds the\n+     *         limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,1 +57,2 @@\n- * represent at most 65535 bytes of data due to the physical restrictions.\n+ * represent at most 65535 bytes of data due to the physical restrictions of\n+ * {@link java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/CharacterRange.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-     * where {@code slot} must be within {@code [0, 65535]}.\n+     * where {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -156,1 +156,1 @@\n-         * The value is within {@code [0, 65535]}.\n+         * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -163,3 +163,3 @@\n-         * {@code slot} must be in the closed range of {@code [0, 255]} for\n-         * {@link Opcode#RET ret}, or within {@code [0, 65535]} for {@link\n-         * Opcode#RET_W wide ret}.\n+         * {@code slot} must be {@link java.lang.classfile##u1 u1} for\n+         * {@link Opcode#RET ret}, or {@link java.lang.classfile##u2 u2} for\n+         * {@link Opcode#RET_W wide ret}.\n@@ -186,1 +186,1 @@\n-         * {@code slot} must be within {@code [0, 65535]}.\n+         * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -189,1 +189,2 @@\n-         * @throws IllegalArgumentException if {@code slot} is out of range\n+         * @throws IllegalArgumentException if {@code slot} is not {@link\n+         *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * <li>{@code slot} must be within {@code [0, 65535]}.\n+ * <li>{@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -76,1 +76,1 @@\n-     * <li>{@code slot} must be within {@code [0, 65535]}.\n+     * <li>{@code slot} must be {@link java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LineNumber.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * computational}, and {@code slot} is within {@code [0, 65535]}.\n+ * computational}, and {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -65,1 +65,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -79,1 +79,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be a {@link java.lang.classfile##u2 u2} value.\n@@ -84,1 +84,2 @@\n-     *         {@link TypeKind#VOID void} or {@code slot} is out of range\n+     *         {@link TypeKind#VOID void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -99,2 +100,4 @@\n-     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n-     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <li>If {@code op} has size 2, {@code slot} must be {@link\n+     *     java.lang.classfile##u1 u1}.\n+     * <li>If {@code op} has size 4, {@code slot} must be {@link\n+     *     java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LoadInstruction.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * Where {@code slot} is within {@code [0, 65535]}.\n+ * Where {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -82,1 +82,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -119,1 +119,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -126,1 +126,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -135,1 +136,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -142,1 +143,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * Where {@code slot} is within {@code [0, 65535]}.\n+ * Where {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -75,1 +75,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -112,1 +112,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -119,1 +119,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -128,1 +129,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -135,1 +136,2 @@\n-     * @throws IllegalArgumentException if {@code slot} is out of range\n+     * @throws IllegalArgumentException if {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * computational}, and {@code slot} is within {@code [0, 65535]}.\n+ * computational}, and {@code slot} is {@link java.lang.classfile##u2 u2}.\n@@ -69,1 +69,1 @@\n-     * The value is within {@code [0, 65535]}.\n+     * It is a {@link java.lang.classfile##u2 u2} value.\n@@ -85,1 +85,1 @@\n-     * {@code slot} must be within {@code [0, 65535]}.\n+     * {@code slot} must be {@link java.lang.classfile##u2 u2}.\n@@ -90,1 +90,2 @@\n-     *         TypeKind#VOID void} or {@code slot} is out of range\n+     *         TypeKind#VOID void} or {@code slot} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -105,2 +106,4 @@\n-     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n-     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <li>If {@code op} has size 2, {@code slot} must be {@link\n+     *     java.lang.classfile##u1 u1}.\n+     * <li>If {@code op} has size 4, {@code slot} must be {@link\n+     *     java.lang.classfile##u2 u2}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StoreInstruction.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n- * will cause a {@code NullPointerException}, unless otherwise specified. <\/p>\n+ * will cause a {@code NullPointerException}, unless otherwise specified.\n@@ -276,0 +276,8 @@\n+ * The Class-File API performs checks to ensure arguments are representable in\n+ * the {@code class} file format.  A value that is lost when it is built to a\n+ * {@code class} file and re-parsed to a model is rejected with an {@link\n+ * IllegalArgumentException}.  For example, a negative value or a value over\n+ * {@code 65535} is lost when built to a {@link ##u2 u2} item, with\n+ * the range {@code [0, 65535]}.  In particular, any variable-sized table\n+ * exceeding its maximum representable size is rejected.\n+ * <p>\n@@ -277,3 +285,4 @@\n- * (except for null arguments checks). All builders and classfile elements factory\n- * methods accepts the provided information without implicit validation.\n- * However, fatal inconsistencies (like for example invalid code sequence or\n+ * (except for null and representable arguments checks). All builders and\n+ * classfile elements factory methods accepts the provided information without\n+ * implicit validation, as long as they are representable in the {@code class}\n+ * file format.  However, fatal inconsistencies (like invalid code sequence or\n@@ -282,1 +291,1 @@\n- * {@link IllegalArgumentException}.\n+ * {@code IllegalArgumentException}.\n@@ -297,3 +306,3 @@\n- * directly from raw values, with no additional conversions or validations.\n- * Following example uses intentionally wrong class name form and it is applied\n- * without any validation or conversion.\n+ * directly from raw values, with no additional conversions or validations, as\n+ * long as they are representable.  Following example uses intentionally wrong\n+ * class name form, which is applied without any validation or conversion.\n@@ -454,0 +463,23 @@\n+ * <h3 id=\"data-types\">Conventional data types<\/h3>\n+ * Chapter {@jvms 4} of the <cite>Java Virtual Machine Specification<\/cite>\n+ * defines a few conventional data types in the {@code class} file format.\n+ * They are consistently represented as {@code int} in the API model.\n+ * Out-of-bound values provided for these data types to the API result in {@link\n+ * IllegalArgumentException}.\n+ * <dl>\n+ * <dt id=\"u1\">{@code u1}<\/dt>\n+ * <dd>One-byte {@linkplain Byte#toUnsignedInt(byte) unsigned} integer, in the\n+ * range {@code [0, 255]}.\n+ * <br>See {@link java.io.DataInput#readUnsignedByte()}.<\/dd>\n+ * <dt id=\"u2\">{@code u2}<\/dt>\n+ * <dd>Two-byte {@linkplain Short#toUnsignedInt(short) unsigned} integer, in the\n+ * range {@code [0, 65535]}.\n+ * <br>Equivalent to a Java {@link Character char}.  Frequently used for flag\n+ * fields and indices and sizes of list structures.\n+ * <br>See {@link java.io.DataInput#readUnsignedShort()}.<\/dd>\n+ * <dt id=\"u4\">{@code u4}<\/dt>\n+ * <dd>Four-byte {@linkplain Integer#toUnsignedLong(int) unsigned} integer, in\n+ * the range {@code [0, 4294967295]}.\n+ * <br>See {@link java.io.DataInput#readInt()}.<\/dd>\n+ * <\/dl>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -85,9 +85,5 @@\n-        switch (kind) {\n-            case GETTER:\n-            case SETTER:\n-            case STATIC_GETTER:\n-            case STATIC_SETTER:\n-                return ofField(kind, owner, name, ClassDesc.ofDescriptor(lookupDescriptor));\n-            default:\n-                return new DirectMethodHandleDescImpl(kind, owner, name, MethodTypeDesc.ofDescriptor(lookupDescriptor));\n-        }\n+        return switch (kind) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER\n+                    -> ofField(kind, owner, name, ClassDesc.ofDescriptor(lookupDescriptor));\n+            default -> new DirectMethodHandleDescImpl(kind, owner, name, MethodTypeDesc.ofDescriptor(lookupDescriptor));\n+        };\n@@ -125,17 +121,7 @@\n-        switch (kind) {\n-            case GETTER:\n-            case SETTER:\n-            case STATIC_GETTER:\n-            case STATIC_SETTER:\n-                throw new IllegalArgumentException(kind.toString());\n-            case VIRTUAL:\n-            case SPECIAL:\n-            case INTERFACE_VIRTUAL:\n-            case INTERFACE_SPECIAL:\n-            case INTERFACE_STATIC:\n-            case STATIC:\n-            case CONSTRUCTOR:\n-                return new DirectMethodHandleDescImpl(kind, owner, name, lookupMethodType);\n-            default:\n-                throw new IllegalArgumentException(kind.toString());\n-        }\n+        return switch (kind) {\n+            case GETTER, SETTER, STATIC_GETTER, STATIC_SETTER\n+                    -> throw new IllegalArgumentException(kind.toString());\n+            case VIRTUAL, SPECIAL, INTERFACE_VIRTUAL, INTERFACE_SPECIAL, INTERFACE_STATIC, STATIC, CONSTRUCTOR\n+                    -> new DirectMethodHandleDescImpl(kind, owner, name, lookupMethodType);\n+            default -> throw new IllegalArgumentException(kind.toString());\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -372,11 +372,26 @@\n-     * <li>If {@code dstType} is a reference type, a reference cast\n-     *     is applied to {@code value} as if by calling {@code dstType.cast(value)}.\n-     * <li>If {@code dstType} is a primitive type, then, if the runtime type\n-     *     of {@code value} is a primitive wrapper type (such as {@link Integer}),\n-     *     a Java unboxing conversion is applied {@jls 5.1.8} followed by a\n-     *     Java casting conversion {@jls 5.5} converting either directly to\n-     *     {@code dstType}, or, if {@code dstType} is {@code boolean},\n-     *     to {@code int}, which is then converted to either {@code true}\n-     *     or {@code false} depending on whether the least-significant-bit\n-     *     is 1 or 0 respectively. If the runtime type of {@code value} is\n-     *     not a primitive wrapper type a {@link ClassCastException} is thrown.\n+     * <li>If {@code dstType} is a reference type, a reference cast is applied\n+     *     to {@code value} as if by calling {@link Class#cast(Object)\n+     *     dstType.cast(value)}.\n+     * <li>Otherwise, {@code dstType} is a primitive type:\n+     *     <ol>\n+     *     <li>If {@code value} is null, the default value (JVMS {@jvms 2.3})\n+     *         of {@code dstType} is returned.\n+     *     <li>If the runtime type of {@code value} is a primitive wrapper type\n+     *         (such as {@link Integer}), a Java unboxing conversion is applied\n+     *         (JLS {@jls 5.1.8}).\n+     *         <ul>\n+     *         <li>If the runtime type is {@link Boolean}, the unboxing result\n+     *             is then converted to {@code int}, where {@code true} becomes\n+     *             {@code 1} and {@code false} becomes {@code 0}.\n+     *         <\/ul>\n+     *         Followed by a Java casting conversion (JLS {@jls 5.5}):\n+     *         <ul>\n+     *         <li>If {@code dstType} is not {@code boolean}, the cast converts\n+     *             directly to {@code dstType}.\n+     *         <li>If {@code dstType} is {@code boolean}, the cast converts to\n+     *             {@code int}, and the resulting {@code boolean} is produced\n+     *             by testing whether the least significant bit of the cast\n+     *             {@code int} is 1.\n+     *         <\/ul>\n+     *     <li>Otherwise, a {@link ClassCastException} is thrown.\n+     *     <\/ol>\n@@ -396,1 +411,1 @@\n-     * @param value the value to be converted\n+     * @param value the value to be converted, may be null\n@@ -398,5 +413,4 @@\n-     * @throws ClassCastException when {@code dstType} is {@code void},\n-     *         when a cast per (1) fails, or when {@code dstType} is a primitive type\n-     *         and the runtime type of {@code value} is not a primitive wrapper type\n-     *         (such as {@link Integer})\n-     *\n+     * @throws ClassCastException when {@code dstType} is {@code void}; when\n+     *         {@code dstType} is a reference type, and the reference cast fails; or\n+     *         when {@code dstType} is primitive, and {@code value} is an\n+     *         instance of a reference type that is not a wrapper class\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":32,"deletions":18,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1519,5 +1519,1 @@\n-     * Returns the set of packages in the module.\n-     *\n-     * <p> The set of packages includes all exported and open packages, as well\n-     * as the packages of any service providers, and the package for the main\n-     * class. <\/p>\n+     * Returns the set of all packages in the module.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -440,1 +440,1 @@\n-                    throw new IllegalArgumentException(\"Invalid KeySpec.\");\n+                    throw new ClassCastException(\"Invalid KeySpec\");\n@@ -443,3 +443,3 @@\n-                throw new IllegalArgumentException(\"Invalid KeySpec \" +\n-                    \"specified (\" + tClass.getName() +\") for key (\" +\n-                    key.getClass().getName() +\")\", e);\n+                throw new ClassCastException(\"Invalid KeySpec \" +\n+                    \"specified: \" + tClass.getName() + \" for key \" +\n+                    key.getClass().getName());\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-     * different accented forms of the same base letter (\"a\" vs \"\" (U+00E9)) to be\n+     * different accented forms of the same base letter (\"a\" vs \"\" (U+00E4)) to be\n@@ -164,2 +164,2 @@\n-     * \"&#092;u00C0\" (A-grave) and combining accents such as \"A&#092;u0300\"\n-     * (A, combining-grave) will be considered significant at the IDENTICAL\n+     * \"&#092;u00E4\" (a-diaeresis) and combining accents such as \"a&#092;u0308\"\n+     * (a, combining-diaeresis) will be considered significant at the IDENTICAL\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n- * and\/or \"tz\" (timezone) <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode\n- * extensions<\/a>, the calendar, the country and\/or the time zone for formatting\n+ * and\/or \"tz\" (timezone) {@linkplain Locale##def_locale_extension Unicode\n+ * extensions}, the calendar, the country and\/or the time zone for formatting\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+ * {@linkplain Locale##def_locale_extension Unicode extension},\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormatSymbols.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3520,0 +3520,4 @@\n+        \/\/ Verify position can fit length wise before checking char by char\n+        if (position + alen > tlen || position < 0) {\n+            return false;\n+        }\n@@ -3524,3 +3528,0 @@\n-        if (position >= tlen) {\n-            return false;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n- * {@code Locale} <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode\n- * extensions<\/a> are supported which may override values within the symbols.\n+ * {@code Locale} {@linkplain Locale##def_locale_extension Unicode\n+ * extensions} are supported which may override values within the symbols.\n@@ -1018,1 +1018,2 @@\n-        if (loadNumberData(locale) instanceof Object[] d &&\n+        \/\/ `locale` was once nullable, need to check before loading locale data\n+        if (locale != null && loadNumberData(locale) instanceof Object[] d &&\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormatSymbols.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n- * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+ * {@linkplain Locale##def_locale_extension Unicode extensions},\n@@ -113,1 +113,1 @@\n- * Although <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>\n+ * Although {@linkplain Locale##def_locale_extension Unicode extensions}\n@@ -694,1 +694,1 @@\n-     * <a href=\"..\/util\/Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- * <p>The requested {@code Locale} may contain an <a\n- * href=\"..\/..\/util\/Locale.html#def_locale_extension\"> extension<\/a> for\n+ * <p>The requested {@code Locale} may contain an {@linkplain\n+ * Locale##def_locale_extension extension} for\n","filename":"src\/java.base\/share\/classes\/java\/text\/spi\/DecimalFormatSymbolsProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1511,3 +1511,3 @@\n-     * If the locale has <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, they may be used later in text\n-     * processing. To set the chronology, time-zone and decimal style from\n+     * If the locale has {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * they may be used later in text processing.\n+     * To set the chronology, time-zone and decimal style from\n@@ -1538,1 +1538,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n@@ -238,1 +238,1 @@\n-     * <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">Unicode extensions<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extensions},\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,2 +153,2 @@\n-     * (Region Override) <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, returned instance will reflect the values specified with\n+     * (Region Override) {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * returned instance will reflect the values specified with\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DecimalStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,2 +292,2 @@\n-     * (Region Override) <a href=\"..\/..\/util\/Locale.html#def_locale_extension\">\n-     * Unicode extensions<\/a>, returned instance will reflect the values specified with\n+     * (Region Override) {@linkplain Locale##def_locale_extension Unicode extensions},\n+     * returned instance will reflect the values specified with\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/WeekFields.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,2 +132,2 @@\n- * locale contains \"fw\" and\/or \"rg\" <a href=\".\/Locale.html#def_locale_extension\">\n- * Unicode extensions<\/a>, the first day of the week will be obtained according to\n+ * locale contains \"fw\" and\/or \"rg\" {@linkplain Locale##def_locale_extension\n+ * Unicode extensions}, the first day of the week will be obtained according to\n@@ -1457,1 +1457,1 @@\n-         * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+         * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -1618,1 +1618,1 @@\n-     * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -1650,1 +1650,1 @@\n-     * <a href=\"Locale.html#def_locale_extension\">Unicode extension<\/a>,\n+     * {@linkplain Locale##def_locale_extension Unicode extension},\n@@ -2635,2 +2635,2 @@\n-     * calendar types can be used for the <a\n-     * href=\"Locale.html#def_locale_extension\">Unicode locale extensions<\/a>.\n+     * calendar types can be used for the {@linkplain Locale##def_locale_extension\n+     * Unicode locale extensions}.\n@@ -2670,1 +2670,1 @@\n-     * @see <a href=\"Locale.html#def_extensions\">Locale extensions<\/a>\n+     * @see Locale##def_locale_extension Locale extensions\n","filename":"src\/java.base\/share\/classes\/java\/util\/Calendar.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3055,2 +3055,2 @@\n-         * <a href=\".\/Locale.html#legacy_language_codes\">Legacy language\n-         * codes<\/a>, either old or new, then repeat the loading process\n+         * {@linkplain Locale##legacy_language_codes Legacy language\n+         * codes}, either old or new, then repeat the loading process\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-     * <a href=\"..\/Locale.html#def_locale_extension\">Unicode extension<\/a> key,\n+     * {@linkplain Locale##def_locale_extension Unicode extension} key,\n@@ -172,1 +172,1 @@\n-     * <a href=\"..\/Locale.html#def_locale_extension\">Unicode extension<\/a> type,\n+     * {@linkplain Locale##def_locale_extension Unicode extension} type,\n","filename":"src\/java.base\/share\/classes\/java\/util\/spi\/LocaleNameProvider.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-            this.flags = flags;\n+            this.flags = Util.checkU2(flags, \"character range flags\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public  AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n+    public AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n@@ -47,1 +47,1 @@\n-        this.flagsMask = mask;\n+        this.flagsMask = Util.checkFlags(mask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AccessFlagsImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        elements = List.copyOf(elements);\n+        elements = Util.sanitizeU2List(elements);\n@@ -192,1 +192,1 @@\n-            values = List.copyOf(values);\n+            values = Util.sanitizeU2List(values);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+        Util.checkU2(attributesCount, \"attributes count\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-                                 MethodHandleEntryImpl handle,\n-                                 List<LoadableConstantEntry> arguments) {\n+                             MethodHandleEntryImpl handle,\n+                             List<LoadableConstantEntry> arguments) {\n@@ -50,1 +50,1 @@\n-        this.arguments = List.copyOf(arguments);\n+        this.arguments = Util.sanitizeU2List(arguments);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BootstrapMethodEntryImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -322,3 +322,1 @@\n-        if (utflen > 65535) {\n-            throw new IllegalArgumentException(\"string too long\");\n-        }\n+        Util.checkU2(utflen, \"utf8 length\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static java.lang.classfile.ClassFile.PREVIEW_MINOR_VERSION;\n+\n@@ -35,2 +37,3 @@\n-        this.majorVersion = majorVersion;\n-        this.minorVersion = minorVersion;\n+        this.majorVersion = Util.checkU2(majorVersion, \"major version\");\n+        this.minorVersion = minorVersion == -1 ? PREVIEW_MINOR_VERSION\n+                : Util.checkU2(minorVersion, \"minor version\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileVersionImpl.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+        Util.checkU2(handlersSize, \"exception handlers\");\n@@ -191,1 +192,1 @@\n-            writeExceptionHandlers(buf, pos);\n+            writeExceptionHandlers(buf, pos, handlersSize);\n@@ -195,2 +196,1 @@\n-    private void writeExceptionHandlers(BufWriterImpl buf, int pos) {\n-        int handlersSize = handlers.size();\n+    private void writeExceptionHandlers(BufWriterImpl buf, int pos, int handlersSize) {\n@@ -231,0 +231,1 @@\n+                        Util.checkU2(crSize, \"character range count\");\n@@ -266,0 +267,1 @@\n+                        Util.checkU2(lvSize, \"local variable count\");\n@@ -295,0 +297,1 @@\n+                        Util.checkU2(lvtSize, \"local variable type count\");\n@@ -445,1 +448,1 @@\n-            b.writeU2(buf.size() \/ 4);\n+            b.writeU2(Util.checkU2(buf.size() \/ 4, \"line number count\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -74,1 +74,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -59,1 +59,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-        this.interfaces = List.copyOf(interfaces);\n+        this.interfaces = Util.sanitizeU2List(interfaces);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/InterfacesImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        return (line < INTERN_LIMIT)\n+        return (Util.checkU2(line, \"line number\") < INTERN_LIMIT)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LineNumberImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-        this.moduleFlags = flags;\n+        this.moduleFlags = Util.checkFlags(flags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+        Util.checkU2(bsmSize, \"num bootstrap methods\");\n@@ -163,4 +164,3 @@\n-        if (size() >= 65536) {\n-            throw new IllegalArgumentException(String.format(\"Constant pool is too large %d\", size()));\n-        }\n-        buf.writeU2(size());\n+        int mySize = size();\n+        Util.checkU2(mySize, \"constant pool count\");\n+        buf.writeU2(mySize);\n@@ -171,1 +171,1 @@\n-        for (int i = writeFrom; i < size(); ) {\n+        for (int i = writeFrom; i < mySize; ) {\n@@ -597,0 +597,1 @@\n+        Util.checkU1(refKind, \"reference kind\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -393,3 +393,3 @@\n-            locals = List.copyOf(locals);\n-            stack = List.copyOf(stack);\n-            unsetFields = List.copyOf(unsetFields);\n+            locals = Util.sanitizeU2List(locals);\n+            stack = Util.sanitizeU2List(stack);\n+            unsetFields = Util.sanitizeU2List(unsetFields);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,3 @@\n-        public TypeParameterTargetImpl(TargetType targetType, int typeParameterIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n-            this.typeParameterIndex = typeParameterIndex;\n+        public TypeParameterTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n@@ -54,0 +54,5 @@\n+\n+        public SupertypeTargetImpl {\n+            Util.checkU2(supertypeIndex, \"supertype index\");\n+        }\n+\n@@ -63,4 +68,4 @@\n-        public TypeParameterBoundTargetImpl(TargetType targetType, int typeParameterIndex, int boundIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n-            this.typeParameterIndex = typeParameterIndex;\n-            this.boundIndex = boundIndex;\n+        public TypeParameterBoundTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n+            Util.checkU1(boundIndex, \"bound index\");\n@@ -78,0 +83,5 @@\n+\n+        public FormalParameterTargetImpl {\n+            Util.checkU1(formalParameterIndex, \"formal parameter index\");\n+        }\n+\n@@ -85,0 +95,5 @@\n+\n+        public ThrowsTargetImpl {\n+            Util.checkU2(throwsTargetIndex, \"throws type index\");\n+        }\n+\n@@ -96,1 +111,1 @@\n-            this.table = List.copyOf(table);\n+            this.table = Util.sanitizeU2List(table);\n@@ -110,0 +125,1 @@\n+            BytecodeHelpers.validateSlot(index);\n@@ -114,0 +130,5 @@\n+\n+        public CatchTargetImpl {\n+            Util.checkU2(exceptionTableIndex, \"exception table index\");\n+        }\n+\n@@ -131,4 +152,4 @@\n-        public TypeArgumentTargetImpl(TargetType targetType, Label target, int typeArgumentIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n-            this.target = requireNonNull(target);\n-            this.typeArgumentIndex = typeArgumentIndex;\n+        public TypeArgumentTargetImpl {\n+            checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n+            requireNonNull(target);\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-            this.exceptions = List.copyOf(exceptions);\n+            this.exceptions = Util.sanitizeU2List(exceptions);\n@@ -247,1 +247,1 @@\n-            this.entries = List.copyOf(entries);\n+            this.entries = Util.sanitizeU2List(entries);\n@@ -271,1 +271,1 @@\n-            this.innerClasses = List.copyOf(innerClasses);\n+            this.innerClasses = Util.sanitizeU2List(innerClasses);\n@@ -295,1 +295,1 @@\n-            this.components = List.copyOf(components);\n+            this.components = Util.sanitizeU2List(components);\n@@ -350,1 +350,1 @@\n-            this.parameters = List.copyOf(parameters);\n+            this.parameters = Util.sanitizeU1List(parameters);\n@@ -424,1 +424,1 @@\n-            this.hashes = List.copyOf(hashes);\n+            this.hashes = Util.sanitizeU2List(hashes);\n@@ -449,1 +449,1 @@\n-        private final Collection<PackageEntry> packages;\n+        private final List<PackageEntry> packages;\n@@ -453,1 +453,1 @@\n-            this.packages = List.copyOf(packages);\n+            this.packages = Util.sanitizeU2List(packages);\n@@ -458,1 +458,1 @@\n-            return List.copyOf(packages);\n+            return packages;\n@@ -477,1 +477,1 @@\n-            resolutionFlags = flags;\n+            resolutionFlags = Util.checkU2(flags, \"resolution flags\");\n@@ -501,1 +501,1 @@\n-            this.permittedSubclasses = List.copyOf(permittedSubclasses);\n+            this.permittedSubclasses = Util.sanitizeU2List(permittedSubclasses);\n@@ -549,1 +549,1 @@\n-            this.memberEntries = List.copyOf(memberEntries);\n+            this.memberEntries = Util.sanitizeU2List(memberEntries);\n@@ -669,1 +669,1 @@\n-            this.ranges = List.copyOf(ranges);\n+            this.ranges = Util.sanitizeU2List(ranges);\n@@ -693,1 +693,1 @@\n-            this.lines = List.copyOf(lines);\n+            this.lines = Util.sanitizeU2List(lines);\n@@ -717,1 +717,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -741,1 +741,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -765,1 +765,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -789,1 +789,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -813,7 +813,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -843,7 +837,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -873,1 +861,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -897,1 +885,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -915,1 +903,8 @@\n-            implements CharacterRangeInfo { }\n+            implements CharacterRangeInfo {\n+\n+        public UnboundCharacterRangeInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(endPc, \"end pc\");\n+            Util.checkU2(flags, \"flags\");\n+        }\n+    }\n@@ -926,0 +921,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -930,1 +926,6 @@\n-            implements LineNumberInfo { }\n+            implements LineNumberInfo {\n+        public UnboundLineNumberInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(lineNumber, \"line number\");\n+        }\n+    }\n@@ -958,0 +959,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -967,1 +969,2 @@\n-            exportsTo = List.copyOf(exportsTo);\n+            Util.checkFlags(exportsFlagsMask);\n+            exportsTo = Util.sanitizeU2List(exportsTo);\n@@ -984,1 +987,2 @@\n-            opensTo = List.copyOf(opensTo);\n+            Util.checkFlags(opensFlagsMask);\n+            opensTo = Util.sanitizeU2List(opensTo);\n@@ -993,1 +997,1 @@\n-            providesWith = List.copyOf(providesWith);\n+            providesWith = Util.sanitizeU2List(providesWith);\n@@ -1002,0 +1006,1 @@\n+            Util.checkFlags(requiresFlagsMask);\n@@ -1013,1 +1018,1 @@\n-            attributes = List.copyOf(attributes);\n+            attributes = Util.sanitizeU2List(attributes);\n@@ -1023,1 +1028,1 @@\n-            targetPath = List.copyOf(targetPath);\n+            targetPath = Util.sanitizeU1List(targetPath);\n@@ -1055,1 +1060,1 @@\n-            this.moduleFlags = moduleFlags;\n+            this.moduleFlags = Util.checkFlags(moduleFlags);\n@@ -1057,5 +1062,5 @@\n-            this.requires = List.copyOf(requires);\n-            this.exports = List.copyOf(exports);\n-            this.opens = List.copyOf(opens);\n-            this.uses = List.copyOf(uses);\n-            this.provides = List.copyOf(provides);\n+            this.requires = Util.sanitizeU2List(requires);\n+            this.exports = Util.sanitizeU2List(exports);\n+            this.opens = Util.sanitizeU2List(opens);\n+            this.uses = Util.sanitizeU2List(uses);\n+            this.provides = Util.sanitizeU2List(provides);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":53,"deletions":48,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-public class Util {\n+public final class Util {\n@@ -155,0 +155,27 @@\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U1, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU1List(List<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU1(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U2, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU2List(Collection<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU2(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input nested list of parameter annotations.\n+    public static List<List<Annotation>> sanitizeParameterAnnotations(List<List<Annotation>> input) {\n+        var array = input.toArray().clone();\n+        checkU1(array.length, \"parameter count\");\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = sanitizeU2List((List<?>) array[i]);\n+        }\n+\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+    }\n+\n@@ -195,0 +222,25 @@\n+    \/\/\/ Ensures the given value won't be truncated when written as a u1\n+    public static int checkU1(int incoming, String valueName) {\n+        if ((incoming & ~0xFF) != 0) {\n+            throw outOfRangeException(incoming, valueName, \"u1\");\n+        }\n+        return incoming;\n+    }\n+\n+    \/\/\/ Ensures the given value won't be truncated when written as a u2\n+    public static char checkU2(int incoming, String valueName) {\n+        if ((incoming & ~0xFFFF) != 0)\n+            throw outOfRangeException(incoming, valueName, \"u2\");\n+        return (char) incoming;\n+    }\n+\n+    public static IllegalArgumentException outOfRangeException(int value, String fieldName, String typeName) {\n+        return new IllegalArgumentException(\n+                String.format(\"%s out of range of %d: %d\", fieldName, typeName, value));\n+    }\n+\n+    \/\/\/ Ensures the given mask won't be truncated when written as an access flag\n+    public static char checkFlags(int mask) {\n+        return checkU2(mask, \"access flags\");\n+    }\n+\n@@ -244,0 +296,1 @@\n+        Util.checkU2(size, \"attributes count\");\n@@ -252,0 +305,1 @@\n+        Util.checkU2(size, \"member count\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -74,1 +75,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringNoRepl(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n@@ -88,1 +94,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringNoRepl(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+          \/\/ use replacement characters for malformed input\n+          return new String(bytes, charset);\n+        }\n@@ -102,1 +113,6 @@\n-        return new String(bytes, charset);\n+        try {\n+            return JAVA_LANG_ACCESS.uncheckedNewStringNoRepl(bytes, charset);\n+        } catch (CharacterCodingException _) {\n+            \/\/ use replacement characters for malformed input\n+            return new String(bytes, charset);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -181,1 +181,5 @@\n-        if (!uninterruptible) end(completed);\n+        if (!uninterruptible) {\n+            end(completed);\n+        } else if (!completed && !isOpen()) {\n+            throw new AsynchronousCloseException();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1565,3 +1565,0 @@\n-        if (ids == null) {\n-            throw new Exception(\"Must provide -id when -gencrl\");\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2504,4 +2504,3 @@\n-    soft goal, and the JVM will make its best effort to achieve it. The\n-    specified value doesn't adapt to your heap size. By default, for G1 the\n-    maximum pause time target is 200 milliseconds. The other generational\n-    collectors do not use a pause time goal by default.\n+    soft goal, and the JVM will make its best effort to achieve it. Only G1\n+    and Parallel support a maximum GC pause time target. For G1, the default\n+    maximum pause time target is 200 milliseconds.\n@@ -2886,0 +2885,40 @@\n+`-XX:+UseShenandoahGC`\n+:   Enables the use of the Shenandoah garbage collector. This is a low pause\n+    time, concurrent garbage collector. Its pause times are not proportional to\n+    the size of the heap. Shenandoah garbage collector can work with compressed\n+    pointers. See `-XX:UseCompressedOops` for further information about\n+    compressed pointers.\n+\n+`-XX:ShenandoahGCMode=`*mode*\n+:   Sets the GC mode for Shenandoah GC to use. By default, this option is set\n+    to `satb`. Among other things, this defines which barriers are in use.\n+    Possible mode values include the following:\n+\n+    `satb`\n+    :   Snapshot-at-the-beginning concurrent GC (three pass mark-evac-update).\n+        It is a single generation GC.\n+\n+    `generational`\n+    :   It is also a snapshot-at-the-beginning and concurrent GC, but it is\n+        generational. Please see [JEP 404](https:\/\/openjdk.org\/jeps\/404) and\n+        [JEP 521](https:\/\/openjdk.org\/jeps\/521) for its advantages and risks.\n+\n+`-XX:ShenandoahGCHeuristics=`*heuristics*\n+:   Sets the heuristics for Shenandoah GC to use. By default, this option is\n+    set to `adaptive`. This fine-tunes the GC mode selected, by choosing when\n+    to start the GC, how much to process on each cycle, and what other features\n+    to automatically enable. When `-XX:ShenandoahGCMode` is `generational`, the\n+    only supported option is the default, `adaptive`.\n+\n+    Possible heuristics are the following:\n+\n+    `adaptive`\n+    :   To maintain the given amount of free heap at all times, even during\n+        the GC cycle.\n+\n+    `static`\n+    :   Trigger GC when free heap falls below a specified threshold.\n+\n+    `compact`\n+    :   Run GC more frequently and with deeper targets to free up more memory.\n+\n","filename":"src\/java.base\/share\/man\/java.md","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,3 +95,5 @@\n-        if (errno() == UnixConstants.ELOOP)\n-            return new FileSystemException(file, other, errorString()\n-                + \" or unable to access attributes of symbolic link\");\n+        if (errno() == UnixConstants.ELOOP) {\n+            String msg = file + \": \" + errorString()\n+                 + \" or unable to access attributes of symbolic link\";\n+            return new FileSystemLoopException(msg);\n+        }\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixException.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+    CHECKED_MALLOC4(_pointer, _type, _size, {})\n+\n+#define CHECKED_MALLOC4(_pointer, _type, _size, _onFailure) \\\n@@ -65,0 +68,1 @@\n+            do _onFailure while (0); \\\n@@ -998,1 +1002,1 @@\n-         CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);\n+         CHECKED_MALLOC4(currif, netif *, sizeof(netif) + IFNAMESIZE, { free(addrP); });\n@@ -1030,1 +1034,4 @@\n-            CHECKED_MALLOC3(currif, netif *, sizeof(netif) + IFNAMESIZE);\n+            CHECKED_MALLOC4(currif, netif *, sizeof(netif) + IFNAMESIZE, {\n+                free(addrP);\n+                free(parent);\n+            });\n@@ -1042,1 +1049,5 @@\n-        CHECKED_MALLOC3(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size);\n+        CHECKED_MALLOC4(tmpaddr, netaddr *, sizeof(netaddr) + 2 * addr_size, {\n+            free(addrP);\n+            free(parent);\n+            free(currif);\n+        });\n","filename":"src\/java.base\/unix\/native\/libnet\/NetworkInterface.c","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -968,1 +968,0 @@\n- \/\/ int got = 0;\n@@ -972,2 +971,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -977,2 +975,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -984,2 +981,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -989,2 +985,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n@@ -994,2 +989,1 @@\n-         \/\/ got =\n-                  getLocaleInfoWrapper(langtag,\n+            getLocaleInfoWrapper(langtag,\n","filename":"src\/java.base\/windows\/native\/libjava\/HostLocaleProviderAdapter_md.c","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-     \/\/ int onlyMapID;\n@@ -307,1 +306,0 @@\n-     \/\/ onlyMapID = 0;\n@@ -328,1 +326,0 @@\n-             \/\/ onlyMapID = 1;\n","filename":"src\/java.base\/windows\/native\/libjava\/TimeZone_md.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-\/\/ static HINSTANCE lib = NULL;\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/NTLMAuthSequence.c","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -394,0 +394,6 @@\n+    private void verifyImageIndex(int imageIndex) {\n+        if (imageIndex < minIndex) {\n+            throw new IndexOutOfBoundsException(\"imageIndex < \" + minIndex);\n+        }\n+    }\n+\n@@ -500,3 +506,1 @@\n-        if (imageIndex < minIndex) {\n-            throw new IndexOutOfBoundsException();\n-        }\n+        verifyImageIndex(imageIndex);\n@@ -845,0 +849,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -859,0 +864,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -889,0 +895,1 @@\n+            verifyImageIndex(imageIndex);\n@@ -907,0 +914,1 @@\n+            verifyImageIndex(imageIndex);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,3 @@\n-        switch (image.getType()) {\n+        Raster raster = image.getRaster();\n+        int type = image.getType();\n+        switch (type) {\n@@ -167,1 +169,1 @@\n-                    return createImageLayout(image.getRaster(), cm);\n+                    return createImageLayout(raster, cm);\n@@ -175,1 +177,1 @@\n-        switch (image.getType()) {\n+        switch (type) {\n@@ -179,1 +181,3 @@\n-                var intRaster = (IntegerComponentRaster) image.getRaster();\n+                if (!(raster instanceof IntegerComponentRaster intRaster)) {\n+                    return null;\n+                }\n@@ -191,1 +195,3 @@\n-                var byteRaster = (ByteComponentRaster) image.getRaster();\n+                if (!(raster instanceof ByteComponentRaster byteRaster)) {\n+                    return null;\n+                }\n@@ -201,1 +207,3 @@\n-                var shortRaster = (ShortComponentRaster) image.getRaster();\n+                if (!(raster instanceof ShortComponentRaster shortRaster)) {\n+                    return null;\n+                }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1101,2 +1101,0 @@\n-        updateFocusability();\n-        promoteDefaultPosition();\n@@ -1104,0 +1102,4 @@\n+        if (refreshChildsTransientFor) {\n+            updateFocusability();\n+        }\n+        promoteDefaultPosition();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindowPeer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+            @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsCheckBoxMenuItemUI.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        new  WindowsMenuItemUIAccessor() {\n+        new WindowsMenuItemUIAccessor() {\n@@ -79,0 +79,1 @@\n+            @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuItemUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-    protected Integer menuBarHeight;\n-    protected boolean hotTrackingOn;\n+    private Integer menuBarHeight;\n+    private boolean hotTrackingOn;\n@@ -65,0 +65,1 @@\n+            @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsMenuUI.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+           @Override\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsRadioButtonMenuItemUI.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,2 +294,7 @@\n-        \/\/ ------------------------------\n-        \/\/ ------------------------------\n+        if (object == null) {\n+            final RuntimeException wrapped =\n+                new IllegalArgumentException(\"Object cannot be null\");\n+            throw new RuntimeOperationsException(wrapped,\n+                      \"Exception occurred trying to register the MBean\");\n+        }\n+\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/interceptor\/DefaultMBeanServerInterceptor.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.IOException;\n@@ -32,0 +33,1 @@\n+import java.nio.channels.FileChannel;\n@@ -34,2 +36,0 @@\n-import java.nio.file.Files;\n-import java.nio.file.OpenOption;\n@@ -723,0 +723,38 @@\n+        \/**\n+         * {@return a request body publisher whose body is the {@code length}\n+         * content bytes read from the provided file {@code channel} starting\n+         * from the specified {@code offset}}\n+         * <p>\n+         * This method and the returned {@code BodyPublisher} do not modify the\n+         * {@code channel}'s position, and do not close the {@code channel}. The\n+         * caller is expected to close the {@code channel} when no longer needed.\n+         *\n+         * @apiNote\n+         * This method can be used to either publish just a region of a file as\n+         * the request body or to publish different regions of a file\n+         * concurrently. A typical usage would be to publish different regions\n+         * of a file by creating a single instance of {@link FileChannel} and\n+         * then send multiple concurrent {@code HttpRequest}s, each of which\n+         * uses a new {@code ofFileChannel BodyPublisher} created from the same\n+         * channel with a different, typically non-overlapping, range of bytes\n+         * specified by offset and length.\n+         *\n+         * @param channel a file channel\n+         * @param offset the offset of the first byte\n+         * @param length the number of bytes to read from the file channel\n+         *\n+         * @throws IndexOutOfBoundsException if the specified byte range is\n+         * found to be {@linkplain Objects#checkFromIndexSize(long, long, long)\n+         * out of bounds} compared with the size of the file referred by the\n+         * channel\n+         *\n+         * @throws IOException if the {@linkplain FileChannel#size() channel's\n+         * size} cannot be determined or the {@code channel} is closed\n+         *\n+         * @since 26\n+         *\/\n+        public static BodyPublisher ofFileChannel(FileChannel channel, long offset, long length) throws IOException {\n+            Objects.requireNonNull(channel, \"channel\");\n+            return new RequestPublishers.FileChannelPublisher(channel, offset, length);\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.channels.FileChannel;\n@@ -421,0 +422,75 @@\n+    public static final class FileChannelPublisher implements BodyPublisher {\n+\n+        private final FileChannel channel;\n+\n+        private final long position;\n+\n+        private final long limit;\n+\n+        public FileChannelPublisher(FileChannel channel, long offset, long length) throws IOException {\n+            this.channel = Objects.requireNonNull(channel, \"channel\");\n+            long fileSize = channel.size();\n+            Objects.checkFromIndexSize(offset, length, fileSize);\n+            this.position = offset;\n+            this.limit = offset + length;\n+        }\n+\n+        @Override\n+        public long contentLength() {\n+            return limit - position;\n+        }\n+\n+        @Override\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+            Iterable<ByteBuffer> iterable = () -> new FileChannelIterator(channel, position, limit);\n+            new PullPublisher<>(iterable).subscribe(subscriber);\n+        }\n+\n+    }\n+\n+    private static final class FileChannelIterator implements Iterator<ByteBuffer> {\n+\n+        private final FileChannel channel;\n+\n+        private final long limit;\n+\n+        private long position;\n+\n+        private boolean terminated;\n+\n+        private FileChannelIterator(FileChannel channel, long position, long limit) {\n+            this.channel = channel;\n+            this.position = position;\n+            this.limit = limit;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return position < limit && !terminated;\n+        }\n+\n+        @Override\n+        public ByteBuffer next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            long remaining = limit - position;\n+            ByteBuffer buffer = Utils.getBufferWithAtMost(remaining);\n+            try {\n+                int readLength = channel.read(buffer, position);\n+                \/\/ Short-circuit if `read()` has failed, e.g., due to file content being changed in the meantime\n+                if (readLength < 0) {\n+                    \/\/ Throw to signal that the request needs to be cancelled\n+                    throw new IOException(\"Unexpected EOF (position=%s)\".formatted(position));\n+                } else {\n+                    position += readLength;\n+                }\n+            } catch (IOException ioe) {\n+                terminated = true;\n+                throw new UncheckedIOException(ioe);\n+            }\n+            return buffer.flip();\n+        }\n+\n+    }\n+\n@@ -433,1 +509,1 @@\n-        public final long contentLength() {\n+        public long contentLength() {\n@@ -438,1 +514,1 @@\n-        public final void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n+        public void subscribe(Flow.Subscriber<? super ByteBuffer> subscriber) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -395,0 +395,4 @@\n+\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance of {@link #BUFSIZE} capacity}\n+     *\/\n@@ -399,0 +403,18 @@\n+    \/**\n+     * {@return a new {@link ByteBuffer} instance whose capacity is set to the\n+     * smaller of the specified {@code maxCapacity} and the default\n+     * ({@value BUFSIZE})}\n+     *\n+     * @param maxCapacity a buffer capacity, in bytes\n+     * @throws IllegalArgumentException if {@code maxCapacity < 0}\n+     *\/\n+    public static ByteBuffer getBufferWithAtMost(long maxCapacity) {\n+        if (maxCapacity < 0) {\n+            throw new IllegalArgumentException(\n+                    \/\/ Match the message produced by `ByteBuffer::createCapacityException`\n+                    \"capacity < 0: (%s < 0)\".formatted(maxCapacity));\n+        }\n+        int effectiveCapacity = (int) Math.min(maxCapacity, BUFSIZE);\n+        return ByteBuffer.allocate(effectiveCapacity);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.security.Provider;\n@@ -54,1 +55,1 @@\n- * The JDK implementation supports the following property that can be set\n+ * The JDK implementation supports the following properties that can be set\n@@ -57,0 +58,3 @@\n+ *   <li><code>org.jcp.xml.dsig.internal.dom.SignatureProvider<\/code>: value\n+ *       must be a {@link Provider}. If specified, the underlying {@code Signature}\n+ *       will be instantiated from this provider.\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/dom\/DOMSignContext.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import java.security.Provider;\n+\n@@ -55,12 +57,22 @@\n- * By default, the JDK implementation enables a secure validation mode by\n- * setting the <code>org.jcp.xml.dsig.secureValidation<\/code> property to\n- * <code>Boolean.TRUE<\/code> (see the {@link #setProperty setProperty}\n- * method). When enabled, validation of XML signatures are subject to\n- * stricter checking of algorithms and other constraints as specified by the\n- * <code>jdk.xml.dsig.secureValidationPolicy<\/code> security property.\n- * The mode can be disabled by setting the property to {@code Boolean.FALSE}.\n- * The mode can also be enabled or disabled by setting the\n- * {@systemProperty org.jcp.xml.dsig.secureValidation} system property to\n- * \"true\" or \"false\". Any other value for the system property is also treated\n- * as \"false\". If the system property is set, it supersedes the\n- * {@code DOMValidateContext} property value.\n+ * The JDK implementation supports the following properties that can be set\n+ * using the {@link #setProperty setProperty} method.\n+ * <ul>\n+ *   <li><code>org.jcp.xml.dsig.secureValidation<\/code>: value must be a\n+ *      {@link Boolean}. When enabled, validation of XML signatures are subject\n+ *      to stricter checking of algorithms and other constraints as specified by the\n+ *      <code>jdk.xml.dsig.secureValidationPolicy<\/code> security property.\n+ *      The default value if not specified is <code>Boolean.TRUE<\/code>.\n+ *      The mode can be disabled by setting the property to {@code Boolean.FALSE}.\n+ *      The mode can also be enabled or disabled by setting the\n+ *      {@systemProperty org.jcp.xml.dsig.secureValidation} system property to\n+ *      \"true\" or \"false\". Any other value for the system property is also treated\n+ *      as \"false\". If the system property is set, it supersedes the\n+ *      {@code DOMValidateContext} property value.\n+ *   <li><code>org.jcp.xml.dsig.validateManifests<\/code>: value\n+ *      must be a {@link Boolean}. If enabled, the references in manifest\n+ *      elements (if exist) are validated during signature validation.\n+ *      The default value if not specified is <code>Boolean.FALSE<\/code>.\n+ *   <li><code>org.jcp.xml.dsig.internal.dom.SignatureProvider<\/code>: value\n+ *      must be a {@link Provider}. If specified, the underlying {@code Signature}\n+ *      will be instantiated from this provider.\n+ * <\/ul>\n","filename":"src\/java.xml.crypto\/share\/classes\/javax\/xml\/crypto\/dsig\/dom\/DOMValidateContext.java","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  private static Address sharedMetaspaceBaseAddr;\n-  private static Address sharedMetaspaceTopAddr;\n+  private static Address aotMetaspaceBaseAddr;\n+  private static Address aotMetaspaceTopAddr;\n@@ -48,2 +48,2 @@\n-    sharedMetaspaceBaseAddr = type.getAddressField(\"_shared_metaspace_base\").getStaticFieldAddress();\n-    sharedMetaspaceTopAddr  = type.getAddressField(\"_shared_metaspace_top\").getStaticFieldAddress();\n+    aotMetaspaceBaseAddr = type.getAddressField(\"_aot_metaspace_base\").getStaticFieldAddress();\n+    aotMetaspaceTopAddr  = type.getAddressField(\"_aot_metaspace_top\").getStaticFieldAddress();\n@@ -53,2 +53,2 @@\n-    Address base = sharedMetaspaceBaseAddr.getAddressAt(0);\n-    Address top  = sharedMetaspaceTopAddr. getAddressAt(0);\n+    Address base = aotMetaspaceBaseAddr.getAddressAt(0);\n+    Address top  = aotMetaspaceTopAddr. getAddressAt(0);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/MetaspaceObj.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-        <string>English<\/string>\n+        <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/ApplicationRuntime-Info.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-  <string>English<\/string>\n+  <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Info-lite.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-        <string>English<\/string>\n+        <string>en-US<\/string>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/Runtime-Info.plist.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,0 @@\n-import java.net.URI;\n@@ -104,0 +103,1 @@\n+import java.nio.file.ProviderNotFoundException;\n@@ -2005,6 +2005,16 @@\n-            Collection<Path> paths = new ArrayList<>();\n-            MemoryFileManager fm = proc.taskFactory.fileManager();\n-\n-            appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.SOURCE_PATH, paths);\n+            Collection<Path> paths = proc.taskFactory.parse(\"\", task -> {\n+                MemoryFileManager fm = proc.taskFactory.fileManager();\n+                Collection<Path> _paths = new ArrayList<>();\n+                try {\n+                    appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.SOURCE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.SYSTEM_MODULES, _paths);\n+                    appendModulePaths(fm, StandardLocation.UPGRADE_MODULE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.MODULE_PATH, _paths);\n+                    return _paths;\n+                } catch (Exception ex) {\n+                    proc.debug(ex, \"SourceCodeAnalysisImpl.refreshIndexes(\" + version + \")\");\n+                    return List.of();\n+                }\n+            });\n@@ -2063,0 +2073,14 @@\n+    private void appendModulePaths(MemoryFileManager fm, Location loc, Collection<Path> paths) throws IOException {\n+        for (Set<Location> moduleLocations : fm.listLocationsForModules(loc)) {\n+            for (Location moduleLocation : moduleLocations) {\n+                Iterable<? extends Path> modulePaths = fm.getLocationAsPaths(moduleLocation);\n+\n+                if (modulePaths == null) {\n+                    continue;\n+                }\n+\n+                modulePaths.forEach(paths::add);\n+            }\n+        }\n+    }\n+\n@@ -2066,18 +2090,1 @@\n-        if (isJRTMarkerFile(path)) {\n-            FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-            Path modules = jrtfs.getPath(\"modules\");\n-            return PATH_TO_INDEX.compute(path, (p, index) -> {\n-                try {\n-                    long lastModified = Files.getLastModifiedTime(modules).toMillis();\n-                    if (index == null || index.timestamp != lastModified) {\n-                        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modules)) {\n-                            index = doIndex(lastModified, path, stream);\n-                        }\n-                    }\n-                    return index;\n-                } catch (IOException ex) {\n-                    proc.debug(ex, \"SourceCodeAnalysisImpl.indexesForPath(\" + path.toString() + \")\");\n-                    return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());\n-                }\n-            });\n-        } else if (!Files.isDirectory(path)) {\n+        if (!Files.isDirectory(path)) {\n@@ -2096,1 +2103,1 @@\n-                    } catch (IOException ex) {\n+                    } catch (IOException | ProviderNotFoundException ex) {\n@@ -2115,4 +2122,0 @@\n-    static boolean isJRTMarkerFile(Path path) {\n-        return path.equals(Paths.get(System.getProperty(\"java.home\"), \"lib\", \"modules\"));\n-    }\n-\n@@ -2203,1 +2206,1 @@\n-            INDEXER.submit(() -> {}).get();\n+            waitCurrentBackgroundTasksFinished();\n@@ -2210,0 +2213,4 @@\n+    public static void waitCurrentBackgroundTasksFinished() throws Exception {\n+        INDEXER.submit(() -> {}).get();\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":38,"deletions":31,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-    if (read_ticks(\"\/proc\/self\/stat\", &userTicks, &systemTicks) < 0) {\n+    if (read_ticks(\"\/proc\/self\/stat\", &userTicks, &systemTicks) != 2) {\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        <batik.version>1.17<\/batik.version>\n+        <batik.version>1.19<\/batik.version>\n","filename":"src\/utils\/IdealGraphVisualizer\/pom.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"some_symbol%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"some_symbol%d\", i);\n@@ -161,1 +161,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n@@ -180,1 +180,1 @@\n-    os::snprintf(symbol_name, symbol_name_length, \"temp-%d\", i);\n+    os::snprintf_checked(symbol_name, symbol_name_length, \"temp-%d\", i);\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-  snprintf(path, len, \"%s\/lib\/jli\/libjli.dylib\", java_home);\n+  os::snprintf_checked(path, len, \"%s\/lib\/jli\/libjli.dylib\", java_home);\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-  snprintf(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n+  os::snprintf_checked(name, len, \"%s%s\", LogFileOutput::Prefix, TestLogFileName);\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-  delete_file(test_file);\n@@ -361,0 +360,2 @@\n+\n+  delete_file(test_file);\n@@ -396,0 +397,2 @@\n+\n+  delete_file(test_file);\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-    os::snprintf(buf, JVM_MAXPATHLEN, \"%d\", (int) wcslen(path));\n+    os::snprintf_checked(buf, JVM_MAXPATHLEN, \"%d\", (int) wcslen(path));\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,0 +298,27 @@\n+\n+TEST(globalDefinitions, jlong_from) {\n+  jlong val = jlong_from(0xFF, 0);\n+  EXPECT_EQ(val, CONST64(0x00000000FF00000000));\n+\n+  val = jlong_from(0, 0xFF);\n+  EXPECT_EQ(val, CONST64(0x00000000000000FF));\n+\n+  val = jlong_from(0xFFFFFFFF, 0);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFF00000000));\n+\n+  val = jlong_from(0, 0xFFFFFFFF);\n+  EXPECT_EQ(val, CONST64(0x00000000FFFFFFFF));\n+\n+  val = jlong_from(0, -1);\n+  EXPECT_EQ(val, CONST64(0x00000000FFFFFFFF));\n+\n+  val = jlong_from(-1, 0);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFF00000000));\n+\n+  val = jlong_from(-1, -1);\n+  EXPECT_EQ((julong)val, UCONST64(0xFFFFFFFFFFFFFFFF));\n+  EXPECT_EQ(val, CONST64(-1));\n+\n+  val = jlong_from(0xABCD, 0xEFEF);\n+  EXPECT_EQ(val, CONST64(0x0000ABCD0000EFEF));\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalDefinitions.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -989,17 +989,17 @@\n-  typedef RBTree<int, unsigned, IntCmp, RBTreeCHeapAllocator<mtTest> > TreeType;\n-    TreeType tree;\n-    const int i1 = 82924;\n-    const char* const s1 = \"[82924] = 1\";\n-    const int i2 = -13591;\n-    const char* const s2 = \"[-13591] = 2\";\n-    const int i3 = 0;\n-    const char* const s3 = \"[0] = 3\";\n-    tree.upsert(i1, 1U);\n-    tree.upsert(i2, 2U);\n-    tree.upsert(i3, 3U);\n-    stringStream ss;\n-    tree.print_on(&ss);\n-    const char* const N = nullptr;\n-    ASSERT_NE(strstr(ss.base(), s1), N);\n-    ASSERT_NE(strstr(ss.base(), s2), N);\n-    ASSERT_NE(strstr(ss.base(), s3), N);\n+  using TreeType = RBTreeCHeap<int, unsigned, IntCmp, mtTest>;\n+  TreeType tree;\n+  const int i1 = 82924;\n+  const char* const s1 = \"[82924] = 1\";\n+  const int i2 = -13591;\n+  const char* const s2 = \"[-13591] = 2\";\n+  const int i3 = 0;\n+  const char* const s3 = \"[0] = 3\";\n+  tree.upsert(i1, 1U);\n+  tree.upsert(i2, 2U);\n+  tree.upsert(i3, 3U);\n+  stringStream ss;\n+  tree.print_on(&ss);\n+  const char* const N = nullptr;\n+  ASSERT_NE(strstr(ss.base(), s1), N);\n+  ASSERT_NE(strstr(ss.base(), s2), N);\n+  ASSERT_NE(strstr(ss.base(), s3), N);\n@@ -1082,0 +1082,12 @@\n+struct OomAllocator {\n+  void* allocate(size_t sz) {\n+    return nullptr;\n+  }\n+  void free(void* ptr) {}\n+};\n+TEST_VM_F(RBTreeTest, AllocatorMayReturnNull) {\n+  RBTree<int, int, Cmp, OomAllocator> rbtree;\n+  bool success = rbtree.upsert(5, 5);\n+  EXPECT_EQ(false, success);\n+  \/\/ The test didn't exit the VM, so it was succesful.\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+    vm.cds.nocoops.archive.available \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run driver compiler.arguments.TestCompileTaskTimeout\n+ * @run driver\/timeout=480 compiler.arguments.TestCompileTaskTimeout\n@@ -52,1 +52,1 @@\n-        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=200\", \"--version\")\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=2000\", \"--version\")\n@@ -55,1 +55,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompileTaskTimeout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n- * @run main\/othervm\/timeout=7200\n+ * @run main\/othervm\/timeout=28800\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressArrayCopy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  * @run main\/othervm\/timeout=480 -Xcomp -XX:CompileCommand=compileonly,TestConcurrentPatching::* -XX:TieredStopAtLevel=1 TestConcurrentPatching\n+  * @run main\/othervm\/timeout=1920 -Xcomp -XX:CompileCommand=compileonly,TestConcurrentPatching::* -XX:TieredStopAtLevel=1 TestConcurrentPatching\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestConcurrentPatching.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -XX:TieredStopAtLevel=1 -Xbatch\n+ * @run main\/othervm\/timeout=480 -XX:TieredStopAtLevel=1 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestPinnedIntrinsics.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main compiler.c2.TestMergeStores aligned\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores aligned\n@@ -49,1 +49,1 @@\n- * @run main compiler.c2.TestMergeStores unaligned\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores unaligned\n@@ -58,1 +58,1 @@\n- * @run main compiler.c2.TestMergeStores StressIGVN\n+ * @run main\/timeout=480 compiler.c2.TestMergeStores StressIGVN\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeStores.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @run main\/othervm compiler.c2.TestScalarReplacementMaxLiveNodes\n- * @run main\/othervm -Xbatch -XX:-OptimizeStringConcat -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 compiler.c2.TestScalarReplacementMaxLiveNodes\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-OptimizeStringConcat -XX:-TieredCompilation\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestScalarReplacementMaxLiveNodes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:+StressRecompilation\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:+StressRecompilation\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestStressRecompilation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/* Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8361582\n+* @summary Ensure the correct backend replicate node is being generated for\n+*          half precision float constants on >16B SVE machines\n+* @modules jdk.incubator.vector\n+* @library \/test\/lib \/\n+* @run main\/othervm compiler.c2.aarch64.TestFloat16Replicate\n+*\/\n+\n+package compiler.c2.aarch64;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.incubator.vector.Float16;\n+import jdk.test.lib.*;\n+import jdk.test.lib.Utils;\n+\n+import static java.lang.Float.*;\n+import static jdk.incubator.vector.Float16.*;\n+\n+public class TestFloat16Replicate {\n+    private static short[] input;\n+    private static short[] output;\n+    private static short[] expected;\n+    private static Random rnd;\n+\n+    \/\/ Choose FP16_IMM8 which is within the range of [-128 << 8, 127 << 8] and a multiple of 256\n+    private static final Float16 FP16_IMM8;\n+\n+    \/\/ Choose a value in the range [-128 << 8, 127 << 8] and a non multiple of 256 for FP16_NON_IMM8\n+    private static final Float16 FP16_NON_IMM8;\n+\n+    private static final int LEN = 1024;\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n+    }\n+\n+    static {\n+        rnd = Utils.getRandomInstance();\n+        int k = rnd.nextInt(-128, 128);\n+        int b = rnd.nextInt(1, 256);\n+        short bits_imm8     = (short) (k << 8);\n+        short bits_non_imm8 = (short) ((k << 8) + b);\n+\n+        FP16_IMM8     = Float16.shortBitsToFloat16(bits_imm8);\n+        FP16_NON_IMM8 = Float16.shortBitsToFloat16(bits_non_imm8);\n+\n+        input  = new short[LEN];\n+        output = new short[LEN];\n+        expected = new short[LEN];\n+\n+        for (int i = 0; i < LEN; i++) {\n+            input[i] = (short) i;\n+        }\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 immediate is a signed value within the\n+    \/\/ range [-128, 127] or a signed multiple of 256 in the range [-32768, 32512] for element widths of\n+    \/\/ 16 bits or higher then the backend should generate the \"replicateHF_imm_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF_IMM8, \">0\"},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(Float16.add(shortBitsToFloat16(input[i]), FP16_IMM8));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddInRange\")\n+    public void checkResultFloat16AddInRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            expected[i] = floatToFloat16(float16ToFloat(input[i]) + FP16_IMM8.floatValue());\n+        }\n+        Verify.checkEQWithRawBits(output, expected);\n+    }\n+\n+    \/\/ For vectorizable loops containing FP16 operations with an FP16 constant as one of the inputs, the IR\n+    \/\/ node `(dst (Replicate con))` is generated to broadcast the constant into all lanes of an SVE register.\n+    \/\/ On SVE-capable hardware with vector length > 16B, if the FP16 constant falls outside the immediate\n+    \/\/ range accepted by the SVE \"dup\" instruction, the backend must:\n+    \/\/   1. Generate the \"loadConH\" machnode to load the FP16 constant from the constant pool.\n+    \/\/   2. Emit the \"replicateHF\" machnode to broadcast this loaded constant into an SVE register.\n+    \/\/ In this case, the backend should not generate the \"replicateHF_imm8_gt128b\" machnode.\n+    @Test\n+    @Warmup(5000)\n+    @IR(counts = {IRNode.REPLICATE_HF, \">0\"},\n+        failOn = {IRNode.REPLICATE_HF_IMM8},\n+        phase = CompilePhase.FINAL_CODE,\n+        applyIf = {\"MaxVectorSize\", \">16\"},\n+        applyIfCPUFeature = {\"sve\", \"true\"})\n+    public void TestFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input[i]), FP16_NON_IMM8));\n+        }\n+    }\n+\n+    @Check(test=\"TestFloat16AddOutOfRange\")\n+    public void checkResultFloat16AddOutOfRange() {\n+        for (int i = 0; i < LEN; ++i) {\n+            expected[i] = floatToFloat16(float16ToFloat(input[i]) + FP16_NON_IMM8.floatValue());\n+        }\n+        Verify.checkEQWithRawBits(output, expected);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFloat16Replicate.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -53,13 +54,18 @@\n-        \/\/ Cross-product: +-AlignVector and +-UseCompactObjectHeaders\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:-UseCompactObjectHeaders\",\n-                                   \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:-UseCompactObjectHeaders\",\n-                                   \"-XX:+AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:+UseCompactObjectHeaders\",\n-                                   \"-XX:-AlignVector\");\n-        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-                                   \"-XX:+UseCompactObjectHeaders\",\n-                                   \"-XX:+AlignVector\");\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                           \"-XX:+UnlockExperimentalVMOptions\");\n+\n+        \/\/ Cross-product:\n+        \/\/   +-AlignVector\n+        \/\/   +-UseCompactObjectHeaders\n+        \/\/   +-UseAutoVectorizationSpeculativeAliasingChecks\n+        int idx = 0;\n+        for (String av : List.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\")) {\n+            for (String coh : List.of(\"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompactObjectHeaders\")) {\n+                for (String sac : List.of(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\")) {\n+                    framework.addScenarios(new Scenario(idx++, av, coh, sac));\n+                }\n+            }\n+        }\n+\n+        framework.start();\n@@ -129,1 +135,1 @@\n-            int val = offset > 0 ? verifyByteArray[(i-offset) % 8] : verifyByteArray[i-offset];\n+            int val = offset >=1 ? verifyByteArray[(i-offset) % 8] : verifyByteArray[i-offset];\n@@ -482,1 +488,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -490,1 +503,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -504,1 +524,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -512,1 +539,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -527,1 +561,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n@@ -535,1 +576,8 @@\n-    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR })\n+    @IR(failOn = { IRNode.LOAD_VECTOR_L, IRNode.STORE_VECTOR },\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_L, \">=1\", IRNode.STORE_VECTOR, \">=1\", \".*multiversion.*\", \">=1\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"})\n+    \/\/ We have unknown aliasing. At runtime \"dest == src\", so the AutoVectorization Predicate fails, and recompiles with Multiversioning.\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":68,"deletions":20,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 -XX:-TieredCompilation -XX:CompileThreshold=2 -XX:CICompilerCount=1\n+ * @run main\/othervm\/timeout=1200 -XX:-TieredCompilation -XX:CompileThreshold=2 -XX:CICompilerCount=1\n@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 -XX:TieredCompileTaskTimeout=1000 -XX:CompileThresholdScaling=0.001 -XX:CICompilerCount=2\n+ * @run main\/othervm\/timeout=1200 -XX:TieredCompileTaskTimeout=1000 -XX:CompileThresholdScaling=0.001 -XX:CICompilerCount=2\n","filename":"test\/hotspot\/jtreg\/compiler\/classUnloading\/methodUnloading\/TestOverloadCompileQueues.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm -XX:CompileOnly=TestAntiDependenciesHighMemUsage2::test1 -XX:-ClipInlining\n+ * @run main\/othervm\/timeout=480 -XX:CompileOnly=TestAntiDependenciesHighMemUsage2::test1 -XX:-ClipInlining\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestAntiDependenciesHighMemUsage2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=480 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/aes\/TestCipherBlockChainingEncrypt.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestLoadBypassesClassCast::test\n+ * @run main\/othervm\/timeout=480 -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:CompileOnly=TestLoadBypassesClassCast::test\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestLoadBypassesClassCast.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/native compiler.floatingpoint.TestFloatSyncJNIArgs\n+ * @run main\/othervm\/native\/timeout=480 compiler.floatingpoint.TestFloatSyncJNIArgs\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestFloatSyncJNIArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-* @run driver compiler.intrinsics.TestLongUnsignedDivMod\n+* @run driver\/timeout=480 compiler.intrinsics.TestLongUnsignedDivMod\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver\/timeout=180 compiler.jsr292.ContinuousCallSiteTargetChange\n+ * @run driver\/timeout=720 compiler.jsr292.ContinuousCallSiteTargetChange\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/ContinuousCallSiteTargetChange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm -Djdk.attach.allowAttachSelf compiler.jsr292.RedefineMethodUsedByMultipleMethodHandles\n+ * @run main\/othervm\/timeout=480 -Djdk.attach.allowAttachSelf compiler.jsr292.RedefineMethodUsedByMultipleMethodHandles\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/RedefineMethodUsedByMultipleMethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -Djdk.attach.allowAttachSelf jdk.vm.ci.runtime.test.RedefineClassTest\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -Djdk.attach.allowAttachSelf jdk.vm.ci.runtime.test.RedefineClassTest\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/RedefineClassTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/timeout=240 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaMethod\n+ * @run junit\/othervm\/timeout=960 -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaMethod\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2956,0 +2956,10 @@\n+    public static final String REPLICATE_HF = PREFIX + \"REPLICATE_HF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF, \"replicateHF\");\n+    }\n+\n+    public static final String REPLICATE_HF_IMM8 = PREFIX + \"REPLICATE_HF_IMM8\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF_IMM8, \"replicateHF_imm8_gt128b\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java).\n+If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java). If a user wants to test all combinations of multiple sets of flags, they can use `TestFramework.addCrossProductScenarios()`.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -50,0 +51,1 @@\n+import java.util.stream.Stream;\n@@ -336,0 +338,65 @@\n+    \/**\n+     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when when constructing\n+     * scenarios directly a string can contain multiple flags separated with a space. This allows grouping\n+     * flags that have to be specified togeher. Further, an empty string in a set stands in for \"no flag\".\n+     * <p>\n+     * Example:\n+     * <pre>\n+     *     addCrossProductScenarios(Set.of(\"\", \"-Xint\", \"-Xbatch -XX:-TieredCompilation\"),\n+     *                              Set.of(\"-XX:+UseNewCode\", \"-XX:UseNewCode2\"))\n+     * <\/pre>\n+     *   produces the following Scenarios\n+     * <pre>\n+     *     Scenario(0, \"-XX:+UseNewCode\")\n+     *     Scenario(1, \"-XX:+UseNewCode2\")\n+     *     Scenario(2, \"-Xint\", \"-XX:+UseNewCode\")\n+     *     Scenario(3, \"-Xint\", \"-XX:+UseNewCode2\")\n+     *     Scenario(4, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode\")\n+     *     Scenario(5, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode2\")\n+     * <\/pre>\n+     *\n+     * @param sets sets of flags to generate the cross product for.\n+     * @return the same framework instance.\n+     *\/\n+    @SafeVarargs\n+    final public TestFramework addCrossProductScenarios(Set<String>... flagSets) {\n+        TestFormat.checkAndReport(flagSets != null &&\n+                                  Arrays.stream(flagSets).noneMatch(Objects::isNull) &&\n+                                  Arrays.stream(flagSets).flatMap(Set::stream).noneMatch(Objects::isNull),\n+                                  \"Flags must not be null\");\n+        if (flagSets.length == 0) {\n+            return this;\n+        }\n+\n+        int initIdx = 0;\n+        if (this.scenarioIndices != null && !this.scenarioIndices.isEmpty()) {\n+            initIdx = this.scenarioIndices.stream().max(Comparator.comparingInt(Integer::intValue)).get() + 1;\n+        }\n+        AtomicInteger idx = new AtomicInteger(initIdx);\n+\n+        Stream<List<String>> crossProduct = Arrays.stream(flagSets)\n+            .reduce(\n+                Stream.of(Collections.<String>emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n+                (Stream<List<String>> acc, Set<String> set) ->\n+                    acc.flatMap(lAcc -> \/\/ For each List<String>> lAcc in acc...\n+                        set.stream().map(flag -> { \/\/ ...and each flag in the current set...\n+                            List<String> newList = new ArrayList<>(lAcc); \/\/ ...create a new list containing lAcc...\n+                            newList.add(flag); \/\/ ...and append the flag.\n+                            return newList;\n+                        }) \/\/ This results in one List<List<String>> for each lAcc...\n+                    ), \/\/ ...that get flattend into one big List<List<String>>.\n+                (a, b) -> Stream.concat(a, b)); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n+\n+        Scenario[] newScenarios = crossProduct\n+            .map(flags -> new Scenario( \/\/ For each List<String> flags in crossProduct create a new Scenario.\n+                idx.getAndIncrement(),\n+                flags.stream() \/\/ Process flags\n+                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split muliple flags in the same string into separate strings.\n+                     .flatMap(Collection::stream) \/\/ Flatten the Stream<List<String>> into Stream<String>>.\n+                     .filter(s -> !s.isEmpty()) \/\/ Remove empty string flags.\n+                     .collect(Collectors.toList())\n+                     .toArray(new String[0])))\n+            .collect(Collectors.toList()).toArray(new Scenario[0]);\n+        return addScenarios(newScenarios);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,TestMaxLoopOptsCountReached::test TestMaxLoopOptsCountReached\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,TestMaxLoopOptsCountReached::test TestMaxLoopOptsCountReached\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMaxLoopOptsCountReached.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-TieredCompilation\n@@ -37,1 +37,1 @@\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation\n@@ -48,1 +48,1 @@\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ * @run main\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n@@ -58,1 +58,1 @@\n- * @run main compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ * @run main\/timeout=480 compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelAtUnsignedTestsNegativeLimit.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Float.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.ProdRed_Int\n+ * @run driver\/timeout=480 compiler.loopopts.superword.ProdRed_Int\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedAbsNeg_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedAbsNeg_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedAbsNeg_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedAbsNeg_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedAbsNeg_Float.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRedSqrt_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRedSqrt_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRedSqrt_Double.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Double\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Double\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Double.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Float\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Float\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Float.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run driver compiler.loopopts.superword.SumRed_Int\n+ * @run driver\/timeout=480 compiler.loopopts.superword.SumRed_Int\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Int.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,516 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing nCOH_yAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestAliasing yCOH_yAV_nSAC\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.test.lib.Utils;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import static compiler.lib.generators.Generators.G;\n+import compiler.lib.generators.Generator;\n+\n+\/**\n+ * More complicated test cases can be found in {@link TestAliasingFuzzing}.\n+ *\/\n+public class TestAliasing {\n+    static int SIZE = 1024*8;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+    private static final Generator INT_GEN = G.ints();\n+\n+    \/\/ Invariants used in tests.\n+    public static int INVAR_ZERO = 0;\n+\n+    \/\/ Original data.\n+    public static byte[] ORIG_AB = fillRandom(new byte[SIZE]);\n+    public static byte[] ORIG_BB = fillRandom(new byte[SIZE]);\n+    public static int[]  ORIG_AI = fillRandom(new int[SIZE]);\n+    public static int[]  ORIG_BI = fillRandom(new int[SIZE]);\n+\n+    \/\/ The data we use in the tests. It is initialized from ORIG_* every time.\n+    public static byte[] AB = new byte[SIZE];\n+    public static byte[] BB = new byte[SIZE];\n+    public static int[]  AI = new int[SIZE];\n+    public static int[]  BI = new int[SIZE];\n+\n+    \/\/ Parallel to data above, but for use in reference methods.\n+    public static byte[] AB_REFERENCE = new byte[SIZE];\n+    public static byte[] BB_REFERENCE = new byte[SIZE];\n+    public static int[]  AI_REFERENCE = new int[SIZE];\n+    public static int[]  BI_REFERENCE = new int[SIZE];\n+\n+    interface TestFunction {\n+        void run();\n+    }\n+\n+    \/\/ Map of goldTests, i.e. tests that work with a golds value generated from the same test method,\n+    \/\/ at the beginning when we are still executing in the interpreter.\n+    Map<String,TestFunction> goldTests = new HashMap<String,TestFunction>();\n+\n+    \/\/ Map of gold, the results from the first run before compilation, one per goldTests entry.\n+    Map<String,Object> golds = new HashMap<String,Object>();\n+\n+    \/\/ Map of referenceTests, i.e. tests that have a reference implementation that is run with the interpreter.\n+    \/\/ The TestFunction must run both the test and reference methods.\n+    Map<String,TestFunction> referenceTests = new HashMap<String,TestFunction>();\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestAliasing.class);\n+        switch (args[0]) {\n+            case \"nCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n+    }\n+\n+    public TestAliasing() {\n+        \/\/ Add all goldTests to list\n+        goldTests.put(\"copy_B_sameIndex_noalias\",         () -> { copy_B_sameIndex_noalias(AB, BB); });\n+        goldTests.put(\"copy_B_sameIndex_alias\",           () -> { copy_B_sameIndex_alias(AB, AB); });\n+        goldTests.put(\"copy_B_differentIndex_noalias\",    () -> { copy_B_differentIndex_noalias(AB, BB); });\n+        goldTests.put(\"copy_B_differentIndex_noalias_v2\", () -> { copy_B_differentIndex_noalias_v2(); });\n+        goldTests.put(\"copy_B_differentIndex_alias\",      () -> { copy_B_differentIndex_alias(AB, AB); });\n+\n+        goldTests.put(\"copy_I_sameIndex_noalias\",         () -> { copy_I_sameIndex_noalias(AI, BI); });\n+        goldTests.put(\"copy_I_sameIndex_alias\",           () -> { copy_I_sameIndex_alias(AI, AI); });\n+        goldTests.put(\"copy_I_differentIndex_noalias\",    () -> { copy_I_differentIndex_noalias(AI, BI); });\n+        goldTests.put(\"copy_I_differentIndex_alias\",      () -> { copy_I_differentIndex_alias(AI, AI); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            init();\n+            test.run();\n+            Object gold = snapshotCopy();\n+            golds.put(name, gold);\n+        }\n+\n+        referenceTests.put(\"fill_B_sameArray_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_B_sameArray_alias(AB, AB, invar1, invar2);\n+            reference_fill_B_sameArray_alias(AB_REFERENCE, AB_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"fill_B_sameArray_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_B_sameArray_noalias(AB, AB, invar1, invar2, limit);\n+            reference_fill_B_sameArray_noalias(AB_REFERENCE, AB_REFERENCE, invar1, invar2, limit);\n+        });\n+    }\n+\n+    public static void init() {\n+        System.arraycopy(ORIG_AB, 0, AB, 0, SIZE);\n+        System.arraycopy(ORIG_BB, 0, BB, 0, SIZE);\n+        System.arraycopy(ORIG_AI, 0, AI, 0, SIZE);\n+        System.arraycopy(ORIG_BI, 0, BI, 0, SIZE);\n+    }\n+\n+    public static void initReference() {\n+        System.arraycopy(ORIG_AB, 0, AB_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_BB, 0, BB_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_AI, 0, AI_REFERENCE, 0, SIZE);\n+        System.arraycopy(ORIG_BI, 0, BI_REFERENCE, 0, SIZE);\n+    }\n+\n+    public static Object snapshotCopy() {\n+        return new Object[] {\n+            AB.clone(), BB.clone(),\n+            AI.clone(), BI.clone()\n+        };\n+    }\n+\n+    public static Object snapshot() {\n+        return new Object[] {\n+            AB, BB,\n+            AI, BI\n+        };\n+    }\n+\n+    public static Object snapshotReference() {\n+        return new Object[] {\n+            AB_REFERENCE, BB_REFERENCE,\n+            AI_REFERENCE, BI_REFERENCE\n+        };\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"copy_B_sameIndex_noalias\",\n+                 \"copy_B_sameIndex_alias\",\n+                 \"copy_B_differentIndex_noalias\",\n+                 \"copy_B_differentIndex_noalias_v2\",\n+                 \"copy_B_differentIndex_alias\",\n+                 \"copy_I_sameIndex_noalias\",\n+                 \"copy_I_sameIndex_alias\",\n+                 \"copy_I_differentIndex_noalias\",\n+                 \"copy_I_differentIndex_alias\",\n+                 \"test_fill_B_sameArray_alias\",\n+                 \"test_fill_B_sameArray_noalias\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object gold = golds.get(name);\n+            \/\/ Compute new result\n+            init();\n+            test.run();\n+            Object result = snapshot();\n+            \/\/ Compare gold and new result\n+            try {\n+                Verify.checkEQ(gold, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+\n+        for (Map.Entry<String,TestFunction> entry : referenceTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Init data for test and reference\n+            init();\n+            initReference();\n+            \/\/ Run test and reference\n+            test.run();\n+            \/\/ Capture results from test and reference\n+            Object result = snapshot();\n+            Object expected = snapshotReference();\n+            \/\/ Compare expected and new result\n+            try {\n+                Verify.checkEQ(expected, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+    }\n+\n+    static byte[] fillRandom(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)(int)INT_GEN.next();\n+        }\n+        return a;\n+    }\n+\n+    static int[] fillRandom(int[] a) {\n+        G.fill(INT_GEN, a);\n+        return a;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_B_sameIndex_noalias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_B_sameIndex_alias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_B_differentIndex_noalias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    \/\/\n+    \/\/ Same as \"copy_B_differentIndex_noalias, but somehow loading from fields rather\n+    \/\/ than arguments does not lead to vectorization.\n+    static void copy_B_differentIndex_noalias_v2() {\n+        for (int i = 0; i < AB.length; i++) {\n+            BB[i] = AB[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B,            \"> 0\",\n+                  IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_B_differentIndex_alias(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_I_sameIndex_noalias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Should always vectorize, no speculative runtime check required.\n+    static void copy_I_sameIndex_alias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, they never fail, so no multiversioning required.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_I_differentIndex_noalias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+          b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,            \"> 0\",\n+                  IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    static void copy_I_differentIndex_alias(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i + INVAR_ZERO];\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*pre .* multiversion_fast.*\",  \"= 1\",\n+                  \".*main .* multiversion_fast.*\", \"= 1\",\n+                  \".*post .* multiversion_fast.*\", \"= 2\", \/\/ vectorized and scalar versions\n+                  \".*multiversion_slow.*\",         \"= 2\", \/\/ main and post (pre-loop only has a single iteration)\n+                  \".*multiversion.*\",              \"= 6\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, it fails and so we do need multiversioning.\n+    \/\/ With AlignVector we cannot prove that both accesses are alignable.\n+    \/\/\n+    \/\/ FYI: invar1 and invar2 are small values, only used to test that everything runs\n+    \/\/      correctly with at different offsets \/ with different alignment.\n+    static void test_fill_B_sameArray_alias(byte[] a, byte[] b, int invar1, int invar2) {\n+        for (int i = 0; i < a.length - 100; i++) {\n+            a[i + invar1] = (byte)0x0a;\n+            b[a.length - i - 1 - invar2] = (byte)0x0b;\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_B_sameArray_alias(byte[] a, byte[] b, int invar1, int invar2) {\n+        for (int i = 0; i < a.length - 100; i++) {\n+            a[i + invar1] = (byte)0x0a;\n+            b[a.length - i - 1 - invar2] = (byte)0x0b;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Without speculative runtime check we cannot know that there is no aliasing.\n+    @IR(counts = {IRNode.STORE_VECTOR,             \"> 0\",\n+                  \".*multiversion.*\",              \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                      \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ We use speculative runtime checks, and they should not fail, so no multiversioning.\n+    static void test_fill_B_sameArray_noalias(byte[] a, byte[] b, int invar1, int invar2, int limit) {\n+        for (int i = 0; i < limit; i++) {\n+            a[invar1 + i] = (byte)0x0a;\n+            b[invar2 - i] = (byte)0x0b;\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_B_sameArray_noalias(byte[] a, byte[] b, int invar1, int invar2, int limit) {\n+        for (int i = 0; i < limit; i++) {\n+            a[invar1 + i] = (byte)0x0a;\n+            b[invar2 - i] = (byte)0x0b;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasing.java","additions":516,"deletions":0,"binary":false,"changes":516,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=all-flags\n+ * @bug 8366490\n+ * @summary Test that we set the ctrl of CastP2X when generating\n+ *          the aliasing runtime check, preventing the CastP2X\n+ *          from floating over a SafePoint that could move the oop,\n+ *          and render the cast value stale.\n+ * @requires vm.gc == \"G1\" | vm.gc == \"null\"\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCastP2XCtrl::test\n+ *      -XX:CompileCommand=dontinline,*TestAliasingCastP2XCtrl::allocateArrays\n+ *      -XX:-TieredCompilation\n+ *      -Xbatch\n+ *      -XX:+UseG1GC\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM\n+ *      compiler.loopopts.superword.TestAliasingCastP2XCtrl\n+ *\/\n+\n+\/*\n+ * @test id=fewer-flags\n+ * @bug 8366490\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestAliasingCastP2XCtrl::test\n+ *      -XX:CompileCommand=dontinline,*TestAliasingCastP2XCtrl::allocateArrays\n+ *      -Xbatch\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM\n+ *      compiler.loopopts.superword.TestAliasingCastP2XCtrl\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8366490\n+ * @run main compiler.loopopts.superword.TestAliasingCastP2XCtrl\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestAliasingCastP2XCtrl {\n+    static final int N = 400;\n+    static boolean flag = false;\n+\n+    static void allocateArrays() {\n+        for (int i = 0; 200_000 > i; ++i) {\n+            int[] a = new int[N];\n+        }\n+        \/\/ Makes GC more likely.\n+        \/\/ Without it I could not reproduce it on slowdebug,\n+        \/\/ but only with fastdebug.\n+        if (flag) { System.gc(); }\n+        flag = !flag;\n+    }\n+\n+    static int[] test() {\n+        int a[] = new int[N];\n+        \/\/ We must make sure that no CastP2X happens before\n+        \/\/ the call below, otherwise we may have an old oop.\n+        allocateArrays();\n+        \/\/ The CastP2X for the aliasing runtime check should\n+        \/\/ only be emitted after the call, to ensure we only\n+        \/\/ deal with oops that are updated if there is a GC\n+        \/\/ that could move our allocated array.\n+\n+        \/\/ Not fully sure why we need the outer loop, but maybe\n+        \/\/ it is needed so that a part of the check is hoisted,\n+        \/\/ and the floats up, over the call if we do not set\n+        \/\/ the ctrl.\n+        for (int k = 0; k < 500; k++) {\n+            for (int i = 1; i < 69; i++) {\n+                \/\/ Aliasing references -> needs runtime check,\n+                \/\/ should always fail.\n+                a[i] =  14;\n+                a[4] -= 14;\n+                \/\/ The range computation for the constant access\n+                \/\/ produces a shape:\n+                \/\/   AddL(CastP2X(a), 0x20)\n+                \/\/ And this shape only depends on a, so it could\n+                \/\/ easily float above the call to allocateArrays\n+                \/\/ if we do not set a ctrl that prevents that.\n+            }\n+        }\n+        return a;\n+    }\n+\n+    public static void main(String[] args) {\n+        int[] gold = test();\n+        for (int r = 0; r < 20; r++) {\n+            int[] a = test();\n+            if (a[4] != gold[4]) {\n+                throw new RuntimeException(\"wrong value \" + gold[4] + \" \" + a[4]);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingCastP2XCtrl.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,1284 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.loopopts.superword.TestAliasingFuzzer vanilla\n+ *\/\n+\n+\/*\n+ * @test id=random-flags\n+ * @bug 8324751\n+ * @summary Test Speculative Aliasing checks in SuperWord\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @compile ..\/..\/..\/compiler\/lib\/ir_framework\/TestFramework.java\n+ * @compile ..\/..\/..\/compiler\/lib\/generators\/Generators.java\n+ * @compile ..\/..\/..\/compiler\/lib\/verify\/Verify.java\n+ * @run driver compiler.loopopts.superword.TestAliasingFuzzer random-flags\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.util.Set;\n+import java.util.List;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import jdk.test.lib.Utils;\n+\n+import compiler.lib.compile_framework.*;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import static compiler.lib.template_framework.Template.body;\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.$;\n+\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+\/**\n+ * Simpler test cases can be found in {@link TestAliasing}.\n+ *\n+ * We randomly generate tests to verify the behavior of the aliasing runtime checks. We feature:\n+ * - Different primitive types:\n+ *   - for access type (primitive, we can have multiple types in a single loop)\n+ *   - for backing type (primitive and additionally we have native memory)\n+ * - Different AccessScenarios:\n+ *   - copy (load and store)\n+ *   - fill (using two stores)\n+ * - Different Aliasing: in some cases we never alias at runtime, in other cases we might\n+ *   -> Should exercise both the predicate and the multiversioning approach with the\n+ *      aliasing runtime checks.\n+ * - Backing memory\n+ *   - Arrays: using int-index\n+ *   - MemorySegment (backed by primitive array or native memory):\n+ *     - Using long-index with MemorySegment::getAtIndex\n+ *     - Using byte-offset with MemorySegment::get\n+ * - Loop iv:\n+ *   - forward (counting up) and backward (counting down)\n+ *   - Different iv stride:\n+ *     - inc\/dec by one, and then scale with ivScale:   for (..; i++)  { access(i * 4); }\n+ *     - abs(ivScale) == 1, but use iv stride instead:  for (..; i+=4) { access(i); }\n+ *   - type of index, invars, and bounds (see isLongIvType)\n+ *     - int: for array and MemorySegment\n+ *     - long: for MemorySegment\n+ * - IR rules:\n+ *   - Verify that verification does (not) happen as expected.\n+ *   - Verify that we do not use multiversioning when no aliasing is expected at runtime.\n+ *     -> verify that the aliasing runtime check is not overly sensitive, so that the\n+ *        predicate does not fail unnecessarily and we have to recompile with multiversioning.\n+ *\n+ * Possible extensions (Future Work):\n+ * - Access with Unsafe\n+ * - Backing memory with Buffers\n+ * - AccessScenario:\n+ *   - More than two accesses\n+ * - Improve IR rules, once more cases vectorize (see e.g. JDK-8359688)\n+ * - Aliasing:\n+ *   - MemorySegment on same backing memory, creating different MemorySegments\n+ *     via slicing. Possibly overlapping MemorySegments.\n+ *   - CONTAINER_UNKNOWN_ALIASING_NEVER: currently always has different\n+ *     memory and split ranges. But we could alternate between same memory\n+ *     and split ranges, and then different memory but overlapping ranges.\n+ *     This would also be never aliasing.\n+ *\n+ *\/\n+public class TestAliasingFuzzer {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public record MyType(String name, int byteSize, String con1, String con2, String layout) {\n+        @Override\n+        public String toString() { return name(); }\n+\n+        public String letter() { return name().substring(0, 1).toUpperCase(); }\n+    }\n+    public static final String con1 = \"0x0102030405060708L\";\n+    public static final String con2 = \"0x0910111213141516L\";\n+    public static final String con1F = \"Float.intBitsToFloat(0x01020304)\";\n+    public static final String con2F = \"Float.intBitsToFloat(0x09101112)\";\n+    public static final String con1D = \"Double.longBitsToDouble(\" + con1 + \")\";\n+    public static final String con2D = \"Double.longBitsToDouble(\" + con2 + \")\";\n+\n+    \/\/ List of primitive types for accesses and arrays.\n+    public static final MyType myByte   = new MyType(\"byte\",   1, con1, con2,   \"ValueLayout.JAVA_BYTE\");\n+    public static final MyType myChar   = new MyType(\"char\",   2, con1, con2,   \"ValueLayout.JAVA_CHAR_UNALIGNED\");\n+    public static final MyType myShort  = new MyType(\"short\",  2, con1, con2,   \"ValueLayout.JAVA_SHORT_UNALIGNED\");\n+    public static final MyType myInt    = new MyType(\"int\",    4, con1, con2,   \"ValueLayout.JAVA_INT_UNALIGNED\");\n+    public static final MyType myLong   = new MyType(\"long\",   8, con1, con2,   \"ValueLayout.JAVA_LONG_UNALIGNED\");\n+    public static final MyType myFloat  = new MyType(\"float\",  4, con1F, con2F, \"ValueLayout.JAVA_FLOAT_UNALIGNED\");\n+    public static final MyType myDouble = new MyType(\"double\", 8, con1D, con2D, \"ValueLayout.JAVA_DOUBLE_UNALIGNED\");\n+    public static final List<MyType> primitiveTypes\n+        = List.of(myByte, myChar, myShort, myInt, myLong, myFloat, myDouble);\n+\n+    \/\/ For native memory, we use this \"fake\" type. It has a byteSize of 1, since we measure the memory in bytes.\n+    public static final MyType myNative = new MyType(\"native\", 1, null, null,   null);\n+    public static final List<MyType> primitiveTypesAndNative\n+        = List.of(myByte, myChar, myShort, myInt, myLong, myFloat, myDouble, myNative);\n+\n+    \/\/ Do the containers (array, MemorySegment, etc) ever overlap?\n+    enum Aliasing {\n+        CONTAINER_DIFFERENT,\n+        CONTAINER_SAME_ALIASING_NEVER,\n+        CONTAINER_SAME_ALIASING_UNKNOWN,\n+        CONTAINER_UNKNOWN_ALIASING_NEVER,\n+        CONTAINER_UNKNOWN_ALIASING_UNKNOWN,\n+    }\n+\n+    enum AccessScenario {\n+        COPY_LOAD_STORE,  \/\/ a[i1] = b[i2];\n+        FILL_STORE_STORE, \/\/ a[i1] = x; b[i2] = y;\n+    }\n+\n+    enum ContainerKind {\n+        ARRAY,\n+        MEMORY_SEGMENT_LONG_ADR_SCALE,  \/\/ for (..; i++)  { access(i * 4); }\n+        MEMORY_SEGMENT_LONG_ADR_STRIDE, \/\/ for (..; i+=4) { access(i); }\n+        MEMORY_SEGMENT_AT_INDEX,\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        long t0 = System.nanoTime();\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"compiler.loopopts.superword.templated.AliasingFuzzer\", generate(comp));\n+\n+        long t1 = System.nanoTime();\n+        \/\/ Compile the source file.\n+        comp.compile();\n+\n+        long t2 = System.nanoTime();\n+\n+        String[] flags = switch(args[0]) {\n+            case \"vanilla\" -> new String[] {};\n+            case \"random-flags\" -> randomFlags();\n+            default -> throw new RuntimeException(\"unknown run id=\" + args[0]);\n+        };\n+        \/\/ Run the tests without any additional VM flags.\n+        \/\/ compiler.loopopts.superword.templated.AliasingFuzzer.main(new String[] {});\n+        comp.invoke(\"compiler.loopopts.superword.templated.AliasingFuzzer\", \"main\", new Object[] {flags});\n+        long t3 = System.nanoTime();\n+\n+        System.out.println(\"Code Generation:  \" + (t1-t0) * 1e-9f);\n+        System.out.println(\"Code Compilation: \" + (t2-t1) * 1e-9f);\n+        System.out.println(\"Running Tests:    \" + (t3-t2) * 1e-9f);\n+    }\n+\n+    public static String[] randomFlags() {\n+        \/\/ We don't want to always run with all flags, that is too expensive.\n+        \/\/ But let's make sure things don't completely, rot by running with some\n+        \/\/ random flags that are relevant.\n+        \/\/ We set the odds towards the \"default\" we are targetting.\n+        return new String[] {\n+            \/\/ Default disabled.\n+            \"-XX:\" + randomPlusMinus(1, 5) + \"AlignVector\",\n+            \/\/ Default enabled.\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"UseAutoVectorizationSpeculativeAliasingChecks\",\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"UseAutoVectorizationPredicate\",\n+            \"-XX:\" + randomPlusMinus(5, 1) + \"ShortRunningLongLoop\",\n+            \/\/ Either way is ok.\n+            \"-XX:\" + randomPlusMinus(1, 1) + \"UseCompactObjectHeaders\",\n+            \"-XX:SuperWordAutomaticAlignment=\" + RANDOM.nextInt(0,3)\n+        };\n+    }\n+\n+    public static String randomPlusMinus(int plus, int minus) {\n+        return (RANDOM.nextInt(plus + minus) < plus) ? \"+\" : \"-\";\n+    }\n+\n+    public static <T> T sample(List<T> list) {\n+        int r = RANDOM.nextInt(list.size());\n+        return list.get(r);\n+    }\n+\n+    public static String generate(CompileFramework comp) {\n+        \/\/ Create a list to collect all tests.\n+        List<TemplateToken> testTemplateTokens = new ArrayList<>();\n+\n+        \/\/ Add some basic functionalities.\n+        testTemplateTokens.add(generateIndexForm());\n+\n+        \/\/ Array tests\n+        for (int i = 0; i < 10; i++) {\n+            testTemplateTokens.add(TestGenerator.makeArray().generate());\n+        }\n+\n+        \/\/ MemorySegment with getAtIndex \/ setAtIndex\n+        for (int i = 0; i < 20; i++) {\n+            testTemplateTokens.add(TestGenerator.makeMemorySegment().generate());\n+        }\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"compiler.loopopts.superword.templated\", \"AliasingFuzzer\",\n+            \/\/ List of imports.\n+            Set.of(\"compiler.lib.generators.*\",\n+                   \"compiler.lib.verify.*\",\n+                   \"java.lang.foreign.*\",\n+                   \"java.util.Random\",\n+                   \"jdk.test.lib.Utils\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+\n+    \/\/ The IndexForm is used to model the index. We can use it for arrays, but also by\n+    \/\/ restricting the MemorySegment index to a simple index.\n+    \/\/\n+    \/\/ Form:\n+    \/\/   index = con + iv * ivScale + invar0 * invar0Scale + invarRest\n+    \/\/                                                       [err]\n+    \/\/\n+    \/\/ The index has a size >= 1, so that the index refers to a region:\n+    \/\/   [index, index + size]\n+    \/\/\n+    \/\/ The idea is that invarRest is always close to zero, with some small range [-err .. err].\n+    \/\/ The invar variables for invarRest must be in the range [-1, 0, 1], so that we can\n+    \/\/ estimate the error range from the invarRestScales.\n+    \/\/\n+    \/\/ At runtime, we will have to generate inputs for the iv.lo\/iv.hi, as well as the invar0,\n+    \/\/ so that the index range lays in some predetermined range [range.lo, range.hi] and the\n+    \/\/ ivStride:\n+    \/\/\n+    \/\/ for (int iv = iv.lo; iv < iv.hi; iv += ivStride) {\n+    \/\/     assert: range.lo <= index(iv)\n+    \/\/                         index(iv) + size <= range.hi\n+    \/\/ }\n+    \/\/\n+    \/\/ Since there are multiple memory accesses, we may have multiple indices to compute.\n+    \/\/ Since they are all in the same loop, the indices share the same iv.lo and iv.hi. Hence,\n+    \/\/ we fix either iv.lo or iv.hi, and compute the other via the constraints.\n+    \/\/\n+    \/\/ Fix iv.lo, assume ivScale > 0:\n+    \/\/   index(iv) is smallest for iv = iv.lo, so we must satisfy\n+    \/\/     range.lo <= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest\n+    \/\/              <= con + iv.lo * ivScale + invar0 * invar0Scale - err\n+    \/\/   It follows:\n+    \/\/     invar0 * invar0Scale >= range.lo - con - iv.lo * ivScale + err\n+    \/\/   This allows us to pick a invar0.\n+    \/\/   Now, we can compute the largest iv.lo possible.\n+    \/\/   index(iv) is largest for iv = iv.hi, so we must satisfy:\n+    \/\/     range.hi >= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest + size\n+    \/\/              >= con + iv.hi * ivScale + invar0 * invar0Scale + err       + size\n+    \/\/   It follows:\n+    \/\/     iv.hi * ivScale <= range.hi - con - invar0 * invar0Scale - err - size\n+    \/\/   This allows us to pick a iv.hi.\n+    \/\/\n+    \/\/ More details can be found in the implementation below.\n+    \/\/\n+    public static record IndexForm(int con, int ivScale, int invar0Scale, int[] invarRestScales, int size) {\n+        public static IndexForm random(int numInvarRest, int size, int ivStrideAbs) {\n+            int con = RANDOM.nextInt(-100_000, 100_000);\n+            int ivScale = randomScale(size \/ ivStrideAbs);\n+            int invar0Scale = randomScale(size);\n+            int[] invarRestScales = new int[numInvarRest];\n+            \/\/ Sample values [-1, 0, 1]\n+            for (int i = 0; i < invarRestScales.length; i++) {\n+                invarRestScales[i] = RANDOM.nextInt(-1, 2);\n+            }\n+            return new IndexForm(con, ivScale, invar0Scale, invarRestScales, size);\n+        }\n+\n+        public static int randomScale(int size) {\n+            int scale = switch(RANDOM.nextInt(10)) {\n+                case 0 -> RANDOM.nextInt(1, 4 * size + 1); \/\/ any strided access\n+                default -> size; \/\/ in most cases, we do not want it to be strided\n+            };\n+            return RANDOM.nextBoolean() ? scale : -scale;\n+        }\n+\n+        public String generate() {\n+            return \"new IndexForm(\" + con() + \", \" + ivScale() + \", \" + invar0Scale() + \", new int[] {\" +\n+                   Arrays.stream(invarRestScales)\n+                         .mapToObj(String::valueOf)\n+                         .collect(Collectors.joining(\", \")) +\n+                   \"}, \" + size() + \")\";\n+        }\n+\n+        public TemplateToken index(String invar0, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"con\", con),\n+                let(\"ivScale\", ivScale),\n+                let(\"invar0Scale\", invar0Scale),\n+                let(\"invar0\", invar0),\n+                \"#con + #ivScale * i + #invar0Scale * #invar0\",\n+                IntStream.range(0, invarRestScales.length).mapToObj(\n+                    i -> List.of(\" + \", invarRestScales[i], \" * \", invarRest[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+\n+        \/\/ MemorySegment need to be long-addressed, otherwise there can be int-overflow\n+        \/\/ in the index, and that prevents RangeCheck Elimination and Vectorization.\n+        public TemplateToken indexLong(String invar0, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"con\", con),\n+                let(\"ivScale\", ivScale),\n+                let(\"invar0Scale\", invar0Scale),\n+                let(\"invar0\", invar0),\n+                \"#{con}L + #{ivScale}L * i + #{invar0Scale}L * #invar0\",\n+                IntStream.range(0, invarRestScales.length).mapToObj(\n+                    i -> List.of(\" + \", invarRestScales[i], \"L * \", invarRest[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+\n+    \/\/ Mirror the IndexForm from the generator to the test.\n+    public static TemplateToken generateIndexForm() {\n+        var template = Template.make(() -> body(\n+            \"\"\"\n+            private static final Random RANDOM = Utils.getRandomInstance();\n+\n+            public static record IndexForm(int con, int ivScale, int invar0Scale, int[] invarRestScales, int size) {\n+                public IndexForm {\n+                    if (ivScale == 0 || invar0Scale == 0) {\n+                        throw new RuntimeException(\"Bad scales: \" + ivScale + \" \" + invar0Scale);\n+                    }\n+                }\n+\n+                public static record Range(int lo, int hi) {\n+                    public Range {\n+                        if (lo >= hi) { throw new RuntimeException(\"Bad range: \" + lo + \" \" + hi); }\n+                    }\n+                }\n+\n+                public int err() {\n+                    int sum = 0;\n+                    for (int scale : invarRestScales) { sum += Math.abs(scale); }\n+                    return sum;\n+                }\n+\n+                public int invar0ForIvLo(Range range, int ivLo) {\n+                    if (ivScale > 0) {\n+                        \/\/ index(iv) is smallest for iv = ivLo, so we must satisfy:\n+                        \/\/   range.lo <= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest\n+                        \/\/            <= con + iv.lo * ivScale + invar0 * invar0Scale - err\n+                        \/\/ It follows:\n+                        \/\/   invar0 * invar0Scale >= range.lo - con - iv.lo * ivScale + err\n+                        int rhs = range.lo() - con - ivLo * ivScale + err();\n+                        int invar0 = (invar0Scale > 0)\n+                        ?\n+                            \/\/ invar0 * invar0Scale >=  range.lo - con - iv.lo * ivScale + err\n+                            \/\/ invar0               >= (range.lo - con - iv.lo * ivScale + err) \/ invar0Scale\n+                            Math.floorDiv(rhs + invar0Scale - 1, invar0Scale) \/\/ round up division\n+                        :\n+                            \/\/ invar0 * invar0Scale >=  range.lo - con - iv.lo * ivScale + err\n+                            \/\/ invar0               <= (range.lo - con - iv.lo * ivScale + err) \/ invar0Scale\n+                            Math.floorDiv(rhs, invar0Scale); \/\/ round down division\n+                        if (range.lo() > con + ivLo * ivScale + invar0 * invar0Scale - err()) {\n+                            throw new RuntimeException(\"sanity check failed (1)\");\n+                        }\n+                        return invar0;\n+                    } else {\n+                        \/\/ index(iv) is largest for iv = ivLo, so we must satisfy:\n+                        \/\/   range.hi >= con + iv.lo * ivScale + invar0 * invar0Scale + invarRest + size\n+                        \/\/            >= con + iv.lo * ivScale + invar0 * invar0Scale + err       + size\n+                        \/\/ It follows:\n+                        \/\/   invar0 * invar0Scale <= range.hi - con - iv.lo * ivScale - err - size\n+                        int rhs = range.hi() - con - ivLo * ivScale - err() - size();\n+                        int invar0 = (invar0Scale > 0)\n+                        ?\n+                            \/\/ invar0 * invar0Scale <= rhs\n+                            \/\/ invar0               <= rhs \/ invar0Scale\n+                            Math.floorDiv(rhs, invar0Scale) \/\/ round down division\n+                        :\n+                            \/\/ invar0 * invar0Scale <= rhs\n+                            \/\/ invar0               >= rhs \/ invar0Scale\n+                            Math.floorDiv(rhs + invar0Scale + 1, invar0Scale); \/\/ round up division\n+                        if (range.hi() < con + ivLo * ivScale + invar0 * invar0Scale + err() + size()) {\n+                            throw new RuntimeException(\"sanity check failed (2)\");\n+                        }\n+                        return invar0;\n+\n+                    }\n+                }\n+\n+                public int ivHiForInvar0(Range range, int invar0) {\n+                    if (ivScale > 0) {\n+                        \/\/ index(iv) is largest for iv = ivHi, so we must satisfy:\n+                        \/\/   range.hi >= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest + size\n+                        \/\/            >= con + iv.hi * ivScale + invar0 * invar0Scale + err       + size\n+                        \/\/ It follows:\n+                        \/\/   iv.hi * ivScale <=  range.hi - con - invar0 * invar0Scale - err - size\n+                        \/\/   iv.hi           <= (range.hi - con - invar0 * invar0Scale - err - size) \/ ivScale\n+                        int rhs = range.hi() - con - invar0 * invar0Scale - err() - size();\n+                        int ivHi = Math.floorDiv(rhs, ivScale); \/\/ round down division\n+                        if (range.hi() < con + ivHi * ivScale + invar0 * invar0Scale + err() + size()) {\n+                            throw new RuntimeException(\"sanity check failed (3)\");\n+                        }\n+                        return ivHi;\n+                    } else {\n+                        \/\/ index(iv) is smallest for iv = ivHi, so we must satisfy:\n+                        \/\/   range.lo <= con + iv.hi * ivScale + invar0 * invar0Scale + invarRest\n+                        \/\/            <= con + iv.hi * ivScale + invar0 * invar0Scale - err\n+                        \/\/ It follows:\n+                        \/\/   iv.hi * ivScale >=  range.lo - con - invar0 * invar0Scale + err\n+                        \/\/   iv.hi           <= (range.lo - con - invar0 * invar0Scale + err) \/ ivScale\n+                        int rhs = range.lo() - con - invar0 * invar0Scale + err();\n+                        int ivHi = Math.floorDiv(rhs, ivScale); \/\/ round down division\n+                        if (range.lo() > con + ivHi * ivScale + invar0 * invar0Scale - err()) {\n+                            throw new RuntimeException(\"sanity check failed (4)\");\n+                        }\n+                        return ivHi;\n+\n+                    }\n+                }\n+            }\n+            \"\"\"\n+        ));\n+        return template.asToken();\n+    }\n+\n+    public static record TestGenerator(\n+        \/\/ The containers.\n+        int numContainers,\n+        int containerByteSize,\n+        ContainerKind containerKind,\n+        MyType containerElementType,\n+\n+        \/\/ Do we count up or down, iterate over the containers forward or backward?\n+        boolean loopForward,\n+        int ivStrideAbs,\n+        boolean isLongIvType,\n+\n+        \/\/ For all index forms: number of invariants in the rest, i.e. the [err] term.\n+        int numInvarRest,\n+\n+        \/\/ Each access has an index form and a type.\n+        IndexForm[] accessIndexForm,\n+        MyType[] accessType,\n+\n+        \/\/ The scenario.\n+        Aliasing aliasing,\n+        AccessScenario accessScenario) {\n+\n+        public static TestGenerator makeArray() {\n+            \/\/ Sample some random parameters:\n+            Aliasing aliasing = sample(Arrays.asList(Aliasing.values()));\n+            AccessScenario accessScenario = sample(Arrays.asList(AccessScenario.values()));\n+            MyType type = sample(primitiveTypes);\n+\n+            \/\/ size must be large enough for:\n+            \/\/   - scale = 4\n+            \/\/   - range with size \/ 4\n+            \/\/ -> need at least size 16_000 to ensure we have 1000 iterations\n+            \/\/ We want there to be a little variation, so alignment is not always the same.\n+            int numElements = Generators.G.safeRestrict(Generators.G.ints(), 18_000, 20_000).next();\n+            int containerByteSize = numElements * type.byteSize();\n+            boolean loopForward = RANDOM.nextBoolean();\n+\n+            int numInvarRest = RANDOM.nextInt(5);\n+            int ivStrideAbs = 1;\n+            boolean isLongIvType = false; \/\/ int index\n+            var form0 = IndexForm.random(numInvarRest, 1, ivStrideAbs);\n+            var form1 = IndexForm.random(numInvarRest, 1, ivStrideAbs);\n+\n+            return new TestGenerator(\n+                2,\n+                containerByteSize,\n+                ContainerKind.ARRAY,\n+                type,\n+                loopForward,\n+                ivStrideAbs,\n+                isLongIvType,\n+                numInvarRest,\n+                new IndexForm[] {form0, form1},\n+                new MyType[]    {type,   type},\n+                aliasing,\n+                accessScenario);\n+        }\n+\n+        public static int alignUp(int value, int align) {\n+            return Math.ceilDiv(value, align) * align;\n+        }\n+\n+        public static TestGenerator makeMemorySegment() {\n+            \/\/ Sample some random parameters:\n+            Aliasing aliasing = sample(Arrays.asList(Aliasing.values()));\n+            AccessScenario accessScenario = sample(Arrays.asList(AccessScenario.values()));\n+            \/\/ Backing memory can be native, access must be primitive.\n+            MyType containerElementType = sample(primitiveTypesAndNative);\n+            MyType accessType0 = sample(primitiveTypes);\n+            MyType accessType1 = sample(primitiveTypes);\n+            ContainerKind containerKind = sample(List.of(\n+                ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE\n+            ));\n+\n+            if (containerKind == ContainerKind.MEMORY_SEGMENT_AT_INDEX) {\n+                \/\/ The access types must be the same, it is a limitation of the index computation.\n+                accessType1 = accessType0;\n+            }\n+\n+            final int minAccessSize = Math.min(accessType0.byteSize(), accessType1.byteSize());\n+            final int maxAccessSize = Math.max(accessType0.byteSize(), accessType1.byteSize());\n+\n+            \/\/ size must be large enough for:\n+            \/\/   - scale = 4\n+            \/\/   - range with size \/ 4\n+            \/\/ -> need at least size 16_000 to ensure we have 1000 iterations\n+            \/\/ We want there to be a little variation, so alignment is not always the same.\n+            final int numAccessElements = Generators.G.safeRestrict(Generators.G.ints(), 18_000, 20_000).next();\n+            final int align = Math.max(maxAccessSize, containerElementType.byteSize());\n+            \/\/ We need to align up, so the size is divisible exactly by all involved type sizes.\n+            final int containerByteSize = alignUp(numAccessElements * maxAccessSize, align);\n+            final boolean loopForward = RANDOM.nextBoolean();\n+\n+            final int numInvarRest = RANDOM.nextInt(5);\n+            int indexSize0 = accessType0.byteSize();\n+            int indexSize1 = accessType1.byteSize();\n+            if (containerKind == ContainerKind.MEMORY_SEGMENT_AT_INDEX) {\n+                \/\/ These are int-indeces for getAtIndex, so we index by element and not bytes.\n+                indexSize0 = 1;\n+                indexSize1 = 1;\n+            }\n+\n+            boolean withAbsOneIvScale = containerKind == ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE;\n+            int ivStrideAbs = containerKind == ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ? minAccessSize : 1;\n+            boolean isLongIvType = RANDOM.nextBoolean();\n+            var form0 = IndexForm.random(numInvarRest, indexSize0, ivStrideAbs);\n+            var form1 = IndexForm.random(numInvarRest, indexSize1, ivStrideAbs);\n+\n+            return new TestGenerator(\n+                2,\n+                containerByteSize,\n+                containerKind,\n+                containerElementType,\n+                loopForward,\n+                ivStrideAbs,\n+                isLongIvType,\n+                numInvarRest,\n+                new IndexForm[] {form0, form1},\n+                new MyType[]    {accessType0, accessType1},\n+                aliasing,\n+                accessScenario);\n+        }\n+\n+        public TemplateToken generate() {\n+            var testTemplate = Template.make(() -> {\n+                \/\/ Let's generate the variable names that are to be shared for the nested Templates.\n+                String[] invarRest = new String[numInvarRest];\n+                for (int i = 0; i < invarRest.length; i++) {\n+                    invarRest[i] = $(\"invar\" + i);\n+                }\n+                String[] containerNames = new String[numContainers];\n+                for (int i = 0; i < numContainers; i++) {\n+                    containerNames[i] = $(\"container\" + i);\n+                }\n+                String[] indexFormNames = new String[accessIndexForm.length];\n+                for (int i = 0; i < indexFormNames.length; i++) {\n+                    indexFormNames[i] = $(\"index\" + i);\n+                }\n+                return body(\n+                    \"\"\"\n+                    \/\/ --- $test start ---\n+                    \"\"\",\n+                    generateTestFields(invarRest, containerNames, indexFormNames),\n+                    \"\"\"\n+                    \/\/ Count the run invocations.\n+                    private static int $iterations = 0;\n+\n+                    @Run(test = \"$test\")\n+                    @Warmup(100)\n+                    public static void $run(RunInfo info) {\n+\n+                        \/\/ Once warmup is over (100x), repeat 10x to get reasonable coverage of the\n+                        \/\/ randomness in the tests.\n+                        int reps = info.isWarmUp() ? 10 : 1;\n+                        for (int r = 0; r < reps; r++) {\n+\n+                            $iterations++;\n+                    \"\"\",\n+                    generateContainerInit(containerNames),\n+                    generateContainerAliasing(containerNames, $(\"iterations\")),\n+                    generateRanges(),\n+                    generateBoundsAndInvariants(indexFormNames, invarRest),\n+                    \"\"\"\n+                            \/\/ Run test and compare with interpreter results.\n+                    \"\"\",\n+                    generateCallMethod(\"result\", $(\"test\"), \"test\"),\n+                    generateCallMethod(\"expected\", $(\"reference\"), \"reference\"),\n+                    \"\"\"\n+                            Verify.checkEQ(result, expected);\n+                        } \/\/ end reps\n+                    } \/\/ end $run\n+\n+                    @Test\n+                    \"\"\",\n+                    generateIRRules(),\n+                    generateTestMethod($(\"test\"), invarRest),\n+                    \"\"\"\n+                    @DontCompile\n+                    \"\"\",\n+                    generateTestMethod($(\"reference\"), invarRest),\n+                    \"\"\"\n+\n+                    \/\/ --- $test end ---\n+                    \"\"\"\n+                );\n+            });\n+            return testTemplate.asToken();\n+        }\n+\n+        private TemplateToken generateArrayField(String name, MyType type) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ type.byteSize()),\n+                let(\"name\", name),\n+                let(\"type\", type),\n+                \"\"\"\n+                private static #type[] original_#name  = new #type[#size];\n+                private static #type[] test_#name      = new #type[#size];\n+                private static #type[] reference_#name = new #type[#size];\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateMemorySegmentField(String name, MyType type) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ type.byteSize()),\n+                let(\"byteSize\", containerByteSize),\n+                let(\"name\", name),\n+                let(\"type\", type),\n+                (type == myNative\n+                 ?  \"\"\"\n+                    private static MemorySegment original_#name  = Arena.ofAuto().allocate(#byteSize);\n+                    private static MemorySegment test_#name      = Arena.ofAuto().allocate(#byteSize);\n+                    private static MemorySegment reference_#name = Arena.ofAuto().allocate(#byteSize);\n+                    \"\"\"\n+                 :  \"\"\"\n+                    private static MemorySegment original_#name  = MemorySegment.ofArray(new #type[#size]);\n+                    private static MemorySegment test_#name      = MemorySegment.ofArray(new #type[#size]);\n+                    private static MemorySegment reference_#name = MemorySegment.ofArray(new #type[#size]);\n+                    \"\"\"\n+                )\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIndexField(String name, IndexForm form) {\n+            var template = Template.make(() -> body(\n+                let(\"name\", name),\n+                let(\"form\", form.generate()),\n+                \"\"\"\n+                private static IndexForm #name = #form;\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestFields(String[] invarRest, String[] containerNames, String[] indexFormNames) {\n+            var template = Template.make(() -> body(\n+                let(\"ivType\", isLongIvType ? \"long\" : \"int\"),\n+                \"\"\"\n+                \/\/ invarRest fields:\n+                \"\"\",\n+                Arrays.stream(invarRest).map(invar ->\n+                    List.of(\"private static #ivType \", invar, \" = 0;\\n\")\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Containers fields:\n+                \"\"\",\n+                Arrays.stream(containerNames).map(name ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            generateArrayField(name, containerElementType);\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            generateMemorySegmentField(name, containerElementType);\n+                    }\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Index forms for the accesses:\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    generateIndexField(indexFormNames[i], accessIndexForm[i])\n+                ).toList()\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInitArray(String name) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ containerElementType.byteSize()),\n+                let(\"name\", name),\n+                \"\"\"\n+                System.arraycopy(original_#name, 0, test_#name, 0, #size);\n+                System.arraycopy(original_#name, 0, reference_#name, 0, #size);\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInitMemorySegment(String name) {\n+            var template = Template.make(() -> body(\n+                let(\"size\", containerByteSize \/ containerElementType.byteSize()),\n+                let(\"name\", name),\n+                \"\"\"\n+                test_#name.copyFrom(original_#name);\n+                reference_#name.copyFrom(original_#name);\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerInit(String[] containerNames) {\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Init containers from original data:\n+                \"\"\",\n+                Arrays.stream(containerNames).map(name ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            generateContainerInitArray(name);\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            generateContainerInitMemorySegment(name);\n+                    }\n+                ).toList()\n+             ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerAliasingAssignment(int i, String name1, String name2, String iterations) {\n+            var template = Template.make(() -> body(\n+                let(\"i\", i),\n+                let(\"name1\", name1),\n+                let(\"name2\", name2),\n+                let(\"iterations\", iterations),\n+                \"\"\"\n+                var test_#i      = (#iterations % 2 == 0) ? test_#name1      : test_#name2;\n+                var reference_#i = (#iterations % 2 == 0) ? reference_#name1 : reference_#name2;\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateContainerAliasing(String[] containerNames, String iterations) {\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Container aliasing:\n+                \"\"\",\n+                IntStream.range(0, containerNames.length).mapToObj(i ->\n+                    switch(aliasing) {\n+                        case Aliasing.CONTAINER_DIFFERENT ->\n+                            generateContainerAliasingAssignment(i, containerNames[i], containerNames[i], iterations);\n+                        case Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                             Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN ->\n+                            generateContainerAliasingAssignment(i, containerNames[0], containerNames[0], iterations);\n+                        case Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER,\n+                             Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                            generateContainerAliasingAssignment(i, containerNames[i], containerNames[0], iterations);\n+                    }\n+                ).toList()\n+             ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateRanges() {\n+            int size = switch (containerKind) {\n+                case ContainerKind.ARRAY,\n+                     ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                    \/\/ Access with element index\n+                    containerByteSize \/ accessType[0].byteSize();\n+                case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                     ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                    \/\/ Access with byte offset\n+                    containerByteSize;\n+            };\n+\n+            if (accessIndexForm.length != 2) { throw new RuntimeException(\"not yet implemented\"); }\n+\n+            var templateSplitRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                int middle = RANDOM.nextInt(#size \/ 3, #size * 2 \/ 3);\n+                int rnd = Math.min(256, #size \/ 10);\n+                int range = #size \/ 3 - RANDOM.nextInt(rnd);\n+                \"\"\",\n+                (RANDOM.nextBoolean()\n+                 \/\/ Maximal range\n+                 ?  \"\"\"\n+                    var r0 = new IndexForm.Range(0, middle);\n+                    var r1 = new IndexForm.Range(middle, #size);\n+                    \"\"\"\n+                 \/\/ Same size range\n+                 \/\/ If the accesses run towards each other, and the runtime\n+                 \/\/ check is too relaxed, we may fail the checks even though\n+                 \/\/ there is no overlap. Having same size ranges makes this\n+                 \/\/ more likely, and we could detect it if we get multiversioning\n+                 \/\/ unexpectedly.\n+                 :  \"\"\"\n+                    var r0 = new IndexForm.Range(middle - range, middle);\n+                    var r1 = new IndexForm.Range(middle, middle + range);\n+                    \"\"\"\n+                ),\n+                \"\"\"\n+                if (RANDOM.nextBoolean()) {\n+                    var tmp = r0;\n+                    r0 = r1;\n+                    r1 = tmp;\n+                }\n+                \"\"\"\n+            ));\n+\n+            var templateWholeRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                var r0 = new IndexForm.Range(0, #size);\n+                var r1 = new IndexForm.Range(0, #size);\n+                \"\"\"\n+            ));\n+\n+            var templateRandomRanges = Template.make(() -> body(\n+                let(\"size\", size),\n+                \"\"\"\n+                int lo0 = RANDOM.nextInt(0, #size * 3 \/ 4);\n+                int lo1 = RANDOM.nextInt(0, #size * 3 \/ 4);\n+                var r0 = new IndexForm.Range(lo0, lo0 + #size \/ 4);\n+                var r1 = new IndexForm.Range(lo1, lo1 + #size \/ 4);\n+                \"\"\"\n+            ));\n+\n+            var templateSmallOverlapRanges = Template.make(() -> body(\n+                \/\/ Idea: same size ranges, with size \"range\". A small overlap,\n+                \/\/       so that bad runtime checks would create wrong results.\n+                let(\"size\", size),\n+                \"\"\"\n+                int rnd = Math.min(256, #size \/ 10);\n+                int middle = #size \/ 2 + RANDOM.nextInt(-rnd, rnd);\n+                int range = #size \/ 3 - RANDOM.nextInt(rnd);\n+                int overlap = RANDOM.nextInt(-rnd, rnd);\n+                var r0 = new IndexForm.Range(middle - range + overlap, middle + overlap);\n+                var r1 = new IndexForm.Range(middle, middle + range);\n+                if (RANDOM.nextBoolean()) {\n+                    var tmp = r0;\n+                    r0 = r1;\n+                    r1 = tmp;\n+                }\n+                \"\"\"\n+                \/\/ Can this go out of bounds? Assume worst case on lower end:\n+                \/\/   middle         - range          + overlap\n+                \/\/   (size\/2 - rnd) - (size\/3 - rnd) - rnd\n+                \/\/   size\/6 - rnd\n+                \/\/ -> safe with rnd = size\/10\n+            ));\n+\n+            var templateAnyRanges = Template.make(() -> body(\n+                switch(RANDOM.nextInt(4)) {\n+                    case 0 -> templateSplitRanges.asToken();\n+                    case 1 -> templateWholeRanges.asToken();\n+                    case 2 -> templateRandomRanges.asToken();\n+                    case 3 -> templateSmallOverlapRanges.asToken();\n+                    default -> throw new RuntimeException(\"impossible\");\n+                }\n+            ));\n+\n+            var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Generate ranges:\n+                \"\"\",\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_DIFFERENT ->\n+                        templateAnyRanges.asToken();\n+                    case Aliasing.CONTAINER_SAME_ALIASING_NEVER ->\n+                        templateSplitRanges.asToken();\n+                    case Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN ->\n+                        templateAnyRanges.asToken();\n+                    case Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER ->\n+                        templateSplitRanges.asToken();\n+                    case Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                        templateAnyRanges.asToken();\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateBoundsAndInvariants(String[] indexFormNames, String[] invarRest) {\n+            \/\/ We want there to be at least 1000 iterations.\n+            final int minIvRange = ivStrideAbs * 1000;\n+\n+            var template = Template.make(() -> body(\n+                let(\"containerByteSize\", containerByteSize),\n+                \"\"\"\n+                \/\/ Compute loop bounds and loop invariants.\n+                int ivLo = RANDOM.nextInt(-1000, 1000);\n+                int ivHi = ivLo + #containerByteSize;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    Template.make(() -> body(\n+                        let(\"i\", i),\n+                        let(\"form\", indexFormNames[i]),\n+                        \"\"\"\n+                        int invar0_#i = #form.invar0ForIvLo(r#i, ivLo);\n+                        ivHi = Math.min(ivHi, #form.ivHiForInvar0(r#i, invar0_#i));\n+                        \"\"\"\n+                    )).asToken()\n+                ).toList(),\n+                let(\"minIvRange\", minIvRange),\n+                \"\"\"\n+                \/\/ Let's check that the range is large enough, so that the vectorized\n+                \/\/ main loop can even be entered.\n+                if (ivLo + #minIvRange > ivHi) { throw new RuntimeException(\"iv range too small: \" + ivLo + \" \" + ivHi); }\n+                \"\"\",\n+                Arrays.stream(invarRest).map(invar ->\n+                    List.of(invar, \" = RANDOM.nextInt(-1, 2);\\n\")\n+                ).toList(),\n+                \"\"\"\n+                \/\/ Verify the bounds we just created, just to be sure there is no unexpected aliasing!\n+                int i = ivLo;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    List.of(\"int lo_\", i, \" = (int)(\", accessIndexForm[i].index(\"invar0_\" + i, invarRest), \");\\n\")\n+                ).toList(),\n+                \"\"\"\n+                i = ivHi;\n+                \"\"\",\n+                IntStream.range(0, indexFormNames.length).mapToObj(i ->\n+                    List.of(\"int hi_\", i, \" =  (int)(\", accessIndexForm[i].index(\"invar0_\" + i, invarRest), \");\\n\")\n+                ).toList(),\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER -> \/\/ could fail in the future if we make it smarter\n+                        List.of(\n+                        \"\"\"\n+                        \/\/ Bounds should not overlap.\n+                        if (false\n+                        \"\"\",\n+                        IntStream.range(0, indexFormNames.length).mapToObj(i1 ->\n+                            IntStream.range(0, i1).mapToObj(i2 ->\n+                                Template.make(() -> body(\n+                                    let(\"i1\", i1),\n+                                    let(\"i2\", i2),\n+                                    \/\/ i1 < i2 or i1 > i2\n+                                    \"\"\"\n+                                    || (lo_#i1 < lo_#i2 && lo_#i1 < hi_#i2 && hi_#i1 < lo_#i2 && hi_#i1 < hi_#i2)\n+                                    || (lo_#i1 > lo_#i2 && lo_#i1 > hi_#i2 && hi_#i1 > lo_#i2 && hi_#i1 > hi_#i2)\n+                                    \"\"\"\n+                                )).asToken()\n+                            ).toList()\n+                        ).toList(),\n+                        \"\"\"\n+                        ) {\n+                            \/\/ pass\n+                        } else {\n+                            throw new RuntimeException(\"bounds overlap!\");\n+                        }\n+                        \"\"\");\n+                    case Aliasing.CONTAINER_DIFFERENT,\n+                         Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                        \"\"\"\n+                        \/\/ Aliasing unknown, cannot verify bounds.\n+                        \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+\n+        private TemplateToken generateCallMethod(String output, String methodName, String containerPrefix) {\n+            var template = Template.make(() -> body(\n+                let(\"output\", output),\n+                let(\"methodName\", methodName),\n+                \"var #output = #methodName(\",\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    List.of(containerPrefix, \"_\", i, \", invar0_\", i, \", \")\n+                ).toList(),\n+                \"ivLo, ivHi);\\n\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRules() {\n+            var template = Template.make(() -> body(\n+                switch (containerKind) {\n+                    case ContainerKind.ARRAY ->\n+                        generateIRRulesArray();\n+                    case ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                        generateIRRulesMemorySegmentAtIndex();\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE ->\n+                        generateIRRulesMemorySegmentLongAdrScale();\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                        generateIRRulesMemorySegmentLongAdrStride();\n+                },\n+                \/\/ In same scnearios, we know that a aliasing runtime check will never fail.\n+                \/\/ That means if we have UseAutoVectorizationPredicate enabled, that predicate\n+                \/\/ will never fail, and we will not have to do multiversioning.\n+                switch(aliasing) {\n+                    case Aliasing.CONTAINER_DIFFERENT,\n+                         Aliasing.CONTAINER_SAME_ALIASING_NEVER,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_NEVER ->\n+                        \/\/ We would have liked to check that there is no multiversioning.\n+                        \/\/\n+                        \/\/ But sadly there are some cases that have issues with RCE and\/or\n+                        \/\/ predicates, and so we end up using multiversioning anyway. We\n+                        \/\/ should fix those cases eventually, to strengthen the checks here.\n+                        \/\/\n+                        \/\/ The array cases are a little more tame, and do not have the same\n+                        \/\/ issues as the MemorySegment cases.\n+                        (containerKind == ContainerKind.ARRAY)\n+                        ? \"\"\"\n+                          \/\/ Aliasing check should never fail at runtime, so the predicate\n+                          \/\/ should never fail, and we do not have to use multiversioning.\n+                          \/\/ Failure could have a few causes:\n+                          \/\/ - issues with doing RCE \/ missing predicates\n+                          \/\/   -> other loop-opts need to be fixed\n+                          \/\/ - predicate fails: recompile with multiversioning\n+                          \/\/   -> logic in runtime check may be wrong\n+                          @IR(counts = {\".*multiversion.*\", \"= 0\"},\n+                              phase = CompilePhase.PRINT_IDEAL,\n+                              applyIf = {\"UseAutoVectorizationPredicate\", \"true\"},\n+                              applyIfPlatform = {\"64-bit\", \"true\"},\n+                              applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                          \"\"\"\n+                        : \"\"\"\n+                          \/\/ Due to cases like JDK-8360204 and JDK-8365982, there can be issues\n+                          \/\/ with RCE leading cases where we remove predicates and then unroll again\n+                          \/\/ and then end up multiversioning. These cases seem relatively rare but\n+                          \/\/ prevent us from asserting that there is never multiversioning in these cases.\n+                          \"\"\";\n+                   case Aliasing.CONTAINER_SAME_ALIASING_UNKNOWN,\n+                         Aliasing.CONTAINER_UNKNOWN_ALIASING_UNKNOWN ->\n+                            \"\"\"\n+                            \/\/ Aliasing unknown, we may use the predicate or multiversioning.\n+                            \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        \/\/ Regular array-accesses are vectorized quite predictably, and we can create nice\n+        \/\/ IR rules - even for cases where we do not expect vectorization.\n+        private TemplateToken generateIRRulesArray() {\n+            var template = Template.make(() -> body(\n+                let(\"T\", containerElementType.letter()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ Currently, we do not allow strided access or shuffle.\n+                        \/\/ Since the load and store are connected, we either vectorize both or none.\n+                        (accessIndexForm[0].ivScale() == accessIndexForm[1].ivScale() &&\n+                         Math.abs(accessIndexForm[0].ivScale()) == 1)\n+                        ?   \"\"\"\n+                            \/\/ Good ivScales, vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"> 0\",\n+                                          IRNode.STORE_VECTOR,   \"> 0\"},\n+                                applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                                              \"AlignVector\", \"false\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\"\n+                        :   \"\"\"\n+                            \/\/ Bad ivScales, no vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"= 0\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\";\n+                    case FILL_STORE_STORE ->\n+                        \/\/ Currently, we do not allow strided access.\n+                        \/\/ We vectorize any contiguous pattern. Possibly only one is vectorized.\n+                        (Math.abs(accessIndexForm[0].ivScale()) == 1 ||\n+                         Math.abs(accessIndexForm[1].ivScale()) == 1)\n+                        ?   \"\"\"\n+                            \/\/ Good ivScales, vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"> 0\"},\n+                                applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\",\n+                                              \"AlignVector\", \"false\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\"\n+                        :   \"\"\"\n+                            \/\/ Bad ivScales, no vectorization expected.\n+                            @IR(counts = {IRNode.LOAD_VECTOR_#T, \"= 0\",\n+                                          IRNode.STORE_VECTOR,   \"= 0\"},\n+                                applyIfPlatform = {\"64-bit\", \"true\"},\n+                                applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+                            \"\"\";\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentAtIndex() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+                \/\/ JDK-8359688: it seems we only vectorize with ivScale=1, and not ivScale=-1\n+                \/\/              The issue seems to be RangeCheck elimination\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentLongAdrStride() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateIRRulesMemorySegmentLongAdrScale() {\n+           var template = Template.make(() -> body(\n+                \"\"\"\n+                \/\/ Unfortunately, there are some issues that prevent RangeCheck elimination.\n+                \/\/ The cases are currently quite unpredictable, so we cannot create any IR\n+                \/\/ rules - sometimes there are vectors sometimes not.\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestMethod(String methodName, String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"methodName\", methodName),\n+                let(\"containerElementType\", containerElementType),\n+                let(\"ivStrideAbs\", ivStrideAbs),\n+                let(\"ivType\", isLongIvType ? \"long\" : \"int\"),\n+                \/\/ Method head \/ signature.\n+                \"public static Object #methodName(\",\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    switch (containerKind) {\n+                        case ContainerKind.ARRAY ->\n+                            List.of(\"#containerElementType[] container_\", i, \", #ivType invar0_\", i, \", \");\n+                        case ContainerKind.MEMORY_SEGMENT_AT_INDEX,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                             ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                            List.of(\"MemorySegment container_\", i, \", #ivType invar0_\", i, \", \");\n+                    }\n+                ).toList(),\n+                \"#ivType ivLo, #ivType ivHi) {\\n\",\n+                \/\/ Method loop body.\n+                (loopForward\n+                 ?  \"for (#ivType i = ivLo; i < ivHi; i+=#ivStrideAbs) {\\n\"\n+                 :  \"for (#ivType i = ivHi-#ivStrideAbs; i >= ivLo; i-=#ivStrideAbs) {\\n\"),\n+                \/\/ Loop iteration.\n+                switch (containerKind) {\n+                    case ContainerKind.ARRAY ->\n+                        generateTestLoopIterationArray(invarRest);\n+                    case ContainerKind.MEMORY_SEGMENT_AT_INDEX ->\n+                        generateTestLoopIterationMemorySegmentAtIndex(invarRest);\n+                    case ContainerKind.MEMORY_SEGMENT_LONG_ADR_SCALE,\n+                         ContainerKind.MEMORY_SEGMENT_LONG_ADR_STRIDE ->\n+                        generateTestLoopIterationMemorySegmentLongAdr(invarRest);\n+                },\n+                \"\"\"\n+                    }\n+                    return new Object[] {\n+                \"\"\",\n+                \/\/ Return a list of all containers that are involved in the test.\n+                \/\/ The caller can then compare the results of the test and reference method.\n+                IntStream.range(0, numContainers).mapToObj(i ->\n+                    \"container_\" + i\n+                ).collect(Collectors.joining(\", \")), \"\\n\",\n+                \"\"\"\n+                    };\n+                }\n+                \"\"\"\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationArray(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type\", containerElementType),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        List.of(\"container_0[\", accessIndexForm[0].index(\"invar0_0\", invarRest), \"] = \",\n+                                \"container_1[\", accessIndexForm[1].index(\"invar0_1\", invarRest), \"];\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0[\", accessIndexForm[0].index(\"invar0_0\", invarRest), \"] = (#type)0x0102030405060708L;\\n\",\n+                                \"container_1[\", accessIndexForm[1].index(\"invar0_1\", invarRest), \"] = (#type)0x1112131415161718L;\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationMemorySegmentAtIndex(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type0\", accessType[0]),\n+                let(\"type1\", accessType[1]),\n+                let(\"type0Layout\", accessType[0].layout()),\n+                let(\"type1Layout\", accessType[1].layout()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ Conversion not implemented, index bound computation is too limited for this currently.\n+                        List.of(\"var v = \",\n+                                \"container_0.getAtIndex(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \");\\n\",\n+                                \"container_1.setAtIndex(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", v);\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0.setAtIndex(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \", (#type0)0x0102030405060708L);\\n\",\n+                                \"container_1.setAtIndex(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", (#type1)0x1112131415161718L);\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+\n+        private TemplateToken generateTestLoopIterationMemorySegmentLongAdr(String[] invarRest) {\n+            var template = Template.make(() -> body(\n+                let(\"type0\", accessType[0]),\n+                let(\"type1\", accessType[1]),\n+                let(\"type0Layout\", accessType[0].layout()),\n+                let(\"type1Layout\", accessType[1].layout()),\n+                switch (accessScenario) {\n+                    case COPY_LOAD_STORE ->\n+                        \/\/ We allow conversions here.\n+                        List.of(\"#type1 v = (#type1)\",\n+                                \"container_0.get(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \");\\n\",\n+                                \"container_1.set(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", v);\\n\");\n+                    case FILL_STORE_STORE ->\n+                        List.of(\"container_0.set(#type0Layout, \", accessIndexForm[0].indexLong(\"invar0_0\", invarRest), \", (#type0)0x0102030405060708L);\\n\",\n+                                \"container_1.set(#type1Layout, \", accessIndexForm[1].indexLong(\"invar0_1\", invarRest), \", (#type1)0x1112131415161718L);\\n\");\n+                }\n+            ));\n+            return template.asToken();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":1284,"deletions":0,"binary":false,"changes":1284,"status":"added"},{"patch":"@@ -398,1 +398,1 @@\n-    \/\/ Would be nice to vectorize: Missing support for CmpF, CMove and MoveF2I.\n+    \/\/ Would be nice to vectorize: Missing support for CmpF and CMove.\n@@ -407,1 +407,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -410,1 +412,0 @@\n-    \/\/ Missing support for MoveF2I\n@@ -419,1 +420,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -422,1 +425,0 @@\n-    \/\/ Missing support for MoveI2F\n@@ -434,1 +436,1 @@\n-    \/\/ Missing support for Needs CmpD, CMove and MoveD2L\n+    \/\/ Missing support to vectorize CmpD and CMove\n@@ -443,1 +445,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, IRNode.VECTOR_SIZE + \"min(max_long, max_double)\", \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -446,1 +450,0 @@\n-    \/\/ Missing support for MoveD2L\n@@ -455,1 +458,3 @@\n-    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.VECTOR_REINTERPRET, \"> 0\"},\n@@ -458,1 +463,0 @@\n-    \/\/ Missing support for MoveL2D\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCompatibleUseDefTypeSize.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.List;\n@@ -39,1 +40,0 @@\n-    static final int ITER  = 100;\n@@ -76,6 +76,22 @@\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-AlignVector\", \"-XX:-VerifyAlignVector\");\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:-VerifyAlignVector\");\n-        TestFramework.runWithFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n-                                   \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+AlignVector\", \"-XX:+VerifyAlignVector\");\n+        \/\/ Cross-product:\n+        \/\/ - AlignVector (+VerifyAlignVector)\n+        \/\/ - UseAutoVectorizationSpeculativeAliasingChecks\n+        List<String[]> avList = List.of(\n+            new String[] {\"-XX:-AlignVector\", \"-XX:-VerifyAlignVector\"},\n+            new String[] {\"-XX:+AlignVector\", \"-XX:-VerifyAlignVector\"},\n+            new String[] {\"-XX:+AlignVector\", \"-XX:+VerifyAlignVector\"}\n+        );\n+        List<String[]> sacList = List.of(\n+            new String[] {\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"},\n+            new String[] {\"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"}\n+        );\n+        for (String[] av : avList) {\n+            for (String[] sac : sacList) {\n+                TestFramework framework = new TestFramework();\n+                framework.addFlags(\"-XX:CompileCommand=compileonly,TestCyclicDependency::test*\",\n+                                   \"-XX:+IgnoreUnrecognizedVMOptions\");\n+                framework.addFlags(av);\n+                framework.addFlags(sac);\n+                framework.start();\n+            }\n+        }\n@@ -137,1 +153,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -148,1 +164,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -159,1 +175,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -170,1 +186,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -181,1 +197,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -192,1 +208,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -203,1 +219,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -214,1 +230,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -225,1 +241,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -236,1 +252,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -247,1 +263,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -260,1 +276,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -271,1 +287,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -282,1 +298,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -295,1 +311,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -306,1 +322,1 @@\n-    @Warmup(100)\n+    @Warmup(1000)\n@@ -433,2 +449,4 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -437,1 +455,9 @@\n-                  IRNode.ADD_VF, \"= 0\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, \"= 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -448,4 +474,8 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always different.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two float-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/ Note: at runtime the float-arrays are always different -> predicate suffices, no multiversioning.\n@@ -459,2 +489,11 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -464,0 +503,1 @@\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -474,4 +514,9 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always the same.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two float-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/       multiversion_slow loop can still vectorize, but only with 2 elements.\n+            \/\/ Note: at runtime the float-arrays are always the same -> predicate fails -> multiversioning.\n@@ -511,2 +556,10 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -515,1 +568,3 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -523,4 +578,8 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always different.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two int-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataI and dataI_2 do not alias -> full vectorization.\n+            \/\/ Note: at runtime the int-arrays are always different -> predicate suffices, no multiversioning.\n@@ -537,2 +596,11 @@\n-                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \"=0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"2\", \"> 0\",\n+                  IRNode.ADD_VF, IRNode.VECTOR_SIZE + \"min(max_int, max_float)\", \"> 0\",\n+                  \".*multiversion.*\", \">0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n@@ -542,0 +610,1 @@\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -549,4 +618,9 @@\n-            \/\/   AlignVector=false -> vectorizes because we cannot prove store-to-load forwarding\n-            \/\/                        failure. But we can only have 2-element vectors in case\n-            \/\/                        the two float-arrays reference the same array.\n-            \/\/                        Note: at runtime the float-arrays are always the same.\n+            \/\/   AlignVector=false\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=false\n+            \/\/       vectorizes because we cannot prove store-to-load forwarding\n+            \/\/       failure. But we can only have 2-element vectors in case\n+            \/\/       the two int-arrays reference the same array.\n+            \/\/     UseAutoVectorizationSpeculativeAliasingChecks=true\n+            \/\/       Speculate that dataF and dataF_2 do not alias -> full vectorization.\n+            \/\/       multiversion_slow loop can still vectorize, but only with 2 elements.\n+            \/\/ Note: at runtime the int-arrays are always the same -> predicate fails -> multiversioning.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCyclicDependency.java","additions":123,"deletions":49,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vanilla-A\n@@ -39,1 +39,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vanilla-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vanilla-U\n@@ -51,1 +51,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v016-A\n@@ -63,1 +63,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v016-U\n@@ -75,1 +75,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v008-A\n@@ -87,1 +87,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v008-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v008-U\n@@ -99,1 +99,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v004-A\n@@ -111,1 +111,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets sse4-v004-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets sse4-v004-U\n@@ -123,1 +123,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v032-A\n@@ -135,1 +135,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v032-U\n@@ -147,1 +147,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v016-A\n@@ -159,1 +159,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx1-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx1-v016-U\n@@ -171,1 +171,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v032-A\n@@ -183,1 +183,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v032-U\n@@ -195,1 +195,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v016-A\n@@ -207,1 +207,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx2-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx2-v016-U\n@@ -219,1 +219,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v064-A\n@@ -231,1 +231,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v064-U\n@@ -243,1 +243,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v032-A\n@@ -255,1 +255,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512-v032-U\n@@ -267,1 +267,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-A\n@@ -279,1 +279,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v064-U\n@@ -291,1 +291,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-A\n@@ -303,1 +303,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets avx512bw-v032-U\n@@ -314,1 +314,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v064-A\n@@ -325,1 +325,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v064-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v064-U\n@@ -336,1 +336,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v032-A\n@@ -347,1 +347,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v032-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v032-U\n@@ -358,1 +358,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v016-A\n@@ -369,1 +369,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v016-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v016-U\n@@ -380,1 +380,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v008-A\n@@ -391,1 +391,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v008-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v008-U\n@@ -402,1 +402,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-A\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v004-A\n@@ -413,1 +413,1 @@\n- * @run driver compiler.loopopts.superword.TestDependencyOffsets vec-v004-U\n+ * @run driver\/timeout=480 compiler.loopopts.superword.TestDependencyOffsets vec-v004-U\n@@ -754,0 +754,2 @@\n+                \/\/ If we have two array references, then we can speculate that they do not alias, and\n+                \/\/ still produce full vectorization.\n@@ -758,1 +760,1 @@\n-                if (0 < byteOffset && byteOffset < maxVectorWidth) {\n+                if (isSingleArray && 0 < byteOffset && byteOffset < maxVectorWidth) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":37,"deletions":35,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run driver\/timeout=1200 compiler.loopopts.superword.TestEquivalentInvariants\n+ * @run driver\/timeout=4800 compiler.loopopts.superword.TestEquivalentInvariants\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,16 @@\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n@@ -66,0 +82,7 @@\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n@@ -163,0 +186,40 @@\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8329273 8348263 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8329273 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n@@ -196,0 +259,4 @@\n+                case \"NoSpeculativeAliasingCheck\" -> framework.addFlags(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\");\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n@@ -197,0 +264,1 @@\n+                default ->                           throw new RuntimeException(\"Bad tag: \" + tag);\n@@ -199,3 +267,0 @@\n-        if (args.length > 1 && args[1].equals(\"AlignVector\")) {\n-            framework.addFlags(\"-XX:+AlignVector\");\n-        }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":68,"deletions":3,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,914 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+import jdk.test.lib.Utils;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test id=byte-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoAutoAlignment\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoAutoAlignment\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=char-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing CharArray\n+ *\/\n+\n+\/*\n+ * @test id=short-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ShortArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray\n+ *\/\n+\n+\/*\n+ * @test id=int-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=int-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoAutoAlignment\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoAutoAlignment\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=int-array-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing IntArray NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=long-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray\n+ *\/\n+\n+\/*\n+ * @test id=long-array-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=long-array-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=long-array-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing LongArray AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=float-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing FloatArray\n+ *\/\n+\n+\/*\n+ * @test id=double-array\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing DoubleArray\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteBuffer\n+ *\/\n+\n+\/*\n+ * @test id=byte-buffer-direct\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing ByteBufferDirect\n+ *\/\n+\n+\/*\n+ * @test id=native\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoSpeculativeAliasingCheck\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector NoSpeculativeAliasingCheck\n+ *\/\n+\n+\/*\n+ * @test id=native-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-AlignVector-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=native-NoSpeculativeAliasingCheck-NoShortRunningLongLoop\n+ * @bug 8324751\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentAliasing Native NoSpeculativeAliasingCheck NoShortRunningLongLoop\n+ *\/\n+\n+public class TestMemorySegmentAliasing {\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMemorySegmentAliasingImpl.class);\n+        framework.addFlags(\"-DmemorySegmentProviderNameForTestVM=\" + args[0]);\n+        for (int i = 1; i < args.length; i++) {\n+            String tag = args[i];\n+            switch (tag) {\n+                case \"AlignVector\" ->                framework.addFlags(\"-XX:+AlignVector\");\n+                case \"NoSpeculativeAliasingCheck\" -> framework.addFlags(\"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\");\n+                \/\/ automatic alignment has an impact on where the main-loop starts, and that affects init and limit\n+                \/\/ of the main loop.\n+                case \"NoAutoAlignment\" ->            framework.addFlags(\"-XX:SuperWordAutomaticAlignment=0\");\n+                \/\/ Disabling the ShortRunningLongLoop optimization changes the shape of the loop.\n+                \/\/ Testing both with and without it allows us to simulate long running loops with short running loops,\n+                \/\/ i.e. we don't need to allocate massive amounts of memory.\n+                case \"NoShortRunningLongLoop\" ->     framework.addFlags(\"-XX:-ShortRunningLongLoop\");\n+                default ->                           throw new RuntimeException(\"Bad tag: \" + tag);\n+            }\n+        }\n+        framework.setDefaultWarmup(100);\n+        framework.start();\n+    }\n+}\n+\n+class TestMemorySegmentAliasingImpl {\n+    static final int BACKING_SIZE = 1024 * 8;\n+    static final Random RANDOM = Utils.getRandomInstance();\n+\n+\n+    interface TestFunction {\n+        void run();\n+    }\n+\n+    interface MemorySegmentProvider {\n+        MemorySegment newMemorySegment();\n+    }\n+\n+    public static MemorySegmentProvider provider;\n+\n+    static {\n+        String providerName = System.getProperty(\"memorySegmentProviderNameForTestVM\");\n+        provider = switch (providerName) {\n+            case \"ByteArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteArray;\n+            case \"CharArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfCharArray;\n+            case \"ShortArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfShortArray;\n+            case \"IntArray\"         -> TestMemorySegmentAliasingImpl::newMemorySegmentOfIntArray;\n+            case \"LongArray\"        -> TestMemorySegmentAliasingImpl::newMemorySegmentOfLongArray;\n+            case \"FloatArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfFloatArray;\n+            case \"DoubleArray\"      -> TestMemorySegmentAliasingImpl::newMemorySegmentOfDoubleArray;\n+            case \"ByteBuffer\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteBuffer;\n+            case \"ByteBufferDirect\" -> TestMemorySegmentAliasingImpl::newMemorySegmentOfByteBufferDirect;\n+            case \"Native\"           -> TestMemorySegmentAliasingImpl::newMemorySegmentOfNative;\n+            case \"MixedArray\"       -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixedArray;\n+            case \"MixedBuffer\"      -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixedBuffer;\n+            case \"Mixed\"            -> TestMemorySegmentAliasingImpl::newMemorySegmentOfMixed;\n+            default -> throw new RuntimeException(\"Test argument not recognized: \" + providerName);\n+        };\n+    }\n+\n+    \/\/ Map of goldTests\n+    public static Map<String, TestFunction> goldTests = new HashMap<>();\n+\n+    \/\/ Map of gold for the goldTests, the results from the first run before compilation\n+    public static Map<String, Object> golds = new HashMap<>();\n+\n+    \/\/ Map of referenceTests, i.e. tests that have a reference implementation that is run with the interpreter.\n+    \/\/ The TestFunction must run both the test and reference methods.\n+    public static Map<String, TestFunction> referenceTests = new HashMap<>();\n+\n+    \/\/ Original data.\n+    public static MemorySegment ORIG_A = fillRandom(newMemorySegment());\n+    public static MemorySegment ORIG_B = fillRandom(newMemorySegment());\n+    public static MemorySegment ORIG_C = fillRandom(newMemorySegment());\n+\n+    \/\/ The data we use in the tests. It is initialized from ORIG_* every time.\n+    public static MemorySegment A = newMemorySegment();\n+    public static MemorySegment B = newMemorySegment();\n+    public static MemorySegment C = newMemorySegment();\n+\n+    \/\/ Parallel to data above, but for use in reference methods.\n+    public static MemorySegment A_REFERENCE = newMemorySegment();\n+    public static MemorySegment B_REFERENCE = newMemorySegment();\n+    public static MemorySegment C_REFERENCE = newMemorySegment();\n+\n+    public TestMemorySegmentAliasingImpl () {\n+        \/\/ Add all goldTests to list\n+        goldTests.put(\"test_byte_incr_noaliasing\",     () -> test_byte_incr_noaliasing(A, B));\n+        goldTests.put(\"test_byte_incr_aliasing\",       () -> test_byte_incr_aliasing(A, A));\n+        goldTests.put(\"test_byte_incr_aliasing_fwd3\",  () -> {\n+            MemorySegment x = A.asSlice(0, BACKING_SIZE - 3);\n+            MemorySegment y = A.asSlice(3, BACKING_SIZE - 3);\n+            test_byte_incr_aliasing_fwd3(x, y);\n+        });\n+        goldTests.put(\"test_byte_incr_noaliasing_fwd128\",  () -> {\n+            MemorySegment x = A.asSlice(0,   BACKING_SIZE - 128);\n+            MemorySegment y = A.asSlice(120, BACKING_SIZE - 128);\n+            test_byte_incr_noaliasing_fwd128(x, y);\n+        });\n+\n+        goldTests.put(\"test_int_to_long_noaliasing\",   () -> test_int_to_long_noaliasing(A, B));\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            init();\n+            test.run();\n+            Object gold = snapshotCopy();\n+            golds.put(name, gold);\n+        }\n+\n+        referenceTests.put(\"test_fill_byte_sameMS_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_byte_sameMS_alias(A, A, invar1, invar2);\n+            reference_fill_byte_sameMS_alias(A_REFERENCE, A_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"test_fill_byte_sameMS_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_byte_sameMS_noalias(A, A, invar1, invar2, limit);\n+            reference_fill_byte_sameMS_noalias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_byte_sameMS_maybeAlias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ In the middle, sometimes we overlap and sometimes not.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle + RANDOM.nextInt(-256, 256);\n+            int invar2 = middle + RANDOM.nextInt(-256, 256);\n+            \/\/ Are the bounds safe? Assume extreme values:\n+            \/\/ invar1 = 8k\/2 + 256 + 256\n+            \/\/ limit = 8k\/3 + 256\n+            \/\/ invar1 + limit = 8k * 5\/6 + 3 * 256\n+            \/\/                = 8k * 5\/6 + 3\/4 * 1k = 7.41k < 8k\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_byte_sameMS_maybeAlias(A, A, invar1, invar2, limit);\n+            reference_fill_byte_sameMS_maybeAlias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_alias\", () -> {\n+            int invar1 = RANDOM.nextInt(64);\n+            int invar2 = RANDOM.nextInt(64);\n+            test_fill_int_sameMS_alias(A, A, invar1, invar2);\n+            reference_fill_int_sameMS_alias(A_REFERENCE, A_REFERENCE, invar1, invar2);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_noalias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ But they never overlap.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle;\n+            int invar2 = middle;\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_int_sameMS_noalias(A, A, invar1, invar2, limit);\n+            reference_fill_int_sameMS_noalias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+        referenceTests.put(\"test_fill_int_sameMS_maybeAlias\", () -> {\n+            \/\/ The accesses either start at the middle and go out,\n+            \/\/ or start from opposite sides and meet in the middle.\n+            \/\/ In the middle, sometimes we overlap and sometimes not.\n+            \/\/      <------|------>\n+            \/\/      ------>|<------\n+            \/\/\n+            \/\/ This tests that the checks we emit are not too relaxed.\n+            int middle = BACKING_SIZE \/ 2 + RANDOM.nextInt(-256, 256);\n+            int limit = BACKING_SIZE \/ 3 + RANDOM.nextInt(256);\n+            int invar1 = middle + RANDOM.nextInt(-256, 256);\n+            int invar2 = middle + RANDOM.nextInt(-256, 256);\n+            \/\/ Are the bounds safe? Assume extreme values:\n+            \/\/ invar1 = 8k\/2 + 256 + 256\n+            \/\/ limit = 8k\/3 + 256\n+            \/\/ invar1 + limit = 8k * 5\/6 + 3 * 256\n+            \/\/                = 8k * 5\/6 + 3\/4 * 1k = 7.41k < 8k\n+            if (RANDOM.nextBoolean()) {\n+                invar1 -= limit;\n+                invar2 += limit;\n+            }\n+            test_fill_int_sameMS_maybeAlias(A, A, invar1, invar2, limit);\n+            reference_fill_int_sameMS_maybeAlias(A_REFERENCE, A_REFERENCE, invar1, invar2, limit);\n+        });\n+    }\n+\n+    static MemorySegment newMemorySegment() {\n+        return provider.newMemorySegment();\n+    }\n+\n+    static MemorySegment copy(MemorySegment src) {\n+        MemorySegment dst = newMemorySegment();\n+        dst.copyFrom(src);\n+        return dst;\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteArray() {\n+        return MemorySegment.ofArray(new byte[BACKING_SIZE]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfCharArray() {\n+        return MemorySegment.ofArray(new char[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfShortArray() {\n+        return MemorySegment.ofArray(new short[BACKING_SIZE \/ 2]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfIntArray() {\n+        return MemorySegment.ofArray(new int[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfLongArray() {\n+        return MemorySegment.ofArray(new long[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfFloatArray() {\n+        return MemorySegment.ofArray(new float[BACKING_SIZE \/ 4]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfDoubleArray() {\n+        return MemorySegment.ofArray(new double[BACKING_SIZE \/ 8]);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBuffer() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocate(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfByteBufferDirect() {\n+        return MemorySegment.ofBuffer(ByteBuffer.allocateDirect(BACKING_SIZE));\n+    }\n+\n+    static MemorySegment newMemorySegmentOfNative() {\n+        \/\/ Auto arena: GC decides when there is no reference to the MemorySegment,\n+        \/\/ and then it deallocates the backing memory.\n+        return Arena.ofAuto().allocate(BACKING_SIZE, 1);\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedArray() {\n+        switch(RANDOM.nextInt(7)) {\n+            case 0  -> { return newMemorySegmentOfByteArray(); }\n+            case 1  -> { return newMemorySegmentOfCharArray(); }\n+            case 2  -> { return newMemorySegmentOfShortArray(); }\n+            case 3  -> { return newMemorySegmentOfIntArray(); }\n+            case 4  -> { return newMemorySegmentOfLongArray(); }\n+            case 5  -> { return newMemorySegmentOfFloatArray(); }\n+            default -> { return newMemorySegmentOfDoubleArray(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixedBuffer() {\n+        switch (RANDOM.nextInt(2)) {\n+            case 0  -> { return newMemorySegmentOfByteBuffer(); }\n+            default -> { return newMemorySegmentOfByteBufferDirect(); }\n+        }\n+    }\n+\n+    static MemorySegment newMemorySegmentOfMixed() {\n+        switch (RANDOM.nextInt(3)) {\n+            case 0  -> { return newMemorySegmentOfMixedArray(); }\n+            case 1  -> { return newMemorySegmentOfMixedBuffer(); }\n+            default -> { return newMemorySegmentOfNative(); }\n+        }\n+    }\n+\n+    static MemorySegment fillRandom(MemorySegment data) {\n+        for (int i = 0; i < (int)data.byteSize(); i += 8) {\n+            data.set(ValueLayout.JAVA_LONG_UNALIGNED, i, RANDOM.nextLong());\n+        }\n+        return data;\n+    }\n+\n+    public static void init() {\n+        A.copyFrom(ORIG_A);\n+        B.copyFrom(ORIG_B);\n+        C.copyFrom(ORIG_C);\n+    }\n+\n+    public static void initReference() {\n+        A_REFERENCE.copyFrom(ORIG_A);\n+        B_REFERENCE.copyFrom(ORIG_B);\n+        C_REFERENCE.copyFrom(ORIG_C);\n+    }\n+\n+    public static Object snapshotCopy() {\n+        return new Object[]{copy(A), copy(B), copy(C)};\n+    }\n+\n+    public static Object snapshot() {\n+        return new Object[]{A, B, C};\n+    }\n+\n+    public static Object snapshotReference() {\n+        return new Object[]{A_REFERENCE, B_REFERENCE, C_REFERENCE};\n+    }\n+\n+    @Run(test = {\"test_byte_incr_noaliasing\",\n+                 \"test_byte_incr_aliasing\",\n+                 \"test_byte_incr_aliasing_fwd3\",\n+                 \"test_byte_incr_noaliasing_fwd128\",\n+                 \"test_int_to_long_noaliasing\",\n+                 \"test_fill_byte_sameMS_alias\",\n+                 \"test_fill_byte_sameMS_noalias\",\n+                 \"test_fill_byte_sameMS_maybeAlias\",\n+                 \"test_fill_int_sameMS_alias\",\n+                 \"test_fill_int_sameMS_noalias\",\n+                 \"test_fill_int_sameMS_maybeAlias\"})\n+    void runTests(RunInfo info) {\n+        for (Map.Entry<String,TestFunction> entry : goldTests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object gold = golds.get(name);\n+            \/\/ Compute new result\n+            init();\n+            test.run();\n+            Object result = snapshot();\n+            \/\/ Compare gold and new result\n+            try {\n+                Verify.checkEQ(gold, result);\n+            } catch (VerifyException e) {\n+                throw new RuntimeException(\"Verify failed for \" + name, e);\n+            }\n+        }\n+\n+        \/\/ Once warmup is over (100x), repeat 10x to get reasonable coverage of the\n+        \/\/ randomness in the tests.\n+        int reps = info.isWarmUp() ? 10 : 1;\n+        for (int r = 0; r < reps; r++) {\n+            for (Map.Entry<String,TestFunction> entry : referenceTests.entrySet()) {\n+                String name = entry.getKey();\n+                TestFunction test = entry.getValue();\n+                \/\/ Init data for test and reference\n+                init();\n+                initReference();\n+                \/\/ Run test and reference\n+                test.run();\n+                \/\/ Capture results from test and reference\n+                Object result = snapshot();\n+                Object expected = snapshotReference();\n+                \/\/ Compare expected and new result\n+                try {\n+                    Verify.checkEQ(expected, result);\n+                } catch (VerifyException e) {\n+                    throw new RuntimeException(\"Verify failed for \" + name, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_noaliasing(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_aliasing(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_aliasing_fwd3(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_byte_incr_noaliasing_fwd128(MemorySegment a, MemorySegment b) {\n+        for (long i = 0; i < a.byteSize(); i++) {\n+            byte v = a.get(ValueLayout.JAVA_BYTE, i);\n+            b.set(ValueLayout.JAVA_BYTE, i, (byte)(v + 1));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.VECTOR_CAST_I2L, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.STORE_VECTOR,                                                   \"> 0\",\n+                  \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ In this case, the limit is pre-loop independent, but its assigned\n+    \/\/ ctrl sits between main and pre loop. Only the early ctrl is before\n+    \/\/ the pre loop.\n+    static void test_int_to_long_noaliasing(MemorySegment a, MemorySegment b) {\n+        long limit = a.byteSize() \/ 8L;\n+        for (long i = 0; i < limit; i++) {\n+            int v = a.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i);\n+            b.set(ValueLayout.JAVA_LONG_UNALIGNED, 8L * i, v);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    static void test_fill_byte_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, i + invar1, (byte)0x0a);\n+            b.set(ValueLayout.JAVA_BYTE, a.byteSize() - i - 1 - invar2, (byte)0x0b);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, i + invar1, (byte)0x0a);\n+            b.set(ValueLayout.JAVA_BYTE, a.byteSize() - i - 1 - invar2, (byte)0x0b);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ For now, we just assert that there is never multiversioning, which holds with or without vectorization:\n+    @IR(counts = {\".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_fill_byte_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ Note: we may or may not use multiversioning, depending if we alias or not at runtime.\n+    static void test_fill_byte_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_byte_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i < limit; i++) {\n+            a.set(ValueLayout.JAVA_BYTE, invar1 + i, (byte)0xa);\n+            b.set(ValueLayout.JAVA_BYTE, invar2 - i, (byte)0xb);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"> 0\"}, \/\/ AutoVectorization Predicate FAILS\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    static void test_fill_int_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, i + invar1, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, a.byteSize() - i - 4 - invar2, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_alias(MemorySegment a, MemorySegment b, long invar1, long invar2) {\n+        for (long i = 0; i < a.byteSize() - 100; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, i + invar1, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, a.byteSize() - i - 4 - invar2, 0x11121314);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\",\n+    \/\/               \".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ For now, we just assert that there is never multiversioning, which holds with or without vectorization:\n+    @IR(counts = {\".*multiversion.*\",   \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static void test_fill_int_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_noalias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @Test\n+    \/\/ @IR(counts = {IRNode.STORE_VECTOR,  \"> 0\"},\n+    \/\/     phase = CompilePhase.PRINT_IDEAL,\n+    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n+    \/\/     applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    \/\/ FAILS: but only on \"native\" and \"byte-buffer-direct\"\n+    \/\/        The issue is that one of the VPointers is invalid.\n+    \/\/\n+    \/\/ Note: we may or may not use multiversioning, depending if we alias or not at runtime.\n+    static void test_fill_int_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+\n+    @DontCompile\n+    static void reference_fill_int_sameMS_maybeAlias(MemorySegment a, MemorySegment b, long invar1, long invar2, long limit) {\n+        for (long i = 0; i <= limit - 4; i+=4) {\n+            a.set(ValueLayout.JAVA_INT_UNALIGNED, invar1 + i, 0x01020304);\n+            b.set(ValueLayout.JAVA_INT_UNALIGNED, invar2 - i, 0x11121314);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentAliasing.java","additions":914,"deletions":0,"binary":false,"changes":914,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8359688: C2 SuperWord: missing RCE with MemorySegment\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8359688\n+ *\/\n+\n+\n+public class TestMemorySegment_8359688 {\n+\n+    public static MemorySegment b = MemorySegment.ofArray(new long[4 * 30_000]);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { b, 0, 5_000, 0 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"= 0\",\n+                  IRNode.REPLICATE_L,  \"= 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Does not manage to remove all RangeChecks -> no vectorization\n+    \/\/ If you see this IR rule fail: investigate JDK-8359688, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test1(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 30_000L - (long)i + (long)invar, 42);\n+            \/\/                                                    ^ subtraction here\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_L,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Is fully RFE'd and vectorized\n+    public static void test2(MemorySegment b, int ivLo, int ivHi, int invar) {\n+        for (int i = ivLo; i < ivHi; i++) {\n+            b.setAtIndex(ValueLayout.JAVA_LONG_UNALIGNED, 1_000L + 1L * i + (long)invar, 42);\n+            \/\/                                                   ^ addition here\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8359688.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8360204: C2 SuperWord: missing RCE with MemorySegment.getAtIndex\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8360204\n+ *\/\n+\n+public class TestMemorySegment_8360204 {\n+\n+    public static MemorySegment a = Arena.ofAuto().allocate(10_000);\n+    public static MemorySegment b = Arena.ofAuto().allocate(10_000);\n+\n+    private static long invar0_1159 = 0;\n+    private static long invar1_1159 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -19125L, b, 71734L + 2_000L, 0, 1_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\",\n+                  \".*multiversion.*\",   \"> 0\"}, \/\/ Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ There is no aliasing, so we should compile without multiversioning.\n+    \/\/ But currently, there seems to be some issue with RCE, we peel and lose the predicate.\n+    \/\/ Then we multiversion.\n+    \/\/ We could imagine that this would eventually vectorize, but since one counts up, and the other down,\n+    \/\/ we would have to implement shuffle first.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8360204, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivLo; i < ivHi; i+=1) {\n+            var v = container_0.getAtIndex(ValueLayout.JAVA_INT_UNALIGNED, 19125L + 1L * i + 1L * invar0_0 + 0L * invar0_1159 + 1L * invar1_1159);\n+            container_1.setAtIndex(ValueLayout.JAVA_INT_UNALIGNED, -71734L + -1L * i + 1L * invar0_1 + 1L * invar0_1159 + 0L * invar1_1159, v);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8360204.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8324751\n+ * @summary Reported issue: JDK-8365982: C2 SuperWord: missing RCE \/ strange Multiversioning with MemorySegment.set\n+ *          The examples are generated from TestAliasingFuzzer.java\n+ *          So if you see something change here, you may want to investigate if we\n+ *          can also tighten up the IR rules there.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment_8365982\n+ *\/\n+\n+public class TestMemorySegment_8365982 {\n+\n+    public static MemorySegment a = MemorySegment.ofArray(new short[100_000]);\n+    public static MemorySegment b = MemorySegment.ofArray(new short[100_000]);\n+\n+    private static long invar0_853 = 0;\n+    private static long invar1_853 = 0;\n+    private static long invar2_853 = 0;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Setup\n+    static Object[] setup() {\n+        return new Object[] { a, -50_000, b, -30_000, 0, 10_000 };\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"= 0\"}, \/\/ Good: The AutoVectorization predicate suffices.\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/\n+    @IR(counts = {IRNode.STORE_VECTOR, \"> 0\",\n+                  IRNode.REPLICATE_S,  \"> 0\",\n+                  \".*multiversion.*\",  \"> 0\"}, \/\/ Bad: Sadly, we now multiversion\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"AlignVector\", \"false\", \"ShortRunningLongLoop\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Some but not all predicates are RCE'd at the beginning. After unrolling, we multiversion (why?).\n+    \/\/ After PreMainPost, we can do more RangeCheck. Now the main-loop of the multiversion_fast loop\n+    \/\/ does not have any range checks any more.\n+    \/\/ Now it vectorizes. That's good, but we should be able to vectorize without multiversioning.\n+    \/\/\n+    \/\/ If you see this IR rule fail: investigate JDK-8365982, possibly close it and fix this IR rule!\n+    \/\/ Also: consider renaming the file to something more descriptive: what have you fixed with this?\n+    \/\/ And: you may now be able to tighten IR rules in TestAliasingFuzzer.java\n+    public static void test(MemorySegment container_0, long invar0_0, MemorySegment container_1, long invar0_1, long ivLo, long ivHi) {\n+        for (long i = ivHi-1; i >= ivLo; i-=1) {\n+            container_0.set(ValueLayout.JAVA_CHAR_UNALIGNED, -47143L + -2L * i + -2L * invar0_0 + -1L * invar0_853 + -1L * invar1_853 + 0L * invar2_853, (char)0x0102030405060708L);\n+            container_1.set(ValueLayout.JAVA_CHAR_UNALIGNED, 74770L + 2L * i + 2L * invar0_1 + 0L * invar0_853 + 0L * invar1_853 + 0L * invar2_853, (char)0x1112131415161718L);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment_8365982.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -32,6 +32,7 @@\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestMovingLoadBeforeStore::test*\n- *                   --add-modules java.base --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n- *                   -Xbatch\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=100\n- *                   compiler.loopopts.superword.TestMovingLoadBeforeStore\n+ * @run main\/othervm\/timeout=480\n+ *   -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestMovingLoadBeforeStore::test*\n+ *   --add-modules java.base --add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\n+ *   -Xbatch\n+ *   -XX:+UnlockDiagnosticVMOptions -XX:+StressLCM\n+ *   -XX:+IgnoreUnrecognizedVMOptions -XX:LoopUnrollLimit=100\n+ *   compiler.loopopts.superword.TestMovingLoadBeforeStore\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMovingLoadBeforeStore.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,4 +40,8 @@\n- * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV\n- * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV_ySAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks nCOH_yAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_nAV_nSAC\n+ * @run driver compiler.loopopts.superword.TestSplitPacks yCOH_yAV_nSAC\n@@ -79,4 +83,8 @@\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"nCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_ySAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"nCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_nAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n+            case \"yCOH_yAV_nSAC\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"); }\n@@ -117,0 +125,7 @@\n+        tests.put(\"test4a_alias\",() -> { short[] x = aS.clone(); return test4a_alias(x, x); });\n+        tests.put(\"test4b_alias\",() -> { short[] x = aS.clone(); return test4b_alias(x, x); });\n+        tests.put(\"test4c_alias\",() -> { short[] x = aS.clone(); return test4c_alias(x, x); });\n+        tests.put(\"test4d_alias\",() -> { short[] x = aS.clone(); return test4d_alias(x, x); });\n+        tests.put(\"test4e_alias\",() -> { short[] x = aS.clone(); return test4e_alias(x, x); });\n+        tests.put(\"test4f_alias\",() -> { short[] x = aS.clone(); return test4f_alias(x, x); });\n+        tests.put(\"test4g_alias\",() -> { short[] x = aS.clone(); return test4g_alias(x, x); });\n@@ -148,0 +163,7 @@\n+                 \"test4a_alias\",\n+                 \"test4b_alias\",\n+                 \"test4c_alias\",\n+                 \"test4d_alias\",\n+                 \"test4e_alias\",\n+                 \"test4f_alias\",\n+                 \"test4g_alias\",\n@@ -714,1 +736,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -718,0 +743,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -727,2 +760,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -732,0 +767,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -741,2 +784,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=8\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -746,0 +791,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -755,2 +808,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -760,0 +815,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -769,2 +832,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -774,0 +839,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -783,2 +856,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -788,0 +863,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -797,2 +880,4 @@\n-                  IRNode.STORE_VECTOR, \"> 0\"},\n-        applyIf = {\"MaxVectorSize\", \">=32\"},\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n@@ -802,0 +887,8 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check -> full vectorization.\n@@ -809,0 +902,175 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 2 -> split into 2-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4a_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+2] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 3 -> split into 2-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4b_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+3] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 4 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4c_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+4] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 5 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4d_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+5] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 6 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4e_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+6] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 7 -> split into 4-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4f_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+7] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"= 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Cyclic dependency with distance 8 -> split into 8-packs\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\",\n+                  \".*multiversion.*\", \"> 0\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    \/\/ Speculative aliasing check with multiversioning -> full vectorization & split packs.\n+    static Object[] test4g_alias(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+8] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":289,"deletions":21,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver compiler.loopstripmining.CheckLoopStripMining\n+ * @run driver\/timeout=480 compiler.loopstripmining.CheckLoopStripMining\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/CheckLoopStripMining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseOnStackReplacement -XX:+IgnoreUnrecognizedVMOptions -XX:MaxTrivialSize=0 -XX:C1MaxTrivialSize=0 compiler.profiling.TestProfileCounterOverflow\n+ * @run main\/othervm\/timeout=480 -Xbatch -XX:-UseOnStackReplacement -XX:+IgnoreUnrecognizedVMOptions -XX:MaxTrivialSize=0 -XX:C1MaxTrivialSize=0 compiler.profiling.TestProfileCounterOverflow\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/TestProfileCounterOverflow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,4 @@\n- * @run main\/othervm -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n- *                   -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n- *                   -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n- *                   compiler.profiling.spectrapredefineclass.Agent\n+ * @run main\/othervm\/timeout=480 -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n+ *                               -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n+ *                               -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n+ *                               compiler.profiling.spectrapredefineclass.Agent\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass\/Launcher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,4 @@\n- * @run main\/othervm -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n- *                   -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n- *                   -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n- *                   compiler.profiling.spectrapredefineclass_classloaders.Agent\n+ * @run main\/othervm\/timeout=480 -XX:CompilationMode=high-only -XX:-BackgroundCompilation -XX:CompileThreshold=10000\n+ *                               -XX:-UseOnStackReplacement -XX:TypeProfileLevel=222\n+ *                               -XX:ReservedCodeCacheSize=3M -Djdk.attach.allowAttachSelf\n+ *                               compiler.profiling.spectrapredefineclass_classloaders.Agent\n","filename":"test\/hotspot\/jtreg\/compiler\/profiling\/spectrapredefineclass_classloaders\/Launcher.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+TieredCompilation\n+ * @run main\/othervm\/timeout=960 -Xbootclasspath\/a:. -XX:+TieredCompilation\n@@ -104,1 +104,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/Level2RecompilationTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n+ * @run main\/othervm\/timeout=480 -XX:-BackgroundCompilation -Xmx128M -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestDeoptOOM.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * @run main\/othervm compiler.valhalla.inlinetypes.TestArrayMetadata\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -XX:+IgnoreUnrecognizedVMOptions\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xcomp\n+ * @run main\/othervm\/timeout=300 -Xcomp\n@@ -37,1 +37,1 @@\n- * @run main\/othervm -XX:MultiArrayExpandLimit=0\n+ * @run main\/othervm\/timeout=300 -XX:MultiArrayExpandLimit=0\n@@ -39,1 +39,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbatch\n@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbatch\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayMetadata.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -52,1 +52,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +58,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -61,1 +61,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -64,1 +64,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -67,1 +67,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -71,1 +71,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -75,1 +75,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -39,1 +39,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC2CCalls.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n- * @run main\/othervm compiler.valhalla.inlinetypes.TestFieldNullMarkers\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -53,1 +53,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -57,1 +57,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -60,1 +60,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -63,1 +63,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -66,1 +66,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -69,1 +69,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -72,1 +72,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n- * @run main\/othervm\/timeout=450 compiler.valhalla.inlinetypes.TestLWorld\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestLWorld\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestNullableArrays\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestNullableArrays\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n- * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestNullableInlineTypes\n+ * @run main\/othervm\/timeout=1000 compiler.valhalla.inlinetypes.TestNullableInlineTypes\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestOnStackReplacement\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestOnStackReplacement\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -36,1 +36,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -56,1 +56,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -61,1 +61,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -66,1 +66,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -71,1 +71,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOopsInReturnConvention.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * @run main\/othervm\/timeout=450 -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ * @run main\/othervm\/timeout=1000 -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n@@ -114,1 +114,1 @@\n- * @run main\/othervm\/timeout=450 -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n+ * @run main\/othervm\/timeout=1000 -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseArrayFlattening\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTearing.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n@@ -57,1 +57,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n@@ -69,1 +69,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -83,1 +83,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n@@ -96,1 +96,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -109,1 +109,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -122,1 +122,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions\n@@ -135,1 +135,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -148,1 +148,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n@@ -161,1 +161,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -174,1 +174,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -188,1 +188,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -202,1 +202,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -216,1 +216,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -38,1 +38,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -50,1 +50,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -53,1 +53,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -56,1 +56,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -62,1 +62,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -65,1 +65,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -68,1 +68,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=600 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestVirtualThreads.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n- * @run main\/othervm -XX:-TieredCompilation -Xbatch\n+ * @run main\/othervm\/timeout=480\n+ *                   -XX:-TieredCompilation -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestRawOopAtSafepoint.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-* @run driver compiler.vectorization.TestFloat16VectorOperations\n+* @run driver\/timeout=480 compiler.vectorization.TestFloat16VectorOperations\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,4 +30,1 @@\n- * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_nAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector nCOH_yAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_nAV\n- * @run driver compiler.vectorization.TestFloatConversionsVector yCOH_yAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVector\n@@ -38,0 +35,2 @@\n+import java.util.Set;\n+\n@@ -52,7 +51,2 @@\n-        switch (args[0]) {\n-            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n-            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n-            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n-        };\n+        framework.addCrossProductScenarios(Set.of(\"-XX:-UseCompactObjectHeaders\", \"-XX:+UseCompactObjectHeaders\"),\n+                                           Set.of(\"-XX:-AlignVector\", \"-XX:+AlignVector\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVector.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm compiler.vectorization.TestVectorZeroCount\n+ * @run main\/othervm\/timeout=480 compiler.vectorization.TestVectorZeroCount\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorZeroCount.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,4 +34,12 @@\n- * @run main\/othervm -Xbootclasspath\/a:.\n- *                   -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI\n- *                   compiler.vectorization.runner.LoopArrayIndexComputeTest\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest nAV_ySAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest yAV_ySAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest nAV_nSAC\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.vectorization.runner.LoopArrayIndexComputeTest yAV_nSAC\n@@ -51,0 +59,12 @@\n+    \/\/ We must pass the flags directly to the test-VM, and not the driver vm in the @run above.\n+    @Override\n+    protected String[] testVMFlags(String[] args) {\n+        return switch (args[0]) {\n+            case \"nAV_ySAC\" -> new String[]{\"-XX:-AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"yAV_ySAC\" -> new String[]{\"-XX:+AlignVector\", \"-XX:+UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"nAV_nSAC\" -> new String[]{\"-XX:-AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            case \"yAV_nSAC\" -> new String[]{\"-XX:+AlignVector\", \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"};\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+    }\n+\n@@ -178,1 +198,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+     \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -189,1 +218,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -279,1 +317,11 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.MUL_VS, \">0\",\n+                  IRNode.LOAD_VECTOR_S, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -307,0 +355,2 @@\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -308,1 +358,2 @@\n-                  IRNode.MUL_VS, IRNode.VECTOR_SIZE_2, \">0\"}) \/\/ size 2 only\n+                  IRNode.MUL_VS, IRNode.VECTOR_SIZE_2, \">0\", \/\/ size 2 only\n+                  \".*multiversion.*\", \"= 0\"})\n@@ -335,1 +386,11 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.ADD_VB, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -340,1 +401,1 @@\n-            res[i] *= bytes[i - 3];\n+            res[i] += bytes[i - 3];\n@@ -362,0 +423,9 @@\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.OR_VB, IRNode.VECTOR_SIZE_4, \">0\", \/\/ size 4 only\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIfAnd = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\", \"AlignVector\", \"false\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n@@ -363,1 +433,3 @@\n-                  IRNode.OR_VB, IRNode.VECTOR_SIZE_4, \">0\"}) \/\/ size 4 only\n+                  IRNode.OR_VB, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n@@ -389,1 +461,10 @@\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    @IR(failOn = {IRNode.STORE_VECTOR},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"false\"})\n+    \/\/ Speculative aliasing check -> never fails -> only predicate, no multiversioning.\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        applyIf = {\"UseAutoVectorizationSpeculativeAliasingChecks\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL,\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.LOAD_VECTOR_I, \">0\", \/\/ full vectorization\n+                  \".*multiversion.*\", \"= 0\"})\n+    \/\/ JDK-8354303: could we prove statically that there is no aliasing?\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":93,"deletions":12,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @summary Run tests with G1\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.G1\n+ * @run driver TestTransparentHugePagesHeap G1\n+*\/\n+\/*\n+ * @test id=Parallel\n+ * @summary Run tests with Parallel\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Parallel\n+ * @run driver TestTransparentHugePagesHeap Parallel\n+*\/\n+\/*\n+ * @test id=Serial\n+ * @summary Run tests with Serial\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @requires os.family == \"linux\"\n+ * @requires vm.gc.Serial\n+ * @run driver TestTransparentHugePagesHeap Serial\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.Scanner;\n+\n+import jdk.test.lib.os.linux.HugePageConfiguration;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Platform;\n+\n+import jtreg.SkippedException;\n+\n+\/\/ We verify that the heap can be backed by THP by looking at the\n+\/\/ THPeligible field for the heap section in \/proc\/self\/smaps. This\n+\/\/ field indicates if a mapping can use THP.\n+\/\/ THP mode 'always': this field is 1 whenever huge pages can be used\n+\/\/ THP mode 'madvise': this field is 1 if the mapping has been madvised\n+\/\/ as MADV_HUGEPAGE. In the JVM that should happen when the flag\n+\/\/ -XX:+UseTransparentHugePages is specified.\n+\/\/\n+\/\/ Note: we don't verify if the heap is backed by huge pages because we\n+\/\/ can't know if the underlying system have any available.\n+public class TestTransparentHugePagesHeap {\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ To be able to detect large page use (esp. THP) somewhat reliably, we\n+        \/\/  need at least kernel 3.8 to get the \"VmFlags\" tag in smaps.\n+        \/\/ (Note: its still good we started the VM at least since this serves as a nice\n+        \/\/  test for all manners of large page options).\n+        if (Platform.getOsVersionMajor() < 3 ||\n+            (Platform.getOsVersionMajor() == 3 && Platform.getOsVersionMinor() < 8)) {\n+            throw new SkippedException(\"Kernel older than 3.8 - skipping this test.\");\n+        }\n+\n+        final HugePageConfiguration hugePageConfiguration = HugePageConfiguration.readFromOS();\n+        if (!hugePageConfiguration.supportsTHP()) {\n+            throw new SkippedException(\"THP is turned off\");\n+        }\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\"-XX:+Use\" + args[0] + \"GC\", \"-Xmx128m\", \"-Xms128m\", \"-Xlog:pagesize:thp-%p.log\", \"-XX:+UseTransparentHugePages\", VerifyTHPEnabledForHeap.class.getName());\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    class VerifyTHPEnabledForHeap {\n+\n+        public static void main(String args[]) throws Exception {\n+            String heapAddress = readHeapAddressInLog();\n+            Path smaps = makeSmapsCopy();\n+\n+            final Pattern heapSection = Pattern.compile(\"^\" + heapAddress + \".*\");\n+            final Pattern thpEligible = Pattern.compile(\"THPeligible:\\\\s+(\\\\d)\\\\s*\");\n+\n+            Scanner smapsFile = new Scanner(smaps);\n+            while (smapsFile.hasNextLine()) {\n+                Matcher heapMatcher = heapSection.matcher(smapsFile.nextLine());\n+\n+                if (heapMatcher.matches()) {\n+                    \/\/ Found the first heap section, verify that it is THP eligible\n+                    while (smapsFile.hasNextLine()) {\n+                        Matcher m = thpEligible.matcher(smapsFile.nextLine());\n+                        if (m.matches()) {\n+                            if (Integer.parseInt(m.group(1)) == 1) {\n+                                \/\/ THPeligible is 1, heap can be backed by huge pages\n+                                return;\n+                            }\n+\n+                            throw new RuntimeException(\"First heap section at 0x\" + heapAddress + \" is not THPeligible\");\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ Failed to verify THP for heap\n+            throw new RuntimeException(\"Could not find heap section in smaps file\");\n+        }\n+\n+        private static String readHeapAddressInLog() throws Exception {\n+            final Pattern heapAddress = Pattern.compile(\".* Heap: .*base=(0x[0-9A-Fa-f]*).*\");\n+\n+            Scanner logFile = new Scanner(Paths.get(\"thp-\" + ProcessHandle.current().pid() + \".log\"));\n+            while (logFile.hasNextLine()) {\n+                Matcher m = heapAddress.matcher(logFile.nextLine());\n+                if (m.matches()) {\n+                    return Long.toHexString(Long.decode(m.group(1)));\n+                }\n+            }\n+            throw new RuntimeException(\"Failed to parse heap address, failing test\");\n+        }\n+\n+        private static Path makeSmapsCopy() throws Exception {\n+            Path src = Paths.get(\"\/proc\/self\/smaps\");\n+            Path dest = Paths.get(\"smaps-copy-\" +  ProcessHandle.current().pid() + \".txt\");\n+            Files.copy(src, dest, StandardCopyOption.REPLACE_EXISTING);\n+            return dest;\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestTransparentHugePagesHeap.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm -XX:+UseG1GC -Xss32m -Xmx128m -XX:G1HeapRegionSize=1m\n+ * @run main\/othervm\/timeout=480 -XX:+UseG1GC -Xss32m -Xmx128m -XX:G1HeapRegionSize=1m\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGreyReclaimedHumongousObjects.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm\/timeout=240  -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=960  -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -64,1 +64,1 @@\n- *@run main\/othervm -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *@run main\/othervm\/timeout=480 -Xms256M -Xmx256M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousClassLoader.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480 -Xms128M -Xmx128M -XX:+UseG1GC -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/humongousObjects\/TestHumongousNonArrayAllocation.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run driver\/timeout=480 gc.g1.ihop.TestIHOPErgo\n+ * @run driver\/timeout=1920 gc.g1.ihop.TestIHOPErgo\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/ihop\/TestIHOPErgo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -62,1 +62,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestAllocObjects.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=240 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -106,1 +106,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xms1g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSieveObjects.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n@@ -59,1 +59,1 @@\n- * @run main\/othervm\/native -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ * @run main\/othervm\/native\/timeout=240 -Xmx1g -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestJNIGlobalRefs.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm\/timeout=700 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=1200 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,4 +34,4 @@\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseSerialGC\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseParallelGC\n- * @run driver gc.stress.TestReclaimStringsLeaksMemory -XX:+UseG1GC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseSerialGC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseParallelGC\n+ * @run driver\/timeout=480 gc.stress.TestReclaimStringsLeaksMemory -XX:+UseG1GC\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestReclaimStringsLeaksMemory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 4 3 1.1 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 4 3 1.1 120\n@@ -43,1 +43,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 16 5 2.1 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 16 5 2.1 120\n@@ -52,1 +52,1 @@\n- * @run driver\/timeout=180 gc.stress.TestStressG1Humongous 32 4 0.6 120\n+ * @run driver\/timeout=240 gc.stress.TestStressG1Humongous 32 4 0.6 120\n@@ -61,1 +61,1 @@\n- * @run driver\/timeout=900 gc.stress.TestStressG1Humongous 1 7 0.6 600\n+ * @run driver\/timeout=1200 gc.stress.TestStressG1Humongous 1 7 0.6 600\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressG1Humongous.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -71,1 +71,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -86,1 +86,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n@@ -101,1 +101,1 @@\n- * @run main\/othervm\/timeout=1800\n+ * @run main\/othervm\/timeout=7200\n@@ -116,1 +116,1 @@\n- * @run main\/othervm\/timeout=1800\n+ * @run main\/othervm\/timeout=7200\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestStressRSetCoarsening.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UseG1GC gc.stress.systemgc.TestSystemGCWithG1 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UseG1GC gc.stress.systemgc.TestSystemGCWithG1 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithG1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc=info -Xmx512m -XX:+UseParallelGC gc.stress.systemgc.TestSystemGCWithParallel 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc=info -Xmx512m -XX:+UseParallelGC gc.stress.systemgc.TestSystemGCWithParallel 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithParallel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UseSerialGC gc.stress.systemgc.TestSystemGCWithSerial 270\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithSerial.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n@@ -57,1 +57,1 @@\n- * @run main\/othervm\/timeout=300 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=540 -Xlog:gc*=info -Xmx512m -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/systemgc\/TestSystemGCWithShenandoah.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/*\n+ * @test id=Normal\n+ * @requires vm.gc.Z & vm.debug\n+ * @summary Test ZGC graceful failure when a commit fails\n+ * @library \/ \/test\/lib\n+ * @run driver gc.z.TestCommitFailure\n+ *\/\n+\n+\/*\n+ * @test id=ZFakeNUMA\n+ * @requires vm.gc.Z & vm.debug\n+ * @library \/ \/test\/lib\n+ * @summary Test ZGC graceful failure when a commit fails (with ZFakeNUMA)\n+ * @run driver gc.z.TestCommitFailure -XX:ZFakeNUMA=16\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import static gc.testlibrary.Allocation.blackHole;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class TestCommitFailure {\n+    static final int K = 1024;\n+    static final int M = 1024 * K;\n+\n+    static final int XMS = 128 * M;\n+    static final int XMX = 512 * M;\n+\n+    static class Test {\n+        static final int LARGE_ALLOC = 256 * M;\n+        static final int SMALL_GARBAGE = 256 * M;\n+        static final int SMALL_LIVE = 128 * M;\n+\n+        \/\/ Allocates at least totalLive bytes of objects and add them to list.\n+        static void allocLive(List<Object> list, int totalLive) {\n+            final int largePageAllocationSize = 6 * M;\n+            for (int live = 0; live < totalLive; live += largePageAllocationSize) {\n+                list.add(new byte[largePageAllocationSize - K]);\n+            }\n+        }\n+\n+        \/\/ Allocates at least totalGarbage bytes of garbage large pages.\n+        static void allocGarbage(int totalGarbage) {\n+            final int largePageAllocationSize = 6 * M;\n+            for (int garbage = 0; garbage < totalGarbage; garbage += largePageAllocationSize) {\n+                blackHole(new byte[largePageAllocationSize - K]);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            final var list = new ArrayList<Object>();\n+            try {\n+                \/\/ Fill heap with small live objects\n+                allocLive(list, SMALL_LIVE);\n+                \/\/ Fill with small garbage objects\n+                allocGarbage(SMALL_GARBAGE);\n+                \/\/ Allocate large objects where commit fails until an OOME is thrown\n+                while (true) {\n+                    list.add(new byte[LARGE_ALLOC - K]);\n+                }\n+            } catch (OutOfMemoryError oome) {}\n+            blackHole(list);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        final int xmxInM = XMX \/ M;\n+        final int xmsInM = XMS \/ M;\n+        final var arguments = new ArrayList(Arrays.asList(args));\n+        arguments.addAll(List.of(\n+            \"-XX:+UseZGC\",\n+            \"-Xlog:gc+init\",\n+            \"-XX:ZFailLargerCommits=\" + XMS,\n+            \"-Xms\" + xmsInM + \"M\",\n+            \"-Xmx\" + xmxInM + \"M\",\n+            Test.class.getName()));\n+\n+        ProcessTools.executeTestJava(arguments)\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestCommitFailure.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,2 @@\n+                \/\/ Disable NUMA to avoid potential OOM after JDK-8359683\n+                \"-XX:-UseNUMA\",\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestSmallHeap.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -XX:+UseZGC -Xlog:gc*,gc+heap=debug,gc+stats=off -Xms128M -Xmx512M -XX:ZUncommitDelay=5 gc.z.TestUncommit\n+ * @run main\/othervm\/timeout=480 -XX:+UseZGC -Xlog:gc*,gc+heap=debug,gc+stats=off -Xms128M -Xmx512M -XX:ZUncommitDelay=5 gc.z.TestUncommit\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestUncommit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/native GTestWrapper\n+ * @run main\/native\/timeout=480 GTestWrapper\n","filename":"test\/hotspot\/jtreg\/gtest\/GTestWrapper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n- * @run driver TestInheritFD\n+ * @run driver\/timeout=480 TestInheritFD\n@@ -81,0 +81,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -93,2 +95,1 @@\n-    public static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    public static long subProcessTimeout = (long)(15L * timeoutFactor);\n+    public static long subProcessTimeout = (long)(60L * Utils.TIMEOUT_FACTOR);\n","filename":"test\/hotspot\/jtreg\/runtime\/8176717\/TestInheritFD.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.cds.default.archive.available\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedCPUSpecificClassSpaceReservation.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp ArraysNewInstanceBug\n+ * @run main\/othervm\/timeout=480 -Xcomp ArraysNewInstanceBug\n","filename":"test\/hotspot\/jtreg\/runtime\/CreateMirror\/ArraysNewInstanceBug.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run driver CreateCoredumpOnCrash\n+ * @run driver\/timeout=480 CreateCoredumpOnCrash\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/CreateCoredumpOnCrash.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,5 @@\n-                pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"R0=.*\")};\n+                if (Platform.isLinux()) {\n+                    pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"R0=.*\")};\n+                } else if (Platform.isWindows()) {\n+                    pattern = new Pattern[] { Pattern.compile(\"Registers:\"), Pattern.compile(\"X0 =.*\")};\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ShowRegistersOnAssertTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests special\n+ * @run driver\/timeout=7200 invocationC1Tests special\n@@ -48,1 +48,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests virtual\n+ * @run driver\/timeout=7200 invocationC1Tests virtual\n@@ -61,1 +61,1 @@\n- * @run driver\/timeout=1800 invocationC1Tests interface\n+ * @run driver\/timeout=7200 invocationC1Tests interface\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationC1Tests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests current-int\n+ * @run driver\/timeout=5400 invokeinterfaceTests current-int\n@@ -50,1 +50,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests current-comp\n+ * @run driver\/timeout=5400 invokeinterfaceTests current-comp\n@@ -64,1 +64,1 @@\n- * @run driver\/timeout=1800 invokeinterfaceTests old-int\n+ * @run driver\/timeout=5400 invokeinterfaceTests old-int\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invokeinterfaceTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver TestResize\n+ * @run driver\/timeout=480 TestResize\n","filename":"test\/hotspot\/jtreg\/runtime\/LoadClass\/TestResize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -Xint -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail VirtualAllocCommitMerge\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -Xint -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail VirtualAllocCommitMerge\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/VirtualAllocCommitMerge.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceICCE\n+ * @run main\/othervm\/timeout=2000 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceICCE\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeInterfaceICCE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceSuccessTest\n+ * @run main\/othervm\/timeout=1200 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeInterfaceSuccessTest\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeInterfaceSuccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=1200 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualICCE\n+ * @run main\/othervm\/timeout=4800 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualICCE\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeVirtualICCE.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=400 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualSuccessTest\n+ * @run main\/othervm\/timeout=1600 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies InvokeVirtualSuccessTest\n","filename":"test\/hotspot\/jtreg\/runtime\/SelectionResolution\/InvokeVirtualSuccessTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm TestThreadDumpMonitorContention\n+ * @run main\/othervm\/timeout=480 TestThreadDumpMonitorContention\n@@ -53,0 +53,5 @@\n+    \/\/ jstack streaming output should be disabled because if the attach operation is executed at a safepoint,\n+    \/\/ the attach streaming output is enabled, and the tool output is lengthy, then we can get both buffers (the attach\n+    \/\/ channel and the tool redirection buffer) full and the test hangs.\n+    \/\/ Instead the attach operation output is buffered and is sent after the operation is completed.\n+    final static String DISABLE_STREAMING_OUTPUT = \"-J-Djdk.attach.allowStreamingOutput=false\";\n@@ -382,1 +387,1 @@\n-            Process process = new ProcessBuilder(JSTACK, PID)\n+            Process process = new ProcessBuilder(JSTACK, DISABLE_STREAMING_OUTPUT, PID)\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpMonitorContention.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-    private static boolean isCOHArchiveAvailable(char coops, char coh,\n-                                                 String archiveSuffix) throws Exception {\n+    private static boolean isArchiveAvailable(char coops, char coh,\n+                                              String archiveSuffix) throws Exception {\n@@ -116,0 +116,4 @@\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n+                    throw new SkippedException(\"Skipping test due to \" +\n+                                               archivePath(archiveSuffix).toString() + \" not available\");\n+                }\n@@ -121,1 +125,1 @@\n-                if (!isCOHArchiveAvailable(coops, coh, archiveSuffix)) {\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n@@ -130,0 +134,4 @@\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n+                    throw new SkippedException(\"Skipping test due to \" +\n+                                               archivePath(archiveSuffix).toString() + \" not available\");\n+                }\n@@ -134,1 +142,1 @@\n-                if (!isCOHArchiveAvailable(coops, coh, archiveSuffix)) {\n+                if (!isArchiveAvailable(coops, coh, archiveSuffix)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/TestDefaultArchiveLoading.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run driver\/timeout=500 LotsOfSyntheticClasses\n+ * @run driver\/timeout=8000 LotsOfSyntheticClasses\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfSyntheticClasses.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,9 +25,1 @@\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.BuildHelper;\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.cds.CDSOptions;\n-import jdk.test.lib.cds.CDSTestUtils;\n-import jdk.test.lib.cds.CDSTestUtils.Result;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n+import cdsutils.DynamicDumpHelper;\n@@ -37,1 +29,0 @@\n-import java.io.InputStream;\n@@ -39,0 +30,1 @@\n+import java.io.InputStream;\n@@ -41,1 +33,0 @@\n-import java.nio.file.Files;\n@@ -44,0 +35,1 @@\n+import java.nio.file.Files;\n@@ -47,1 +39,0 @@\n-import java.util.Arrays;\n@@ -49,0 +40,1 @@\n+import java.util.Arrays;\n@@ -56,0 +48,10 @@\n+import jdk.test.lib.BuildHelper;\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils.Result;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -57,1 +59,0 @@\n-import cdsutils.DynamicDumpHelper;\n@@ -79,3 +80,0 @@\n-    private static final String timeoutFactor =\n-        System.getProperty(\"test.timeout.factor\", \"1.0\");\n-\n@@ -423,1 +421,1 @@\n-        cmd.add(\"-Dtest.timeout.factor=\" + timeoutFactor);\n+        cmd.add(\"-Dtest.timeout.factor=\" + Utils.TIMEOUT_FACTOR);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.flagless\n@@ -40,1 +39,0 @@\n- * @requires vm.flagless\n@@ -61,6 +59,1 @@\n-        doTest(args, false);\n-\n-        if (Platform.is64bit()) {\n-            \/\/ There's no oop\/klass compression on 32-bit.\n-            doTest(args, true);\n-        }\n+        doTest(args);\n@@ -69,2 +62,2 @@\n-    public static void doTest(String[] args, boolean compressed) throws Exception {\n-        Tester tester = new Tester(compressed);\n+    public static void doTest(String[] args) throws Exception {\n+        Tester tester = new Tester();\n@@ -83,1 +76,0 @@\n-        boolean compressed;\n@@ -87,1 +79,1 @@\n-        public Tester(boolean compressed) {\n+        public Tester() {\n@@ -89,1 +81,0 @@\n-            this.compressed = compressed;\n@@ -91,2 +82,2 @@\n-            dumpMapFile = \"test\" + (compressed ? \"0\" : \"1\") + \".dump.aotmap\";\n-            runMapFile  = \"test\" + (compressed ? \"0\" : \"1\") + \".run.aotmap\";\n+            dumpMapFile = \"test\" + \"0\" + \".dump.aotmap\";\n+            runMapFile  = \"test\" + \"0\" + \".run.aotmap\";\n@@ -107,6 +98,0 @@\n-            if (Platform.is64bit()) {\n-                \/\/ These options are available only on 64-bit.\n-                String sign = (compressed) ?  \"+\" : \"-\";\n-                vmArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n-            }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/AOTMapTest.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ * @run driver\/timeout=480 jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n@@ -40,1 +40,1 @@\n- * @run driver AOTCodeCompressedOopsTest\n+ * @run driver\/timeout=480 AOTCodeCompressedOopsTest\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeCompressedOopsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run driver AOTProfileFlags\n+ * @run driver\/timeout=480 AOTProfileFlags\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+ * @requires vm.cds.nocoops.archive.available\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/loaderConstraints\/DynamicLoaderConstraintsTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver\/timeout=650 SharedStringsStress\n+ * @run driver\/timeout=2600 SharedStringsStress\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/SharedStringsStress.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- * @run testng\/othervm -Xcomp -XX:-TieredCompilation  ArrayIndexOutOfBoundsExceptionTest\n- * @run testng\/othervm -Xcomp -XX:TieredStopAtLevel=1 ArrayIndexOutOfBoundsExceptionTest\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation  ArrayIndexOutOfBoundsExceptionTest\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 ArrayIndexOutOfBoundsExceptionTest\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/ArrayIndexOutOfBoundsException\/ArrayIndexOutOfBoundsExceptionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n+ * @run main\/othervm\/timeout=480 -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/RedefineClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run driver StressAsyncUL\n+ * @run driver\/timeout=480 StressAsyncUL\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/StressAsyncUL.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Xmx128m ReflectOutOfMemoryError\n+ * @run main\/othervm\/timeout=480 -Xmx128m ReflectOutOfMemoryError\n","filename":"test\/hotspot\/jtreg\/runtime\/reflect\/ReflectOutOfMemoryError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run junit\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI --enable-native-access=ALL-UNNAMED UnmountedVThreadNativeMethodAtTop\n+ * @run junit\/othervm\/native\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI --enable-native-access=ALL-UNNAMED UnmountedVThreadNativeMethodAtTop\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/UnmountedVThreadNativeMethodAtTop.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm\/native -Xmx512m -agentlib:HeapMonitorTest MyPackage.HeapMonitorThreadTest\n+ * @run main\/othervm\/native\/timeout=480 -Xmx512m -agentlib:HeapMonitorTest MyPackage.HeapMonitorThreadTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorThreadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,3 @@\n- * @run main\/othervm\/native -agentlib:TagMapTest\n- *                          -Xlog:jvmti+table\n- *                          TagMapTest\n+ * @run main\/othervm\/native\/timeout=480 -agentlib:TagMapTest\n+ *                                      -Xlog:jvmti+table\n+ *                                      TagMapTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetTag\/TagMapTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n@@ -43,1 +43,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=700\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/SuspendResume2\/SuspendResume2.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=240 ClhsdbDumpheap\n+ * @run main\/othervm\/timeout=960 ClhsdbDumpheap\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpheap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC true false\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC true false\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC true true\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC true true\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC false false\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC false false\n@@ -77,1 +77,1 @@\n- * @run main\/othervm\/timeout=480 ClhsdbFindPC false true\n+ * @run main\/othervm\/timeout=1920 ClhsdbFindPC false true\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver\/timeout=300 ClhsdbJstackXcompStress\n+ * @run driver\/timeout=1200 ClhsdbJstackXcompStress\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbJstackXcompStress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm ClhsdbThreadContext\n+ * @run main\/othervm\/timeout=480 ClhsdbThreadContext\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbThreadContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver TestJhsdbJstackLineNumbers\n+ * @run driver\/timeout=480 TestJhsdbJstackLineNumbers\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackLineNumbers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver TestObjectAlignment\n+ * @run driver\/timeout=480 TestObjectAlignment\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestObjectAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run driver SADebugDTest\n+ * @run driver\/timeout=480 SADebugDTest\n@@ -128,1 +128,1 @@\n-                Process debugd = startProcess(\"debugd\", pb, null, l -> checkOutput(l, useRmiPort, rmiPort), 20, TimeUnit.SECONDS);\n+                Process debugd = startProcess(\"debugd\", pb, null, l -> checkOutput(l, useRmiPort, rmiPort), 80, TimeUnit.SECONDS);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/SADebugDTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,17 +46,1 @@\n-                    \"share\/adlc\",\n-                    \"share\/c1\",\n-                    \"share\/cds\",\n-                    \"share\/ci\",\n-                    \"share\/classfile\",\n-                    \"share\/code\",\n-                    \"share\/compiler\",\n-                    \"share\/interpreter\",\n-                    \"share\/jfr\",\n-                    \"share\/jvmci\",\n-                    \"share\/libadt\",\n-                    \"share\/logging\",\n-                    \"share\/metaprogramming\",\n-                    \"share\/oops\",\n-                    \"share\/opto\",\n-                    \"share\/services\",\n-                    \"share\/utilities\"\n+                    \"share\"\n","filename":"test\/hotspot\/jtreg\/sources\/TestIncludesAreSorted.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver ir_framework.tests.TestNotCompilable\n+ * @run driver\/timeout=480 ir_framework.tests.TestNotCompilable\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestNotCompilable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import java.util.Set;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test cross product scenarios with the framework.\n+ * @library \/test\/lib \/testlibrary_tests \/\n+ * @run driver ir_framework.tests.TestScenariosCrossProduct\n+ *\/\n+\n+public class TestScenariosCrossProduct {\n+    static void hasNFailures(String s, int count) {\n+        if (!s.matches(\"The following scenarios have failed: (#[0-9](, )?){\" + count + \"}. Please check stderr for more information.\")) {\n+            throw new RuntimeException(\"Expected \" + count + \" failures in \\\"\" + s + \"\\\"\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Test argument handling\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios((Set<String>[]) null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios(Set.of(\"foo\", \"bar\"), null);\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestFormatException e) {}\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios(Set.of(\"blub\"), Set.of(\"foo\", null));\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (NullPointerException e) {} \/\/ Set.of prevents null elements\n+        try {\n+            TestFramework t = new TestFramework();\n+            t.addCrossProductScenarios();\n+        } catch (TestFormatException e) {\n+            Asserts.fail(\"Should not have thrown exception\");\n+        }\n+\n+        \/\/ Single set should test all flags in the set by themselves.\n+        try {\n+            TestFramework t1 = new TestFramework();\n+            t1.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\",\n+                                               \"-XX:TLABRefillWasteFraction=53\",\n+                                               \"-XX:TLABRefillWasteFraction=64\"));\n+            t1.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n+        }\n+\n+        \/\/ The cross product of a set with one element and a set with three elements is three sets.\n+        try {\n+            TestFramework t2 = new TestFramework();\n+            t2.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\", \"-XX:+UseNewCode3\"));\n+            t2.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 3);\n+        }\n+\n+        \/\/ The cross product of two sets with two elements is four sets.\n+        try {\n+            TestFramework t3 = new TestFramework();\n+            t3.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=53\", \"-XX:TLABRefillWasteFraction=64\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:-UseNewCode\"));\n+            t3.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 4);\n+        }\n+\n+        \/\/ Test with a pair of flags.\n+        try {\n+            TestFramework t4 = new TestFramework();\n+            t4.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=50 -XX:+UseNewCode\", \"-XX:TLABRefillWasteFraction=40\"),\n+                                        Set.of(\"-XX:+UseNewCode2\"));\n+            t4.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 1);\n+        }\n+\n+        \/\/ Test with an empty string. All 6 scenarios fail because 64 is the default value for TLABRefillWasteFraction.\n+        try {\n+            TestFramework t5 = new TestFramework();\n+            t5.addCrossProductScenarios(Set.of(\"\", \"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            t5.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n+        }\n+\n+        try {\n+            TestFramework t6 = new TestFramework();\n+            t6.addScenarios(new Scenario(0, \"-XX:TLABRefillWasteFraction=50\", \"-XX:+UseNewCode\")); \/\/ failPair\n+            t6.addCrossProductScenarios(Set.of(\"-XX:TLABRefillWasteFraction=51\", \"-XX:TLABRefillWasteFraction=53\"),\n+                                        Set.of(\"-XX:+UseNewCode\", \"-XX:+UseNewCode2\"));\n+            try {\n+                t6.addScenarios(new Scenario(4, \"-XX:+UseNewCode3\")); \/\/ fails because index 4 is already used\n+            Asserts.fail(\"Should have thrown exception\");\n+            } catch (TestFormatException e) {}\n+            t6.addScenarios(new Scenario(5, \"-XX:+UseNewCode3\")); \/\/ fail default\n+            t6.start();\n+            Asserts.fail(\"Should have thrown exception\");\n+        } catch (TestRunException e) {\n+            hasNFailures(e.getMessage(), 6);\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"64\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failDefault() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail1() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"TLABRefillWasteFraction\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n+    public void fail2() {\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"TLABRefillWasteFraction\", \"50\", \"UseNewCode\", \"true\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failPair() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestScenariosCrossProduct.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_class\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_obj\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large001\/large001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large002\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large004\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @run main\/othervm\/timeout=300\n+ * @run main\/othervm\/timeout=1200\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/LargeObjects\/large005\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft004.soft004 -t 1\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.SoftReference.soft004.soft004 -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/SoftReference\/soft004\/soft004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak004.weak004 -t 1\n+ * @run main\/othervm\/timeout=480 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI gc.gctests.WeakReference.weak004.weak004 -t 1\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReference\/weak004\/weak004.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm gc.vector.SimpleGC.SimpleGC -ms low -gp circularList(low)\n+ * @run main\/othervm\/timeout=480 gc.vector.SimpleGC.SimpleGC -ms low -gp circularList(low)\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/vector\/CircularListLow\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run driver\/timeout=300 ExecDriver --java -server -Xcomp -XX:+DoEscapeAnalysis\n+ * @run driver\/timeout=1200 ExecDriver --java -server -Xcomp -XX:+DoEscapeAnalysis\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/escape\/AdaptiveBlocking\/AdaptiveBlocking001\/AdaptiveBlocking001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -41,1 +41,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/CompressedClassSpaceSize\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver metaspace.shrink_grow.ShrinkGrowMultiJVM.ShrinkGrowMultiJVM\n+ * @run driver\/timeout=480 metaspace.shrink_grow.ShrinkGrowMultiJVM.ShrinkGrowMultiJVM\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/shrink_grow\/ShrinkGrowMultiJVM\/ShrinkGrowMultiJVM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy001\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy002\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy004\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy005\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy006\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy007\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy008\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy009\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy010\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy011\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy012\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy013\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy014\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy015\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects001\/referringObjects001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * @run driver\n+ * @run driver\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/StepEvent\/_itself_\/stepEvent004\/stepEvent004.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n- * @run driver\n+ * @run driver\/timeout=480\n@@ -94,1 +94,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadDeathEvent\/thread\/thread001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -79,1 +79,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/stress\/serial\/mixed002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=420\n+ * @run main\/othervm\/timeout=1680\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdwp\/VirtualMachine\/HoldEvents\/holdevents002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\/native -agentlib:rawmnwait001 nsk.jvmti.RawMonitorWait.rawmnwait001\n+ * @run main\/othervm\/native\/timeout=480 -agentlib:rawmnwait001 nsk.jvmti.RawMonitorWait.rawmnwait001\n@@ -42,1 +42,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/RawMonitorWait\/rawmnwait001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -66,1 +66,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -66,1 +66,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP03\/sp03t002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP04\/sp04t002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -45,1 +45,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/sampling\/SP07\/sp07t001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n+ * @run main\/othervm\/timeout=480 nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n- * @run main\/othervm\/native nsk.monitoring.stress.thread.strace001 -threadCount=50 -depth=200\n+ * @run main\/othervm\/native\/timeout=480 nsk.monitoring.stress.thread.strace001 -threadCount=50 -depth=200\n@@ -65,1 +65,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -67,1 +67,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace002\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n- * @run main\/othervm\/native\n+ * @run main\/othervm\/native\/timeout=480\n@@ -68,1 +68,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/stress\/thread\/strace003\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\/native nsk.stress.strace.strace006\n+ * @run main\/othervm\/native\/timeout=480 nsk.stress.strace.strace006\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/strace\/strace006.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm nsk.stress.thread.thread001 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread001 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread001.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm nsk.stress.thread.thread002 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread002 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread002.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm nsk.stress.thread.thread005 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread005 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread005.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm nsk.stress.thread.thread006 500 2m 5s\n+ * @run main\/othervm\/timeout=480 nsk.stress.thread.thread006 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread006.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=300 nsk.stress.thread.thread007 500 2m 5s\n+ * @run main\/othervm\/timeout=1200 nsk.stress.thread.thread007 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread007.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 nsk.stress.thread.thread008 500 2m 5s\n+ * @run main\/othervm\/timeout=1200 nsk.stress.thread.thread008 500 2m 5s\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/thread\/thread008.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree001\/btree001.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree002\/btree002.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -53,1 +53,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree003\/btree003.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree004\/btree004.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree005\/btree005.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -52,1 +52,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree006\/btree006.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -47,1 +47,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree007\/btree007.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree008\/btree008.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -56,1 +56,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree009\/btree009.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -47,1 +47,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree010\/btree010.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree011\/btree011.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder btree\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder btree\n@@ -46,1 +46,1 @@\n- * @run driver nsk.sysdict.share.GenClassesBuilder fats\n+ * @run driver\/timeout=480 nsk.sysdict.share.GenClassesBuilder fats\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/vm\/stress\/btree\/btree012\/btree012.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/indy\/func\/jvmti\/mergeCP_indy2manyDiff_a\/TestDescription.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm -XX:CompileCommand=MemLimit,*.*,0 vm.mlvm.meth.stress.compiler.i2c_c2i.Test\n+ * @run main\/othervm\/timeout=480 -XX:CompileCommand=MemLimit,*.*,0 vm.mlvm.meth.stress.compiler.i2c_c2i.Test\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/i2c_c2i\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/meth\/stress\/compiler\/sequences\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java 8361521 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @library \/test\/lib\n@@ -50,0 +51,1 @@\n+import jdk.test.lib.Utils;\n@@ -62,3 +64,1 @@\n-            double timeoutFactor = Double.parseDouble(\n-                    System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-            timeout = (int) (timeout * timeoutFactor);\n+            timeout = (int) (timeout * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyFactory\/TestProviderLeak.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.test.lib.Utils;\n@@ -33,0 +34,1 @@\n+ * @library \/test\/lib\n@@ -287,2 +289,1 @@\n-                    float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-                    long sleepSeconds = (long)(20 * timeoutFactor);\n+                    long sleepSeconds = (long)(20 * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/com\/sun\/jdi\/InterruptHangTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,1 @@\n+    private static final String[] DEBUGGEE_OPTIONS = {\"-Xmx64M\"};\n@@ -118,1 +119,2 @@\n-        super(DEBUGGEE_CLASS);\n+        super(new LaunchOptions(DEBUGGEE_CLASS)\n+                .addDebuggeeOptions(DEBUGGEE_OPTIONS));\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbStopInNotificationThreadTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,3 +32,3 @@\n- * @run driver MethodEntryExitEvents SUSPEND_EVENT_THREAD MethodEntryExitEventsDebugee\n- * @run driver MethodEntryExitEvents SUSPEND_NONE MethodEntryExitEventsDebugee\n- * @run driver MethodEntryExitEvents SUSPEND_ALL MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_EVENT_THREAD MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_NONE MethodEntryExitEventsDebugee\n+ * @run driver\/timeout=480 MethodEntryExitEvents SUSPEND_ALL MethodEntryExitEventsDebugee\n","filename":"test\/jdk\/com\/sun\/jdi\/MethodEntryExitEvents.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xmx7m ThreadMemoryLeakTest\n+ * @run main\/othervm\/timeout=480 -Xmx7m ThreadMemoryLeakTest\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm LdapPoolTimeoutTest\n+ * @run testng\/othervm\/timeout=480 LdapPoolTimeoutTest\n@@ -147,1 +147,0 @@\n-\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapPoolTimeoutTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -57,6 +60,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -344,0 +341,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Bind.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @key intermittent\n@@ -48,0 +49,2 @@\n+import jtreg.SkippedException;\n+\n@@ -57,1 +60,1 @@\n-            throw new jtreg.SkippedException(\"SCTP protocol is not supported\");\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n@@ -66,1 +69,1 @@\n-            throw new jtreg.SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n+            throw new SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/CloseDescriptors.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -52,0 +53,2 @@\n+import jtreg.SkippedException;\n+\n@@ -64,6 +67,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -358,0 +355,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/CommUp.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -28,0 +29,1 @@\n+ * @run main\/timeout=480 Connect\n@@ -46,0 +48,2 @@\n+import jtreg.SkippedException;\n+\n@@ -53,6 +57,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -238,0 +236,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Connect.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -64,7 +67,0 @@\n-\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -352,0 +348,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Receive.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -48,0 +49,2 @@\n+import jtreg.SkippedException;\n+\n@@ -59,6 +62,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -267,0 +264,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/ReceiveIntoDirect.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -63,6 +66,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -454,0 +451,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Send.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -46,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -54,6 +57,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -275,0 +272,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/Shutdown.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -46,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -69,6 +72,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -193,0 +190,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpChannel\/SocketOptionTests.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -51,0 +52,2 @@\n+import jtreg.SkippedException;\n+\n@@ -61,6 +64,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -280,0 +277,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/Branch.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -41,0 +42,2 @@\n+import jtreg.SkippedException;\n+\n@@ -49,3 +52,1 @@\n-            System.out.println(\"SCTP protocol is not supported\");\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n@@ -60,3 +61,1 @@\n-            System.out.println(\"Cannot locate lsof in \" + lsofDirs);\n-            System.out.println(\"Test cannot be run\");\n-            return;\n+            throw new SkippedException(\"Cannot locate lsof in \" + lsofDirs);\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/CloseDescriptors.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -45,0 +46,2 @@\n+import jtreg.SkippedException;\n+\n@@ -55,6 +58,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -358,0 +355,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/Send.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -38,0 +39,2 @@\n+import jtreg.SkippedException;\n+\n@@ -48,6 +51,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -189,0 +186,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/SendFailed.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -54,0 +55,2 @@\n+import jtreg.SkippedException;\n+\n@@ -77,6 +80,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -247,0 +244,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpMultiChannel\/SocketOptionTests.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -44,0 +45,2 @@\n+import jtreg.SkippedException;\n+\n@@ -53,6 +56,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -265,0 +262,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpServerChannel\/Accept.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @library \/test\/lib\n@@ -28,0 +29,1 @@\n+ * @run main\/timeout=480 NonBlockingAccept\n@@ -45,0 +47,2 @@\n+import jtreg.SkippedException;\n+\n@@ -54,6 +58,0 @@\n-        if (!Util.isSCTPSupported()) {\n-            out.println(\"SCTP protocol is not supported\");\n-            out.println(\"Test cannot be run\");\n-            return;\n-        }\n-\n@@ -221,0 +219,4 @@\n+        if (!Util.isSCTPSupported()) {\n+            throw new SkippedException(\"SCTP protocol is not supported\");\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/nio\/sctp\/SctpServerChannel\/NonBlockingAccept.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8346952\n+ * @bug 8346952 8361521\n","filename":"test\/jdk\/java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/timeout=300\/othervm MTTest\n+ * @run main\/timeout=400\/othervm MTTest\n","filename":"test\/jdk\/java\/awt\/font\/NumericShaper\/MTTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run main TestMethodFinder\n+ * @run main\/timeout=480 TestMethodFinder\n","filename":"test\/jdk\/java\/beans\/XMLDecoder\/8028054\/TestMethodFinder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED StdLibTest\n+ * @run testng\/othervm\/timeout=480 --enable-native-access=ALL-UNNAMED StdLibTest\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,4 @@\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAccessModes\n+ * @run testng\/othervm\/timeout=480 -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAccessModes\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run junit TestBufferStackStress2\n+ * @run junit\/timeout=480 TestBufferStackStress2\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress2.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/foreign\/TestConcurrentClose.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @run main\/othervm\/timeout=10 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n+ * @run main\/othervm\/timeout=60 --enable-native-access=ALL-UNNAMED -Xlog:class+init TestDeadlock Arena\n","filename":"test\/jdk\/java\/foreign\/TestDeadlock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng TestMismatch\n+ * @run testng\/timeout=480 TestMismatch\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run testng\/othervm -Xmx6G TestStringEncodingJumbo\n+ * @run testng\/othervm\/timeout=480 -Xmx6G TestStringEncodingJumbo\n","filename":"test\/jdk\/java\/foreign\/TestStringEncodingJumbo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm\/native\n+ * @run testng\/othervm\/native\/timeout=480\n","filename":"test\/jdk\/java\/foreign\/TestStubAllocFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng\/othervm\/native -Xcheck:jni -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n+ * @run testng\/othervm\/native\/timeout=480 -Xcheck:jni -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStack.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED TestLoaderLookup\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED TestLoaderLookup\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm UnreferencedFISClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedFISClosesFd\n","filename":"test\/jdk\/java\/io\/FileInputStream\/UnreferencedFISClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main\/othervm UnreferencedFOSClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedFOSClosesFd\n","filename":"test\/jdk\/java\/io\/FileOutputStream\/UnreferencedFOSClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm UnreferencedRAFClosesFd\n+ * @run main\/othervm\/timeout=480 UnreferencedRAFClosesFd\n","filename":"test\/jdk\/java\/io\/RandomAccessFile\/UnreferencedRAFClosesFd.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main\/othervm --add-modules=ALL-SYSTEM FieldSetAccessibleTest\n+ * @run main\/othervm\/timeout=480 --add-modules=ALL-SYSTEM FieldSetAccessibleTest\n","filename":"test\/jdk\/java\/lang\/Class\/getDeclaredField\/FieldSetAccessibleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run junit IntegralPowTest\n+ * @run junit\/timeout=480 IntegralPowTest\n","filename":"test\/jdk\/java\/lang\/Math\/IntegralPowTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <errno.h>\n@@ -25,0 +26,3 @@\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys\/resource.h>\n@@ -27,0 +31,2 @@\n+static jint limit_num_fds();\n+\n@@ -29,0 +35,7 @@\n+  \/\/ Lower the number of possible open files to make the test go faster\n+  jint ret = limit_num_fds();\n+  if (ret != 0) {\n+    fprintf(stderr, \"Failed to limit number of fds: %s\", strerror(errno));\n+    return ret;\n+  }\n+\n@@ -32,0 +45,1 @@\n+    fprintf(stderr, \"Failed to open file: %s\", strerror(errno));\n@@ -34,0 +48,1 @@\n+\n@@ -37,0 +52,24 @@\n+\n+static jint limit_num_fds() {\n+  struct rlimit rl;\n+\n+  \/\/ Fetch the current limit\n+  int ret = getrlimit(RLIMIT_NOFILE, &rl);\n+  if (ret != 0) {\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Use a lower value unless it is already low\n+  rlim_t limit = 100;\n+  if (limit < rl.rlim_cur) {\n+    rl.rlim_cur = limit;\n+  }\n+\n+  \/\/ Lower the value\n+  int ret2 = setrlimit(RLIMIT_NOFILE, &rl);\n+  if (ret2 != 0) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/libFDLeaker.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,2 @@\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=POSIX_SPAWN UnblockSignals\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=POSIX_SPAWN -Xrs UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=POSIX_SPAWN UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=POSIX_SPAWN -Xrs UnblockSignals\n@@ -44,2 +44,2 @@\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=FORK UnblockSignals\n- * @run main\/othervm -Djdk.lang.Process.launchMechanism=FORK -Xrs UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=FORK UnblockSignals\n+ * @run main\/othervm\/timeout=480 -Djdk.lang.Process.launchMechanism=FORK -Xrs UnblockSignals\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/UnblockSignals.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run testng\/othervm -Xint -DtestUnused=true LocalsAndOperands\n- * @run testng\/othervm -Xcomp LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xint -DtestUnused=true LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xcomp LocalsAndOperands\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm -Xcomp -XX:-TieredCompilation LocalsAndOperands\n+ * @run testng\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation LocalsAndOperands\n","filename":"test\/jdk\/java\/lang\/StackWalker\/LocalsAndOperands.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,3 @@\n- * @run junit\/othervm -XX:+CompactStrings -Xmx8g MaxSizeUTF16String\n- * @run junit\/othervm -XX:-CompactStrings -Xmx8g MaxSizeUTF16String\n- * @run junit\/othervm -Xcomp -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -XX:+CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -XX:-CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm\/timeout=480 -Xcomp -Xmx8g MaxSizeUTF16String\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/MaxSizeUTF16String.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n- * @run testng\/othervm -XX:+CompactStrings CompactStringBuilder\n- * @run testng\/othervm -XX:-CompactStrings CompactStringBuilder\n- * @run testng\/othervm -Xcomp CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -XX:+CompactStrings CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -XX:-CompactStrings CompactStringBuilder\n+ * @run testng\/othervm\/timeout=480 -Xcomp CompactStringBuilder\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/CompactStringBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CancelTimerWithContention.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit\/othervm MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 MiscMonitorTests\n@@ -38,1 +38,1 @@\n- * @run junit\/othervm -Xint MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xint MiscMonitorTests\n@@ -46,1 +46,1 @@\n- * @run junit\/othervm -Xcomp MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp MiscMonitorTests\n@@ -54,1 +54,1 @@\n- * @run junit\/othervm -Xcomp -XX:TieredStopAtLevel=3 MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:TieredStopAtLevel=3 MiscMonitorTests\n@@ -63,1 +63,1 @@\n- * @run junit\/othervm -Xcomp -XX:-TieredCompilation MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation MiscMonitorTests\n@@ -71,1 +71,1 @@\n- * @run junit\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000 MiscMonitorTests\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockDiagnosticVMOptions -XX:+FullGCALot -XX:FullGCALotInterval=1000 MiscMonitorTests\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MiscMonitorTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorEnterExit\n@@ -57,1 +57,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorEnterExit\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorEnterExit\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm\/native -Xcomp --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n@@ -57,1 +57,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED MonitorWaitNotify\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit Parking\n+ * @run junit\/timeout=480 Parking\n@@ -36,1 +36,1 @@\n- * @run junit\/othervm -Xint Parking\n+ * @run junit\/othervm\/timeout=480 -Xint Parking\n@@ -43,1 +43,1 @@\n- * @run junit\/othervm -Xcomp Parking\n+ * @run junit\/othervm\/timeout=480 -Xcomp Parking\n@@ -50,1 +50,1 @@\n- * @run junit\/othervm -Xcomp -XX:-TieredCompilation Parking\n+ * @run junit\/othervm\/timeout=480 -Xcomp -XX:-TieredCompilation Parking\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Parking.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED RetryMonitorEnterWhenPinned\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/RetryMonitorEnterWhenPinned.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/timeout=200\/native --enable-native-access=ALL-UNNAMED Starvation 100000\n+ * @run main\/othervm\/timeout=800\/native --enable-native-access=ALL-UNNAMED Starvation 100000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Starvation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -39,1 +39,1 @@\n- * @run junit\/othervm\/native -Xint --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xint --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -47,1 +47,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:TieredStopAtLevel=1 --enable-native-access=ALL-UNNAMED SynchronizedNative\n@@ -55,1 +55,1 @@\n- * @run junit\/othervm\/native -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED SynchronizedNative\n+ * @run junit\/othervm\/native\/timeout=480 -Xcomp -XX:-TieredCompilation --enable-native-access=ALL-UNNAMED SynchronizedNative\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/SynchronizedNative.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED ThreadPollOnYield\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED ThreadPollOnYield\n@@ -39,1 +39,1 @@\n- * @run junit\/othervm\/native --enable-native-access=ALL-UNNAMED -Xcomp -XX:-TieredCompilation\n+ * @run junit\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED -Xcomp -XX:-TieredCompilation\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadPollOnYield.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 100000\n+ * @run main\/othervm\/timeout=1200 GetStackTraceALotWhenBlocking 100000\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\/timeout=300 GetStackTraceALotWhenBlocking 50000\n+ * @run main\/othervm\/timeout=1200 GetStackTraceALotWhenBlocking 50000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenBlocking.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main GetStackTraceALotWithTimedWait 100000\n+ * @run main\/timeout=480 GetStackTraceALotWithTimedWait 100000\n@@ -34,1 +34,1 @@\n- * @run main GetStackTraceALotWithTimedWait 50000\n+ * @run main\/timeout=480 GetStackTraceALotWithTimedWait 50000\n@@ -91,1 +91,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWithTimedWait.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=300 ParkALot 300000\n+ * @run main\/othervm\/timeout=1200 ParkALot 300000\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 ParkALot 100000\n+ * @run main\/othervm\/timeout=1200 ParkALot 100000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/ParkALot.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/native --enable-native-access=ALL-UNNAMED PinALot 500000\n+ * @run main\/othervm\/native\/timeout=480 --enable-native-access=ALL-UNNAMED PinALot 500000\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/native\/timeout=300 --enable-native-access=ALL-UNNAMED PinALot 200000\n+ * @run main\/othervm\/native\/timeout=1200 --enable-native-access=ALL-UNNAMED PinALot 200000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/PinALot.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm\/timeout=400 -Xmx1500m Skynet\n+ * @run main\/othervm\/timeout=1600 -Xmx1500m Skynet\n@@ -35,1 +35,1 @@\n- * @run main\/othervm\/timeout=400 -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm\/timeout=1600 -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=300 Skynet100kWithMonitors 50\n+ * @run main\/othervm\/timeout=1200 Skynet100kWithMonitors 50\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/timeout=300 Skynet100kWithMonitors 10\n+ * @run main\/othervm\/timeout=1200 Skynet100kWithMonitors 10\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet100kWithMonitors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main SleepALot 500000\n+ * @run main\/timeout=480 SleepALot 500000\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=300 SleepALot 200000\n+ * @run main\/othervm\/timeout=1200 SleepALot 200000\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/SleepALot.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng LoaderLeakTest\n+ * @run testng\/timeout=480 LoaderLeakTest\n","filename":"test\/jdk\/java\/lang\/annotation\/LoaderLeakTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng ConvertTest\n- *\/\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.ConstantBootstraps;\n-import java.math.BigInteger;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class ConvertTest {\n-\n-    @DataProvider\n-    public static Object[][] cceInputs() {\n-        return new Object[][]{\n-            { void.class, null },\n-            { Integer.class, \"a\" },\n-            { int.class, BigInteger.ZERO },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"cceInputs\", expectedExceptions = ClassCastException.class)\n-    public void testBadConversion(Class<?> dstType, Object value) {\n-        ConstantBootstraps.explicitCast(null, null, dstType, value);\n-    }\n-\n-    @DataProvider\n-    public static Object[][] goodInputs() {\n-        Object o = new Object();\n-        return new Object[][]{\n-            { Object.class, null, null },\n-            { Object.class, o, o },\n-            { String.class, \"abc\", \"abc\" },\n-            { short.class, 10, (short) 10 },\n-            { int.class, (short) 10, 10 },\n-            { boolean.class, 1, true },\n-            { boolean.class, 2, false },\n-            { int.class, true, 1 },\n-            { int.class, false, 0 },\n-            { int.class, 10, 10 },\n-            { Integer.class, 10, 10 },\n-            { Object.class, 10, 10 },\n-            { Number.class, 10, 10 },\n-        };\n-    }\n-\n-    @Test(dataProvider = \"goodInputs\")\n-    public void testSuccess(Class<?> dstType, Object value, Object expected) {\n-        Object actual = ConstantBootstraps.explicitCast(null, null, dstType, value);\n-        assertEquals(actual, expected);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/constant\/ConvertTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,2 @@\n-  * @run main TestLambdaFormCustomization\n-  * @run main\/othervm -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=0 TestLambdaFormCustomization\n+  * @run main\/timeout=480 TestLambdaFormCustomization\n+  * @run main\/othervm\/timeout=480 -Djava.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD=0 TestLambdaFormCustomization\n","filename":"test\/jdk\/java\/lang\/invoke\/TestLambdaFormCustomization.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8186046 8195694\n+ * @bug 8186046 8195694 8241100 8364751\n@@ -34,0 +34,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -244,0 +245,41 @@\n+\n+    @DataProvider\n+    public static Object[][] cceCasts() {\n+        return new Object[][]{\n+                { void.class, null },\n+                { Integer.class, \"a\" },\n+                { int.class, BigInteger.ZERO },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"cceCasts\", expectedExceptions = ClassCastException.class)\n+    public void testBadCasts(Class<?> dstType, Object value) {\n+        ConstantBootstraps.explicitCast(null, null, dstType, value);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] validCasts() {\n+        Object o = new Object();\n+        return new Object[][]{\n+                { Object.class, null, null },\n+                { Object.class, o, o },\n+                { String.class, \"abc\", \"abc\" },\n+                { short.class, 10, (short) 10 },\n+                { int.class, (short) 10, 10 },\n+                { boolean.class, 1, true },\n+                { boolean.class, 2, false },\n+                { int.class, true, 1 },\n+                { int.class, false, 0 },\n+                { int.class, 10, 10 },\n+                { Integer.class, 10, 10 },\n+                { Object.class, 10, 10 },\n+                { Number.class, 10, 10 },\n+                { char.class, null, (char) 0 }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"validCasts\")\n+    public void testSuccessfulCasts(Class<?> dstType, Object value, Object expected) {\n+        Object actual = ConstantBootstraps.explicitCast(null, null, dstType, value);\n+        assertEquals(actual, expected);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/condy\/ConstantBootstrapsTest.java","additions":44,"deletions":2,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng\/othervm\/timeout=180 IllegalArgumentsTest\n+ * @run testng\/othervm\/timeout=720 IllegalArgumentsTest\n","filename":"test\/jdk\/java\/lang\/reflect\/IllegalArgumentsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Xmx4g LargeValueExceptions\n+ * @run testng\/othervm\/timeout=480 -Xmx4g LargeValueExceptions\n","filename":"test\/jdk\/java\/math\/BigInteger\/LargeValueExceptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm UnreferencedDatagramSockets\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedDatagramSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedDatagramSockets\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/UnreferencedDatagramSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,0 @@\n-\n-\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackModeIPv4.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedMulticastSockets\n- * @run main\/othervm UnreferencedMulticastSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedMulticastSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedMulticastSockets\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/UnreferencedMulticastSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @run main\/othervm UnreferencedSockets\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true UnreferencedSockets\n+ * @run main\/othervm\/timeout=480 UnreferencedSockets\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true UnreferencedSockets\n","filename":"test\/jdk\/java\/net\/ServerSocket\/UnreferencedSockets.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @run main CloseAvailable\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true CloseAvailable\n+ * @run main\/timeout=480 CloseAvailable\n+ * @run main\/othervm\/timeout=480 -Djava.net.preferIPv4Stack=true CloseAvailable\n","filename":"test\/jdk\/java\/net\/Socket\/CloseAvailable.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n- * @run testng\/othervm AsFileDownloadTest\n+ * @run testng\/othervm\/timeout=480 AsFileDownloadTest\n","filename":"test\/jdk\/java\/net\/httpclient\/AsFileDownloadTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n- * @run testng\/othervm -Djdk.internal.httpclient.debug=true BufferingSubscriberTest\n+ * @run testng\/othervm\/timeout=480 -Djdk.internal.httpclient.debug=true BufferingSubscriberTest\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferingSubscriberTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,2 +62,2 @@\n- * @run main\/othervm  CancelledResponse\n- * @run main\/othervm  CancelledResponse SSL\n+ * @run main\/othervm\/timeout=480 CancelledResponse\n+ * @run main\/othervm\/timeout=480 CancelledResponse SSL\n","filename":"test\/jdk\/java\/net\/httpclient\/CancelledResponse.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,708 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies `HttpRequest.BodyPublishers::ofFileChannel`\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit FileChannelPublisherTest\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpResponse.BodyHandlers.discarding;\n+import static java.net.http.HttpResponse.BodyHandlers.ofInputStream;\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FileChannelPublisherTest {\n+\n+    private static final String CLASS_NAME = FileChannelPublisherTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final int DEFAULT_BUFFER_SIZE = Utils.getBuffer().capacity();\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    private static final HttpClient CLIENT = HttpClient.newBuilder().sslContext(SSL_CONTEXT).proxy(NO_PROXY).build();\n+\n+    private static final ExecutorService EXECUTOR = Executors.newCachedThreadPool();\n+\n+    private static final ServerRequestPair\n+            HTTP1 = ServerRequestPair.of(Version.HTTP_1_1, false),\n+            HTTPS1 = ServerRequestPair.of(Version.HTTP_1_1, true),\n+            HTTP2 = ServerRequestPair.of(Version.HTTP_2, false),\n+            HTTPS2 = ServerRequestPair.of(Version.HTTP_2, true);\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private record ServerRequestPair(\n+            String serverName,\n+            HttpTestServer server,\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes,\n+            HttpRequest.Builder requestBuilder,\n+            boolean secure) {\n+\n+        private static CountDownLatch SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+\n+        private static CountDownLatch SERVER_READ_PERMISSION = null;\n+\n+        private static ServerRequestPair of(Version version, boolean secure) {\n+\n+            \/\/ Create the server\n+            SSLContext sslContext = secure ? SSL_CONTEXT : null;\n+            HttpTestServer server = createServer(version, sslContext);\n+            String serverName = secure ? version.toString().replaceFirst(\"_\", \"S_\") : version.toString();\n+\n+            \/\/ Add the handler\n+            String handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            BlockingQueue<byte[]> serverReadRequestBodyBytes =\n+                    addRequestBodyConsumingServerHandler(serverName, server, handlerPath);\n+\n+            \/\/ Create the request builder\n+            String requestUriScheme = secure ? \"https\" : \"http\";\n+            \/\/ `x` suffix in the URI is not a typo, but ensures that *only* the parent handler path is matched\n+            URI requestUri = URI.create(\"%s:\/\/%s%sx\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+            HttpRequest.Builder requestBuilder = HttpRequest.newBuilder(requestUri).version(version);\n+\n+            \/\/ Create the pair\n+            ServerRequestPair pair = new ServerRequestPair(serverName, server, serverReadRequestBodyBytes, requestBuilder, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", pair, server.serverAuthority());\n+\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                \/\/ The default HTTP\/1.1 test server processes requests sequentially.\n+                \/\/ This causes a deadlock for concurrent tests such as `testSlicedUpload()`.\n+                \/\/ Hence, explicitly providing a multithreaded executor for HTTP\/1.1.\n+                ExecutorService executor = Version.HTTP_1_1.equals(version) ? EXECUTOR : null;\n+                return HttpTestServer.create(version, sslContext, executor);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n+        }\n+\n+        private static BlockingQueue<byte[]> addRequestBodyConsumingServerHandler(\n+                String serverName, HttpTestServer server, String handlerPath) {\n+            BlockingQueue<byte[]> readRequestBodyBytes = new LinkedBlockingQueue<>();\n+            HttpTestHandler handler = exchange -> {\n+                \/\/ `HttpTestExchange::toString` changes on failure, pin it\n+                String exchangeName = exchange.toString();\n+                try (exchange) {\n+\n+                    \/\/ Discard `HEAD` requests used for initial connection admission\n+                    if (\"HEAD\".equals(exchange.getRequestMethod())) {\n+                        exchange.sendResponseHeaders(200, -1L);\n+                        return;\n+                    }\n+\n+                    signalServerRequestReceived(serverName, exchangeName);\n+                    awaitServerReadPermission(serverName, exchangeName);\n+\n+                    LOGGER.log(\"Server[%s] is reading the request body (exchange=%s)\", serverName, exchangeName);\n+                    byte[] requestBodyBytes = exchange.getRequestBody().readAllBytes();\n+                    LOGGER.log(\"Server[%s] has read %s bytes (exchange=%s)\", serverName, requestBodyBytes.length, exchangeName);\n+                    readRequestBodyBytes.add(requestBodyBytes);\n+\n+                    LOGGER.log(\"Server[%s] is writing the response (exchange=%s)\", serverName, exchangeName);\n+                    exchange.sendResponseHeaders(200, requestBodyBytes.length);\n+                    exchange.getResponseBody().write(requestBodyBytes);\n+\n+                } catch (Throwable exception) {\n+                    LOGGER.log(\n+                            \"Server[%s] failed to process the request (exchange=%s)\".formatted(serverName, exception),\n+                            exception);\n+                    readRequestBodyBytes.add(new byte[0]);\n+                } finally {\n+                    LOGGER.log(\"Server[%s] completed processing the request (exchange=%s)\", serverName, exchangeName);\n+                }\n+            };\n+            server.addHandler(handler, handlerPath);\n+            return readRequestBodyBytes;\n+        }\n+\n+        private static void signalServerRequestReceived(String serverName, String exchangeName) {\n+            if (SERVER_REQUEST_RECEIVED_SIGNAL != null) {\n+                LOGGER.log(\"Server[%s] is signaling that the request is received (exchange=%s)\", serverName, exchangeName);\n+                SERVER_REQUEST_RECEIVED_SIGNAL.countDown();\n+            }\n+        }\n+\n+        private static void awaitServerReadPermission(String serverName, String exchangeName) {\n+            if (SERVER_READ_PERMISSION != null) {\n+                LOGGER.log(\"Server[%s] is waiting for the read permission (exchange=%s)\", serverName, exchangeName);\n+                try {\n+                    SERVER_READ_PERMISSION.await();\n+                } catch (InterruptedException ie) {\n+                    Thread.currentThread().interrupt();     \/\/ Restore the `interrupted` flag\n+                    throw new RuntimeException(ie);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return serverName;\n+        }\n+\n+    }\n+\n+    @AfterAll\n+    static void shutDown() {\n+        LOGGER.log(\"Closing the client\");\n+        CLIENT.close();\n+        LOGGER.log(\"Closing servers\");\n+        closeServers();\n+        LOGGER.log(\"Closing the executor\");\n+        EXECUTOR.shutdownNow();\n+    }\n+\n+    private static void closeServers() {\n+        Exception[] exceptionRef = {null};\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .map(pair -> (Runnable) pair.server::stop)\n+                .forEach(terminator -> {\n+                    try {\n+                        terminator.run();\n+                    } catch (Exception exception) {\n+                        if (exceptionRef[0] == null) {\n+                            exceptionRef[0] = exception;\n+                        } else {\n+                            exceptionRef[0].addSuppressed(exception);\n+                        }\n+                    }\n+                });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"failed closing one or more server resources\", exceptionRef[0]);\n+        }\n+    }\n+\n+    \/**\n+     * Resets {@link ServerRequestPair#serverReadRequestBodyBytes()} to avoid leftover state from a test leaking to the next.\n+     *\/\n+    @BeforeEach\n+    void resetServerHandlerResults() {\n+        Stream\n+                .of(HTTP1, HTTPS1, HTTP2, HTTPS2)\n+                .forEach(pair -> pair.serverReadRequestBodyBytes.clear());\n+    }\n+\n+    static ServerRequestPair[] serverRequestPairs() {\n+        return new ServerRequestPair[]{\n+                HTTP1,\n+                HTTPS1,\n+                HTTP2,\n+                HTTPS2\n+        };\n+    }\n+\n+    @Test\n+    void testNullFileChannel() {\n+        assertThrows(NullPointerException.class, () -> BodyPublishers.ofFileChannel(null, 0, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+            \"6,-1,1\",   \/\/ offset < 0\n+            \"6,7,1\",    \/\/ offset > fileSize\n+            \"6,0,-1\",   \/\/ length < 0\n+            \"6,0,7\",    \/\/ length > fileSize\n+            \"6,2,5\"     \/\/ (offset + length) > fileSize\n+    })\n+    void testIllegalOffsetOrLength(\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength,\n+            @TempDir Path tempDir) throws Exception {\n+        withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, (_, fileChannel) ->\n+                assertThrows(\n+                        IndexOutOfBoundsException.class,\n+                        () -> BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength)));\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>smaller<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentLessThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length smaller than the default buffer size\n+        int fileLength = 6;\n+        assertTrue(fileLength < DEFAULT_BUFFER_SIZE);\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range to stress the inclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength - 1)` sub-range to stress the exclusion of EOF\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = fileLength - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    \/**\n+     * Stresses corner cases in {@linkplain\n+     * BodyPublishers#ofFileChannel(FileChannel, long, long) the file channel\n+     * publisher}, which uses a {@linkplain #DEFAULT_BUFFER_SIZE fixed size}\n+     * buffer to read files, by providing sub-ranges and files that are\n+     * <em>bigger<\/em> than the buffer size.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testContentMoreThanBufferSize(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Use a file of length that is\n+        \/\/ 1. greater than the default buffer size\n+        \/\/ 2. *not* a multitude of the buffer size\n+        int fileLength = 1 + 3 * DEFAULT_BUFFER_SIZE;\n+\n+        \/\/ Publish the `[0, fileLength)` sub-range\n+        testSuccessfulContentDelivery(\n+                \"Complete content\",\n+                pair, tempDir, fileLength, 0, fileLength);\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 1;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies exactly 3 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 1;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertEquals(\n+                    fileLength - fileChannelOffset, fileChannelLength,\n+                    \"must be until EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content until the EOF. Occupies 3 buffers, the last is custom sized. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 2 * DEFAULT_BUFFER_SIZE;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies exactly 2 buffers. \" + debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+        \/\/ Publish the `[1, fileLength)` sub-range such that\n+        \/\/ - EOF is *not* included\n+        \/\/ - the total length is *not* a multitude of the buffer size\n+        {\n+            int fileChannelOffset = 2;\n+            int fileChannelLength = 3 * DEFAULT_BUFFER_SIZE - 2;\n+            String debuggingContext = debuggingContext(fileLength, fileChannelOffset, fileChannelLength);\n+            assertTrue(\n+                    fileLength - fileChannelOffset > fileChannelLength,\n+                    \"must end before EOF \" + debuggingContext);\n+            testSuccessfulContentDelivery(\n+                    \"Partial content *before* the EOF. Occupies 3 buffers, the last is custom sized. \"+ debuggingContext,\n+                    pair, tempDir, fileLength, fileChannelOffset, fileChannelLength);\n+        }\n+\n+    }\n+\n+    private static String debuggingContext(int fileLength, int fileChannelOffset, int fileChannelLength) {\n+        Map<String, Object> context = new LinkedHashMap<>();    \/\/ Using `LHM` to preserve the insertion order\n+        context.put(\"DEFAULT_BUFFER_SIZE\", DEFAULT_BUFFER_SIZE);\n+        context.put(\"fileLength\", fileLength);\n+        context.put(\"fileChannelOffset\", fileChannelOffset);\n+        context.put(\"fileChannelLength\", fileChannelLength);\n+        boolean customSizedBuffer = fileChannelLength % DEFAULT_BUFFER_SIZE == 0;\n+        context.put(\"customSizedBuffer\", customSizedBuffer);\n+        return context.toString();\n+    }\n+\n+    private void testSuccessfulContentDelivery(\n+            String caseDescription,\n+            ServerRequestPair pair,\n+            Path tempDir,\n+            int fileLength,\n+            int fileChannelOffset,\n+            int fileChannelLength) throws Exception {\n+\n+        \/\/ Case names come handy even when no debug logging is enabled.\n+        \/\/ Hence, intentionally avoiding `Logger`.\n+        System.err.printf(\"Case: %s%n\", caseDescription);\n+\n+        \/\/ Create the file to upload\n+        String fileName = \"data-%d-%d-%d.txt\".formatted(fileLength, fileChannelOffset, fileChannelLength);\n+        Path filePath = tempDir.resolve(fileName);\n+        withFileChannel(filePath, fileLength, (fileBytes, fileChannel) -> {\n+\n+            \/\/ Upload the file\n+            HttpRequest request = pair\n+                    .requestBuilder\n+                    .POST(BodyPublishers.ofFileChannel(fileChannel, fileChannelOffset, fileChannelLength))\n+                    .build();\n+            CLIENT.send(request, discarding());\n+\n+            \/\/ Verify the received request body\n+            byte[] expectedRequestBodyBytes = new byte[fileChannelLength];\n+            System.arraycopy(fileBytes, fileChannelOffset, expectedRequestBodyBytes, 0, fileChannelLength);\n+            byte[] actualRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+            assertArrayEquals(expectedRequestBodyBytes, actualRequestBodyBytes);\n+\n+        });\n+\n+    }\n+\n+    \/**\n+     * <em>Big enough<\/em> file length to observe the effects of publisher state corruption while uploading.\n+     * <p>\n+     * Certain tests follow below steps:\n+     * <\/p>\n+     * <ol>\n+     * <li>Issue the request<\/li>\n+     * <li>Wait for the server's signal that the request (not the body!) is received<\/li>\n+     * <li>Corrupt the publisher's state; modify the file, close the file channel, etc.<\/li>\n+     * <li>Signal the server to proceed with reading<\/li>\n+     * <\/ol>\n+     * <p>\n+     * With small files, even before we permit the server to read (step 4), file gets already uploaded.\n+     * This voids the effect of state corruption (step 3).\n+     * To circumvent this, use this <em>big enough<\/em> file size.\n+     * <\/p>\n+     *\n+     * @see #testChannelCloseDuringPublisherRead(ServerRequestPair, Path)\n+     * @see #testFileModificationDuringPublisherRead(ServerRequestPair, Path)\n+     *\/\n+    private static final int BIG_FILE_LENGTH = 8 * 1024 * 1024;  \/\/ 8 MiB\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testChannelCloseDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            AtomicReference<Future<HttpResponse<Void>>> responseFutureRef = new AtomicReference<>();\n+            withFileChannel(tempDir.resolve(\"data.txt\"), fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                responseFutureRef.set(CLIENT.sendAsync(request, discarding()));\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+            }));\n+\n+            LOGGER.log(\"File channel is closed\");\n+\n+            \/\/ Let the server proceed\n+            LOGGER.log(\"Permitting the server to proceed\");\n+            ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+            \/\/ Verifying the client failure\n+            LOGGER.log(\"Verifying the client failure\");\n+            Exception requestFailure0 = assertThrows(ExecutionException.class, () -> responseFutureRef.get().get());\n+            Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+            assertInstanceOf(ClosedChannelException.class, requestFailure1.getCause());\n+\n+            verifyServerIncompleteRead(pair, fileLength);\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testFileModificationDuringPublisherRead(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+        establishInitialConnection(pair);\n+        ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = new CountDownLatch(1);\n+        ServerRequestPair.SERVER_READ_PERMISSION = new CountDownLatch(1);\n+        try {\n+\n+            int fileLength = BIG_FILE_LENGTH;\n+            Path filePath = tempDir.resolve(\"data.txt\");\n+            withFileChannel(filePath, fileLength, ((_, fileChannel) -> {\n+\n+                \/\/ Issue the request\n+                LOGGER.log(\"Issuing the request\");\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, 0, fileLength))\n+                        .build();\n+                Future<HttpResponse<Void>> responseFuture = CLIENT.sendAsync(request, discarding());\n+\n+                \/\/ Wait for server to receive the request\n+                LOGGER.log(\"Waiting for the request to be received\");\n+                ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL.await();\n+\n+                \/\/ Modify the file\n+                LOGGER.log(\"Modifying the file\");\n+                Files.write(filePath, generateFileBytes(1));\n+\n+                \/\/ Let the server proceed\n+                LOGGER.log(\"Permitting the server to proceed\");\n+                ServerRequestPair.SERVER_READ_PERMISSION.countDown();\n+\n+                \/\/ Verifying the client failure\n+                LOGGER.log(\"Verifying the client failure\");\n+                Exception requestFailure0 = assertThrows(ExecutionException.class, responseFuture::get);\n+                Exception requestFailure1 = assertInstanceOf(UncheckedIOException.class, requestFailure0.getCause());\n+                Exception requestFailure2 = assertInstanceOf(IOException.class, requestFailure1.getCause());\n+                String requestFailure2Message = requestFailure2.getMessage();\n+                assertTrue(\n+                        requestFailure2Message.contains(\"Unexpected EOF\"),\n+                        \"unexpected message: \" + requestFailure2Message);\n+\n+                verifyServerIncompleteRead(pair, fileLength);\n+\n+            }));\n+\n+        } finally {\n+            ServerRequestPair.SERVER_REQUEST_RECEIVED_SIGNAL = null;\n+            ServerRequestPair.SERVER_READ_PERMISSION = null;\n+        }\n+    }\n+\n+    private static void verifyServerIncompleteRead(ServerRequestPair pair, int fileLength) throws InterruptedException {\n+        LOGGER.log(\"Verifying the server's incomplete read\");\n+        byte[] readRequestBodyBytes = pair.serverReadRequestBodyBytes.take();\n+        assertTrue(\n+                readRequestBodyBytes.length < fileLength,\n+                \"was expecting `readRequestBodyBytes < fileLength` (%s < %s)\".formatted(\n+                        readRequestBodyBytes.length, fileLength));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"serverRequestPairs\")\n+    void testSlicedUpload(ServerRequestPair pair, @TempDir Path tempDir) throws Exception {\n+\n+        \/\/ Populate the file\n+        int sliceCount = 4;\n+        int sliceLength = 14_281; \/\/ Intentionally using a prime number to increase the chances of hitting corner cases\n+        int fileLength = sliceCount * sliceLength;\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Path filePath = tempDir.resolve(\"data.txt\");\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+\n+        List<InputStream> responseBodyStreams = new ArrayList<>(sliceCount);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+\n+            \/\/ Upload the complete file in mutually exclusive slices\n+            List<Future<HttpResponse<InputStream>>> responseFutures = new ArrayList<>(sliceCount);\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Issuing request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpRequest request = pair\n+                        .requestBuilder\n+                        .POST(BodyPublishers.ofFileChannel(fileChannel, sliceIndex * sliceLength, sliceLength))\n+                        .build();\n+                responseFutures.add(CLIENT.sendAsync(\n+                        request,\n+                        \/\/ Intentionally using an `InputStream` response\n+                        \/\/ handler to defer consuming the response body\n+                        \/\/ until after the file channel is closed:\n+                        ofInputStream()));\n+            }\n+\n+            \/\/ Collect response body `InputStream`s from all requests\n+            for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+                LOGGER.log(\"Collecting response body `InputStream` for request %d\/%d\", (sliceIndex + 1), sliceCount);\n+                HttpResponse<InputStream> response = responseFutures.get(sliceIndex).get();\n+                assertEquals(200, response.statusCode());\n+                responseBodyStreams.add(response.body());\n+            }\n+\n+        }\n+\n+        LOGGER.log(\"File channel is closed\");\n+\n+        \/\/ Verify response bodies\n+        for (int sliceIndex = 0; sliceIndex < sliceCount; sliceIndex++) {\n+            LOGGER.log(\"Consuming response body %d\/%d\", (sliceIndex + 1), sliceCount);\n+            byte[] expectedResponseBodyBytes = new byte[sliceLength];\n+            System.arraycopy(fileBytes, sliceIndex * sliceLength, expectedResponseBodyBytes, 0, sliceLength);\n+            try (InputStream responseBodyStream = responseBodyStreams.get(sliceIndex)) {\n+                byte[] responseBodyBytes = responseBodyStream.readAllBytes();\n+                assertArrayEquals(expectedResponseBodyBytes, responseBodyBytes);\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * Performs the initial {@code HEAD} request to the specified server. This\n+     * effectively admits a connection to the client's pool, where all protocol\n+     * upgrades, handshakes, etc. are already performed.\n+     * <p>\n+     * HTTP\/2 test server consumes the complete request payload in the very\n+     * first upgrade frame. That is, if a client sends 100 MiB of data, all\n+     * of it will be consumed first before the configured handler is\n+     * invoked. Though certain tests expect the data to be consumed\n+     * piecemeal. To accommodate this, we ensure client has an upgraded\n+     * connection in the pool.\n+     * <\/p>\n+     *\/\n+    private static void establishInitialConnection(ServerRequestPair pair) {\n+        LOGGER.log(\"Server[%s] is getting queried for the initial connection pool admission\", pair);\n+        try {\n+            CLIENT.send(pair.requestBuilder.HEAD().build(), discarding());\n+        } catch (Exception exception) {\n+            throw new RuntimeException(exception);\n+        }\n+    }\n+\n+    private static void withFileChannel(Path filePath, int fileLength, FileChannelConsumer fileChannelConsumer) throws Exception {\n+        byte[] fileBytes = generateFileBytes(fileLength);\n+        Files.write(filePath, fileBytes, StandardOpenOption.CREATE);\n+        try (FileChannel fileChannel = FileChannel.open(filePath)) {\n+            fileChannelConsumer.consume(fileBytes, fileChannel);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface FileChannelConsumer {\n+\n+        void consume(byte[] fileBytes, FileChannel fileChannel) throws Exception;\n+\n+    }\n+\n+    private static byte[] generateFileBytes(int length) {\n+        byte[] bytes = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            bytes[i] = (byte) i;\n+        }\n+        return bytes;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/FileChannelPublisherTest.java","additions":708,"deletions":0,"binary":false,"changes":708,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n- * @run main\/othervm -Dtest.requiresHost=true\n+ * @run main\/othervm\/timeout=480 -Dtest.requiresHost=true\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpSlowServerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,4 +36,4 @@\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n- * @run main\/othervm\/timeout=40 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=ssl,channel ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.chunkSize=64 ManyRequests\n+ * @run main\/othervm\/timeout=160 -Djdk.httpclient.HttpClient.log=channel -Dtest.insertDelay=true -Dtest.chunkSize=64 ManyRequests\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm ResponseBodyBeforeError\n+ * @run testng\/othervm\/timeout=480 ResponseBodyBeforeError\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponseBodyBeforeError.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run testng\/othervm ResponsePublisher\n+ * @run testng\/othervm\/timeout=480 ResponsePublisher\n","filename":"test\/jdk\/java\/net\/httpclient\/ResponsePublisher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=480\n@@ -37,1 +37,1 @@\n- * @run testng\/othervm -Djdk.httpclient.allowRestrictedHeaders=Host\n+ * @run testng\/othervm\/timeout=480 -Djdk.httpclient.allowRestrictedHeaders=Host\n","filename":"test\/jdk\/java\/net\/httpclient\/SpecialHeadersTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseKeepAlive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseKeepAliveAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSL.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLKeepAlive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main\/othervm\n+ * @run main\/othervm\/timeout=480\n","filename":"test\/jdk\/java\/net\/httpclient\/SplitResponseSSLKeepAliveAsync.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng java.net.http\/jdk.internal.net.http.FlowTest\n+ * @run testng\/timeout=480 java.net.http\/jdk.internal.net.http.FlowTest\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/FlowTestDriver.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm -Djdk.net.useFastTcpLoopback StressLoopback\n+ * @run main\/othervm\/timeout=480 -Djdk.net.useFastTcpLoopback StressLoopback\n","filename":"test\/jdk\/java\/nio\/channels\/AsynchronousSocketChannel\/StressLoopback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8361495\n+ * @summary Test for AsynchronousCloseException from uninterruptible FileChannel\n+ * @run junit AsyncCloseStreams\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.nio.channels.AsynchronousCloseException;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.concurrent.LinkedTransferQueue;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+public class AsyncCloseStreams {\n+    private static final Closeable STOP = () -> { };\n+\n+    private static Thread startCloseThread(LinkedTransferQueue<Closeable> q) {\n+        return Thread.ofPlatform().start(() -> {\n+                try {\n+                    Closeable c;\n+                    while((c = q.take()) != STOP) {\n+                        try {\n+                            c.close();\n+                        } catch (IOException ignored) {\n+                        }\n+                    }\n+                } catch (InterruptedException ignored) {\n+                }\n+            });\n+    }\n+\n+    @Test\n+    public void available() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+\n+            do {\n+                InputStream in = Files.newInputStream(path);\n+                close.offer(in);\n+                int available = 0;\n+                try {\n+                    available = in.available();\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                    continue;\n+                } catch (Throwable t) {\n+                    fail(\"Unexpected error\", t);\n+                }\n+                if (available < 0) {\n+                    fail(\"FAILED: available < 0\");\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void read() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+            byte[] bytes = new byte[100_000];\n+            Arrays.fill(bytes, (byte)27);\n+            Files.write(path, bytes);\n+\n+            do {\n+                InputStream in = Files.newInputStream(path);\n+                close.offer(in);\n+                int value = 0;\n+                try {\n+                    value = in.read();\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                    continue;\n+                } catch (Throwable t) {\n+                    fail(\"Unexpected error\", t);\n+                }\n+                if (value < 0) {\n+                    fail(\"FAILED: value < 0\");\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+\n+    @Test\n+    public void write() throws InterruptedException, IOException {\n+        var close = new LinkedTransferQueue<Closeable>();\n+        Thread closeThread = startCloseThread(close);\n+\n+        try {\n+            Path path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+            path.toFile().deleteOnExit();\n+\n+            do {\n+                OutputStream out = Files.newOutputStream(path);\n+                close.offer(out);\n+                try {\n+                    out.write(27);\n+                } catch (AsynchronousCloseException ace) {\n+                    System.err.println(\"AsynchronousCloseException caught\");\n+                    break;\n+                } catch (ClosedChannelException ignored) {\n+                } catch (Throwable t) {\n+                    fail(\"Write error\", t);\n+                }\n+            } while (true);\n+        } finally {\n+            close.offer(STOP);\n+            closeThread.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/AsyncCloseStreams.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo\n+ * @run testng\/othervm\/timeout=720 TransferTo\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo_2GB_transferFrom\n+ * @run testng\/othervm\/timeout=720 TransferTo_2GB_transferFrom\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo_2GB_transferFrom.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng\/othervm\/timeout=180 TransferTo_2GB_transferTo\n+ * @run testng\/othervm\/timeout=720 TransferTo_2GB_transferTo\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/TransferTo_2GB_transferTo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm CleanerTest\n+ * @run main\/othervm\/timeout=480 CleanerTest\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/CleanerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @modules java.base\/sun.nio.ch:+open java.base\/java.io:+open\n@@ -35,0 +36,1 @@\n+import java.lang.reflect.Field;\n@@ -50,0 +52,18 @@\n+    private static final int TRIES = 3;\n+\n+    public static int getFD(FileChannel channel) throws Exception {\n+        Field fFdFd = channel.getClass().getDeclaredField(\"fd\");\n+        fFdFd.setAccessible(true);\n+        FileDescriptor fd = (FileDescriptor) fFdFd.get(channel);\n+\n+        Field fFd = FileDescriptor.class.getDeclaredField(\"fd\");\n+        fFd.setAccessible(true);\n+        return fFd.getInt(fd);\n+    }\n+\n+    private static void testWrite(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                StandardOpenOption.WRITE,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n@@ -51,3 +71,0 @@\n-    private static int testWrite(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, StandardOpenOption.WRITE,\n-             ExtendedOpenOption.DIRECT)) {\n@@ -63,3 +80,17 @@\n-            src.flip();\n-            fc.write(src);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                src.flip();\n+                fc.position(0);\n+                fc.write(src);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"write. File still exists in cache!\");\n@@ -69,2 +100,6 @@\n-    private static int testRead(Path p, long blockSize) throws Exception {\n-        try (FileChannel fc = FileChannel.open(p, ExtendedOpenOption.DIRECT)) {\n+    private static void testRead(Path p, long blockSize) throws Exception {\n+        try (FileChannel fc = FileChannel.open(p,\n+                StandardOpenOption.READ,\n+                ExtendedOpenOption.DIRECT)) {\n+            int fd = getFD(fc);\n+\n@@ -77,2 +112,17 @@\n-            fc.read(dest);\n-            return size;\n+\n+            \/\/ If there is AV or other FS tracing software, it may cache the file\n+            \/\/ contents on first access, even though we have asked for DIRECT here.\n+            \/\/ Do several attempts to make test more resilient.\n+\n+            for (int t = 0; t < TRIES; t++) {\n+                flushFileCache(size, fd);\n+                dest.clear();\n+                fc.position(0);\n+                fc.read(dest);\n+                if (!isFileInCache(size, fd)) {\n+                    return;\n+                }\n+            }\n+\n+            throw new RuntimeException(\"DirectIO is not working properly with \" +\n+                                       \"read. File still exists in cache!\");\n@@ -87,6 +137,2 @@\n-    private static boolean isFileInCache(int size, Path p) {\n-        String path = p.toString();\n-        return isFileInCache0(size, path);\n-    }\n-\n-    private static native boolean isFileInCache0(int size, String path);\n+    private static native boolean flushFileCache(int size, int fd);\n+    private static native boolean isFileInCache(int size, int fd);\n@@ -101,10 +147,2 @@\n-            int size = testWrite(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"write. File still exists in cache!\");\n-            }\n-            size = testRead(p, blockSize);\n-            if (isFileInCache(size, p)) {\n-                throw new RuntimeException(\"DirectIO is not working properly with \"\n-                    + \"read. File still exists in cache!\");\n-            }\n+            testWrite(p, blockSize);\n+            testRead(p, blockSize);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/DirectIOTest.java","additions":64,"deletions":26,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n- * Method:    isFileInCache0\n- * Signature: (ILjava\/lang\/String;)Z\n+ * Method:    flushFileCache\n+ * Signature: (II;)V\n@@ -51,1 +51,1 @@\n-JNIEXPORT jboolean Java_DirectIOTest_isFileInCache0(JNIEnv *env,\n+JNIEXPORT void Java_DirectIOTest_flushFileCache(JNIEnv *env,\n@@ -54,1 +54,15 @@\n-                                                jstring file_path) {\n+                                                jint fd) {\n+#ifdef __linux__\n+    posix_fadvise(fd, 0, file_size, POSIX_FADV_DONTNEED);\n+#endif\n+}\n+\n+\/*\n+ * Class:     DirectIO\n+ * Method:    isFileInCache\n+ * Signature: (II;)Z\n+ *\/\n+JNIEXPORT jboolean Java_DirectIOTest_isFileInCache(JNIEnv *env,\n+                                                jclass cls,\n+                                                jint file_size,\n+                                                jint fd) {\n@@ -72,6 +86,0 @@\n-    const char* path = (*env)->GetStringUTFChars(env, file_path, JNI_FALSE);\n-\n-    int fd = open(path, O_RDWR);\n-\n-    (*env)->ReleaseStringUTFChars(env, file_path, path);\n-\n@@ -80,1 +88,0 @@\n-        close(fd);\n@@ -82,1 +89,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: mmap failed\");\n@@ -98,1 +105,1 @@\n-            \"test of whether file exists in cache failed\");\n+            \"test of whether file exists in cache failed: malloc failed\");\n@@ -100,1 +107,0 @@\n-    close(fd);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/libDirectIO.c","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main CloseDuringConnect\n+ * @run main\/timeout=480 CloseDuringConnect\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/CloseDuringConnect.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run junit\/othervm OpenLeak\n+ * @run junit\/othervm\/timeout=480 OpenLeak\n","filename":"test\/jdk\/java\/nio\/channels\/SocketChannel\/OpenLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run testng\/othervm IOExchanges\n+ * @run testng\/othervm\/timeout=480 IOExchanges\n","filename":"test\/jdk\/java\/nio\/channels\/unixdomain\/IOExchanges.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit BlockingChannelOps\n+ * @run junit\/timeout=480 BlockingChannelOps\n@@ -36,2 +36,2 @@\n- * @run junit\/othervm -Djdk.pollerMode=1 BlockingChannelOps\n- * @run junit\/othervm -Djdk.pollerMode=2 BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -Djdk.pollerMode=1 BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -Djdk.pollerMode=2 BlockingChannelOps\n@@ -44,1 +44,1 @@\n- * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n+ * @run junit\/othervm\/timeout=480 -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations BlockingChannelOps\n","filename":"test\/jdk\/java\/nio\/channels\/vthread\/BlockingChannelOps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8154364\n+ * @bug 8154364 8366254\n@@ -36,0 +36,1 @@\n+import java.nio.file.FileSystemLoopException;\n@@ -454,1 +455,1 @@\n-        assertThrows(FileSystemException.class, () -> Files.isSameFile(x, y));\n+        assertThrows(FileSystemLoopException.class, () -> Files.isSameFile(x, y));\n","filename":"test\/jdk\/java\/nio\/file\/Files\/IsSameFile.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main\/othervm\/timeout=360 DGCDeadLock\n+ * @run main\/othervm\/timeout=1440 DGCDeadLock\n@@ -59,2 +59,1 @@\n-    public static final double TEST_FAIL_TIME =\n-            (HOLD_TARGET_TIME + 30000) * TestLibrary.getTimeoutFactor();\n+    public static final double TEST_FAIL_TIME = (HOLD_TARGET_TIME + 30000) * Math.max(TestLibrary.getTimeoutFactor(), 4);\n","filename":"test\/jdk\/java\/rmi\/transport\/dgcDeadLock\/DGCDeadLock.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8298420\n+ * @bug 8298420 8365288\n@@ -81,1 +81,3 @@\n-        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false);\n+        testClass(PEMData.rsapriv, X509EncodedKeySpec.class, false, ClassCastException.class);\n+        System.out.println(\"Decoder test rsapriv PEM asking other EKS returned:\");\n+        testClass(PEMData.rsapriv, XEKS.class, false, ClassCastException.class);\n@@ -487,0 +489,13 @@\n+    static void testClass(PEMData.Entry entry, Class clazz, boolean pass,\n+        Class ec) throws RuntimeException {\n+        try {\n+            testClass(entry, clazz);\n+        } catch (Exception e) {\n+            if (ec.isInstance(e)) {\n+                System.out.println(\"PASS\");\n+                return;\n+            }\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n@@ -576,0 +591,11 @@\n+\n+    class XEKS extends EncodedKeySpec {\n+        public XEKS(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"\";\n+        }\n+    }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main Chain\n+ * @run main\/timeout=480 Chain\n","filename":"test\/jdk\/java\/security\/SignedObject\/Chain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run junit DateFormatTest\n+ * @run junit\/timeout=480 DateFormatTest\n","filename":"test\/jdk\/java\/text\/Format\/DateFormat\/DateFormatTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366401\n+ * @summary Check serialization of DecimalFormatSymbols. That is, ensure the\n+ *          behavior for each stream version is correct during de-serialization.\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED DFSSerializationTest\n+ *\/\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Field;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Currency;\n+import java.util.Locale;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class DFSSerializationTest {\n+\n+    @Nested\n+    class VersionTests {\n+\n+        \/\/ Ensure correct monetarySeparator and exponential field defaults\n+        \/\/ Reads monetary from decimal, and sets exponential to 'E'\n+        @Test\n+        public void version0Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(0)\n+                    .set(\"monetarySeparator\", '~')\n+                    .set(\"exponential\", 'Z')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Check exponential is set to proper default 'E', not 'Z'\n+            assertEquals('E', readField(dfs, \"exponential\"));\n+            \/\/ Ensure that mSep is based on dSep, and is not '~'\n+            assertNotEquals('~', dfs.getMonetaryDecimalSeparator());\n+            assertEquals(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator());\n+        }\n+\n+        \/\/ Version 1 did not have a locale field, and it defaulted to Locale.ROOT.\n+        \/\/ Note that other versions did allow a locale field, which was nullable.\n+        \/\/ E.g. see nullableLocaleTest which does not set locale when it is `null`\n+        @Test\n+        public void version1Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(1)\n+                    .set(\"locale\", null)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(Locale.ROOT, dfs.getLocale());\n+        }\n+\n+        \/\/ Version 2 did not have an exponential separator, and created it via exponent\n+        \/\/ char field.\n+        @Test\n+        public void version2Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(2)\n+                    .set(\"exponentialSeparator\", null)\n+                    .set(\"exponential\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(\"~\", dfs.getExponentSeparator());\n+        }\n+\n+        \/\/ Version 3 didn't have perMillText, percentText, and minusSignText.\n+        \/\/ These were created from the corresponding char equivalents.\n+        @Test\n+        public void version3Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(3)\n+                    .set(\"perMillText\", null)\n+                    .set(\"percentText\", null)\n+                    .set(\"minusSignText\", null)\n+                    .set(\"perMill\", '~')\n+                    .set(\"percent\", '~')\n+                    .set(\"minusSign\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Need to check these String fields using reflection, since they\n+            \/\/ are not exposed via the public API\n+            assertEquals(\"~\", readField(dfs, \"perMillText\"));\n+            assertEquals(\"~\", readField(dfs, \"percentText\"));\n+            assertEquals(\"~\", readField(dfs, \"minusSignText\"));\n+        }\n+\n+        \/\/ Version 4 did not have monetaryGroupingSeparator. It should be based\n+        \/\/ off of groupingSeparator.\n+        @Test\n+        public void version4Test() {\n+            var crafted = new DFSBuilder()\n+                    .setVer(4)\n+                    .set(\"monetaryGroupingSeparator\", 'Z')\n+                    .set(\"groupingSeparator\", '~')\n+                    .build();\n+            var bytes = ser(crafted);\n+            var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator());\n+        }\n+    }\n+\n+    \/\/ Up-to-date DFS stream versions do not expect a null locale since the\n+    \/\/ standard DecimalFormatSymbols API forbids it. However, this was not always\n+    \/\/ the case and previous stream versions can contain a null locale. Thus,\n+    \/\/ ensure that a null locale does not cause number data loading to fail.\n+    @Test\n+    public void nullableLocaleTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"locale\", null)\n+                .set(\"minusSignText\", \"zFoo\")\n+                .set(\"minusSign\", 'z') \/\/ Set so that char\/String forms agree\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertNull(dfs.getLocale());\n+        \/\/ LMS should be based off of minusSignText when locale is null\n+        assertEquals(\"zFoo\", readField(dfs, \"lenientMinusSigns\"));\n+    }\n+\n+    \/\/ readObject fails when the {@code char} and {@code String} representations\n+    \/\/ of percent, per mille, and\/or minus sign disagree.\n+    @Test\n+    public void disagreeingTextTest() {\n+        var expected = \"'char' and 'String' representations of either percent, \" +\n+                \"per mille, and\/or minus sign disagree.\";\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"minusSignText\", \"Z\")\n+                        .set(\"minusSign\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"perMillText\", \"Z\")\n+                        .set(\"perMill\", 'X')\n+                        .build()))).getMessage());\n+        assertEquals(expected, assertThrows(InvalidObjectException.class, () ->\n+                deSer(ser(new DFSBuilder()\n+                        .set(\"percentText\", \"Z\")\n+                        .set(\"percent\", 'X')\n+                        .build()))).getMessage());\n+    }\n+\n+    \/\/ Ensure the serial version is updated to the current after de-serialization.\n+    @Test\n+    public void updatedVersionTest() {\n+        var bytes = ser(new DFSBuilder().setVer(-25).build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(5, readField(dfs, \"serialVersionOnStream\"));\n+    }\n+\n+    \/\/ Should set currency from 4217 code when it is valid.\n+    @Test\n+    public void validIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder().set(\"intlCurrencySymbol\", \"JPY\").build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(Currency.getInstance(\"JPY\"), dfs.getCurrency());\n+    }\n+\n+    \/\/ Should not set currency when 4217 code is invalid, it remains null.\n+    @Test\n+    public void invalidIntlCurrencyTest() {\n+        var bytes = ser(new DFSBuilder()\n+                .set(\"intlCurrencySymbol\", \">.,\")\n+                .set(\"locale\", Locale.JAPAN)\n+                .build());\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        \/\/ Can not init off invalid 4217 code, remains null\n+        assertNull(dfs.getCurrency());\n+    }\n+\n+\/\/ Utilities ----\n+\n+    \/\/ Utility to serialize\n+    private static byte[] ser(Object obj) {\n+        return assertDoesNotThrow(() -> {\n+            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                 ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream)) {\n+                oos.writeObject(obj);\n+                return byteArrayOutputStream.toByteArray();\n+            }\n+        }, \"Unexpected error during serialization\");\n+    }\n+\n+    \/\/ Utility to deserialize\n+    private static DecimalFormatSymbols deSer(byte[] bytes) throws IOException, ClassNotFoundException {\n+        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n+             ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream)) {\n+            return (DecimalFormatSymbols) ois.readObject();\n+        }\n+    }\n+\n+    \/\/ Utility to read a private field\n+    private static Object readField(DecimalFormatSymbols dfs, String name) {\n+        return assertDoesNotThrow(() -> {\n+            var field = DecimalFormatSymbols.class.getDeclaredField(name);\n+            field.setAccessible(true);\n+            return field.get(dfs);\n+        }, \"Unexpected error during field reading\");\n+    }\n+\n+    \/\/ Utility class to build instances of DFS via reflection\n+    private static class DFSBuilder {\n+\n+        private final DecimalFormatSymbols dfs;\n+\n+        private DFSBuilder() {\n+            dfs = new DecimalFormatSymbols();\n+        }\n+\n+        private DFSBuilder setVer(Object value) {\n+            return set(\"serialVersionOnStream\", value);\n+        }\n+\n+        private DFSBuilder set(String field, Object value) {\n+            return assertDoesNotThrow(() -> {\n+                Field f = dfs.getClass().getDeclaredField(field);\n+                f.setAccessible(true);\n+                f.set(dfs, value);\n+                return this;\n+            }, \"Unexpected error during reflection setting\");\n+        }\n+\n+        private DecimalFormatSymbols build() {\n+            return dfs;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DFSSerializationTest.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,6 +24,0 @@\n-\/**\n- * @test\n- * @bug 4109023 4153060 4153061\n- * @summary test ParsePosition and FieldPosition\n- * @run junit PositionTest\n- *\/\n@@ -42,2 +36,6 @@\n-import java.text.*;\n-import java.io.*;\n+\/*\n+ * @test\n+ * @bug 4109023 4153060 4153061 8366400\n+ * @summary test ParsePosition and FieldPosition\n+ * @run junit PositionTest\n+ *\/\n@@ -47,0 +45,8 @@\n+import java.text.DecimalFormat;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -51,0 +57,44 @@\n+    \/\/ Parsing text which contains un-parseable data, but the index\n+    \/\/ begins at the valid portion. Ensure PP is properly updated.\n+    @Test\n+    public void modifiedPositionTest() {\n+        var df = new DecimalFormat(\"YY#\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        var pp = new ParsePosition(9);\n+        assertEquals(123L, assertDoesNotThrow(() -> df.parse(\"FOOBARBAZYY123\", pp)));\n+        assertEquals(-1, pp.getErrorIndex());\n+        assertEquals(14, pp.getIndex());\n+    }\n+\n+    \/\/ Clearly invalid index value that could not work under any scenarios\n+    \/\/ Specifically, ensuring no SIOOBE during affix matching\n+    @Test\n+    public void invalidPositionParseTest() {\n+        var df = new DecimalFormat();\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"1\", new ParsePosition(-1))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"1\", new ParsePosition(Integer.MAX_VALUE))));\n+    }\n+\n+    \/\/ When prefix matching, position + affix length is greater than parsed String length\n+    \/\/ Ensure we do not index out of bounds of the length of the parsed String\n+    @Test\n+    public void prefixMatchingTest() {\n+        var df = new DecimalFormat(\"ZZZ#;YYY#\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        \/\/ 0 + 3 > 2 = (pos + prefix > text)\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"Z1\", new ParsePosition(0))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"Y1\", new ParsePosition(0))));\n+    }\n+\n+    \/\/ When suffix matching, position + affix length is greater than parsed String length\n+    \/\/ Ensure we do not index out of bounds of the length of the parsed String\n+    @Test\n+    public void suffixMatchingTest() {\n+        var df = new DecimalFormat(\"#ZZ;#YY\");\n+        df.setStrict(false); \/\/ Lenient by default, set for test explicitness\n+        \/\/ Matches prefix properly first. Then 3 + 2 > 4 = (pos + suffix > text)\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"123Z\", new ParsePosition(0))));\n+        assertNull(assertDoesNotThrow(() -> df.parse(\"123Y\", new ParsePosition(0))));\n+    }\n+\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/PositionTest.java","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run testng\/othervm -Xmx2g WhiteBoxResizeTest\n+ * @run testng\/othervm\/timeout=960 -Xmx2g WhiteBoxResizeTest\n","filename":"test\/jdk\/java\/util\/HashMap\/WhiteBoxResizeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Djava.locale.providers=CLDR,SPI CurrencyNameProviderTest\n+ * @run main\/othervm\/timeout=480 -Djava.locale.providers=CLDR,SPI CurrencyNameProviderTest\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/CurrencyNameProviderTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run junit\/othervm -Djava.locale.providers=CLDR,SPI LocaleNameProviderTest\n+ * @run junit\/othervm\/timeout=960 -Djava.locale.providers=CLDR,SPI LocaleNameProviderTest\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/LocaleNameProviderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,5 @@\n+import javax.swing.SwingConstants;\n+import javax.swing.BoxLayout;\n+import javax.swing.Box;\n+import java.awt.Dimension;\n+import java.awt.Component;\n@@ -101,1 +106,2 @@\n-        var label = new JLabel(SDF.format(new Date()));\n+        contents.setSize(350, 250);\n+        \/\/ Panel with vertical layout\n@@ -103,0 +109,8 @@\n+        panel.setLayout(new BoxLayout(panel, BoxLayout.PAGE_AXIS));\n+        \/\/ Time zone ID label\n+        var timeZoneID = new JLabel(\"Time zone ID: \" + SDF.getTimeZone().getID(), SwingConstants.CENTER);\n+        timeZoneID.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Time label\n+        var label = new JLabel(SDF.format(new Date()), SwingConstants.CENTER);\n+        label.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Update button\n@@ -104,0 +118,7 @@\n+        button.setAlignmentX(Component.CENTER_ALIGNMENT);\n+        \/\/ Add components with spacing\n+        panel.add(Box.createRigidArea(new Dimension(0, 10)));\n+        panel.add(timeZoneID);\n+        panel.add(Box.createRigidArea(new Dimension(0, 5)));\n+        panel.add(label);\n+        panel.add(Box.createRigidArea(new Dimension(0, 10)));\n@@ -105,3 +126,2 @@\n-        contents.setSize(350, 250);\n-        contents.add(label, BorderLayout.NORTH);\n-        contents.add(panel, BorderLayout.CENTER);\n+        contents.add(panel);\n+\n@@ -110,0 +130,3 @@\n+            \/\/ Clear JVM cached timezone and force reload from OS\n+            TimeZone.setDefault(null);\n+            System.setProperty(\"user.timezone\", \"\");\n@@ -112,0 +135,1 @@\n+            timeZoneID.setText(\"Time zone ID: \" + tz.getID());\n","filename":"test\/jdk\/java\/util\/TimeZone\/DefaultTimeZoneTest.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run main\/othervm -Xmx64m BasicCancelTest\n+ * @run main\/othervm\/timeout=480 -Xmx64m BasicCancelTest\n","filename":"test\/jdk\/java\/util\/concurrent\/ScheduledThreadPoolExecutor\/BasicCancelTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm FileHandlerPath\n+ * @run main\/othervm\/timeout=480 FileHandlerPath\n","filename":"test\/jdk\/java\/util\/logging\/FileHandlerPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -52,0 +53,1 @@\n+ * @library \/test\/lib\n@@ -63,5 +65,0 @@\n-    public static final double TIMEOUT_FACTOR;\n-    static {\n-        String toFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-        TIMEOUT_FACTOR = Double.parseDouble(toFactor);\n-    }\n@@ -69,1 +66,1 @@\n-        return Math.min(count, (int) Math.ceil(TIMEOUT_FACTOR * count));\n+        return Math.min(count, (int) Math.ceil(Utils.TIMEOUT_FACTOR * count));\n","filename":"test\/jdk\/java\/util\/logging\/LogManager\/Configuration\/updateConfiguration\/HandlersOnComplexResetUpdate.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -52,0 +53,1 @@\n+ * @library \/test\/lib\n@@ -63,5 +65,0 @@\n-    public static final double TIMEOUT_FACTOR;\n-    static {\n-        String toFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-        TIMEOUT_FACTOR = Double.parseDouble(toFactor);\n-    }\n@@ -69,1 +66,1 @@\n-        return Math.min(count, (int) Math.ceil(TIMEOUT_FACTOR * count));\n+        return Math.min(count, (int) Math.ceil(Utils.TIMEOUT_FACTOR * count));\n","filename":"test\/jdk\/java\/util\/logging\/LogManager\/Configuration\/updateConfiguration\/HandlersOnComplexUpdate.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+timeout.default.seconds=480\n","filename":"test\/jdk\/java\/util\/stream\/boottest\/java.base\/java\/util\/stream\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+timeout.default.seconds=480\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary Test basic deflater & inflater functionality\n+ * @summary Test basic deflater and inflater functionality\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 DeInflate\n","filename":"test\/jdk\/java\/util\/zip\/DeInflate.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng TestZipFileEncodings\n+ * @run testng\/timeout=480 TestZipFileEncodings\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestZipFileEncodings.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8364135\n+ * @summary Test verifies that jpeg image reader throws\n+ *          IndexOutOfBoundsException when \"-1\" image index is used.\n+ * @run main JpegNegativeImageIndexTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.concurrent.Callable;\n+\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+\n+public class JpegNegativeImageIndexTest {\n+\n+    private static boolean failed;\n+\n+    private static void checkException(boolean exceptionReceived,\n+                                       String testName) {\n+        if (!exceptionReceived) {\n+            System.out.println(\"Didn't receive IndexOutOfBoundsException for \"\n+                + testName);\n+            failed = true;\n+        }\n+    }\n+\n+    private static void testMethod(String methodName,\n+                                   Callable<?> method) {\n+        boolean exceptionReceived = false;\n+        System.out.println(\"Testing \" + methodName);\n+        try {\n+            method.call();\n+        } catch (Exception e) {\n+            if (e instanceof IndexOutOfBoundsException) {\n+                exceptionReceived = true;\n+            }\n+        }\n+        checkException(exceptionReceived, methodName);\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+        Iterator<ImageReader> readers =\n+            ImageIO.getImageReadersByFormatName(\"jpeg\");\n+        if (!readers.hasNext()) {\n+            throw new RuntimeException(\"No jpeg image readers found\");\n+        }\n+\n+        ImageReader ir = readers.next();\n+\n+        testMethod(\"getImageTypes()\", () -> ir.getImageTypes(-1));\n+        testMethod(\"getWidth()\", () -> ir.getWidth(-1));\n+        testMethod(\"getHeight()\", () -> ir.getHeight(-1));\n+        testMethod(\"getRawImageType()\", () -> ir.getRawImageType(-1));\n+\n+        if (failed) {\n+            throw new RuntimeException(\"JpegImageReader didn't throw required\" +\n+                \" IndexOutOfBoundsException for -1 image index\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/plugins\/jpeg\/JpegNegativeImageIndexTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8364227\n+ * @summary Test various null parameters and verify Exceptions thrown\n+ * @modules java.management.rmi\n+ * @run main ExceptionTestNulls\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import javax.management.AttributeNotFoundException;\n+import javax.management.ObjectName;\n+import javax.management.InstanceAlreadyExistsException;\n+import javax.management.InstanceNotFoundException;\n+import javax.management.InvalidAttributeValueException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.MBeanException;\n+import javax.management.MBeanServer;\n+import javax.management.MBeanServerConnection;\n+import javax.management.MBeanServerFactory;\n+import javax.management.NotCompliantMBeanException;\n+import javax.management.NotificationListener;\n+import javax.management.ReflectionException;\n+import javax.management.RuntimeOperationsException;\n+\n+public class ExceptionTestNulls {\n+\n+    public interface MyMBean {\n+    }\n+\n+    public class My implements MyMBean {\n+    }\n+\n+    private int count;\n+\n+    public static void main(String args[]) throws Exception {\n+        ExceptionTestNulls test = new ExceptionTestNulls();\n+        test.run();\n+    }\n+\n+    public ExceptionTestNulls() {\n+        count = 0; \/\/ Simple index for printing tests, for readability.\n+    }\n+\n+    public void run() {\n+\n+        try {\n+        ObjectName name = new ObjectName(\"a:b=c\");\n+        ObjectName namePattern = new ObjectName(\"*:type=Foo\");\n+        My myMy = new My();\n+            MBeanServer mbs = MBeanServerFactory.newMBeanServer();\n+\n+            try {\n+                \/\/ createMBean with null className\n+                mbs.createMBean((String) null, name, name, new Object[0], new String[0]);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ createMBean with ObjectName as a pattern\n+                mbs.createMBean(\"myMy\", namePattern, name, new Object[0], new String[0]);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ registerMBean with null Object\n+                mbs.registerMBean(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ registerMBean with no name available\n+                mbs.registerMBean(myMy, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                \/\/ unregisterMBean with null ObjectName\n+                mbs.unregisterMBean(null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.isRegistered(null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.getAttribute(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+            try {\n+                mbs.getAttribute(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.getAttributes(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.getAttributes(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttribute(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttribute(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttributes(null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.setAttributes(name, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.addNotificationListener(null, (NotificationListener) null, null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+           try {\n+                mbs.registerMBean(myMy, name);\n+                mbs.addNotificationListener(null, name, null, null);\n+            } catch (RuntimeOperationsException e) {\n+                checkROEContainsIAE(e);\n+            }\n+\n+        } catch (MBeanException | MalformedObjectNameException | InstanceAlreadyExistsException\n+                 | NotCompliantMBeanException | InstanceNotFoundException | ReflectionException\n+                 | AttributeNotFoundException | InvalidAttributeValueException e) {\n+            \/\/ Should not reach here.  Known Exceptions thrown by methods above.\n+            \/\/ These would be a failure, as would other exceptions not caught (e.g. NullPointerException).\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public void checkROEContainsIAE(RuntimeOperationsException e) {\n+        System.out.println(++count);\n+        System.out.println(\"Checking: \" + e);\n+        if (e.getCause() instanceof IllegalArgumentException) {\n+            System.out.println(\"Got expected cause: \" + e.getCause());\n+            System.out.println();\n+        } else {\n+            throw new RuntimeException(\"Not the expected cause: \" + e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/management\/MBeanServer\/ExceptionTestNulls.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @run main\/othervm DisabledAlgorithms default\n- * @run main\/othervm DisabledAlgorithms empty\n+ * @run main\/othervm\/timeout=480 DisabledAlgorithms default\n+ * @run main\/othervm\/timeout=480 DisabledAlgorithms empty\n","filename":"test\/jdk\/javax\/net\/ssl\/ciphersuites\/DisabledAlgorithms.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,3 @@\n-import javax.print.attribute.AttributeSet;\n-import javax.print.attribute.HashAttributeSet;\n-import javax.print.attribute.standard.PrinterName;\n+import java.io.IOException;\n+\n+import jtreg.SkippedException;\n@@ -36,0 +36,2 @@\n+ * @library \/test\/lib\/\n+ * @requires (os.family == \"linux\")\n@@ -41,6 +43,0 @@\n-    String os = System.getProperty(\"os.name\").toLowerCase();\n-    System.out.println(\"OS is \" + os);\n-    if (!os.equals(\"linux\")) {\n-        System.out.println(\"Linux specific test. No need to continue\");\n-        return;\n-    }\n@@ -54,1 +50,10 @@\n-    Process proc = Runtime.getRuntime().exec(lpcmd);\n+    Process proc;\n+    try {\n+        proc = Runtime.getRuntime().exec(lpcmd);\n+    } catch (IOException e) {\n+        if (e.getMessage().contains(\"No such file or directory\")) {\n+            throw new SkippedException(\"Cannot find lpstat\");\n+        } else {\n+            throw e;\n+        }\n+    }\n@@ -69,1 +74,0 @@\n-\n","filename":"test\/jdk\/javax\/print\/PrintServiceLookup\/CountPrintServices.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run main bug6868611\n+ * @run main\/timeout=480 bug6868611\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/6868611\/bug6868611.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -28,4 +29,4 @@\n- *     ComponentOrientation property is set to RIGHT_TO_LEFT. This test is\n- *     manual.  The tester is asked to compare left-to-right and\n- *     right-to-left menu bars and judge whether they are mirror images of each\n- *     other.\n+ *     ComponentOrientation property is set to RIGHT_TO_LEFT.\n+ *     The tester is asked to compare left-to-right and\n+ *     right-to-left menu bars and decide whether they are mirror\n+ *     images of each other.\n@@ -38,1 +39,0 @@\n-import java.awt.Point;\n@@ -41,0 +41,2 @@\n+import java.util.List;\n+\n@@ -45,0 +47,1 @@\n+import javax.swing.JOptionPane;\n@@ -50,1 +53,1 @@\n-public class RightLeftOrientation {\n+public final class RightLeftOrientation {\n@@ -52,2 +55,1 @@\n-    static JFrame ltrFrame;\n-    static JFrame rtlFrame;\n+    private static List<JFrame> frames;\n@@ -56,3 +58,1 @@\n-        This test checks menu bars for correct Right-To-Left Component Orientation.\n-\n-        You should see two frames, each containing a menu bar.\n+        This test checks menu bars for correct Right-To-Left component orientation.\n@@ -60,1 +60,2 @@\n-        One frame will be labelled \"Left To Right\" and will contain\n+        You should see two frames, each contains a menu bar.\n+        One frame is labelled \"Left To Right\" and contains\n@@ -62,2 +63,2 @@\n-        The other frame will be labelled \"Right To Left\" and will\n-        contain a menu bar with menus starting on its right side.\n+        The other frame is labelled \"Right To Left\" and\n+        contains a menu bar with menus starting on its right side.\n@@ -65,4 +66,5 @@\n-        The test will also contain radio buttons that can be used to set\n-        the look and feel of the menu bars.\n-        For each look and feel, you should compare the two menu\n-        bars and make sure they are mirror images of each other. \"\"\";\n+        The test also displays a frame with radio buttons\n+        to change the look and feel of the menu bars.\n+        For each look and feel, compare the two menu bars\n+        in LTR and RTL orientation and make sure they are mirror\n+        images of each other.\"\"\";\n@@ -72,1 +74,1 @@\n-                 .title(\"RTL test Instructions\")\n+                 .title(\"Menu Bar RTL Instructions\")\n@@ -74,1 +76,0 @@\n-                 .rows((int) INSTRUCTIONS.lines().count() + 2)\n@@ -77,0 +78,1 @@\n+                 .positionTestUIRightColumn()\n@@ -81,2 +83,2 @@\n-    private static JFrame createTestUI() {\n-        JFrame frame = new JFrame(\"RightLeftOrientation\");\n+    private static JFrame createPlafChangerFrame() {\n+        JFrame frame = new JFrame(\"Change Look and Feel\");\n@@ -86,1 +88,0 @@\n-        JRadioButton rb;\n@@ -91,1 +92,1 @@\n-            rb = new JRadioButton(lafInfos[i].getName());\n+            JRadioButton rb = new JRadioButton(lafInfos[i].getName());\n@@ -102,0 +103,3 @@\n+        frame.pack();\n+        return frame;\n+    }\n@@ -103,1 +107,4 @@\n-        ltrFrame = new JFrame(\"Left To Right\");\n+    private static List<JFrame> createTestUI() {\n+        JFrame plafFrame = createPlafChangerFrame();\n+\n+        JFrame ltrFrame = new JFrame(\"Left To Right\");\n@@ -106,2 +113,0 @@\n-        ltrFrame.setLocation(new Point(10, 10));\n-        ltrFrame.setVisible(true);\n@@ -109,1 +114,1 @@\n-        rtlFrame = new JFrame(\"Right To Left\");\n+        JFrame rtlFrame = new JFrame(\"Right To Left\");\n@@ -112,4 +117,2 @@\n-        rtlFrame.setLocation(new Point(10, 120));\n-        rtlFrame.setVisible(true);\n-        frame.pack();\n-        return frame;\n+\n+        return (frames = List.of(plafFrame, ltrFrame, rtlFrame));\n@@ -118,1 +121,2 @@\n-    static class PlafChanger implements ActionListener {\n+    private static final class PlafChanger implements ActionListener {\n+        @Override\n@@ -124,5 +128,8 @@\n-                SwingUtilities.updateComponentTreeUI(ltrFrame);\n-                SwingUtilities.updateComponentTreeUI(rtlFrame);\n-            }\n-            catch (Exception exc) {\n-                System.err.println(\"Could not load LookAndFeel: \" + lnfName);\n+                frames.forEach(SwingUtilities::updateComponentTreeUI);\n+            } catch (Exception exc) {\n+                String message = \"Could not set Look and Feel to \" + lnfName;\n+                System.err.println(message);\n+                JOptionPane.showMessageDialog(frames.get(0),\n+                                              message,\n+                                              \"Look and Feel Error\",\n+                                              JOptionPane.ERROR_MESSAGE);\n","filename":"test\/jdk\/javax\/swing\/JMenuBar\/RightLeftOrientation.java","additions":46,"deletions":39,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Djava.awt.headless=true ConcurrentModification\n+ * @run main\/othervm\/timeout=480 -Djava.awt.headless=true ConcurrentModification\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicDirectoryModel\/ConcurrentModification.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -38,0 +40,1 @@\n+   @library \/test\/lib\n@@ -41,2 +44,1 @@\n-    private static final float tf = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    private static final long TIMEOUT = 10_000 * (long)tf;\n+    private static final long TIMEOUT = (long) (10_000 * Utils.TIMEOUT_FACTOR);\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/Parser\/8078268\/bug8078268.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main\/othervm\/timeout=300 -Dsun.net.httpserver.nodelay=true GenerationTests\n+ * @run main\/othervm\/timeout=1200 -Dsun.net.httpserver.nodelay=true GenerationTests\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/GenerationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8341277 8361102\n- * @summary Testing ClassFile instruction argument validation.\n+ * @bug 8341277 8361102 8361182 8361614\n+ * @summary Testing ClassFile (pseudo-)instruction argument validation.\n@@ -32,0 +32,2 @@\n+import java.lang.classfile.attribute.CharacterRangeInfo;\n+import java.lang.classfile.attribute.LineNumberInfo;\n@@ -281,0 +283,58 @@\n+\n+    @Test\n+    void testCharacterRange() {\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 0));\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65535));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, -1));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var dummyLabel = cob.startLabel();\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 0));\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65535));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testLineNumber() {\n+        assertDoesNotThrow(() -> LineNumberInfo.of(0, 25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, -1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, 65536));\n+        assertDoesNotThrow(() -> LineNumber.of(25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(-1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationLocalVarTargetInfo() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationTypeArgumentTarget() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeArgument(TypeAnnotation.TargetType.CAST, label, 0));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofCastExpr(label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodInvocationTypeArgument(label, Integer.MIN_VALUE));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodReferenceTypeArgument(label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorInvocationTypeArgument(label, 300));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorReferenceTypeArgument(label, -2));\n+            cob.return_();\n+        }));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820 8336833\n+ * @bug 8320360 8330684 8331320 8331655 8331940 8332486 8335820 8336833 8361635\n@@ -30,0 +30,3 @@\n+\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.AttributedElement;\n@@ -31,4 +34,1 @@\n-import java.lang.classfile.constantpool.PoolEntry;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.BufWriter;\n@@ -36,0 +36,4 @@\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CustomAttribute;\n+import java.lang.classfile.Label;\n@@ -37,0 +41,1 @@\n+import java.lang.classfile.Signature;\n@@ -44,0 +49,1 @@\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -45,0 +51,5 @@\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayList;\n@@ -46,0 +57,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiConsumer;\n@@ -54,0 +67,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -76,0 +91,108 @@\n+    @Test\n+    void testBsmOverLimit() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            var cp = clb.constantPool();\n+            var mhe = cp.methodHandleEntry(BSM_GET_STATIC_FINAL);\n+            var digits = new IntegerEntry[10];\n+            for (int i = 0; i < 10; i++) {\n+                digits[i] = cp.intEntry(i);\n+            }\n+            int lastIndex = -1;\n+            for (int i = 0; i < 66000; i++) {\n+                lastIndex = cp.bsmEntry(mhe, List.of(\n+                        digits[i \/ 10000 % 10],\n+                        digits[i \/ 1000 % 10],\n+                        digits[i \/ 100 % 10],\n+                        digits[i \/ 10 % 10],\n+                        digits[i \/ 1 % 10])).bsmIndex();\n+            }\n+            assertEquals(65999, lastIndex);\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyFields() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.withField(\"f\", CD_int, 0);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyMethods() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.withMethodBody(\"m\", MTD_void, 0, CodeBuilder::return_);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    static final class MyAttribute extends CustomAttribute<MyAttribute> {\n+        static final MyAttribute INSTANCE = new MyAttribute();\n+\n+        private enum Mapper implements AttributeMapper<MyAttribute> {\n+            INSTANCE;\n+\n+            @Override\n+            public MyAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void writeAttribute(BufWriter buf, MyAttribute attr) {\n+                buf.writeIndex(buf.constantPool().utf8Entry(\"MyAttribute\"));\n+                buf.writeInt(0);\n+            }\n+\n+            @Override\n+            public boolean allowMultiple() {\n+                return true;\n+            }\n+\n+            @Override\n+            public AttributeStability stability() {\n+                return AttributeStability.STATELESS;\n+            }\n+\n+\n+        }\n+\n+        private MyAttribute() {\n+            super(Mapper.INSTANCE);\n+        }\n+    }\n+\n+    @Test\n+    void testTooManyClassAttributes() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                clb.with(MyAttribute.INSTANCE);\n+            }\n+            reached.set(true);\n+        }));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testTooManyFieldAttributes() {\n+        AtomicBoolean reached = new AtomicBoolean();\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withField(\"f\", CD_int, fb -> {\n+            for (int i = 1; i < 66000; i++) {\n+                fb.with(MyAttribute.INSTANCE);\n+            }\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+    }\n+\n@@ -102,0 +225,85 @@\n+    private static void testPseudoOverflow(BiConsumer<CodeBuilder, Label> handler) {\n+        ClassFile cf = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        AtomicBoolean reached = new AtomicBoolean(false);\n+        assertDoesNotThrow(() -> cf.build(CD_Void, cb -> cb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            cob.nop();\n+            var label = cob.newLabel();\n+            for (int i = 0; i < 65535; i++) {\n+                handler.accept(cob, label);\n+            }\n+            cob.labelBinding(label);\n+            cob.return_();\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+\n+        reached.set(false);\n+        assertThrows(IllegalArgumentException.class, () -> cf.build(CD_Void, cb -> cb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            cob.nop();\n+            var label = cob.newLabel();\n+            for (int i = 0; i < 65536; i++) {\n+                handler.accept(cob, label);\n+            }\n+            cob.labelBinding(label);\n+            cob.return_();\n+            reached.set(true);\n+        })));\n+        assertTrue(reached.get());\n+    }\n+\n+    @Test\n+    void testExceptionCatchOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.exceptionCatch(cob.startLabel(), label, label, CD_Throwable));\n+    }\n+\n+    @Test\n+    void testLocalVariableOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.localVariable(0, \"fake\", CD_int, cob.startLabel(), label));\n+    }\n+\n+    @Test\n+    void testLocalVariableTypeOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.localVariableType(0, \"fake\", Signature.of(CD_int), cob.startLabel(), label));\n+    }\n+\n+    @Test\n+    void testCharacterRangeOverflow() {\n+        testPseudoOverflow((cob, label) -> cob.characterRange(cob.startLabel(), label, 0, 0, 0));\n+    }\n+\n+    \/\/ LineNumber deduplicates so cannot really overflow\n+\n+    @Test\n+    void testHugeLookupswitch() {\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            var l = cob.newLabel();\n+            \/\/ 10000 * 8 > 65535\n+            var cases = new ArrayList<SwitchCase>(10000);\n+            for (int i = 0; i < 10000; i++) {\n+                cases.add(SwitchCase.of(i, l));\n+            }\n+            cob.lookupswitch(l, cases);\n+            cob.labelBinding(l);\n+            cob.return_();\n+        })));\n+    }\n+\n+    @Test\n+    void testHugeTableswitch() {\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> clb.withMethodBody(\"test\", MTD_void, ACC_STATIC, cob -> {\n+            var l = cob.newLabel();\n+            \/\/ 20000 * 4 > 65535\n+            cob.tableswitch(-10000, 10000, l, List.of());\n+            cob.labelBinding(l);\n+            cob.return_();\n+        })));\n+    }\n+\n+    @Test\n+    void testHugeUtf8Entry() {\n+        var longString = String.valueOf((char) 0x800).repeat(22000);\n+        assertThrows(IllegalArgumentException.class, () -> ClassFile.of().build(CD_Void, clb -> {\n+            clb.constantPool().utf8Entry(longString);\n+        }));\n+    }\n+\n","filename":"test\/jdk\/jdk\/classfile\/LimitsTest.java","additions":214,"deletions":6,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361635\n+ * @summary Testing list size validation in class file format.\n+ * @run junit ListValidationTest\n+ *\/\n+\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationElement;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.Interfaces;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+import jdk.internal.classfile.impl.UnboundAttribute;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.util.Collections.nCopies;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class ListValidationTest {\n+    @Test\n+    void testAnnotationElements() {\n+        var e = AnnotationElement.ofInt(\"dummy\", 0);\n+        assertDoesNotThrow(() -> Annotation.of(CD_String, nCopies(65535, e)));\n+        assertThrows(IllegalArgumentException.class, () -> Annotation.of(CD_String, nCopies(66000, e)));\n+    }\n+\n+    @Test\n+    void testAnnotationArrayValue() {\n+        var v = AnnotationValue.ofInt(0);\n+        assertDoesNotThrow(() -> AnnotationValue.ofArray(nCopies(65535, v)));\n+        assertThrows(IllegalArgumentException.class, () -> AnnotationValue.ofArray(nCopies(66000, v)));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationPath() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(), nCopies(255, TypeAnnotation.TypePathComponent.INNER_TYPE), anno));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.of(TypeAnnotation.TargetInfo.ofField(), nCopies(256, TypeAnnotation.TypePathComponent.INNER_TYPE), anno));\n+    }\n+\n+    @Test\n+    void testBsmArgs() {\n+        var cpb = ConstantPoolBuilder.of();\n+        assertDoesNotThrow(() -> cpb.bsmEntry(BSM_INVOKE, nCopies(65535, 0)));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.bsmEntry(BSM_INVOKE, nCopies(66000, 0)));\n+    }\n+\n+    @Test\n+    void testInterfaces() {\n+        var cpb = ConstantPoolBuilder.of();\n+        assertDoesNotThrow(() -> Interfaces.ofSymbols(nCopies(65535, CD_Number)));\n+        assertThrows(IllegalArgumentException.class, () -> cpb.bsmEntry(BSM_INVOKE, nCopies(66000, 0)));\n+    }\n+\n+    @Test\n+    void testStackMapFrame() {\n+        Label label = dummyLabel();\n+        assertDoesNotThrow(() -> StackMapFrameInfo.of(label,\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapFrameInfo.of(label,\n+                nCopies(66000, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapFrameInfo.of(label,\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(66000, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE)));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationLocalVarTarget() {\n+        Label label = dummyLabel();\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofLocalVariable(nCopies(65535, TypeAnnotation.LocalVarTargetInfo.of(label, label, 0))));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofLocalVariable(nCopies(66000, TypeAnnotation.LocalVarTargetInfo.of(label, label, 0))));\n+    }\n+\n+    @Test\n+    void testExceptionsAttribute() {\n+        assertDoesNotThrow(() -> ExceptionsAttribute.ofSymbols(nCopies(65535, CD_Throwable)));\n+        assertThrows(IllegalArgumentException.class, () -> ExceptionsAttribute.ofSymbols(nCopies(66000, CD_Throwable)));\n+    }\n+\n+    @Test\n+    void testStackMapTableAttribute() {\n+        var frame = StackMapFrameInfo.of(dummyLabel(),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.INTEGER),\n+                nCopies(65535, StackMapFrameInfo.SimpleVerificationTypeInfo.DOUBLE));\n+        assertDoesNotThrow(() -> StackMapTableAttribute.of(nCopies(65535, frame)));\n+        assertThrows(IllegalArgumentException.class, () -> StackMapTableAttribute.of(nCopies(66000, frame)));\n+    }\n+\n+    @Test\n+    void testInnerClassesAttribute() {\n+        var entry = InnerClassInfo.of(CD_Void, Optional.empty(), Optional.empty(), 0);\n+        assertDoesNotThrow(() -> InnerClassesAttribute.of(nCopies(65535, entry)));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassesAttribute.of(nCopies(66000, entry)));\n+    }\n+\n+    @Test\n+    void testRecordAttribute() {\n+        var component = RecordComponentInfo.of(\"hello\", CD_int, List.of());\n+        assertDoesNotThrow(() -> RecordAttribute.of(nCopies(65535, component)));\n+        assertThrows(IllegalArgumentException.class, () -> RecordAttribute.of(nCopies(66000, component)));\n+    }\n+\n+    @Test\n+    void testMethodParametersAttribute() {\n+        var component = MethodParameterInfo.of(Optional.empty(), 0);\n+        assertDoesNotThrow(() -> MethodParametersAttribute.of(nCopies(255, component)));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParametersAttribute.of(nCopies(300, component)));\n+    }\n+\n+    @Test\n+    void testModuleHashesAttribute() {\n+        var hash = ModuleHashInfo.of(ModuleDesc.of(\"java.base\"), new byte[0]);\n+        assertDoesNotThrow(() -> ModuleHashesAttribute.of(\"dummy\", nCopies(65535, hash)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleHashesAttribute.of(\"dummy\", nCopies(66000, hash)));\n+    }\n+\n+    @Test\n+    void testModulePackagesAttribute() {\n+        var pkgDesc = PackageDesc.of(\"java.io\");\n+        assertDoesNotThrow(() -> ModulePackagesAttribute.ofNames(nCopies(65535, pkgDesc)));\n+        assertThrows(IllegalArgumentException.class, () -> ModulePackagesAttribute.ofNames(nCopies(66000, pkgDesc)));\n+    }\n+\n+    @Test\n+    void testPermittedSubclassesAttribute() {\n+        assertDoesNotThrow(() -> PermittedSubclassesAttribute.ofSymbols(nCopies(65535, CD_Collection)));\n+        assertThrows(IllegalArgumentException.class, () -> PermittedSubclassesAttribute.ofSymbols(nCopies(66000, CD_Collection)));\n+    }\n+\n+    @Test\n+    void testNestMembersAttribute() {\n+        assertDoesNotThrow(() -> NestMembersAttribute.ofSymbols(nCopies(65535, CD_Collection)));\n+        assertThrows(IllegalArgumentException.class, () -> NestMembersAttribute.ofSymbols(nCopies(66000, CD_Collection)));\n+    }\n+\n+    @Test\n+    void testCharacterRangeTableAttribute() {\n+        var range = CharacterRangeInfo.of(0, 0, 0, 0, 0);\n+        assertDoesNotThrow(() -> CharacterRangeTableAttribute.of(nCopies(65535, range)));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeTableAttribute.of(nCopies(66000, range)));\n+    }\n+\n+    @Test\n+    void testLineNumberTableAttribute() {\n+        var lineNumber = LineNumberInfo.of(0, 0);\n+        assertDoesNotThrow(() -> LineNumberTableAttribute.of(nCopies(65535, lineNumber)));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberTableAttribute.of(nCopies(66000, lineNumber)));\n+    }\n+\n+    @Test\n+    void testLocalVariableTableAttribute() {\n+        var utf8 = TemporaryConstantPool.INSTANCE.utf8Entry(\"dummy\");\n+        var localVariable = new UnboundAttribute.UnboundLocalVariableInfo(0, 0, utf8, utf8, 0);\n+        assertDoesNotThrow(() -> LocalVariableTableAttribute.of(nCopies(65535, localVariable)));\n+        assertThrows(IllegalArgumentException.class, () -> LocalVariableTableAttribute.of(nCopies(66000, localVariable)));\n+    }\n+\n+    @Test\n+    void testLocalVariableTypeTableAttribute() {\n+        var utf8 = TemporaryConstantPool.INSTANCE.utf8Entry(\"dummy\");\n+        var localVariableType = new UnboundAttribute.UnboundLocalVariableTypeInfo(0, 0, utf8, utf8, 0);\n+        assertDoesNotThrow(() -> LocalVariableTypeTableAttribute.of(nCopies(65535, localVariableType)));\n+        assertThrows(IllegalArgumentException.class, () -> LocalVariableTypeTableAttribute.of(nCopies(66000, localVariableType)));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleAnnotationsAttribute() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeVisibleAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleAnnotationsAttribute() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeInvisibleAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleParameterAnnotationsAttributeTopLevel() {\n+        assertDoesNotThrow(() -> RuntimeVisibleParameterAnnotationsAttribute.of(nCopies(255, List.of())));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleParameterAnnotationsAttribute.of(nCopies(256, List.of())));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleParameterAnnotationsAttributeTopLevel() {\n+        assertDoesNotThrow(() -> RuntimeInvisibleParameterAnnotationsAttribute.of(nCopies(255, List.of())));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleParameterAnnotationsAttribute.of(nCopies(256, List.of())));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleParameterAnnotationsAttributeNested() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeVisibleParameterAnnotationsAttribute.of(List.of(nCopies(65535, anno))));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleParameterAnnotationsAttribute.of(List.of(nCopies(65536, anno))));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleParameterAnnotationsAttributeNested() {\n+        var anno = Annotation.of(CD_String);\n+        assertDoesNotThrow(() -> RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(nCopies(65535, anno))));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleParameterAnnotationsAttribute.of(List.of(nCopies(65536, anno))));\n+    }\n+\n+    @Test\n+    void testRuntimeVisibleTypeAnnotationsAttribute() {\n+        var anno = TypeAnnotation.of(TypeAnnotation.TargetInfo.ofMethodReturn(), List.of(), Annotation.of(CD_String));\n+        assertDoesNotThrow(() -> RuntimeVisibleTypeAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeVisibleTypeAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testRuntimeInvisibleTypeAnnotationsAttribute() {\n+        var anno = TypeAnnotation.of(TypeAnnotation.TargetInfo.ofMethodReturn(), List.of(), Annotation.of(CD_String));\n+        assertDoesNotThrow(() -> RuntimeInvisibleTypeAnnotationsAttribute.of(nCopies(65535, anno)));\n+        assertThrows(IllegalArgumentException.class, () -> RuntimeInvisibleTypeAnnotationsAttribute.of(nCopies(66000, anno)));\n+    }\n+\n+    @Test\n+    void testModuleExportEntry() {\n+        var pkg = PackageDesc.of(\"dummy.test\");\n+        var mod = ModuleDesc.of(\"the.other\");\n+        assertDoesNotThrow(() -> ModuleExportInfo.of(pkg, 0, nCopies(65535, mod)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(pkg, 0, nCopies(66000, mod)));\n+    }\n+\n+    @Test\n+    void testModuleOpenEntry() {\n+        var pkg = PackageDesc.of(\"dummy.test\");\n+        var mod = ModuleDesc.of(\"the.other\");\n+        assertDoesNotThrow(() -> ModuleOpenInfo.of(pkg, 0, nCopies(65535, mod)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(pkg, 0, nCopies(66000, mod)));\n+    }\n+\n+    @Test\n+    void testModuleProvideEntry() {\n+        assertDoesNotThrow(() -> ModuleProvideInfo.of(CD_Object, nCopies(65535, CD_String)));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleProvideInfo.of(CD_Object, nCopies(66000, CD_String)));\n+    }\n+\n+    @Test\n+    void testRecordComponentAttributes() {\n+        var attr = SyntheticAttribute.of();\n+        assertDoesNotThrow(() -> RecordComponentInfo.of(\"dummy\", CD_int, nCopies(65535, attr)));\n+        assertThrows(IllegalArgumentException.class, () -> RecordComponentInfo.of(\"dummy\", CD_int, nCopies(66000, attr)));\n+    }\n+\n+    @Test\n+    void testModuleAttribute() {\n+        var md = ModuleDesc.of(\"java.base\");\n+        var pkg = PackageDesc.of(\"java.lang\");\n+        var require = ModuleRequireInfo.of(md, 0, null);\n+        var export = ModuleExportInfo.of(pkg, 0, List.of());\n+        var provide = ModuleProvideInfo.of(CD_Object, List.of());\n+        var open = ModuleOpenInfo.of(pkg, 0, List.of());\n+        var classEntry = TemporaryConstantPool.INSTANCE.classEntry(CD_String);\n+        var moduleEntry = TemporaryConstantPool.INSTANCE.moduleEntry(md);\n+        assertDoesNotThrow(() -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(66000, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(66000, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(66000, open),\n+                nCopies(65535, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(66000, classEntry),\n+                nCopies(65535, provide)\n+        ));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(moduleEntry, 0, null,\n+                nCopies(65535, require),\n+                nCopies(65535, export),\n+                nCopies(65535, open),\n+                nCopies(65535, classEntry),\n+                nCopies(66000, provide)\n+        ));\n+    }\n+\n+    private static Label dummyLabel() {\n+        Label[] capture = new Label[1];\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            capture[0] = cob.startLabel();\n+            cob.return_();\n+        }));\n+        return capture[0];\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ListValidationTest.java","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.constant.ClassDesc;\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.classfile.ClassFile.*;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 8311172\n- * @run junit PreviewMinorVersionTest\n- * @summary Ensures ClassFile.PREVIEW_MINOR_VERSION equals that of classes with\n- *          preview minor version from ClassModel::minorVersion\n- *\/\n-public class PreviewMinorVersionTest {\n-\n-    @Test\n-    public void testMinorVersionMatches() {\n-        \/\/ compile a class with --enable-preview\n-        \/\/ uses Record feature to trigger forcePreview\n-        var cf = ClassFile.of();\n-        var cd = ClassDesc.of(\"Test\");\n-        var bytes = cf.build(cd, cb -> cb\n-                .withSuperclass(CD_Object)\n-                \/\/ old preview minor version,\n-                \/\/ with all bits set to 1\n-                .withVersion(JAVA_17_VERSION, -1)\n-        );\n-\n-        var cm = ClassFile.of().parse(bytes);\n-        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n-    }\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PreviewMinorVersionTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileVersion;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_17_VERSION;\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8311172 8361614\n+ * @summary Testing ClassFile validation of non-instruction subint (u1, u2) arguments.\n+ * @run junit SubIntValidationTest\n+ *\/\n+class SubIntValidationTest {\n+\n+    @Test\n+    public void testBuilderFlags() {\n+        ClassFile.of().build(CD_Void, clb -> {\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, -1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, 70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, -1, _ -> {}));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, 70000, _ -> {}));\n+            clb.withField(\"test\", CD_String, fb -> {\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(70000 | ACC_STATIC));\n+            });\n+            clb.withMethod(\"test\", MTD_void, ACC_STATIC, mb -> {\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(70000 | ACC_STATIC));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void testClassFileVersion() {\n+        \/\/ Prohibited but representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(0, 0));\n+        \/\/ Non-representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(JAVA_17_VERSION, 42));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(-1, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(65536, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, -2));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, 65536));\n+        ClassFile.of().build(CD_Void, clb -> assertThrows(IllegalArgumentException.class, () -> clb.withVersion(-1, 0)));\n+        \/\/ Special rule without serializing to class file format\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, ClassFileVersion.of(0, -1).minorVersion());\n+    }\n+\n+    @Test\n+    public void testReadMinorVersion() {\n+        var cf = ClassFile.of();\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, cb -> cb\n+                .withSuperclass(CD_Object)\n+                \/\/ old preview minor version,\n+                \/\/ with all bits set to 1\n+                .withVersion(JAVA_17_VERSION, -1)\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n+    }\n+\n+    \/\/ LocalVarTargetInfo\/TypeArgumentTarget in InstructionValidationTest for Label\n+    @Test\n+    public void testTypeAnnotations() {\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeParameter(TypeAnnotation.TargetType.CLASS_TYPE_PARAMETER, 0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameter(300));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassExtends(65535));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(255, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(-1, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameterBound(0, 256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofThrows(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofExceptionParameter(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.ARRAY, 2));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.INNER_TYPE, -1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.TYPE_ARGUMENT, 256));\n+    }\n+\n+    @Test\n+    public void testInnerClasses() {\n+        assertDoesNotThrow(() -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(ConstantPoolBuilder.of().classEntry(CD_String),\n+                Optional.empty(), Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testMethodParameter() {\n+        assertDoesNotThrow(() -> MethodParameterInfo.of(Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.of(Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.ofParameter(Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testModule() {\n+        assertDoesNotThrow(() -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65535, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                -1, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65536, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        ModuleAttribute.of(ModuleDesc.of(\"java.base\"), b -> {\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(65536));\n+            b.moduleFlags(0);\n+        });\n+    }\n+\n+    @Test\n+    public void testModuleExport() {\n+        assertDoesNotThrow(() -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleOpen() {\n+        assertDoesNotThrow(() -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleRequire() {\n+        assertDoesNotThrow(() -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 0, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), -1, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 65536, null));\n+    }\n+\n+    @Test\n+    public void testModuleResolution() {\n+        assertDoesNotThrow(() -> ModuleResolutionAttribute.of(256));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(65536));\n+    }\n+\n+    @Test\n+    public void testMethodHandleEntry() {\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        var ref = cp.fieldRefEntry(CD_String, \"a\", CD_int);\n+        \/\/ Intentionally choose an invalid but representable refKind\n+        assertDoesNotThrow(() -> cp.methodHandleEntry(25, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(256, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(-1, ref));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/SubIntValidationTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run main\/timeout=480 AddTest\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AddTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main TestDockerMemoryMetricsSubgroup\n+ * @run main\/timeout=480 TestDockerMemoryMetricsSubgroup\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetricsSubgroup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run driver TestGetFreeSwapSpaceSize\n+ * @run driver\/timeout=480 TestGetFreeSwapSpaceSize\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestGetFreeSwapSpaceSize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run driver TestLimitsUpdating\n+ * @run driver\/timeout=480 TestLimitsUpdating\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestLimitsUpdating.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run driver TestPidsLimit\n+ * @run driver\/timeout=480 TestPidsLimit\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -176,1 +176,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n@@ -196,1 +196,1 @@\n- * @run main\/othervm   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ * @run main\/othervm\/timeout=480   -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/BasicExt.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                Fuzz\n@@ -56,3 +56,3 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               -XX:+PreserveFramePointer\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                -XX:+PreserveFramePointer\n+ *                                Fuzz\n@@ -90,2 +90,1 @@\n-    static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    static int COMPILATION_TIMEOUT = (int)(5_000 * timeoutFactor); \/\/ ms\n+    static int COMPILATION_TIMEOUT = (int)(5_000 * Utils.TIMEOUT_FACTOR); \/\/ ms\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xlog:jfr+streaming+system=trace jdk.jfr.api.consumer.recordingstream.TestClose\n+ * @run main\/othervm\/timeout=480 -Xlog:jfr+streaming+system=trace jdk.jfr.api.consumer.recordingstream.TestClose\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n+ * @run main\/othervm\/timeout=480 -Xlog:jfr=warning jdk.jfr.api.metadata.annotations.TestStackFilter\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestStackFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-* @run main\/othervm jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n+* @run main\/othervm\/timeout=480 jdk.jfr.event.oldobject.TestEmergencyDumpAtOOM\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestEmergencyDumpAtOOM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectDescription\n+ * @run main\/othervm\/timeout=960 -XX:TLABSize=2k jdk.jfr.event.oldobject.TestObjectDescription\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n+ * @run main\/timeout=480 jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleMultipleRecordings.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm jdk.jfr.jvm.TestModularImage\n+ * @run main\/othervm\/timeout=480 jdk.jfr.jvm.TestModularImage\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestModularImage.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Point;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.SampleModel;\n+import java.awt.image.WritableRaster;\n+import java.io.File;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_GRAY;\n+\n+\/**\n+ * @test\n+ * @bug 8366208\n+ * @summary Verifies ColorConvertOp works correctly with BufferedImage and\n+ *          semi-custom raster\n+ *\/\n+public final class FilterSemiCustomImages {\n+\n+    private static final int W = 144;\n+    private static final int H = 123;\n+\n+    private static final int[] TYPES = {\n+            TYPE_INT_RGB, TYPE_INT_ARGB, TYPE_INT_ARGB_PRE, TYPE_INT_BGR,\n+            TYPE_3BYTE_BGR, TYPE_4BYTE_ABGR, TYPE_4BYTE_ABGR_PRE,\n+            TYPE_USHORT_GRAY\n+    };\n+\n+    private static final int[] CSS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    private static final class CustomRaster extends WritableRaster {\n+        CustomRaster(SampleModel sampleModel, Point origin) {\n+            super(sampleModel, origin);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int fromIndex : CSS) {\n+            for (int toIndex : CSS) {\n+                if (fromIndex != toIndex) {\n+                    for (int type : TYPES) {\n+                        test(fromIndex, toIndex, type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void test(int fromIndex, int toIndex, int type)\n+            throws Exception\n+    {\n+        ColorSpace fromCS = ColorSpace.getInstance(fromIndex);\n+        ColorSpace toCS = ColorSpace.getInstance(toIndex);\n+        ColorConvertOp op = new ColorConvertOp(fromCS, toCS, null);\n+\n+        \/\/ standard source -> standard dst\n+        BufferedImage srcGold = new BufferedImage(W, H, type);\n+        fill(srcGold);\n+        BufferedImage dstGold = new BufferedImage(W, H, type);\n+        op.filter(srcGold, dstGold);\n+\n+        \/\/ custom source -> standard dst\n+        BufferedImage srcCustom = makeCustomBI(srcGold);\n+        fill(srcCustom);\n+        BufferedImage dst = new BufferedImage(W, H, type);\n+        op.filter(srcCustom, dst);\n+        verify(dstGold, dst);\n+\n+        \/\/ standard source -> custom dst\n+        BufferedImage src = new BufferedImage(W, H, type);\n+        fill(src);\n+        BufferedImage dstCustom = makeCustomBI(dstGold);\n+        op.filter(src, dstCustom);\n+        verify(dstGold, dstCustom);\n+\n+        \/\/ custom source -> custom dst\n+        srcCustom = makeCustomBI(srcGold);\n+        fill(srcCustom);\n+        dstCustom = makeCustomBI(dstGold);\n+        op.filter(srcCustom, dstCustom);\n+        verify(dstGold, dstCustom);\n+    }\n+\n+    private static BufferedImage makeCustomBI(BufferedImage bi) {\n+        ColorModel cm = bi.getColorModel();\n+        SampleModel sm = bi.getSampleModel();\n+        CustomRaster cr = new CustomRaster(sm, new Point());\n+        return new BufferedImage(cm, cr, bi.isAlphaPremultiplied(), null) {\n+            @Override\n+            public int getType() {\n+                return bi.getType();\n+            }\n+        };\n+    }\n+\n+    private static void fill(BufferedImage image) {\n+        int width = image.getWidth();\n+        int height = image.getHeight();\n+        for (int x = 0; x < width; ++x) {\n+            for (int y = 0; y < height; ++y) {\n+                \/\/ alpha channel may be calculated slightly differently on\n+                \/\/ different code paths, so only check fully transparent and\n+                \/\/ fully opaque pixels\n+                Color c = new Color(y * 255 \/ (height - 1),\n+                                    x * 255 \/ (width - 1),\n+                                    x % 255,\n+                                    (x % 2 == 0) ? 0 : 255);\n+                image.setRGB(x, y, c.getRGB());\n+            }\n+        }\n+    }\n+\n+    private static void verify(BufferedImage dstGold, BufferedImage dst)\n+            throws Exception\n+    {\n+        for (int x = 0; x < W; ++x) {\n+            for (int y = 0; y < H; ++y) {\n+                if (dst.getRGB(x, y) != dstGold.getRGB(x, y)) {\n+                    ImageIO.write(dst, \"png\", new File(\"custom.png\"));\n+                    ImageIO.write(dstGold, \"png\", new File(\"gold.png\"));\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/FilterSemiCustomImages.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.test.lib.Utils;\n@@ -72,1 +73,1 @@\n- * @run main\/othervm MonitorVmStartTerminate\n+ * @run main\/othervm\/timeout=240 MonitorVmStartTerminate\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/MonitorVmStartTerminate.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,5 +37,8 @@\n-import java.net.*;\n-import java.util.*;\n-import java.io.*;\n-import javax.net.ssl.*;\n-import java.security.Security;\n+\n+import java.io.PrintStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.URL;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n@@ -43,1 +46,4 @@\n-import java.security.KeyFactory;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.security.cert.X509Certificate;\n+\n@@ -45,3 +51,0 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.spec.*;\n-import java.security.interfaces.*;\n@@ -50,355 +53,16 @@\n-\n-\/*\n- * Certificates and key used in the test.\n- *\n- * TLS server certificate:\n- * server private key:\n- * -----BEGIN RSA PRIVATE KEY-----\n- * Proc-Type: 4,ENCRYPTED\n- * DEK-Info: DES-EDE3-CBC,D9AE407F6D0E389A\n- *\n- * WPrA7TFol\/cQCcp9oHnXWNpYlvRbbIcQj0m+RKT2Iuzfus+DHt3Zadf8nJpKfX2e\n- * h2rnhlzCN9M7djRDooZKDOPCsdBn51Au7HlZF3S3Opgo7D8XFM1a8t1Je4ke14oI\n- * nw6QKYsBblRziPnP2PZ0zvX24nOv7bbY8beynlJHGs00VWSFdoH2DS0aE1p6D+3n\n- * ptJuJ75dVfZFK4X7162APlNXevX8D6PEQpSiRw1rjjGGcnvQ4HdWk3BxDVDcCNJb\n- * Y1aGNRxsjTDvPi3R9Qx2M+W03QzEPx4SR3ZHVskeSJHaetM0TM\/w\/45Paq4GokXP\n- * ZeTnbEx1xmjkA7h+t4doLL4watx5F6yLsJzu8xB3lt\/1EtmkYtLz1t7X4BetPAXz\n- * zS69X\/VwhKfsOI3qXBWuL2oHPyhDmT1gcaUQwEPSV6ogHEEQEDXdiUS8heNK13KF\n- * TCQYFkETvV2BLxUhV1hypPzRQ6tUpJiAbD5KmoK2lD9slshG2QtvKQq0\/bgkDY5J\n- * LhDHV2dtcZ3kDPkkZXpbcJQvoeH3d09C5sIsuTFo2zgNR6oETHUc5TzP6FY2YYRa\n- * QcK5HcmtsRRiXFm01ac+aMejJUIujjFt84SiKWT\/73vC8AmY4tYcJBLjCg4XIxSH\n- * fdDFLL1YZENNO5ivlp8mdiHqcawx+36L7DrEZQ8RZt6cqST5t\/+XTdM74s6k81GT\n- * pNsa82P2K2zmIUZ\/DL2mKjW1vfRByw1NQFEBkN3vdyZxYfM\/JyUzX4hbjXBEkh9Q\n- * QYrcwLKLjis2QzSvK04B3bvRzRb+4ocWiso8ZPAXAIxZFBWDpTMM2A==\n- * -----END RSA PRIVATE KEY-----\n- *\n- * -----BEGIN RSA PRIVATE KEY-----\n- * MIICXAIBAAKBgQClrFscN6LdmYktsnm4j9VIpecchBeNaZzGrG358h0fORna03Ie\n- * buxEzHCk3LoAMPagTz1UemFqzFfQCn+VKBg\/mtmU8hvIJIh+\/p0PPftXUwizIDPU\n- * PxdHFNHN6gjYDnVOr77M0uyvqXpJ38LZrLgkQJCmA1Yq0DAFQCxPq9l0iQIDAQAB\n- * AoGAbqcbg1E1mkR99uOJoNeQYKFOJyGiiXTMnXV1TseC4+PDfQBU7Dax35GcesBi\n- * CtapIpFKKS5D+ozY6b7ZT8ojxuQ\/uHLPAvz0WDR3ds4iRF8tyu71Q1ZHcQsJa17y\n- * yO7UbkSSKn\/Mp9Rb+\/dKqftUGNXVFLqgHBOzN2s3We3bbbECQQDYBPKOg3hkaGHo\n- * OhpHKqtQ6EVkldihG\/3i4WejRonelXN+HRh1KrB2HBx0M8D\/qAzP1i3rNSlSHer4\n- * 59YRTJnHAkEAxFX\/sVYSn07BHv9Zhn6XXct\/Cj43z\/tKNbzlNbcxqQwQerw3IH51\n- * 8UH2YOA+GD3lXbKp+MytoFLWv8zg4YT\/LwJAfqan75Z1R6lLffRS49bIiq8jwE16\n- * rTrUJ+kv8jKxMqc9B3vXkxpsS1M\/+4E8bqgAmvpgAb8xcsvHsBd9ErdukQJBAKs2\n- * j67W75BrPjBI34pQ1LEfp56IGWXOrq1kF8IbCjxv3+MYRT6Z6UJFkpRymNPNDjsC\n- * dgUYgITiGJHUGXuw3lMCQHEHqo9ZtXz92yFT+VhsNc29B8m\/sqUJdtCcMd\/jGpAF\n- * u6GHufjqIZBpQsk63wbwESAPZZ+kk1O1kS5GIRLX608=\n- * -----END RSA PRIVATE KEY-----\n- *\n- * Private-Key: (1024 bit)\n- * modulus:\n- *     00:a5:ac:5b:1c:37:a2:dd:99:89:2d:b2:79:b8:8f:\n- *     d5:48:a5:e7:1c:84:17:8d:69:9c:c6:ac:6d:f9:f2:\n- *     1d:1f:39:19:da:d3:72:1e:6e:ec:44:cc:70:a4:dc:\n- *     ba:00:30:f6:a0:4f:3d:54:7a:61:6a:cc:57:d0:0a:\n- *     7f:95:28:18:3f:9a:d9:94:f2:1b:c8:24:88:7e:fe:\n- *     9d:0f:3d:fb:57:53:08:b3:20:33:d4:3f:17:47:14:\n- *     d1:cd:ea:08:d8:0e:75:4e:af:be:cc:d2:ec:af:a9:\n- *     7a:49:df:c2:d9:ac:b8:24:40:90:a6:03:56:2a:d0:\n- *     30:05:40:2c:4f:ab:d9:74:89\n- * publicExponent: 65537 (0x10001)\n- * privateExponent:\n- *     6e:a7:1b:83:51:35:9a:44:7d:f6:e3:89:a0:d7:90:\n- *     60:a1:4e:27:21:a2:89:74:cc:9d:75:75:4e:c7:82:\n- *     e3:e3:c3:7d:00:54:ec:36:b1:df:91:9c:7a:c0:62:\n- *     0a:d6:a9:22:91:4a:29:2e:43:fa:8c:d8:e9:be:d9:\n- *     4f:ca:23:c6:e4:3f:b8:72:cf:02:fc:f4:58:34:77:\n- *     76:ce:22:44:5f:2d:ca:ee:f5:43:56:47:71:0b:09:\n- *     6b:5e:f2:c8:ee:d4:6e:44:92:2a:7f:cc:a7:d4:5b:\n- *     fb:f7:4a:a9:fb:54:18:d5:d5:14:ba:a0:1c:13:b3:\n- *     37:6b:37:59:ed:db:6d:b1\n- * prime1:\n- *     00:d8:04:f2:8e:83:78:64:68:61:e8:3a:1a:47:2a:\n- *     ab:50:e8:45:64:95:d8:a1:1b:fd:e2:e1:67:a3:46:\n- *     89:de:95:73:7e:1d:18:75:2a:b0:76:1c:1c:74:33:\n- *     c0:ff:a8:0c:cf:d6:2d:eb:35:29:52:1d:ea:f8:e7:\n- *     d6:11:4c:99:c7\n- * prime2:\n- *     00:c4:55:ff:b1:56:12:9f:4e:c1:1e:ff:59:86:7e:\n- *     97:5d:cb:7f:0a:3e:37:cf:fb:4a:35:bc:e5:35:b7:\n- *     31:a9:0c:10:7a:bc:37:20:7e:75:f1:41:f6:60:e0:\n- *     3e:18:3d:e5:5d:b2:a9:f8:cc:ad:a0:52:d6:bf:cc:\n- *     e0:e1:84:ff:2f\n- * exponent1:\n- *     7e:a6:a7:ef:96:75:47:a9:4b:7d:f4:52:e3:d6:c8:\n- *     8a:af:23:c0:4d:7a:ad:3a:d4:27:e9:2f:f2:32:b1:\n- *     32:a7:3d:07:7b:d7:93:1a:6c:4b:53:3f:fb:81:3c:\n- *     6e:a8:00:9a:fa:60:01:bf:31:72:cb:c7:b0:17:7d:\n- *     12:b7:6e:91\n- * exponent2:\n- *     00:ab:36:8f:ae:d6:ef:90:6b:3e:30:48:df:8a:50:\n- *     d4:b1:1f:a7:9e:88:19:65:ce:ae:ad:64:17:c2:1b:\n- *     0a:3c:6f:df:e3:18:45:3e:99:e9:42:45:92:94:72:\n- *     98:d3:cd:0e:3b:02:76:05:18:80:84:e2:18:91:d4:\n- *     19:7b:b0:de:53\n- * coefficient:\n- *     71:07:aa:8f:59:b5:7c:fd:db:21:53:f9:58:6c:35:\n- *     cd:bd:07:c9:bf:b2:a5:09:76:d0:9c:31:df:e3:1a:\n- *     90:05:bb:a1:87:b9:f8:ea:21:90:69:42:c9:3a:df:\n- *     06:f0:11:20:0f:65:9f:a4:93:53:b5:91:2e:46:21:\n- *     12:d7:eb:4f\n- *\n- *\n- * server certificate:\n- * Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 7 (0x7)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 03:27:57 2008 GMT\n- *         Not After : Aug 25 03:27:57 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org, OU=SSL-Server, CN=localhost\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:a5:ac:5b:1c:37:a2:dd:99:89:2d:b2:79:b8:8f:\n- *                 d5:48:a5:e7:1c:84:17:8d:69:9c:c6:ac:6d:f9:f2:\n- *                 1d:1f:39:19:da:d3:72:1e:6e:ec:44:cc:70:a4:dc:\n- *                 ba:00:30:f6:a0:4f:3d:54:7a:61:6a:cc:57:d0:0a:\n- *                 7f:95:28:18:3f:9a:d9:94:f2:1b:c8:24:88:7e:fe:\n- *                 9d:0f:3d:fb:57:53:08:b3:20:33:d4:3f:17:47:14:\n- *                 d1:cd:ea:08:d8:0e:75:4e:af:be:cc:d2:ec:af:a9:\n- *                 7a:49:df:c2:d9:ac:b8:24:40:90:a6:03:56:2a:d0:\n- *                 30:05:40:2c:4f:ab:d9:74:89\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Basic Constraints:\n- *             CA:FALSE\n- *         X509v3 Key Usage:\n- *             Digital Signature, Non Repudiation, Key Encipherment\n- *         X509v3 Subject Key Identifier:\n- *             ED:6E:DB:F4:B5:56:C8:FB:1A:06:61:3F:0F:08:BB:A6:04:D8:16:54\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *\n- *         X509v3 Subject Alternative Name: critical\n- *             IP Address:127.0.0.1\n- * Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICnzCCAgigAwIBAgIBBzANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3NTdaFw0yODA4MjUwMzI3NTdaMHIxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtU2VydmVyMRIwEAYD\n- * VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKWsWxw3\n- * ot2ZiS2yebiP1Uil5xyEF41pnMasbfnyHR85GdrTch5u7ETMcKTcugAw9qBPPVR6\n- * YWrMV9AKf5UoGD+a2ZTyG8gkiH7+nQ89+1dTCLMgM9Q\/F0cU0c3qCNgOdU6vvszS\n- * 7K+peknfwtmsuCRAkKYDVirQMAVALE+r2XSJAgMBAAGjbjBsMAkGA1UdEwQCMAAw\n- * CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTtbtv0tVbI+xoGYT8PCLumBNgWVDAfBgNV\n- * HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\n- * MA0GCSqGSIb3DQEBBAUAA4GBAFJjItCtCBZcjD69wdqfIbKmRFa6eJAjR6LcoDva\n- * cKC\/sDOLelpspiZ66Zb0Xdv5qQ7QrfOXt3K8QqJKRMdZLF9WfUfy0gJDM32ub91h\n- * pu+TmcGPs+6RdrAQcuvU1ZDV9X8SMj7BtKaim4d5sqFw1npncKiA5xFn8vOYwdun\n- * nZif\n- * -----END CERTIFICATE-----\n- *\n- *\n- * TLS client certificate:\n- * client private key:\n- * ----BEGIN RSA PRIVATE KEY-----\n- * Proc-Type: 4,ENCRYPTED\n- * DEK-Info: DES-EDE3-CBC,FA2A435CD35A9390\n- *\n- * Z+Y2uaETbsUWIyJUyVu1UV2G4rgFYJyACZT6Tp1KjRtxflSh2kXkJ9MpuXMXA0V4\n- * Yy3fDzPqCL9NJmQAYRlAx\/W\/+j4F5EyMWDIx8fUxzONRZyoiwF7jLm+KscAfv6Pf\n- * q7ItWOdj3z7IYrwlB8YIGd3F2cDKT3S+lYRk7rKb\/qT7itbuHnY4Ardh3yl+MZak\n- * jBp+ELUlRsUqSr1V0LoM+0rCCykarpyfhpxEcqsrl0v9Cyi5uhU50\/oKv5zql3SH\n- * l2ImgDjp3batAs8+Bd4NF2aqi0a7Hy44JUHxRm4caZryU\/i\/D9N1MbuM6882HLat\n- * 5N0G+NaIUfywa8mjwq2D5aiit18HqKA6XeRRYeJ5Dvu9DCO4GeFSwcUFIBMI0L46\n- * 7s114+oDodg57pMgITi+04vmUxvqlN9aiyd7f5Fgd7PeHGeOdbMz1NaJLJaPI9++\n- * NakK8eK9iwT\/Gdq0Uap5\/CHW7vCT5PO+h3HY0STH0lWStXhdWnFO04zTdywsbSp+\n- * DLpHeFT66shfeUlxR0PsCbG9vPRt\/QmGLeYQZITppWo\/ylSq4j+pRIuXvuWHdBRN\n- * rTZ8QF4Y7AxQUXVz1j1++s6ZMHTzaK2i9HrhmDs1MbJl+QwWre3Xpv3LvTVz3k5U\n- * wX8kuY1m3STt71QCaRWENq5sRaMImLxZbxc\/ivFl9RAzUqo4NCxLod\/QgA4iLqtO\n- * ztnlpzwlC\/F8HbQ1oqYWwnZAPhzU\/cULtstl+Yrws2c2atO323LbPXZqbASySgig\n- * sNpFXQMObdfP6LN23bY+1SvtK7V4NUTNhpdIc6INQAQ=\n- * -----END RSA PRIVATE KEY-----\n- *\n- * -----BEGIN RSA PRIVATE KEY-----\n- * MIICWwIBAAKBgQC78EA2rCZUTvSjWgAvaSFvuXo6k+yi9uGOx2PYLxIwmS6w8o\/4\n- * Jy0keCiE9wG\/jUR53TvSVfPOPLJbIX3v\/TNKsaP\/xsibuQ98QTWX+ds6BWAFFa9Z\n- * F5KjEK0WHOQHU6+odqJWKpLT+SjgeM9eH0irXBnd4WdDunWN9YKsQ5JEGwIDAQAB\n- * AoGAEbdqNj0wN85hnWyEi\/ObJU8UyKTdL9eaF72QGfcF\/fLSxfd3vurihIeXOkGW\n- * tpn4lIxYcVGM9CognhqgJpl11jFTQzn1KqZ+NEJRKkCHA4hDabKJbSC9fXHvRwrf\n- * BsFpZqgiNxp3HseUTiwnaUVeyPgMt\/jAj5nB5Sib+UyUxrECQQDnNQBiF2aifEg6\n- * zbJOOC7he5CHAdkFxSxWVFVHL6EfXfqdLVkUohMbgZv+XxyIeU2biOExSg49Kds3\n- * FOKgTau1AkEA0Bd1haj6QuCo8I0AXm2WO+MMTZMTvtHD\/bGjKNM+fT4I8rKYnQRX\n- * 1acHdqS9Xx2rNJqZgkMmpESIdPR2fc4yjwJALFeM6EMmqvj8\/VIf5UJ\/Mz14fXwM\n- * PEARfckUxd9LnnFutCBTWlKvKXJVEZb6KO5ixPaegc57Jp3Vbh3yTN44lQJADD\/1\n- * SSMDaIB1MYP7a5Oj7m6VQNPRq8AJe5vDcRnOae0G9dKRrVyeFxO4GsHj6\/+BHp2j\n- * P8nYMn9eURQ7DXjf\/QJAAQzMlWnKGSO8pyTDtnQx3hRMoUkOEhmNq4bQhLkYqtnY\n- * FcqpUQ2qMjW+NiNWk5HnTrMS3L9EdJobMUzaNZLy4w==\n- * -----END RSA PRIVATE KEY-----\n- *\n- * Private-Key: (1024 bit)\n- * modulus:\n- *     00:bb:f0:40:36:ac:26:54:4e:f4:a3:5a:00:2f:69:\n- *     21:6f:b9:7a:3a:93:ec:a2:f6:e1:8e:c7:63:d8:2f:\n- *     12:30:99:2e:b0:f2:8f:f8:27:2d:24:78:28:84:f7:\n- *     01:bf:8d:44:79:dd:3b:d2:55:f3:ce:3c:b2:5b:21:\n- *     7d:ef:fd:33:4a:b1:a3:ff:c6:c8:9b:b9:0f:7c:41:\n- *     35:97:f9:db:3a:05:60:05:15:af:59:17:92:a3:10:\n- *     ad:16:1c:e4:07:53:af:a8:76:a2:56:2a:92:d3:f9:\n- *     28:e0:78:cf:5e:1f:48:ab:5c:19:dd:e1:67:43:ba:\n- *     75:8d:f5:82:ac:43:92:44:1b\n- * publicExponent: 65537 (0x10001)\n- * privateExponent:\n- *     11:b7:6a:36:3d:30:37:ce:61:9d:6c:84:8b:f3:9b:\n- *     25:4f:14:c8:a4:dd:2f:d7:9a:17:bd:90:19:f7:05:\n- *     fd:f2:d2:c5:f7:77:be:ea:e2:84:87:97:3a:41:96:\n- *     b6:99:f8:94:8c:58:71:51:8c:f4:2a:20:9e:1a:a0:\n- *     26:99:75:d6:31:53:43:39:f5:2a:a6:7e:34:42:51:\n- *     2a:40:87:03:88:43:69:b2:89:6d:20:bd:7d:71:ef:\n- *     47:0a:df:06:c1:69:66:a8:22:37:1a:77:1e:c7:94:\n- *     4e:2c:27:69:45:5e:c8:f8:0c:b7:f8:c0:8f:99:c1:\n- *     e5:28:9b:f9:4c:94:c6:b1\n- * prime1:\n- *     00:e7:35:00:62:17:66:a2:7c:48:3a:cd:b2:4e:38:\n- *     2e:e1:7b:90:87:01:d9:05:c5:2c:56:54:55:47:2f:\n- *     a1:1f:5d:fa:9d:2d:59:14:a2:13:1b:81:9b:fe:5f:\n- *     1c:88:79:4d:9b:88:e1:31:4a:0e:3d:29:db:37:14:\n- *     e2:a0:4d:ab:b5\n- * prime2:\n- *     00:d0:17:75:85:a8:fa:42:e0:a8:f0:8d:00:5e:6d:\n- *     96:3b:e3:0c:4d:93:13:be:d1:c3:fd:b1:a3:28:d3:\n- *     3e:7d:3e:08:f2:b2:98:9d:04:57:d5:a7:07:76:a4:\n- *     bd:5f:1d:ab:34:9a:99:82:43:26:a4:44:88:74:f4:\n- *     76:7d:ce:32:8f\n- * exponent1:\n- *     2c:57:8c:e8:43:26:aa:f8:fc:fd:52:1f:e5:42:7f:\n- *     33:3d:78:7d:7c:0c:3c:40:11:7d:c9:14:c5:df:4b:\n- *     9e:71:6e:b4:20:53:5a:52:af:29:72:55:11:96:fa:\n- *     28:ee:62:c4:f6:9e:81:ce:7b:26:9d:d5:6e:1d:f2:\n- *     4c:de:38:95\n- * exponent2:\n- *     0c:3f:f5:49:23:03:68:80:75:31:83:fb:6b:93:a3:\n- *     ee:6e:95:40:d3:d1:ab:c0:09:7b:9b:c3:71:19:ce:\n- *     69:ed:06:f5:d2:91:ad:5c:9e:17:13:b8:1a:c1:e3:\n- *     eb:ff:81:1e:9d:a3:3f:c9:d8:32:7f:5e:51:14:3b:\n- *     0d:78:df:fd\n- * coefficient:\n- *     01:0c:cc:95:69:ca:19:23:bc:a7:24:c3:b6:74:31:\n- *     de:14:4c:a1:49:0e:12:19:8d:ab:86:d0:84:b9:18:\n- *     aa:d9:d8:15:ca:a9:51:0d:aa:32:35:be:36:23:56:\n- *     93:91:e7:4e:b3:12:dc:bf:44:74:9a:1b:31:4c:da:\n- *     35:92:f2:e3\n- *\n- * client certificate:\n- * Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 6 (0x6)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 03:27:34 2008 GMT\n- *         Not After : Aug 25 03:27:34 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org, OU=SSL-Client, CN=localhost\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:bb:f0:40:36:ac:26:54:4e:f4:a3:5a:00:2f:69:\n- *                 21:6f:b9:7a:3a:93:ec:a2:f6:e1:8e:c7:63:d8:2f:\n- *                 12:30:99:2e:b0:f2:8f:f8:27:2d:24:78:28:84:f7:\n- *                 01:bf:8d:44:79:dd:3b:d2:55:f3:ce:3c:b2:5b:21:\n- *                 7d:ef:fd:33:4a:b1:a3:ff:c6:c8:9b:b9:0f:7c:41:\n- *                 35:97:f9:db:3a:05:60:05:15:af:59:17:92:a3:10:\n- *                 ad:16:1c:e4:07:53:af:a8:76:a2:56:2a:92:d3:f9:\n- *                 28:e0:78:cf:5e:1f:48:ab:5c:19:dd:e1:67:43:ba:\n- *                 75:8d:f5:82:ac:43:92:44:1b\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Basic Constraints:\n- *             CA:FALSE\n- *         X509v3 Key Usage:\n- *             Digital Signature, Non Repudiation, Key Encipherment\n- *         X509v3 Subject Key Identifier:\n- *             CD:BB:C8:85:AA:91:BD:FD:1D:BE:CD:67:7C:FF:B3:E9:4C:A8:22:E6\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *\n- *         X509v3 Subject Alternative Name: critical\n- *             IP Address:127.0.0.1\n- * Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICnzCCAgigAwIBAgIBBjANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3MzRaFw0yODA4MjUwMzI3MzRaMHIxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtQ2xpZW50MRIwEAYD\n- * VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALvwQDas\n- * JlRO9KNaAC9pIW+5ejqT7KL24Y7HY9gvEjCZLrDyj\/gnLSR4KIT3Ab+NRHndO9JV\n- * 8848slshfe\/9M0qxo\/\/GyJu5D3xBNZf52zoFYAUVr1kXkqMQrRYc5AdTr6h2olYq\n- * ktP5KOB4z14fSKtcGd3hZ0O6dY31gqxDkkQbAgMBAAGjbjBsMAkGA1UdEwQCMAAw\n- * CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTNu8iFqpG9\/R2+zWd8\/7PpTKgi5jAfBgNV\n- * HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\n- * MA0GCSqGSIb3DQEBBAUAA4GBACjj9PS+W6XOF7toFMwMOv\/AemZeBOpcEF1Ei1Hx\n- * HjvB6EOHkMY8tFm5OPzkiWiK3+s3awpSW0jWdzMYwrQJ3\/klMsPDpI7PEuirqwHP\n- * i5Wyl\/vk7jmfWVcBO9MVhPUo4BYl4vS9aj6JA5QbkbkB95LOgT\/BowY0WmHeVsXC\n- * I9aw\n- * -----END CERTIFICATE-----\n- *\n- *\n- *\n- * Trusted CA certificate:\n- * Certificate:\n- *   Data:\n- *     Version: 3 (0x2)\n- *     Serial Number: 0 (0x0)\n- *     Signature Algorithm: md5WithRSAEncryption\n- *     Issuer: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Validity\n- *         Not Before: Dec  8 02:43:36 2008 GMT\n- *         Not After : Aug 25 02:43:36 2028 GMT\n- *     Subject: C=US, ST=Some-State, L=Some-City, O=Some-Org\n- *     Subject Public Key Info:\n- *         Public Key Algorithm: rsaEncryption\n- *         RSA Public Key: (1024 bit)\n- *             Modulus (1024 bit):\n- *                 00:cb:c4:38:20:07:be:88:a7:93:b0:a1:43:51:2d:\n- *                 d7:8e:85:af:54:dd:ad:a2:7b:23:5b:cf:99:13:53:\n- *                 99:45:7d:ee:6d:ba:2d:bf:e3:ad:6e:3d:9f:1a:f9:\n- *                 03:97:e0:17:55:ae:11:26:57:de:01:29:8e:05:3f:\n- *                 21:f7:e7:36:e8:2e:37:d7:48:ac:53:d6:60:0e:c7:\n- *                 50:6d:f6:c5:85:f7:8b:a6:c5:91:35:72:3c:94:ee:\n- *                 f1:17:f0:71:e3:ec:1b:ce:ca:4e:40:42:b0:6d:ee:\n- *                 6a:0e:d6:e5:ad:3c:0f:c9:ba:82:4f:78:f8:89:97:\n- *                 89:2a:95:12:4c:d8:09:2a:e9\n- *             Exponent: 65537 (0x10001)\n- *     X509v3 extensions:\n- *         X509v3 Subject Key Identifier:\n- *             FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *         X509v3 Authority Key Identifier:\n- *             keyid:FA:B9:51:BF:4C:E7:D9:86:98:33:F9:E7:CB:1E:F1:33:49:F7:A8:14\n- *             DirName:\/C=US\/ST=Some-State\/L=Some-City\/O=Some-Org\n- *             serial:00\n- *\n- *         X509v3 Basic Constraints:\n- *             CA:TRUE\n- *  Signature Algorithm: md5WithRSAEncryption\n- *\n- * -----BEGIN CERTIFICATE-----\n- * MIICrDCCAhWgAwIBAgIBADANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\n- * MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\n- * EwhTb21lLU9yZzAeFw0wODEyMDgwMjQzMzZaFw0yODA4MjUwMjQzMzZaMEkxCzAJ\n- * BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\n- * dHkxETAPBgNVBAoTCFNvbWUtT3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\n- * gQDLxDggB76Ip5OwoUNRLdeOha9U3a2ieyNbz5kTU5lFfe5tui2\/461uPZ8a+QOX\n- * 4BdVrhEmV94BKY4FPyH35zboLjfXSKxT1mAOx1Bt9sWF94umxZE1cjyU7vEX8HHj\n- * 7BvOyk5AQrBt7moO1uWtPA\/JuoJPePiJl4kqlRJM2Akq6QIDAQABo4GjMIGgMB0G\n- * A1UdDgQWBBT6uVG\/TOfZhpgz+efLHvEzSfeoFDBxBgNVHSMEajBogBT6uVG\/TOfZ\n- * hpgz+efLHvEzSfeoFKFNpEswSTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUt\n- * U3RhdGUxEjAQBgNVBAcTCVNvbWUtQ2l0eTERMA8GA1UEChMIU29tZS1PcmeCAQAw\n- * DAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQQFAAOBgQBcIm534U123Hz+rtyYO5uA\n- * ofd81G6FnTfEAV8Kw9fGyyEbQZclBv34A9JsFKeMvU4OFIaixD7nLZ\/NZ+IWbhmZ\n- * LovmJXyCkOufea73pNiZ+f\/4\/ScZaIlM\/PRycQSqbFNd4j9Wott+08qxHPLpsf3P\n- * 6Mvf0r1PNTY2hwTJLJmKtg==\n- * -----END CERTIFICATE---\n- *\/\n+import jdk.test.lib.security.CertificateBuilder;\n+import jdk.test.lib.security.CertificateBuilder.KeyUsage;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n@@ -408,2 +72,0 @@\n-    static Map cookies;\n-    ServerSocket ss;\n@@ -424,202 +86,8 @@\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String trusedCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICrDCCAhWgAwIBAgIBADANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMjQzMzZaFw0yODA4MjUwMjQzMzZaMEkxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKB\\n\" +\n-        \"gQDLxDggB76Ip5OwoUNRLdeOha9U3a2ieyNbz5kTU5lFfe5tui2\/461uPZ8a+QOX\\n\" +\n-        \"4BdVrhEmV94BKY4FPyH35zboLjfXSKxT1mAOx1Bt9sWF94umxZE1cjyU7vEX8HHj\\n\" +\n-        \"7BvOyk5AQrBt7moO1uWtPA\/JuoJPePiJl4kqlRJM2Akq6QIDAQABo4GjMIGgMB0G\\n\" +\n-        \"A1UdDgQWBBT6uVG\/TOfZhpgz+efLHvEzSfeoFDBxBgNVHSMEajBogBT6uVG\/TOfZ\\n\" +\n-        \"hpgz+efLHvEzSfeoFKFNpEswSTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUt\\n\" +\n-        \"U3RhdGUxEjAQBgNVBAcTCVNvbWUtQ2l0eTERMA8GA1UEChMIU29tZS1PcmeCAQAw\\n\" +\n-        \"DAYDVR0TBAUwAwEB\/zANBgkqhkiG9w0BAQQFAAOBgQBcIm534U123Hz+rtyYO5uA\\n\" +\n-        \"ofd81G6FnTfEAV8Kw9fGyyEbQZclBv34A9JsFKeMvU4OFIaixD7nLZ\/NZ+IWbhmZ\\n\" +\n-        \"LovmJXyCkOufea73pNiZ+f\/4\/ScZaIlM\/PRycQSqbFNd4j9Wott+08qxHPLpsf3P\\n\" +\n-        \"6Mvf0r1PNTY2hwTJLJmKtg==\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    static String serverCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICnzCCAgigAwIBAgIBBzANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3NTdaFw0yODA4MjUwMzI3NTdaMHIxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtU2VydmVyMRIwEAYD\\n\" +\n-        \"VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAKWsWxw3\\n\" +\n-        \"ot2ZiS2yebiP1Uil5xyEF41pnMasbfnyHR85GdrTch5u7ETMcKTcugAw9qBPPVR6\\n\" +\n-        \"YWrMV9AKf5UoGD+a2ZTyG8gkiH7+nQ89+1dTCLMgM9Q\/F0cU0c3qCNgOdU6vvszS\\n\" +\n-        \"7K+peknfwtmsuCRAkKYDVirQMAVALE+r2XSJAgMBAAGjbjBsMAkGA1UdEwQCMAAw\\n\" +\n-        \"CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTtbtv0tVbI+xoGYT8PCLumBNgWVDAfBgNV\\n\" +\n-        \"HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\\n\" +\n-        \"MA0GCSqGSIb3DQEBBAUAA4GBAFJjItCtCBZcjD69wdqfIbKmRFa6eJAjR6LcoDva\\n\" +\n-        \"cKC\/sDOLelpspiZ66Zb0Xdv5qQ7QrfOXt3K8QqJKRMdZLF9WfUfy0gJDM32ub91h\\n\" +\n-        \"pu+TmcGPs+6RdrAQcuvU1ZDV9X8SMj7BtKaim4d5sqFw1npncKiA5xFn8vOYwdun\\n\" +\n-        \"nZif\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-    static String clientCertStr =\n-        \"-----BEGIN CERTIFICATE-----\\n\" +\n-        \"MIICnzCCAgigAwIBAgIBBjANBgkqhkiG9w0BAQQFADBJMQswCQYDVQQGEwJVUzET\\n\" +\n-        \"MBEGA1UECBMKU29tZS1TdGF0ZTESMBAGA1UEBxMJU29tZS1DaXR5MREwDwYDVQQK\\n\" +\n-        \"EwhTb21lLU9yZzAeFw0wODEyMDgwMzI3MzRaFw0yODA4MjUwMzI3MzRaMHIxCzAJ\\n\" +\n-        \"BgNVBAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMRIwEAYDVQQHEwlTb21lLUNp\\n\" +\n-        \"dHkxETAPBgNVBAoTCFNvbWUtT3JnMRMwEQYDVQQLEwpTU0wtQ2xpZW50MRIwEAYD\\n\" +\n-        \"VQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBALvwQDas\\n\" +\n-        \"JlRO9KNaAC9pIW+5ejqT7KL24Y7HY9gvEjCZLrDyj\/gnLSR4KIT3Ab+NRHndO9JV\\n\" +\n-        \"8848slshfe\/9M0qxo\/\/GyJu5D3xBNZf52zoFYAUVr1kXkqMQrRYc5AdTr6h2olYq\\n\" +\n-        \"ktP5KOB4z14fSKtcGd3hZ0O6dY31gqxDkkQbAgMBAAGjbjBsMAkGA1UdEwQCMAAw\\n\" +\n-        \"CwYDVR0PBAQDAgXgMB0GA1UdDgQWBBTNu8iFqpG9\/R2+zWd8\/7PpTKgi5jAfBgNV\\n\" +\n-        \"HSMEGDAWgBT6uVG\/TOfZhpgz+efLHvEzSfeoFDASBgNVHREBAf8ECDAGhwR\/AAAB\\n\" +\n-        \"MA0GCSqGSIb3DQEBBAUAA4GBACjj9PS+W6XOF7toFMwMOv\/AemZeBOpcEF1Ei1Hx\\n\" +\n-        \"HjvB6EOHkMY8tFm5OPzkiWiK3+s3awpSW0jWdzMYwrQJ3\/klMsPDpI7PEuirqwHP\\n\" +\n-        \"i5Wyl\/vk7jmfWVcBO9MVhPUo4BYl4vS9aj6JA5QbkbkB95LOgT\/BowY0WmHeVsXC\\n\" +\n-        \"I9aw\\n\" +\n-        \"-----END CERTIFICATE-----\";\n-\n-\n-    static byte serverPrivateExponent[] = {\n-        (byte)0x6e, (byte)0xa7, (byte)0x1b, (byte)0x83,\n-        (byte)0x51, (byte)0x35, (byte)0x9a, (byte)0x44,\n-        (byte)0x7d, (byte)0xf6, (byte)0xe3, (byte)0x89,\n-        (byte)0xa0, (byte)0xd7, (byte)0x90, (byte)0x60,\n-        (byte)0xa1, (byte)0x4e, (byte)0x27, (byte)0x21,\n-        (byte)0xa2, (byte)0x89, (byte)0x74, (byte)0xcc,\n-        (byte)0x9d, (byte)0x75, (byte)0x75, (byte)0x4e,\n-        (byte)0xc7, (byte)0x82, (byte)0xe3, (byte)0xe3,\n-        (byte)0xc3, (byte)0x7d, (byte)0x00, (byte)0x54,\n-        (byte)0xec, (byte)0x36, (byte)0xb1, (byte)0xdf,\n-        (byte)0x91, (byte)0x9c, (byte)0x7a, (byte)0xc0,\n-        (byte)0x62, (byte)0x0a, (byte)0xd6, (byte)0xa9,\n-        (byte)0x22, (byte)0x91, (byte)0x4a, (byte)0x29,\n-        (byte)0x2e, (byte)0x43, (byte)0xfa, (byte)0x8c,\n-        (byte)0xd8, (byte)0xe9, (byte)0xbe, (byte)0xd9,\n-        (byte)0x4f, (byte)0xca, (byte)0x23, (byte)0xc6,\n-        (byte)0xe4, (byte)0x3f, (byte)0xb8, (byte)0x72,\n-        (byte)0xcf, (byte)0x02, (byte)0xfc, (byte)0xf4,\n-        (byte)0x58, (byte)0x34, (byte)0x77, (byte)0x76,\n-        (byte)0xce, (byte)0x22, (byte)0x44, (byte)0x5f,\n-        (byte)0x2d, (byte)0xca, (byte)0xee, (byte)0xf5,\n-        (byte)0x43, (byte)0x56, (byte)0x47, (byte)0x71,\n-        (byte)0x0b, (byte)0x09, (byte)0x6b, (byte)0x5e,\n-        (byte)0xf2, (byte)0xc8, (byte)0xee, (byte)0xd4,\n-        (byte)0x6e, (byte)0x44, (byte)0x92, (byte)0x2a,\n-        (byte)0x7f, (byte)0xcc, (byte)0xa7, (byte)0xd4,\n-        (byte)0x5b, (byte)0xfb, (byte)0xf7, (byte)0x4a,\n-        (byte)0xa9, (byte)0xfb, (byte)0x54, (byte)0x18,\n-        (byte)0xd5, (byte)0xd5, (byte)0x14, (byte)0xba,\n-        (byte)0xa0, (byte)0x1c, (byte)0x13, (byte)0xb3,\n-        (byte)0x37, (byte)0x6b, (byte)0x37, (byte)0x59,\n-        (byte)0xed, (byte)0xdb, (byte)0x6d, (byte)0xb1\n-    };\n-\n-    static byte serverModulus[] = {\n-        (byte)0x00,\n-        (byte)0xa5, (byte)0xac, (byte)0x5b, (byte)0x1c,\n-        (byte)0x37, (byte)0xa2, (byte)0xdd, (byte)0x99,\n-        (byte)0x89, (byte)0x2d, (byte)0xb2, (byte)0x79,\n-        (byte)0xb8, (byte)0x8f, (byte)0xd5, (byte)0x48,\n-        (byte)0xa5, (byte)0xe7, (byte)0x1c, (byte)0x84,\n-        (byte)0x17, (byte)0x8d, (byte)0x69, (byte)0x9c,\n-        (byte)0xc6, (byte)0xac, (byte)0x6d, (byte)0xf9,\n-        (byte)0xf2, (byte)0x1d, (byte)0x1f, (byte)0x39,\n-        (byte)0x19, (byte)0xda, (byte)0xd3, (byte)0x72,\n-        (byte)0x1e, (byte)0x6e, (byte)0xec, (byte)0x44,\n-        (byte)0xcc, (byte)0x70, (byte)0xa4, (byte)0xdc,\n-        (byte)0xba, (byte)0x00, (byte)0x30, (byte)0xf6,\n-        (byte)0xa0, (byte)0x4f, (byte)0x3d, (byte)0x54,\n-        (byte)0x7a, (byte)0x61, (byte)0x6a, (byte)0xcc,\n-        (byte)0x57, (byte)0xd0, (byte)0x0a, (byte)0x7f,\n-        (byte)0x95, (byte)0x28, (byte)0x18, (byte)0x3f,\n-        (byte)0x9a, (byte)0xd9, (byte)0x94, (byte)0xf2,\n-        (byte)0x1b, (byte)0xc8, (byte)0x24, (byte)0x88,\n-        (byte)0x7e, (byte)0xfe, (byte)0x9d, (byte)0x0f,\n-        (byte)0x3d, (byte)0xfb, (byte)0x57, (byte)0x53,\n-        (byte)0x08, (byte)0xb3, (byte)0x20, (byte)0x33,\n-        (byte)0xd4, (byte)0x3f, (byte)0x17, (byte)0x47,\n-        (byte)0x14, (byte)0xd1, (byte)0xcd, (byte)0xea,\n-        (byte)0x08, (byte)0xd8, (byte)0x0e, (byte)0x75,\n-        (byte)0x4e, (byte)0xaf, (byte)0xbe, (byte)0xcc,\n-        (byte)0xd2, (byte)0xec, (byte)0xaf, (byte)0xa9,\n-        (byte)0x7a, (byte)0x49, (byte)0xdf, (byte)0xc2,\n-        (byte)0xd9, (byte)0xac, (byte)0xb8, (byte)0x24,\n-        (byte)0x40, (byte)0x90, (byte)0xa6, (byte)0x03,\n-        (byte)0x56, (byte)0x2a, (byte)0xd0, (byte)0x30,\n-        (byte)0x05, (byte)0x40, (byte)0x2c, (byte)0x4f,\n-        (byte)0xab, (byte)0xd9, (byte)0x74, (byte)0x89\n-    };\n-\n-    static byte clientPrivateExponent[] = {\n-        (byte)0x11, (byte)0xb7, (byte)0x6a, (byte)0x36,\n-        (byte)0x3d, (byte)0x30, (byte)0x37, (byte)0xce,\n-        (byte)0x61, (byte)0x9d, (byte)0x6c, (byte)0x84,\n-        (byte)0x8b, (byte)0xf3, (byte)0x9b, (byte)0x25,\n-        (byte)0x4f, (byte)0x14, (byte)0xc8, (byte)0xa4,\n-        (byte)0xdd, (byte)0x2f, (byte)0xd7, (byte)0x9a,\n-        (byte)0x17, (byte)0xbd, (byte)0x90, (byte)0x19,\n-        (byte)0xf7, (byte)0x05, (byte)0xfd, (byte)0xf2,\n-        (byte)0xd2, (byte)0xc5, (byte)0xf7, (byte)0x77,\n-        (byte)0xbe, (byte)0xea, (byte)0xe2, (byte)0x84,\n-        (byte)0x87, (byte)0x97, (byte)0x3a, (byte)0x41,\n-        (byte)0x96, (byte)0xb6, (byte)0x99, (byte)0xf8,\n-        (byte)0x94, (byte)0x8c, (byte)0x58, (byte)0x71,\n-        (byte)0x51, (byte)0x8c, (byte)0xf4, (byte)0x2a,\n-        (byte)0x20, (byte)0x9e, (byte)0x1a, (byte)0xa0,\n-        (byte)0x26, (byte)0x99, (byte)0x75, (byte)0xd6,\n-        (byte)0x31, (byte)0x53, (byte)0x43, (byte)0x39,\n-        (byte)0xf5, (byte)0x2a, (byte)0xa6, (byte)0x7e,\n-        (byte)0x34, (byte)0x42, (byte)0x51, (byte)0x2a,\n-        (byte)0x40, (byte)0x87, (byte)0x03, (byte)0x88,\n-        (byte)0x43, (byte)0x69, (byte)0xb2, (byte)0x89,\n-        (byte)0x6d, (byte)0x20, (byte)0xbd, (byte)0x7d,\n-        (byte)0x71, (byte)0xef, (byte)0x47, (byte)0x0a,\n-        (byte)0xdf, (byte)0x06, (byte)0xc1, (byte)0x69,\n-        (byte)0x66, (byte)0xa8, (byte)0x22, (byte)0x37,\n-        (byte)0x1a, (byte)0x77, (byte)0x1e, (byte)0xc7,\n-        (byte)0x94, (byte)0x4e, (byte)0x2c, (byte)0x27,\n-        (byte)0x69, (byte)0x45, (byte)0x5e, (byte)0xc8,\n-        (byte)0xf8, (byte)0x0c, (byte)0xb7, (byte)0xf8,\n-        (byte)0xc0, (byte)0x8f, (byte)0x99, (byte)0xc1,\n-        (byte)0xe5, (byte)0x28, (byte)0x9b, (byte)0xf9,\n-        (byte)0x4c, (byte)0x94, (byte)0xc6, (byte)0xb1\n-    };\n-\n-    static byte clientModulus[] = {\n-        (byte)0x00,\n-        (byte)0xbb, (byte)0xf0, (byte)0x40, (byte)0x36,\n-        (byte)0xac, (byte)0x26, (byte)0x54, (byte)0x4e,\n-        (byte)0xf4, (byte)0xa3, (byte)0x5a, (byte)0x00,\n-        (byte)0x2f, (byte)0x69, (byte)0x21, (byte)0x6f,\n-        (byte)0xb9, (byte)0x7a, (byte)0x3a, (byte)0x93,\n-        (byte)0xec, (byte)0xa2, (byte)0xf6, (byte)0xe1,\n-        (byte)0x8e, (byte)0xc7, (byte)0x63, (byte)0xd8,\n-        (byte)0x2f, (byte)0x12, (byte)0x30, (byte)0x99,\n-        (byte)0x2e, (byte)0xb0, (byte)0xf2, (byte)0x8f,\n-        (byte)0xf8, (byte)0x27, (byte)0x2d, (byte)0x24,\n-        (byte)0x78, (byte)0x28, (byte)0x84, (byte)0xf7,\n-        (byte)0x01, (byte)0xbf, (byte)0x8d, (byte)0x44,\n-        (byte)0x79, (byte)0xdd, (byte)0x3b, (byte)0xd2,\n-        (byte)0x55, (byte)0xf3, (byte)0xce, (byte)0x3c,\n-        (byte)0xb2, (byte)0x5b, (byte)0x21, (byte)0x7d,\n-        (byte)0xef, (byte)0xfd, (byte)0x33, (byte)0x4a,\n-        (byte)0xb1, (byte)0xa3, (byte)0xff, (byte)0xc6,\n-        (byte)0xc8, (byte)0x9b, (byte)0xb9, (byte)0x0f,\n-        (byte)0x7c, (byte)0x41, (byte)0x35, (byte)0x97,\n-        (byte)0xf9, (byte)0xdb, (byte)0x3a, (byte)0x05,\n-        (byte)0x60, (byte)0x05, (byte)0x15, (byte)0xaf,\n-        (byte)0x59, (byte)0x17, (byte)0x92, (byte)0xa3,\n-        (byte)0x10, (byte)0xad, (byte)0x16, (byte)0x1c,\n-        (byte)0xe4, (byte)0x07, (byte)0x53, (byte)0xaf,\n-        (byte)0xa8, (byte)0x76, (byte)0xa2, (byte)0x56,\n-        (byte)0x2a, (byte)0x92, (byte)0xd3, (byte)0xf9,\n-        (byte)0x28, (byte)0xe0, (byte)0x78, (byte)0xcf,\n-        (byte)0x5e, (byte)0x1f, (byte)0x48, (byte)0xab,\n-        (byte)0x5c, (byte)0x19, (byte)0xdd, (byte)0xe1,\n-        (byte)0x67, (byte)0x43, (byte)0xba, (byte)0x75,\n-        (byte)0x8d, (byte)0xf5, (byte)0x82, (byte)0xac,\n-        (byte)0x43, (byte)0x92, (byte)0x44, (byte)0x1b\n-    };\n+    static X509Certificate trustedCert;\n+\n+    static X509Certificate serverCert;\n+\n+    static X509Certificate clientCert;\n+\n+    static KeyPair serverKeys;\n+    static KeyPair clientKeys;\n@@ -642,1 +110,1 @@\n-    static boolean debug = false;\n+    static boolean debug = Boolean.getBoolean(\"test.debug\");\n@@ -653,2 +121,2 @@\n-        SSLContext context = getSSLContext(trusedCertStr, serverCertStr,\n-            serverModulus, serverPrivateExponent, passphrase);\n+        SSLContext context = getSSLContext(trustedCert, serverCert,\n+            serverKeys, passphrase);\n@@ -709,2 +177,2 @@\n-            SSLContext context = getSSLContext(trusedCertStr, clientCertStr,\n-                clientModulus, clientPrivateExponent, passphrase);\n+            SSLContext context = getSSLContext(trustedCert, clientCert,\n+                    clientKeys, passphrase);\n@@ -758,0 +226,59 @@\n+    private static X509Certificate createTrustedCert(KeyPair caKeys) throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(random.nextLong(1000000)+1);\n+        return CertificateBuilder.newCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .setOneHourValidity()\n+                .build(null, caKeys.getPrivate(), \"MD5WithRSA\");\n+    }\n+\n+    private static void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        serverKeys = kpg.generateKeyPair();\n+        clientKeys = kpg.generateKeyPair();\n+\n+        trustedCert = createTrustedCert(caKeys);\n+        if (debug) {\n+            System.out.println(\"----------- Trusted Cert -----------\");\n+            CertificateBuilder.printCertificate(trustedCert, System.out);\n+        }\n+\n+        serverCert = CertificateBuilder.newCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic(),\n+                KeyUsage.DIGITAL_SIGNATURE, KeyUsage.NONREPUDIATION, KeyUsage.KEY_ENCIPHERMENT)\n+                .addBasicConstraintsExt(false, false, -1)\n+                .addExtension(CertificateBuilder.createIPSubjectAltNameExt(true, \"127.0.0.1\"))\n+                .setOneHourValidity()\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+        if (debug) {\n+            System.out.println(\"----------- Server Cert -----------\");\n+            CertificateBuilder.printCertificate(serverCert, System.out);\n+        }\n+\n+        clientCert = CertificateBuilder.newCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic(),\n+                KeyUsage.DIGITAL_SIGNATURE, KeyUsage.NONREPUDIATION, KeyUsage.KEY_ENCIPHERMENT)\n+                .addExtension(CertificateBuilder.createIPSubjectAltNameExt(true, \"127.0.0.1\"))\n+                .addBasicConstraintsExt(false, false, -1)\n+                .setOneHourValidity()\n+                .build(trustedCert, caKeys.getPrivate(), \"MD5WithRSA\");\n+        if (debug) {\n+            System.out.println(\"----------- Client Cert -----------\");\n+            CertificateBuilder.printCertificate(clientCert, System.out);\n+        }\n+    }\n+\n@@ -765,1 +292,1 @@\n-        if (debug)\n+        if (debug) {\n@@ -767,0 +294,3 @@\n+        }\n+\n+        setupCertificates();\n@@ -858,11 +388,2 @@\n-    private static SSLContext getSSLContext(String trusedCertStr,\n-            String keyCertStr, byte[] modulus,\n-            byte[] privateExponent, char[] passphrase) throws Exception {\n-\n-        \/\/ generate certificate from cert string\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-\n-        ByteArrayInputStream is =\n-                    new ByteArrayInputStream(trusedCertStr.getBytes());\n-        Certificate trusedCert = cf.generateCertificate(is);\n-        is.close();\n+    private static SSLContext getSSLContext(X509Certificate trustedCert,\n+            X509Certificate keyCert, KeyPair key, char[] passphrase) throws Exception {\n@@ -871,1 +392,1 @@\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n@@ -875,15 +396,1 @@\n-        ks.setCertificateEntry(\"RSA Export Signer\", trusedCert);\n-\n-        if (keyCertStr != null) {\n-            \/\/ generate the private key.\n-            RSAPrivateKeySpec priKeySpec = new RSAPrivateKeySpec(\n-                                            new BigInteger(modulus),\n-                                            new BigInteger(privateExponent));\n-            KeyFactory kf = KeyFactory.getInstance(\"RSA\");\n-            RSAPrivateKey priKey =\n-                    (RSAPrivateKey)kf.generatePrivate(priKeySpec);\n-\n-            \/\/ generate certificate chain\n-            is = new ByteArrayInputStream(keyCertStr.getBytes());\n-            Certificate keyCert = cf.generateCertificate(is);\n-            is.close();\n+        ks.setCertificateEntry(\"RSA Export Signer\", trustedCert);\n@@ -891,0 +398,1 @@\n+        if (keyCert != null) {\n@@ -893,1 +401,1 @@\n-            chain[1] = trusedCert;\n+            chain[1] = trustedCert;\n@@ -896,1 +404,1 @@\n-            ks.setKeyEntry(\"Whatever\", priKey, passphrase, chain);\n+            ks.setKeyEntry(\"Whatever\", key.getPrivate(), passphrase, chain);\n@@ -905,1 +413,1 @@\n-        if (keyCertStr != null) {\n+        if (keyCert != null) {\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/IPIdentities.java","additions":112,"deletions":604,"binary":false,"changes":716,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+modules = \\\n+    java.base\/sun.security.util \\\n+    java.base\/sun.security.x509\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TEST.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,5 +47,5 @@\n- * @run main\/othervm\/timeout=150 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=0 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=2000 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=100000 TestMaxCachedBufferSize\n- * @run main\/othervm\/timeout=150 -Djdk.nio.maxCachedBufferSize=10000000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=0 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=2000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=100000 TestMaxCachedBufferSize\n+ * @run main\/othervm\/timeout=600 -Djdk.nio.maxCachedBufferSize=10000000 TestMaxCachedBufferSize\n","filename":"test\/jdk\/sun\/nio\/ch\/TestMaxCachedBufferSize.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n- * @run junit\/timeout=10 TestEncoderReplaceUTF16\n- * @run junit\/timeout=10\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n+ * @run junit\/timeout=40 TestEncoderReplaceUTF16\n+ * @run junit\/timeout=40\/othervm -XX:-CompactStrings TestEncoderReplaceUTF16\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceUTF16.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @run main EdDSATest\n+ * @run main\/timeout=480 EdDSATest\n","filename":"test\/jdk\/sun\/security\/ec\/ed\/EdDSATest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm IncludeRandom\n+ * @run main\/othervm\/timeout=480 IncludeRandom\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run main\/othervm Constructors\n+ * @run main\/othervm\/timeout=480 Constructors\n","filename":"test\/jdk\/sun\/security\/krb5\/name\/Constructors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -49,2 +51,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm ARCFOUR is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/ReinitCipher.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-import java.io.PrintStream;\n-import java.security.*;\n-import java.security.spec.*;\n-import java.util.Random;\n+import jtreg.SkippedException;\n@@ -37,2 +34,6 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -40,0 +41,1 @@\n+import java.security.spec.AlgorithmParameterSpec;\n@@ -51,3 +53,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/Test4512704.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,5 +34,14 @@\n-import java.security.*;\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-import java.math.*;\n-import java.io.*;\n+import jtreg.SkippedException;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherInputStream;\n+import javax.crypto.CipherOutputStream;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.util.Arrays;\n+import java.util.Random;\n@@ -40,1 +49,0 @@\n-import java.util.*;\n@@ -58,3 +66,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCICOWithGCM.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -47,1 +49,0 @@\n-\/\/        test(\"CCM\", p);\n@@ -56,3 +57,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCICOWithGCMAndAAD.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-import jdk.test.lib.Utils;\n+import jtreg.SkippedException;\n@@ -73,2 +73,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPoly.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @build jdk.test.lib.Convert\n@@ -34,1 +33,2 @@\n-import java.util.*;\n+import jtreg.SkippedException;\n+\n@@ -39,1 +39,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -44,1 +43,5 @@\n-import jdk.test.lib.Convert;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -129,2 +132,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyKAT.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import java.util.*;\n+import jtreg.SkippedException;\n+\n@@ -38,1 +39,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -41,1 +41,0 @@\n-import javax.crypto.AEADBadTagException;\n@@ -45,0 +44,5 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n@@ -241,2 +245,1 @@\n-            System.out.println(\"Skip; no support for \" + CIPHER_ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + CIPHER_ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyNoReuse.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -35,1 +37,0 @@\n-import java.security.Key;\n@@ -40,1 +41,0 @@\n-import javax.crypto.spec.ChaCha20ParameterSpec;\n@@ -63,2 +63,1 @@\n-            System.out.println(\"Skip; no support for \" + ALGO);\n-            return;\n+            throw new SkippedException(\"Skip; no support for \" + ALGO);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyOutputSize.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -41,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -42,0 +45,1 @@\n+import java.util.List;\n@@ -48,3 +52,3 @@\n-    private static String[] TRANSFORMATIONS = {\n-        \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n-        \"RSA\/ECB\/PKCS1Padding\"\n+    private static final String[] TRANSFORMATIONS = {\n+            \"AES\/ECB\/PKCS5Padding\", \"AES\/GCM\/NoPadding\",\n+            \"RSA\/ECB\/PKCS1Padding\"\n@@ -53,2 +57,2 @@\n-    private static byte[] BYTES16 =\n-            Arrays.copyOf(TRANSFORMATIONS[0].getBytes(), 16);\n+    private static final byte[] BYTES16 =\n+            Arrays.copyOf(\"AES\/ECB\/PKCS5Padding\".getBytes(), 16);\n@@ -100,2 +104,15 @@\n-        for (String t : TRANSFORMATIONS) {\n-            checkModes(t, p);\n+        List<String> skipped = new ArrayList<>();\n+        for (final String t : TRANSFORMATIONS) {\n+            try {\n+                checkModes(t, p);\n+            } catch (SkippedException skippedException) {\n+                \/\/ printing to System.out, so it's easier to see which test it relates to\n+                skippedException.printStackTrace(System.out);\n+                skipped.add(t);\n+            }\n+        }\n+\n+        if (!skipped.isEmpty()) {\n+            throw new SkippedException(\"Some tests skipped: \" + skipped);\n+        } else {\n+            System.out.println(\"All tests passed\");\n@@ -103,1 +120,0 @@\n-        System.out.println(\"All tests passed\");\n@@ -110,2 +126,1 @@\n-            System.out.println(\"Skip \" + t + \" due to \" + e.getMessage());\n-            return;\n+            throw new SkippedException(\"Skip \" + t + \" due to \" + e.getMessage());\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestCipherMode.java","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,7 @@\n-import java.security.*;\n+import jtreg.SkippedException;\n+\n+import java.security.AlgorithmParameters;\n+import java.security.GeneralSecurityException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Provider;\n@@ -36,3 +42,5 @@\n-import javax.crypto.*;\n-import javax.crypto.spec.*;\n-import java.math.*;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n@@ -40,1 +48,1 @@\n-import java.util.*;\n+import java.util.Arrays;\n@@ -80,3 +88,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + mode);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + mode);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestGCMKeyAndIvCheck.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jtreg.SkippedException;\n+\n@@ -314,3 +316,2 @@\n-            System.out.println(\"Skip testing \" + p.getName() +\n-                    \", no support for \" + transformation);\n-            return;\n+            throw new SkippedException(\"Skip testing \" + p.getName() +\n+                                       \", no support for \" + transformation);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jtreg.SkippedException;\n@@ -58,2 +59,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm \" + RSA_ALGOS[0] + \" is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRSACipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import jtreg.SkippedException;\n@@ -57,2 +58,1 @@\n-            System.out.println(RSA_ALGOS[0] + \" unsupported, skipping\");\n-            return;\n+            throw new SkippedException(RSA_ALGOS[0] + \" unsupported, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRSACipherWrap.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jtreg.SkippedException;\n@@ -52,2 +53,1 @@\n-            System.out.println(\"Not supported by provider, skipping\");\n-            return;\n+            throw new SkippedException(\"Algorithm RSA\/ECB\/NoPadding is not supported by provider, skipping\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestRawRSACipher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -40,0 +42,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -47,5 +51,1 @@\n-    private static class CI { \/\/ class for holding Cipher Information\n-\n-        String transformation;\n-        String keyAlgo;\n-        int dataSize;\n+    private record CI (String transformation, String keyAlgo, int dataSize){}  \/\/ record for holding Cipher Information\n@@ -53,6 +53,0 @@\n-        CI(String transformation, String keyAlgo, int dataSize) {\n-            this.transformation = transformation;\n-            this.keyAlgo = keyAlgo;\n-            this.dataSize = dataSize;\n-        }\n-    }\n@@ -60,24 +54,24 @@\n-        new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n-        new CI(\"RC4\", \"RC4\", 401),\n-        new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n-        new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n-        new CI(\"DES\/cbc\/PKCS5Padding\", \"DES\", 6401),\n-        new CI(\"DESede\/CBC\/PKCS5Padding\", \"DESede\", 402),\n-        new CI(\"AES\/CBC\/PKCS5Padding\", \"AES\", 30),\n-        new CI(\"Blowfish\/CBC\/PKCS5Padding\", \"Blowfish\", 19),\n-        new CI(\"DES\/ECB\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/ECB\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/ECB\/NoPadding\", \"AES\", 4800),\n-        new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 32),\n-        new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 6400),\n-        new CI(\"DESede\/ECB\/PKCS5Padding\", \"DESede\", 400),\n-        new CI(\"AES\/ECB\/PKCS5Padding\", \"AES\", 64),\n-\n-        new CI(\"DES\", \"DES\", 6400),\n-        new CI(\"DESede\", \"DESede\", 408),\n-        new CI(\"AES\", \"AES\", 128),\n-\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n+            new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n+            new CI(\"RC4\", \"RC4\", 401),\n+            new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n+            new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n+            new CI(\"DES\/cbc\/PKCS5Padding\", \"DES\", 6401),\n+            new CI(\"DESede\/CBC\/PKCS5Padding\", \"DESede\", 402),\n+            new CI(\"AES\/CBC\/PKCS5Padding\", \"AES\", 30),\n+            new CI(\"Blowfish\/CBC\/PKCS5Padding\", \"Blowfish\", 19),\n+            new CI(\"DES\/ECB\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/ECB\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/ECB\/NoPadding\", \"AES\", 4800),\n+            new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 32),\n+            new CI(\"DES\/ECB\/PKCS5Padding\", \"DES\", 6400),\n+            new CI(\"DESede\/ECB\/PKCS5Padding\", \"DESede\", 400),\n+            new CI(\"AES\/ECB\/PKCS5Padding\", \"AES\", 64),\n+\n+            new CI(\"DES\", \"DES\", 6400),\n+            new CI(\"DESede\", \"DESede\", 408),\n+            new CI(\"AES\", \"AES\", 128),\n+\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 3200),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 3200),\n@@ -93,1 +87,1 @@\n-        boolean status = true;\n+        List<CI> skippedList = new ArrayList<>();\n@@ -96,2 +90,1 @@\n-            for (int i = 0; i < TEST_LIST.length; i++) {\n-                CI currTest = TEST_LIST[i];\n+            for (CI currTest : TEST_LIST) {\n@@ -126,1 +119,2 @@\n-                            nsae);\n+                                       nsae);\n+                    skippedList.add(currTest);\n@@ -134,0 +128,4 @@\n+\n+        if (!skippedList.isEmpty()){\n+            throw new SkippedException(\"Some tests skipped: \" + skippedList);\n+        }\n@@ -137,2 +135,2 @@\n-            AlgorithmParameters params, int firstBlkSize,\n-            byte[] in, byte[] answer) throws Exception {\n+                             AlgorithmParameters params, int firstBlkSize,\n+                             byte[] in, byte[] answer) throws Exception {\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphers.java","additions":40,"deletions":42,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jtreg.SkippedException;\n+\n@@ -42,0 +44,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -50,4 +54,1 @@\n-    private static class CI { \/\/ class for holding Cipher Information\n-        String transformation;\n-        String keyAlgo;\n-        int dataSize;\n+    private record CI (String transformation, String keyAlgo, int dataSize){}  \/\/ record for holding Cipher Information\n@@ -55,6 +56,1 @@\n-        CI(String transformation, String keyAlgo, int dataSize) {\n-            this.transformation = transformation;\n-            this.keyAlgo = keyAlgo;\n-            this.dataSize = dataSize;\n-        }\n-    }\n+    private static final StringBuffer debugBuf = new StringBuffer();\n@@ -62,11 +58,11 @@\n-    private static final CI TEST_LIST[] = {\n-        new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n-        new CI(\"RC4\", \"RC4\", 401),\n-        new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n-        new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n-        new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n-        new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 1600),\n-        new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n-        new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n+    private static final CI[] TEST_LIST = {\n+            new CI(\"ARCFOUR\", \"ARCFOUR\", 400),\n+            new CI(\"RC4\", \"RC4\", 401),\n+            new CI(\"DES\/CBC\/NoPadding\", \"DES\", 400),\n+            new CI(\"DESede\/CBC\/NoPadding\", \"DESede\", 160),\n+            new CI(\"AES\/CBC\/NoPadding\", \"AES\", 4800),\n+            new CI(\"Blowfish\/CBC\/NoPadding\", \"Blowfish\", 24),\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 1600),\n+            new CI(\"AES\/CTR\/NoPadding\", \"AES\", 65),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 1600),\n+            new CI(\"AES\/CTS\/NoPadding\", \"AES\", 65),\n@@ -75,2 +71,0 @@\n-    private static final StringBuffer debugBuf = new StringBuffer();\n-\n@@ -79,1 +73,1 @@\n-        boolean status = true;\n+        List<CI> skippedList = new ArrayList<>();\n@@ -82,2 +76,1 @@\n-            for (int i = 0; i < TEST_LIST.length; i++) {\n-                CI currTest = TEST_LIST[i];\n+            for (CI currTest : TEST_LIST) {\n@@ -87,1 +80,1 @@\n-                        KeyGenerator.getInstance(currTest.keyAlgo, p);\n+                            KeyGenerator.getInstance(currTest.keyAlgo, p);\n@@ -91,1 +84,1 @@\n-                               System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+                            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n@@ -101,1 +94,1 @@\n-                         plainTxt, answer);\n+                            plainTxt, answer);\n@@ -106,1 +99,1 @@\n-                         answer, answer2);\n+                            answer, answer2);\n@@ -111,0 +104,1 @@\n+                    skippedList.add(currTest);\n@@ -118,0 +112,4 @@\n+\n+        if (!skippedList.isEmpty()){\n+            throw new SkippedException(\"Some tests skipped: \" + skippedList);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestSymmCiphersNoPad.java","additions":29,"deletions":31,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm\/timeout=30 TestHKDF\n+ * @run main\/othervm\/timeout=120 TestHKDF\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KDF\/TestHKDF.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main TestDefaultSize\n+ * @run main\/timeout=480 TestDefaultSize\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyPairGenerator\/TestDefaultSize.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=30 ImportKeyToP12\n+ * @run main\/othervm\/timeout=120 ImportKeyToP12\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/ImportKeyToP12.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm\/timeout=30 -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt TestLargeSecretKeys\n+ * @run main\/othervm\/timeout=120 -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt TestLargeSecretKeys\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/TestLargeSecretKeys.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main\/othervm KeytoolOpensslInteropTest true\n+ * @run main\/othervm\/timeout=480 KeytoolOpensslInteropTest true\n@@ -51,1 +51,1 @@\n- * @run main\/othervm KeytoolOpensslInteropTest false\n+ * @run main\/othervm\/timeout=480 KeytoolOpensslInteropTest false\n","filename":"test\/jdk\/sun\/security\/pkcs12\/KeytoolOpensslInteropTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main Launcher\n+ * @run main\/timeout=480 Launcher\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xcomp Launcher\n+ * @run main\/othervm\/timeout=480 -Xcomp Launcher\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -42,0 +43,1 @@\n+import jdk.test.lib.Utils;\n@@ -140,2 +142,1 @@\n-        float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-        baseSocket.setSoTimeout((int)(1000 * timeoutFactor));\n+        baseSocket.setSoTimeout((int)(1000 * Utils.TIMEOUT_FACTOR));\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketCloseHang.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,4 +65,4 @@\n- * @run main\/othervm CertChecking false SunX509\n- * @run main\/othervm CertChecking true SunX509\n- * @run main\/othervm CertChecking false PKIX\n- * @run main\/othervm CertChecking true PKIX\n+ * @run main\/othervm\/timeout=480 CertChecking false SunX509\n+ * @run main\/othervm\/timeout=480 CertChecking true SunX509\n+ * @run main\/othervm\/timeout=480 CertChecking false PKIX\n+ * @run main\/othervm\/timeout=480 CertChecking true PKIX\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/CertChecking.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/timeout=240 ConciseJarsigner\n+ * @run main\/timeout=960 ConciseJarsigner\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/ConciseJarsigner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run testng InsufficientSectionDelimiter\n+ * @run testng\/timeout=480 InsufficientSectionDelimiter\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/InsufficientSectionDelimiter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,2 @@\n- * @run main\/othervm RestrictedAlgo RESTRICT\n- * @run main\/othervm RestrictedAlgo NO_RESTRICT\n+ * @run main\/othervm\/timeout=480 RestrictedAlgo RESTRICT\n+ * @run main\/othervm\/timeout=480 RestrictedAlgo NO_RESTRICT\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RestrictedAlgo.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run testng SectionNameContinuedVsLineBreak\n+ * @run testng\/timeout=480 SectionNameContinuedVsLineBreak\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/SectionNameContinuedVsLineBreak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- * @run main\/timeout=600 TimestampCheck\n+ * @run main\/timeout=2400 TimestampCheck\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/TimestampCheck.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng\/timeout=300 GenerateAll\n+ * @run testng\/timeout=1200 GenerateAll\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/GenerateAll.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main ReadJar\n+ * @run main\/timeout=480 ReadJar\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/ReadJar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main TrustedCert\n+ * @run main\/timeout=480 TrustedCert\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakecacerts\/TrustedCert.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -XX:+UsePerfData TestJcmdSanity\n+ * @run main\/othervm\/timeout=480 -XX:+UsePerfData TestJcmdSanity\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdSanity.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main BasicLauncherTest\n+ * @run main\/timeout=480 BasicLauncherTest\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/BasicLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng Bug8139107\n+ * @run testng\/timeout=480 Bug8139107\n@@ -59,1 +59,0 @@\n-\n","filename":"test\/jdk\/sun\/util\/resources\/TimeZone\/Bug8139107.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n+ * @run main\/othervm\/timeout=480 -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n","filename":"test\/jdk\/tools\/jlink\/JLink100Modules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,9 @@\n+import tests.JImageGenerator;\n+\n+import java.io.BufferedOutputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n@@ -27,3 +36,4 @@\n-import java.util.Arrays;\n-import java.util.StringJoiner;\n-import java.util.spi.ToolProvider;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n@@ -31,1 +41,5 @@\n-import tests.JImageGenerator;\n+import static java.lang.classfile.ClassFile.ACC_MANDATED;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -39,2 +53,1 @@\n- * @library ..\/lib\n- * @enablePreview\n+ * @library ..\/lib \/test\/lib\n@@ -42,3 +55,0 @@\n- *          jdk.jlink\/jdk.tools.jlink.internal\n- *          jdk.jlink\/jdk.tools.jlink.plugin\n- *          jdk.jlink\/jdk.tools.jmod\n@@ -46,1 +56,0 @@\n- *          jdk.compiler\n@@ -48,1 +57,1 @@\n- * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n+ * @run main\/othervm -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink20000Packages\n@@ -51,11 +60,3 @@\n-    private static final ToolProvider JAVAC_TOOL = ToolProvider.findFirst(\"javac\")\n-            .orElseThrow(() -> new RuntimeException(\"javac tool not found\"));\n-\n-    static void report(String command, String[] args) {\n-        System.out.println(command + \" \" + String.join(\" \", Arrays.asList(args)));\n-    }\n-\n-    static void javac(String[] args) {\n-        report(\"javac\", args);\n-        JAVAC_TOOL.run(System.out, System.err, args);\n-    }\n+    private static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    private static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n@@ -64,1 +65,4 @@\n-        Path src = Paths.get(\"bug8321413\");\n+        String moduleName = \"bug8321413x\";\n+        Path src = Paths.get(moduleName);\n+        Files.createDirectories(src);\n+        Path jarPath = src.resolve(moduleName +\".jar\");\n@@ -66,7 +70,0 @@\n-        Path mainModulePath = src.resolve(\"bug8321413x\");\n-\n-        StringJoiner mainModuleInfoContent = new StringJoiner(\";\\n  exports \", \"module bug8321413x {\\n  exports \", \";\\n}\");\n-\n-        for (int i = 0; i < 20000; i++) {\n-            String packageName = \"p\" + i;\n-            String className = \"C\" + i;\n@@ -74,8 +71,27 @@\n-            Path packagePath = Files.createDirectories(mainModulePath.resolve(packageName));\n-\n-            StringBuilder classContent = new StringBuilder(\"package \");\n-            classContent.append(packageName).append(\";\\n\");\n-            classContent.append(\"class \").append(className).append(\" {}\\n\");\n-            Files.writeString(packagePath.resolve(className + \".java\"), classContent.toString());\n-\n-            mainModuleInfoContent.add(packageName);\n+        \/\/ Generate module with 20000 classes in unique packages\n+        try (JarOutputStream out = new JarOutputStream(new BufferedOutputStream(Files.newOutputStream(jarPath)))) {\n+            Set<String> packageNames = new HashSet<>();\n+            for (int i = 0; i < 20_000; i++) {\n+                String packageName = \"p\" + i;\n+                packageNames.add(packageName);\n+\n+                \/\/ Generate a class file for this package\n+                String className = \"C\" + i;\n+                byte[] classData = ClassFile.of().build(ClassDesc.of(packageName, className), cb -> {});\n+                out.putNextEntry(new JarEntry(packageName + \"\/\" + className +\".class\"));\n+                out.write(classData);\n+            }\n+\n+            \/\/ Write the main class\n+            out.putNextEntry(new JarEntry(\"testpackage\/JLink20000PackagesTest.class\"));\n+            out.write(generateMainClass());\n+            packageNames.add(\"testpackage\");\n+\n+            \/\/ Write the module descriptor\n+            byte[] moduleInfo = ClassFile.of().buildModule(ModuleAttribute.of(\n+                    ModuleDesc.of(moduleName), mab -> {\n+                        mab.requires(ModuleDesc.of(\"java.base\"), ACC_MANDATED, null);\n+                        packageNames.forEach(pkgName -> mab.exports(PackageDesc.of(pkgName), 0));\n+                    }));\n+            out.putNextEntry(new JarEntry(\"module-info.class\"));\n+            out.write(moduleInfo);\n@@ -84,24 +100,0 @@\n-        \/\/ create module reading the generated modules\n-        Path mainModuleInfo = mainModulePath.resolve(\"module-info.java\");\n-        Files.writeString(mainModuleInfo, mainModuleInfoContent.toString());\n-\n-        Path mainClassDir = mainModulePath.resolve(\"testpackage\");\n-        Files.createDirectories(mainClassDir);\n-\n-        Files.writeString(mainClassDir.resolve(\"JLink20000PackagesTest.java\"), \"\"\"\n-                package testpackage;\n-\n-                public class JLink20000PackagesTest {\n-                    public static void main(String[] args) throws Exception {\n-                        System.out.println(\"JLink20000PackagesTest started.\");\n-                    }\n-                }\n-                \"\"\");\n-\n-        String out = src.resolve(\"out\").toString();\n-        javac(new String[]{\n-                \"-d\", out,\n-                \"--module-source-path\", src.toString(),\n-                \"--module\", \"bug8321413x\"\n-        });\n-\n@@ -109,1 +101,0 @@\n-                .modulePath(out)\n@@ -111,1 +102,2 @@\n-                .addMods(\"bug8321413x\")\n+                .addJars(jarPath)\n+                .addMods(moduleName)\n@@ -120,0 +112,1 @@\n+                \/\/ Option is useful to verify build image\n@@ -121,1 +114,1 @@\n-                \"-m\", \"bug8321413x\/testpackage.JLink20000PackagesTest\");\n+                \"-m\", moduleName + \"\/testpackage.JLink20000PackagesTest\");\n@@ -129,0 +122,18 @@\n+\n+    \/**\n+     * Generate test class with main() does\n+     * System.out.println(\"JLink20000PackagesTest started.\");\n+     *\/\n+    private static byte[] generateMainClass() {\n+        return ClassFile.of().build(ClassDesc.of(\"testpackage\", \"JLink20000PackagesTest\"),\n+                cb -> {\n+                    cb.withMethod(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n+                            ACC_PUBLIC | ACC_STATIC, mb -> {\n+                                mb.withCode(cob -> cob.getstatic(CD_System, \"out\", CD_PrintStream)\n+                                        .ldc(\"JLink20000PackagesTest started.\")\n+                                        .invokevirtual(CD_PrintStream, \"println\", MTD_void_String)\n+                                        .return_()\n+                                );\n+                            });\n+                });\n+    }\n","filename":"test\/jdk\/tools\/jlink\/JLink20000Packages.java","additions":77,"deletions":66,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n- * @run main\/othervm -Xmx1g JLinkTest\n+ * @run main\/othervm\/timeout=480 -Xmx1g JLinkTest\n","filename":"test\/jdk\/tools\/jlink\/JLinkTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n- * @run junit\/othervm\/timeout=180 -Xmx1g IncludeLocalesPluginTest\n+ * @run junit\/othervm\/timeout=720 -Xmx1g IncludeLocalesPluginTest\n","filename":"test\/jdk\/tools\/jlink\/plugins\/IncludeLocalesPluginTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xmx1g JavaSEReproducibleTest\n+ * @run main\/othervm\/timeout=480 -Xmx1g JavaSEReproducibleTest\n","filename":"test\/jdk\/tools\/jlink\/runtimeImage\/JavaSEReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/DmgContentTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/MacFileAssociationsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m\n+ * @run main\/othervm\/timeout=1440 -Xmx512m\n@@ -66,1 +66,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m\n+ * @run main\/othervm\/timeout=2160 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/AddLauncherTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherSubstTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=1440 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppVersionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=4000 -Xmx512m jdk.jpackage.test.Main\n@@ -81,1 +81,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=4000 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/InstallDirTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2840 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/JavaOptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2880 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/MainClassTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=2160 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/share\/MultiNameTwoPhaseTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm\/timeout=720 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xmx512m jdk.jpackage.test.Main\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main InstanceMainTest\n+ * @run main\/timeout=480 InstanceMainTest\n","filename":"test\/jdk\/tools\/launcher\/InstanceMainTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -426,1 +426,1 @@\n-            return linkableRuntime ? jars : jmods + File.pathSeparator + jars;\n+            return (linkableRuntime || jmods.isEmpty()) ? jars : jmods + File.pathSeparator + jars;\n@@ -657,1 +657,1 @@\n-            return jmods + File.pathSeparator + jars;\n+            return jmods.isEmpty() ? jars : jmods + File.pathSeparator + jars;\n","filename":"test\/jdk\/tools\/lib\/tests\/JImageGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        map.put(\"vm.cds.nocoops.archive.available\", this::vmCDSNocoopsArchiveAvailable);\n@@ -444,0 +445,10 @@\n+    \/**\n+     * Check for CDS no compressed oops archive existence.\n+     *\n+     * @return true if CDS archive classes_nocoops.jsa exists in the JDK to be tested.\n+     *\/\n+    protected String vmCDSNocoopsArchiveAvailable() {\n+        Path archive = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"server\", \"classes_nocoops.jsa\");\n+        return \"\" + (\"true\".equals(vmCDS()) && Files.exists(archive));\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+jdk\/jshell\/ToolSimpleTest.java                                                  8366582    generic-all\n+jdk\/jshell\/ToolLocalSimpleTest.java                                             8366582    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @run main TestRedirectLinks\n+ * @run main\/timeout=480 TestRedirectLinks\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run testng ClassesTest\n+ * @run testng\/timeout=480 ClassesTest\n","filename":"test\/langtools\/jdk\/jshell\/ClassesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,7 @@\n+        Path classDirPath = getClassDir();\n+        Path baseDir = classDirPath.resolve(directory);\n+        Path jarPath = baseDir.resolve(jarName);\n+        jar(directory, jarPath, files);\n+    }\n+\n+    public void jar(Path directory, Path jarPath, String...files) {\n@@ -79,1 +86,0 @@\n-        Path jarPath = baseDir.resolve(jarName);\n","filename":"test\/langtools\/jdk\/jshell\/Compiler.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run testng CompletionSuggestionTest\n+ * @run testng\/timeout=480 CompletionSuggestionTest\n@@ -837,0 +837,16 @@\n+\n+    public void testCustomClassPathIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"package p1.p2;\\n\" +\n+                \"public class Test {\\n\" +\n+                \"}\",\n+                \"package p1.p3;\\n\" +\n+                \"public class Test {\\n\" +\n+                \"}\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+        addToClasspath(compiler.getPath(p1.resolve(jarName)));\n+\n+        assertCompletion(\"p1.|\", \"p2.\", \"p3.\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,3 +38,1 @@\n-    private static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-\n-    private static final int TIMEOUT = (int)(2000 * timeoutFactor);\n+    private static final int TIMEOUT = (int)(2000 * Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\")));\n","filename":"test\/langtools\/jdk\/jshell\/HangingRemoteAgent.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run testng JdiHangingLaunchExecutionControlTest\n+ * @run testng\/timeout=480 JdiHangingLaunchExecutionControlTest\n","filename":"test\/langtools\/jdk\/jshell\/JdiHangingLaunchExecutionControlTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run testng JdiHangingListenExecutionControlTest\n+ * @run testng\/timeout=480 JdiHangingListenExecutionControlTest\n","filename":"test\/langtools\/jdk\/jshell\/JdiHangingListenExecutionControlTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -569,0 +570,30 @@\n+    public void assertCompletions(boolean after, String input, String expectedCompletionsPattern) {\n+        if (!after) {\n+            try {\n+                Class<?> sourceCodeAnalysisImpl = Class.forName(\"jdk.jshell.SourceCodeAnalysisImpl\");\n+                Method waitBackgroundTaskFinished = sourceCodeAnalysisImpl.getDeclaredMethod(\"waitCurrentBackgroundTasksFinished\");\n+\n+                waitBackgroundTaskFinished.setAccessible(true);\n+                waitBackgroundTaskFinished.invoke(null);\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(ex.getMessage(), ex);\n+            }\n+\n+            setCommandInput(input + \"\\t\");\n+        } else {\n+            assertOutput(getCommandOutput().trim(), \"\", \"command output: \" + input);\n+            assertOutput(getCommandErrorOutput(), \"\", \"command error: \" + input);\n+            assertOutput(getUserOutput(), \"\", \"user output: \" + input);\n+            assertOutput(getUserErrorOutput(), \"\", \"user error: \" + input);\n+            String actualOutput = getTerminalOutput();\n+            Pattern compiledPattern =\n+                    Pattern.compile(expectedCompletionsPattern, Pattern.DOTALL);\n+            if (!compiledPattern.asMatchPredicate().test(actualOutput)) {\n+                throw new AssertionError(\"Actual output:\\n\" +\n+                                         actualOutput + \"\\n\" +\n+                                         \"does not match expected pattern: \" +\n+                                         expectedCompletionsPattern);\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ReplToolTesting.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8177650\n+ * @summary Verify JShell tool code completion\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ *          jdk.jshell\/jdk.jshell:+open\n+ *          jdk.jshell\/jdk.internal.jshell.tool\n+ *          java.desktop\n+ * @build toolbox.ToolBox toolbox.JarTask toolbox.JavacTask\n+ * @build ReplToolTesting TestingInputStream Compiler\n+ * @run testng ToolCompletionTest\n+ *\/\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.testng.annotations.Test;\n+\n+public class ToolCompletionTest extends ReplToolTesting {\n+\n+    private final Compiler compiler = new Compiler();\n+    private final Path outDir = Paths.get(\"tool_completion_test\");\n+\n+    @Test\n+    public void testClassPathOnCmdLineIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--class-path\", compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testClassPathViaEnvIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\"},\n+                (a) -> assertCommand(a, \"\/env --class-path \" + compiler.getPath(p1.resolve(jarName)).toString(), null),\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testClassPathChangeIndexing() {\n+        \/\/verify that changing the classpath has effect:\n+        Path dir1 = outDir.resolve(\"dir1\");\n+        compiler.compile(dir1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName1 = \"test1.jar\";\n+        compiler.jar(dir1, jarName1, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        Path dir2 = outDir.resolve(\"dir2\");\n+        compiler.compile(dir2,\n+                \"\"\"\n+                package p1.p5;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p6;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName2 = \"test2.jar\";\n+        compiler.jar(dir2, jarName2, \"p1\/p5\/Test.class\", \"p1\/p6\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--class-path\", compiler.getPath(dir1.resolve(jarName1)).toString()},\n+                (a) -> assertCommand(a, \"1\", null),\n+                (a) -> assertCommand(a, \"\/env --class-path \" + compiler.getPath(dir2.resolve(jarName2)).toString(), null),\n+                (a) -> assertCompletions(a, \"p1.\", \".*p5\\\\..*p6\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testModulePathOnCmdLineIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--module-path\", compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testModulePathOnCmdLineIndexing2() throws IOException {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        Path lib = outDir.resolve(\"lib\");\n+        Files.createDirectories(lib);\n+        compiler.jar(p1, lib.resolve(jarName), \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"--module-path\", lib.toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testUpgradeModulePathIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C--upgrade-module-path\", \"-C\" + compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testBootClassPathPrepend() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C-Xbootclasspath\/p:\" + compiler.getPath(p1.resolve(jarName)).toString(), \"-C--source=8\"},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ToolCompletionTest.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng\/othervm ToolLocalSimpleTest\n+ * @run testng\/othervm\/timeout=480 ToolLocalSimpleTest\n","filename":"test\/langtools\/jdk\/jshell\/ToolLocalSimpleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * @run testng ToolSimpleTest\n+ * @run testng\/timeout=480 ToolSimpleTest\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,12 +148,1 @@\n-    private static final long TIMEOUT;\n-\n-    static {\n-        long factor;\n-\n-        try {\n-            factor = (long) Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1\"));\n-        } catch (NumberFormatException ex) {\n-            factor = 1;\n-        }\n-        TIMEOUT = 60_000 * factor;\n-    }\n+    private static final long TIMEOUT = (long) (60_000 * Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\")));\n","filename":"test\/langtools\/jdk\/jshell\/UITesting.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng VariablesTest\n+ * @run testng\/timeout=480 VariablesTest\n","filename":"test\/langtools\/jdk\/jshell\/VariablesTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main MineField\n+ * @run main\/timeout=480 MineField\n","filename":"test\/langtools\/tools\/javac\/Paths\/MineField.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @run main WildcardMineField\n+ * @run main\/timeout=480 WildcardMineField\n","filename":"test\/langtools\/tools\/javac\/Paths\/WildcardMineField.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm CheckExamples\n+ * @run main\/othervm\/timeout=480 CheckExamples\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @run main\/othervm RunExamples\n+ * @run main\/othervm\/timeout=480 RunExamples\n","filename":"test\/langtools\/tools\/javac\/diags\/RunExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main CheckAttributedTree -q -r -et ERRONEOUS .\n+ * @run main\/timeout=480 CheckAttributedTree -q -r -et ERRONEOUS .\n","filename":"test\/langtools\/tools\/javac\/failover\/CheckAttributedTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run testng MultiReleaseJarTest\n+ * @run testng\/timeout=480 MultiReleaseJarTest\n","filename":"test\/langtools\/tools\/javac\/file\/MultiReleaseJar\/MultiReleaseJarTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 GenericConstructorAndDiamondTest\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7030150\/GenericConstructorAndDiamondTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @run main NegativeCyclicDependencyTest\n+ * @run main\/timeout=480 NegativeCyclicDependencyTest\n","filename":"test\/langtools\/tools\/javac\/importscope\/NegativeCyclicDependencyTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @run main LambdaParserTest\n+ * @run main\/timeout=480 LambdaParserTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/LambdaParserTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9,0 +9,2 @@\n+\n+timeout.default.seconds=480\n","filename":"test\/langtools\/tools\/javac\/lambda\/bridge\/template_tests\/TEST.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480  IntersectionTargetTypeTest\n","filename":"test\/langtools\/tools\/javac\/lambda\/intersection\/IntersectionTargetTypeTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8362237\n- * @summary Test source launcher with specific VM behaviors\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.launcher\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          java.base\/jdk.internal.module\n- * @build toolbox.JavaTask toolbox.JavacTask toolbox.TestRunner toolbox.ToolBox\n- * @run main\/othervm -XX:-StackTraceInThrowable SourceLauncherStackTraceTest\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.List;\n-\n-import toolbox.TestRunner;\n-\n-\/\/\/ SourceLauncherTest runs the source launcher in the same VM, so we must\n-\/\/\/ use another test to run specific tests with specific VM flags\n-public class SourceLauncherStackTraceTest extends TestRunner {\n-\n-    \/\/ Inheritance will shadow all parent tests\n-    SourceLauncherTest parent = new SourceLauncherTest();\n-\n-    SourceLauncherStackTraceTest() {\n-        super(System.err);\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        SourceLauncherStackTraceTest t = new SourceLauncherStackTraceTest();\n-        t.runTests(m -> new Object[] { Paths.get(m.getName()) });\n-    }\n-\n-    \/*\n-     * Tests in which main throws an exception without a stacktrace.\n-     *\/\n-    @Test\n-    public void testTargetException2(Path base) throws IOException {\n-        parent.tb.writeJavaFiles(base, \"\"\"\n-                public class TestLauncher {\n-                    public static TestLauncher test() {\n-                        throw new RuntimeException(\"No trace\");\n-                    }\n-\n-                    public static void main(String[] args) {\n-                        \/\/ This will throw a RuntimeException without\n-                        \/\/ a stack trace due to VM options\n-                        test();\n-                    }\n-                }\n-                \"\"\");\n-        Path file = base.resolve(\"TestLauncher.java\");\n-        SourceLauncherTest.Result r = parent.run(file, List.of(), List.of(\"3\"));\n-        parent.checkEmpty(\"stdout\", r.stdOut());\n-        parent.checkEmpty(\"stderr\", r.stdErr());\n-        parent.checkTrace(\"exception\", r.exception(), \"java.lang.RuntimeException: No trace\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherStackTraceTest.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+ *      8362237\n@@ -718,0 +719,23 @@\n+    \/*\n+     * Tests in which main throws a traceless exception.\n+     *\/\n+    @Test\n+    public void testTracelessTargetException(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \"\"\"\n+            class TestLauncherException extends RuntimeException {\n+                TestLauncherException() {\n+                    super(\"No trace\", null, true, false); \/\/ No writable trace\n+                }\n+\n+                public static void main(String... args) {\n+                    throw new TestLauncherException();\n+                }\n+            }\n+            \"\"\");\n+        Path file = base.resolve(\"TestLauncherException.java\");\n+        SourceLauncherTest.Result r = run(file, List.of(), List.of(\"3\"));\n+        checkEmpty(\"stdout\", r.stdOut());\n+        checkEmpty(\"stderr\", r.stdErr());\n+        checkTrace(\"exception\", r.exception(), \"TestLauncherException: No trace\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run junit CreateSymbolsReproducibleTest\n+ * @run junit\/timeout=480 CreateSymbolsReproducibleTest\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsReproducibleTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main JavacTreeScannerTest -q -r .\n+ * @run main\/timeout=480 JavacTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/JavacTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run main SourceDocTreeScannerTest -q -r .\n+ * @run main\/timeout=480 SourceDocTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceDocTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main SourceTreeScannerTest -q -r .\n+ * @run main\/timeout=480 SourceTreeScannerTest -q -r .\n","filename":"test\/langtools\/tools\/javac\/tree\/SourceTreeScannerTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/timeout=480 TestComparisons\n","filename":"test\/langtools\/tools\/javac\/types\/TestComparisons.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @run junit IteratorsTest\n+ * @run junit\/timeout=480 IteratorsTest\n","filename":"test\/langtools\/tools\/javac\/util\/IteratorsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm Warn5\n+ * @run main\/othervm\/timeout=480 Warn5\n","filename":"test\/langtools\/tools\/javac\/varargs\/warning\/Warn5.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,6 +105,0 @@\n-    \/** The timeout factor for slow systems. *\/\n-    public static final float timeoutFactor;\n-    static {\n-        String ttf = System.getProperty(\"test.timeout.factor\");\n-        timeoutFactor = (ttf == null) ? 1.0f : Float.parseFloat(ttf);\n-    }\n@@ -485,2 +479,2 @@\n-    private static final int RETRY_DELETE_MILLIS = isWindows() ? (int)(500 * timeoutFactor): 0;\n-    private static final int MAX_RETRY_DELETE_MILLIS = isWindows() ? (int)(15 * 1000 * timeoutFactor) : 0;\n+    private static final int RETRY_DELETE_MILLIS = isWindows() ? 500 : 0;\n+    private static final int MAX_RETRY_DELETE_MILLIS = isWindows() ? 60 * 1000 : 0;\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -231,3 +231,0 @@\n-    \/\/ This property is passed to child test processes\n-    public static final String TestTimeoutFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-\n@@ -436,1 +433,1 @@\n-        cmd.add(\"-Dtest.timeout.factor=\" + TestTimeoutFactor);\n+        cmd.add(\"-Dtest.timeout.factor=\" + Utils.TIMEOUT_FACTOR);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.security.cert.*;\n+import java.security.cert.Extension;\n@@ -29,4 +31,0 @@\n-import java.security.cert.X509Certificate;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.Extension;\n@@ -59,0 +57,1 @@\n+\n@@ -103,0 +102,83 @@\n+    public enum KeyUsage {\n+        DIGITAL_SIGNATURE,\n+        NONREPUDIATION,\n+        KEY_ENCIPHERMENT,\n+        DATA_ENCIPHERMENT,\n+        KEY_AGREEMENT,\n+        KEY_CERT_SIGN,\n+        CRL_SIGN,\n+        ENCIPHER_ONLY,\n+        DECIPHER_ONLY;\n+    }\n+\n+    \/**\n+     * Create a new CertificateBuilder instance. This method sets the subject name,\n+     * public key, authority key id, and serial number.\n+     *\n+     * @param subjectName entity associated with the public key\n+     * @param publicKey the entity's public key\n+     * @param caKey public key of certificate signer\n+     * @param keyUsages list of key uses\n+     * @return\n+     * @throws CertificateException\n+     * @throws IOException\n+     *\/\n+    public static CertificateBuilder newCertificateBuilder(String subjectName,\n+                           PublicKey publicKey, PublicKey caKey, KeyUsage... keyUsages)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        boolean [] keyUsage = new boolean[KeyUsage.values().length];\n+        for (KeyUsage ku : keyUsages) {\n+            keyUsage[ku.ordinal()] = true;\n+        }\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setSerialNumber(BigInteger.valueOf(random.nextLong(1000000)+1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        if (keyUsages.length != 0) {\n+            builder.addKeyUsageExt(keyUsage);\n+        }\n+        return builder;\n+    }\n+\n+    \/**\n+     * Create a Subject Alternative Name extension for the given DNS name\n+     * @param critical Sets the extension to critical or non-critical\n+     * @param dnsName DNS name to use in the extension\n+     * @throws IOException\n+     *\/\n+    public static SubjectAlternativeNameExtension createDNSSubjectAltNameExt(\n+            boolean critical, String dnsName) throws IOException {\n+        GeneralNames gns = new GeneralNames();\n+        gns.add(new GeneralName(new DNSName(dnsName)));\n+        return new SubjectAlternativeNameExtension(critical, gns);\n+    }\n+\n+    \/**\n+     * Create a Subject Alternative Name extension for the given IP address\n+     * @param critical Sets the extension to critical or non-critical\n+     * @param ipAddress IP address to use in the extension\n+     * @throws IOException\n+     *\/\n+    public static SubjectAlternativeNameExtension createIPSubjectAltNameExt(\n+            boolean critical, String ipAddress) throws IOException {\n+        GeneralNames gns = new GeneralNames();\n+        gns.add(new GeneralName(new IPAddressName(ipAddress)));\n+        return new SubjectAlternativeNameExtension(critical, gns);\n+    }\n+\n+    public static void printCertificate(X509Certificate certificate, PrintStream ps) {\n+        try {\n+            Base64.Encoder encoder = Base64.getEncoder();\n+            ps.println(\"-----BEGIN CERTIFICATE-----\");\n+            ps.println(encoder.encodeToString(certificate.getEncoded()));\n+            ps.println(\"-----END CERTIFICATE-----\");\n+        } catch (CertificateEncodingException exc) {\n+            exc.printStackTrace(ps);\n+        }\n+    }\n+\n@@ -180,0 +262,5 @@\n+    public CertificateBuilder setOneHourValidity() {\n+        return setNotBefore(Date.from(Instant.now().minus(5, ChronoUnit.MINUTES)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)));\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertificateBuilder.java","additions":91,"deletions":4,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.lib.Utils;\n@@ -35,4 +36,0 @@\n-    \/\/ The jtreg testing timeout factor.\n-    private static final double TIMEOUT_FACTOR = Double.valueOf(\n-            System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-\n@@ -60,1 +57,1 @@\n-        return waitFor(booleanSupplier, Math.round(1000L * TIMEOUT_FACTOR));\n+        return waitFor(booleanSupplier, Math.round(1000L * Utils.TIMEOUT_FACTOR));\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n@@ -265,0 +266,14 @@\n+    @Benchmark\n+    public void convertD2LBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToLongBits(doubles[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertD2LBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = Double.doubleToRawLongBits(doubles[i]);\n+        }\n+    }\n+\n@@ -272,0 +287,14 @@\n+    @Benchmark\n+    public void convertF2IBits() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = Float.floatToIntBits(floats[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convertF2IBitsRaw() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) Float.floatToRawIntBits(floats[i]);\n+        }\n+    }\n+\n@@ -307,0 +336,7 @@\n+    @Benchmark\n+    public void convertIBits2F() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = Float.intBitsToFloat(ints[i]);\n+        }\n+    }\n+\n@@ -328,0 +364,7 @@\n+    @Benchmark\n+    public void convertLBits2D() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = Double.longBitsToDouble(longs[i]);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1)\n+public abstract class VectorAliasing {\n+    @Param({\/*\"512\",  \"1024\", *\/  \"10000\"})\n+    public int SIZE;\n+\n+    public static int INVAR_ZERO = 0;\n+\n+    \/\/ For all types we have an \"a\" and \"b\" series. Each series is an alias to the same array.\n+    private byte[] aB;\n+    private byte[] bB;\n+\n+    private int[] aI;\n+    private int[] bI;\n+\n+    private long[] aL;\n+    private long[] bL;\n+\n+    private int iteration = 0;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        aB = new byte[SIZE];\n+        bB = new byte[SIZE];\n+\n+        aI = new int[SIZE];\n+        bI = new int[SIZE];\n+\n+        aL = new long[SIZE];\n+        bL = new long[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            aB[i] = (byte) r.nextInt();\n+            bB[i] = (byte) r.nextInt();\n+\n+            aI[i] = r.nextInt();\n+            bI[i] = r.nextInt();\n+\n+            aL[i] = r.nextLong();\n+            bL[i] = r.nextLong();\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_B(byte[] a, byte b[]) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_B(byte[] a, byte b[], int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_I(int[] a, int[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_I(int[] a, int[] b, int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_L(long[] a, long[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            b[i] = a[i];\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void copy_L(long[] a, long[] b, int aOffset, int bOffset, int size) {\n+        for (int i = 0; i < size; i++) {\n+            b[i + bOffset] = a[i + aOffset];\n+        }\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_B_sameIndex_noalias() {\n+        copy_B(bB, aB);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_B_sameIndex_alias() {\n+        copy_B(aB, aB);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_B_differentIndex_noalias() {\n+        copy_B(bB, aB, 0, 0, aB.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_B_differentIndex_alias() {\n+        copy_B(aB, aB, 0, 0, aB.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_B_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_B(bB, aB, 0, 0, aB.length); \/\/ noalias\n+        } else {\n+            copy_B(aB, aB, 0, 0, aB.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_B_half() {\n+        copy_B(aB, aB, 0, aB.length \/ 2, aB.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_B_partial_overlap() {\n+        copy_B(aB, aB, 0, aB.length \/ 4, aB.length \/ 4 * 3);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_I_sameIndex_noalias() {\n+        copy_I(bI, aI);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_I_sameIndex_alias() {\n+        copy_I(aI, aI);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_I_differentIndex_noalias() {\n+        copy_I(bI, aI, 0, 0, aI.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_I_differentIndex_alias() {\n+        copy_I(aI, aI, 0, 0, aI.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_I_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_I(bI, aI, 0, 0, aI.length); \/\/ noalias\n+        } else {\n+            copy_I(aI, aI, 0, 0, aI.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_I_half() {\n+        copy_I(aI, aI, 0, aI.length \/ 2, aI.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_I_partial_overlap() {\n+        copy_I(aI, aI, 0, aI.length \/ 4, aI.length \/ 4 * 3);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_L_sameIndex_noalias() {\n+        copy_L(bL, aL);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes with static analysis, since using same index -> iterations trivially independent.\n+    public void bench_copy_array_L_sameIndex_alias() {\n+        copy_L(aL, aL);\n+    }\n+\n+    @Benchmark\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    public void bench_copy_array_L_differentIndex_noalias() {\n+        copy_L(bL, aL, 0, 0, aL.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ never vectorizes, with our without runtime check\n+    public void bench_copy_array_L_differentIndex_alias() {\n+        copy_L(aL, aL, 0, 0, aL.length);\n+    }\n+\n+    @Benchmark\n+    \/\/ Requires multiversioning for vectorization.\n+    \/\/ With only the predicate, we will eventually deopt and compile without vectorization.\n+    public void bench_copy_array_L_differentIndex_mixed() {\n+        if ((iteration++) % 2 == 0) {\n+            copy_L(bL, aL, 0, 0, aL.length); \/\/ noalias\n+        } else {\n+            copy_L(aL, aL, 0, 0, aL.length); \/\/ alias\n+        }\n+    }\n+\n+    \/\/ No overlap -> expect vectoirzation.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_L_half() {\n+        copy_L(aL, aL, 0, aL.length \/ 2, aL.length \/ 2);\n+    }\n+\n+    \/\/ Overlap, but never alias -> expect vectorization.\n+    \/\/ Vectorizes if has at least one of: predicate or multiversioning\n+    @Benchmark\n+    public void bench_copy_array_L_partial_overlap() {\n+        copy_L(aL, aL, 0, aL.length \/ 4, aL.length \/ 4 * 3);\n+    }\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-UseAutoVectorizationSpeculativeAliasingChecks\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutSpeculativeAliasingChecks extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-UseAutoVectorizationPredicate\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutAutoVectorizationPredicate extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:-LoopMultiversioning\"\n+    })\n+    public static class VectorAliasingSuperWordWithoutMultiversioning extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:AutoVectorizationOverrideProfitability=0\"\n+    })\n+    public static class VectorAliasingSuperWordPretendNotProfitable extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:+UseSuperWord\"\n+    })\n+    public static class VectorAliasingSuperWord extends VectorAliasing {}\n+\n+    @Fork(value = 1, jvmArgs = {\n+        \"-XX:-UseSuperWord\"\n+    })\n+    public static class VectorAliasingNoSuperWord extends VectorAliasing {}\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorAliasing.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"}]}