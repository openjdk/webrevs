{"files":[{"patch":"@@ -752,0 +752,2 @@\n+# Default disabled within Valhalla until support added (JDK-8348568)\n+#\n@@ -754,1 +756,1 @@\n-  UTIL_ARG_ENABLE(NAME: cds-archive-coh, DEFAULT: auto, RESULT: BUILD_CDS_ARCHIVE_COH,\n+  UTIL_ARG_ENABLE(NAME: cds-archive-coh, DEFAULT: false, RESULT: BUILD_CDS_ARCHIVE_COH,\n","filename":"make\/autoconf\/jdk-options.m4","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1697,0 +1697,3 @@\n+  } else if (_entry_point == nullptr) {\n+    \/\/ See CallLeafNoFPIndirect\n+    return 1 * NativeInstruction::instruction_size;\n@@ -1805,12 +1808,1 @@\n-  \/\/ n.b. frame size includes space for return pc and rfp\n-  const int framesize = C->output()->frame_size_in_bytes();\n-\n-  if (C->clinit_barrier_on_entry()) {\n-    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n-\n-    Label L_skip_barrier;\n-    __ mov_metadata(rscratch2, C->method()->holder()->constant_encoding());\n-    __ clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n-    __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-    __ bind(L_skip_barrier);\n-  }\n+  __ verified_entry(C, 0);\n@@ -1819,2 +1811,2 @@\n-  if (C->max_vector_size() > 0) {\n-    __ reinitialize_ptrue();\n+  if (C->stub_function() == nullptr) {\n+    __ entry_barrier();\n@@ -1823,25 +1815,2 @@\n-  int bangsize = C->output()->bang_size_in_bytes();\n-  if (C->output()->need_stack_bang(bangsize))\n-    __ generate_stack_overflow_check(bangsize);\n-\n-  __ build_frame(framesize);\n-\n-  if (C->stub_function() == nullptr) {\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    \/\/ Dummy labels for just measuring the code size\n-    Label dummy_slow_path;\n-    Label dummy_continuation;\n-    Label dummy_guard;\n-    Label* slow_path = &dummy_slow_path;\n-    Label* continuation = &dummy_continuation;\n-    Label* guard = &dummy_guard;\n-    if (!Compile::current()->output()->in_scratch_emit_size()) {\n-      \/\/ Use real labels from actual stub when not emitting code for the purpose of measuring its size\n-      C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-      Compile::current()->output()->add_stub(stub);\n-      slow_path = &stub->entry();\n-      continuation = &stub->continuation();\n-      guard = &stub->guard();\n-    }\n-    \/\/ In the C2 code, we move the non-hot part of nmethod entry barriers out-of-line to a stub.\n-    bs->nmethod_entry_barrier(masm, slow_path, continuation, guard);\n+  if (!Compile::current()->output()->in_scratch_emit_size()) {\n+    __ bind(*_verified_entry);\n@@ -1864,6 +1833,0 @@\n-uint MachPrologNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_); \/\/ too many variables; just compute it\n-                              \/\/ the hard way\n-}\n-\n@@ -1912,1 +1875,1 @@\n-  __ remove_frame(framesize);\n+  __ remove_frame(framesize, C->needs_stack_repair());\n@@ -1931,5 +1894,0 @@\n-uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {\n-  \/\/ Variable size. Determine dynamically.\n-  return MachNode::size(ra_);\n-}\n-\n@@ -2231,1 +2189,12 @@\n-\/\/=============================================================================\n+\/\/\/=============================================================================\n+#ifndef PRODUCT\n+void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const\n+{\n+  st->print_cr(\"# MachVEPNode\");\n+  if (!_verified) {\n+    st->print_cr(\"\\t load_class\");\n+  } else {\n+    st->print_cr(\"\\t unpack_inline_arg\");\n+  }\n+}\n+#endif\n@@ -2233,0 +2202,27 @@\n+void MachVEPNode::emit(C2_MacroAssembler *masm, PhaseRegAlloc* ra_) const\n+{\n+  if (!_verified) {\n+    __ ic_check(1);\n+  } else {\n+    \/\/ TODO 8284443 Avoid creation of temporary frame\n+    if (ra_->C->stub_function() == nullptr) {\n+      __ verified_entry(ra_->C, 0);\n+      __ entry_barrier();\n+      int framesize = ra_->C->output()->frame_slots() << LogBytesPerInt;\n+      __ remove_frame(framesize, false);\n+    }\n+    \/\/ Unpack inline type args passed as oop and then jump to\n+    \/\/ the verified entry point (skipping the unverified entry).\n+    int sp_inc = __ unpack_inline_args(ra_->C, _receiver_only);\n+    \/\/ Emit code for verified entry and save increment for stack repair on return\n+    __ verified_entry(ra_->C, sp_inc);\n+    if (Compile::current()->output()->in_scratch_emit_size()) {\n+      Label dummy_verified_entry;\n+      __ b(dummy_verified_entry);\n+    } else {\n+      __ b(*_verified_entry);\n+    }\n+  }\n+}\n+\n+\/\/=============================================================================\n@@ -2255,5 +2251,0 @@\n-uint MachUEPNode::size(PhaseRegAlloc* ra_) const\n-{\n-  return MachNode::size(ra_);\n-}\n-\n@@ -3765,0 +3756,31 @@\n+    if (tf()->returns_inline_type_as_fields() && !_method->is_method_handle_intrinsic() && _method->return_type()->is_loaded()) {\n+      \/\/ The last return value is not set by the callee but used to pass the null marker to compiled code.\n+      \/\/ Search for the corresponding projection, get the register and emit code that initialized it.\n+      uint con = (tf()->range_cc()->cnt() - 1);\n+      for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+        ProjNode* proj = fast_out(i)->as_Proj();\n+        if (proj->_con == con) {\n+          \/\/ Set null marker if r0 is non-null (a non-null value is returned buffered or scalarized)\n+          OptoReg::Name optoReg = ra_->get_reg_first(proj);\n+          VMReg reg = OptoReg::as_VMReg(optoReg, ra_->_framesize, OptoReg::reg2stack(ra_->_matcher._new_SP));\n+          Register toReg = reg->is_reg() ? reg->as_Register() : rscratch1;\n+          __ cmp(r0, zr);\n+          __ cset(toReg, Assembler::NE);\n+          if (reg->is_stack()) {\n+            int st_off = reg->reg2stack() * VMRegImpl::stack_slot_size;\n+            __ str(toReg, Address(sp, st_off));\n+          }\n+          break;\n+        }\n+      }\n+      if (return_value_is_used()) {\n+        \/\/ An inline type is returned as fields in multiple registers.\n+        \/\/ R0 either contains an oop if the inline type is buffered or a pointer\n+        \/\/ to the corresponding InlineKlass with the lowest bit set to 1. Zero r0\n+        \/\/ if the lowest bit is set to allow C2 to use the oop after null checking.\n+        \/\/ r0 &= (r0 & 1) - 1\n+        __ andr(rscratch1, r0, 0x1);\n+        __ sub(rscratch1, rscratch1, 0x1);\n+        __ andr(r0, r0, rscratch1);\n+      }\n+    }\n@@ -6949,1 +6971,1 @@\n-    \"mov  $dst, $con\\t# ptr\\n\\t\"\n+    \"mov  $dst, $con\\t# ptr\"\n@@ -8142,0 +8164,30 @@\n+instruct castI2N(iRegNNoSp dst, iRegI src) %{\n+  match(Set dst (CastI2N src));\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"mov $dst, $src\\t# int -> narrow ptr\" %}\n+\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ mov(as_Register($dst$$reg), as_Register($src$$reg));\n+    }\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct castN2X(iRegLNoSp dst, iRegN src) %{\n+  match(Set dst (CastP2X src));\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"mov $dst, $src\\t# ptr -> long\" %}\n+\n+  ins_encode %{\n+    if ($dst$$reg != $src$$reg) {\n+      __ mov(as_Register($dst$$reg), as_Register($src$$reg));\n+    }\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -15095,1 +15147,1 @@\n-instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, Universe dummy, rFlagsReg cr)\n+instruct clearArray_reg_reg_immL0(iRegL_R11 cnt, iRegP_R10 base, immL0 zero, Universe dummy, rFlagsReg cr)\n@@ -15097,1 +15149,1 @@\n-  match(Set dummy (ClearArray cnt base));\n+  match(Set dummy (ClearArray (Binary cnt base) zero));\n@@ -15114,0 +15166,16 @@\n+instruct clearArray_reg_reg(iRegL_R11 cnt, iRegP_R10 base, iRegL val, Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(((ClearArrayNode*)n)->word_copy_only());\n+  match(Set dummy (ClearArray (Binary cnt base) val));\n+  effect(USE_KILL cnt, USE_KILL base, KILL cr);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ClearArray $cnt, $base, $val\" %}\n+\n+  ins_encode %{\n+    __ fill_words($base$$Register, $cnt$$Register, $val$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -15117,1 +15185,2 @@\n-            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord));\n+            < (uint64_t)(BlockZeroingLowLimit >> LogBytesPerWord)\n+            && !((ClearArrayNode*)n)->word_copy_only());\n@@ -16434,0 +16503,18 @@\n+\/\/ entry point is null, target holds the address to call\n+instruct CallLeafNoFPIndirect(iRegP target)\n+%{\n+  predicate(n->as_Call()->entry_point() == nullptr);\n+\n+  match(CallLeafNoFP target);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf nofp indirect $target\" %}\n+\n+  ins_encode %{\n+    __ blr($target$$Register);\n+  %}\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n@@ -16436,0 +16523,2 @@\n+  predicate(n->as_Call()->entry_point() != nullptr);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":150,"deletions":61,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -156,2 +156,2 @@\n-      sender_unextended_sp = sender_sp;\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+      intptr_t **saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);\n+      saved_fp = *saved_fp_addr;\n@@ -162,1 +162,4 @@\n-    }\n+      \/\/ Repair the sender sp if this is a method with scalarized inline type args\n+      sender_sp = repair_sender_sp(sender_sp, saved_fp_addr);\n+      sender_unextended_sp = sender_sp;\n+    }\n@@ -670,0 +673,3 @@\n+      if (cb()->is_nmethod() && cb()->as_nmethod_or_null()->needs_stack_repair()) {\n+        values.describe(frame_no, fp_loc - 1, err_msg(\"fsize for #%d\", frame_no), 1);\n+      }\n@@ -825,0 +831,38 @@\n+\/\/ Check for a method with scalarized inline type arguments that needs\n+\/\/ a stack repair and return the repaired sender stack pointer.\n+intptr_t* frame::repair_sender_sp(intptr_t* sender_sp, intptr_t** saved_fp_addr) const {\n+  nmethod* nm = _cb->as_nmethod_or_null();\n+  if (nm != nullptr && nm->needs_stack_repair()) {\n+    \/\/ The stack increment resides just below the saved FP on the stack and\n+    \/\/ records the total frame size excluding the two words for saving FP and LR.\n+    intptr_t* sp_inc_addr = (intptr_t*) (saved_fp_addr - 1);\n+    assert(*sp_inc_addr % StackAlignmentInBytes == 0, \"sp_inc not aligned\");\n+    int real_frame_size = (*sp_inc_addr \/ wordSize) + 2;\n+    assert(real_frame_size >= _cb->frame_size() && real_frame_size <= 1000000, \"invalid frame size\");\n+    sender_sp = unextended_sp() + real_frame_size;\n+  }\n+  return sender_sp;\n+}\n+\n+intptr_t* frame::repair_sender_sp(nmethod* nm, intptr_t* sp, intptr_t** saved_fp_addr) {\n+  assert(nm != nullptr && nm->needs_stack_repair(), \"\");\n+  \/\/ The stack increment resides just below the saved FP on the stack and\n+  \/\/ records the total frame size excluding the two words for saving FP and LR.\n+  intptr_t* real_frame_size_addr = (intptr_t*) (saved_fp_addr - 1);\n+  int real_frame_size = (*real_frame_size_addr \/ wordSize) + 2;\n+  assert(real_frame_size >= nm->frame_size() && real_frame_size <= 1000000, \"invalid frame size\");\n+  return sp + real_frame_size;\n+}\n+\n+bool frame::was_augmented_on_entry(int& real_size) const {\n+  assert(is_compiled_frame(), \"\");\n+  if (_cb->as_nmethod_or_null()->needs_stack_repair()) {\n+    intptr_t* real_frame_size_addr = unextended_sp() + _cb->frame_size() - sender_sp_offset - 1;\n+    log_trace(continuations)(\"real_frame_size is addr is \" INTPTR_FORMAT, p2i(real_frame_size_addr));\n+    real_size = (*real_frame_size_addr \/ wordSize) + 2;\n+    return real_size != _cb->frame_size();\n+  }\n+  real_size = _cb->frame_size();\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":47,"deletions":3,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -51,0 +53,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -56,0 +59,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n@@ -59,0 +63,1 @@\n+#include \"vmreg_aarch64.inline.hpp\"\n@@ -2069,1 +2074,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -2102,1 +2111,5 @@\n-  if (!VerifyOops) return;\n+  if (!VerifyOops || VerifyAdapterSharing) {\n+    \/\/ Below address of the code string confuses VerifyAdapterSharing\n+    \/\/ because it may differ between otherwise equivalent adapters.\n+    return;\n+  }\n@@ -2200,0 +2213,4 @@\n+void MacroAssembler::super_call_VM_leaf(address entry_point) {\n+  MacroAssembler::call_VM_leaf_base(entry_point, 1);\n+}\n+\n@@ -2245,0 +2262,88 @@\n+void MacroAssembler::test_markword_is_inline_type(Register markword, Label& is_inline_type) {\n+  assert_different_registers(markword, rscratch2);\n+  mov(rscratch2, markWord::inline_type_mask_in_place);\n+  andr(markword, markword, rscratch2);\n+  mov(rscratch2, markWord::inline_type_pattern);\n+  cmp(markword, rscratch2);\n+  br(Assembler::EQ, is_inline_type);\n+}\n+\n+void MacroAssembler::test_oop_is_not_inline_type(Register object, Register tmp, Label& not_inline_type, bool can_be_null) {\n+  assert_different_registers(tmp, rscratch1);\n+  if (can_be_null) {\n+    cbz(object, not_inline_type);\n+  }\n+  const int is_inline_type_mask = markWord::inline_type_pattern;\n+  ldr(tmp, Address(object, oopDesc::mark_offset_in_bytes()));\n+  mov(rscratch1, is_inline_type_mask);\n+  andr(tmp, tmp, rscratch1);\n+  cmp(tmp, rscratch1);\n+  br(Assembler::NE, not_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_null_free_inline_type(Register flags, Register temp_reg, Label& is_null_free_inline_type) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ResolvedFieldEntry::is_null_free_inline_type_shift, is_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_not_null_free_inline_type(Register flags, Register temp_reg, Label& not_null_free_inline_type) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbz(flags, ResolvedFieldEntry::is_null_free_inline_type_shift, not_null_free_inline_type);\n+}\n+\n+void MacroAssembler::test_field_is_flat(Register flags, Register temp_reg, Label& is_flat) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ResolvedFieldEntry::is_flat_shift, is_flat);\n+}\n+\n+void MacroAssembler::test_field_has_null_marker(Register flags, Register temp_reg, Label& has_null_marker) {\n+  assert(temp_reg == noreg, \"not needed\"); \/\/ keep signature uniform with x86\n+  tbnz(flags, ResolvedFieldEntry::has_null_marker_shift, has_null_marker);\n+}\n+\n+void MacroAssembler::test_oop_prototype_bit(Register oop, Register temp_reg, int32_t test_bit, bool jmp_set, Label& jmp_label) {\n+  Label test_mark_word;\n+  \/\/ load mark word\n+  ldr(temp_reg, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  \/\/ check displaced\n+  tst(temp_reg, markWord::unlocked_value);\n+  br(Assembler::NE, test_mark_word);\n+  \/\/ slow path use klass prototype\n+  load_prototype_header(temp_reg, oop);\n+\n+  bind(test_mark_word);\n+  andr(temp_reg, temp_reg, test_bit);\n+  if (jmp_set) {\n+    cbnz(temp_reg, jmp_label);\n+  } else {\n+    cbz(temp_reg, jmp_label);\n+  }\n+}\n+\n+void MacroAssembler::test_flat_array_oop(Register oop, Register temp_reg, Label& is_flat_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, true, is_flat_array);\n+}\n+\n+void MacroAssembler::test_non_flat_array_oop(Register oop, Register temp_reg,\n+                                                  Label&is_non_flat_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::flat_array_bit_in_place, false, is_non_flat_array);\n+}\n+\n+void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label& is_null_free_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, true, is_null_free_array);\n+}\n+\n+void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&is_non_null_free_array) {\n+  test_oop_prototype_bit(oop, temp_reg, markWord::null_free_array_bit_in_place, false, is_non_null_free_array);\n+}\n+\n+void MacroAssembler::test_flat_array_layout(Register lh, Label& is_flat_array) {\n+  tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  br(Assembler::NE, is_flat_array);\n+}\n+\n+void MacroAssembler::test_non_flat_array_layout(Register lh, Label& is_non_flat_array) {\n+  tst(lh, Klass::_lh_array_tag_flat_value_bit_inplace);\n+  br(Assembler::EQ, is_non_flat_array);\n+}\n+\n@@ -5036,0 +5141,10 @@\n+void MacroAssembler::load_metadata(Register dst, Register src) {\n+  if (UseCompactObjectHeaders) {\n+    load_narrow_klass_compact(dst, src);\n+  } else if (UseCompressedClassPointers) {\n+    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  } else {\n+    ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n@@ -5146,0 +5261,5 @@\n+void MacroAssembler::load_prototype_header(Register dst, Register src) {\n+  load_klass(dst, src);\n+  ldr(dst, Address(dst, Klass::prototype_header_offset()));\n+}\n+\n@@ -5547,0 +5667,40 @@\n+void MacroAssembler::flat_field_copy(DecoratorSet decorators, Register src, Register dst,\n+                                     Register inline_layout_info) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->flat_field_copy(this, decorators, src, dst, inline_layout_info);\n+}\n+\n+void MacroAssembler::payload_offset(Register inline_klass, Register offset) {\n+  ldr(offset, Address(inline_klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+  ldrw(offset, Address(offset, InlineKlass::payload_offset_offset()));\n+}\n+\n+void MacroAssembler::payload_address(Register oop, Register data, Register inline_klass) {\n+  \/\/ ((address) (void*) o) + vk->payload_offset();\n+  Register offset = (data == oop) ? rscratch1 : data;\n+  payload_offset(inline_klass, offset);\n+  if (data == oop) {\n+    add(data, data, offset);\n+  } else {\n+    lea(data, Address(oop, offset));\n+  }\n+}\n+\n+void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,\n+                                                Register index, Register data) {\n+  assert_different_registers(array, array_klass, index);\n+  assert_different_registers(rscratch1, array, index);\n+\n+  \/\/ array->base() + (index << Klass::layout_helper_log2_element_size(lh));\n+  ldrw(rscratch1, Address(array_klass, Klass::layout_helper_offset()));\n+\n+  \/\/ Klass::layout_helper_log2_element_size(lh)\n+  \/\/ (lh >> _lh_log2_element_size_shift) & _lh_log2_element_size_mask;\n+  lsr(rscratch1, rscratch1, Klass::_lh_log2_element_size_shift);\n+  andr(rscratch1, rscratch1, Klass::_lh_log2_element_size_mask);\n+  lslv(index, index, rscratch1);\n+\n+  add(data, array, index);\n+  add(data, data, arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT));\n+}\n+\n@@ -5622,0 +5782,102 @@\n+\/\/ Object \/ value buffer allocation...\n+void MacroAssembler::allocate_instance(Register klass, Register new_obj,\n+                                       Register t1, Register t2,\n+                                       bool clear_fields, Label& alloc_failed)\n+{\n+  Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;\n+  Register layout_size = t1;\n+  assert(new_obj == r0, \"needs to be r0\");\n+  assert_different_registers(klass, new_obj, t1, t2);\n+\n+  \/\/ get instance_size in InstanceKlass (scaled to a count of bytes)\n+  ldrw(layout_size, Address(klass, Klass::layout_helper_offset()));\n+  \/\/ test to see if it is malformed in some way\n+  tst(layout_size, Klass::_lh_instance_slow_path_bit);\n+  br(Assembler::NE, slow_case_no_pop);\n+\n+  \/\/ Allocate the instance:\n+  \/\/  If TLAB is enabled:\n+  \/\/    Try to allocate in the TLAB.\n+  \/\/    If fails, go to the slow path.\n+  \/\/    Initialize the allocation.\n+  \/\/    Exit.\n+  \/\/\n+  \/\/  Go to slow path.\n+\n+  if (UseTLAB) {\n+    push(klass);\n+    tlab_allocate(new_obj, layout_size, 0, klass, t2, slow_case);\n+    if (ZeroTLAB || (!clear_fields)) {\n+      \/\/ the fields have been already cleared\n+      b(initialize_header);\n+    } else {\n+      \/\/ initialize both the header and fields\n+      b(initialize_object);\n+    }\n+\n+    if (clear_fields) {\n+      \/\/ The object is initialized before the header.  If the object size is\n+      \/\/ zero, go directly to the header initialization.\n+      bind(initialize_object);\n+      int header_size = oopDesc::header_size() * HeapWordSize;\n+      assert(is_aligned(header_size, BytesPerLong), \"oop header size must be 8-byte-aligned\");\n+      subs(layout_size, layout_size, header_size);\n+      br(Assembler::EQ, initialize_header);\n+\n+      \/\/ Initialize topmost object field, divide size by 8, check if odd and\n+      \/\/ test if zero.\n+\n+  #ifdef ASSERT\n+      \/\/ make sure instance_size was multiple of 8\n+      Label L;\n+      tst(layout_size, 7);\n+      br(Assembler::EQ, L);\n+      stop(\"object size is not multiple of 8 - adjust this code\");\n+      bind(L);\n+      \/\/ must be > 0, no extra check needed here\n+  #endif\n+\n+      lsr(layout_size, layout_size, LogBytesPerLong);\n+\n+      \/\/ initialize remaining object fields: instance_size was a multiple of 8\n+      {\n+        Label loop;\n+        Register base = t2;\n+\n+        bind(loop);\n+        add(rscratch1, new_obj, layout_size, Assembler::LSL, LogBytesPerLong);\n+        str(zr, Address(rscratch1, header_size - 1*oopSize));\n+        subs(layout_size, layout_size, 1);\n+        br(Assembler::NE, loop);\n+      }\n+    } \/\/ clear_fields\n+\n+    \/\/ initialize object header only.\n+    bind(initialize_header);\n+    pop(klass);\n+    Register mark_word = t2;\n+    if (UseCompactObjectHeaders || EnableValhalla) {\n+      ldr(mark_word, Address(klass, Klass::prototype_header_offset()));\n+      str(mark_word, Address(new_obj, oopDesc::mark_offset_in_bytes()));\n+    } else {\n+      mov(mark_word, (intptr_t)markWord::prototype().value());\n+      str(mark_word, Address(new_obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+    if (!UseCompactObjectHeaders) {\n+      store_klass_gap(new_obj, zr);  \/\/ zero klass gap for compressed oops\n+      mov(t2, klass);                \/\/ preserve klass\n+      store_klass(new_obj, t2);      \/\/ src klass reg is potentially compressed\n+    }\n+    b(done);\n+  }\n+\n+  if (UseTLAB) {\n+    bind(slow_case);\n+    pop(klass);\n+  }\n+  bind(slow_case_no_pop);\n+  b(alloc_failed);\n+\n+  bind(done);\n+}\n+\n@@ -5693,0 +5955,20 @@\n+void MacroAssembler::get_inline_type_field_klass(Register holder_klass, Register index, Register inline_klass) {\n+  inline_layout_info(holder_klass, index, inline_klass);\n+  ldr(inline_klass, Address(inline_klass, InlineLayoutInfo::klass_offset()));\n+}\n+\n+void MacroAssembler::inline_layout_info(Register holder_klass, Register index, Register layout_info) {\n+  assert_different_registers(holder_klass, index, layout_info);\n+  InlineLayoutInfo array[2];\n+  int size = (char*)&array[1] - (char*)&array[0]; \/\/ computing size of array elements\n+  if (is_power_of_2(size)) {\n+    lsl(index, index, log2i_exact(size)); \/\/ Scale index by power of 2\n+  } else {\n+    mov(layout_info, size);\n+    mul(index, index, layout_info); \/\/ Scale the index to be the entry index * array_element_size\n+  }\n+  ldr(layout_info, Address(holder_klass, InstanceKlass::inline_layout_info_array_offset()));\n+  add(layout_info, layout_info, Array<InlineLayoutInfo>::base_offset_in_bytes());\n+  lea(layout_info, Address(layout_info, index));\n+}\n+\n@@ -5818,0 +6100,62 @@\n+void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair) {\n+  if (needs_stack_repair) {\n+    \/\/ Remove the extension of the caller's frame used for inline type unpacking\n+    \/\/\n+    \/\/ Right now the stack looks like this:\n+    \/\/\n+    \/\/ | Arguments from caller     |\n+    \/\/ |---------------------------|  <-- caller's SP\n+    \/\/ | Saved LR #1               |\n+    \/\/ | Saved FP #1               |\n+    \/\/ |---------------------------|\n+    \/\/ | Extension space for       |\n+    \/\/ |   inline arg (un)packing  |\n+    \/\/ |---------------------------|  <-- start of this method's frame\n+    \/\/ | Saved LR #2               |\n+    \/\/ | Saved FP #2               |\n+    \/\/ |---------------------------|  <-- FP\n+    \/\/ | sp_inc                    |\n+    \/\/ | method locals             |\n+    \/\/ |---------------------------|  <-- SP\n+    \/\/\n+    \/\/ There are two copies of FP and LR on the stack. They will be identical at\n+    \/\/ first, but that can change.\n+    \/\/ If the caller has been deoptimized, LR #1 will be patched to point at the\n+    \/\/ deopt blob, and LR #2 will still point into the old method.\n+    \/\/ If the saved FP (x29) was not used as the frame pointer, but to store an\n+    \/\/ oop, the GC will be aware only of FP #2 as the spilled location of x29 and\n+    \/\/ will fix only this one.\n+    \/\/\n+    \/\/ When restoring, one must then load FP #2 into x29, and LR #1 into x30,\n+    \/\/ while keeping in mind that from the scalarized entry point, there will be\n+    \/\/ only one copy of each.\n+    \/\/\n+    \/\/ The sp_inc stack slot holds the total size of the frame including the\n+    \/\/ extension space minus two words for the saved FP and LR. That is how to\n+    \/\/ find LR #1. FP #2 is always located just after sp_inc.\n+\n+    int sp_inc_offset = initial_framesize - 3 * wordSize;  \/\/ Immediately below saved LR and FP\n+\n+    ldr(rscratch1, Address(sp, sp_inc_offset));\n+    ldr(rfp, Address(sp, sp_inc_offset + wordSize));\n+    add(sp, sp, rscratch1);\n+    ldr(lr, Address(sp, wordSize));\n+    add(sp, sp, 2 * wordSize);\n+  } else {\n+    remove_frame(initial_framesize);\n+  }\n+}\n+\n+void MacroAssembler::save_stack_increment(int sp_inc, int frame_size) {\n+  int real_frame_size = frame_size + sp_inc;\n+  assert(sp_inc == 0 || sp_inc > 2*wordSize, \"invalid sp_inc value\");\n+  assert(real_frame_size >= 2*wordSize, \"frame size must include FP\/LR space\");\n+  assert((real_frame_size & (StackAlignmentInBytes-1)) == 0, \"frame size not aligned\");\n+\n+  int sp_inc_offset = frame_size - 3 * wordSize;  \/\/ Immediately below saved LR and FP\n+\n+  \/\/ Subtract two words for the saved FP and LR as these will be popped\n+  \/\/ separately. See remove_frame above.\n+  mov(rscratch1, real_frame_size - 2*wordSize);\n+  str(rscratch1, Address(sp, sp_inc_offset));\n+}\n@@ -6735,0 +7079,448 @@\n+#ifdef COMPILER2\n+\/\/ C2 compiled method's prolog code\n+\/\/ Moved here from aarch64.ad to support Valhalla code belows\n+void MacroAssembler::verified_entry(Compile* C, int sp_inc) {\n+  if (C->clinit_barrier_on_entry()) {\n+    assert(!C->method()->holder()->is_not_initialized(), \"initialization should have been started\");\n+\n+    Label L_skip_barrier;\n+\n+    mov_metadata(rscratch2, C->method()->holder()->constant_encoding());\n+    clinit_barrier(rscratch2, rscratch1, &L_skip_barrier);\n+    far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n+    bind(L_skip_barrier);\n+  }\n+\n+  if (C->max_vector_size() > 0) {\n+    reinitialize_ptrue();\n+  }\n+\n+  int bangsize = C->output()->bang_size_in_bytes();\n+  if (C->output()->need_stack_bang(bangsize))\n+    generate_stack_overflow_check(bangsize);\n+\n+  \/\/ n.b. frame size includes space for return pc and rfp\n+  const long framesize = C->output()->frame_size_in_bytes();\n+  build_frame(framesize);\n+\n+  if (C->needs_stack_repair()) {\n+    save_stack_increment(sp_inc, framesize);\n+  }\n+\n+  if (VerifyStackAtCalls) {\n+    Unimplemented();\n+  }\n+}\n+#endif \/\/ COMPILER2\n+\n+int MacroAssembler::store_inline_type_fields_to_buf(ciInlineKlass* vk, bool from_interpreter) {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  \/\/ An inline type might be returned. If fields are in registers we\n+  \/\/ need to allocate an inline type instance and initialize it with\n+  \/\/ the value of the fields.\n+  Label skip;\n+  \/\/ We only need a new buffered inline type if a new one is not returned\n+  tbz(r0, 0, skip);\n+  int call_offset = -1;\n+\n+  \/\/ Be careful not to clobber r1-7 which hold returned fields\n+  \/\/ Also do not use callee-saved registers as these may be live in the interpreter\n+  Register tmp1 = r13, tmp2 = r14, klass = r15, r0_preserved = r12;\n+\n+  \/\/ The following code is similar to allocate_instance but has some slight differences,\n+  \/\/ e.g. object size is always not zero, sometimes it's constant; storing klass ptr after\n+  \/\/ allocating is not necessary if vk != nullptr, etc. allocate_instance is not aware of these.\n+  Label slow_case;\n+  \/\/ 1. Try to allocate a new buffered inline instance either from TLAB or eden space\n+  mov(r0_preserved, r0); \/\/ save r0 for slow_case since *_allocate may corrupt it when allocation failed\n+\n+  if (vk != nullptr) {\n+    \/\/ Called from C1, where the return type is statically known.\n+    movptr(klass, (intptr_t)vk->get_InlineKlass());\n+    jint lh = vk->layout_helper();\n+    assert(lh != Klass::_lh_neutral_value, \"inline class in return type must have been resolved\");\n+    if (UseTLAB && !Klass::layout_helper_needs_slow_path(lh)) {\n+      tlab_allocate(r0, noreg, lh, tmp1, tmp2, slow_case);\n+    } else {\n+      b(slow_case);\n+    }\n+  } else {\n+    \/\/ Call from interpreter. R0 contains ((the InlineKlass* of the return type) | 0x01)\n+    andr(klass, r0, -2);\n+    if (UseTLAB) {\n+      ldrw(tmp2, Address(klass, Klass::layout_helper_offset()));\n+      tst(tmp2, Klass::_lh_instance_slow_path_bit);\n+      br(Assembler::NE, slow_case);\n+      tlab_allocate(r0, tmp2, 0, tmp1, tmp2, slow_case);\n+    } else {\n+      b(slow_case);\n+    }\n+  }\n+  if (UseTLAB) {\n+    \/\/ 2. Initialize buffered inline instance header\n+    Register buffer_obj = r0;\n+    if (UseCompactObjectHeaders) {\n+      ldr(rscratch1, Address(klass, Klass::prototype_header_offset()));\n+      str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n+    } else {\n+      mov(rscratch1, (intptr_t)markWord::inline_type_prototype().value());\n+      str(rscratch1, Address(buffer_obj, oopDesc::mark_offset_in_bytes()));\n+      store_klass_gap(buffer_obj, zr);\n+      if (vk == nullptr) {\n+        \/\/ store_klass corrupts klass, so save it for later use (interpreter case only).\n+        mov(tmp1, klass);\n+      }\n+      store_klass(buffer_obj, klass);\n+      klass = tmp1;\n+    }\n+    \/\/ 3. Initialize its fields with an inline class specific handler\n+    if (vk != nullptr) {\n+      far_call(RuntimeAddress(vk->pack_handler())); \/\/ no need for call info as this will not safepoint.\n+    } else {\n+      ldr(tmp1, Address(klass, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+      ldr(tmp1, Address(tmp1, InlineKlass::pack_handler_offset()));\n+      blr(tmp1);\n+    }\n+\n+    membar(Assembler::StoreStore);\n+    b(skip);\n+  } else {\n+    \/\/ Must have already branched to slow_case above.\n+    DEBUG_ONLY(should_not_reach_here());\n+  }\n+  bind(slow_case);\n+  \/\/ We failed to allocate a new inline type, fall back to a runtime\n+  \/\/ call. Some oop field may be live in some registers but we can't\n+  \/\/ tell. That runtime call will take care of preserving them\n+  \/\/ across a GC if there's one.\n+  mov(r0, r0_preserved);\n+\n+  if (from_interpreter) {\n+    super_call_VM_leaf(StubRoutines::store_inline_type_fields_to_buf());\n+  } else {\n+    far_call(RuntimeAddress(StubRoutines::store_inline_type_fields_to_buf()));\n+    call_offset = offset();\n+  }\n+  membar(Assembler::StoreStore);\n+\n+  bind(skip);\n+  return call_offset;\n+}\n+\n+\/\/ Move a value between registers\/stack slots and update the reg_state\n+bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[]) {\n+  assert(from->is_valid() && to->is_valid(), \"source and destination must be valid\");\n+  if (reg_state[to->value()] == reg_written) {\n+    return true; \/\/ Already written\n+  }\n+\n+  if (from != to && bt != T_VOID) {\n+    if (reg_state[to->value()] == reg_readonly) {\n+      return false; \/\/ Not yet writable\n+    }\n+    if (from->is_reg()) {\n+      if (to->is_reg()) {\n+        if (from->is_Register() && to->is_Register()) {\n+          mov(to->as_Register(), from->as_Register());\n+        } else if (from->is_FloatRegister() && to->is_FloatRegister()) {\n+          fmovd(to->as_FloatRegister(), from->as_FloatRegister());\n+        } else {\n+          ShouldNotReachHere();\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n+        Address to_addr = Address(sp, st_off);\n+        if (from->is_FloatRegister()) {\n+          if (bt == T_DOUBLE) {\n+             strd(from->as_FloatRegister(), to_addr);\n+          } else {\n+             assert(bt == T_FLOAT, \"must be float\");\n+             strs(from->as_FloatRegister(), to_addr);\n+          }\n+        } else {\n+          str(from->as_Register(), to_addr);\n+        }\n+      }\n+    } else {\n+      Address from_addr = Address(sp, from->reg2stack() * VMRegImpl::stack_slot_size);\n+      if (to->is_reg()) {\n+        if (to->is_FloatRegister()) {\n+          if (bt == T_DOUBLE) {\n+            ldrd(to->as_FloatRegister(), from_addr);\n+          } else {\n+            assert(bt == T_FLOAT, \"must be float\");\n+            ldrs(to->as_FloatRegister(), from_addr);\n+          }\n+        } else {\n+          ldr(to->as_Register(), from_addr);\n+        }\n+      } else {\n+        int st_off = to->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(rscratch1, from_addr);\n+        str(rscratch1, Address(sp, st_off));\n+      }\n+    }\n+  }\n+\n+  \/\/ Update register states\n+  reg_state[from->value()] = reg_writable;\n+  reg_state[to->value()] = reg_written;\n+  return true;\n+}\n+\n+\/\/ Calculate the extra stack space required for packing or unpacking inline\n+\/\/ args and adjust the stack pointer\n+int MacroAssembler::extend_stack_for_inline_args(int args_on_stack) {\n+  int sp_inc = args_on_stack * VMRegImpl::stack_slot_size;\n+  sp_inc = align_up(sp_inc, StackAlignmentInBytes);\n+  assert(sp_inc > 0, \"sanity\");\n+\n+  \/\/ Save a copy of the FP and LR here for deoptimization patching and frame walking\n+  stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+\n+  \/\/ Adjust the stack pointer. This will be repaired on return by MacroAssembler::remove_frame\n+  if (sp_inc < (1 << 9)) {\n+    sub(sp, sp, sp_inc);   \/\/ Fits in an immediate\n+  } else {\n+    mov(rscratch1, sp_inc);\n+    sub(sp, sp, rscratch1);\n+  }\n+\n+  return sp_inc + 2 * wordSize;  \/\/ Account for the FP\/LR space\n+}\n+\n+\/\/ Read all fields from an inline type oop and store the values in registers\/stack slots\n+bool MacroAssembler::unpack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index,\n+                                          VMReg from, int& from_index, VMRegPair* to, int to_count, int& to_index,\n+                                          RegState reg_state[]) {\n+  assert(sig->at(sig_index)._bt == T_VOID, \"should be at end delimiter\");\n+  assert(from->is_valid(), \"source must be valid\");\n+  bool progress = false;\n+#ifdef ASSERT\n+  const int start_offset = offset();\n+#endif\n+\n+  Label L_null, L_notNull;\n+  \/\/ Don't use r14 as tmp because it's used for spilling (see MacroAssembler::spill_reg_for)\n+  \/\/ TODO 8366717 We need to make sure that r14 (and potentially other long-life regs) are kept live in slowpath runtime calls in GC barriers\n+  Register tmp1 = r10;\n+  Register tmp2 = r11;\n+  Register fromReg = noreg;\n+  ScalarizedInlineArgsStream stream(sig, sig_index, to, to_count, to_index, -1);\n+  bool done = true;\n+  bool mark_done = true;\n+  VMReg toReg;\n+  BasicType bt;\n+  \/\/ Check if argument requires a null check\n+  bool null_check = false;\n+  VMReg nullCheckReg;\n+  while (stream.next(nullCheckReg, bt)) {\n+    if (sig->at(stream.sig_index())._offset == -1) {\n+      null_check = true;\n+      break;\n+    }\n+  }\n+  stream.reset(sig_index, to_index);\n+  while (stream.next(toReg, bt)) {\n+    assert(toReg->is_valid(), \"destination must be valid\");\n+    int idx = (int)toReg->value();\n+    if (reg_state[idx] == reg_readonly) {\n+      if (idx != from->value()) {\n+        mark_done = false;\n+      }\n+      done = false;\n+      continue;\n+    } else if (reg_state[idx] == reg_written) {\n+      continue;\n+    }\n+    assert(reg_state[idx] == reg_writable, \"must be writable\");\n+    reg_state[idx] = reg_written;\n+    progress = true;\n+\n+    if (fromReg == noreg) {\n+      if (from->is_reg()) {\n+        fromReg = from->as_Register();\n+      } else {\n+        int st_off = from->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldr(tmp1, Address(sp, st_off));\n+        fromReg = tmp1;\n+      }\n+      if (null_check) {\n+        \/\/ Nullable inline type argument, emit null check\n+        cbz(fromReg, L_null);\n+      }\n+    }\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      assert(null_check, \"Missing null check at\");\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        mov(tmp2, 1);\n+        str(tmp2, Address(sp, st_off));\n+      } else {\n+        mov(toReg->as_Register(), 1);\n+      }\n+      continue;\n+    }\n+    assert(off > 0, \"offset in object should be positive\");\n+    Address fromAddr = Address(fromReg, off);\n+    if (!toReg->is_FloatRegister()) {\n+      Register dst = toReg->is_stack() ? tmp2 : toReg->as_Register();\n+      if (is_reference_type(bt)) {\n+        load_heap_oop(dst, fromAddr, rscratch1, rscratch2);\n+      } else {\n+        bool is_signed = (bt != T_CHAR) && (bt != T_BOOLEAN);\n+        load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);\n+      }\n+      if (toReg->is_stack()) {\n+        int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        str(dst, Address(sp, st_off));\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      ldrd(toReg->as_FloatRegister(), fromAddr);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      ldrs(toReg->as_FloatRegister(), fromAddr);\n+    }\n+  }\n+  if (progress && null_check) {\n+    if (done) {\n+      b(L_notNull);\n+      bind(L_null);\n+      \/\/ Set null marker to zero to signal that the argument is null.\n+      \/\/ Also set all oop fields to zero to make the GC happy.\n+      stream.reset(sig_index, to_index);\n+      while (stream.next(toReg, bt)) {\n+        if (sig->at(stream.sig_index())._offset == -1 ||\n+            bt == T_OBJECT || bt == T_ARRAY) {\n+          if (toReg->is_stack()) {\n+            int st_off = toReg->reg2stack() * VMRegImpl::stack_slot_size;\n+            str(zr, Address(sp, st_off));\n+          } else {\n+            mov(toReg->as_Register(), zr);\n+          }\n+        }\n+      }\n+      bind(L_notNull);\n+    } else {\n+      bind(L_null);\n+    }\n+  }\n+\n+  \/\/ TODO 8366717 This is probably okay but looks fishy because stream is reset in the \"Set null marker to zero\" case just above. Same on x64.\n+  sig_index = stream.sig_index();\n+  to_index = stream.regs_index();\n+\n+  if (mark_done && reg_state[from->value()] != reg_written) {\n+    \/\/ This is okay because no one else will write to that slot\n+    reg_state[from->value()] = reg_writable;\n+  }\n+  from_index--;\n+  assert(progress || (start_offset == offset()), \"should not emit code\");\n+  return done;\n+}\n+\n+\/\/ Pack fields back into an inline type oop\n+bool MacroAssembler::pack_inline_helper(const GrowableArray<SigEntry>* sig, int& sig_index, int vtarg_index,\n+                                        VMRegPair* from, int from_count, int& from_index, VMReg to,\n+                                        RegState reg_state[], Register val_array) {\n+  assert(sig->at(sig_index)._bt == T_METADATA, \"should be at delimiter\");\n+  assert(to->is_valid(), \"destination must be valid\");\n+\n+  if (reg_state[to->value()] == reg_written) {\n+    skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+    return true; \/\/ Already written\n+  }\n+\n+  \/\/ The GC barrier expanded by store_heap_oop below may call into the\n+  \/\/ runtime so use callee-saved registers for any values that need to be\n+  \/\/ preserved. The GC barrier assembler should take care of saving the\n+  \/\/ Java argument registers.\n+  \/\/ TODO 8284443 Isn't it an issue if below code uses r14 as tmp when it contains a spilled value?\n+  \/\/ Be careful with r14 because it's used for spilling (see MacroAssembler::spill_reg_for).\n+  Register val_obj_tmp = r21;\n+  Register from_reg_tmp = r22;\n+  Register tmp1 = r14;\n+  Register tmp2 = r13;\n+  Register tmp3 = r12;\n+  Register val_obj = to->is_stack() ? val_obj_tmp : to->as_Register();\n+\n+  assert_different_registers(val_obj_tmp, from_reg_tmp, tmp1, tmp2, tmp3, val_array);\n+\n+  if (reg_state[to->value()] == reg_readonly) {\n+    if (!is_reg_in_unpacked_fields(sig, sig_index, to, from, from_count, from_index)) {\n+      skip_unpacked_fields(sig, sig_index, from, from_count, from_index);\n+      return false; \/\/ Not yet writable\n+    }\n+    val_obj = val_obj_tmp;\n+  }\n+\n+  int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_OBJECT);\n+  load_heap_oop(val_obj, Address(val_array, index), tmp1, tmp2);\n+\n+  ScalarizedInlineArgsStream stream(sig, sig_index, from, from_count, from_index);\n+  VMReg fromReg;\n+  BasicType bt;\n+  Label L_null;\n+  while (stream.next(fromReg, bt)) {\n+    assert(fromReg->is_valid(), \"source must be valid\");\n+    reg_state[fromReg->value()] = reg_writable;\n+\n+    int off = sig->at(stream.sig_index())._offset;\n+    if (off == -1) {\n+      \/\/ Nullable inline type argument, emit null check\n+      Label L_notNull;\n+      if (fromReg->is_stack()) {\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        ldrb(tmp2, Address(sp, ld_off));\n+        cbnz(tmp2, L_notNull);\n+      } else {\n+        cbnz(fromReg->as_Register(), L_notNull);\n+      }\n+      mov(val_obj, 0);\n+      b(L_null);\n+      bind(L_notNull);\n+      continue;\n+    }\n+\n+    assert(off > 0, \"offset in object should be positive\");\n+    size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;\n+\n+    \/\/ Pack the scalarized field into the value object.\n+    Address dst(val_obj, off);\n+    if (!fromReg->is_FloatRegister()) {\n+      Register src;\n+      if (fromReg->is_stack()) {\n+        src = from_reg_tmp;\n+        int ld_off = fromReg->reg2stack() * VMRegImpl::stack_slot_size;\n+        load_sized_value(src, Address(sp, ld_off), size_in_bytes, \/* is_signed *\/ false);\n+      } else {\n+        src = fromReg->as_Register();\n+      }\n+      assert_different_registers(dst.base(), src, tmp1, tmp2, tmp3, val_array);\n+      if (is_reference_type(bt)) {\n+        store_heap_oop(dst, src, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);\n+      } else {\n+        store_sized_value(dst, src, size_in_bytes);\n+      }\n+    } else if (bt == T_DOUBLE) {\n+      strd(fromReg->as_FloatRegister(), dst);\n+    } else {\n+      assert(bt == T_FLOAT, \"must be float\");\n+      strs(fromReg->as_FloatRegister(), dst);\n+    }\n+  }\n+  bind(L_null);\n+  sig_index = stream.sig_index();\n+  from_index = stream.regs_index();\n+\n+  assert(reg_state[to->value()] == reg_writable, \"must have already been read\");\n+  bool success = move_helper(val_obj->as_VMReg(), to, T_OBJECT, reg_state);\n+  assert(success, \"to register must be writeable\");\n+  return true;\n+}\n+\n+VMReg MacroAssembler::spill_reg_for(VMReg reg) {\n+  return (reg->is_FloatRegister()) ? v8->as_VMReg() : r14->as_VMReg();\n+}\n+\n@@ -7145,0 +7937,4 @@\n+  if (EnableValhalla) {\n+    \/\/ Mask inline_type bit such that we go to the slow path if object is an inline type\n+    andr(mark, mark, ~((int) markWord::inline_type_bit_in_place));\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":798,"deletions":2,"binary":false,"changes":800,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"asm\/assembler.hpp\"\n@@ -41,0 +42,2 @@\n+#include \"utilities\/macros.hpp\"\n+#include \"vmreg_x86.inline.hpp\"\n@@ -304,4 +307,6 @@\n-  __ movptr(c_rarg0, result);\n-  Label is_long, is_float, is_double, exit;\n-  __ movl(c_rarg1, result_type);\n-  __ cmpl(c_rarg1, T_OBJECT);\n+  __ movptr(r13, result);\n+  Label is_long, is_float, is_double, check_prim, exit;\n+  __ movl(rbx, result_type);\n+  __ cmpl(rbx, T_OBJECT);\n+  __ jcc(Assembler::equal, check_prim);\n+  __ cmpl(rbx, T_LONG);\n@@ -309,3 +314,1 @@\n-  __ cmpl(c_rarg1, T_LONG);\n-  __ jcc(Assembler::equal, is_long);\n-  __ cmpl(c_rarg1, T_FLOAT);\n+  __ cmpl(rbx, T_FLOAT);\n@@ -313,1 +316,1 @@\n-  __ cmpl(c_rarg1, T_DOUBLE);\n+  __ cmpl(rbx, T_DOUBLE);\n@@ -319,1 +322,1 @@\n-    __ cmpl(c_rarg1, T_INT);\n+    __ cmpl(rbx, T_INT);\n@@ -327,1 +330,1 @@\n-  __ movl(Address(c_rarg0, 0), rax);\n+  __ movl(Address(r13, 0), rax);\n@@ -385,0 +388,13 @@\n+  __ BIND(check_prim);\n+  if (InlineTypeReturnedAsFields) {\n+    \/\/ Check for scalarized return value\n+    __ testptr(rax, 1);\n+    __ jcc(Assembler::zero, is_long);\n+    \/\/ Load pack handler address\n+    __ andptr(rax, -2);\n+    __ movptr(rax, Address(rax, InstanceKlass::adr_inlineklass_fixed_block_offset()));\n+    __ movptr(rbx, Address(rax, InlineKlass::pack_handler_jobject_offset()));\n+    \/\/ Call pack handler to initialize the buffer\n+    __ call(rbx);\n+    __ jmp(exit);\n+  }\n@@ -386,1 +402,1 @@\n-  __ movq(Address(c_rarg0, 0), rax);\n+  __ movq(Address(r13, 0), rax);\n@@ -390,1 +406,1 @@\n-  __ movflt(Address(c_rarg0, 0), xmm0);\n+  __ movflt(Address(r13, 0), xmm0);\n@@ -394,1 +410,1 @@\n-  __ movdbl(Address(c_rarg0, 0), xmm0);\n+  __ movdbl(Address(r13, 0), xmm0);\n@@ -3768,0 +3784,61 @@\n+static void save_return_registers(MacroAssembler* masm) {\n+  masm->push_ppx(rax);\n+  if (InlineTypeReturnedAsFields) {\n+    masm->push(rdi);\n+    masm->push(rsi);\n+    masm->push(rdx);\n+    masm->push(rcx);\n+    masm->push(r8);\n+    masm->push(r9);\n+  }\n+  masm->push_d(xmm0);\n+  if (InlineTypeReturnedAsFields) {\n+    masm->push_d(xmm1);\n+    masm->push_d(xmm2);\n+    masm->push_d(xmm3);\n+    masm->push_d(xmm4);\n+    masm->push_d(xmm5);\n+    masm->push_d(xmm6);\n+    masm->push_d(xmm7);\n+  }\n+#ifdef ASSERT\n+  masm->movq(rax, 0xBADC0FFE);\n+  masm->movq(rdi, rax);\n+  masm->movq(rsi, rax);\n+  masm->movq(rdx, rax);\n+  masm->movq(rcx, rax);\n+  masm->movq(r8, rax);\n+  masm->movq(r9, rax);\n+  masm->movq(xmm0, rax);\n+  masm->movq(xmm1, rax);\n+  masm->movq(xmm2, rax);\n+  masm->movq(xmm3, rax);\n+  masm->movq(xmm4, rax);\n+  masm->movq(xmm5, rax);\n+  masm->movq(xmm6, rax);\n+  masm->movq(xmm7, rax);\n+#endif\n+}\n+\n+static void restore_return_registers(MacroAssembler* masm) {\n+  if (InlineTypeReturnedAsFields) {\n+    masm->pop_d(xmm7);\n+    masm->pop_d(xmm6);\n+    masm->pop_d(xmm5);\n+    masm->pop_d(xmm4);\n+    masm->pop_d(xmm3);\n+    masm->pop_d(xmm2);\n+    masm->pop_d(xmm1);\n+  }\n+  masm->pop_d(xmm0);\n+  if (InlineTypeReturnedAsFields) {\n+    masm->pop(r9);\n+    masm->pop(r8);\n+    masm->pop(rcx);\n+    masm->pop(rdx);\n+    masm->pop(rsi);\n+    masm->pop(rdi);\n+  }\n+  masm->pop_ppx(rax);\n+}\n+\n@@ -3819,2 +3896,1 @@\n-    __ push_ppx(rax);\n-    __ push_d(xmm0);\n+    save_return_registers(_masm);\n@@ -3831,2 +3907,1 @@\n-    __ pop_d(xmm0);\n-    __ pop_ppx(rax);\n+    restore_return_registers(_masm);\n@@ -3858,2 +3933,1 @@\n-    __ push_ppx(rax);\n-    __ push_d(xmm0);\n+    save_return_registers(_masm);\n@@ -3871,2 +3945,1 @@\n-    __ pop_d(xmm0);\n-    __ pop_ppx(rax);\n+    restore_return_registers(_masm);\n@@ -4079,0 +4152,10 @@\n+  \/\/ Generate these first because they are called from other stubs\n+  if (InlineTypeReturnedAsFields) {\n+    StubRoutines::_load_inline_type_fields_in_regs =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::load_inline_type_fields_in_regs),\n+                                 \"load_inline_type_fields_in_regs\", false);\n+    StubRoutines::_store_inline_type_fields_to_buf =\n+      generate_return_value_stub(CAST_FROM_FN_PTR(address, SharedRuntime::store_inline_type_fields_to_buf),\n+                                 \"store_inline_type_fields_to_buf\", true);\n+  }\n+\n@@ -4124,0 +4207,144 @@\n+\/\/ Call here from the interpreter or compiled code to either load\n+\/\/ multiple returned values from the inline type instance being\n+\/\/ returned to registers or to store returned values to a newly\n+\/\/ allocated inline type instance.\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n+address StubGenerator::generate_return_value_stub(address destination, const char* name, bool has_res) {\n+  \/\/ We need to save all registers the calling convention may use so\n+  \/\/ the runtime calls read or update those registers. This needs to\n+  \/\/ be in sync with SharedRuntime::java_return_convention().\n+  enum layout {\n+    pad_off = frame::arg_reg_save_area_bytes\/BytesPerInt, pad_off_2,\n+    rax_off, rax_off_2,\n+    j_rarg5_off, j_rarg5_2,\n+    j_rarg4_off, j_rarg4_2,\n+    j_rarg3_off, j_rarg3_2,\n+    j_rarg2_off, j_rarg2_2,\n+    j_rarg1_off, j_rarg1_2,\n+    j_rarg0_off, j_rarg0_2,\n+    j_farg0_off, j_farg0_2,\n+    j_farg1_off, j_farg1_2,\n+    j_farg2_off, j_farg2_2,\n+    j_farg3_off, j_farg3_2,\n+    j_farg4_off, j_farg4_2,\n+    j_farg5_off, j_farg5_2,\n+    j_farg6_off, j_farg6_2,\n+    j_farg7_off, j_farg7_2,\n+    rbp_off, rbp_off_2,\n+    return_off, return_off_2,\n+\n+    framesize\n+  };\n+\n+  CodeBuffer buffer(name, 1000, 512);\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+\n+  int frame_size_in_bytes = align_up(framesize*BytesPerInt, 16);\n+  assert(frame_size_in_bytes == framesize*BytesPerInt, \"misaligned\");\n+  int frame_size_in_slots = frame_size_in_bytes \/ BytesPerInt;\n+  int frame_size_in_words = frame_size_in_bytes \/ wordSize;\n+\n+  OopMapSet *oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(frame_size_in_slots, 0);\n+\n+  map->set_callee_saved(VMRegImpl::stack2reg(rax_off), rax->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg5_off), j_rarg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg4_off), j_rarg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg3_off), j_rarg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg2_off), j_rarg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg1_off), j_rarg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_rarg0_off), j_rarg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg0_off), j_farg0->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg1_off), j_farg1->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg2_off), j_farg2->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg3_off), j_farg3->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg4_off), j_farg4->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg5_off), j_farg5->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg6_off), j_farg6->as_VMReg());\n+  map->set_callee_saved(VMRegImpl::stack2reg(j_farg7_off), j_farg7->as_VMReg());\n+\n+  int start = __ offset();\n+\n+  __ subptr(rsp, frame_size_in_bytes - 8 \/* return address*\/);\n+\n+  __ movptr(Address(rsp, rbp_off * BytesPerInt), rbp);\n+  __ movdbl(Address(rsp, j_farg7_off * BytesPerInt), j_farg7);\n+  __ movdbl(Address(rsp, j_farg6_off * BytesPerInt), j_farg6);\n+  __ movdbl(Address(rsp, j_farg5_off * BytesPerInt), j_farg5);\n+  __ movdbl(Address(rsp, j_farg4_off * BytesPerInt), j_farg4);\n+  __ movdbl(Address(rsp, j_farg3_off * BytesPerInt), j_farg3);\n+  __ movdbl(Address(rsp, j_farg2_off * BytesPerInt), j_farg2);\n+  __ movdbl(Address(rsp, j_farg1_off * BytesPerInt), j_farg1);\n+  __ movdbl(Address(rsp, j_farg0_off * BytesPerInt), j_farg0);\n+\n+  __ movptr(Address(rsp, j_rarg0_off * BytesPerInt), j_rarg0);\n+  __ movptr(Address(rsp, j_rarg1_off * BytesPerInt), j_rarg1);\n+  __ movptr(Address(rsp, j_rarg2_off * BytesPerInt), j_rarg2);\n+  __ movptr(Address(rsp, j_rarg3_off * BytesPerInt), j_rarg3);\n+  __ movptr(Address(rsp, j_rarg4_off * BytesPerInt), j_rarg4);\n+  __ movptr(Address(rsp, j_rarg5_off * BytesPerInt), j_rarg5);\n+  __ movptr(Address(rsp, rax_off * BytesPerInt), rax);\n+\n+  int frame_complete = __ offset();\n+\n+  __ set_last_Java_frame(noreg, noreg, nullptr, rscratch1);\n+\n+  __ mov(c_rarg0, r15_thread);\n+  __ mov(c_rarg1, rax);\n+\n+  __ call(RuntimeAddress(destination));\n+\n+  \/\/ Set an oopmap for the call site.\n+\n+  oop_maps->add_gc_map( __ offset() - start, map);\n+\n+  \/\/ clear last_Java_sp\n+  __ reset_last_Java_frame(false);\n+\n+  __ movptr(rbp, Address(rsp, rbp_off * BytesPerInt));\n+  __ movdbl(j_farg7, Address(rsp, j_farg7_off * BytesPerInt));\n+  __ movdbl(j_farg6, Address(rsp, j_farg6_off * BytesPerInt));\n+  __ movdbl(j_farg5, Address(rsp, j_farg5_off * BytesPerInt));\n+  __ movdbl(j_farg4, Address(rsp, j_farg4_off * BytesPerInt));\n+  __ movdbl(j_farg3, Address(rsp, j_farg3_off * BytesPerInt));\n+  __ movdbl(j_farg2, Address(rsp, j_farg2_off * BytesPerInt));\n+  __ movdbl(j_farg1, Address(rsp, j_farg1_off * BytesPerInt));\n+  __ movdbl(j_farg0, Address(rsp, j_farg0_off * BytesPerInt));\n+\n+  __ movptr(j_rarg0, Address(rsp, j_rarg0_off * BytesPerInt));\n+  __ movptr(j_rarg1, Address(rsp, j_rarg1_off * BytesPerInt));\n+  __ movptr(j_rarg2, Address(rsp, j_rarg2_off * BytesPerInt));\n+  __ movptr(j_rarg3, Address(rsp, j_rarg3_off * BytesPerInt));\n+  __ movptr(j_rarg4, Address(rsp, j_rarg4_off * BytesPerInt));\n+  __ movptr(j_rarg5, Address(rsp, j_rarg5_off * BytesPerInt));\n+  __ movptr(rax, Address(rsp, rax_off * BytesPerInt));\n+\n+  __ addptr(rsp, frame_size_in_bytes-8);\n+\n+  \/\/ check for pending exceptions\n+  Label pending;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, pending);\n+\n+  if (has_res) {\n+    __ get_vm_result_oop(rax);\n+  }\n+\n+  __ ret(0);\n+\n+  __ bind(pending);\n+\n+  __ movptr(rax, Address(r15_thread, Thread::pending_exception_offset()));\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ -------------\n+  \/\/ make sure all code is generated\n+  _masm->flush();\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &buffer, frame_complete, frame_size_in_words, oop_maps, false);\n+  return stub->entry_point();\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":248,"deletions":21,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+                 Inline_Entry,\n+                 Verified_Inline_Entry,\n+                 Verified_Inline_Entry_RO,\n@@ -71,0 +74,1 @@\n+  void check(int e) const { assert(0 <= e && e < max_Entries, \"must be\"); }\n@@ -76,0 +80,3 @@\n+    _values[Inline_Entry  ] = 0;\n+    _values[Verified_Inline_Entry] = -1;\n+    _values[Verified_Inline_Entry_RO] = -1;\n@@ -84,2 +91,2 @@\n-  int value(Entries e) { return _values[e]; }\n-  void set_value(Entries e, int val) { _values[e] = val; }\n+  int value(Entries e) const { check(e); return _values[e]; }\n+  void set_value(Entries e, int val) { check(e); _values[e] = val; }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/growableArray.hpp\"\n","filename":"src\/hotspot\/share\/asm\/macroAssembler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,250 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"jvm.h\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/signature_cc.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/node.hpp\"\n+#endif\n+\n+void MacroAssembler::skip_unpacked_fields(const GrowableArray<SigEntry>* sig, int& sig_index, VMRegPair* regs_from, int regs_from_count, int& from_index) {\n+  ScalarizedInlineArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);\n+  VMReg reg;\n+  BasicType bt;\n+  while (stream.next(reg, bt)) {}\n+  sig_index = stream.sig_index();\n+  from_index = stream.regs_index();\n+}\n+\n+bool MacroAssembler::is_reg_in_unpacked_fields(const GrowableArray<SigEntry>* sig, int sig_index, VMReg to, VMRegPair* regs_from, int regs_from_count, int from_index) {\n+  ScalarizedInlineArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);\n+  VMReg reg;\n+  BasicType bt;\n+  while (stream.next(reg, bt)) {\n+    if (reg == to) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void MacroAssembler::mark_reg_writable(const VMRegPair* regs, int num_regs, int reg_index, MacroAssembler::RegState* reg_state) {\n+  assert(0 <= reg_index && reg_index < num_regs, \"sanity\");\n+  VMReg from_reg = regs[reg_index].first();\n+  if (from_reg->is_valid()) {\n+    assert(from_reg->is_stack(), \"reserved entries must be stack\");\n+    reg_state[from_reg->value()] = MacroAssembler::reg_writable;\n+  }\n+}\n+\n+MacroAssembler::RegState* MacroAssembler::init_reg_state(VMRegPair* regs, int num_regs, int sp_inc, int max_stack) {\n+  int max_reg = VMRegImpl::stack2reg(max_stack)->value();\n+  MacroAssembler::RegState* reg_state = NEW_RESOURCE_ARRAY(MacroAssembler::RegState, max_reg);\n+\n+  \/\/ Make all writable\n+  for (int i = 0; i < max_reg; ++i) {\n+    reg_state[i] = MacroAssembler::reg_writable;\n+  }\n+  \/\/ Set all source registers\/stack slots to readonly to prevent accidental overwriting\n+  for (int i = 0; i < num_regs; ++i) {\n+    VMReg reg = regs[i].first();\n+    if (!reg->is_valid()) continue;\n+    if (reg->is_stack()) {\n+      \/\/ Update source stack location by adding stack increment\n+      reg = VMRegImpl::stack2reg(reg->reg2stack() + sp_inc\/VMRegImpl::stack_slot_size);\n+      regs[i] = reg;\n+    }\n+    assert(reg->value() >= 0 && reg->value() < max_reg, \"reg value out of bounds\");\n+    reg_state[reg->value()] = MacroAssembler::reg_readonly;\n+  }\n+  return reg_state;\n+}\n+\n+#ifdef COMPILER2\n+int MacroAssembler::unpack_inline_args(Compile* C, bool receiver_only) {\n+  assert(C->has_scalarized_args(), \"inline type argument scalarization is disabled\");\n+  Method* method = C->method()->get_Method();\n+  const GrowableArray<SigEntry>* sig = method->adapter()->get_sig_cc();\n+  assert(sig != nullptr, \"must have scalarized signature\");\n+\n+  \/\/ Get unscalarized calling convention\n+  BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, 256);\n+  int args_passed = 0;\n+  if (!method->is_static()) {\n+    sig_bt[args_passed++] = T_OBJECT;\n+  }\n+  if (!receiver_only) {\n+    for (SignatureStream ss(method->signature()); !ss.at_return_type(); ss.next()) {\n+      BasicType bt = ss.type();\n+      sig_bt[args_passed++] = bt;\n+      if (type2size[bt] == 2) {\n+        sig_bt[args_passed++] = T_VOID;\n+      }\n+    }\n+  } else {\n+    \/\/ Only unpack the receiver, all other arguments are already scalarized\n+    InstanceKlass* holder = method->method_holder();\n+    int rec_len = (holder->is_inline_klass() && method->is_scalarized_arg(0)) ? InlineKlass::cast(holder)->extended_sig()->length() : 1;\n+    \/\/ Copy scalarized signature but skip receiver and inline type delimiters\n+    for (int i = 0; i < sig->length(); i++) {\n+      if (SigEntry::skip_value_delimiters(sig, i) && rec_len <= 0) {\n+        sig_bt[args_passed++] = sig->at(i)._bt;\n+      }\n+      rec_len--;\n+    }\n+  }\n+  VMRegPair* regs = NEW_RESOURCE_ARRAY(VMRegPair, args_passed);\n+  int args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, args_passed);\n+\n+  \/\/ Get scalarized calling convention\n+  int args_passed_cc = SigEntry::fill_sig_bt(sig, sig_bt);\n+  VMRegPair* regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig->length());\n+  int args_on_stack_cc = SharedRuntime::java_calling_convention(sig_bt, regs_cc, args_passed_cc);\n+\n+  \/\/ Check if we need to extend the stack for unpacking\n+  int sp_inc = 0;\n+  if (args_on_stack_cc > args_on_stack) {\n+    sp_inc = extend_stack_for_inline_args(args_on_stack_cc);\n+  }\n+  shuffle_inline_args(false, receiver_only, sig,\n+                      args_passed, args_on_stack, regs,           \/\/ from\n+                      args_passed_cc, args_on_stack_cc, regs_cc,  \/\/ to\n+                      sp_inc, noreg);\n+  return sp_inc;\n+}\n+#endif \/\/ COMPILER2\n+\n+void MacroAssembler::shuffle_inline_args(bool is_packing, bool receiver_only,\n+                                         const GrowableArray<SigEntry>* sig,\n+                                         int args_passed, int args_on_stack, VMRegPair* regs,\n+                                         int args_passed_to, int args_on_stack_to, VMRegPair* regs_to,\n+                                         int sp_inc, Register val_array) {\n+  int max_stack = MAX2(args_on_stack + sp_inc\/VMRegImpl::stack_slot_size, args_on_stack_to);\n+  RegState* reg_state = init_reg_state(regs, args_passed, sp_inc, max_stack);\n+\n+  \/\/ Emit code for packing\/unpacking inline type arguments\n+  \/\/ We try multiple times and eventually start spilling to resolve (circular) dependencies\n+  bool done = (args_passed_to == 0);\n+  for (int i = 0; i < 2*args_passed_to && !done; ++i) {\n+    done = true;\n+    bool spill = (i > args_passed_to); \/\/ Start spilling?\n+    \/\/ Iterate over all arguments (when unpacking, do in reverse)\n+    int step = is_packing ? 1 : -1;\n+    int from_index    = is_packing ? 0 : args_passed      - 1;\n+    int to_index      = is_packing ? 0 : args_passed_to   - 1;\n+    int sig_index     = is_packing ? 0 : sig->length()    - 1;\n+    int sig_index_end = is_packing ? sig->length() : -1;\n+    int vtarg_index = 0;\n+    for (; sig_index != sig_index_end; sig_index += step) {\n+      assert(0 <= sig_index && sig_index < sig->length(), \"index out of bounds\");\n+      if (spill) {\n+        \/\/ This call returns true IFF we should keep trying to spill in this round.\n+        spill = shuffle_inline_args_spill(is_packing, sig, sig_index, regs, from_index, args_passed,\n+                                          reg_state);\n+      }\n+      BasicType bt = sig->at(sig_index)._bt;\n+      if (SigEntry::skip_value_delimiters(sig, sig_index)) {\n+        VMReg from_reg = regs[from_index].first();\n+        if (from_reg->is_valid()) {\n+          done &= move_helper(from_reg, regs_to[to_index].first(), bt, reg_state);\n+        } else {\n+          \/\/ halves of T_LONG or T_DOUBLE\n+          assert(bt == T_VOID, \"unexpected basic type\");\n+        }\n+        to_index += step;\n+        from_index += step;\n+      } else if (is_packing) {\n+        assert(val_array != noreg, \"must be\");\n+        VMReg reg_to = regs_to[to_index].first();\n+        done &= pack_inline_helper(sig, sig_index, vtarg_index,\n+                                   regs, args_passed, from_index, reg_to,\n+                                   reg_state, val_array);\n+        vtarg_index++;\n+        to_index++;\n+      } else if (!receiver_only || (from_index == 0 && bt == T_VOID)) {\n+        VMReg from_reg = regs[from_index].first();\n+        done &= unpack_inline_helper(sig, sig_index,\n+                                     from_reg, from_index, regs_to, args_passed_to, to_index,\n+                                     reg_state);\n+        if (from_index == -1 && sig_index != 0) {\n+          \/\/ This can happen when we are confusing an empty inline type argument which is\n+          \/\/ not counted in the scalarized signature for the receiver. Just ignore it.\n+          assert(receiver_only, \"sanity\");\n+          from_index = 0;\n+        }\n+      }\n+    }\n+  }\n+  guarantee(done, \"Could not resolve circular dependency when shuffling inline type arguments\");\n+}\n+\n+bool MacroAssembler::shuffle_inline_args_spill(bool is_packing, const GrowableArray<SigEntry>* sig, int sig_index,\n+                                               VMRegPair* regs_from, int from_index, int regs_from_count, RegState* reg_state) {\n+  VMReg reg;\n+  if (!is_packing || SigEntry::skip_value_delimiters(sig, sig_index)) {\n+    reg = regs_from[from_index].first();\n+    if (!reg->is_valid() || reg_state[reg->value()] != reg_readonly) {\n+      \/\/ Spilling this won't break cycles\n+      return true;\n+    }\n+  } else {\n+    ScalarizedInlineArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);\n+    VMReg from_reg;\n+    BasicType bt;\n+    bool found = false;\n+    while (stream.next(from_reg, bt)) {\n+      reg = from_reg;\n+      assert(from_reg->is_valid(), \"must be\");\n+      if (reg_state[from_reg->value()] == reg_readonly) {\n+        found = true;\n+        break;\n+      }\n+    }\n+    if (!found) {\n+      \/\/ Spilling fields in this inline type arg won't break cycles\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Spill argument to be able to write the source and resolve circular dependencies\n+  VMReg spill_reg = spill_reg_for(reg);\n+  if (reg_state[spill_reg->value()] == reg_readonly) {\n+    \/\/ We have already spilled (in previous round). The spilled register should be consumed by this round.\n+  } else {\n+    bool res = move_helper(reg, spill_reg, T_DOUBLE, reg_state);\n+    assert(res, \"Spilling should not fail\");\n+    \/\/ Set spill_reg as new source and update state\n+    reg = spill_reg;\n+    regs_from[from_index].set1(reg);\n+    reg_state[reg->value()] = reg_readonly;\n+  }\n+\n+  return false; \/\/ Do not spill again in this round\n+}\n","filename":"src\/hotspot\/share\/asm\/macroAssembler_common.cpp","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"},{"patch":"@@ -379,0 +379,1 @@\n+\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -858,1 +858,1 @@\n-      k->set_prototype_header(markWord::prototype().set_narrow_klass(nk));\n+      k->set_prototype_header_klass(nk);\n@@ -861,1 +861,7 @@\n-    if (k->is_objArray_klass()) {\n+    if (k->is_flatArray_klass()) {\n+      num_obj_array_klasses ++;\n+      type = \"flat array\";\n+    } else if (k->is_refArray_klass()) {\n+        num_obj_array_klasses ++;\n+        type = \"ref array\";\n+    } else if (k->is_objArray_klass()) {\n@@ -865,1 +871,1 @@\n-      type = \"array\";\n+      type = \"obj array\";\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n@@ -297,1 +298,1 @@\n-  ((objArrayOop)array.resolve())->replace_if_null(index, o);\n+  refArrayOopDesc::cast(array.resolve())->replace_if_null(index, o);\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -569,1 +569,5 @@\n-  if (k->local_interfaces()->length() != _interfaces->length()) {\n+  const int actual_num_interfaces = k->local_interfaces()->length();\n+  const int specified_num_interfaces = _interfaces->length(); \/\/ specified in classlist\n+  int expected_num_interfaces = actual_num_interfaces;\n+\n+  if (specified_num_interfaces != expected_num_interfaces) {\n@@ -573,1 +577,1 @@\n-          _interfaces->length(), k->local_interfaces()->length());\n+          specified_num_interfaces, expected_num_interfaces);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -38,0 +41,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -57,0 +61,1 @@\n+\/\/ NOTE: this table must be in-sync with sun.jvm.hotspot.memory.FileMapInfo::populateMetadataTypeArray().\n@@ -69,0 +74,3 @@\n+  f(FlatArrayKlass) \\\n+  f(InlineKlass) \\\n+  f(RefArrayKlass) \\\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -369,0 +369,3 @@\n+      if (oak->is_refined_objArray_klass()) {\n+        oak = ObjArrayKlass::cast(oak->super());\n+      }\n@@ -439,8 +442,10 @@\n-\n-      if (elm->is_instance_klass()) {\n-        assert(InstanceKlass::cast(elm)->array_klasses() == nullptr, \"must be\");\n-        InstanceKlass::cast(elm)->set_array_klasses(oak);\n-      } else {\n-        assert(elm->is_array_klass(), \"sanity\");\n-        assert(ArrayKlass::cast(elm)->higher_dimension() == nullptr, \"must be\");\n-        ArrayKlass::cast(elm)->set_higher_dimension(oak);\n+      \/\/ Higher dimension may have been set when doing setup on ObjArrayKlass\n+      if (!oak->is_refined_objArray_klass()) {\n+        if (elm->is_instance_klass()) {\n+          assert(InstanceKlass::cast(elm)->array_klasses() == nullptr, \"must be\");\n+          InstanceKlass::cast(elm)->set_array_klasses(oak);\n+        } else {\n+          assert(elm->is_array_klass(), \"sanity\");\n+          assert(ArrayKlass::cast(elm)->higher_dimension() == nullptr, \"must be\");\n+          ArrayKlass::cast(elm)->set_higher_dimension(oak);\n+        }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -90,0 +90,65 @@\n+inline void CDSMustMatchFlags::do_print(outputStream* st, bool v) {\n+  st->print(\"%s\", v ? \"true\" : \"false\");\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, intx v) {\n+  st->print(\"%zd\", v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, uintx v) {\n+  st->print(\"%zu\", v);\n+}\n+\n+inline void CDSMustMatchFlags::do_print(outputStream* st, double v) {\n+  st->print(\"%f\", v);\n+}\n+\n+void CDSMustMatchFlags::init() {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+  _max_name_width = 0;\n+\n+#define INIT_CDS_MUST_MATCH_FLAG(n) \\\n+  _v_##n = n; \\\n+  _max_name_width = MAX2(_max_name_width,strlen(#n));\n+  CDS_MUST_MATCH_FLAGS_DO(INIT_CDS_MUST_MATCH_FLAG);\n+#undef INIT_CDS_MUST_MATCH_FLAG\n+}\n+\n+bool CDSMustMatchFlags::runtime_check() const {\n+#define CHECK_CDS_MUST_MATCH_FLAG(n) \\\n+  if (_v_##n != n) { \\\n+    ResourceMark rm; \\\n+    stringStream ss; \\\n+    ss.print(\"VM option %s is different between dumptime (\", #n);  \\\n+    do_print(&ss, _v_ ## n); \\\n+    ss.print(\") and runtime (\"); \\\n+    do_print(&ss, n); \\\n+    ss.print(\")\"); \\\n+    log_info(cds)(\"%s\", ss.as_string()); \\\n+    return false; \\\n+  }\n+  CDS_MUST_MATCH_FLAGS_DO(CHECK_CDS_MUST_MATCH_FLAG);\n+#undef CHECK_CDS_MUST_MATCH_FLAG\n+\n+  return true;\n+}\n+\n+void CDSMustMatchFlags::print_info() const {\n+  LogTarget(Info, cds) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Recorded VM flags during dumptime:\");\n+    print(&ls);\n+  }\n+}\n+\n+void CDSMustMatchFlags::print(outputStream* st) const {\n+#define PRINT_CDS_MUST_MATCH_FLAG(n) \\\n+  st->print(\"- %-s \", #n);                   \\\n+  st->sp(int(_max_name_width - strlen(#n))); \\\n+  do_print(st, _v_##n);                      \\\n+  st->cr();\n+  CDS_MUST_MATCH_FLAGS_DO(PRINT_CDS_MUST_MATCH_FLAG);\n+#undef PRINT_CDS_MUST_MATCH_FLAG\n+}\n+\n@@ -249,0 +314,1 @@\n+  _has_valhalla_patched_classes = CDSConfig::is_valhalla_preview();\n@@ -263,0 +329,1 @@\n+  _must_match.init();\n@@ -322,0 +389,2 @@\n+  st->print_cr(\"- has_valhalla_patched_classes    %d\", _has_valhalla_patched_classes);\n+  _must_match.print(st);\n@@ -705,0 +774,4 @@\n+  if (!header()->check_must_match_flags()) {\n+    return false;\n+  }\n+\n@@ -2077,0 +2150,18 @@\n+  if (is_static()) {\n+    const char* err = nullptr;\n+    if (CDSConfig::is_valhalla_preview()) {\n+      if (!_has_valhalla_patched_classes) {\n+        err = \"not created\";\n+      }\n+    } else {\n+      if (_has_valhalla_patched_classes) {\n+        err = \"created\";\n+      }\n+    }\n+    if (err != nullptr) {\n+      log_warning(cds)(\"This archive was %s with --enable-preview -XX:+EnableValhalla. It is \"\n+                         \"incompatible with the current JVM setting\", err);\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -597,0 +597,1 @@\n+      \/\/ For valhalla, the prototype header is the same as markWord::prototype();\n@@ -1305,1 +1306,5 @@\n-      assert(resolved_k == k, \"classes used by archived heap must not be replaced by JVMTI ClassFileLoadHook\");\n+      if (resolved_k->is_array_klass()) {\n+        assert(resolved_k == k || resolved_k == k->super(), \"classes used by archived heap must not be replaced by JVMTI ClassFileLoadHook\");\n+      } else {\n+        assert(resolved_k == k, \"classes used by archived heap must not be replaced by JVMTI ClassFileLoadHook\");\n+      }\n@@ -2047,0 +2052,7 @@\n+\n+    if (CDSConfig::is_valhalla_preview() && strcmp(klass_name, \"jdk\/internal\/module\/ArchivedModuleGraph\") == 0) {\n+      \/\/ FIXME -- ArchivedModuleGraph doesn't work when java.base is patched with valhalla classes.\n+      i++;\n+      continue;\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -127,1 +129,1 @@\n-\/\/ [0] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are\n+\/\/ [0] All classes are loaded in MetaspaceShared::loadable_descriptors(). All metadata are\n@@ -481,1 +483,1 @@\n-  soc->do_tag(objArrayOopDesc::base_offset_in_bytes());\n+  soc->do_tag(refArrayOopDesc::base_offset_in_bytes());\n@@ -896,1 +898,1 @@\n-void MetaspaceShared::preload_classes(TRAPS) {\n+void MetaspaceShared::loadable_descriptors(TRAPS) {\n@@ -943,1 +945,1 @@\n-    preload_classes(CHECK);\n+    loadable_descriptors(CHECK);\n@@ -1248,0 +1250,5 @@\n+  if (CDSConfig::is_valhalla_preview()) {\n+    log_info(cds)(\"Archived java heap is not yet supported with Valhalla preview\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  static void preload_classes(TRAPS) NOT_CDS_RETURN;\n+  static void loadable_descriptors(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -479,1 +480,2 @@\n-      (sym->char_at(1) == JVM_SIGNATURE_ARRAY || sym->char_at(1) == JVM_SIGNATURE_CLASS)) {\n+      (sym->char_at(1) == JVM_SIGNATURE_ARRAY ||\n+       sym->char_at(1) == JVM_SIGNATURE_CLASS )) {\n@@ -492,1 +494,1 @@\n-      return ciObjArrayKlass::make_impl(elem_klass);\n+      return ciArrayKlass::make(elem_klass);\n@@ -518,0 +520,4 @@\n+  int i = 0;\n+  while (sym->char_at(i) == JVM_SIGNATURE_ARRAY) {\n+    i++;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -514,1 +515,1 @@\n-      \/\/ array\n+      \/\/ TODO 8350865 I think we need to handle null-free\/flat arrays here\n@@ -964,0 +965,1 @@\n+\n@@ -1010,27 +1012,79 @@\n-  \/\/ staticfield <klass> <name> <signature> <value>\n-  \/\/\n-  \/\/ Initialize a class and fill in the value for a static field.\n-  \/\/ This is useful when the compile was dependent on the value of\n-  \/\/ static fields but it's impossible to properly rerun the static\n-  \/\/ initializer.\n-  void process_staticfield(TRAPS) {\n-    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n-\n-    if (k == nullptr || ReplaySuppressInitializers == 0 ||\n-        (ReplaySuppressInitializers == 2 && k->class_loader() == nullptr)) {\n-      skip_remaining();\n-      return;\n-    }\n-\n-    assert(k->is_initialized(), \"must be\");\n-\n-    const char* field_name = parse_escaped_string();\n-    const char* field_signature = parse_string();\n-    fieldDescriptor fd;\n-    Symbol* name = SymbolTable::new_symbol(field_name);\n-    Symbol* sig = SymbolTable::new_symbol(field_signature);\n-    if (!k->find_local_field(name, sig, &fd) ||\n-        !fd.is_static() ||\n-        fd.has_initial_value()) {\n-      report_error(field_name);\n-      return;\n+  class InlineTypeFieldInitializer : public FieldClosure {\n+    oop _vt;\n+    CompileReplay* _replay;\n+  public:\n+    InlineTypeFieldInitializer(oop vt, CompileReplay* replay)\n+  : _vt(vt), _replay(replay) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      BasicType bt = fd->field_type();\n+      const char* string_value = fd->is_null_free_inline_type() ? nullptr : _replay->parse_escaped_string();\n+      switch (bt) {\n+      case T_BYTE: {\n+        int value = atoi(string_value);\n+        _vt->byte_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_BOOLEAN: {\n+        int value = atoi(string_value);\n+        _vt->bool_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_SHORT: {\n+        int value = atoi(string_value);\n+        _vt->short_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_CHAR: {\n+        int value = atoi(string_value);\n+        _vt->char_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_INT: {\n+        int value = atoi(string_value);\n+        _vt->int_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_LONG: {\n+        jlong value;\n+        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+          break;\n+        }\n+        _vt->long_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_FLOAT: {\n+        float value = atof(string_value);\n+        _vt->float_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        double value = atof(string_value);\n+        _vt->double_field_put(fd->offset(), value);\n+        break;\n+      }\n+      case T_ARRAY:\n+      case T_OBJECT:\n+        if (!fd->is_null_free_inline_type()) {\n+          JavaThread* THREAD = JavaThread::current();\n+          bool res = _replay->process_staticfield_reference(string_value, _vt, fd, THREAD);\n+          assert(res, \"should succeed for arrays & objects\");\n+          break;\n+        } else {\n+          InlineKlass* vk = InlineKlass::cast(fd->field_holder()->get_inline_type_field_klass(fd->index()));\n+          if (fd->is_flat()) {\n+            int field_offset = fd->offset() - vk->payload_offset();\n+            oop obj = cast_to_oop(cast_from_oop<address>(_vt) + field_offset);\n+            InlineTypeFieldInitializer init_fields(obj, _replay);\n+            vk->do_nonstatic_fields(&init_fields);\n+          } else {\n+            oop value = vk->allocate_instance(JavaThread::current());\n+            _vt->obj_field_put(fd->offset(), value);\n+          }\n+          break;\n+        }\n+      default: {\n+        fatal(\"Unhandled type: %s\", type2name(bt));\n+      }\n+      }\n@@ -1038,0 +1092,1 @@\n+  };\n@@ -1039,1 +1094,1 @@\n-    oop java_mirror = k->java_mirror();\n+  bool process_staticfield_reference(const char* field_signature, oop java_mirror, fieldDescriptor* fd, TRAPS) {\n@@ -1047,4 +1102,2 @@\n-          ArrayKlass* kelem = (ArrayKlass *)parse_klass(CHECK);\n-          if (kelem == nullptr) {\n-            return;\n-          }\n+          Klass* k = resolve_klass(field_signature, CHECK_(true));\n+          ArrayKlass* kelem = (ArrayKlass *)k;\n@@ -1060,1 +1113,1 @@\n-          value = kelem->multi_allocate(rank, dims, CHECK);\n+          value = kelem->multi_allocate(rank, dims, CHECK_(true));\n@@ -1063,1 +1116,1 @@\n-            value = oopFactory::new_byteArray(length, CHECK);\n+            value = oopFactory::new_byteArray(length, CHECK_(true));\n@@ -1065,1 +1118,1 @@\n-            value = oopFactory::new_boolArray(length, CHECK);\n+            value = oopFactory::new_boolArray(length, CHECK_(true));\n@@ -1067,1 +1120,1 @@\n-            value = oopFactory::new_charArray(length, CHECK);\n+            value = oopFactory::new_charArray(length, CHECK_(true));\n@@ -1069,1 +1122,1 @@\n-            value = oopFactory::new_shortArray(length, CHECK);\n+            value = oopFactory::new_shortArray(length, CHECK_(true));\n@@ -1071,1 +1124,1 @@\n-            value = oopFactory::new_floatArray(length, CHECK);\n+            value = oopFactory::new_floatArray(length, CHECK_(true));\n@@ -1073,1 +1126,1 @@\n-            value = oopFactory::new_doubleArray(length, CHECK);\n+            value = oopFactory::new_doubleArray(length, CHECK_(true));\n@@ -1075,1 +1128,1 @@\n-            value = oopFactory::new_intArray(length, CHECK);\n+            value = oopFactory::new_intArray(length, CHECK_(true));\n@@ -1077,1 +1130,1 @@\n-            value = oopFactory::new_longArray(length, CHECK);\n+            value = oopFactory::new_longArray(length, CHECK_(true));\n@@ -1080,1 +1133,4 @@\n-            Klass* actual_array_klass = parse_klass(CHECK);\n+            Klass* actual_array_klass = parse_klass(CHECK_(true));\n+            \/\/ TODO 8350865 I think we need to handle null-free\/flat arrays here\n+            \/\/ This handling will change the array property argument passed to the\n+            \/\/ factory below\n@@ -1082,1 +1138,1 @@\n-            value = oopFactory::new_objArray(kelem, length, CHECK);\n+            value = oopFactory::new_objArray(kelem, length, CHECK_(true));\n@@ -1087,0 +1143,14 @@\n+        java_mirror->obj_field_put(fd->offset(), value);\n+        return true;\n+      }\n+    } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      Handle value = java_lang_String::create_from_str(string_value, CHECK_(true));\n+      java_mirror->obj_field_put(fd->offset(), value());\n+      return true;\n+    } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {\n+      const char* instance = parse_escaped_string();\n+      oop value = nullptr;\n+      if (instance != nullptr) {\n+        Klass* k = resolve_klass(instance, CHECK_(true));\n+        value = InstanceKlass::cast(k)->allocate_instance(CHECK_(true));\n@@ -1088,0 +1158,76 @@\n+      java_mirror->obj_field_put(fd->offset(), value);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Initialize a class and fill in the value for a static field.\n+  \/\/ This is useful when the compile was dependent on the value of\n+  \/\/ static fields but it's impossible to properly rerun the static\n+  \/\/ initializer.\n+  void process_staticfield(TRAPS) {\n+    InstanceKlass* k = (InstanceKlass *)parse_klass(CHECK);\n+\n+    if (k == nullptr || ReplaySuppressInitializers == 0 ||\n+        (ReplaySuppressInitializers == 2 && k->class_loader() == nullptr)) {\n+        skip_remaining();\n+      return;\n+    }\n+\n+    assert(k->is_initialized(), \"must be\");\n+\n+    const char* field_name = parse_escaped_string();\n+    const char* field_signature = parse_string();\n+    fieldDescriptor fd;\n+    Symbol* name = SymbolTable::new_symbol(field_name);\n+    Symbol* sig = SymbolTable::new_symbol(field_signature);\n+    if (!k->find_local_field(name, sig, &fd) ||\n+        !fd.is_static() ||\n+        fd.has_initial_value()) {\n+      report_error(field_name);\n+      return;\n+    }\n+\n+    oop java_mirror = k->java_mirror();\n+    if (strcmp(field_signature, \"I\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->int_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"B\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->byte_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"C\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->char_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"S\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->short_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"Z\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      int value = atoi(string_value);\n+      java_mirror->bool_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"J\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      jlong value;\n+      if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n+        fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n+        return;\n+      }\n+      java_mirror->long_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"F\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      float value = atof(string_value);\n+      java_mirror->float_field_put(fd.offset(), value);\n+    } else if (strcmp(field_signature, \"D\") == 0) {\n+      const char* string_value = parse_escaped_string();\n+      double value = atof(string_value);\n+      java_mirror->double_field_put(fd.offset(), value);\n+    } else if (fd.is_null_free_inline_type()) {\n+      Klass* kelem = resolve_klass(field_signature, CHECK);\n+      InlineKlass* vk = InlineKlass::cast(kelem);\n+      oop value = vk->allocate_instance(CHECK);\n+      InlineTypeFieldInitializer init_fields(value, this);\n+      vk->do_nonstatic_fields(&init_fields);\n@@ -1090,40 +1236,2 @@\n-      const char* string_value = parse_escaped_string();\n-      if (strcmp(field_signature, \"I\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->int_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"B\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->byte_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"C\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->char_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"S\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->short_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Z\") == 0) {\n-        int value = atoi(string_value);\n-        java_mirror->bool_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"J\") == 0) {\n-        jlong value;\n-        if (sscanf(string_value, JLONG_FORMAT, &value) != 1) {\n-          fprintf(stderr, \"Error parsing long: %s\\n\", string_value);\n-          return;\n-        }\n-        java_mirror->long_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"F\") == 0) {\n-        float value = atof(string_value);\n-        java_mirror->float_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"D\") == 0) {\n-        double value = atof(string_value);\n-        java_mirror->double_field_put(fd.offset(), value);\n-      } else if (strcmp(field_signature, \"Ljava\/lang\/String;\") == 0) {\n-        Handle value = java_lang_String::create_from_str(string_value, CHECK);\n-        java_mirror->obj_field_put(fd.offset(), value());\n-      } else if (field_signature[0] == JVM_SIGNATURE_CLASS) {\n-        oop value = nullptr;\n-        if (string_value != nullptr) {\n-          Klass* k = resolve_klass(string_value, CHECK);\n-          value = InstanceKlass::cast(k)->allocate_instance(CHECK);\n-        }\n-        java_mirror->obj_field_put(fd.offset(), value);\n-      } else {\n+      bool res = process_staticfield_reference(field_signature, java_mirror, &fd, CHECK);\n+      if (!res)  {\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":192,"deletions":84,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+\n@@ -53,0 +54,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -87,0 +89,1 @@\n+#include \"utilities\/stringUtils.hpp\"\n@@ -159,0 +162,2 @@\n+#define CONSTANT_CLASS_DESCRIPTORS        70\n+\n@@ -197,1 +202,1 @@\n-      case JVM_CONSTANT_Class : {\n+      case JVM_CONSTANT_Class: {\n@@ -501,0 +506,3 @@\n+\n+        Symbol* const name = cp->symbol_at(class_index);\n+        const unsigned int name_len = name->utf8_length();\n@@ -710,1 +718,1 @@\n-            } else if (!Signature::is_void_method(signature)) { \/\/ must have void signature.\n+            } else if (!Signature::is_void_method(signature)) {  \/\/ must have void signature.\n@@ -730,2 +738,3 @@\n-            if (ref_kind == JVM_REF_newInvokeSpecial) {\n-              if (name != vmSymbols::object_initializer_name()) {\n+\n+            if (name != vmSymbols::object_initializer_name()) { \/\/ !<init>\n+              if (ref_kind == JVM_REF_newInvokeSpecial) {\n@@ -737,2 +746,10 @@\n-            } else {\n-              if (name == vmSymbols::object_initializer_name()) {\n+            } else { \/\/ <init>\n+              \/\/ The allowed invocation mode of <init> depends on its signature.\n+              \/\/ This test corresponds to verify_invoke_instructions in the verifier.\n+              const int signature_ref_index =\n+                cp->signature_ref_index_at(name_and_type_ref_index);\n+              const Symbol* const signature = cp->symbol_at(signature_ref_index);\n+              if (signature->is_void_method_signature()\n+                  && ref_kind == JVM_REF_newInvokeSpecial) {\n+                \/\/ OK, could be a constructor call\n+              } else {\n@@ -790,4 +807,13 @@\n-\/\/ Side-effects: populates the _local_interfaces field\n-void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,\n-                                       const int itfs_len,\n-                                       ConstantPool* const cp,\n+static void check_identity_and_value_modifiers(ClassFileParser* current, const InstanceKlass* super_type, TRAPS) {\n+  assert(super_type != nullptr,\"Method doesn't support null super type\");\n+  if (super_type->access_flags().is_identity_class() && !current->access_flags().is_identity_class()\n+      && super_type->name() != vmSymbols::java_lang_Object()) {\n+      THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                err_msg(\"Value type %s has an identity type as supertype\",\n+                current->class_name()->as_klass_external_name()));\n+  }\n+}\n+\n+void ClassFileParser::parse_interfaces(const ClassFileStream* stream,\n+                                       int itfs_len,\n+                                       ConstantPool* cp,\n@@ -795,0 +821,6 @@\n+                                       \/\/ FIXME: lots of these functions\n+                                       \/\/ declare their parameters as const,\n+                                       \/\/ which adds only noise to the code.\n+                                       \/\/ Remove the spurious const modifiers.\n+                                       \/\/ Many are of the form \"const int x\"\n+                                       \/\/ or \"T* const x\".\n@@ -802,0 +834,1 @@\n+\n@@ -804,3 +837,2 @@\n-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n-\n-    int index;\n+    _local_interface_indexes = new GrowableArray<u2>(itfs_len);\n+    int index = 0;\n@@ -809,1 +841,0 @@\n-      Klass* interf;\n@@ -814,29 +845,1 @@\n-      if (cp->tag_at(interface_index).is_klass()) {\n-        interf = cp->resolved_klass_at(interface_index);\n-      } else {\n-        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n-\n-        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n-        \/\/ But need to make sure it's not an array type.\n-        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n-                           \"Bad interface name in class file %s\", CHECK);\n-\n-        \/\/ Call resolve on the interface class name with class circularity checking\n-        interf = SystemDictionary::resolve_super_or_fail(_class_name,\n-                                                         unresolved_klass,\n-                                                         Handle(THREAD, _loader_data->class_loader()),\n-                                                         false, CHECK);\n-      }\n-\n-      if (!interf->is_interface()) {\n-        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n-                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n-                          _class_name->as_klass_external_name(),\n-                          interf->external_name(),\n-                          interf->class_in_module_of_loader()));\n-      }\n-\n-      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n-        *has_nonstatic_concrete_methods = true;\n-      }\n-      _local_interfaces->at_put(index, InstanceKlass::cast(interf));\n+      _local_interface_indexes->at_put_grow(index, interface_index);\n@@ -854,2 +857,1 @@\n-      const InstanceKlass* const k = _local_interfaces->at(index);\n-      Symbol* interface_name = k->name();\n+      Symbol* interface_name = cp->klass_name_at(_local_interface_indexes->at(index));\n@@ -942,0 +944,2 @@\n+    _jdk_internal_LooselyConsistentValue,\n+    _jdk_internal_NullRestricted,\n@@ -1368,1 +1372,1 @@\n-                                   bool is_interface,\n+                                   AccessFlags class_access_flags,\n@@ -1381,0 +1385,1 @@\n+  bool is_inline_type = !class_access_flags.is_identity_class() && !class_access_flags.is_abstract();\n@@ -1388,1 +1393,5 @@\n-  const int total_fields = length + num_injected;\n+\n+  \/\/ two more slots are required for inline classes:\n+  \/\/ one for the static field with a reference to the pre-allocated default value\n+  \/\/ one for the field the JVM injects when detecting an empty inline class\n+  const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);\n@@ -1394,0 +1403,1 @@\n+  int instance_fields_count = 0;\n@@ -1399,0 +1409,7 @@\n+    jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;\n+    if (!supports_inline_types()) {\n+      recognized_modifiers &= ~JVM_ACC_STRICT;\n+    }\n+\n+    const jint flags = cfs->get_u2_fast() & recognized_modifiers;\n+    verify_legal_field_modifiers(flags, class_access_flags, CHECK);\n@@ -1400,2 +1417,0 @@\n-    const jint flags = cfs->get_u2_fast() & JVM_RECOGNIZED_FIELD_MODIFIERS;\n-    verify_legal_field_modifiers(flags, is_interface, CHECK);\n@@ -1418,0 +1433,1 @@\n+    if (!access_flags.is_static()) instance_fields_count++;\n@@ -1425,0 +1441,2 @@\n+    bool is_null_restricted = false;\n+\n@@ -1444,0 +1462,18 @@\n+        if (parsed_annotations.has_annotation(AnnotationCollector::_jdk_internal_NullRestricted)) {\n+          if (!Signature::has_envelope(sig)) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s with signature %s (primitive types can never be null)\",\n+              class_name()->as_C_string(), name->as_C_string(), sig->as_C_string());\n+          }\n+          const bool is_strict = (flags & JVM_ACC_STRICT) != 0;\n+          if (!is_strict) {\n+            Exceptions::fthrow(\n+              THREAD_AND_LOCATION,\n+              vmSymbols::java_lang_ClassFormatError(),\n+              \"Illegal use of @jdk.internal.vm.annotation.NullRestricted annotation on field %s.%s which doesn't have the @jdk.internal.vm.annotation.Strict annotation\",\n+              class_name()->as_C_string(), name->as_C_string());\n+          }\n+          is_null_restricted = true;\n+        }\n@@ -1466,0 +1502,4 @@\n+    if (is_null_restricted) {\n+      fieldFlags.update_null_free_inline_type(true);\n+    }\n+\n@@ -1482,0 +1522,3 @@\n+    if (access_flags.is_strict() && access_flags.is_static()) {\n+      _has_strict_static_fields = true;\n+    }\n@@ -1486,1 +1529,0 @@\n-  int index = length;\n@@ -1514,3 +1556,2 @@\n-      fi.set_index(index);\n-      _temp_field_info->append(fi);\n-      index++;\n+      int idx = _temp_field_info->append(fi);\n+      _temp_field_info->adr_at(idx)->set_index(idx);\n@@ -1520,1 +1561,17 @@\n-  assert(_temp_field_info->length() == index, \"Must be\");\n+  if (is_inline_type) {\n+    \/\/ Inject static \".null_reset\" field. This is an all-zero value with its null-channel set to zero.\n+    \/\/ IT should never be seen by user code, it is used when writing \"null\" to a nullable flat field\n+    \/\/ The all-zero value ensure that any embedded oop will be set to null, to avoid keeping dead objects\n+    \/\/ alive.\n+    FieldInfo::FieldFlags fflags2(0);\n+    fflags2.update_injected(true);\n+    AccessFlags aflags2(JVM_ACC_STATIC);\n+    FieldInfo fi2(aflags2,\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(null_reset_value_name)),\n+                 (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(object_signature)),\n+                 0,\n+                 fflags2);\n+    int idx2 = _temp_field_info->append(fi2);\n+    _temp_field_info->adr_at(idx2)->set_index(idx2);\n+    _static_oop_count++;\n+  }\n@@ -1900,0 +1957,8 @@\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_LooselyConsistentValue_signature): {\n+      if (_location != _in_class)   break; \/\/ only allow for classes\n+      return _jdk_internal_LooselyConsistentValue;\n+    }\n+    case VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_NullRestricted_signature): {\n+      if (_location != _in_field)   break; \/\/ only allow for fields\n+      return _jdk_internal_NullRestricted;\n+    }\n@@ -2136,0 +2201,2 @@\n+                                      bool is_value_class,\n+                                      bool is_abstract_class,\n@@ -2177,1 +2244,1 @@\n-    verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);\n+    verify_legal_method_modifiers(flags, access_flags() , name, CHECK_NULL);\n@@ -2185,0 +2252,9 @@\n+  if (EnableValhalla) {\n+    if (((flags & JVM_ACC_SYNCHRONIZED) == JVM_ACC_SYNCHRONIZED)\n+        && ((flags & JVM_ACC_STATIC) == 0 )\n+        && !_access_flags.is_identity_class()) {\n+      classfile_parse_error(\"Invalid synchronized method in non-identity class %s\", THREAD);\n+        return nullptr;\n+    }\n+  }\n+\n@@ -2719,0 +2795,2 @@\n+                                    bool is_value_class,\n+                                    bool is_abstract_type,\n@@ -2743,0 +2821,2 @@\n+                                    is_value_class,\n+                                    is_abstract_type,\n@@ -3008,0 +3088,1 @@\n+\n@@ -3016,0 +3097,1 @@\n+\n@@ -3020,0 +3102,9 @@\n+\n+    if (!supports_inline_types()) {\n+      const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+      const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+      if (!is_module && !is_interface) {\n+        flags |= JVM_ACC_IDENTITY;\n+      }\n+    }\n+\n@@ -3124,0 +3215,43 @@\n+u2 ClassFileParser::parse_classfile_loadable_descriptors_attribute(const ClassFileStream* const cfs,\n+                                                                   const u1* const loadable_descriptors_attribute_start,\n+                                                                   TRAPS) {\n+  const u1* const current_mark = cfs->current();\n+  u2 length = 0;\n+  if (loadable_descriptors_attribute_start != nullptr) {\n+    cfs->set_current(loadable_descriptors_attribute_start);\n+    cfs->guarantee_more(2, CHECK_0);  \/\/ length\n+    length = cfs->get_u2_fast();\n+  }\n+  const int size = length;\n+  Array<u2>* const loadable_descriptors = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  _loadable_descriptors = loadable_descriptors;\n+  if (length > 0) {\n+    int index = 0;\n+    cfs->guarantee_more(2 * length, CHECK_0);\n+    for (int n = 0; n < length; n++) {\n+      const u2 descriptor_index = cfs->get_u2_fast();\n+      guarantee_property(\n+        valid_symbol_at(descriptor_index),\n+        \"LoadableDescriptors descriptor_index %u has bad constant type in class file %s\",\n+        descriptor_index, CHECK_0);\n+      Symbol* descriptor = _cp->symbol_at(descriptor_index);\n+      bool valid = legal_field_signature(descriptor, CHECK_0);\n+      if(!valid) {\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_ClassFormatError(),\n+          \"Descriptor from LoadableDescriptors attribute at index \\\"%d\\\" in class %s has illegal signature \\\"%s\\\"\",\n+          descriptor_index, _class_name->as_C_string(), descriptor->as_C_string());\n+        return 0;\n+      }\n+      loadable_descriptors->at_put(index++, descriptor_index);\n+    }\n+    assert(index == size, \"wrong size\");\n+  }\n+\n+  \/\/ Restore buffer's current position.\n+  cfs->set_current(current_mark);\n+\n+  return length;\n+}\n+\n@@ -3389,0 +3523,2 @@\n+  \/\/ Set _loadable_descriptors attribute to default sentinel\n+  _loadable_descriptors = Universe::the_empty_short_array();\n@@ -3395,0 +3531,1 @@\n+  bool parsed_loadable_descriptors_attribute = false;\n@@ -3416,0 +3553,2 @@\n+  const u1* loadable_descriptors_attribute_start = nullptr;\n+  u4  loadable_descriptors_attribute_length = 0;\n@@ -3631,0 +3770,9 @@\n+            if (EnableValhalla && tag == vmSymbols::tag_loadable_descriptors()) {\n+              if (parsed_loadable_descriptors_attribute) {\n+                classfile_parse_error(\"Multiple LoadableDescriptors attributes in class file %s\", CHECK);\n+                return;\n+              }\n+              parsed_loadable_descriptors_attribute = true;\n+              loadable_descriptors_attribute_start = cfs->current();\n+              loadable_descriptors_attribute_length = attribute_length;\n+            }\n@@ -3707,0 +3855,12 @@\n+  if (parsed_loadable_descriptors_attribute) {\n+    const u2 num_classes = parse_classfile_loadable_descriptors_attribute(\n+                            cfs,\n+                            loadable_descriptors_attribute_start,\n+                            CHECK);\n+    if (_need_verify) {\n+      guarantee_property(\n+        loadable_descriptors_attribute_length == sizeof(num_classes) + sizeof(u2) * num_classes,\n+        \"Wrong LoadableDescriptors attribute length in class file %s\", CHECK);\n+    }\n+  }\n+\n@@ -3773,0 +3933,1 @@\n+  this_klass->set_loadable_descriptors(_loadable_descriptors);\n@@ -3776,0 +3937,1 @@\n+  this_klass->set_inline_layout_info_array(_inline_layout_info_array);\n@@ -3815,3 +3977,2 @@\n-                       \"Invalid superclass index %u in class file %s\",\n-                       super_class_index,\n-                       CHECK_NULL);\n+                   \"Invalid superclass index 0 in class file %s\",\n+                   CHECK_NULL);\n@@ -3825,1 +3986,0 @@\n-    bool is_array = false;\n@@ -3828,4 +3988,0 @@\n-      if (need_verify)\n-        is_array = super_klass->is_array_klass();\n-    } else if (need_verify) {\n-      is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -3834,0 +3990,1 @@\n+      bool is_array = (cp->klass_name_at(super_class_index)->char_at(0) == JVM_SIGNATURE_ARRAY);\n@@ -4016,0 +4173,6 @@\n+bool ClassFileParser::supports_inline_types() const {\n+  \/\/ Inline types are only supported by class file version 70.65535 and later\n+  return _major_version > JAVA_26_VERSION ||\n+         (_major_version == JAVA_26_VERSION && _minor_version == JAVA_PREVIEW_MINOR_VERSION);\n+}\n+\n@@ -4059,3 +4222,4 @@\n-  } else if (max_transitive_size == local_size) {\n-    \/\/ only local interfaces added, share local interface array\n-    return local_ifs;\n+    \/\/ The three lines below are commented to work around bug JDK-8245487\n+\/\/  } else if (max_transitive_size == local_size) {\n+\/\/    \/\/ only local interfaces added, share local interface array\n+\/\/    return local_ifs;\n@@ -4082,0 +4246,1 @@\n+\n@@ -4112,0 +4277,10 @@\n+    \/\/ The JVMS says that super classes for value types must not have the ACC_IDENTITY\n+    \/\/ flag set. But, java.lang.Object must still be allowed to be a direct super class\n+    \/\/ for a value classes.  So, it is treated as a special case for now.\n+    if (!this_klass->access_flags().is_identity_class() &&\n+        super->name() != vmSymbols::java_lang_Object() &&\n+        super->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super, THREAD);\n+      return;\n+    }\n+\n@@ -4303,1 +4478,1 @@\n-  const bool is_super      = (flags & JVM_ACC_SUPER)      != 0;\n+  const bool is_identity   = (flags & JVM_ACC_IDENTITY)   != 0;\n@@ -4307,0 +4482,2 @@\n+  const bool valid_value_class = is_identity || is_interface ||\n+                                 (supports_inline_types() && (!is_identity && (is_abstract || is_final)));\n@@ -4310,2 +4487,3 @@\n-      (is_interface && major_gte_1_5 && (is_super || is_enum)) ||\n-      (!is_interface && major_gte_1_5 && is_annotation)) {\n+      (is_interface && major_gte_1_5 && (is_identity || is_enum)) ||   \/\/  ACC_SUPER (now ACC_IDENTITY) was illegal for interfaces\n+      (!is_interface && major_gte_1_5 && is_annotation) ||\n+      (!valid_value_class)) {\n@@ -4313,1 +4491,4 @@\n-    \/\/ Names are all known to be < 64k so we know this formatted message is not excessively large.\n+    const char* class_note = \"\";\n+    if (!valid_value_class) {\n+      class_note = \" (a value class must be final or else abstract)\";\n+    }\n@@ -4317,2 +4498,2 @@\n-      \"Illegal class modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags\n+      \"Illegal class modifiers in class %s%s: 0x%X\",\n+      _class_name->as_C_string(), class_note, flags\n@@ -4388,2 +4569,2 @@\n-void ClassFileParser::verify_legal_field_modifiers(jint flags,\n-                                                   bool is_interface,\n+void ClassFileParser:: verify_legal_field_modifiers(jint flags,\n+                                                   AccessFlags class_access_flags,\n@@ -4401,0 +4582,1 @@\n+  const bool is_strict    = (flags & JVM_ACC_STRICT)    != 0;\n@@ -4403,1 +4585,2 @@\n-  bool is_illegal = false;\n+  const bool is_interface = class_access_flags.is_interface();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n@@ -4405,9 +4588,30 @@\n-  if (is_interface) {\n-    if (!is_public || !is_static || !is_final || is_private ||\n-        is_protected || is_volatile || is_transient ||\n-        (major_gte_1_5 && is_enum)) {\n-      is_illegal = true;\n-    }\n-  } else { \/\/ not interface\n-    if (has_illegal_visibility(flags) || (is_final && is_volatile)) {\n-      is_illegal = true;\n+  bool is_illegal = false;\n+  const char* error_msg = \"\";\n+\n+  \/\/ There is some overlap in the checks that apply, for example interface fields\n+  \/\/ must be static, static fields can't be strict, and therefore interfaces can't\n+  \/\/ have strict fields. So we don't have to check every possible invalid combination\n+  \/\/ individually as long as all are covered. Once we have found an illegal combination\n+  \/\/ we can stop checking.\n+\n+  if (!is_illegal) {\n+    if (is_interface) {\n+      if (!is_public || !is_static || !is_final || is_private ||\n+          is_protected || is_volatile || is_transient ||\n+          (major_gte_1_5 && is_enum)) {\n+        is_illegal = true;\n+        error_msg = \"interface fields must be public, static and final, and may be synthetic\";\n+      }\n+    } else { \/\/ not interface\n+      if (has_illegal_visibility(flags)) {\n+        is_illegal = true;\n+        error_msg = \"invalid visibility flags for class field\";\n+      } else if (is_final && is_volatile) {\n+        is_illegal = true;\n+        error_msg = \"fields cannot be final and volatile\";\n+      } else if (supports_inline_types()) {\n+        if (!is_identity_class && !is_static && (!is_strict || !is_final)) {\n+          is_illegal = true;\n+          error_msg = \"value class fields must be either non-static final and strict, or static\";\n+        }\n+      }\n@@ -4423,2 +4627,2 @@\n-      \"Illegal field modifiers in class %s: 0x%X\",\n-      _class_name->as_C_string(), flags);\n+      \"Illegal field modifiers (%s) in class %s: 0x%X\",\n+      error_msg, _class_name->as_C_string(), flags);\n@@ -4430,1 +4634,1 @@\n-                                                    bool is_interface,\n+                                                    AccessFlags class_access_flags,\n@@ -4449,0 +4653,4 @@\n+  \/\/ LW401 CR required: removal of value factories support\n+  const bool is_interface    = class_access_flags.is_interface();\n+  const bool is_identity_class = class_access_flags.is_identity_class();\n+  const bool is_abstract_class = class_access_flags.is_abstract();\n@@ -4452,0 +4660,1 @@\n+  const char* class_note = \"\";\n@@ -4491,4 +4700,9 @@\n-        if (is_abstract) {\n-          if ((is_final || is_native || is_private || is_static ||\n-              (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n-            is_illegal = true;\n+        if (!is_identity_class && is_synchronized && !is_static) {\n+          is_illegal = true;\n+          class_note = \" (not an identity class)\";\n+        } else {\n+          if (is_abstract) {\n+            if ((is_final || is_native || is_private || is_static ||\n+                (major_gte_1_5 && (is_synchronized || (!major_gte_17 && is_strict))))) {\n+              is_illegal = true;\n+            }\n@@ -4507,2 +4721,3 @@\n-      \"Method %s in class %s has illegal modifiers: 0x%X\",\n-      name->as_C_string(), _class_name->as_C_string(), flags);\n+      \"Method %s in class %s%s has illegal modifiers: 0x%X\",\n+      name->as_C_string(), _class_name->as_C_string(),\n+      class_note, flags);\n@@ -4566,0 +4781,9 @@\n+bool ClassFileParser::is_class_in_loadable_descriptors_attribute(Symbol *klass) {\n+  if (_loadable_descriptors == nullptr) return false;\n+  for (int i = 0; i < _loadable_descriptors->length(); i++) {\n+        Symbol* class_name = _cp->symbol_at(_loadable_descriptors->at(i));\n+        if (class_name == klass) return true;\n+  }\n+  return false;\n+}\n+\n@@ -4667,1 +4891,2 @@\n-    case JVM_SIGNATURE_CLASS: {\n+    case JVM_SIGNATURE_CLASS:\n+    {\n@@ -4678,1 +4903,1 @@\n-        \/\/ Skip leading 'L' and ignore first appearance of ';'\n+        \/\/ Skip leading 'L' or 'Q' and ignore first appearance of ';'\n@@ -4734,0 +4959,4 @@\n+    } else if ((_major_version >= CONSTANT_CLASS_DESCRIPTORS || _class_name->starts_with(\"jdk\/internal\/reflect\/\"))\n+                   && bytes[length - 1] == ';' ) {\n+      \/\/ Support for L...; descriptors\n+      legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);\n@@ -4801,1 +5030,2 @@\n-      if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {\n+      if (name == vmSymbols::object_initializer_name() ||\n+          name == vmSymbols::class_initializer_name()) {\n@@ -4828,0 +5058,10 @@\n+bool ClassFileParser::legal_field_signature(const Symbol* signature, TRAPS) const {\n+  const char* const bytes = (const char*)signature->bytes();\n+  const unsigned int length = signature->utf8_length();\n+  const char* const p = skip_over_field_signature(bytes, false, length, CHECK_false);\n+\n+  if (p == nullptr || (p - bytes) != (int)length) {\n+    return false;\n+  }\n+  return true;\n+}\n@@ -4863,3 +5103,3 @@\n-      name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n-      sig_length > 0 &&\n-      signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n+    name->char_at(0) == JVM_SIGNATURE_SPECIAL &&\n+    sig_length > 0 &&\n+    signature->char_at(sig_length - 1) != JVM_SIGNATURE_VOID) {\n@@ -4916,2 +5156,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->_static_field_size;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->_static_field_size;\n@@ -4921,2 +5161,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->oop_map_blocks->_nonstatic_oop_map_count;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->oop_map_blocks->_nonstatic_oop_map_count;\n@@ -4926,2 +5166,2 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  return _field_info->_instance_size;\n+  assert(_layout_info != nullptr, \"invariant\");\n+  return _layout_info->_instance_size;\n@@ -5042,1 +5282,0 @@\n-\n@@ -5065,3 +5304,3 @@\n-  assert(_field_info != nullptr, \"invariant\");\n-  assert(ik->static_field_size() == _field_info->_static_field_size, \"sanity\");\n-  assert(ik->nonstatic_oop_map_count() == _field_info->oop_map_blocks->_nonstatic_oop_map_count,\n+  assert(_layout_info != nullptr, \"invariant\");\n+  assert(ik->static_field_size() == _layout_info->_static_field_size, \"sanity\");\n+  assert(ik->nonstatic_oop_map_count() == _layout_info->oop_map_blocks->_nonstatic_oop_map_count,\n@@ -5071,1 +5310,1 @@\n-  assert(ik->size_helper() == _field_info->_instance_size, \"sanity\");\n+  assert(ik->size_helper() == _layout_info->_instance_size, \"sanity\");\n@@ -5077,2 +5316,12 @@\n-  ik->set_nonstatic_field_size(_field_info->_nonstatic_field_size);\n-  ik->set_has_nonstatic_fields(_field_info->_has_nonstatic_fields);\n+  ik->set_nonstatic_field_size(_layout_info->_nonstatic_field_size);\n+  ik->set_has_nonstatic_fields(_layout_info->_has_nonstatic_fields);\n+  ik->set_has_strict_static_fields(_has_strict_static_fields);\n+\n+  if (_layout_info->_is_naturally_atomic) {\n+    ik->set_is_naturally_atomic();\n+  }\n+\n+  if (_layout_info->_must_be_atomic) {\n+    ik->set_must_be_atomic();\n+  }\n+\n@@ -5084,0 +5333,3 @@\n+  if (ik->is_inline_klass()) {\n+    InlineKlass::cast(ik)->init_fixed_block();\n+  }\n@@ -5098,0 +5350,1 @@\n+  assert(nullptr == _loadable_descriptors, \"invariant\");\n@@ -5101,0 +5354,1 @@\n+  assert(nullptr == _inline_layout_info_array, \"invariant\");\n@@ -5217,1 +5471,1 @@\n-  OopMapBlocksBuilder* oop_map_blocks = _field_info->oop_map_blocks;\n+  OopMapBlocksBuilder* oop_map_blocks = _layout_info->oop_map_blocks;\n@@ -5278,0 +5532,15 @@\n+  if (is_inline_type()) {\n+    InlineKlass* vk = InlineKlass::cast(ik);\n+    vk->set_payload_alignment(_layout_info->_payload_alignment);\n+    vk->set_payload_offset(_layout_info->_payload_offset);\n+    vk->set_payload_size_in_bytes(_layout_info->_payload_size_in_bytes);\n+    vk->set_non_atomic_size_in_bytes(_layout_info->_non_atomic_size_in_bytes);\n+    vk->set_non_atomic_alignment(_layout_info->_non_atomic_alignment);\n+    vk->set_atomic_size_in_bytes(_layout_info->_atomic_layout_size_in_bytes);\n+    vk->set_nullable_size_in_bytes(_layout_info->_nullable_layout_size_in_bytes);\n+    vk->set_null_marker_offset(_layout_info->_null_marker_offset);\n+    vk->set_null_reset_value_offset(_layout_info->_null_reset_value_offset);\n+    if (_layout_info->_is_empty_inline_klass) vk->set_is_empty_inline_type();\n+    vk->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -5360,0 +5629,1 @@\n+  _loadable_descriptors(nullptr),\n@@ -5362,0 +5632,1 @@\n+  _local_interface_indexes(nullptr),\n@@ -5371,1 +5642,2 @@\n-  _field_info(nullptr),\n+  _layout_info(nullptr),\n+  _inline_layout_info_array(nullptr),\n@@ -5400,0 +5672,5 @@\n+  _has_strict_static_fields(false),\n+  _has_inline_type_fields(false),\n+  _is_naturally_atomic(false),\n+  _must_be_atomic(true),\n+  _has_loosely_consistent_annotation(false),\n@@ -5437,0 +5714,1 @@\n+  _loadable_descriptors = nullptr;\n@@ -5441,0 +5719,1 @@\n+  _inline_layout_info_array = nullptr;\n@@ -5460,0 +5739,4 @@\n+  if (_inline_layout_info_array != nullptr) {\n+    MetadataFactory::free_array<InlineLayoutInfo>(_loader_data, _inline_layout_info_array);\n+  }\n+\n@@ -5482,0 +5765,4 @@\n+  if (_loadable_descriptors != nullptr && _loadable_descriptors != Universe::the_empty_short_array()) {\n+    MetadataFactory::free_array<u2>(_loader_data, _loadable_descriptors);\n+  }\n+\n@@ -5580,0 +5867,9 @@\n+  \/\/ Fixing ACC_SUPER\/ACC_IDENTITY for old class files\n+  if (!supports_inline_types()) {\n+    const bool is_module = (flags & JVM_ACC_MODULE) != 0;\n+    const bool is_interface = (flags & JVM_ACC_INTERFACE) != 0;\n+    if (!is_module && !is_interface) {\n+      flags |= JVM_ACC_IDENTITY;\n+    }\n+  }\n+\n@@ -5683,2 +5979,0 @@\n-  assert(_local_interfaces != nullptr, \"invariant\");\n-\n@@ -5687,1 +5981,1 @@\n-               _access_flags.is_interface(),\n+               _access_flags,\n@@ -5697,1 +5991,3 @@\n-                _access_flags.is_interface(),\n+                is_interface(),\n+                !is_identity_class(),\n+                is_abstract_class(),\n@@ -5777,2 +6073,2 @@\n-                       \"java.lang.Object cannot implement an interface in class file %s\",\n-                       CHECK);\n+        \"java.lang.Object cannot implement an interface in class file %s\",\n+        CHECK);\n@@ -5783,1 +6079,1 @@\n-    if (_access_flags.is_interface()) {\n+    if (is_interface()) {\n@@ -5804,0 +6100,14 @@\n+    if (_super_klass->is_interface()) {\n+      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (_super_klass->is_final()) {\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", _super_klass, THREAD);\n+      return;\n+    }\n+\n+    if (EnableValhalla) {\n+      check_identity_and_value_modifiers(this, _super_klass, CHECK);\n+    }\n+\n@@ -5807,0 +6117,1 @@\n+  }\n@@ -5808,3 +6119,24 @@\n-    if (_super_klass->is_interface()) {\n-      classfile_icce_error(\"class %s has interface %s as super class\", _super_klass, THREAD);\n-      return;\n+  if (_parsed_annotations->has_annotation(AnnotationCollector::_jdk_internal_LooselyConsistentValue) && _access_flags.is_identity_class()) {\n+    THROW_MSG(vmSymbols::java_lang_ClassFormatError(),\n+          err_msg(\"class %s cannot have annotation jdk.internal.vm.annotation.LooselyConsistentValue, because it is not a value class\",\n+                  _class_name->as_klass_external_name()));\n+  }\n+\n+  \/\/ Determining is the class allows tearing or not (default is not)\n+  if (EnableValhalla && !_access_flags.is_identity_class()) {\n+    if (_parsed_annotations->has_annotation(ClassAnnotationCollector::_jdk_internal_LooselyConsistentValue)\n+        && (_super_klass == vmClasses::Object_klass() || !_super_klass->must_be_atomic())) {\n+      \/\/ Conditions above are not sufficient to determine atomicity requirements,\n+      \/\/ the presence of fields with atomic requirements could force the current class to have atomicy requirements too\n+      \/\/ Marking as not needing atomicity for now, can be updated when computing the fields layout\n+      \/\/ The InstanceKlass must be filled with the value from the FieldLayoutInfo returned by\n+      \/\/ the FieldLayoutBuilder, not with this _must_be_atomic field.\n+      _must_be_atomic = false;\n+    }\n+    \/\/ Apply VM options override\n+    if (*ForceNonTearable != '\\0') {\n+      \/\/ Allow a command line switch to force the same atomicity property:\n+      const char* class_name_str = _class_name->as_C_string();\n+      if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {\n+        _must_be_atomic = true;\n+      }\n@@ -5814,0 +6146,46 @@\n+  int itfs_len = _local_interface_indexes == nullptr ? 0 : _local_interface_indexes->length();\n+  _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n+  if (_local_interface_indexes != nullptr) {\n+    for (int i = 0; i < _local_interface_indexes->length(); i++) {\n+      u2 interface_index = _local_interface_indexes->at(i);\n+      Klass* interf;\n+      if (cp->tag_at(interface_index).is_klass()) {\n+        interf = cp->resolved_klass_at(interface_index);\n+      } else {\n+        Symbol* const unresolved_klass  = cp->klass_name_at(interface_index);\n+\n+        \/\/ Don't need to check legal name because it's checked when parsing constant pool.\n+        \/\/ But need to make sure it's not an array type.\n+        guarantee_property(unresolved_klass->char_at(0) != JVM_SIGNATURE_ARRAY,\n+                            \"Bad interface name in class file %s\", CHECK);\n+\n+        \/\/ Call resolve on the interface class name with class circularity checking\n+        interf = SystemDictionary::resolve_super_or_fail(\n+                                                  _class_name,\n+                                                  unresolved_klass,\n+                                                  Handle(THREAD, _loader_data->class_loader()),\n+                                                  false,\n+                                                  CHECK);\n+      }\n+\n+      if (!interf->is_interface()) {\n+        THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+                  err_msg(\"class %s can not implement %s, because it is not an interface (%s)\",\n+                          _class_name->as_klass_external_name(),\n+                          interf->external_name(),\n+                          interf->class_in_module_of_loader()));\n+      }\n+\n+      if (EnableValhalla) {\n+        \/\/ Check modifiers and set carries_identity_modifier\/carries_value_modifier flags\n+        check_identity_and_value_modifiers(this, InstanceKlass::cast(interf), CHECK);\n+      }\n+\n+      if (InstanceKlass::cast(interf)->has_nonstatic_concrete_methods()) {\n+        _has_nonstatic_concrete_methods = true;\n+      }\n+      _local_interfaces->at_put(i, InstanceKlass::cast(interf));\n+    }\n+  }\n+  assert(_local_interfaces != nullptr, \"invariant\");\n+\n@@ -5841,1 +6219,1 @@\n-  _itable_size = _access_flags.is_interface() ? 0 :\n+  _itable_size = is_interface() ? 0 :\n@@ -5846,3 +6224,92 @@\n-  _field_info = new FieldLayoutInfo();\n-  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n-                        _parsed_annotations->is_contended(), _field_info);\n+  if (EnableValhalla) {\n+    _inline_layout_info_array = MetadataFactory::new_array<InlineLayoutInfo>(_loader_data,\n+                                                   java_fields_count(),\n+                                                   CHECK);\n+    for (GrowableArrayIterator<FieldInfo> it = _temp_field_info->begin(); it != _temp_field_info->end(); ++it) {\n+      FieldInfo fieldinfo = *it;\n+      if (fieldinfo.access_flags().is_static()) continue;  \/\/ Only non-static fields are processed at load time\n+      Symbol* sig = fieldinfo.signature(cp);\n+      if (fieldinfo.field_flags().is_null_free_inline_type()) {\n+        \/\/ Pre-load classes of null-free fields that are candidate for flattening\n+        TempNewSymbol s = Signature::strip_envelope(sig);\n+        if (s == _class_name) {\n+          THROW_MSG(vmSymbols::java_lang_ClassCircularityError(),\n+                    err_msg(\"Class %s cannot have a null-free non-static field of its own type\", _class_name->as_C_string()));\n+        }\n+        log_info(class, preload)(\"Preloading of class %s during loading of class %s. \"\n+                                  \"Cause: a null-free non-static field is declared with this type\",\n+                                  s->as_C_string(), _class_name->as_C_string());\n+        InstanceKlass* klass = SystemDictionary::resolve_with_circularity_detection(_class_name, s,\n+                                                                                    Handle(THREAD,\n+                                                                                    _loader_data->class_loader()),\n+                                                                                    false, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          log_warning(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                      \"(cause: null-free non-static field) failed: %s\",\n+                                      s->as_C_string(), _class_name->as_C_string(),\n+                                      PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          return; \/\/ Exception is still pending\n+        }\n+        assert(klass != nullptr, \"Sanity check\");\n+        InstanceKlass::check_can_be_annotated_with_NullRestricted(klass, _class_name, CHECK);\n+        InlineKlass* vk = InlineKlass::cast(klass);\n+        _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(vk);\n+        log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                 \"(cause: null-free non-static field) succeeded\",\n+                                 s->as_C_string(), _class_name->as_C_string());\n+      } else if (Signature::has_envelope(sig) && PreloadClasses) {\n+        \/\/ Preloading classes for nullable fields that are listed in the LoadableDescriptors attribute\n+        \/\/ Those classes would be required later for the flattening of nullable inline type fields\n+        TempNewSymbol name = Signature::strip_envelope(sig);\n+        if (name != _class_name && is_class_in_loadable_descriptors_attribute(sig)) {\n+          log_info(class, preload)(\"Preloading of class %s during loading of class %s. \"\n+                                   \"Cause: field type in LoadableDescriptors attribute\",\n+                                   name->as_C_string(), _class_name->as_C_string());\n+          oop loader = loader_data()->class_loader();\n+          Klass* klass = SystemDictionary::resolve_super_or_fail(_class_name, name,\n+                                                                 Handle(THREAD, loader),\n+                                                                 false, THREAD);\n+          if (klass != nullptr) {\n+            if (klass->is_inline_klass()) {\n+              _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+              log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                       \"(cause: field type in LoadableDescriptors attribute) succeeded\",\n+                                       name->as_C_string(), _class_name->as_C_string());\n+            } else {\n+              \/\/ Non value class are allowed by the current spec, but it could be an indication of an issue so let's log a warning\n+              log_warning(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                          \"(cause: field type in LoadableDescriptors attribute) but loaded class is not a value class\",\n+                                          name->as_C_string(), _class_name->as_C_string());\n+            }\n+          } else {\n+            log_warning(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                        \"(cause: field type in LoadableDescriptors attribute) failed : %s\",\n+                                        name->as_C_string(), _class_name->as_C_string(),\n+                                        PENDING_EXCEPTION->klass()->name()->as_C_string());\n+          }\n+          \/\/ Loads triggered by the LoadableDescriptors attribute are speculative, failures must not impact loading of current class\n+          if (HAS_PENDING_EXCEPTION) {\n+            CLEAR_PENDING_EXCEPTION;\n+          }\n+        } else {\n+          \/\/ Just poking the system dictionary to see if the class has already be loaded. Looking for migrated classes\n+          \/\/ used when --enable-preview when jdk isn't compiled with --enable-preview so doesn't include LoadableDescriptors.\n+          \/\/ This is temporary.\n+          oop loader = loader_data()->class_loader();\n+          InstanceKlass* klass = SystemDictionary::find_instance_klass(THREAD, name, Handle(THREAD, loader));\n+          if (klass != nullptr && klass->is_inline_klass()) {\n+            _inline_layout_info_array->adr_at(fieldinfo.index())->set_klass(InlineKlass::cast(klass));\n+            log_info(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                     \"(cause: field type not in LoadableDescriptors attribute) succeeded\",\n+                                     name->as_C_string(), _class_name->as_C_string());\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  _layout_info = new FieldLayoutInfo();\n+  FieldLayoutBuilder lb(class_name(), loader_data(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n+      _parsed_annotations->is_contended(), is_inline_type(),\n+      access_flags().is_abstract() && !access_flags().is_identity_class() && !access_flags().is_interface(),\n+      _must_be_atomic, _layout_info, _inline_layout_info_array);\n@@ -5850,0 +6317,1 @@\n+  _has_inline_type_fields = _layout_info->_has_inline_fields;\n@@ -5859,0 +6327,21 @@\n+\n+  \/\/ Strict static fields track initialization status from the beginning of time.\n+  \/\/ After this class runs <clinit>, they will be verified as being \"not unset\".\n+  \/\/ See Step 8 of InstanceKlass::initialize_impl.\n+  if (_has_strict_static_fields) {\n+    bool found_one = false;\n+    for (int i = 0; i < _temp_field_info->length(); i++) {\n+      FieldInfo& fi = *_temp_field_info->adr_at(i);\n+      if (fi.access_flags().is_strict() && fi.access_flags().is_static()) {\n+        found_one = true;\n+        if (fi.initializer_index() != 0) {\n+          \/\/ skip strict static fields with ConstantValue attributes\n+        } else {\n+          _fields_status->adr_at(fi.index())->update_strict_static_unset(true);\n+          _fields_status->adr_at(fi.index())->update_strict_static_unread(true);\n+        }\n+      }\n+    }\n+    assert(found_one == _has_strict_static_fields,\n+           \"correct prediction = %d\", (int)_has_strict_static_fields);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":617,"deletions":128,"binary":false,"changes":745,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -447,0 +448,10 @@\n+void ClassLoaderData::inline_classes_do(void f(InlineKlass*)) {\n+  \/\/ Lock-free access requires load_acquire\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+    if (k->is_inline_klass()) {\n+      f(InlineKlass::cast(k));\n+    }\n+    assert(k != k->next_link(), \"no loops!\");\n+  }\n+}\n+\n@@ -625,0 +636,2 @@\n+  inline_classes_do(InlineKlass::cleanup);\n+\n@@ -904,1 +917,5 @@\n-        MetadataFactory::free_metadata(this, (InstanceKlass*)m);\n+        if (!((Klass*)m)->is_inline_klass()) {\n+          MetadataFactory::free_metadata(this, (InstanceKlass*)m);\n+        } else {\n+          MetadataFactory::free_metadata(this, (InlineKlass*)m);\n+        }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -35,0 +38,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -36,0 +40,60 @@\n+static LayoutKind field_layout_selection(FieldInfo field_info, Array<InlineLayoutInfo>* inline_layout_info_array,\n+                                         bool use_atomic_flat) {\n+\n+  if (!UseFieldFlattening) {\n+    return LayoutKind::REFERENCE;\n+  }\n+\n+  if (field_info.field_flags().is_injected()) {\n+    \/\/ don't flatten injected fields\n+    return LayoutKind::REFERENCE;\n+  }\n+\n+  if (field_info.access_flags().is_volatile()) {\n+    \/\/ volatile is used as a keyword to prevent flattening\n+    return LayoutKind::REFERENCE;\n+  }\n+\n+  if (inline_layout_info_array == nullptr || inline_layout_info_array->adr_at(field_info.index())->klass() == nullptr) {\n+    \/\/ field's type is not a known value class, using a reference\n+    return LayoutKind::REFERENCE;\n+  }\n+\n+  InlineLayoutInfo* inline_field_info = inline_layout_info_array->adr_at(field_info.index());\n+  InlineKlass* vk = inline_field_info->klass();\n+\n+  if (field_info.field_flags().is_null_free_inline_type()) {\n+    assert(field_info.access_flags().is_strict(), \"null-free fields must be strict\");\n+    if (vk->must_be_atomic() || AlwaysAtomicAccesses) {\n+      if (vk->is_naturally_atomic() && vk->has_non_atomic_layout()) return LayoutKind::NON_ATOMIC_FLAT;\n+      return (vk->has_atomic_layout() && use_atomic_flat) ? LayoutKind::ATOMIC_FLAT : LayoutKind::REFERENCE;\n+    } else {\n+      return vk->has_non_atomic_layout() ? LayoutKind::NON_ATOMIC_FLAT : LayoutKind::REFERENCE;\n+    }\n+  } else {\n+    if (UseNullableValueFlattening && vk->has_nullable_atomic_layout()) {\n+      return use_atomic_flat ? LayoutKind::NULLABLE_ATOMIC_FLAT : LayoutKind::REFERENCE;\n+    } else {\n+      return LayoutKind::REFERENCE;\n+    }\n+  }\n+}\n+\n+static void get_size_and_alignment(InlineKlass* vk, LayoutKind kind, int* size, int* alignment) {\n+  switch(kind) {\n+    case LayoutKind::NON_ATOMIC_FLAT:\n+      *size = vk->non_atomic_size_in_bytes();\n+      *alignment = vk->non_atomic_alignment();\n+      break;\n+    case LayoutKind::ATOMIC_FLAT:\n+      *size = vk->atomic_size_in_bytes();\n+      *alignment = *size;\n+      break;\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+      *size = vk->nullable_atomic_size_in_bytes();\n+      *alignment = *size;\n+    break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n@@ -40,1 +104,3 @@\n-  _kind(kind),\n+  _inline_klass(nullptr),\n+  _block_kind(kind),\n+  _layout_kind(LayoutKind::UNKNOWN),\n@@ -44,3 +110,2 @@\n-  _field_index(-1),\n-  _is_reference(false) {\n-  assert(kind == EMPTY || kind == RESERVED || kind == PADDING || kind == INHERITED,\n+  _field_index(-1) {\n+  assert(kind == EMPTY || kind == RESERVED || kind == PADDING || kind == INHERITED || kind == NULL_MARKER,\n@@ -52,1 +117,1 @@\n-LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment, bool is_reference) :\n+LayoutRawBlock::LayoutRawBlock(int index, Kind kind, int size, int alignment) :\n@@ -55,1 +120,3 @@\n- _kind(kind),\n+ _inline_klass(nullptr),\n+ _block_kind(kind),\n+ _layout_kind(LayoutKind::UNKNOWN),\n@@ -59,3 +126,2 @@\n- _field_index(index),\n- _is_reference(is_reference) {\n-  assert(kind == REGULAR || kind == FLATTENED || kind == INHERITED,\n+ _field_index(index) {\n+  assert(kind == REGULAR || kind == FLAT || kind == INHERITED,\n@@ -77,1 +143,2 @@\n-  _primitive_fields(nullptr),\n+  _small_primitive_fields(nullptr),\n+  _big_primitive_fields(nullptr),\n@@ -84,3 +151,5 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n-  if (_primitive_fields == nullptr) {\n-    _primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/);\n+  if (size >= oopSize) {\n+    add_to_big_primitive_list(block);\n+  } else {\n+    add_to_small_primitive_list(block);\n@@ -88,1 +157,0 @@\n-  _primitive_fields->append(block);\n@@ -93,1 +161,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/);\n@@ -101,0 +169,11 @@\n+void FieldGroup::add_flat_field(int idx, InlineKlass* vk, LayoutKind lk, int size, int alignment) {\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::FLAT, size, alignment);\n+  block->set_inline_klass(vk);\n+  block->set_layout_kind(lk);\n+  if (block->size() >= oopSize) {\n+    add_to_big_primitive_list(block);\n+  } else {\n+    add_to_small_primitive_list(block);\n+  }\n+}\n+\n@@ -102,2 +181,18 @@\n-  if (_primitive_fields != nullptr) {\n-    _primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  if (_small_primitive_fields != nullptr) {\n+    _small_primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  }\n+  if (_big_primitive_fields != nullptr) {\n+    _big_primitive_fields->sort(LayoutRawBlock::compare_size_inverted);\n+  }\n+}\n+\n+void FieldGroup::add_to_small_primitive_list(LayoutRawBlock* block) {\n+  if (_small_primitive_fields == nullptr) {\n+    _small_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n+  }\n+  _small_primitive_fields->append(block);\n+}\n+\n+void FieldGroup::add_to_big_primitive_list(LayoutRawBlock* block) {\n+  if (_big_primitive_fields == nullptr) {\n+    _big_primitive_fields = new GrowableArray<LayoutRawBlock*>(INITIAL_LIST_SIZE);\n@@ -105,0 +200,1 @@\n+  _big_primitive_fields->append(block);\n@@ -107,1 +203,1 @@\n-FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp) :\n+FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, Array<InlineLayoutInfo>* inline_layout_info_array, ConstantPool* cp) :\n@@ -109,0 +205,1 @@\n+  _inline_layout_info_array(inline_layout_info_array),\n@@ -112,1 +209,7 @@\n-  _last(_blocks) {}\n+  _last(_blocks),\n+  _super_first_field_offset(-1),\n+  _super_alignment(-1),\n+  _super_min_align_required(-1),\n+  _null_reset_value_offset(-1),\n+  _super_has_fields(false),\n+  _has_inherited_fields(false) {}\n@@ -138,2 +241,1 @@\n-    bool super_has_instance_fields = false;\n-    reconstruct_layout(super_klass, super_has_instance_fields, super_ends_with_oop);\n+    reconstruct_layout(super_klass, _super_has_fields, super_ends_with_oop);\n@@ -141,1 +243,1 @@\n-    if (!super_klass->has_contended_annotations() || !super_has_instance_fields) {\n+    if ((!super_klass->has_contended_annotations()) || !_super_has_fields) {\n@@ -150,3 +252,6 @@\n-  LayoutRawBlock* block = _start;\n-  while (block->kind() != LayoutRawBlock::INHERITED && block->kind() != LayoutRawBlock::REGULAR\n-      && block->kind() != LayoutRawBlock::FLATTENED && block->kind() != LayoutRawBlock::PADDING) {\n+  LayoutRawBlock* block = _blocks;\n+  while (block != nullptr\n+         && block->block_kind() != LayoutRawBlock::INHERITED\n+         && block->block_kind() != LayoutRawBlock::REGULAR\n+         && block->block_kind() != LayoutRawBlock::FLAT\n+         && block->block_kind() != LayoutRawBlock::NULL_MARKER) {\n@@ -158,3 +263,2 @@\n-\n-\/\/ Insert a set of fields into a layout using a best-fit strategy.\n-\/\/ For each field, search for the smallest empty slot able to fit the field\n+\/\/ Insert a set of fields into a layout.\n+\/\/ For each field, search for an empty slot able to fit the field\n@@ -174,1 +278,0 @@\n-\n@@ -192,0 +295,1 @@\n+\n@@ -193,1 +297,1 @@\n-        if (cursor->kind() == LayoutRawBlock::EMPTY && cursor->fit(b->size(), b->alignment())) {\n+        if (cursor->block_kind() == LayoutRawBlock::EMPTY && cursor->fit(b->size(), b->alignment())) {\n@@ -205,1 +309,1 @@\n-      assert(candidate->kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n+      assert(candidate->block_kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n@@ -208,1 +312,0 @@\n-\n@@ -224,2 +327,2 @@\n-      assert(slot->kind() == LayoutRawBlock::EMPTY, \"Matching slot must be an empty slot\");\n-      assert(slot->size() >= block->offset() + block->size() ,\"Matching slot must be big enough\");\n+      assert(slot->block_kind() == LayoutRawBlock::EMPTY, \"Matching slot must be an empty slot\");\n+      assert(slot->size() >= block->offset() - slot->offset() + block->size() ,\"Matching slot must be big enough\");\n@@ -235,1 +338,3 @@\n-      _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+      if (block->block_kind() == LayoutRawBlock::REGULAR || block->block_kind() == LayoutRawBlock::FLAT) {\n+        _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+      }\n@@ -264,1 +369,1 @@\n-    while (candidate->kind() != LayoutRawBlock::EMPTY || !candidate->fit(size, first->alignment())) {\n+    while (candidate->block_kind() != LayoutRawBlock::EMPTY || !candidate->fit(size, first->alignment())) {\n@@ -272,1 +377,1 @@\n-    assert(candidate->kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n+    assert(candidate->block_kind() == LayoutRawBlock::EMPTY, \"Candidate must be an empty block\");\n@@ -284,1 +389,1 @@\n-  assert(slot->kind() == LayoutRawBlock::EMPTY, \"Blocks can only be inserted in empty blocks\");\n+  assert(slot->block_kind() == LayoutRawBlock::EMPTY, \"Blocks can only be inserted in empty blocks\");\n@@ -290,0 +395,1 @@\n+  assert(block->size() >= block->size(), \"Enough space must remain after adjustment\");\n@@ -294,1 +400,13 @@\n-  _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+  \/\/ NULL_MARKER blocks are not real fields, so they don't have an entry in the FieldInfo array\n+  if (block->block_kind() != LayoutRawBlock::NULL_MARKER) {\n+    _field_info->adr_at(block->field_index())->set_offset(block->offset());\n+    if (_field_info->adr_at(block->field_index())->name(_cp) == vmSymbols::null_reset_value_name()) {\n+      _null_reset_value_offset = block->offset();\n+    }\n+  }\n+  if (block->block_kind() == LayoutRawBlock::FLAT && block->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n+    int nm_offset = block->inline_klass()->null_marker_offset() - block->inline_klass()->payload_offset() + block->offset();\n+    _field_info->adr_at(block->field_index())->set_null_marker_offset(nm_offset);\n+    _inline_layout_info_array->adr_at(block->field_index())->set_null_marker_offset(nm_offset);\n+  }\n+\n@@ -300,0 +418,3 @@\n+  if (ik->is_abstract() && !ik->is_identity_class()) {\n+    _super_alignment = type2aelembytes(BasicType::T_LONG);\n+  }\n@@ -309,0 +430,21 @@\n+      _has_inherited_fields = true;\n+      if (_super_first_field_offset == -1 || fs.offset() < _super_first_field_offset) {\n+        _super_first_field_offset = fs.offset();\n+      }\n+      LayoutRawBlock* block;\n+      if (fs.is_flat()) {\n+        InlineLayoutInfo layout_info = ik->inline_layout_info(fs.index());\n+        InlineKlass* vk = layout_info.klass();\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED,\n+                                   vk->layout_size_in_bytes(layout_info.kind()),\n+                                   vk->layout_alignment(layout_info.kind()));\n+        assert(_super_alignment == -1 || _super_alignment >=  vk->payload_alignment(), \"Invalid value alignment\");\n+        _super_min_align_required = _super_min_align_required > vk->payload_alignment() ? _super_min_align_required : vk->payload_alignment();\n+      } else {\n+        int size = type2aelembytes(type);\n+        \/\/ INHERITED blocks are marked as non-reference because oop_maps are handled by their holder class\n+        block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size);\n+        \/\/ For primitive types, the alignment is equal to the size\n+        assert(_super_alignment == -1 || _super_alignment >=  size, \"Invalid value alignment\");\n+        _super_min_align_required = _super_min_align_required > size ? _super_min_align_required : size;\n+      }\n@@ -313,3 +455,0 @@\n-      int size = type2aelembytes(type);\n-      \/\/ INHERITED blocks are marked as non-reference because oop_maps are handled by their holder class\n-      LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::INHERITED, size, size, false);\n@@ -331,1 +470,0 @@\n-\n@@ -355,0 +493,1 @@\n+      \/\/ FIXME it would be better if initial empty block where tagged as PADDING for value classes\n@@ -365,2 +504,1 @@\n-  assert(b->kind() != LayoutRawBlock::EMPTY, \"Sanity check\");\n-\n+  assert(b->block_kind() != LayoutRawBlock::EMPTY, \"Sanity check\");\n@@ -387,1 +525,1 @@\n-  assert(slot->kind() == LayoutRawBlock::EMPTY, \"Blocks can only be inserted in empty blocks\");\n+  assert(slot->block_kind() == LayoutRawBlock::EMPTY, \"Blocks can only be inserted in empty blocks\");\n@@ -403,0 +541,3 @@\n+  if (_start == slot) {\n+    _start = block;\n+  }\n@@ -424,1 +565,77 @@\n-void FieldLayout::print(outputStream* output, bool is_static, const InstanceKlass* super) {\n+void FieldLayout::shift_fields(int shift) {\n+  LayoutRawBlock* b = first_field_block();\n+  LayoutRawBlock* previous = b->prev_block();\n+  if (previous->block_kind() == LayoutRawBlock::EMPTY) {\n+    previous->set_size(previous->size() + shift);\n+  } else {\n+    LayoutRawBlock* nb = new LayoutRawBlock(LayoutRawBlock::PADDING, shift);\n+    nb->set_offset(b->offset());\n+    previous->set_next_block(nb);\n+    nb->set_prev_block(previous);\n+    b->set_prev_block(nb);\n+    nb->set_next_block(b);\n+  }\n+  while (b != nullptr) {\n+    b->set_offset(b->offset() + shift);\n+    if (b->block_kind() == LayoutRawBlock::REGULAR || b->block_kind() == LayoutRawBlock::FLAT) {\n+      _field_info->adr_at(b->field_index())->set_offset(b->offset());\n+      if (b->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n+        int new_nm_offset = _field_info->adr_at(b->field_index())->null_marker_offset() + shift;\n+        _field_info->adr_at(b->field_index())->set_null_marker_offset(new_nm_offset);\n+        _inline_layout_info_array->adr_at(b->field_index())->set_null_marker_offset(new_nm_offset);\n+\n+      }\n+    }\n+    assert(b->block_kind() == LayoutRawBlock::EMPTY || b->offset() % b->alignment() == 0, \"Must still be correctly aligned\");\n+    b = b->next_block();\n+  }\n+}\n+\n+LayoutRawBlock* FieldLayout::find_null_marker() {\n+  LayoutRawBlock* b = _blocks;\n+  while (b != nullptr) {\n+    if (b->block_kind() == LayoutRawBlock::NULL_MARKER) {\n+      return b;\n+    }\n+    b = b->next_block();\n+  }\n+  ShouldNotReachHere();\n+}\n+\n+void FieldLayout::remove_null_marker() {\n+  LayoutRawBlock* b = first_field_block();\n+  while (b != nullptr) {\n+    if (b->block_kind() == LayoutRawBlock::NULL_MARKER) {\n+      if (b->next_block()->block_kind() == LayoutRawBlock::EMPTY) {\n+        LayoutRawBlock* n = b->next_block();\n+        remove(b);\n+        n->set_offset(b->offset());\n+        n->set_size(n->size() + b->size());\n+      } else {\n+        b->set_block_kind(LayoutRawBlock::EMPTY);\n+      }\n+      return;\n+    }\n+    b = b->next_block();\n+  }\n+  ShouldNotReachHere(); \/\/ if we reach this point, the null marker was not found!\n+}\n+\n+static const char* layout_kind_to_string(LayoutKind lk) {\n+  switch(lk) {\n+    case LayoutKind::REFERENCE:\n+      return \"REFERENCE\";\n+    case LayoutKind::NON_ATOMIC_FLAT:\n+      return \"NON_ATOMIC_FLAT\";\n+    case LayoutKind::ATOMIC_FLAT:\n+      return \"ATOMIC_FLAT\";\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+      return \"NULLABLE_ATOMIC_FLAT\";\n+    case LayoutKind::UNKNOWN:\n+      return \"UNKNOWN\";\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void FieldLayout::print(outputStream* output, bool is_static, const InstanceKlass* super, Array<InlineLayoutInfo>* inline_fields) {\n@@ -428,1 +645,1 @@\n-    switch(b->kind()) {\n+    switch(b->block_kind()) {\n@@ -431,1 +648,1 @@\n-        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+        output->print_cr(\" @%d %s %d\/%d \\\"%s\\\" %s\",\n@@ -433,2 +650,1 @@\n-                         fi->name(_cp)->as_C_string(),\n-                         fi->signature(_cp)->as_C_string(),\n+                         \"REGULAR\",\n@@ -437,1 +653,2 @@\n-                         \"REGULAR\");\n+                         fi->name(_cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string());\n@@ -440,1 +657,1 @@\n-      case LayoutRawBlock::FLATTENED: {\n+      case LayoutRawBlock::FLAT: {\n@@ -442,1 +659,3 @@\n-        output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+        InlineKlass* ik = inline_fields->adr_at(fi->index())->klass();\n+        assert(ik != nullptr, \"\");\n+        output->print_cr(\" @%d %s %d\/%d \\\"%s\\\" %s %s@%p %s\",\n@@ -444,2 +663,1 @@\n-                         fi->name(_cp)->as_C_string(),\n-                         fi->signature(_cp)->as_C_string(),\n+                         \"FLAT\",\n@@ -448,1 +666,4 @@\n-                         \"FLATTENED\");\n+                         fi->name(_cp)->as_C_string(),\n+                         fi->signature(_cp)->as_C_string(),\n+                         ik->name()->as_C_string(),\n+                         ik->class_loader_data(), layout_kind_to_string(b->layout_kind()));\n@@ -452,1 +673,1 @@\n-        output->print_cr(\" @%d %d\/- %s\",\n+        output->print_cr(\" @%d %s %d\/-\",\n@@ -454,2 +675,2 @@\n-                         b->size(),\n-                         \"RESERVED\");\n+                         \"RESERVED\",\n+                         b->size());\n@@ -465,2 +686,2 @@\n-            if (fs.offset() == b->offset()) {\n-              output->print_cr(\" @%d \\\"%s\\\" %s %d\/%d %s\",\n+            if (fs.offset() == b->offset() && fs.access_flags().is_static() == is_static) {\n+              output->print_cr(\" @%d %s %d\/%d \\\"%s\\\" %s\",\n@@ -468,2 +689,1 @@\n-                  fs.name()->as_C_string(),\n-                  fs.signature()->as_C_string(),\n+                  \"INHERITED\",\n@@ -471,2 +691,3 @@\n-                  b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla\n-                  \"INHERITED\");\n+                  b->size(), \/\/ so far, alignment constraint == size, will change with Valhalla => FIXME\n+                  fs.name()->as_C_string(),\n+                  fs.signature()->as_C_string());\n@@ -476,3 +697,1 @@\n-          }\n-          ik = ik->super();\n-        break;\n+        ik = ik->super();\n@@ -481,12 +700,24 @@\n-      case LayoutRawBlock::EMPTY:\n-        output->print_cr(\" @%d %d\/1 %s\",\n-                         b->offset(),\n-                         b->size(),\n-                        \"EMPTY\");\n-        break;\n-      case LayoutRawBlock::PADDING:\n-        output->print_cr(\" @%d %d\/1 %s\",\n-                         b->offset(),\n-                         b->size(),\n-                        \"PADDING\");\n-        break;\n+      break;\n+    }\n+    case LayoutRawBlock::EMPTY:\n+      output->print_cr(\" @%d %s %d\/1\",\n+                       b->offset(),\n+                      \"EMPTY\",\n+                       b->size());\n+      break;\n+    case LayoutRawBlock::PADDING:\n+      output->print_cr(\" @%d %s %d\/1\",\n+                      b->offset(),\n+                      \"PADDING\",\n+                      b->size());\n+      break;\n+    case LayoutRawBlock::NULL_MARKER:\n+    {\n+      output->print_cr(\" @%d %s %d\/1 \",\n+                      b->offset(),\n+                      \"NULL_MARKER\",\n+                      b->size());\n+      break;\n+    }\n+    default:\n+      fatal(\"Unknown block type\");\n@@ -498,2 +729,3 @@\n-FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, const InstanceKlass* super_klass, ConstantPool* constant_pool,\n-      GrowableArray<FieldInfo>* field_info, bool is_contended, FieldLayoutInfo* info) :\n+FieldLayoutBuilder::FieldLayoutBuilder(const Symbol* classname, ClassLoaderData* loader_data, const InstanceKlass* super_klass, ConstantPool* constant_pool,\n+                                       GrowableArray<FieldInfo>* field_info, bool is_contended, bool is_inline_type,bool is_abstract_value,\n+                                       bool must_be_atomic, FieldLayoutInfo* info, Array<InlineLayoutInfo>* inline_layout_info_array) :\n@@ -501,0 +733,1 @@\n+  _loader_data(loader_data),\n@@ -505,0 +738,1 @@\n+  _inline_layout_info_array(inline_layout_info_array),\n@@ -511,1 +745,13 @@\n-  _alignment(-1),\n+  _payload_alignment(-1),\n+  _payload_offset(-1),\n+  _null_marker_offset(-1),\n+  _payload_size_in_bytes(-1),\n+  _non_atomic_layout_size_in_bytes(-1),\n+  _non_atomic_layout_alignment(-1),\n+  _atomic_layout_size_in_bytes(-1),\n+  _nullable_layout_size_in_bytes(-1),\n+  _fields_size_sum(0),\n+  _declared_non_static_fields_count(0),\n+  _has_non_naturally_atomic_fields(false),\n+  _is_naturally_atomic(false),\n+  _must_be_atomic(must_be_atomic),\n@@ -513,2 +759,6 @@\n-  _is_contended(is_contended) {}\n-\n+  _has_inline_type_fields(false),\n+  _is_contended(is_contended),\n+  _is_inline_type(is_inline_type),\n+  _is_abstract_value(is_abstract_value),\n+  _has_flattening_information(is_inline_type),\n+  _is_empty_inline_class(false) {}\n@@ -529,1 +779,1 @@\n-  _layout = new FieldLayout(_field_info, _constant_pool);\n+  _layout = new FieldLayout(_field_info, _inline_layout_info_array, _constant_pool);\n@@ -532,0 +782,1 @@\n+  _nonstatic_oopmap_count = super_klass == nullptr ? 0 : super_klass->nonstatic_oop_map_count();\n@@ -535,1 +786,1 @@\n-  _static_layout = new FieldLayout(_field_info, _constant_pool);\n+  _static_layout = new FieldLayout(_field_info, _inline_layout_info_array, _constant_pool);\n@@ -541,1 +792,1 @@\n-\/\/ Field sorting for regular classes:\n+\/\/ Field sorting for regular (non-inline) classes:\n@@ -546,0 +797,1 @@\n+\/\/   - field flattening decisions are taken in this method\n@@ -549,1 +801,0 @@\n-    FieldInfo ctrl = _field_info->at(0);\n@@ -571,12 +822,22 @@\n-      case T_BYTE:\n-      case T_CHAR:\n-      case T_DOUBLE:\n-      case T_FLOAT:\n-      case T_INT:\n-      case T_LONG:\n-      case T_SHORT:\n-      case T_BOOLEAN:\n-        group->add_primitive_field(idx, type);\n-        break;\n-      case T_OBJECT:\n-      case T_ARRAY:\n+    case T_BYTE:\n+    case T_CHAR:\n+    case T_DOUBLE:\n+    case T_FLOAT:\n+    case T_INT:\n+    case T_LONG:\n+    case T_SHORT:\n+    case T_BOOLEAN:\n+      group->add_primitive_field(idx, type);\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY:\n+    {\n+      LayoutKind lk = field_layout_selection(fieldinfo, _inline_layout_info_array, true);\n+      if (fieldinfo.field_flags().is_null_free_inline_type() || lk != LayoutKind::REFERENCE\n+          || (!fieldinfo.field_flags().is_injected()\n+              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(fieldinfo.index())->klass() != nullptr\n+              && !_inline_layout_info_array->adr_at(fieldinfo.index())->klass()->is_identity_class())) {\n+        _has_inline_type_fields = true;\n+        _has_flattening_information = true;\n+      }\n+      if (lk == LayoutKind::REFERENCE) {\n@@ -585,3 +846,16 @@\n-        break;\n-      default:\n-        fatal(\"Something wrong?\");\n+      } else {\n+        _has_flattening_information = true;\n+        InlineKlass* vk = _inline_layout_info_array->adr_at(fieldinfo.index())->klass();\n+        int size, alignment;\n+        get_size_and_alignment(vk, lk, &size, &alignment);\n+        group->add_flat_field(idx, vk, lk, size, alignment);\n+        _inline_layout_info_array->adr_at(fieldinfo.index())->set_kind(lk);\n+        _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+        _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n+        _field_info->adr_at(idx)->set_layout_kind(lk);\n+        \/\/ no need to update _must_be_atomic if vk->must_be_atomic() is true because current class is not an inline class\n+      }\n+      break;\n+    }\n+    default:\n+      fatal(\"Something wrong?\");\n@@ -599,0 +873,84 @@\n+\/* Field sorting for inline classes:\n+ *   - because inline classes are immutable, the @Contended annotation is ignored\n+ *     when computing their layout (with only read operation, there's no false\n+ *     sharing issue)\n+ *   - this method also records the alignment of the field with the most\n+ *     constraining alignment, this value is then used as the alignment\n+ *     constraint when flattening this inline type into another container\n+ *   - field flattening decisions are taken in this method (those decisions are\n+ *     currently only based in the size of the fields to be flattened, the size\n+ *     of the resulting instance is not considered)\n+ *\/\n+void FieldLayoutBuilder::inline_class_field_sorting() {\n+  assert(_is_inline_type || _is_abstract_value, \"Should only be used for inline classes\");\n+  int alignment = -1;\n+  int idx = 0;\n+  for (GrowableArrayIterator<FieldInfo> it = _field_info->begin(); it != _field_info->end(); ++it, ++idx) {\n+    FieldGroup* group = nullptr;\n+    FieldInfo fieldinfo = *it;\n+    int field_alignment = 1;\n+    if (fieldinfo.access_flags().is_static()) {\n+      group = _static_fields;\n+    } else {\n+      _has_nonstatic_fields = true;\n+      _declared_non_static_fields_count++;\n+      group = _root_group;\n+    }\n+    assert(group != nullptr, \"invariant\");\n+    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n+    switch(type) {\n+    case T_BYTE:\n+    case T_CHAR:\n+    case T_DOUBLE:\n+    case T_FLOAT:\n+    case T_INT:\n+    case T_LONG:\n+    case T_SHORT:\n+    case T_BOOLEAN:\n+      if (group != _static_fields) {\n+        field_alignment = type2aelembytes(type); \/\/ alignment == size for primitive types\n+      }\n+      group->add_primitive_field(fieldinfo.index(), type);\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY:\n+    {\n+      bool use_atomic_flat = _must_be_atomic; \/\/ flatten atomic fields only if the container is itself atomic\n+      LayoutKind lk = field_layout_selection(fieldinfo, _inline_layout_info_array, use_atomic_flat);\n+      if (fieldinfo.field_flags().is_null_free_inline_type() || lk != LayoutKind::REFERENCE\n+          || (!fieldinfo.field_flags().is_injected()\n+              && _inline_layout_info_array != nullptr && _inline_layout_info_array->adr_at(fieldinfo.index())->klass() != nullptr\n+              && !_inline_layout_info_array->adr_at(fieldinfo.index())->klass()->is_identity_class())) {\n+        _has_inline_type_fields = true;\n+        _has_flattening_information = true;\n+      }\n+      if (lk == LayoutKind::REFERENCE) {\n+        if (group != _static_fields) {\n+          _nonstatic_oopmap_count++;\n+          field_alignment = type2aelembytes(type); \/\/ alignment == size for oops\n+        }\n+        group->add_oop_field(idx);\n+      } else {\n+        _has_flattening_information = true;\n+        InlineKlass* vk = _inline_layout_info_array->adr_at(fieldinfo.index())->klass();\n+        if (!vk->is_naturally_atomic()) _has_non_naturally_atomic_fields = true;\n+        int size, alignment;\n+        get_size_and_alignment(vk, lk, &size, &alignment);\n+        group->add_flat_field(idx, vk, lk, size, alignment);\n+        _inline_layout_info_array->adr_at(fieldinfo.index())->set_kind(lk);\n+        _nonstatic_oopmap_count += vk->nonstatic_oop_map_count();\n+        field_alignment = alignment;\n+        _field_info->adr_at(idx)->field_flags_addr()->update_flat(true);\n+        _field_info->adr_at(idx)->set_layout_kind(lk);\n+      }\n+      break;\n+    }\n+    default:\n+      fatal(\"Unexpected BasicType\");\n+    }\n+    if (!fieldinfo.access_flags().is_static() && field_alignment > alignment) alignment = field_alignment;\n+  }\n+  _payload_alignment = alignment;\n+  assert(_has_nonstatic_fields || _is_abstract_value, \"Concrete value types do not support zero instance size yet\");\n+}\n+\n@@ -608,1 +966,2 @@\n-\/\/   - primitive fields are allocated first (from the biggest to the smallest)\n+\/\/   - primitive fields (both primitive types and flat inline types) are allocated\n+\/\/     first (from the biggest to the smallest)\n@@ -621,1 +980,0 @@\n-\n@@ -632,1 +990,2 @@\n-    _layout->add(_root_group->primitive_fields());\n+    _layout->add(_root_group->big_primitive_fields());\n+    _layout->add(_root_group->small_primitive_fields());\n@@ -634,1 +993,2 @@\n-    _layout->add(_root_group->primitive_fields());\n+    _layout->add(_root_group->big_primitive_fields());\n+    _layout->add(_root_group->small_primitive_fields());\n@@ -643,1 +1003,2 @@\n-      _layout->add(cg->primitive_fields(), start);\n+      _layout->add(cg->big_primitive_fields());\n+      _layout->add(cg->small_primitive_fields(), start);\n@@ -653,2 +1014,4 @@\n-  _static_layout->add_contiguously(this->_static_fields->oop_fields());\n-  _static_layout->add(this->_static_fields->primitive_fields());\n+  \/\/ Warning: IntanceMirrorKlass expects static oops to be allocated first\n+  _static_layout->add_contiguously(_static_fields->oop_fields());\n+  _static_layout->add(_static_fields->big_primitive_fields());\n+  _static_layout->add(_static_fields->small_primitive_fields());\n@@ -659,4 +1022,13 @@\n-void FieldLayoutBuilder::epilogue() {\n-  \/\/ Computing oopmaps\n-  int super_oop_map_count = (_super_klass == nullptr) ? 0 :_super_klass->nonstatic_oop_map_count();\n-  int max_oop_map_count = super_oop_map_count + _nonstatic_oopmap_count;\n+\/* Computation of inline classes has a slightly different strategy than for\n+ * regular classes. Regular classes have their oop fields allocated at the end\n+ * of the layout to increase GC performances. Unfortunately, this strategy\n+ * increases the number of empty slots inside an instance. Because the purpose\n+ * of inline classes is to be embedded into other containers, it is critical\n+ * to keep their size as small as possible. For this reason, the allocation\n+ * strategy is:\n+ *   - big primitive fields (primitive types and flat inline type smaller\n+ *     than an oop) are allocated first (from the biggest to the smallest)\n+ *   - then oop fields\n+ *   - then small primitive fields (from the biggest to the smallest)\n+ *\/\n+void FieldLayoutBuilder::compute_inline_class_layout() {\n@@ -664,5 +1036,227 @@\n-  OopMapBlocksBuilder* nonstatic_oop_maps =\n-      new OopMapBlocksBuilder(max_oop_map_count);\n-  if (super_oop_map_count > 0) {\n-    nonstatic_oop_maps->initialize_inherited_blocks(_super_klass->start_of_nonstatic_oop_maps(),\n-    _super_klass->nonstatic_oop_map_count());\n+  \/\/ Test if the concrete inline class is an empty class (no instance fields)\n+  \/\/ and insert a dummy field if needed\n+  if (!_is_abstract_value) {\n+    bool declares_non_static_fields = false;\n+    for (GrowableArrayIterator<FieldInfo> it = _field_info->begin(); it != _field_info->end(); ++it) {\n+      FieldInfo fieldinfo = *it;\n+      if (!fieldinfo.access_flags().is_static()) {\n+        declares_non_static_fields = true;\n+        break;\n+      }\n+    }\n+    if (!declares_non_static_fields) {\n+      bool has_inherited_fields = false;\n+      const InstanceKlass* super = _super_klass;\n+      while(super != nullptr) {\n+        if (super->has_nonstatic_fields()) {\n+          has_inherited_fields = true;\n+          break;\n+        }\n+        super = super->super() == nullptr ? nullptr : InstanceKlass::cast(super->super());\n+      }\n+\n+      if (!has_inherited_fields) {\n+        \/\/ Inject \".empty\" dummy field\n+        _is_empty_inline_class = true;\n+        FieldInfo::FieldFlags fflags(0);\n+        fflags.update_injected(true);\n+        AccessFlags aflags;\n+        FieldInfo fi(aflags,\n+                    (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(empty_marker_name)),\n+                    (u2)vmSymbols::as_int(VM_SYMBOL_ENUM_NAME(byte_signature)),\n+                    0,\n+                    fflags);\n+        int idx = _field_info->append(fi);\n+        _field_info->adr_at(idx)->set_index(idx);\n+      }\n+    }\n+  }\n+\n+  prologue();\n+  inline_class_field_sorting();\n+\n+  assert(_layout->start()->block_kind() == LayoutRawBlock::RESERVED, \"Unexpected\");\n+\n+  if (_layout->super_has_fields() && !_is_abstract_value) {  \/\/ non-static field layout\n+    if (!_has_nonstatic_fields) {\n+      assert(_is_abstract_value, \"Concrete value types have at least one field\");\n+      \/\/ Nothing to do\n+    } else {\n+      \/\/ decide which alignment to use, then set first allowed field offset\n+\n+      assert(_layout->super_alignment() >= _payload_alignment, \"Incompatible alignment\");\n+      assert(_layout->super_alignment() % _payload_alignment == 0, \"Incompatible alignment\");\n+\n+      if (_payload_alignment < _layout->super_alignment()) {\n+        int new_alignment = _payload_alignment > _layout->super_min_align_required() ? _payload_alignment : _layout->super_min_align_required();\n+        assert(new_alignment % _payload_alignment == 0, \"Must be\");\n+        assert(new_alignment % _layout->super_min_align_required() == 0, \"Must be\");\n+        _payload_alignment = new_alignment;\n+      }\n+      _layout->set_start(_layout->first_field_block());\n+    }\n+  } else {\n+    if (_is_abstract_value && _has_nonstatic_fields) {\n+      _payload_alignment = type2aelembytes(BasicType::T_LONG);\n+    }\n+    assert(_layout->start()->next_block()->block_kind() == LayoutRawBlock::EMPTY || !UseCompressedClassPointers, \"Unexpected\");\n+    LayoutRawBlock* first_empty = _layout->start()->next_block();\n+    if (first_empty->offset() % _payload_alignment != 0) {\n+      LayoutRawBlock* padding = new LayoutRawBlock(LayoutRawBlock::PADDING, _payload_alignment - (first_empty->offset() % _payload_alignment));\n+      _layout->insert(first_empty, padding);\n+      if (first_empty->size() == 0) {\n+        _layout->remove(first_empty);\n+      }\n+      _layout->set_start(padding);\n+    }\n+  }\n+\n+  _layout->add(_root_group->big_primitive_fields());\n+  _layout->add(_root_group->oop_fields());\n+  _layout->add(_root_group->small_primitive_fields());\n+\n+  LayoutRawBlock* first_field = _layout->first_field_block();\n+  if (first_field != nullptr) {\n+    _payload_offset = _layout->first_field_block()->offset();\n+    _payload_size_in_bytes = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+  } else {\n+    assert(_is_abstract_value, \"Concrete inline types must have at least one field\");\n+    _payload_offset = _layout->blocks()->size();\n+    _payload_size_in_bytes = 0;\n+  }\n+\n+  \/\/ Determining if the value class is naturally atomic:\n+  if ((!_layout->super_has_fields() && _declared_non_static_fields_count <= 1 && !_has_non_naturally_atomic_fields)\n+      || (_layout->super_has_fields() && _super_klass->is_naturally_atomic() && _declared_non_static_fields_count == 0)) {\n+        _is_naturally_atomic = true;\n+  }\n+\n+  \/\/ At this point, the characteristics of the raw layout (used in standalone instances) are known.\n+  \/\/ From this, additional layouts will be computed: atomic and nullable layouts\n+  \/\/ Once those additional layouts are computed, the raw layout might need some adjustments\n+\n+  bool vm_uses_flattening = UseFieldFlattening || UseArrayFlattening;\n+\n+  if (!_is_abstract_value && vm_uses_flattening) { \/\/ Flat layouts are only for concrete value classes\n+    \/\/ Validation of the non atomic layout\n+    if (UseNonAtomicValueFlattening && !AlwaysAtomicAccesses && (!_must_be_atomic || _is_naturally_atomic)) {\n+      _non_atomic_layout_size_in_bytes = _payload_size_in_bytes;\n+      _non_atomic_layout_alignment = _payload_alignment;\n+    }\n+\n+    \/\/ Next step is to compute the characteristics for a layout enabling atomic updates\n+    if (UseAtomicValueFlattening) {\n+      int atomic_size = _payload_size_in_bytes == 0 ? 0 : round_up_power_of_2(_payload_size_in_bytes);\n+      if (atomic_size <= (int)MAX_ATOMIC_OP_SIZE) {\n+        _atomic_layout_size_in_bytes = atomic_size;\n+      }\n+    }\n+\n+    \/\/ Next step is the nullable layout: the layout must include a null marker and must also be atomic\n+    if (UseNullableValueFlattening) {\n+      \/\/ Looking if there's an empty slot inside the layout that could be used to store a null marker\n+      \/\/ FIXME: could it be possible to re-use the .empty field as a null marker for empty values?\n+      LayoutRawBlock* b = _layout->first_field_block();\n+      assert(b != nullptr, \"A concrete value class must have at least one (possible dummy) field\");\n+      int null_marker_offset = -1;\n+      if (_is_empty_inline_class) {\n+        \/\/ Reusing the dummy field as a field marker\n+        assert(_field_info->adr_at(b->field_index())->name(_constant_pool) == vmSymbols::empty_marker_name(), \"b must be the dummy field\");\n+        null_marker_offset = b->offset();\n+      } else {\n+        while (b != _layout->last_block()) {\n+          if (b->block_kind() == LayoutRawBlock::EMPTY) {\n+            break;\n+          }\n+          b = b->next_block();\n+        }\n+        if (b != _layout->last_block()) {\n+          \/\/ found an empty slot, register its offset from the beginning of the payload\n+          null_marker_offset = b->offset();\n+          LayoutRawBlock* marker = new LayoutRawBlock(LayoutRawBlock::NULL_MARKER, 1);\n+          _layout->add_field_at_offset(marker, b->offset());\n+        }\n+        if (null_marker_offset == -1) { \/\/ no empty slot available to store the null marker, need to inject one\n+          int last_offset = _layout->last_block()->offset();\n+          LayoutRawBlock* marker = new LayoutRawBlock(LayoutRawBlock::NULL_MARKER, 1);\n+          _layout->insert_field_block(_layout->last_block(), marker);\n+          assert(marker->offset() == last_offset, \"Null marker should have been inserted at the end\");\n+          null_marker_offset = marker->offset();\n+        }\n+      }\n+\n+      \/\/ Now that the null marker is there, the size of the nullable layout must computed (remember, must be atomic too)\n+      int new_raw_size = _layout->last_block()->offset() - _layout->first_field_block()->offset();\n+      int nullable_size = round_up_power_of_2(new_raw_size);\n+      if (nullable_size <= (int)MAX_ATOMIC_OP_SIZE) {\n+        _nullable_layout_size_in_bytes = nullable_size;\n+        _null_marker_offset = null_marker_offset;\n+      } else {\n+        \/\/ If the nullable layout is rejected, the NULL_MARKER block should be removed\n+        \/\/ from the layout, otherwise it will appear anyway if the layout is printer\n+        if (!_is_empty_inline_class) {  \/\/ empty values don't have a dedicated NULL_MARKER block\n+          _layout->remove_null_marker();\n+        }\n+        _null_marker_offset = -1;\n+      }\n+    }\n+    \/\/ If the inline class has an atomic or nullable (which is also atomic) layout,\n+    \/\/ we want the raw layout to have the same alignment as those atomic layouts so access codes\n+    \/\/ could remain  simple (single instruction without intermediate copy). This might required\n+    \/\/ to shift all fields in the raw layout, but this operation is possible only if the class\n+    \/\/ doesn't have inherited fields (offsets of inherited fields cannot be changed). If a\n+    \/\/ field shift is needed but not possible, all atomic layouts are disabled and only reference\n+    \/\/ and loosely consistent are supported.\n+    int required_alignment = _payload_alignment;\n+    if (has_atomic_layout() && _payload_alignment < atomic_layout_size_in_bytes()) {\n+      required_alignment = atomic_layout_size_in_bytes();\n+    }\n+    if (has_nullable_atomic_layout() && _payload_alignment < nullable_layout_size_in_bytes()) {\n+      required_alignment = nullable_layout_size_in_bytes();\n+    }\n+    int shift = first_field->offset() % required_alignment;\n+    if (shift != 0) {\n+      if (required_alignment > _payload_alignment && !_layout->has_inherited_fields()) {\n+        assert(_layout->first_field_block() != nullptr, \"A concrete value class must have at least one (possible dummy) field\");\n+        _layout->shift_fields(shift);\n+        _payload_offset = _layout->first_field_block()->offset();\n+        if (has_nullable_atomic_layout()) {\n+          assert(!_is_empty_inline_class, \"Should not get here with empty values\");\n+          _null_marker_offset = _layout->find_null_marker()->offset();\n+        }\n+        _payload_alignment = required_alignment;\n+      } else {\n+        _atomic_layout_size_in_bytes = -1;\n+        if (has_nullable_atomic_layout() && !_is_empty_inline_class) {  \/\/ empty values don't have a dedicated NULL_MARKER block\n+          _layout->remove_null_marker();\n+        }\n+        _nullable_layout_size_in_bytes = -1;\n+        _null_marker_offset = -1;\n+      }\n+    } else {\n+      _payload_alignment = required_alignment;\n+    }\n+\n+    \/\/ If the inline class has a nullable layout, the layout used in heap allocated standalone\n+    \/\/ instances must also be the nullable layout, in order to be able to set the null marker to\n+    \/\/ non-null before copying the payload to other containers.\n+    if (has_nullable_atomic_layout() && payload_layout_size_in_bytes() < nullable_layout_size_in_bytes()) {\n+      _payload_size_in_bytes = nullable_layout_size_in_bytes();\n+    }\n+  }\n+  \/\/ Warning:: InstanceMirrorKlass expects static oops to be allocated first\n+  _static_layout->add_contiguously(_static_fields->oop_fields());\n+  _static_layout->add(_static_fields->big_primitive_fields());\n+  _static_layout->add(_static_fields->small_primitive_fields());\n+\n+  epilogue();\n+}\n+\n+void FieldLayoutBuilder::add_flat_field_oopmap(OopMapBlocksBuilder* nonstatic_oop_maps,\n+                InlineKlass* vklass, int offset) {\n+  int diff = offset - vklass->payload_offset();\n+  const OopMapBlock* map = vklass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* last_map = map + vklass->nonstatic_oop_map_count();\n+  while (map < last_map) {\n+    nonstatic_oop_maps->add(map->offset() + diff, map->count());\n+    map++;\n@@ -670,0 +1264,1 @@\n+}\n@@ -671,3 +1266,18 @@\n-  if (_root_group->oop_fields() != nullptr) {\n-    for (int i = 0; i < _root_group->oop_fields()->length(); i++) {\n-      LayoutRawBlock* b = _root_group->oop_fields()->at(i);\n+void FieldLayoutBuilder::register_embedded_oops_from_list(OopMapBlocksBuilder* nonstatic_oop_maps, GrowableArray<LayoutRawBlock*>* list) {\n+  if (list == nullptr) return;\n+  for (int i = 0; i < list->length(); i++) {\n+    LayoutRawBlock* f = list->at(i);\n+    if (f->block_kind() == LayoutRawBlock::FLAT) {\n+      InlineKlass* vk = f->inline_klass();\n+      assert(vk != nullptr, \"Should have been initialized\");\n+      if (vk->contains_oops()) {\n+        add_flat_field_oopmap(nonstatic_oop_maps, vk, f->offset());\n+      }\n+    }\n+  }\n+}\n+\n+void FieldLayoutBuilder::register_embedded_oops(OopMapBlocksBuilder* nonstatic_oop_maps, FieldGroup* group) {\n+  if (group->oop_fields() != nullptr) {\n+    for (int i = 0; i < group->oop_fields()->length(); i++) {\n+      LayoutRawBlock* b = group->oop_fields()->at(i);\n@@ -677,0 +1287,3 @@\n+  register_embedded_oops_from_list(nonstatic_oop_maps, group->big_primitive_fields());\n+  register_embedded_oops_from_list(nonstatic_oop_maps, group->small_primitive_fields());\n+}\n@@ -678,0 +1291,10 @@\n+void FieldLayoutBuilder::epilogue() {\n+  \/\/ Computing oopmaps\n+  OopMapBlocksBuilder* nonstatic_oop_maps =\n+      new OopMapBlocksBuilder(_nonstatic_oopmap_count);\n+  int super_oop_map_count = (_super_klass == nullptr) ? 0 :_super_klass->nonstatic_oop_map_count();\n+  if (super_oop_map_count > 0) {\n+    nonstatic_oop_maps->initialize_inherited_blocks(_super_klass->start_of_nonstatic_oop_maps(),\n+    _super_klass->nonstatic_oop_map_count());\n+  }\n+  register_embedded_oops(nonstatic_oop_maps, _root_group);\n@@ -683,1 +1306,1 @@\n-        nonstatic_oop_maps->add(cg->oop_fields()->at(0)->offset(), cg->oop_count());\n+        register_embedded_oops(nonstatic_oop_maps, cg);\n@@ -687,1 +1310,0 @@\n-\n@@ -703,0 +1325,45 @@\n+  _info->_has_inline_fields = _has_inline_type_fields;\n+  _info->_is_naturally_atomic = _is_naturally_atomic;\n+  if (_is_inline_type) {\n+    _info->_must_be_atomic = _must_be_atomic;\n+    _info->_payload_alignment = _payload_alignment;\n+    _info->_payload_offset = _payload_offset;\n+    _info->_payload_size_in_bytes = _payload_size_in_bytes;\n+    _info->_non_atomic_size_in_bytes = _non_atomic_layout_size_in_bytes;\n+    _info->_non_atomic_alignment = _non_atomic_layout_alignment;\n+    _info->_atomic_layout_size_in_bytes = _atomic_layout_size_in_bytes;\n+    _info->_nullable_layout_size_in_bytes = _nullable_layout_size_in_bytes;\n+    _info->_null_marker_offset = _null_marker_offset;\n+    _info->_null_reset_value_offset = _static_layout->null_reset_value_offset();\n+    _info->_is_empty_inline_klass = _is_empty_inline_class;\n+  }\n+\n+  \/\/ This may be too restrictive, since if all the fields fit in 64\n+  \/\/ bits we could make the decision to align instances of this class\n+  \/\/ to 64-bit boundaries, and load and store them as single words.\n+  \/\/ And on machines which supported larger atomics we could similarly\n+  \/\/ allow larger values to be atomic, if properly aligned.\n+\n+#ifdef ASSERT\n+  \/\/ Tests verifying integrity of field layouts are using the output of -XX:+PrintFieldLayout\n+  \/\/ which prints the details of LayoutRawBlocks used to compute the layout.\n+  \/\/ The code below checks that offsets in the _field_info meta-data match offsets\n+  \/\/ in the LayoutRawBlocks\n+  LayoutRawBlock* b = _layout->blocks();\n+  while(b != _layout->last_block()) {\n+    if (b->block_kind() == LayoutRawBlock::REGULAR || b->block_kind() == LayoutRawBlock::FLAT) {\n+      if (_field_info->adr_at(b->field_index())->offset() != (u4)b->offset()) {\n+        tty->print_cr(\"Offset from field info = %d, offset from block = %d\", (int)_field_info->adr_at(b->field_index())->offset(), b->offset());\n+      }\n+      assert(_field_info->adr_at(b->field_index())->offset() == (u4)b->offset(),\" Must match\");\n+    }\n+    b = b->next_block();\n+  }\n+  b = _static_layout->blocks();\n+  while(b != _static_layout->last_block()) {\n+    if (b->block_kind() == LayoutRawBlock::REGULAR || b->block_kind() == LayoutRawBlock::FLAT) {\n+      assert(_field_info->adr_at(b->field_index())->offset() == (u4)b->offset(),\" Must match\");\n+    }\n+    b = b->next_block();\n+  }\n+#endif \/\/ ASSERT\n@@ -704,1 +1371,4 @@\n-  if (PrintFieldLayout) {\n+  static bool first_layout_print = true;\n+\n+\n+  if (PrintFieldLayout || (PrintInlineLayout && _has_flattening_information)) {\n@@ -706,7 +1376,42 @@\n-    tty->print_cr(\"Layout of class %s\", _classname->as_C_string());\n-    tty->print_cr(\"Instance fields:\");\n-    _layout->print(tty, false, _super_klass);\n-    tty->print_cr(\"Static fields:\");\n-    _static_layout->print(tty, true, nullptr);\n-    tty->print_cr(\"Instance size = %d bytes\", _info->_instance_size * wordSize);\n-    tty->print_cr(\"---\");\n+    stringStream st;\n+    if (first_layout_print) {\n+      st.print_cr(\"Field layout log format: @offset size\/alignment [name] [signature] [comment]\");\n+      st.print_cr(\"Heap oop size = %d\", heapOopSize);\n+      first_layout_print = false;\n+    }\n+    if (_super_klass != nullptr) {\n+      st.print_cr(\"Layout of class %s@%p extends %s@%p\", _classname->as_C_string(),\n+                    _loader_data, _super_klass->name()->as_C_string(), _super_klass->class_loader_data());\n+    } else {\n+      st.print_cr(\"Layout of class %s@%p\", _classname->as_C_string(), _loader_data);\n+    }\n+    st.print_cr(\"Instance fields:\");\n+    _layout->print(&st, false, _super_klass, _inline_layout_info_array);\n+    st.print_cr(\"Static fields:\");\n+    _static_layout->print(&st, true, nullptr, _inline_layout_info_array);\n+    st.print_cr(\"Instance size = %d bytes\", _info->_instance_size * wordSize);\n+    if (_is_inline_type) {\n+      st.print_cr(\"First field offset = %d\", _payload_offset);\n+      st.print_cr(\"Payload layout: %d\/%d\", _payload_size_in_bytes, _payload_alignment);\n+      if (has_non_atomic_flat_layout()) {\n+        st.print_cr(\"Non atomic flat layout: %d\/%d\", _non_atomic_layout_size_in_bytes, _non_atomic_layout_alignment);\n+      } else {\n+        st.print_cr(\"Non atomic flat layout: -\/-\");\n+      }\n+      if (has_atomic_layout()) {\n+        st.print_cr(\"Atomic flat layout: %d\/%d\", _atomic_layout_size_in_bytes, _atomic_layout_size_in_bytes);\n+      } else {\n+        st.print_cr(\"Atomic flat layout: -\/-\");\n+      }\n+      if (has_nullable_atomic_layout()) {\n+        st.print_cr(\"Nullable flat layout: %d\/%d\", _nullable_layout_size_in_bytes, _nullable_layout_size_in_bytes);\n+      } else {\n+        st.print_cr(\"Nullable flat layout: -\/-\");\n+      }\n+      if (_null_marker_offset != -1) {\n+        st.print_cr(\"Null marker offset = %d\", _null_marker_offset);\n+      }\n+    }\n+    st.print_cr(\"---\");\n+    \/\/ Print output all together.\n+    tty->print_raw(st.as_string());\n@@ -717,1 +1422,5 @@\n-  compute_regular_layout();\n+  if (_is_inline_type || _is_abstract_value) {\n+    compute_inline_class_layout();\n+  } else {\n+    compute_regular_layout();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":844,"deletions":135,"binary":false,"changes":979,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -57,1 +59,1 @@\n-#include \"oops\/instanceMirrorKlass.hpp\"\n+#include \"oops\/instanceMirrorKlass.inline.hpp\"\n@@ -1088,1 +1090,9 @@\n-    if (k->is_typeArray_klass()) {\n+    if (k->is_flatArray_klass()) {\n+      Klass* element_klass = (Klass*) FlatArrayKlass::cast(k)->element_klass();\n+      assert(element_klass->is_inline_klass(), \"Must be inline type component\");\n+      if (is_scratch) {\n+        comp_mirror = Handle(THREAD, HeapShared::scratch_java_mirror(element_klass));\n+      } else {\n+        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+      }\n+    } else if (k->is_typeArray_klass()) {\n@@ -1097,0 +1107,1 @@\n+      assert(!k->is_refArray_klass() || !k->is_flatArray_klass(), \"Must not have mirror\");\n@@ -1099,0 +1110,1 @@\n+      oop comp_oop = element_klass->java_mirror();\n@@ -1102,1 +1114,1 @@\n-        comp_mirror = Handle(THREAD, element_klass->java_mirror());\n+        comp_mirror = Handle(THREAD, comp_oop);\n@@ -1132,1 +1144,0 @@\n-\n@@ -1136,0 +1147,9 @@\n+\n+    if (k->is_refined_objArray_klass()) {\n+      Klass* super_klass = k->super();\n+      assert(super_klass != nullptr, \"Must be\");\n+      Handle mirror(THREAD, super_klass->java_mirror());\n+      k->set_java_mirror(mirror);\n+      return;\n+    }\n+\n@@ -1158,0 +1178,1 @@\n+\n@@ -1180,3 +1201,3 @@\n-  if (k->class_loader() != nullptr &&\n-      k->class_loader() != SystemDictionary::java_platform_loader() &&\n-      k->class_loader() != SystemDictionary::java_system_loader()) {\n+  if ((k->class_loader() != nullptr &&\n+       k->class_loader() != SystemDictionary::java_platform_loader() &&\n+       k->class_loader() != SystemDictionary::java_system_loader())) {\n@@ -1221,1 +1242,0 @@\n-  assert(as_Klass(m) == k, \"must be\");\n@@ -1225,0 +1245,1 @@\n+    assert(as_Klass(m) == k, \"must be\");\n@@ -1234,0 +1255,4 @@\n+  } else {\n+    ObjArrayKlass* objarray_k = (ObjArrayKlass*)as_Klass(m);\n+    \/\/ Mirror should be restored for an ObjArrayKlass or one of its refined array klasses\n+    assert(objarray_k == k || objarray_k->next_refined_array_klass() == k, \"must be\");\n@@ -1412,1 +1437,3 @@\n-  if (is_instance)  st->print(\"L\");\n+  if (is_instance)  {\n+    st->print(\"L\");\n+  }\n@@ -1471,0 +1498,1 @@\n+  assert(!klass->is_refined_objArray_klass(), \"should not be ref or flat array klass\");\n@@ -2870,1 +2898,1 @@\n-      if (method->name() == vmSymbols::object_initializer_name() &&\n+      if (method->is_object_constructor() &&\n@@ -3229,2 +3257,2 @@\n-  if (m->is_object_initializer()) {\n-    flags |= java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR;\n+  if (m->is_object_constructor()) {\n+    flags |= java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR;\n@@ -3621,1 +3649,1 @@\n-int java_lang_reflect_Field::_trusted_final_offset;\n+int java_lang_reflect_Field::_flags_offset;\n@@ -3631,1 +3659,1 @@\n-  macro(_trusted_final_offset,    k, vmSymbols::trusted_final_name(),    bool_signature,       false); \\\n+  macro(_flags_offset,     k, vmSymbols::flags_name(),     int_signature,    false); \\\n@@ -3696,2 +3724,2 @@\n-void java_lang_reflect_Field::set_trusted_final(oop field) {\n-  field->bool_field_put(_trusted_final_offset, true);\n+void java_lang_reflect_Field::set_flags(oop field, int value) {\n+  field->int_field_put(_flags_offset, value);\n@@ -4000,2 +4028,1 @@\n-int java_lang_boxing_object::_value_offset;\n-int java_lang_boxing_object::_long_value_offset;\n+int* java_lang_boxing_object::_offsets;\n@@ -4003,3 +4030,9 @@\n-#define BOXING_FIELDS_DO(macro) \\\n-  macro(_value_offset,      integerKlass, \"value\", int_signature, false); \\\n-  macro(_long_value_offset, longKlass, \"value\", long_signature, false);\n+#define BOXING_FIELDS_DO(macro)                                                                                                    \\\n+  macro(java_lang_boxing_object::_offsets[T_BOOLEAN - T_BOOLEAN], vmClasses::Boolean_klass(),   \"value\", bool_signature,   false); \\\n+  macro(java_lang_boxing_object::_offsets[T_CHAR - T_BOOLEAN],    vmClasses::Character_klass(), \"value\", char_signature,   false); \\\n+  macro(java_lang_boxing_object::_offsets[T_FLOAT - T_BOOLEAN],   vmClasses::Float_klass(),     \"value\", float_signature,  false); \\\n+  macro(java_lang_boxing_object::_offsets[T_DOUBLE - T_BOOLEAN],  vmClasses::Double_klass(),    \"value\", double_signature, false); \\\n+  macro(java_lang_boxing_object::_offsets[T_BYTE - T_BOOLEAN],    vmClasses::Byte_klass(),      \"value\", byte_signature,   false); \\\n+  macro(java_lang_boxing_object::_offsets[T_SHORT - T_BOOLEAN],   vmClasses::Short_klass(),     \"value\", short_signature,  false); \\\n+  macro(java_lang_boxing_object::_offsets[T_INT - T_BOOLEAN],     vmClasses::Integer_klass(),   \"value\", int_signature,    false); \\\n+  macro(java_lang_boxing_object::_offsets[T_LONG - T_BOOLEAN],    vmClasses::Long_klass(),      \"value\", long_signature,   false);\n@@ -4008,2 +4041,2 @@\n-  InstanceKlass* integerKlass = vmClasses::Integer_klass();\n-  InstanceKlass* longKlass = vmClasses::Long_klass();\n+  assert(T_LONG - T_BOOLEAN == 7, \"Sanity check\");\n+  java_lang_boxing_object::_offsets = NEW_C_HEAP_ARRAY(int, 8, mtInternal);\n@@ -4015,0 +4048,4 @@\n+  if (f->reading()) {\n+    assert(T_LONG - T_BOOLEAN == 7, \"Sanity check\");\n+    java_lang_boxing_object::_offsets = NEW_C_HEAP_ARRAY(int, 8, mtInternal);\n+  }\n@@ -4035,1 +4072,1 @@\n-      box->bool_field_put(_value_offset, value->z);\n+      box->bool_field_put(value_offset(type), value->z);\n@@ -4038,1 +4075,1 @@\n-      box->char_field_put(_value_offset, value->c);\n+      box->char_field_put(value_offset(type), value->c);\n@@ -4041,1 +4078,1 @@\n-      box->float_field_put(_value_offset, value->f);\n+      box->float_field_put(value_offset(type), value->f);\n@@ -4044,1 +4081,1 @@\n-      box->double_field_put(_long_value_offset, value->d);\n+      box->double_field_put(value_offset(type), value->d);\n@@ -4047,1 +4084,1 @@\n-      box->byte_field_put(_value_offset, value->b);\n+      box->byte_field_put(value_offset(type), value->b);\n@@ -4050,1 +4087,1 @@\n-      box->short_field_put(_value_offset, value->s);\n+      box->short_field_put(value_offset(type), value->s);\n@@ -4053,1 +4090,1 @@\n-      box->int_field_put(_value_offset, value->i);\n+      box->int_field_put(value_offset(type), value->i);\n@@ -4056,1 +4093,1 @@\n-      box->long_field_put(_long_value_offset, value->j);\n+      box->long_field_put(value_offset(type), value->j);\n@@ -4078,1 +4115,1 @@\n-    value->z = box->bool_field(_value_offset);\n+    value->z = box->bool_field(value_offset(type));\n@@ -4081,1 +4118,1 @@\n-    value->c = box->char_field(_value_offset);\n+    value->c = box->char_field(value_offset(type));\n@@ -4084,1 +4121,1 @@\n-    value->f = box->float_field(_value_offset);\n+    value->f = box->float_field(value_offset(type));\n@@ -4087,1 +4124,1 @@\n-    value->d = box->double_field(_long_value_offset);\n+    value->d = box->double_field(value_offset(type));\n@@ -4090,1 +4127,1 @@\n-    value->b = box->byte_field(_value_offset);\n+    value->b = box->byte_field(value_offset(type));\n@@ -4093,1 +4130,1 @@\n-    value->s = box->short_field(_value_offset);\n+    value->s = box->short_field(value_offset(type));\n@@ -4096,1 +4133,1 @@\n-    value->i = box->int_field(_value_offset);\n+    value->i = box->int_field(value_offset(type));\n@@ -4099,1 +4136,1 @@\n-    value->j = box->long_field(_long_value_offset);\n+    value->j = box->long_field(value_offset(type));\n@@ -4112,1 +4149,1 @@\n-    box->bool_field_put(_value_offset, value->z);\n+    box->bool_field_put(value_offset(type), value->z);\n@@ -4115,1 +4152,1 @@\n-    box->char_field_put(_value_offset, value->c);\n+    box->char_field_put(value_offset(type), value->c);\n@@ -4118,1 +4155,1 @@\n-    box->float_field_put(_value_offset, value->f);\n+    box->float_field_put(value_offset(type), value->f);\n@@ -4121,1 +4158,1 @@\n-    box->double_field_put(_long_value_offset, value->d);\n+    box->double_field_put(value_offset(type), value->d);\n@@ -4124,1 +4161,1 @@\n-    box->byte_field_put(_value_offset, value->b);\n+    box->byte_field_put(value_offset(type), value->b);\n@@ -4127,1 +4164,1 @@\n-    box->short_field_put(_value_offset, value->s);\n+    box->short_field_put(value_offset(type), value->s);\n@@ -4130,1 +4167,1 @@\n-    box->int_field_put(_value_offset, value->i);\n+    box->int_field_put(value_offset(type), value->i);\n@@ -4133,1 +4170,1 @@\n-    box->long_field_put(_long_value_offset, value->j);\n+    box->long_field_put(value_offset(type), value->j);\n@@ -4529,1 +4566,0 @@\n-\n@@ -4539,1 +4575,1 @@\n-  return (flags(mname) & (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) > 0;\n+  return (flags(mname) & (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) > 0;\n@@ -5532,16 +5568,11 @@\n-#define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \\\n-  valid &= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)\n-\n-#define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \\\n-  valid &= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)\n-\n-  \/\/ Boxed primitive objects (java_lang_boxing_object)\n-\n-  CHECK_OFFSET(\"java\/lang\/Boolean\",   java_lang_boxing_object, value, \"Z\");\n-  CHECK_OFFSET(\"java\/lang\/Character\", java_lang_boxing_object, value, \"C\");\n-  CHECK_OFFSET(\"java\/lang\/Float\",     java_lang_boxing_object, value, \"F\");\n-  CHECK_LONG_OFFSET(\"java\/lang\/Double\", java_lang_boxing_object, value, \"D\");\n-  CHECK_OFFSET(\"java\/lang\/Byte\",      java_lang_boxing_object, value, \"B\");\n-  CHECK_OFFSET(\"java\/lang\/Short\",     java_lang_boxing_object, value, \"S\");\n-  CHECK_OFFSET(\"java\/lang\/Integer\",   java_lang_boxing_object, value, \"I\");\n-  CHECK_LONG_OFFSET(\"java\/lang\/Long\", java_lang_boxing_object, value, \"J\");\n+#define CHECK_OFFSET(klass_name, type, field_sig) \\\n+  valid &= check_offset(klass_name, java_lang_boxing_object::value_offset(type), \"value\", field_sig)\n+\n+  CHECK_OFFSET(\"java\/lang\/Boolean\",   T_BOOLEAN, \"Z\");\n+  CHECK_OFFSET(\"java\/lang\/Character\", T_CHAR,    \"C\");\n+  CHECK_OFFSET(\"java\/lang\/Float\",     T_FLOAT,   \"F\");\n+  CHECK_OFFSET(\"java\/lang\/Double\",    T_DOUBLE,  \"D\");\n+  CHECK_OFFSET(\"java\/lang\/Byte\",      T_BYTE,    \"B\");\n+  CHECK_OFFSET(\"java\/lang\/Short\",     T_SHORT,   \"S\");\n+  CHECK_OFFSET(\"java\/lang\/Integer\",   T_INT,     \"I\");\n+  CHECK_OFFSET(\"java\/lang\/Long\",      T_LONG,    \"J\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":96,"deletions":65,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -74,0 +76,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -188,0 +191,15 @@\n+\/\/ These migrated value classes are loaded by the bootstrap class loader but are added to the initiating\n+\/\/ loaders automatically so that fields of these types can be found and potentially flattened during\n+\/\/ field layout.\n+static void add_migrated_value_classes(ClassLoaderData* cld) {\n+  JavaThread* current = JavaThread::current();\n+  auto add_klass = [&] (Symbol* classname) {\n+    InstanceKlass* ik = SystemDictionary::find_instance_klass(current, classname, Handle(current, nullptr));\n+    assert(ik != nullptr, \"Must exist\");\n+    SystemDictionary::add_to_initiating_loader(current, ik, cld);\n+  };\n+\n+  MonitorLocker mu1(SystemDictionary_lock);\n+  vmSymbols::migrated_class_names_do(add_klass);\n+}\n+\n@@ -193,2 +211,9 @@\n-    return (class_loader() == nullptr) ? ClassLoaderData::the_null_class_loader_data() :\n-                                      ClassLoaderDataGraph::find_or_create(class_loader);\n+    if (class_loader() == nullptr) {\n+      return ClassLoaderData::the_null_class_loader_data();\n+    } else {\n+      ClassLoaderData* cld = ClassLoaderDataGraph::find_or_create(class_loader);\n+      if (EnableValhalla) {\n+        add_migrated_value_classes(cld);\n+      }\n+      return cld;\n+    }\n@@ -397,1 +422,2 @@\n-\/\/ during class definition to allow class circularity checking\n+\/\/ during class definition, or may be called for inline field layout processing\n+\/\/ to detect class circularity errors.\n@@ -410,0 +436,2 @@\n+\/\/ inline field layout callers:\n+\/\/    The field's class must be loaded to determine layout.\n@@ -413,1 +441,1 @@\n-\/\/ placeholder for the same thread, class, classloader is found.\n+\/\/ placeholder for the same thread, class, and classloader is found.\n@@ -448,1 +476,1 @@\n-    \/\/ Must check ClassCircularity before resolving next_name (superclass or interface).\n+    \/\/ Must check ClassCircularity before resolving next_name (superclass, interface, field types or speculatively preloaded argument types).\n@@ -472,1 +500,1 @@\n-  \/\/ Resolve the superclass or superinterface, check results on return\n+  \/\/ Resolve the superclass, superinterface, field type or speculatively preloaded argument types and check results on return.\n@@ -918,2 +946,1 @@\n-  assert(!ModuleEntryTable::javabase_moduleEntry()->is_patched(),\n-         \"Cannot use sharing if java.base is patched\");\n+  assert(!CDSConfig::module_patching_disables_cds(), \"Cannot use CDS\");\n@@ -995,1 +1022,1 @@\n-        assert(!mod_entry->is_patched(), \"cannot load archived classes for patched module\");\n+        assert(!CDSConfig::module_patching_disables_cds(), \"Cannot use CDS\");\n@@ -1073,0 +1100,69 @@\n+\/\/ Pre-load class referred to in non-static null-free instance field. These fields trigger MANDATORY loading.\n+\/\/ Some pre-loading does not fail fatally\n+bool SystemDictionary::preload_from_null_free_field(InstanceKlass* ik, Handle class_loader, Symbol* sig, int field_index, TRAPS) {\n+  TempNewSymbol name = Signature::strip_envelope(sig);\n+  log_info(class, preload)(\"Preloading of class %s during loading of shared class %s. \"\n+                           \"Cause: a null-free non-static field is declared with this type\",\n+                           name->as_C_string(), ik->name()->as_C_string());\n+  InstanceKlass* real_k = SystemDictionary::resolve_with_circularity_detection(ik->name(), name,\n+                                                                               class_loader, false, CHECK_false);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_warning(class, preload)(\"Preloading of class %s during loading of class %s \"\n+                                \"(cause: null-free non-static field) failed: %s\",\n+                                name->as_C_string(), ik->name()->as_C_string(),\n+                                PENDING_EXCEPTION->klass()->name()->as_C_string());\n+    return false; \/\/ Exception is still pending\n+  }\n+\n+  InstanceKlass* k = ik->get_inline_type_field_klass_or_null(field_index);\n+  if (real_k != k) {\n+    \/\/ oops, the app has substituted a different version of k! Does not fail fatally\n+    log_warning(class, preload)(\"Preloading of class %s during loading of shared class %s \"\n+                                \"(cause: null-free non-static field) failed : \"\n+                                \"app substituted a different version of %s\",\n+                                name->as_C_string(), ik->name()->as_C_string(),\n+                                name->as_C_string());\n+    return false;\n+  }\n+  log_info(class, preload)(\"Preloading of class %s during loading of shared class %s \"\n+                           \"(cause: null-free non-static field) succeeded\",\n+                           name->as_C_string(), ik->name()->as_C_string());\n+\n+  assert(real_k != nullptr, \"Sanity check\");\n+  InstanceKlass::check_can_be_annotated_with_NullRestricted(real_k, ik->name(), CHECK_false);\n+\n+  return true;\n+}\n+\n+\/\/ Tries to pre-load classes referred to in non-static nullable instance fields if they are found in the\n+\/\/ loadable descriptors attribute. If loading fails, we can fail silently.\n+void SystemDictionary::try_preload_from_loadable_descriptors(InstanceKlass* ik, Handle class_loader, Symbol* sig, int field_index, TRAPS) {\n+  TempNewSymbol name = Signature::strip_envelope(sig);\n+  if (name != ik->name() && ik->is_class_in_loadable_descriptors_attribute(sig)) {\n+    log_info(class, preload)(\"Preloading of class %s during loading of shared class %s. \"\n+                             \"Cause: field type in LoadableDescriptors attribute\",\n+                             name->as_C_string(), ik->name()->as_C_string());\n+    InstanceKlass* real_k = SystemDictionary::resolve_with_circularity_detection(ik->name(), name,\n+                                                                                 class_loader, false, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      CLEAR_PENDING_EXCEPTION;\n+    }\n+\n+    InstanceKlass* k = ik->get_inline_type_field_klass_or_null(field_index);\n+    if (real_k != k) {\n+      \/\/ oops, the app has substituted a different version of k!\n+      log_warning(class, preload)(\"Preloading of class %s during loading of shared class %s \"\n+                                  \"(cause: field type in LoadableDescriptors attribute) failed : \"\n+                                  \"app substituted a different version of %s\",\n+                                  name->as_C_string(), ik->name()->as_C_string(),\n+                                  k->name()->as_C_string());\n+      return;\n+    } else if (real_k != nullptr) {\n+      log_info(class, preload)(\"Preloading of class %s during loading of shared class %s \"\n+                               \"(cause: field type in LoadableDescriptors attribute) succeeded\",\n+                                name->as_C_string(), ik->name()->as_C_string());\n+    }\n+  }\n+}\n+\n+\n@@ -1096,0 +1192,21 @@\n+  if (ik->has_inline_type_fields()) {\n+    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) continue;\n+\n+      Symbol* sig = fs.signature();\n+      int field_index = fs.index();\n+\n+      if (fs.is_null_free_inline_type()) {\n+        \/\/ A false return means that the class didn't load for other reasons than an exception.\n+        bool check = preload_from_null_free_field(ik, class_loader, sig, field_index, CHECK_NULL);\n+        if (!check) {\n+          ik->set_shared_loading_failed();\n+          return nullptr;\n+        }\n+      } else if (Signature::has_envelope(sig)) {\n+          \/\/ Pending exceptions are cleared so we can fail silently\n+          try_preload_from_loadable_descriptors(ik, class_loader, sig, field_index, CHECK_NULL);\n+      }\n+    }\n+  }\n+\n@@ -1131,0 +1248,1 @@\n+\n@@ -1653,1 +1771,0 @@\n-#if INCLUDE_CDS\n@@ -1656,1 +1773,3 @@\n-\/\/ This API should be used only by AOTLinkedClassBulkLoader\n+\/\/ This API is used by AOTLinkedClassBulkLoader and to register boxing\n+\/\/ classes from java.lang in all class loaders to enable more value\n+\/\/ classes optimizations\n@@ -1660,1 +1779,0 @@\n-  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n@@ -1666,2 +1784,3 @@\n-  assert(dictionary->find_class(current, name) == nullptr, \"sanity\");\n-  dictionary->add_klass(current, name, k);\n+  if (dictionary->find_class(current, name) == nullptr) {\n+    dictionary->add_klass(current, name, k);\n+  }\n@@ -1669,1 +1788,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":133,"deletions":15,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -51,1 +52,1 @@\n-#include \"runtime\/fieldDescriptor.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -69,0 +70,1 @@\n+#define INLINE_TYPE_MAJOR_VERSION                       56\n@@ -480,0 +482,3 @@\n+    case BAD_STRICT_FIELDS:\n+      ss->print(\"Invalid use of strict instance fields\");\n+      break;\n@@ -486,0 +491,3 @@\n+    case STRICT_FIELDS_MISMATCH:\n+      ss->print(\"Current frame's strict instance fields not compatible with stackmap.\");\n+      break;\n@@ -498,0 +506,7 @@\n+    case WRONG_INLINE_TYPE:\n+      ss->print(\"Type \");\n+      _type.details(ss);\n+      ss->print(\" and type \");\n+      _expected.details(ss);\n+      ss->print(\" must be identical inline types.\");\n+      break;\n@@ -620,0 +635,5 @@\n+static bool supports_strict_fields(InstanceKlass* klass) {\n+  int ver = klass->major_version();\n+  return ver > Verifier::VALUE_TYPES_MAJOR_VERSION ||\n+         (ver == Verifier::VALUE_TYPES_MAJOR_VERSION && klass->minor_version() == Verifier::JAVA_PREVIEW_MINOR_VERSION);\n+}\n@@ -715,0 +735,15 @@\n+  \/\/ Collect the initial strict instance fields\n+  StackMapFrame::AssertUnsetFieldTable* strict_fields = new StackMapFrame::AssertUnsetFieldTable();\n+  if (m->is_object_constructor()) {\n+    for (AllFieldStream fs(m->method_holder()); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_strict() && !fs.access_flags().is_static()) {\n+        NameAndSig new_field(fs.name(), fs.signature());\n+        if (IgnoreAssertUnsetFields) {\n+          strict_fields->put(new_field, true);\n+        } else {\n+          strict_fields->put(new_field, false);\n+        }\n+      }\n+    }\n+  }\n+\n@@ -716,1 +751,1 @@\n-  StackMapFrame current_frame(max_locals, max_stack, this);\n+  StackMapFrame current_frame(max_locals, max_stack, strict_fields, this);\n@@ -743,1 +778,1 @@\n-  StackMapReader reader(this, &stream, code_data, code_length, &current_frame, max_locals, max_stack, THREAD);\n+  StackMapReader reader(this, &stream, code_data, code_length, &current_frame, max_locals, max_stack, strict_fields, THREAD);\n@@ -1616,1 +1651,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            object_type(), CHECK_VERIFY(this));\n@@ -1621,1 +1656,1 @@\n-            VerificationType::reference_check(), CHECK_VERIFY(this));\n+            object_type(), CHECK_VERIFY(this));\n@@ -1684,1 +1719,1 @@\n-          if (_method->name() == vmSymbols::object_initializer_name() &&\n+          if (_method->is_object_constructor() &&\n@@ -1707,4 +1742,0 @@\n-          verify_invoke_instructions(\n-            &bcs, code_length, &current_frame, (bci >= ex_min && bci < ex_max),\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n-          no_control_flow = false; break;\n@@ -1715,1 +1746,1 @@\n-            &this_uninit, return_type, cp, &stackmap_table, CHECK_VERIFY(this));\n+            &this_uninit, cp, &stackmap_table, CHECK_VERIFY(this));\n@@ -1773,2 +1804,2 @@\n-        case Bytecodes::_monitorexit :\n-          current_frame.pop_stack(\n+        case Bytecodes::_monitorexit : {\n+          VerificationType ref = current_frame.pop_stack(\n@@ -1777,0 +1808,1 @@\n+        }\n@@ -2154,1 +2186,1 @@\n-            | (1 << JVM_CONSTANT_String)  | (1 << JVM_CONSTANT_Class)\n+            | (1 << JVM_CONSTANT_String) | (1 << JVM_CONSTANT_Class)\n@@ -2330,1 +2362,1 @@\n-    (!allow_arrays || !ref_class_type.is_array())) {\n+      (!allow_arrays || !ref_class_type.is_array())) {\n@@ -2337,0 +2369,1 @@\n+\n@@ -2378,1 +2411,1 @@\n-      \/\/ The JVMS 2nd edition allows field initialization before the superclass\n+      \/\/ Field initialization is allowed before the superclass\n@@ -2381,4 +2414,24 @@\n-      if (stack_object_type == VerificationType::uninitialized_this_type() &&\n-          target_class_type.equals(current_type()) &&\n-          _klass->find_local_field(field_name, field_sig, &fd)) {\n-        stack_object_type = current_type();\n+      bool is_local_field = _klass->find_local_field(field_name, field_sig, &fd) &&\n+                            target_class_type.equals(current_type());\n+      if (stack_object_type == VerificationType::uninitialized_this_type()) {\n+        if (is_local_field) {\n+          \/\/ Set the type to the current type so the is_assignable check passes.\n+          stack_object_type = current_type();\n+\n+          if (fd.access_flags().is_strict()) {\n+            ResourceMark rm(THREAD);\n+            if (!current_frame->satisfy_unset_field(fd.name(), fd.signature())) {\n+              log_info(verification)(\"Attempting to initialize field not found in initial strict instance fields: %s%s\",\n+                                     fd.name()->as_C_string(), fd.signature()->as_C_string());\n+              verify_error(ErrorContext::bad_strict_fields(bci, current_frame),\n+                           \"Initializing unknown strict field: %s:%s\", fd.name()->as_C_string(), fd.signature()->as_C_string());\n+            }\n+          }\n+        }\n+      } else if (supports_strict_fields(_klass)) {\n+        \/\/ `strict` fields are not writable, but only local fields produce verification errors\n+        if (is_local_field && fd.access_flags().is_strict() && fd.access_flags().is_final()) {\n+          verify_error(ErrorContext::bad_code(bci),\n+                       \"Illegal use of putfield on a strict field\");\n+          return;\n+        }\n@@ -2666,0 +2719,7 @@\n+    } else if (ref_class_type.name() == superk->name()) {\n+      \/\/ Strict final fields must be satisfied by this point\n+      if (!current_frame->verify_unset_fields_satisfied()) {\n+        log_info(verification)(\"Strict instance fields not initialized\");\n+        StackMapFrame::print_strict_fields(current_frame->assert_unset_fields());\n+        current_frame->unsatisfied_strict_fields_error(current_class(), bci);\n+      }\n@@ -2789,1 +2849,1 @@\n-    bool in_try_block, bool *this_uninit, VerificationType return_type,\n+    bool in_try_block, bool *this_uninit,\n@@ -2821,1 +2881,1 @@\n-  \/\/ Get referenced class type\n+  \/\/ Get referenced class\n@@ -2887,1 +2947,2 @@\n-    \/\/ Make sure <init> can only be invoked by invokespecial\n+    \/\/ Make sure:\n+    \/\/   <init> can only be invoked by invokespecial.\n@@ -2889,1 +2950,1 @@\n-        method_name != vmSymbols::object_initializer_name()) {\n+          method_name != vmSymbols::object_initializer_name()) {\n@@ -2899,1 +2960,1 @@\n-           && !ref_class_type.equals(VerificationType::reference_type(current_class()->super()->name()))) {\n+           && !ref_class_type.equals(VerificationType::reference_type(current_class()->super()->name()))) { \/\/ super() can never be an inline_type.\n@@ -2999,3 +3060,1 @@\n-      \/\/ <init> method must have a void return type\n-      \/* Unreachable?  Class file parser verifies that methods with '<' have\n-       * void return *\/\n+      \/\/ an <init> method must have a void return type\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":87,"deletions":28,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+static_assert(!std::is_polymorphic<BufferedInlineTypeBlob>::value,   \"no virtual methods are allowed in code blobs\");\n@@ -94,0 +95,1 @@\n+      &BufferedInlineTypeBlob::_vpntr,\n@@ -429,1 +431,1 @@\n-    blob = new (size) BufferBlob(name, CodeBlobKind::Buffer, cb, size);\n+    blob = new (size) BufferBlob(name, CodeBlobKind::Buffer, cb, size, sizeof(BufferBlob));\n@@ -445,0 +447,4 @@\n+BufferBlob::BufferBlob(const char* name, CodeBlobKind kind, CodeBuffer* cb, int size, uint16_t header_size, int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments)\n+  : RuntimeBlob(name, kind, cb, size, header_size, frame_complete, frame_size, oop_maps, caller_must_gc_arguments)\n+{}\n+\n@@ -449,2 +455,2 @@\n-AdapterBlob::AdapterBlob(int size, CodeBuffer* cb, int entry_offset[AdapterBlob::ENTRY_COUNT]) :\n-  BufferBlob(\"I2C\/C2I adapters\", CodeBlobKind::Adapter, cb, size, sizeof(AdapterBlob)) {\n+AdapterBlob::AdapterBlob(int size, CodeBuffer* cb, int entry_offset[AdapterBlob::ENTRY_COUNT], int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) :\n+  BufferBlob(\"I2C\/C2I adapters\", CodeBlobKind::Adapter, cb, size, sizeof(AdapterBlob), frame_complete, frame_size, oop_maps, caller_must_gc_arguments) {\n@@ -459,2 +465,5 @@\n-  _c2i_unverified_offset = entry_offset[2];\n-  _c2i_no_clinit_check_offset = entry_offset[3];\n+  _c2i_inline_offset = entry_offset[2];\n+  _c2i_inline_ro_offset = entry_offset[3];\n+  _c2i_unverified_offset = entry_offset[4];\n+  _c2i_unverified_inline_offset = entry_offset[5];\n+  _c2i_no_clinit_check_offset = entry_offset[6];\n@@ -464,1 +473,1 @@\n-AdapterBlob* AdapterBlob::create(CodeBuffer* cb, int entry_offset[AdapterBlob::ENTRY_COUNT]) {\n+AdapterBlob* AdapterBlob::create(CodeBuffer* cb, int entry_offset[AdapterBlob::ENTRY_COUNT], int frame_complete, int frame_size, OopMapSet* oop_maps, bool caller_must_gc_arguments) {\n@@ -473,1 +482,1 @@\n-    blob = new (size) AdapterBlob(size, cb, entry_offset);\n+    blob = new (size) AdapterBlob(size, cb, entry_offset, frame_complete, frame_size, oop_maps, caller_must_gc_arguments);\n@@ -484,2 +493,5 @@\n-  entry_offset[2] = _c2i_unverified_offset;\n-  entry_offset[3] = _c2i_no_clinit_check_offset;\n+  entry_offset[2] = _c2i_inline_offset;\n+  entry_offset[3] = _c2i_inline_ro_offset;\n+  entry_offset[4] = _c2i_unverified_offset;\n+  entry_offset[5] = _c2i_unverified_inline_offset;\n+  entry_offset[6] = _c2i_no_clinit_check_offset;\n@@ -562,0 +574,25 @@\n+\/\/ Implementation of BufferedInlineTypeBlob\n+BufferedInlineTypeBlob::BufferedInlineTypeBlob(int size, CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off) :\n+  BufferBlob(\"buffered inline type\", CodeBlobKind::BufferedInlineType, cb, size, sizeof(BufferedInlineTypeBlob)),\n+  _pack_fields_off(pack_fields_off),\n+  _pack_fields_jobject_off(pack_fields_jobject_off),\n+  _unpack_fields_off(unpack_fields_off) {\n+  CodeCache::commit(this);\n+}\n+\n+BufferedInlineTypeBlob* BufferedInlineTypeBlob::create(CodeBuffer* cb, int pack_fields_off, int pack_fields_jobject_off, int unpack_fields_off) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  BufferedInlineTypeBlob* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(BufferedInlineTypeBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) BufferedInlineTypeBlob(size, cb, pack_fields_off, pack_fields_jobject_off, unpack_fields_off);\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n+\n+\/\/----------------------------------------------------------------------------------------------------\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -723,0 +723,11 @@\n+\n+      \/\/ If inline types are passed as fields, use the extended signature\n+      \/\/ which contains the types of all (oop) fields of the inline type.\n+      if (is_compiled_by_c2() && callee->has_scalarized_args()) {\n+        const GrowableArray<SigEntry>* sig = callee->adapter()->get_sig_cc();\n+        assert(sig != nullptr, \"sig should never be null\");\n+        TempNewSymbol tmp_sig = SigEntry::create_symbol(sig);\n+        has_receiver = false; \/\/ The extended signature contains the receiver type\n+        fr.oops_compiled_arguments_do(tmp_sig, has_receiver, has_appendix, reg_map, f);\n+        return;\n+      }\n@@ -1259,0 +1270,4 @@\n+  _inline_entry_point             = entry_point();\n+  _verified_inline_entry_point    = verified_entry_point();\n+  _verified_inline_ro_entry_point = verified_entry_point();\n+\n@@ -1298,1 +1313,1 @@\n-\n+    assert(!method->has_scalarized_args(), \"scalarized native wrappers not supported yet\");\n@@ -1502,0 +1517,4 @@\n+    _inline_entry_point             = code_begin() + offsets->value(CodeOffsets::Inline_Entry);\n+    _verified_inline_entry_point    = code_begin() + offsets->value(CodeOffsets::Verified_Inline_Entry);\n+    _verified_inline_ro_entry_point = code_begin() + offsets->value(CodeOffsets::Verified_Inline_Entry_RO);\n+\n@@ -3719,0 +3738,1 @@\n+  if (pos == inline_entry_point())                                      label = \"[Inline Entry Point]\";\n@@ -3720,0 +3740,2 @@\n+  if (pos == verified_inline_entry_point())                             label = \"[Verified Inline Entry Point]\";\n+  if (pos == verified_inline_ro_entry_point())                          label = \"[Verified Inline Entry Point (RO)]\";\n@@ -3729,0 +3751,10 @@\n+static int maybe_print_entry_label(outputStream* stream, address pos, address entry, const char* label) {\n+  if (pos == entry) {\n+    stream->bol();\n+    stream->print_cr(\"%s\", label);\n+    return 1;\n+  } else {\n+    return 0;\n+  }\n+}\n+\n@@ -3731,33 +3763,12 @@\n-    const char* label = nmethod_section_label(block_begin);\n-    if (label != nullptr) {\n-      stream->bol();\n-      stream->print_cr(\"%s\", label);\n-    }\n-  }\n-\n-  if (block_begin == entry_point()) {\n-    Method* m = method();\n-    if (m != nullptr) {\n-      stream->print(\"  # \");\n-      m->print_value_on(stream);\n-      stream->cr();\n-    }\n-    if (m != nullptr && !is_osr_method()) {\n-      ResourceMark rm;\n-      int sizeargs = m->size_of_parameters();\n-      BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);\n-      VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);\n-      {\n-        int sig_index = 0;\n-        if (!m->is_static())\n-          sig_bt[sig_index++] = T_OBJECT; \/\/ 'this'\n-        for (SignatureStream ss(m->signature()); !ss.at_return_type(); ss.next()) {\n-          BasicType t = ss.type();\n-          sig_bt[sig_index++] = t;\n-          if (type2size[t] == 2) {\n-            sig_bt[sig_index++] = T_VOID;\n-          } else {\n-            assert(type2size[t] == 1, \"size is 1 or 2\");\n-          }\n-        }\n-        assert(sig_index == sizeargs, \"\");\n+    int n = 0;\n+    \/\/ Multiple entry points may be at the same position. Print them all.\n+    n += maybe_print_entry_label(stream, block_begin, entry_point(),                    \"[Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, inline_entry_point(),             \"[Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),           \"[Verified Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_entry_point(),    \"[Verified Inline Entry Point]\");\n+    n += maybe_print_entry_label(stream, block_begin, verified_inline_ro_entry_point(), \"[Verified Inline Entry Point (RO)]\");\n+    if (n == 0) {\n+      const char* label = nmethod_section_label(block_begin);\n+      if (label != nullptr) {\n+        stream->bol();\n+        stream->print_cr(\"%s\", label);\n@@ -3765,54 +3776,73 @@\n-      const char* spname = \"sp\"; \/\/ make arch-specific?\n-      SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n-      int stack_slot_offset = this->frame_size() * wordSize;\n-      int tab1 = 14, tab2 = 24;\n-      int sig_index = 0;\n-      int arg_index = (m->is_static() ? 0 : -1);\n-      bool did_old_sp = false;\n-      for (SignatureStream ss(m->signature()); !ss.at_return_type(); ) {\n-        bool at_this = (arg_index == -1);\n-        bool at_old_sp = false;\n-        BasicType t = (at_this ? T_OBJECT : ss.type());\n-        assert(t == sig_bt[sig_index], \"sigs in sync\");\n-        if (at_this)\n-          stream->print(\"  # this: \");\n-        else\n-          stream->print(\"  # parm%d: \", arg_index);\n-        stream->move_to(tab1);\n-        VMReg fst = regs[sig_index].first();\n-        VMReg snd = regs[sig_index].second();\n-        if (fst->is_reg()) {\n-          stream->print(\"%s\", fst->name());\n-          if (snd->is_valid())  {\n-            stream->print(\":%s\", snd->name());\n-          }\n-        } else if (fst->is_stack()) {\n-          int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n-          if (offset == stack_slot_offset)  at_old_sp = true;\n-          stream->print(\"[%s+0x%x]\", spname, offset);\n-        } else {\n-          stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n-        }\n-        stream->print(\" \");\n-        stream->move_to(tab2);\n-        stream->print(\"= \");\n-        if (at_this) {\n-          m->method_holder()->print_value_on(stream);\n-        } else {\n-          bool did_name = false;\n-          if (!at_this && ss.is_reference()) {\n-            Symbol* name = ss.as_symbol();\n-            name->print_value_on(stream);\n-            did_name = true;\n-          }\n-          if (!did_name)\n-            stream->print(\"%s\", type2name(t));\n-        }\n-        if (at_old_sp) {\n-          stream->print(\"  (%s of caller)\", spname);\n-          did_old_sp = true;\n-        }\n-        stream->cr();\n-        sig_index += type2size[t];\n-        arg_index += 1;\n-        if (!at_this)  ss.next();\n+    }\n+  }\n+\n+  Method* m = method();\n+  if (m == nullptr || is_osr_method()) {\n+    return;\n+  }\n+\n+  \/\/ Print the name of the method (only once)\n+  address low = MIN3(entry_point(),\n+                     verified_entry_point(),\n+                     inline_entry_point());\n+  \/\/ The verified inline entry point and verified inline RO entry point are not always\n+  \/\/ used. When they are unused. CodeOffsets::Verified_Inline_Entry(_RO) is -1. Hence,\n+  \/\/ the calculated entry point is smaller than the block they are offsetting into.\n+  if (verified_inline_entry_point() >= block_begin) {\n+    low = MIN2(low, verified_inline_entry_point());\n+  }\n+  if (verified_inline_ro_entry_point() >= block_begin) {\n+    low = MIN2(low, verified_inline_ro_entry_point());\n+  }\n+  assert(low != 0, \"sanity\");\n+  if (block_begin == low) {\n+    stream->print(\"  # \");\n+    m->print_value_on(stream);\n+    stream->cr();\n+  }\n+\n+  \/\/ Print the arguments for the 3 types of verified entry points\n+  CompiledEntrySignature ces(m);\n+  ces.compute_calling_conventions(false);\n+  const GrowableArray<SigEntry>* sig_cc;\n+  const VMRegPair* regs;\n+  if (block_begin == verified_entry_point()) {\n+    sig_cc = ces.sig_cc();\n+    regs = ces.regs_cc();\n+  } else if (block_begin == verified_inline_entry_point()) {\n+    sig_cc = ces.sig();\n+    regs = ces.regs();\n+  } else if (block_begin == verified_inline_ro_entry_point()) {\n+    sig_cc = ces.sig_cc_ro();\n+    regs = ces.regs_cc_ro();\n+  } else {\n+    return;\n+  }\n+\n+  bool has_this = !m->is_static();\n+  if (ces.has_inline_recv() && block_begin == verified_entry_point()) {\n+    \/\/ <this> argument is scalarized for verified_entry_point()\n+    has_this = false;\n+  }\n+  const char* spname = \"sp\"; \/\/ make arch-specific?\n+  int stack_slot_offset = this->frame_size() * wordSize;\n+  int tab1 = 14, tab2 = 24;\n+  int sig_index = 0;\n+  int arg_index = has_this ? -1 : 0;\n+  bool did_old_sp = false;\n+  for (ExtendedSignature sig = ExtendedSignature(sig_cc, SigEntryFilter()); !sig.at_end(); ++sig) {\n+    bool at_this = (arg_index == -1);\n+    bool at_old_sp = false;\n+    BasicType t = (*sig)._bt;\n+    if (at_this) {\n+      stream->print(\"  # this: \");\n+    } else {\n+      stream->print(\"  # parm%d: \", arg_index);\n+    }\n+    stream->move_to(tab1);\n+    VMReg fst = regs[sig_index].first();\n+    VMReg snd = regs[sig_index].second();\n+    if (fst->is_reg()) {\n+      stream->print(\"%s\", fst->name());\n+      if (snd->is_valid())  {\n+        stream->print(\":%s\", snd->name());\n@@ -3820,6 +3850,23 @@\n-      if (!did_old_sp) {\n-        stream->print(\"  # \");\n-        stream->move_to(tab1);\n-        stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n-        stream->print(\"  (%s of caller)\", spname);\n-        stream->cr();\n+    } else if (fst->is_stack()) {\n+      int offset = fst->reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;\n+      if (offset == stack_slot_offset)  at_old_sp = true;\n+      stream->print(\"[%s+0x%x]\", spname, offset);\n+    } else {\n+      stream->print(\"reg%d:%d??\", (int)(intptr_t)fst, (int)(intptr_t)snd);\n+    }\n+    stream->print(\" \");\n+    stream->move_to(tab2);\n+    stream->print(\"= \");\n+    if (at_this) {\n+      m->method_holder()->print_value_on(stream);\n+    } else {\n+      bool did_name = false;\n+      if (is_reference_type(t)) {\n+        Symbol* name = (*sig)._name;\n+        name->print_value_on(stream);\n+        did_name = true;\n+      }\n+      if (!did_name)\n+        stream->print(\"%s\", type2name(t));\n+      if ((*sig)._null_marker) {\n+        stream->print(\" (null marker)\");\n@@ -3828,0 +3875,14 @@\n+    if (at_old_sp) {\n+      stream->print(\"  (%s of caller)\", spname);\n+      did_old_sp = true;\n+    }\n+    stream->cr();\n+    sig_index += type2size[t];\n+    arg_index += 1;\n+  }\n+  if (!did_old_sp) {\n+    stream->print(\"  # \");\n+    stream->move_to(tab1);\n+    stream->print(\"[%s+0x%x]\", spname, stack_slot_offset);\n+    stream->print(\"  (%s of caller)\", spname);\n+    stream->cr();\n@@ -3951,1 +4012,1 @@\n-      st->print(\" {reexecute=%d rethrow=%d return_oop=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop());\n+      st->print(\" {reexecute=%d rethrow=%d return_oop=%d return_scalarized=%d}\", sd->should_reexecute(), sd->rethrow_exception(), sd->return_oop(), sd->return_scalarized());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":156,"deletions":95,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -1286,1 +1286,1 @@\n-          if (vfst.method()->is_static_initializer() ||\n+        if (vfst.method()->is_class_initializer() ||\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"oops\/flatArrayKlass.inline.hpp\"\n@@ -2368,1 +2369,1 @@\n-    cast_to_oop(copy_destination())->init_mark();\n+    cast_to_oop(copy_destination())->reinit_mark();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-        klass->is_objArray_klass() &&\n+        klass->is_refArray_klass() &&\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_BARRIERSETRUNTIME_HPP\n+#define SHARE_GC_SHARED_BARRIERSETRUNTIME_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class oopDesc;\n+class JavaThread;\n+\n+class BarrierSetRuntime: public AllStatic {\n+public:\n+  \/\/ Template interpreter...\n+  static void value_copy(void* src, void* dst, InlineLayoutInfo* layout_info);\n+  static void value_copy_is_dest_uninitialized(void* src, void* dst, InlineLayoutInfo* layout_info);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_BARRIERSETRUNTIME_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetRuntime.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -96,1 +97,12 @@\n-inline bool ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+oop_arraycopy_partial_barrier(BarrierSetT *bs, T* dst_raw, T* p) {\n+  const size_t pd = pointer_delta(p, dst_raw, (size_t)heapOopSize);\n+  \/\/ pointer delta is scaled to number of elements (length field in\n+  \/\/ objArrayOop) which we assume is 32 bit.\n+  assert(pd == (size_t)(int)pd, \"length field overflow\");\n+  bs->write_ref_array((HeapWord*)dst_raw, pd);\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+template <typename T>\n+inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n@@ -105,1 +117,2 @@\n-  if (!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) {\n+  if ((!HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value) &&\n+      (!HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value)) {\n@@ -118,11 +131,11 @@\n-      if (oopDesc::is_instanceof_or_null(CompressedOops::decode(element), bound)) {\n-        bs->template write_ref_field_pre<decorators>(p);\n-        *p = element;\n-      } else {\n-        \/\/ We must do a barrier to cover the partial copy.\n-        const size_t pd = pointer_delta(p, dst_raw, (size_t)heapOopSize);\n-        \/\/ pointer delta is scaled to number of elements (length field in\n-        \/\/ objArrayOop) which we assume is 32 bit.\n-        assert(pd == (size_t)(int)pd, \"length field overflow\");\n-        bs->write_ref_array((HeapWord*)dst_raw, pd);\n-        return false;\n+      \/\/ Apply any required checks\n+      if (HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value && CompressedOops::is_null(element)) {\n+        oop_arraycopy_partial_barrier(bs, dst_raw, p);\n+        throw_array_null_pointer_store_exception(src_obj, dst_obj, JavaThread::current());\n+        return;\n+      }\n+      if (HasDecorator<decorators, ARRAYCOPY_CHECKCAST>::value &&\n+          (!oopDesc::is_instanceof_or_null(CompressedOops::decode(element), bound))) {\n+        oop_arraycopy_partial_barrier(bs, dst_raw, p);\n+        throw_array_store_exception(src_obj, dst_obj, JavaThread::current());\n+        return;\n@@ -130,0 +143,3 @@\n+      \/\/ write\n+      bs->template write_ref_field_pre<decorators>(p);\n+      *p = element;\n@@ -133,1 +149,0 @@\n-  return true;\n@@ -144,0 +159,32 @@\n+template <DecoratorSet decorators, typename BarrierSetT>\n+inline void ModRefBarrierSet::AccessBarrier<decorators, BarrierSetT>::\n+value_copy_in_heap(void* src, void* dst, InlineKlass* md, LayoutKind lk) {\n+  if (HasDecorator<decorators, IS_DEST_UNINITIALIZED>::value || (!md->contains_oops())) {\n+    Raw::value_copy(src, dst, md, lk);\n+  } else {\n+    BarrierSetT* bs = barrier_set_cast<BarrierSetT>(BarrierSet::barrier_set());\n+    \/\/ src\/dst aren't oops, need offset to adjust oop map offset\n+    const address dst_oop_addr_offset = ((address) dst) - md->payload_offset();\n+    typedef typename ValueOopType<decorators>::type OopType;\n+\n+    \/\/ Pre-barriers...\n+    OopMapBlock* map = md->start_of_nonstatic_oop_maps();\n+    OopMapBlock* const end = map + md->nonstatic_oop_map_count();\n+    while (map != end) {\n+      address doop_address = dst_oop_addr_offset + map->offset();\n+      bs->write_ref_array_pre((OopType*) doop_address, map->count(), false);\n+      map++;\n+    }\n+\n+    Raw::value_copy(src, dst, md, lk);\n+\n+    \/\/ Post-barriers...\n+    map = md->start_of_nonstatic_oop_maps();\n+    while (map != end) {\n+      address doop_address = dst_oop_addr_offset + map->offset();\n+      bs->write_ref_array((HeapWord*) doop_address, map->count());\n+      map++;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":61,"deletions":14,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/z\/zAddress.hpp\"\n@@ -35,0 +36,2 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n+#include \"utilities\/copy.hpp\"\n@@ -332,1 +335,1 @@\n-inline void ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_copy_one(zpointer* dst, zpointer* src) {\n+inline ZBarrierSet::OopCopyCheckStatus ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_copy_one(zpointer* dst, zpointer* src) {\n@@ -335,0 +338,4 @@\n+  if (HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value && is_null(obj)) {\n+    return oop_copy_check_null;\n+  }\n+\n@@ -336,0 +343,1 @@\n+  return oop_copy_check_ok;\n@@ -339,1 +347,1 @@\n-inline bool ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_copy_one_check_cast(zpointer* dst, zpointer* src, Klass* dst_klass) {\n+inline ZBarrierSet::OopCopyCheckStatus ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_copy_one_check_cast(zpointer* dst, zpointer* src, Klass* dst_klass) {\n@@ -341,0 +349,1 @@\n+  const bool null_check = HasDecorator<decorators, ARRAYCOPY_NOTNULL>::value;\n@@ -342,1 +351,4 @@\n-  if (!oopDesc::is_instanceof_or_null(to_oop(obj), dst_klass)) {\n+  if (null_check && is_null(obj)) {\n+    return oop_copy_check_null;\n+  }\n+  else if (!oopDesc::is_instanceof_or_null(to_oop(obj), dst_klass)) {\n@@ -344,1 +356,1 @@\n-    return false;\n+    return oop_copy_check_class_cast;\n@@ -349,1 +361,1 @@\n-  return true;\n+  return oop_copy_check_ok;\n@@ -354,1 +366,1 @@\n-inline bool ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap_check_cast(zpointer* dst, zpointer* src, size_t length, Klass* dst_klass) {\n+inline ZBarrierSet::OopCopyCheckStatus ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap_check_cast(zpointer* dst, zpointer* src, size_t length, Klass* dst_klass) {\n@@ -356,5 +368,3 @@\n-  for (const zpointer* const end = src + length; src < end; src++, dst++) {\n-    if (!oop_copy_one_check_cast(dst, src, dst_klass)) {\n-      \/\/ Check cast failed\n-      return false;\n-    }\n+  OopCopyCheckStatus check_status = oop_copy_check_ok;\n+  for (const zpointer* const end = src + length; (check_status == oop_copy_check_ok) && (src < end); src++, dst++) {\n+    check_status = oop_copy_one_check_cast(dst, src, dst_klass);\n@@ -362,2 +372,1 @@\n-\n-  return true;\n+  return check_status;\n@@ -367,1 +376,1 @@\n-inline bool ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap_no_check_cast(zpointer* dst, zpointer* src, size_t length) {\n+inline ZBarrierSet::OopCopyCheckStatus ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap_no_check_cast(zpointer* dst, zpointer* src, size_t length) {\n@@ -369,1 +378,1 @@\n-\n+  OopCopyCheckStatus check_status = oop_copy_check_ok;\n@@ -371,2 +380,2 @@\n-    for (const zpointer* const end = src + length; src < end; src++, dst++) {\n-      oop_copy_one(dst, src);\n+    for (const zpointer* const end = src + length; (check_status == oop_copy_check_ok) && (src < end); src++, dst++) {\n+      check_status = oop_copy_one(dst, src);\n@@ -374,1 +383,1 @@\n-    return true;\n+    return check_status;\n@@ -381,2 +390,2 @@\n-    for ( ; src >= end; src--, dst--) {\n-      oop_copy_one(dst, src);\n+    for ( ; (check_status == oop_copy_check_ok) && (src >= end); src--, dst--) {\n+      check_status = oop_copy_one(dst, src);\n@@ -384,1 +393,1 @@\n-    return true;\n+    return check_status;\n@@ -388,1 +397,1 @@\n-  return true;\n+  return check_status;\n@@ -392,1 +401,1 @@\n-inline bool ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, zpointer* src_raw,\n+inline void ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::oop_arraycopy_in_heap(arrayOop src_obj, size_t src_offset_in_bytes, zpointer* src_raw,\n@@ -397,0 +406,1 @@\n+  OopCopyCheckStatus check_status;\n@@ -400,1 +410,3 @@\n-    return oop_arraycopy_in_heap_check_cast(dst, src, length, dst_klass);\n+    check_status = oop_arraycopy_in_heap_check_cast(dst, src, length, dst_klass);\n+  } else {\n+    check_status = oop_arraycopy_in_heap_no_check_cast(dst, src, length);\n@@ -403,1 +415,13 @@\n-  return oop_arraycopy_in_heap_no_check_cast(dst, src, length);\n+  switch (check_status) {\n+  case oop_copy_check_ok:\n+    return;\n+  case oop_copy_check_class_cast:\n+    throw_array_store_exception(src_obj, dst_obj, JavaThread::current());\n+    break;\n+  case oop_copy_check_null:\n+    throw_array_null_pointer_store_exception(src_obj, dst_obj, JavaThread::current());\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+    return;\n+  }\n@@ -435,1 +459,1 @@\n-  if (dst->is_objArray()) {\n+  if (dst->is_refArray()) {\n@@ -460,0 +484,49 @@\n+static inline void copy_primitive_payload(const void* src, const void* dst, const size_t payload_size_bytes, size_t& copied_bytes) {\n+  if (payload_size_bytes == 0) {\n+    return;\n+  }\n+  void* src_payload = (void*)(address(src) + copied_bytes);\n+  void* dst_payload = (void*)(address(dst) + copied_bytes);\n+  Copy::copy_value_content(src_payload, dst_payload, payload_size_bytes);\n+  copied_bytes += payload_size_bytes;\n+}\n+\n+template <DecoratorSet decorators, typename BarrierSetT>\n+inline void ZBarrierSet::AccessBarrier<decorators, BarrierSetT>::value_copy_in_heap(void* src, void* dst, InlineKlass* md, LayoutKind lk) {\n+  if (md->contains_oops()) {\n+    \/\/ Iterate over each oop map, performing:\n+    \/\/   1) possibly raw copy for any primitive payload before each map\n+    \/\/   2) load and store barrier for each oop\n+    \/\/   3) possibly raw copy for any primitive payload trailer\n+\n+    \/\/ src\/dst may not be oops, need offset to adjust oop map offset\n+    const address src_oop_addr_offset = ((address) src) - md->payload_offset();\n+    OopMapBlock* map = md->start_of_nonstatic_oop_maps();\n+    const OopMapBlock* const end = map + md->nonstatic_oop_map_count();\n+    size_t size_in_bytes = md->layout_size_in_bytes(lk);\n+    size_t copied_bytes = 0;\n+    while (map != end) {\n+      zpointer *src_p = (zpointer*)(src_oop_addr_offset + map->offset());\n+      const uintptr_t oop_offset = uintptr_t(src_p) - uintptr_t(src);\n+      zpointer *dst_p = (zpointer*)(uintptr_t(dst) + oop_offset);\n+\n+      \/\/ Copy any leading primitive payload before every cluster of oops\n+      assert(copied_bytes < oop_offset || copied_bytes == oop_offset, \"Negative sized leading payload segment\");\n+      copy_primitive_payload(src, dst, oop_offset - copied_bytes, copied_bytes);\n+\n+      \/\/ Copy a cluster of oops\n+      for (const zpointer* const src_end = src_p + map->count(); src_p < src_end; src_p++, dst_p++) {\n+        oop_copy_one(dst_p, src_p);\n+        copied_bytes += sizeof(zpointer);\n+      }\n+      map++;\n+    }\n+\n+    \/\/ Copy trailing primitive payload after potential oops\n+    assert(copied_bytes < size_in_bytes || copied_bytes == size_in_bytes, \"Negative sized trailing payload segment\");\n+    copy_primitive_payload(src, dst, size_in_bytes - copied_bytes, copied_bytes);\n+  } else {\n+    Raw::value_copy_in_heap(src, dst, md, lk);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":100,"deletions":27,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n@@ -48,1 +49,1 @@\n-  return obj->klass()->is_objArray_klass() && is_invisible_object(obj);\n+  return obj->klass()->is_refArray_klass() && is_invisible_object(obj);\n@@ -71,1 +72,2 @@\n-  obj->oop_iterate_range(cl, start, end);\n+  assert(obj->is_refArray(), \"Must be\");\n+  refArrayOop(obj)->oop_iterate_range(cl, start, end);\n","filename":"src\/hotspot\/share\/gc\/z\/zIterator.inline.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -47,0 +48,3 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -78,0 +82,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -228,0 +233,32 @@\n+JRT_ENTRY(void, InterpreterRuntime::read_flat_field(JavaThread* current, oopDesc* obj, ResolvedFieldEntry* entry))\n+  assert(oopDesc::is_oop(obj), \"Sanity check\");\n+  Handle obj_h(THREAD, obj);\n+\n+  InstanceKlass* holder = InstanceKlass::cast(entry->field_holder());\n+  assert(entry->field_holder()->field_is_flat(entry->field_index()), \"Sanity check\");\n+\n+  InlineLayoutInfo* layout_info = holder->inline_layout_info_adr(entry->field_index());\n+  InlineKlass* field_vklass = layout_info->klass();\n+\n+#ifdef ASSERT\n+  fieldDescriptor fd;\n+  bool found = holder->find_field_from_offset(entry->field_offset(), false, &fd);\n+  assert(found, \"Field not found\");\n+  assert(fd.is_flat(), \"Field must be flat\");\n+#endif \/\/ ASSERT\n+\n+  oop res = field_vklass->read_payload_from_addr(obj_h(), entry->field_offset(), layout_info->kind(), CHECK);\n+  current->set_vm_result_oop(res);\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::write_flat_field(JavaThread* current, oopDesc* obj, oopDesc* value, ResolvedFieldEntry* entry))\n+  assert(oopDesc::is_oop(obj), \"Sanity check\");\n+  Handle obj_h(THREAD, obj);\n+  assert(value == nullptr || oopDesc::is_oop(value), \"Sanity check\");\n+  Handle val_h(THREAD, value);\n+\n+  InstanceKlass* holder = entry->field_holder();\n+  InlineLayoutInfo* li = holder->inline_layout_info_adr(entry->field_index());\n+  InlineKlass* vk = li->klass();\n+  vk->write_value_to_addr(val_h(), ((char*)(oopDesc*)obj_h()) + entry->field_offset(), li->kind(), true, CHECK);\n+JRT_END\n@@ -237,1 +274,1 @@\n-  objArrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n+  arrayOop obj = oopFactory::new_objArray(klass, size, CHECK);\n@@ -241,0 +278,12 @@\n+JRT_ENTRY(void, InterpreterRuntime::flat_array_load(JavaThread* current, arrayOopDesc* array, int index))\n+  assert(array->is_flatArray(), \"Must be\");\n+  flatArrayOop farray = (flatArrayOop)array;\n+  oop res = farray->obj_at(index, CHECK);\n+  current->set_vm_result_oop(res);\n+JRT_END\n+\n+JRT_ENTRY(void, InterpreterRuntime::flat_array_store(JavaThread* current, oopDesc* val, arrayOopDesc* array, int index))\n+  assert(array->is_flatArray(), \"Must be\");\n+  flatArrayOop farray = (flatArrayOop)array;\n+  farray->obj_at_put(index, val, CHECK);\n+JRT_END\n@@ -246,2 +295,2 @@\n-  int          i = last_frame.get_index_u2(Bytecodes::_multianewarray);\n-  Klass* klass   = constants->klass_at(i, CHECK);\n+  int i = last_frame.get_index_u2(Bytecodes::_multianewarray);\n+  Klass* klass = constants->klass_at(i, CHECK);\n@@ -276,0 +325,24 @@\n+JRT_ENTRY(jboolean, InterpreterRuntime::is_substitutable(JavaThread* current, oopDesc* aobj, oopDesc* bobj))\n+  assert(oopDesc::is_oop(aobj) && oopDesc::is_oop(bobj), \"must be valid oops\");\n+\n+  Handle ha(THREAD, aobj);\n+  Handle hb(THREAD, bobj);\n+  JavaValue result(T_BOOLEAN);\n+  JavaCallArguments args;\n+  args.push_oop(ha);\n+  args.push_oop(hb);\n+  methodHandle method(current, Universe::is_substitutable_method());\n+  method->method_holder()->initialize(CHECK_false); \/\/ Ensure class ValueObjectMethods is initialized\n+  JavaCalls::call(&result, method, &args, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    \/\/ Something really bad happened because isSubstitutable() should not throw exceptions\n+    \/\/ If it is an error, just let it propagate\n+    \/\/ If it is an exception, wrap it into an InternalError\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+      Handle e(THREAD, PENDING_EXCEPTION);\n+      CLEAR_PENDING_EXCEPTION;\n+      THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in substitutability test\", e, false);\n+    }\n+  }\n+  return result.get_jboolean();\n+JRT_END\n@@ -623,0 +696,4 @@\n+JRT_ENTRY(void, InterpreterRuntime::throw_InstantiationError(JavaThread* current))\n+  THROW(vmSymbols::java_lang_InstantiationError());\n+JRT_END\n+\n@@ -702,0 +779,1 @@\n+  bool strict_static_final = info.is_strict() && info.is_static() && info.is_final();\n@@ -707,1 +785,5 @@\n-    get_code = ((is_static) ? Bytecodes::_getstatic : Bytecodes::_getfield);\n+    if (is_static) {\n+      get_code = Bytecodes::_getstatic;\n+    } else {\n+      get_code = Bytecodes::_getfield;\n+    }\n@@ -709,1 +791,1 @@\n-      put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);\n+        put_code = ((is_static) ? Bytecodes::_putstatic : Bytecodes::_putfield);\n@@ -711,0 +793,13 @@\n+    assert(!info.is_strict_static_unset(), \"after initialization, no unset flags\");\n+  } else if (is_static && (info.is_strict_static_unset() || strict_static_final)) {\n+    \/\/ During <clinit>, closely track the state of strict statics.\n+    \/\/ 1. if we are reading an uninitialized strict static, throw\n+    \/\/ 2. if we are writing one, clear the \"unset\" flag\n+    \/\/\n+    \/\/ Note: If we were handling an attempted write of a null to a\n+    \/\/ null-restricted strict static, we would NOT clear the \"unset\"\n+    \/\/ flag.\n+    assert(klass->is_being_initialized(), \"else should have thrown\");\n+    assert(klass->is_reentrant_initialization(THREAD),\n+      \"<clinit> must be running in current thread\");\n+    klass->notify_strict_static_access(info.index(), is_put, CHECK);\n@@ -714,1 +809,4 @@\n-  entry->set_flags(info.access_flags().is_final(), info.access_flags().is_volatile());\n+  entry->set_flags(info.access_flags().is_final(), info.access_flags().is_volatile(),\n+                   info.is_flat(), info.is_null_free_inline_type(),\n+                   info.has_null_marker());\n+\n@@ -761,1 +859,0 @@\n-\n@@ -766,1 +863,0 @@\n-\n@@ -781,0 +877,15 @@\n+JRT_ENTRY(void, InterpreterRuntime::throw_identity_exception(JavaThread* current, oopDesc* obj))\n+  Klass* klass = cast_to_oop(obj)->klass();\n+  ResourceMark rm(THREAD);\n+  const char* desc = \"Cannot synchronize on an instance of value class \";\n+  const char* className = klass->external_name();\n+  size_t msglen = strlen(desc) + strlen(className) + 1;\n+  char* message = NEW_RESOURCE_ARRAY(char, msglen);\n+  if (nullptr == message) {\n+    \/\/ Out of memory: can't create detailed error message\n+    THROW_MSG(vmSymbols::java_lang_IdentityException(), className);\n+  } else {\n+    jio_snprintf(message, msglen, \"%s%s\", desc, className);\n+    THROW_MSG(vmSymbols::java_lang_IdentityException(), message);\n+  }\n+JRT_END\n@@ -1191,0 +1302,1 @@\n+  assert(entry->is_valid(), \"Invalid ResolvedFieldEntry\");\n@@ -1198,0 +1310,1 @@\n+  bool is_flat = entry->is_flat();\n@@ -1206,1 +1319,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(field_holder, entry->field_offset(), is_static);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(field_holder, entry->field_offset(), is_static, is_flat);\n@@ -1214,0 +1327,1 @@\n+  assert(entry->is_valid(), \"Invalid ResolvedFieldEntry\");\n@@ -1235,0 +1349,1 @@\n+\n@@ -1236,0 +1351,1 @@\n+  bool is_flat = entry->is_flat();\n@@ -1238,1 +1354,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, entry->field_offset(), is_static);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, entry->field_offset(), is_static, is_flat);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":126,"deletions":10,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-                  if (!method->is_static_initializer()) {\n+                  if (!method->is_class_initializer()) {\n@@ -461,1 +461,1 @@\n-                  if (!method->is_object_initializer()) {\n+                  if (!method->is_object_constructor()) {\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1630,1 +1630,1 @@\n-              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false);\n+              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false, CHECK_NULL);\n@@ -1881,1 +1881,1 @@\n-  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);\n+  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false, THREAD);\n@@ -2209,1 +2209,1 @@\n-    if (m->is_object_initializer()) {\n+    if (m->is_object_constructor()) {\n@@ -2236,1 +2236,1 @@\n-    if (!m->is_object_initializer() && !m->is_static_initializer() && !m->is_overpass()) {\n+    if (!(m->is_object_constructor() || m->is_class_initializer()) && !m->is_overpass()) {\n@@ -2976,1 +2976,5 @@\n-  if (m->is_object_initializer()) {\n+  if (m->is_class_initializer()) {\n+      JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n+          \"Cannot create java.lang.reflect.Method for class initializer\");\n+  }\n+  else if (m->is_object_constructor()) {\n@@ -2978,3 +2982,0 @@\n-  } else if (m->is_static_initializer()) {\n-    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-        \"Cannot create java.lang.reflect.Method for class initializer\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+  f(InlineLayoutInfo) \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+#include \"oops\/fieldInfo.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -38,0 +41,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -512,0 +516,124 @@\n+\n+class FindClassByNameClosure : public KlassInfoClosure {\n+ private:\n+  GrowableArray<Klass*>* _klasses;\n+  Symbol* _classname;\n+ public:\n+  FindClassByNameClosure(GrowableArray<Klass*>* klasses, Symbol* classname) :\n+    _klasses(klasses), _classname(classname) { }\n+\n+  void do_cinfo(KlassInfoEntry* cie) {\n+    if (cie->klass()->name() == _classname) {\n+      _klasses->append(cie->klass());\n+    }\n+  }\n+};\n+\n+class FieldDesc {\n+private:\n+  Symbol* _name;\n+  Symbol* _signature;\n+  int _offset;\n+  int _index;\n+  InstanceKlass* _holder;\n+  AccessFlags _access_flags;\n+  FieldInfo::FieldFlags _field_flags;\n+ public:\n+  FieldDesc() : _name(nullptr), _signature(nullptr), _offset(-1), _index(-1), _holder(nullptr),\n+                _access_flags(AccessFlags()), _field_flags(FieldInfo::FieldFlags((u4)0)) { }\n+\n+  FieldDesc(fieldDescriptor& fd) : _name(fd.name()), _signature(fd.signature()), _offset(fd.offset()),\n+                                   _index(fd.index()), _holder(fd.field_holder()),\n+                                   _access_flags(fd.access_flags()), _field_flags(fd.field_flags()) { }\n+\n+  const Symbol* name() { return _name;}\n+  const Symbol* signature() { return _signature; }\n+  int offset() const { return _offset; }\n+  int index() const { return _index; }\n+  const InstanceKlass* holder() { return _holder; }\n+  const AccessFlags& access_flags() { return _access_flags; }\n+  bool is_null_free_inline_type() const { return _field_flags.is_null_free_inline_type(); }\n+};\n+\n+static int compare_offset(FieldDesc* f1, FieldDesc* f2) {\n+   return f1->offset() > f2->offset() ? 1 : -1;\n+}\n+\n+static void print_field(outputStream* st, int level, int offset, FieldDesc& fd, bool is_inline_type, bool is_flat ) {\n+  const char* flat_field_msg = \"\";\n+  if (is_flat) {\n+    flat_field_msg = is_flat ? \"flat\" : \"not flat\";\n+  }\n+  st->print_cr(\"  @ %d %*s \\\"%s\\\" %s %s %s\",\n+      offset, level * 3, \"\",\n+      fd.name()->as_C_string(),\n+      fd.signature()->as_C_string(),\n+      is_inline_type ? \" \/\/ inline type \" : \"\",\n+      flat_field_msg);\n+}\n+\n+static void print_flat_field(outputStream* st, int level, int offset, InstanceKlass* klass) {\n+  assert(klass->is_inline_klass(), \"Only inline types can be flat\");\n+  InlineKlass* vklass = InlineKlass::cast(klass);\n+  GrowableArray<FieldDesc>* fields = new (mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+  for (AllFieldStream fd(klass); !fd.done(); fd.next()) {\n+    if (!fd.access_flags().is_static()) {\n+      fields->append(FieldDesc(fd.field_descriptor()));\n+    }\n+  }\n+  fields->sort(compare_offset);\n+  for(int i = 0; i < fields->length(); i++) {\n+    FieldDesc fd = fields->at(i);\n+    int offset2 = offset + fd.offset() - vklass->payload_offset();\n+    print_field(st, level, offset2, fd,\n+        fd.is_null_free_inline_type(), fd.holder()->field_is_flat(fd.index()));\n+    if (fd.holder()->field_is_flat(fd.index())) {\n+      print_flat_field(st, level + 1, offset2 ,\n+          InstanceKlass::cast(fd.holder()->get_inline_type_field_klass(fd.index())));\n+    }\n+  }\n+}\n+\n+void PrintClassLayout::print_class_layout(outputStream* st, char* class_name) {\n+  KlassInfoTable cit(true);\n+  if (cit.allocation_failed()) {\n+    st->print_cr(\"ERROR: Ran out of C-heap; hierarchy not generated\");\n+    return;\n+  }\n+\n+  Thread* THREAD = Thread::current();\n+\n+  Symbol* classname = SymbolTable::probe(class_name, (int)strlen(class_name));\n+\n+  GrowableArray<Klass*>* klasses = new (mtServiceability) GrowableArray<Klass*>(100, mtServiceability);\n+\n+  FindClassByNameClosure fbnc(klasses, classname);\n+  cit.iterate(&fbnc);\n+\n+  for(int i = 0; i < klasses->length(); i++) {\n+    Klass* klass = klasses->at(i);\n+    if (!klass->is_instance_klass()) continue;  \/\/ Skip\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    int tab = 1;\n+    st->print_cr(\"Class %s [@%s]:\", klass->name()->as_C_string(),\n+        klass->class_loader_data()->loader_name());\n+    ResourceMark rm;\n+    GrowableArray<FieldDesc>* fields = new (mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);\n+    for (AllFieldStream fd(ik); !fd.done(); fd.next()) {\n+      if (!fd.access_flags().is_static()) {\n+        fields->append(FieldDesc(fd.field_descriptor()));\n+      }\n+    }\n+    fields->sort(compare_offset);\n+    for(int i = 0; i < fields->length(); i++) {\n+      FieldDesc fd = fields->at(i);\n+      print_field(st, 0, fd.offset(), fd, fd.is_null_free_inline_type(), fd.holder()->field_is_flat(fd.index()));\n+      if (fd.holder()->field_is_flat(fd.index())) {\n+        print_flat_field(st, 1, fd.offset(),\n+            InstanceKlass::cast(fd.holder()->get_inline_type_field_klass(fd.index())));\n+      }\n+    }\n+  }\n+  st->cr();\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -193,0 +193,5 @@\n+class PrintClassLayout : AllStatic {\n+ public:\n+  static void print_class_layout(outputStream* st, char* classname);\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/flatArrayKlass.inline.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"oops\/refArrayKlass.inline.hpp\"\n@@ -151,0 +153,1 @@\n+      set_init_function<InlineKlass>();\n@@ -157,0 +160,2 @@\n+      set_init_function<FlatArrayKlass>();\n+      set_init_function<RefArrayKlass>();\n@@ -214,0 +219,1 @@\n+      set_init_function<InlineKlass>();\n@@ -220,0 +226,2 @@\n+      set_init_function<FlatArrayKlass>();\n+      set_init_function<RefArrayKlass>();\n@@ -277,0 +285,1 @@\n+      set_init_function<InlineKlass>();\n@@ -283,0 +292,2 @@\n+      set_init_function<FlatArrayKlass>();\n+      set_init_function<RefArrayKlass>();\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+#include \"oops\/arrayKlass.hpp\"\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -35,0 +39,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -37,0 +42,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -76,1 +82,1 @@\n-  return Universe::objectArrayKlass()->allocate_instance(length, THREAD);\n+  return Universe::objectArrayKlass()->allocate_instance(length, ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n@@ -107,0 +113,10 @@\n+objArrayOop oopFactory::new_objArray(Klass* klass, int length, ArrayKlass::ArrayProperties properties, TRAPS) {\n+  assert(!klass->is_array_klass() || properties == ArrayKlass::ArrayProperties::DEFAULT, \"properties only apply to single dimension arrays\");\n+  ArrayKlass* ak = klass->array_klass(CHECK_NULL);\n+  return ObjArrayKlass::cast(ak)->allocate_instance(length, properties, THREAD);\n+}\n+\n+objArrayOop oopFactory::new_refArray(Klass* array_klass, int length, TRAPS) {\n+  RefArrayKlass* rak = RefArrayKlass::cast(array_klass);  \/\/ asserts is refArray_klass().\n+  return rak->allocate_instance(length, rak->properties(), THREAD);\n+}\n@@ -109,5 +125,17 @@\n-  if (klass->is_array_klass()) {\n-    return ArrayKlass::cast(klass)->allocate_arrayArray(1, length, THREAD);\n-  } else {\n-    return InstanceKlass::cast(klass)->allocate_objArray(1, length, THREAD);\n-  }\n+  return  new_objArray(klass, length, ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+}\n+\n+flatArrayOop oopFactory::new_flatArray(Klass* k, int length, ArrayKlass::ArrayProperties props, LayoutKind lk, TRAPS) {\n+  InlineKlass* klass = InlineKlass::cast(k);\n+\n+  ArrayKlass* array_type = klass->array_klass(CHECK_NULL);\n+  ObjArrayKlass* oak = ObjArrayKlass::cast(array_type)->klass_with_properties(props, CHECK_NULL);\n+\n+  assert(oak->is_flatArray_klass(), \"Expected to be\");\n+  assert(FlatArrayKlass::cast(oak)->layout_kind() == lk, \"Unexpected layout kind\");\n+\n+  flatArrayOop oop = (flatArrayOop)FlatArrayKlass::cast(oak)->allocate_instance(length, props, CHECK_NULL);\n+  assert(oop == nullptr || oop->is_flatArray(), \"sanity\");\n+  assert(oop == nullptr || oop->klass()->is_flatArray_klass(), \"sanity\");\n+\n+  return oop;\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -42,0 +44,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -95,2 +98,2 @@\n-ArrayKlass::ArrayKlass(Symbol* name, KlassKind kind) :\n-  Klass(kind),\n+ArrayKlass::ArrayKlass(Symbol* name, KlassKind kind, ArrayProperties props, markWord prototype_header) :\n+Klass(kind, prototype_header),\n@@ -98,0 +101,1 @@\n+  _properties(props),\n@@ -111,0 +115,19 @@\n+Symbol* ArrayKlass::create_element_klass_array_name(Klass* element_klass, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  Symbol* name = nullptr;\n+  char *name_str = element_klass->name()->as_C_string();\n+  int len = element_klass->name()->utf8_length();\n+  char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);\n+  int idx = 0;\n+  new_str[idx++] = JVM_SIGNATURE_ARRAY;\n+  if (element_klass->is_instance_klass()) { \/\/ it could be an array or simple type\n+    new_str[idx++] = JVM_SIGNATURE_CLASS;\n+  }\n+  memcpy(&new_str[idx], name_str, len * sizeof(char));\n+  idx += len;\n+  if (element_klass->is_instance_klass()) {\n+    new_str[idx++] = JVM_SIGNATURE_ENDCLASS;\n+  }\n+  new_str[idx++] = '\\0';\n+  return SymbolTable::new_symbol(new_str);\n+}\n@@ -124,1 +147,10 @@\n-  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module_oop), Handle(), Handle(), CHECK);\n+\n+  if (k->is_refArray_klass() || k->is_flatArray_klass()) {\n+    assert(super_klass != nullptr, \"Must be\");\n+    assert(k->super() != nullptr, \"Must be\");\n+    assert(k->super() == super_klass, \"Must be\");\n+    Handle mirror(THREAD, super_klass->java_mirror());\n+    k->set_java_mirror(mirror);\n+  } else {\n+    java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module_oop), Handle(), Handle(), CHECK);\n+  }\n@@ -141,2 +173,1 @@\n-      ObjArrayKlass* ak =\n-          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+      ObjArrayKlass* ak = RefArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n@@ -190,8 +221,2 @@\n-objArrayOop ArrayKlass::allocate_arrayArray(int n, int length, TRAPS) {\n-  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);\n-  size_t size = objArrayOopDesc::object_size(length);\n-  ArrayKlass* ak = array_klass(n + dimension(), CHECK_NULL);\n-  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n-                                                                \/* do_zero *\/ true, CHECK_NULL);\n-  \/\/ initialization to null not necessary, area already cleared\n-  return o;\n+oop ArrayKlass::component_mirror() const {\n+  return java_lang_Class::component_mirror(java_mirror());\n@@ -239,1 +264,1 @@\n-    ArrayKlass *ak = higher_dimension();\n+    ObjArrayKlass *ak = higher_dimension();\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"oops\/refArrayOop.hpp\"\n@@ -194,1 +196,1 @@\n-  return resolved_references()->replace_if_null(index, new_result);\n+  return refArrayOopDesc::cast(resolved_references())->replace_if_null(index, new_result);\n@@ -265,1 +267,1 @@\n-      \/\/ All of these should have been reverted back to ClassIndex before calling\n+      \/\/ All of these should have been reverted back to Unresolved before calling\n@@ -481,0 +483,1 @@\n+    assert(src_k->is_instance_klass() || src_k->is_typeArray_klass(), \"Sanity check\");\n@@ -622,0 +625,6 @@\n+void check_is_inline_type(Klass* k, TRAPS) {\n+  if (!k->is_inline_klass()) {\n+    THROW(vmSymbols::java_lang_IncompatibleClassChangeError());\n+  }\n+}\n+\n@@ -659,0 +668,1 @@\n+  bool inline_type_signature = false;\n@@ -667,0 +677,3 @@\n+  if (inline_type_signature) {\n+    name->decrement_refcount();\n+  }\n@@ -675,0 +688,16 @@\n+  if (!HAS_PENDING_EXCEPTION && inline_type_signature) {\n+    check_is_inline_type(k, THREAD);\n+  }\n+\n+  if (!HAS_PENDING_EXCEPTION) {\n+    Klass* bottom_klass = nullptr;\n+    if (k->is_objArray_klass()) {\n+      bottom_klass = ObjArrayKlass::cast(k)->bottom_klass();\n+      assert(bottom_klass != nullptr, \"Should be set\");\n+      assert(bottom_klass->is_instance_klass() || bottom_klass->is_typeArray_klass(), \"Sanity check\");\n+    } else if (k->is_flatArray_klass()) {\n+      bottom_klass = FlatArrayKlass::cast(k)->element_klass();\n+      assert(bottom_klass != nullptr, \"Should be set\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-  \/\/ For temporary use while constructing constant pool\n+  \/\/ For temporary use while constructing constant pool. Used during a retransform\/class redefinition as well.\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+      invoke_code = Bytecodes::_invokevirtual;\n@@ -228,1 +229,1 @@\n-    method_entry->set_bytecode2(Bytecodes::_invokevirtual);\n+    method_entry->set_bytecode2(invoke_code);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+\n@@ -119,0 +120,8 @@\n+  bool is_null_free_inline_type() {\n+    return field()->field_flags().is_null_free_inline_type();\n+  }\n+\n+  bool is_flat() const {\n+    return field()->field_flags().is_flat();\n+  }\n+\n@@ -127,0 +136,4 @@\n+  int null_marker_offset() const {\n+    return field()->null_marker_offset();\n+  }\n+\n@@ -194,1 +207,79 @@\n-\/\/ Iterate over fields including the ones declared in supertypes\n+\/* Very generally, a base class for a stream adapter, a derived class just implements\n+ * current_stream that returns a FieldStreamType, and this adapter takes care of providing\n+ * the methods of FieldStreamBase.\n+ *\n+ * In practice, this is used to provide a stream over the fields of a class and its superclasses\n+ * and interfaces. The derived class of HierarchicalFieldStreamBase decides in which order we iterate\n+ * on the superclasses (and interfaces), and the template parameter FieldStreamType is the underlying\n+ * stream we use to iterate over the fields each class. Methods such as done and next are still up to\n+ * the derived classes, allowing them to iterate over the class hierarchy, but also skip elements that\n+ * the underlying FieldStreamType would otherwise include.\n+ *\/\n+template<typename FieldStreamType>\n+class HierarchicalFieldStreamBase : public StackObj {\n+  virtual FieldStreamType& current_stream() = 0;\n+  virtual const FieldStreamType& current_stream() const = 0;\n+\n+public:\n+  \/\/ bridge functions from FieldStreamBase\n+  int index() const {\n+    return current_stream().index();\n+  }\n+\n+  AccessFlags access_flags() const {\n+    return current_stream().access_flags();\n+  }\n+\n+  FieldInfo::FieldFlags field_flags() const {\n+    return current_stream().field_flags();\n+  }\n+\n+  Symbol* name() const {\n+    return current_stream().name();\n+  }\n+\n+  Symbol* signature() const {\n+    return current_stream().signature();\n+  }\n+\n+  Symbol* generic_signature() const {\n+    return current_stream().generic_signature();\n+  }\n+\n+  int offset() const {\n+    return current_stream().offset();\n+  }\n+\n+  bool is_contended() const {\n+    return current_stream().is_contended();\n+  }\n+\n+  int contended_group() const {\n+    return current_stream().contended_group();\n+  }\n+\n+  FieldInfo to_FieldInfo() {\n+    return current_stream().to_FieldInfo();\n+  }\n+\n+  fieldDescriptor& field_descriptor() const {\n+    return current_stream().field_descriptor();\n+  }\n+\n+  bool is_flat() const {\n+    return current_stream().is_flat();\n+  }\n+\n+  bool is_null_free_inline_type() {\n+    return current_stream().is_null_free_inline_type();\n+  }\n+\n+  int null_marker_offset() {\n+    return current_stream().null_marker_offset();\n+  }\n+};\n+\n+\/* Iterate over fields including the ones declared in supertypes.\n+ * Derived classes are traversed before base classes, and interfaces\n+ * at the end.\n+ *\/\n@@ -196,1 +287,1 @@\n-class HierarchicalFieldStream : public StackObj  {\n+class HierarchicalFieldStream final : public HierarchicalFieldStreamBase<FieldStreamType>  {\n@@ -234,0 +325,3 @@\n+  FieldStreamType& current_stream() override { return _current_stream; }\n+  const FieldStreamType& current_stream() const override { return _current_stream; }\n+\n@@ -235,1 +329,1 @@\n-  HierarchicalFieldStream(InstanceKlass* klass) :\n+  explicit HierarchicalFieldStream(InstanceKlass* klass) :\n@@ -249,0 +343,1 @@\n+};\n@@ -250,16 +345,20 @@\n-  \/\/ bridge functions from FieldStreamBase\n-\n-  AccessFlags access_flags() const {\n-    return _current_stream.access_flags();\n-  }\n-\n-  FieldInfo::FieldFlags field_flags() const {\n-    return _current_stream.field_flags();\n-  }\n-\n-  Symbol* name() const {\n-    return _current_stream.name();\n-  }\n-\n-  Symbol* signature() const {\n-    return _current_stream.signature();\n+\/* Iterates on the fields of a class and its super-class top-down (java.lang.Object first)\n+ * Doesn't traverse interfaces for now, because it's not clear which order would make sense\n+ * Let's decide when or if the need arises. Since we are not traversing interfaces, we\n+ * wouldn't get all the static fields, and since the current use-case of this stream does not\n+ * care about static fields, we restrict it to regular non-static fields.\n+ *\/\n+class TopDownHierarchicalNonStaticFieldStreamBase final : public HierarchicalFieldStreamBase<JavaFieldStream> {\n+  GrowableArray<InstanceKlass*>* _super_types;  \/\/ Self and super type, bottom up\n+  int _current_stream_index;\n+  JavaFieldStream _current_stream;\n+\n+  void next_stream_if_needed() {\n+    precond(_current_stream_index >= 0);\n+    while (_current_stream.done()) {\n+      _current_stream_index--;\n+      if (_current_stream_index < 0) {\n+        return;\n+      }\n+      _current_stream = JavaFieldStream(_super_types->at(_current_stream_index));\n+    }\n@@ -268,2 +367,6 @@\n-  Symbol* generic_signature() const {\n-    return _current_stream.generic_signature();\n+  GrowableArray<InstanceKlass*>* get_super_types(InstanceKlass* klass) {\n+    auto super_types = new GrowableArray<InstanceKlass*>();\n+    do {\n+      super_types->push(klass);\n+    } while ((klass = klass->java_super()) != nullptr);\n+    return super_types;\n@@ -272,2 +375,3 @@\n-  int offset() const {\n-    return _current_stream.offset();\n+  void raw_next() {\n+    _current_stream.next();\n+    next_stream_if_needed();\n@@ -276,2 +380,4 @@\n-  bool is_contended() const {\n-    return _current_stream.is_contended();\n+  void closest_non_static() {\n+    while (!done() && access_flags().is_static()) {\n+      raw_next();\n+    }\n@@ -280,3 +386,2 @@\n-  int contended_group() const {\n-    return _current_stream.contended_group();\n-  }\n+  JavaFieldStream& current_stream() override { return _current_stream; }\n+  const JavaFieldStream& current_stream() const override { return _current_stream; }\n@@ -284,2 +389,7 @@\n-  FieldInfo to_FieldInfo() {\n-    return _current_stream.to_FieldInfo();\n+ public:\n+  explicit TopDownHierarchicalNonStaticFieldStreamBase(InstanceKlass* klass) :\n+    _super_types(get_super_types(klass)),\n+    _current_stream_index(_super_types->length() - 1),\n+    _current_stream(JavaFieldStream(_super_types->at(_current_stream_index))) {\n+    next_stream_if_needed();\n+    closest_non_static();\n@@ -288,2 +398,3 @@\n-  fieldDescriptor& field_descriptor() const {\n-    return _current_stream.field_descriptor();\n+  void next() {\n+    raw_next();\n+    closest_non_static();\n@@ -292,0 +403,1 @@\n+  bool done() const { return _current_stream_index < 0; }\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":144,"deletions":32,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    if (!is_static)\n+    if (!is_static) {\n@@ -143,0 +143,1 @@\n+    }\n@@ -1603,0 +1604,1 @@\n+    case Bytecodes::_invokeinterface:\n@@ -1604,4 +1606,3 @@\n-    case Bytecodes::_invokespecial:     do_method(false, false, itr->get_index_u2(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_invokestatic:      do_method(true,  false, itr->get_index_u2(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_invokedynamic:     do_method(true,  false, itr->get_index_u4(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_invokeinterface:   do_method(false, true,  itr->get_index_u2(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_invokespecial:     do_method(false, itr->get_index_u2(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_invokestatic:      do_method(true , itr->get_index_u2(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_invokedynamic:     do_method(true , itr->get_index_u4(), itr->bci(), itr->code()); break;\n@@ -1627,0 +1628,1 @@\n+\n@@ -1952,1 +1954,3 @@\n-  if (!is_static) in[i++] = CellTypeState::ref;\n+  if (!is_static) {\n+    in[i++] = CellTypeState::ref;\n+  }\n@@ -1958,1 +1962,1 @@\n-void GenerateOopMap::do_method(int is_static, int is_interface, int idx, int bci, Bytecodes::Code bc) {\n+void GenerateOopMap::do_method(int is_static, int idx, int bci, Bytecodes::Code bc) {\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -72,0 +73,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -75,0 +77,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -152,0 +155,5 @@\n+void InlineLayoutInfo::metaspace_pointers_do(MetaspaceClosure* it) {\n+  log_trace(cds)(\"Iter(InlineFieldInfo): %p\", this);\n+  it->push(&_klass);\n+}\n+\n@@ -173,0 +181,13 @@\n+bool InstanceKlass::field_is_null_free_inline_type(int index) const {\n+  return field(index).field_flags().is_null_free_inline_type();\n+}\n+\n+bool InstanceKlass::is_class_in_loadable_descriptors_attribute(Symbol* name) const {\n+  if (_loadable_descriptors == nullptr) return false;\n+  for (int i = 0; i < _loadable_descriptors->length(); i++) {\n+        Symbol* class_name = _constants->symbol_at(_loadable_descriptors->at(i));\n+        if (class_name == name) return true;\n+  }\n+  return false;\n+}\n+\n@@ -467,1 +488,2 @@\n-                                       parser.is_interface());\n+                                       parser.is_interface(),\n+                                       parser.is_inline_type());\n@@ -490,0 +512,3 @@\n+  } else if (parser.is_inline_type()) {\n+    \/\/ inline type\n+    ik = new (loader_data, size, use_class_space, THREAD) InlineKlass(parser);\n@@ -506,0 +531,6 @@\n+#ifdef ASSERT\n+  ik->bounds_check((address) ik->start_of_vtable(), false, size);\n+  ik->bounds_check((address) ik->start_of_itable(), false, size);\n+  ik->bounds_check((address) ik->end_of_itable(), true, size);\n+  ik->bounds_check((address) ik->end_of_nonstatic_oop_maps(), true, size);\n+#endif \/\/ASSERT\n@@ -509,0 +540,23 @@\n+#ifndef PRODUCT\n+bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {\n+  const char* bad = nullptr;\n+  address end = nullptr;\n+  if (addr < (address)this) {\n+    bad = \"before\";\n+  } else if (addr == (address)this) {\n+    if (edge_ok)  return true;\n+    bad = \"just before\";\n+  } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes < 0 ? size() : size_in_bytes))) {\n+    if (edge_ok)  return true;\n+    bad = \"just after\";\n+  } else if (addr > end) {\n+    bad = \"after\";\n+  } else {\n+    return true;\n+  }\n+  tty->print_cr(\"%s object bounds: \" INTPTR_FORMAT \" [\" INTPTR_FORMAT \"..\" INTPTR_FORMAT \"]\",\n+      bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);\n+  Verbose = WizardMode = true; this->print(); \/\/@@\n+  return false;\n+}\n+#endif \/\/PRODUCT\n@@ -536,2 +590,2 @@\n-InstanceKlass::InstanceKlass(const ClassFileParser& parser, KlassKind kind, ReferenceType reference_type) :\n-  Klass(kind),\n+InstanceKlass::InstanceKlass(const ClassFileParser& parser, KlassKind kind, markWord prototype_header, ReferenceType reference_type) :\n+  Klass(kind, prototype_header),\n@@ -548,1 +602,4 @@\n-  _init_thread(nullptr)\n+  _init_thread(nullptr),\n+  _inline_layout_info_array(nullptr),\n+  _loadable_descriptors(nullptr),\n+  _adr_inlineklass_fixed_block(nullptr)\n@@ -555,0 +612,3 @@\n+  if (parser.has_inline_fields()) {\n+    set_has_inline_type_fields();\n+  }\n@@ -699,0 +759,5 @@\n+  if (inline_layout_info_array() != nullptr) {\n+    MetadataFactory::free_array<InlineLayoutInfo>(loader_data, inline_layout_info_array());\n+  }\n+  set_inline_layout_info_array(nullptr);\n+\n@@ -733,0 +798,7 @@\n+  if (loadable_descriptors() != nullptr &&\n+      loadable_descriptors() != Universe::the_empty_short_array() &&\n+      !loadable_descriptors()->in_aot_cache()) {\n+    MetadataFactory::free_array<jushort>(loader_data, loadable_descriptors());\n+  }\n+  set_loadable_descriptors(nullptr);\n+\n@@ -901,0 +973,38 @@\n+static void load_classes_from_loadable_descriptors_attribute(InstanceKlass *ik, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  if (ik->loadable_descriptors() != nullptr && PreloadClasses) {\n+    HandleMark hm(THREAD);\n+    for (int i = 0; i < ik->loadable_descriptors()->length(); i++) {\n+      Symbol* sig = ik->constants()->symbol_at(ik->loadable_descriptors()->at(i));\n+      if (!Signature::has_envelope(sig)) continue;\n+      TempNewSymbol class_name = Signature::strip_envelope(sig);\n+      if (class_name == ik->name()) continue;\n+      log_info(class, preload)(\"Preloading of class %s during linking of class %s \"\n+                               \"because of the class is listed in the LoadableDescriptors attribute\",\n+                               sig->as_C_string(), ik->name()->as_C_string());\n+      oop loader = ik->class_loader();\n+      Klass* klass = SystemDictionary::resolve_or_null(class_name,\n+                                                        Handle(THREAD, loader), THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION;\n+      }\n+      if (klass != nullptr) {\n+        log_info(class, preload)(\"Preloading of class %s during linking of class %s \"\n+                                 \"(cause: LoadableDescriptors attribute) succeeded\",\n+                                 class_name->as_C_string(), ik->name()->as_C_string());\n+        if (!klass->is_inline_klass()) {\n+          \/\/ Non value class are allowed by the current spec, but it could be an indication\n+          \/\/ of an issue so let's log a warning\n+          log_warning(class, preload)(\"Preloading of class %s during linking of class %s \"\n+                                      \"(cause: LoadableDescriptors attribute) but loaded class is not a value class\",\n+                                      class_name->as_C_string(), ik->name()->as_C_string());\n+        }\n+      } else {\n+        log_warning(class, preload)(\"Preloading of class %s during linking of class %s \"\n+                                    \"(cause: LoadableDescriptors attribute) failed\",\n+                                    class_name->as_C_string(), ik->name()->as_C_string());\n+      }\n+    }\n+  }\n+}\n+\n@@ -971,0 +1081,7 @@\n+  if (EnableValhalla) {\n+    \/\/ Aggressively preloading all classes from the LoadableDescriptors attribute\n+    \/\/ so inline classes can be scalarized in the calling conventions computed below\n+    load_classes_from_loadable_descriptors_attribute(this, THREAD);\n+    assert(!HAS_PENDING_EXCEPTION, \"Shouldn't have pending exceptions from call above\");\n+  }\n+\n@@ -1275,0 +1392,21 @@\n+  \/\/ Pre-allocating an all-zero value to be used to reset nullable flat storages\n+  if (is_inline_klass()) {\n+      InlineKlass* vk = InlineKlass::cast(this);\n+      if (vk->has_nullable_atomic_layout()) {\n+        oop val = vk->allocate_instance(THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+            Handle e(THREAD, PENDING_EXCEPTION);\n+            CLEAR_PENDING_EXCEPTION;\n+            {\n+                EXCEPTION_MARK;\n+                add_initialization_error(THREAD, e);\n+                \/\/ Locks object, set state, and notify all waiting threads\n+                set_initialization_state_and_notify(initialization_error, THREAD);\n+                CLEAR_PENDING_EXCEPTION;\n+            }\n+            THROW_OOP(e());\n+        }\n+        vk->set_null_reset_value(val);\n+      }\n+  }\n+\n@@ -1307,1 +1445,0 @@\n-\n@@ -1328,0 +1465,30 @@\n+\n+    if (has_strict_static_fields() && !HAS_PENDING_EXCEPTION) {\n+      \/\/ Step 9 also verifies that strict static fields have been initialized.\n+      \/\/ Status bits were set in ClassFileParser::post_process_parsed_stream.\n+      \/\/ After <clinit>, bits must all be clear, or else we must throw an error.\n+      \/\/ This is an extremely fast check, so we won't bother with a timer.\n+      assert(fields_status() != nullptr, \"\");\n+      Symbol* bad_strict_static = nullptr;\n+      for (int index = 0; index < fields_status()->length(); index++) {\n+        \/\/ Very fast loop over single byte array looking for a set bit.\n+        if (fields_status()->adr_at(index)->is_strict_static_unset()) {\n+          \/\/ This strict static field has not been set by the class initializer.\n+          \/\/ Note that in the common no-error case, we read no field metadata.\n+          \/\/ We only unpack it when we need to report an error.\n+          FieldInfo fi = field(index);\n+          bad_strict_static = fi.name(constants());\n+          if (debug_logging_enabled) {\n+            ResourceMark rm(jt);\n+            const char* msg = format_strict_static_message(bad_strict_static);\n+            log_debug(class, init)(\"%s\", msg);\n+          } else {\n+            \/\/ If we are not logging, do not bother to look for a second offense.\n+            break;\n+          }\n+        }\n+      }\n+      if (bad_strict_static != nullptr) {\n+        throw_strict_static_exception(bad_strict_static, \"is unset after initialization of\", THREAD);\n+      }\n+    }\n@@ -1381,0 +1548,68 @@\n+void InstanceKlass::notify_strict_static_access(int field_index, bool is_writing, TRAPS) {\n+  guarantee(field_index >= 0 && field_index < fields_status()->length(), \"valid field index\");\n+  DEBUG_ONLY(FieldInfo debugfi = field(field_index));\n+  assert(debugfi.access_flags().is_strict(), \"\");\n+  assert(debugfi.access_flags().is_static(), \"\");\n+  FieldStatus& fs = *fields_status()->adr_at(field_index);\n+  LogTarget(Trace, class, init) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm(THREAD);\n+    LogStream ls(lt);\n+    FieldInfo fi = field(field_index);\n+    ls.print(\"notify %s %s %s%s \",\n+             external_name(), is_writing? \"Write\" : \"Read\",\n+             fs.is_strict_static_unset() ? \"Unset\" : \"(set)\",\n+             fs.is_strict_static_unread() ? \"+Unread\" : \"\");\n+    fi.print(&ls, constants());\n+  }\n+  if (fs.is_strict_static_unset()) {\n+    assert(fs.is_strict_static_unread(), \"ClassFileParser resp.\");\n+    \/\/ If it is not set, there are only two reasonable things we can do here:\n+    \/\/ - mark it set if this is putstatic\n+    \/\/ - throw an error (Read-Before-Write) if this is getstatic\n+\n+    \/\/ The unset state is (or should be) transient, and observable only in one\n+    \/\/ thread during the execution of <clinit>.  Something is wrong here as this\n+    \/\/ should not be possible\n+    guarantee(is_reentrant_initialization(THREAD), \"unscoped access to strict static\");\n+    if (is_writing) {\n+      \/\/ clear the \"unset\" bit, since the field is actually going to be written\n+      fs.update_strict_static_unset(false);\n+    } else {\n+      \/\/ throw an IllegalStateException, since we are reading before writing\n+      \/\/ see also InstanceKlass::initialize_impl, Step 8 (at end)\n+      Symbol* bad_strict_static = field(field_index).name(constants());\n+      throw_strict_static_exception(bad_strict_static, \"is unset before first read in\", CHECK);\n+    }\n+  } else {\n+    \/\/ Ensure no write after read for final strict statics\n+    FieldInfo fi = field(field_index);\n+    bool is_final = fi.access_flags().is_final();\n+    if (is_final) {\n+      \/\/ no final write after read, so observing a constant freezes it, as if <clinit> ended early\n+      \/\/ (maybe we could trust the constant a little earlier, before <clinit> ends)\n+      if (is_writing && !fs.is_strict_static_unread()) {\n+        Symbol* bad_strict_static = fi.name(constants());\n+        throw_strict_static_exception(bad_strict_static, \"is set after read (as final) in\", CHECK);\n+      } else if (!is_writing && fs.is_strict_static_unread()) {\n+        fs.update_strict_static_unread(false);\n+      }\n+    }\n+  }\n+}\n+\n+void InstanceKlass::throw_strict_static_exception(Symbol* field_name, const char* when, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  const char* msg = format_strict_static_message(field_name, when);\n+  THROW_MSG(vmSymbols::java_lang_IllegalStateException(), msg);\n+}\n+\n+const char* InstanceKlass::format_strict_static_message(Symbol* field_name, const char* when) {\n+  stringStream ss;\n+  ss.print(\"Strict static \\\"%s\\\" %s %s\",\n+           field_name->as_C_string(),\n+           when == nullptr ? \"is unset in\" : when,\n+           external_name());\n+  return ss.as_string();\n+}\n+\n@@ -1564,9 +1799,0 @@\n-objArrayOop InstanceKlass::allocate_objArray(int n, int length, TRAPS) {\n-  check_array_allocation_length(length, arrayOopDesc::max_array_length(T_OBJECT), CHECK_NULL);\n-  size_t size = objArrayOopDesc::object_size(length);\n-  ArrayKlass* ak = array_klass(n, CHECK_NULL);\n-  objArrayOop o = (objArrayOop)Universe::heap()->array_allocate(ak, size, length,\n-                                                                \/* do_zero *\/ true, CHECK_NULL);\n-  return o;\n-}\n-\n@@ -1640,1 +1866,1 @@\n-  ObjArrayKlass* ak = array_klasses();\n+  ArrayKlass* ak = array_klasses();\n@@ -1647,2 +1873,2 @@\n-  ObjArrayKlass* oak = array_klasses_acquire();\n-  if (oak == nullptr) {\n+  ArrayKlass* ak = array_klasses_acquire();\n+  if (ak == nullptr) {\n@@ -1651,1 +1877,1 @@\n-    return oak->array_klass_or_null(n);\n+    return ak->array_klass_or_null(n);\n@@ -1668,1 +1894,1 @@\n-  if (clinit != nullptr && clinit->has_valid_initializer_flags()) {\n+  if (clinit != nullptr && clinit->is_class_initializer()) {\n@@ -1777,4 +2003,0 @@\n-bool InstanceKlass::contains_field_offset(int offset) {\n-  fieldDescriptor fd;\n-  return find_field_from_offset(offset, false, &fd);\n-}\n@@ -1861,0 +2083,9 @@\n+bool InstanceKlass::contains_field_offset(int offset) {\n+  if (this->is_inline_klass()) {\n+    InlineKlass* vk = InlineKlass::cast(this);\n+    return offset >= vk->payload_offset() && offset < (vk->payload_offset() + vk->payload_size_in_bytes());\n+  } else {\n+    fieldDescriptor fd;\n+    return find_field_from_offset(offset, false, &fd);\n+  }\n+}\n@@ -2244,0 +2475,3 @@\n+    if (name == vmSymbols::object_initializer_name()) {\n+      break;  \/\/ <init> is never inherited\n+    }\n@@ -2656,0 +2890,1 @@\n+  it->push(&_loadable_descriptors);\n@@ -2657,0 +2892,1 @@\n+  it->push(&_inline_layout_info_array, MetaspaceClosure::_writable);\n@@ -2704,1 +2940,1 @@\n-  \/\/ These are not allocated from metaspace. They are safe to set to null.\n+  \/\/ These are not allocated from metaspace. They are safe to set to nullptr.\n@@ -2795,0 +3031,4 @@\n+  if (is_inline_klass()) {\n+    InlineKlass::cast(this)->initialize_calling_convention(CHECK);\n+  }\n+\n@@ -2828,1 +3068,1 @@\n-    assert(this == array_klasses()->bottom_klass(), \"sanity\");\n+    assert(this == ObjArrayKlass::cast(array_klasses())->bottom_klass(), \"sanity\");\n@@ -2831,0 +3071,6 @@\n+    if (class_loader_data() == nullptr) {\n+      ResourceMark rm(THREAD);\n+      log_debug(cds)(\"  loader_data %s \", loader_data == nullptr ? \"nullptr\" : \"non null\");\n+      log_debug(cds)(\"  this %s array_klasses %s \", this->name()->as_C_string(), array_klasses()->name()->as_C_string());\n+    }\n+    assert(!array_klasses()->is_refined_objArray_klass(), \"must be non-refined objarrayklass\");\n@@ -2984,0 +3230,4 @@\n+bool InstanceKlass::supports_inline_types() const {\n+  return major_version() >= Verifier::VALUE_TYPES_MAJOR_VERSION && minor_version() == Verifier::JAVA_PREVIEW_MINOR_VERSION;\n+}\n+\n@@ -3016,0 +3266,2 @@\n+  return signature_name_of_carrier(JVM_SIGNATURE_CLASS);\n+}\n@@ -3017,0 +3269,1 @@\n+const char* InstanceKlass::signature_name_of_carrier(char c) const {\n@@ -3023,1 +3276,1 @@\n-  \/\/ Add L as type indicator\n+  \/\/ Add L or Q as type indicator\n@@ -3025,1 +3278,1 @@\n-  dest[dest_index++] = JVM_SIGNATURE_CLASS;\n+  dest[dest_index++] = c;\n@@ -3306,0 +3559,19 @@\n+void InstanceKlass::check_can_be_annotated_with_NullRestricted(InstanceKlass* type, Symbol* container_klass_name, TRAPS) {\n+  assert(type->is_instance_klass(), \"Sanity check\");\n+  if (type->is_identity_class()) {\n+    ResourceMark rm(THREAD);\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+              err_msg(\"Class %s expects class %s to be a value class, but it is an identity class\",\n+              container_klass_name->as_C_string(),\n+              type->external_name()));\n+  }\n+\n+  if (type->is_abstract()) {\n+    ResourceMark rm(THREAD);\n+    THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),\n+              err_msg(\"Class %s expects class %s to be concrete value type, but it is an abstract class\",\n+              container_klass_name->as_C_string(),\n+              type->external_name()));\n+  }\n+}\n+\n@@ -3372,2 +3644,1 @@\n-  \/\/ Remember to strip ACC_SUPER bit\n-  return (access & (~JVM_ACC_SUPER));\n+  return access;\n@@ -3627,1 +3898,4 @@\n-static void print_vtable(intptr_t* start, int len, outputStream* st) {\n+static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {\n+  ResourceMark rm;\n+  int* forward_refs = NEW_RESOURCE_ARRAY(int, len);\n+  for (int i = 0; i < len; i++)  forward_refs[i] = 0;\n@@ -3631,0 +3905,5 @@\n+    if (forward_refs[i] != 0) {\n+      int from = forward_refs[i];\n+      int off = (int) start[from];\n+      st->print(\" (offset %d <= [%d])\", off, from);\n+    }\n@@ -3634,0 +3913,6 @@\n+    } else if (self != nullptr && e > 0 && e < 0x10000) {\n+      address location = self + e;\n+      int index = (int)((intptr_t*)location - start);\n+      st->print(\" (offset %d => [%d])\", (int)e, index);\n+      if (index >= 0 && index < len)\n+        forward_refs[index] = i;\n@@ -3640,1 +3925,22 @@\n-  return print_vtable(reinterpret_cast<intptr_t*>(start), len, st);\n+  return print_vtable(nullptr, reinterpret_cast<intptr_t*>(start), len, st);\n+}\n+\n+template<typename T>\n+ static void print_array_on(outputStream* st, Array<T>* array) {\n+   if (array == nullptr) { st->print_cr(\"nullptr\"); return; }\n+   array->print_value_on(st); st->cr();\n+   if (Verbose || WizardMode) {\n+     for (int i = 0; i < array->length(); i++) {\n+       st->print(\"%d : \", i); array->at(i)->print_value_on(st); st->cr();\n+     }\n+   }\n+ }\n+\n+static void print_array_on(outputStream* st, Array<int>* array) {\n+  if (array == nullptr) { st->print_cr(\"nullptr\"); return; }\n+  array->print_value_on(st); st->cr();\n+  if (Verbose || WizardMode) {\n+    for (int i = 0; i < array->length(); i++) {\n+      st->print(\"%d : %d\", i, array->at(i)); st->cr();\n+    }\n+  }\n@@ -3681,8 +3987,2 @@\n-  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);               st->cr();\n-  if (Verbose || WizardMode) {\n-    Array<Method*>* method_array = methods();\n-    for (int i = 0; i < method_array->length(); i++) {\n-      st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-    }\n-  }\n-  st->print(BULLET\"method ordering:   \"); method_ordering()->print_value_on(st);      st->cr();\n+  st->print(BULLET\"methods:           \"); print_array_on(st, methods());\n+  st->print(BULLET\"method ordering:   \"); print_array_on(st, method_ordering());\n@@ -3690,7 +3990,1 @@\n-    st->print(BULLET\"default_methods:   \"); default_methods()->print_value_on(st);    st->cr();\n-    if (Verbose) {\n-      Array<Method*>* method_array = default_methods();\n-      for (int i = 0; i < method_array->length(); i++) {\n-        st->print(\"%d : \", i); method_array->at(i)->print_value(); st->cr();\n-      }\n-    }\n+    st->print(BULLET\"default_methods:   \"); print_array_on(st, default_methods());\n@@ -3756,0 +4050,1 @@\n+  st->print(BULLET\"loadable descriptors:     \"); loadable_descriptors()->print_value_on(st); st->cr();\n@@ -3766,1 +4061,1 @@\n-  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);\n+  if (itable_length() > 0 && (Verbose || WizardMode))  print_vtable(nullptr, start_of_itable(), itable_length(), st);\n@@ -3798,0 +4093,1 @@\n+  for (int i = 0; i < _indent; i++) _st->print(\"  \");\n@@ -3800,1 +4096,1 @@\n-     fd->print_on(_st);\n+     fd->print_on(_st, _base_offset);\n@@ -3803,2 +4099,2 @@\n-     fd->print_on_for(_st, _obj);\n-     _st->cr();\n+     fd->print_on_for(_st, _obj, _indent, _base_offset);\n+     if (!fd->field_flags().is_flat()) _st->cr();\n@@ -3809,1 +4105,1 @@\n-void InstanceKlass::oop_print_on(oop obj, outputStream* st) {\n+void InstanceKlass::oop_print_on(oop obj, outputStream* st, int indent, int base_offset) {\n@@ -3825,1 +4121,1 @@\n-  FieldPrinter print_field(st, obj);\n+  FieldPrinter print_field(st, obj, indent, base_offset);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":348,"deletions":52,"binary":false,"changes":400,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/vmreg.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"oops\/refArrayKlass.hpp\"\n@@ -59,0 +61,1 @@\n+\/\/    [EMBEDDED InlineKlassFixedBlock] only if is an InlineKlass instance\n@@ -74,0 +77,1 @@\n+class BufferedInlineTypeBlob;\n@@ -89,0 +93,2 @@\n+   int _indent;\n+   int _base_offset;\n@@ -90,1 +96,2 @@\n-   FieldPrinter(outputStream* st, oop obj = nullptr) : _obj(obj), _st(st) {}\n+   FieldPrinter(outputStream* st, oop obj = nullptr, int indent = 0, int base_offset = 0) :\n+                 _obj(obj), _st(st), _indent(indent), _base_offset(base_offset) {}\n@@ -134,0 +141,54 @@\n+class SigEntry;\n+\n+class InlineKlassFixedBlock {\n+  Array<SigEntry>** _extended_sig;\n+  Array<VMRegPair>** _return_regs;\n+  address* _pack_handler;\n+  address* _pack_handler_jobject;\n+  address* _unpack_handler;\n+  int* _null_reset_value_offset;\n+  int _payload_offset;          \/\/ offset of the begining of the payload in a heap buffered instance\n+  int _payload_size_in_bytes;   \/\/ size of payload layout\n+  int _payload_alignment;       \/\/ alignment required for payload\n+  int _non_atomic_size_in_bytes; \/\/ size of null-free non-atomic flat layout\n+  int _non_atomic_alignment;    \/\/ alignment requirement for null-free non-atomic layout\n+  int _atomic_size_in_bytes;    \/\/ size and alignment requirement for a null-free atomic layout, -1 if no atomic flat layout is possible\n+  int _nullable_size_in_bytes;  \/\/ size and alignment requirement for a nullable layout (always atomic), -1 if no nullable flat layout is possible\n+  int _null_marker_offset;      \/\/ expressed as an offset from the beginning of the object for a heap buffered value\n+                                \/\/ payload_offset must be subtracted to get the offset from the beginning of the payload\n+\n+  friend class InlineKlass;\n+};\n+\n+class InlineLayoutInfo : public MetaspaceObj {\n+  InlineKlass* _klass;\n+  LayoutKind _kind;\n+  int _null_marker_offset; \/\/ null marker offset for this field, relative to the beginning of the current container\n+\n+ public:\n+  InlineLayoutInfo(): _klass(nullptr), _kind(LayoutKind::UNKNOWN), _null_marker_offset(-1)  {}\n+  InlineLayoutInfo(InlineKlass* ik, LayoutKind kind, int size, int nm_offset):\n+    _klass(ik), _kind(kind), _null_marker_offset(nm_offset) {}\n+\n+  InlineKlass* klass() const { return _klass; }\n+  void set_klass(InlineKlass* k) { _klass = k; }\n+\n+  LayoutKind kind() const {\n+    assert(_kind != LayoutKind::UNKNOWN, \"Not set\");\n+    return _kind;\n+  }\n+  void set_kind(LayoutKind lk) { _kind = lk; }\n+\n+  int null_marker_offset() const {\n+    assert(_null_marker_offset != -1, \"Not set\");\n+    return _null_marker_offset;\n+  }\n+  void set_null_marker_offset(int o) { _null_marker_offset = o; }\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  MetaspaceObj::Type type() const { return InlineLayoutInfoType; }\n+\n+  static ByteSize klass_offset() { return in_ByteSize(offset_of(InlineLayoutInfo, _klass)); }\n+  static ByteSize null_marker_offset_offset() { return in_ByteSize(offset_of(InlineLayoutInfo, _null_marker_offset)); }\n+};\n+\n@@ -139,0 +200,1 @@\n+  friend class TemplateTable;\n@@ -144,1 +206,1 @@\n-  InstanceKlass(const ClassFileParser& parser, KlassKind kind = Kind, ReferenceType reference_type = REF_NONE);\n+  InstanceKlass(const ClassFileParser& parser, KlassKind kind = Kind, markWord prototype = markWord::prototype(), ReferenceType reference_type = REF_NONE);\n@@ -282,0 +344,4 @@\n+  Array<InlineLayoutInfo>* _inline_layout_info_array;\n+  Array<u2>* _loadable_descriptors;\n+  const InlineKlassFixedBlock* _adr_inlineklass_fixed_block;\n+\n@@ -330,0 +396,15 @@\n+  bool has_inline_type_fields() const { return _misc_flags.has_inline_type_fields(); }\n+  void set_has_inline_type_fields()   { _misc_flags.set_has_inline_type_fields(true); }\n+\n+  bool is_naturally_atomic() const  { return _misc_flags.is_naturally_atomic(); }\n+  void set_is_naturally_atomic()    { _misc_flags.set_is_naturally_atomic(true); }\n+\n+  \/\/ Query if this class has atomicity requirements (default is yes)\n+  \/\/ This bit can occur anywhere, but is only significant\n+  \/\/ for inline classes *and* their super types.\n+  \/\/ It inherits from supers.\n+  \/\/ Its value depends on the ForceNonTearable VM option, the LooselyConsistentValue annotation\n+  \/\/ and the presence of flat fields with atomicity requirements\n+  bool must_be_atomic() const { return _misc_flags.must_be_atomic(); }\n+  void set_must_be_atomic()   { _misc_flags.set_must_be_atomic(true); }\n+\n@@ -394,0 +475,6 @@\n+  bool field_is_flat(int index) const { return field_flags(index).is_flat(); }\n+  bool field_has_null_marker(int index) const { return field_flags(index).has_null_marker(); }\n+  bool field_is_null_free_inline_type(int index) const;\n+  bool is_class_in_loadable_descriptors_attribute(Symbol* name) const;\n+\n+  int null_marker_offset(int index) const { return inline_layout_info(index).null_marker_offset(); }\n@@ -408,0 +495,3 @@\n+  Array<u2>* loadable_descriptors() const { return _loadable_descriptors; }\n+  void set_loadable_descriptors(Array<u2>* c) { _loadable_descriptors = c; }\n+\n@@ -503,0 +593,3 @@\n+  \/\/ Check if this klass can be null-free\n+  static void check_can_be_annotated_with_NullRestricted(InstanceKlass* type, Symbol* container_klass_name, TRAPS);\n+\n@@ -538,0 +631,3 @@\n+  static ByteSize kind_offset() { return in_ByteSize(offset_of(InstanceKlass, _kind)); }\n+  static ByteSize misc_flags_offset() { return in_ByteSize(offset_of(InstanceKlass, _misc_flags)); }\n+\n@@ -665,0 +761,2 @@\n+  bool supports_inline_types() const;\n+\n@@ -779,0 +877,7 @@\n+  \/\/ runtime support for strict statics\n+  bool has_strict_static_fields() const     { return _misc_flags.has_strict_static_fields(); }\n+  void set_has_strict_static_fields(bool b) { _misc_flags.set_has_strict_static_fields(b); }\n+  void notify_strict_static_access(int field_index, bool is_writing, TRAPS);\n+  const char* format_strict_static_message(Symbol* field_name, const char* doing_what = nullptr);\n+  void throw_strict_static_exception(Symbol* field_name, const char* when, TRAPS);\n+\n@@ -823,1 +928,0 @@\n-  objArrayOop allocate_objArray(int n, int length, TRAPS);\n@@ -873,0 +977,3 @@\n+  static ByteSize inline_layout_info_array_offset() { return in_ByteSize(offset_of(InstanceKlass, _inline_layout_info_array)); }\n+  static ByteSize adr_inlineklass_fixed_block_offset() { return in_ByteSize(offset_of(InstanceKlass, _adr_inlineklass_fixed_block)); }\n+\n@@ -936,1 +1043,2 @@\n-                  bool is_interface) {\n+                  bool is_interface,\n+                  bool is_inline_type) {\n@@ -941,1 +1049,2 @@\n-           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0));\n+           (is_interface ? (int)sizeof(Klass*)\/wordSize : 0) +\n+           (is_inline_type ? (int)sizeof(InlineKlassFixedBlock) : 0));\n@@ -947,1 +1056,2 @@\n-                                               is_interface());\n+                                               is_interface(),\n+                                               is_inline_klass());\n@@ -954,0 +1064,1 @@\n+  bool bounds_check(address addr, bool edge_ok = false, intptr_t size_in_bytes = -1) const PRODUCT_RETURN0;\n@@ -960,0 +1071,18 @@\n+  void set_inline_layout_info_array(Array<InlineLayoutInfo>* array) { _inline_layout_info_array = array; }\n+  Array<InlineLayoutInfo>* inline_layout_info_array() const { return _inline_layout_info_array; }\n+  void set_inline_layout_info(int index, InlineLayoutInfo *info) {\n+    assert(_inline_layout_info_array != nullptr ,\"Array not created\");\n+    _inline_layout_info_array->at_put(index, *info);\n+  }\n+  InlineLayoutInfo inline_layout_info(int index) const {\n+    assert(_inline_layout_info_array != nullptr ,\"Array not created\");\n+    return _inline_layout_info_array->at(index);\n+  }\n+  InlineLayoutInfo* inline_layout_info_adr(int index) {\n+    assert(_inline_layout_info_array != nullptr ,\"Array not created\");\n+    return _inline_layout_info_array->adr_at(index);\n+  }\n+\n+  inline InlineKlass* get_inline_type_field_klass(int idx) const ;\n+  inline InlineKlass* get_inline_type_field_klass_or_null(int idx) const;\n+\n@@ -961,1 +1090,1 @@\n-  int size_helper() const {\n+  virtual int size_helper() const {\n@@ -1012,0 +1141,1 @@\n+  const char* signature_name_of_carrier(char c) const;\n@@ -1137,1 +1267,1 @@\n-  void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);\n+  virtual void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);\n@@ -1164,1 +1294,2 @@\n-  void oop_print_on      (oop obj, outputStream* st);\n+  void oop_print_on      (oop obj, outputStream* st) { oop_print_on(obj, st, 0, 0); }\n+  void oop_print_on      (oop obj, outputStream* st, int indent = 0, int base_offset = 0);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":140,"deletions":9,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -277,17 +277,0 @@\n-static markWord make_prototype(const Klass* kls) {\n-  markWord prototype = markWord::prototype();\n-#ifdef _LP64\n-  if (UseCompactObjectHeaders) {\n-    \/\/ With compact object headers, the narrow Klass ID is part of the mark word.\n-    \/\/ We therfore seed the mark word with the narrow Klass ID.\n-    \/\/ Note that only those Klass that can be instantiated have a narrow Klass ID.\n-    \/\/ For those who don't, we leave the klass bits empty and assert if someone\n-    \/\/ tries to use those.\n-    const narrowKlass nk = CompressedKlassPointers::is_encodable(kls) ?\n-        CompressedKlassPointers::encode(const_cast<Klass*>(kls)) : 0;\n-    prototype = prototype.set_narrow_klass(nk);\n-  }\n-#endif\n-  return prototype;\n-}\n-\n@@ -302,2 +285,1 @@\n-Klass::Klass(KlassKind kind) : _kind(kind),\n-                               _prototype_header(make_prototype(this)),\n+Klass::Klass(KlassKind kind, markWord prototype_header) : _kind(kind),\n@@ -305,0 +287,1 @@\n+  set_prototype_header(make_prototype_header(this, prototype_header));\n@@ -317,2 +300,2 @@\n-  int  tag   =  isobj ? _lh_array_tag_obj_value : _lh_array_tag_type_value;\n-  int lh = array_layout_helper(tag, hsize, etype, exact_log2(esize));\n+  int  tag   =  isobj ? _lh_array_tag_ref_value : _lh_array_tag_type_value;\n+  int lh = array_layout_helper(tag, false, hsize, etype, exact_log2(esize));\n@@ -322,1 +305,1 @@\n-  assert(layout_helper_is_objArray(lh) == isobj, \"correct kind\");\n+  assert(layout_helper_is_refArray(lh) == isobj, \"correct kind\");\n@@ -1036,4 +1019,2 @@\n-     if (UseCompactObjectHeaders) {\n-       st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n-       st->cr();\n-     }\n+     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n+     st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -69,12 +69,16 @@\n-  enum KlassKind : u2 {\n-    InstanceKlassKind,\n-    InstanceRefKlassKind,\n-    InstanceMirrorKlassKind,\n-    InstanceClassLoaderKlassKind,\n-    InstanceStackChunkKlassKind,\n-    TypeArrayKlassKind,\n-    ObjArrayKlassKind,\n-    UnknownKlassKind\n-  };\n-\n-  static const uint KLASS_KIND_COUNT = ObjArrayKlassKind + 1;\n+   enum KlassKind : u2\n+   {\n+     InstanceKlassKind,\n+     InlineKlassKind,\n+     InstanceRefKlassKind,\n+     InstanceMirrorKlassKind,\n+     InstanceClassLoaderKlassKind,\n+     InstanceStackChunkKlassKind,\n+     TypeArrayKlassKind,\n+     ObjArrayKlassKind,\n+     RefArrayKlassKind,\n+     FlatArrayKlassKind,\n+     UnknownKlassKind\n+   };\n+\n+   static const uint KLASS_KIND_COUNT = FlatArrayKlassKind + 1;\n@@ -102,1 +106,1 @@\n-  \/\/    tag is 0x80 if the elements are oops, 0xC0 if non-oops\n+  \/\/    tag is 0x80 if the elements are oops, 0xC0 if non-oops, 0xA0 if value types\n@@ -205,1 +209,1 @@\n-  Klass(KlassKind kind);\n+  Klass(KlassKind kind, markWord prototype_header = markWord::prototype());\n@@ -453,1 +457,1 @@\n-  static const int _lh_array_tag_bits          = 2;\n+  static const int _lh_array_tag_bits          = 4;\n@@ -455,2 +459,9 @@\n-  static const int _lh_array_tag_obj_value     = ~0x01;   \/\/ 0x80000000 >> 30\n-  static const unsigned int _lh_array_tag_type_value = 0Xffffffff; \/\/ ~0x00,  \/\/ 0xC0000000 >> 30\n+  static const unsigned int _lh_array_tag_type_value = 0Xfffffffc;\n+  static const unsigned int _lh_array_tag_flat_value = 0Xfffffffa;\n+  static const unsigned int _lh_array_tag_ref_value  = 0Xfffffff8;\n+\n+  \/\/ null-free array flag bit under the array tag bits, shift one more to get array tag value\n+  static const int _lh_null_free_shift = _lh_array_tag_shift - 1;\n+  static const int _lh_null_free_mask  = 1;\n+\n+  static const jint _lh_array_tag_flat_value_bit_inplace = (jint) (1 << (_lh_array_tag_shift + 1));\n@@ -474,2 +485,1 @@\n-    \/\/ _lh_array_tag_type_value == (lh >> _lh_array_tag_shift);\n-    return (juint)lh >= (juint)(_lh_array_tag_type_value << _lh_array_tag_shift);\n+    return (juint) _lh_array_tag_type_value == (juint)(lh >> _lh_array_tag_shift);\n@@ -477,3 +487,14 @@\n-  static bool layout_helper_is_objArray(jint lh) {\n-    \/\/ _lh_array_tag_obj_value == (lh >> _lh_array_tag_shift);\n-    return (jint)lh < (jint)(_lh_array_tag_type_value << _lh_array_tag_shift);\n+  static bool layout_helper_is_refArray(jint lh) {\n+    return (juint)_lh_array_tag_ref_value == (juint)(lh >> _lh_array_tag_shift);\n+  }\n+  static bool layout_helper_is_flatArray(jint lh) {\n+    return (juint)_lh_array_tag_flat_value == (juint)(lh >> _lh_array_tag_shift);\n+  }\n+  static bool layout_helper_is_null_free(jint lh) {\n+    assert(layout_helper_is_flatArray(lh) || layout_helper_is_refArray(lh), \"must be array of inline types\");\n+    return ((lh >> _lh_null_free_shift) & _lh_null_free_mask);\n+  }\n+  static jint layout_helper_set_null_free(jint lh) {\n+    lh |= (_lh_null_free_mask << _lh_null_free_shift);\n+    assert(layout_helper_is_null_free(lh), \"Bad encoding\");\n+    return lh;\n@@ -490,1 +511,1 @@\n-    assert(btvalue >= T_BOOLEAN && btvalue <= T_OBJECT, \"sanity\");\n+    assert((btvalue >= T_BOOLEAN && btvalue <= T_OBJECT) || btvalue == T_FLAT_ELEMENT, \"sanity\");\n@@ -511,1 +532,1 @@\n-    assert(l2esz <= LogBytesPerLong,\n+    assert(layout_helper_element_type(lh) == T_FLAT_ELEMENT || l2esz <= LogBytesPerLong,\n@@ -515,1 +536,1 @@\n-  static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {\n+  static jint array_layout_helper(jint tag, bool null_free, int hsize, BasicType etype, int log2_esize) {\n@@ -517,0 +538,1 @@\n+      |    ((null_free ? 1 : 0) <<  _lh_null_free_shift)\n@@ -659,0 +681,1 @@\n+  virtual bool is_refArray_klass_slow()     const { return false; }\n@@ -660,0 +683,1 @@\n+  virtual bool is_flatArray_klass_slow()    const { return false; }\n@@ -661,0 +685,2 @@\n+  \/\/ current implementation uses this method even in non debug builds\n+  virtual bool is_inline_klass_slow()       const { return false; }\n@@ -676,2 +702,1 @@\n-  \/\/ Other is anything that is not one of the more specialized kinds of InstanceKlass.\n-  bool is_other_instance_klass()        const { return _kind == InstanceKlassKind; }\n+  bool is_inline_klass()                const { return assert_same_query(_kind == InlineKlassKind, is_inline_klass_slow()); }\n@@ -683,1 +708,3 @@\n-  bool is_objArray_klass()              const { return assert_same_query( _kind == ObjArrayKlassKind,  is_objArray_klass_slow()); }\n+  bool is_flatArray_klass()             const { return assert_same_query( _kind == FlatArrayKlassKind, is_flatArray_klass_slow()); }\n+  bool is_objArray_klass()              const { return assert_same_query( _kind == ObjArrayKlassKind || _kind == RefArrayKlassKind || _kind == FlatArrayKlassKind,  is_objArray_klass_slow()); }\n+  bool is_refArray_klass()              const { return assert_same_query( _kind == RefArrayKlassKind, is_refArray_klass_slow()); }\n@@ -685,0 +712,1 @@\n+  bool is_refined_objArray_klass()      const { return is_refArray_klass() || is_flatArray_klass(); }\n@@ -687,0 +715,2 @@\n+  inline bool is_null_free_array_klass() const { return !is_typeArray_klass() && layout_helper_is_null_free(layout_helper()); }\n+\n@@ -695,1 +725,1 @@\n-  bool is_super() const                 { return _access_flags.is_super(); }\n+  bool is_identity_class() const        { assert(is_instance_klass(), \"only for instanceKlass\"); return _access_flags.is_identity_class(); }\n@@ -712,0 +742,1 @@\n+  static inline markWord make_prototype_header(const Klass* kls, markWord prototype = markWord::prototype());\n@@ -715,0 +746,1 @@\n+  inline void set_prototype_header_klass(narrowKlass klass);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":61,"deletions":29,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -1233,4 +1233,4 @@\n-  if (m->is_static())             return false; \/\/ e.g., Stream.empty\n-  if (m->is_object_initializer()) return false; \/\/ <init>\n-  if (m->is_static_initializer()) return false; \/\/ <clinit>\n-  if (m->is_private())            return false; \/\/ uses direct call\n+  if (m->is_static())             return false;   \/\/ e.g., Stream.empty\n+  if (m->is_private())            return false;   \/\/ uses direct call\n+  if (m->is_object_constructor()) return false;   \/\/ <init>(...)V\n+  if (m->is_class_initializer())  return false;   \/\/ <clinit>()V\n@@ -1443,0 +1443,12 @@\n+int count_interface_methods_needing_itable_index(Array<Method*>* methods) {\n+  int method_count = 0;\n+  if (methods->length() > 0) {\n+    for (int i = methods->length(); --i >= 0; ) {\n+      if (interface_method_needs_itable_index(methods->at(i))) {\n+        method_count++;\n+      }\n+    }\n+  }\n+  return method_count;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -301,1 +301,4 @@\n-  int size_offset_table()                { return _size_offset_table; }\n+  InstanceKlass* klass() const          { return _klass; }\n+  int table_offset() const              { return _table_offset; }\n+  int size_offset_table() const         { return _size_offset_table; }\n+  int size_method_table() const         { return _size_method_table; }\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -125,1 +126,0 @@\n-\n@@ -170,0 +170,5 @@\n+address Method::get_c2i_inline_entry() {\n+  assert(adapter() != nullptr, \"must have\");\n+  return adapter()->get_c2i_inline_entry();\n+}\n+\n@@ -175,0 +180,5 @@\n+address Method::get_c2i_unverified_inline_entry() {\n+  assert(adapter() != nullptr, \"must have\");\n+  return adapter()->get_c2i_unverified_inline_entry();\n+}\n+\n@@ -400,1 +410,1 @@\n-  if (!method_holder()->is_rewritten()) {\n+  if (!method_holder()->is_rewritten() || CDSConfig::is_valhalla_preview()) {\n@@ -443,0 +453,2 @@\n+    _from_compiled_inline_entry = _adapter->get_c2i_inline_entry();\n+    _from_compiled_inline_ro_entry = _adapter->get_c2i_inline_ro_entry();\n@@ -732,0 +744,14 @@\n+\/\/ InlineKlass the method is declared to return. This must not\n+\/\/ safepoint as it is called with references live on the stack at\n+\/\/ locations the GC is unaware of.\n+InlineKlass* Method::returns_inline_type() const {\n+  assert(InlineTypeReturnedAsFields, \"Inline types should never be returned as fields\");\n+  if (is_native()) {\n+    return nullptr;\n+  }\n+  NoSafepointVerifier nsv;\n+  SignatureStream ss(signature());\n+  ss.skip_to_return_type();\n+  return ss.as_inline_klass(method_holder());\n+}\n+\n@@ -880,0 +906,5 @@\n+  if (has_scalarized_return()) {\n+    \/\/ Don't treat this as (trivial) getter method because the\n+    \/\/ inline type should be returned in a scalarized form.\n+    return false;\n+  }\n@@ -901,0 +932,5 @@\n+  if (has_scalarized_args()) {\n+    \/\/ Don't treat this as (trivial) setter method because the\n+    \/\/ inline type argument should be passed in a scalarized form.\n+    return false;\n+  }\n@@ -911,6 +947,2 @@\n-          Bytecodes::is_return(java_code_at(last_index)));\n-}\n-\n-bool Method::has_valid_initializer_flags() const {\n-  return (is_static() ||\n-          method_holder()->major_version() < 51);\n+          Bytecodes::is_return(java_code_at(last_index)) &&\n+          !has_scalarized_args());\n@@ -919,1 +951,1 @@\n-bool Method::is_static_initializer() const {\n+bool Method::is_class_initializer() const {\n@@ -923,2 +955,3 @@\n-  return name() == vmSymbols::class_initializer_name() &&\n-         has_valid_initializer_flags();\n+  return (name() == vmSymbols::class_initializer_name() &&\n+          (is_static() ||\n+           method_holder()->major_version() < 51));\n@@ -927,2 +960,3 @@\n-bool Method::is_object_initializer() const {\n-   return name() == vmSymbols::object_initializer_name();\n+\/\/ A method named <init>, is a classic object constructor.\n+bool Method::is_object_constructor() const {\n+  return name() == vmSymbols::object_initializer_name();\n@@ -991,1 +1025,1 @@\n-  if( constants()->tag_at(klass_index).is_unresolved_klass() ) {\n+  if( constants()->tag_at(klass_index).is_unresolved_klass()) {\n@@ -1006,1 +1040,3 @@\n-    if (constants()->tag_at(klass_index).is_unresolved_klass()) return false;\n+    if (constants()->tag_at(klass_index).is_unresolved_klass()) {\n+      return false;\n+    }\n@@ -1174,1 +1210,3 @@\n-    _from_compiled_entry = nullptr;\n+    _from_compiled_entry    = nullptr;\n+    _from_compiled_inline_entry = nullptr;\n+    _from_compiled_inline_ro_entry = nullptr;\n@@ -1176,1 +1214,3 @@\n-    _from_compiled_entry = adapter()->get_c2i_entry();\n+    _from_compiled_entry    = adapter()->get_c2i_entry();\n+    _from_compiled_inline_entry = adapter()->get_c2i_inline_entry();\n+    _from_compiled_inline_ro_entry = adapter()->get_c2i_inline_ro_entry();\n@@ -1210,0 +1250,2 @@\n+  _from_compiled_inline_entry = nullptr;\n+  _from_compiled_inline_ro_entry = nullptr;\n@@ -1241,0 +1283,2 @@\n+  set_has_scalarized_args(false);\n+  set_has_scalarized_return(false);\n@@ -1277,0 +1321,3 @@\n+  if (InlineTypeReturnedAsFields && returns_inline_type() && !has_scalarized_return()) {\n+    set_has_scalarized_return();\n+  }\n@@ -1287,1 +1334,4 @@\n-    h_method->_from_compiled_entry = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+    h_method->_from_compiled_entry = wrong_method_abstract;\n+    h_method->_from_compiled_inline_entry = wrong_method_abstract;\n+    h_method->_from_compiled_inline_ro_entry = wrong_method_abstract;\n@@ -1292,0 +1342,2 @@\n+    h_method->_from_compiled_inline_entry = adapter()->get_c2i_inline_entry();\n+    h_method->_from_compiled_inline_ro_entry = adapter()->get_c2i_inline_ro_entry();\n@@ -1347,0 +1399,12 @@\n+address Method::verified_inline_code_entry() {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_entry != nullptr, \"must be set\");\n+  return _from_compiled_inline_entry;\n+}\n+\n+address Method::verified_inline_ro_code_entry() {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(_from_compiled_inline_ro_entry != nullptr, \"must be set\");\n+  return _from_compiled_inline_ro_entry;\n+}\n+\n@@ -1378,0 +1442,2 @@\n+  mh->_from_compiled_inline_entry = code->verified_inline_entry_point();\n+  mh->_from_compiled_inline_ro_entry = code->verified_inline_ro_entry_point();\n@@ -1570,0 +1636,2 @@\n+    m->set_from_compiled_inline_entry(m->adapter()->get_c2i_inline_entry());\n+    m->set_from_compiled_inline_ro_entry(m->adapter()->get_c2i_inline_ro_entry());\n@@ -2187,0 +2255,25 @@\n+bool Method::is_scalarized_arg(int idx) const {\n+  if (!has_scalarized_args()) {\n+    return false;\n+  }\n+  \/\/ Search through signature and check if argument is wrapped in T_METADATA\/T_VOID\n+  int depth = 0;\n+  const GrowableArray<SigEntry>* sig = adapter()->get_sig_cc();\n+  for (int i = 0; i < sig->length(); i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_METADATA) {\n+      depth++;\n+    }\n+    if (idx == 0) {\n+      break; \/\/ Argument found\n+    }\n+    if (bt == T_VOID && (sig->at(i-1)._bt != T_LONG && sig->at(i-1)._bt != T_DOUBLE)) {\n+      depth--;\n+    }\n+    if (depth == 0 && bt != T_LONG && bt != T_DOUBLE) {\n+      idx--; \/\/ Advance to next argument\n+    }\n+  }\n+  return depth != 0;\n+}\n+\n@@ -2212,0 +2305,4 @@\n+#ifdef ASSERT\n+  if (valid_itable_index())\n+    st->print_cr(\" - itable index:      %d\",   itable_index());\n+#endif\n@@ -2219,1 +2316,3 @@\n-  st->print_cr(\" - compiled entry     \" PTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled entry           \" PTR_FORMAT, p2i(from_compiled_entry()));\n+  st->print_cr(\" - compiled inline entry    \" PTR_FORMAT, p2i(from_compiled_inline_entry()));\n+  st->print_cr(\" - compiled inline ro entry \" PTR_FORMAT, p2i(from_compiled_inline_ro_entry()));\n@@ -2289,0 +2388,1 @@\n+  if (WizardMode) access_flags().print_on(st);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":119,"deletions":19,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  u1 _flags;                    \/\/ Flags: [0000|00|is_final|is_volatile]\n+  u1 _flags;                    \/\/ Flags: [000|has_null_marker|is_null_free_inline_type|is_flat|is_final|is_volatile]\n@@ -125,0 +125,4 @@\n+      is_flat_shift         = 2,\n+      is_null_free_inline_type_shift = 3,\n+      has_null_marker_shift = 4,\n+      max_flag_shift = has_null_marker_shift\n@@ -137,0 +141,3 @@\n+  bool is_flat()                const { return (_flags & (1 << is_flat_shift))     != 0; }\n+  bool is_null_free_inline_type() const { return (_flags & (1 << is_null_free_inline_type_shift)) != 0; }\n+  bool has_null_marker()        const { return (_flags & (1 << has_null_marker_shift)) != 0; }\n@@ -154,2 +161,6 @@\n-  void set_flags(bool is_final_flag, bool is_volatile_flag) {\n-    int new_flags = (is_final_flag << is_final_shift) | static_cast<int>(is_volatile_flag);\n+  void set_flags(bool is_final_flag, bool is_volatile_flag, bool is_flat_flag, bool is_null_free_inline_type_flag,\n+                 bool has_null_marker_flag) {\n+    u1 new_flags = ((is_final_flag ? 1 : 0) << is_final_shift) | static_cast<int>(is_volatile_flag) |\n+      ((is_flat_flag ? 1 : 0) << is_flat_shift) |\n+      ((is_null_free_inline_type_flag ? 1 : 0) << is_null_free_inline_type_shift) |\n+      ((has_null_marker_flag ? 1 : 0) << has_null_marker_shift);\n@@ -159,0 +170,3 @@\n+    assert(is_flat() == is_flat_flag, \"Must be\");\n+    assert(is_null_free_inline_type() == is_null_free_inline_type_flag, \"Must be\");\n+    assert(has_null_marker() == has_null_marker_flag, \"Must be\");\n@@ -170,1 +184,1 @@\n-  \/\/ Populate the strucutre with resolution information\n+  \/\/ Populate the structure with resolution information\n@@ -180,0 +194,1 @@\n+    assert(is_valid(), \"invalid\");\n@@ -197,0 +212,2 @@\n+  \/\/ Debug help\n+  bool is_valid() const;\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -849,0 +849,6 @@\n+  product(bool, UseArrayLoadStoreProfile, true,                             \\\n+          \"Take advantage of profiling at array load\/store\")                \\\n+                                                                            \\\n+  product(bool, UseACmpProfile, true,                                       \\\n+          \"Take advantage of profiling at acmp\")                            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"ci\/ciFlatArrayKlass.hpp\"\n+#include \"ci\/ciInlineKlass.hpp\"\n@@ -34,0 +36,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -39,0 +42,1 @@\n+#include \"opto\/inlinetypenode.hpp\"\n@@ -42,0 +46,1 @@\n+#include \"opto\/narrowptrnode.hpp\"\n@@ -49,0 +54,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -55,1 +61,1 @@\n-GraphKit::GraphKit(JVMState* jvms)\n+GraphKit::GraphKit(JVMState* jvms, PhaseGVN* gvn)\n@@ -58,1 +64,1 @@\n-    _gvn(*C->initial_gvn()),\n+    _gvn((gvn != nullptr) ? *gvn : *C->initial_gvn()),\n@@ -61,0 +67,1 @@\n+  assert(gvn == nullptr || !gvn->is_IterGVN() || gvn->is_IterGVN()->delay_transform(), \"delay transform should be enabled\");\n@@ -64,0 +71,7 @@\n+#ifdef ASSERT\n+  if (_gvn.is_IterGVN() != nullptr) {\n+    assert(_gvn.is_IterGVN()->delay_transform(), \"Transformation must be delayed if IterGVN is used\");\n+    \/\/ Save the initial size of _for_igvn worklist for verification (see ~GraphKit)\n+    _worklist_size = _gvn.C->igvn_worklist()->size();\n+  }\n+#endif\n@@ -348,1 +362,2 @@\n-  assert(ex_jvms->sp() == phi_map->_jvms->sp(), \"matching stack sizes\");\n+  \/\/ TODO 8325632 Re-enable\n+  \/\/ assert(ex_jvms->sp() == phi_map->_jvms->sp(), \"matching stack sizes\");\n@@ -876,1 +891,1 @@\n-           (is_anewarray && code == Bytecodes::_multianewarray);\n+           (is_anewarray && (code == Bytecodes::_multianewarray));\n@@ -967,0 +982,2 @@\n+\n+  JVMState* callee_jvms = nullptr;\n@@ -992,2 +1009,3 @@\n-      for (j = 0; j < l; j++)\n-        call->set_req(p++, in_map->in(k+j));\n+      for (j = 0; j < l; j++) {\n+        call->set_req(p++, in_map->in(k + j));\n+      }\n@@ -1003,2 +1021,3 @@\n-      for (j = 0; j < l; j++)\n-        call->set_req(p++, in_map->in(k+j));\n+      for (j = 0; j < l; j++) {\n+        call->set_req(p++, in_map->in(k + j));\n+      }\n@@ -1043,0 +1062,1 @@\n+    callee_jvms = out_jvms;\n@@ -1218,1 +1238,1 @@\n-  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS));\n+  return _gvn.transform(LoadKlassNode::make(_gvn, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n@@ -1267,1 +1287,2 @@\n-                                  bool speculative) {\n+                                  bool speculative,\n+                                  bool null_marker_check) {\n@@ -1272,0 +1293,23 @@\n+  if (value->is_InlineType()) {\n+    \/\/ Null checking a scalarized but nullable inline type. Check the null marker\n+    \/\/ input instead of the oop input to avoid keeping buffer allocations alive.\n+    InlineTypeNode* vtptr = value->as_InlineType();\n+    while (vtptr->get_oop()->is_InlineType()) {\n+      vtptr = vtptr->get_oop()->as_InlineType();\n+    }\n+    null_check_common(vtptr->get_null_marker(), T_INT, assert_null, null_control, speculative, true);\n+    if (stopped()) {\n+      return top();\n+    }\n+    if (assert_null) {\n+      \/\/ TODO 8284443 Scalarize here (this currently leads to compilation bailouts)\n+      \/\/ vtptr = InlineTypeNode::make_null(_gvn, vtptr->type()->inline_klass());\n+      \/\/ replace_in_map(value, vtptr);\n+      \/\/ return vtptr;\n+      replace_in_map(value, null());\n+      return null();\n+    }\n+    bool do_replace_in_map = (null_control == nullptr || (*null_control) == top());\n+    return cast_not_null(value, do_replace_in_map);\n+  }\n+\n@@ -1375,1 +1419,1 @@\n-  } else if (type == T_OBJECT) {\n+  } else if (type == T_OBJECT || null_marker_check) {\n@@ -1449,1 +1493,0 @@\n-\n@@ -1453,0 +1496,9 @@\n+  if (obj->is_InlineType()) {\n+    Node* vt = obj->isa_InlineType()->clone_if_required(&gvn(), map(), do_replace_in_map);\n+    vt->as_InlineType()->set_null_marker(_gvn);\n+    vt = _gvn.transform(vt);\n+    if (do_replace_in_map) {\n+      replace_in_map(obj, vt);\n+    }\n+    return vt;\n+  }\n@@ -1469,0 +1521,11 @@\n+Node* GraphKit::cast_to_non_larval(Node* obj) {\n+  const Type* obj_type = gvn().type(obj);\n+  if (obj->is_InlineType() || !obj_type->is_inlinetypeptr()) {\n+    return obj;\n+  }\n+\n+  Node* new_obj = InlineTypeNode::make_from_oop(this, obj, obj_type->inline_klass());\n+  replace_in_map(obj, new_obj);\n+  return new_obj;\n+}\n+\n@@ -1581,0 +1644,1 @@\n+\n@@ -1634,1 +1698,3 @@\n-                                DecoratorSet decorators) {\n+                                DecoratorSet decorators,\n+                                bool safe_for_replace,\n+                                const InlineTypeNode* vt) {\n@@ -1647,0 +1713,7 @@\n+  if (val->is_InlineType()) {\n+    \/\/ Store to non-flat field. Buffer the inline type and make sure\n+    \/\/ the store is re-executed if the allocation triggers deoptimization.\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    val = val->as_InlineType()->buffer(this, safe_for_replace);\n+  }\n@@ -1650,1 +1723,1 @@\n-  C2ParseAccess access(this, decorators | C2_WRITE_ACCESS, bt, obj, addr);\n+  C2ParseAccess access(this, decorators | C2_WRITE_ACCESS, bt, obj, addr, nullptr, vt);\n@@ -1663,1 +1736,2 @@\n-                               DecoratorSet decorators) {\n+                               DecoratorSet decorators,\n+                               Node* ctl) {\n@@ -1669,1 +1743,1 @@\n-  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, obj, addr);\n+  C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, obj, addr, ctl);\n@@ -1774,2 +1848,15 @@\n-  uint shift  = exact_log2(type2aelembytes(elembt));\n-  uint header = arrayOopDesc::base_offset_in_bytes(elembt);\n+  const TypeAryPtr* arytype = _gvn.type(ary)->is_aryptr();\n+  uint shift;\n+  uint header;\n+  if (arytype->is_flat() && arytype->klass_is_exact()) {\n+    \/\/ We can only determine the flat array layout statically if the klass is exact. Otherwise, we could have different\n+    \/\/ value classes at runtime with a potentially different layout. The caller needs to fall back to call\n+    \/\/ load\/store_unknown_inline_Type() at runtime. We could return a sentinel node for the non-exact case but that\n+    \/\/ might mess with other GVN transformations in between. Thus, we just continue in the else branch normally, even\n+    \/\/ though we don't need the address node in this case and throw it away again.\n+    shift = arytype->flat_log_elem_size();\n+    header = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT);\n+  } else {\n+    shift = exact_log2(type2aelembytes(elembt));\n+    header = arrayOopDesc::base_offset_in_bytes(elembt);\n+  }\n@@ -1791,0 +1878,28 @@\n+Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* vk, bool is_null_free, bool is_not_null_free, bool is_atomic) {\n+  assert(vk->maybe_flat_in_array(), \"element of type %s cannot be flat in array\", vk->name()->as_utf8());\n+  if (!vk->has_nullable_atomic_layout()) {\n+    \/\/ Element does not have a nullable flat layout, cannot be nullable\n+    is_null_free = true;\n+  }\n+  if (!vk->has_atomic_layout() && !vk->has_non_atomic_layout()) {\n+    \/\/ Element does not have a null-free flat layout, cannot be null-free\n+    is_not_null_free = true;\n+  }\n+  if (is_null_free) {\n+    \/\/ TODO 8350865 Impossible type\n+    is_not_null_free = false;\n+  }\n+\n+  bool is_exact = is_null_free || is_not_null_free;\n+  ciArrayKlass* array_klass = ciArrayKlass::make(vk, is_null_free, is_atomic, true);\n+  assert(array_klass->is_elem_null_free() == is_null_free, \"inconsistency\");\n+  assert(array_klass->is_elem_atomic() == is_atomic, \"inconsistency\");\n+  const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+  arytype = arytype->cast_to_exactness(is_exact);\n+  arytype = arytype->cast_to_not_null_free(is_not_null_free);\n+  assert(arytype->is_null_free() == is_null_free, \"inconsistency\");\n+  assert(arytype->is_not_null_free() == is_not_null_free, \"inconsistency\");\n+  assert(arytype->is_atomic() == is_atomic, \"inconsistency\");\n+  return _gvn.transform(new CastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n+}\n+\n@@ -1806,6 +1921,42 @@\n-void GraphKit::set_arguments_for_java_call(CallJavaNode* call) {\n-  \/\/ Add the call arguments:\n-  uint nargs = call->method()->arg_size();\n-  for (uint i = 0; i < nargs; i++) {\n-    Node* arg = argument(i);\n-    call->init_req(i + TypeFunc::Parms, arg);\n+void GraphKit::set_arguments_for_java_call(CallJavaNode* call, bool is_late_inline) {\n+  PreserveReexecuteState preexecs(this);\n+  if (EnableValhalla) {\n+    \/\/ Make sure the call is \"re-executed\", if buffering of inline type arguments triggers deoptimization.\n+    \/\/ At this point, the call hasn't been executed yet, so we will only ever execute the call once.\n+    jvms()->set_should_reexecute(true);\n+    int arg_size = method()->get_declared_signature_at_bci(bci())->arg_size_for_bc(java_bc());\n+    inc_sp(arg_size);\n+  }\n+  \/\/ Add the call arguments\n+  const TypeTuple* domain = call->tf()->domain_sig();\n+  uint nargs = domain->cnt();\n+  int arg_num = 0;\n+  for (uint i = TypeFunc::Parms, idx = TypeFunc::Parms; i < nargs; i++) {\n+    Node* arg = argument(i-TypeFunc::Parms);\n+    const Type* t = domain->field_at(i);\n+    \/\/ TODO 8284443 A static call to a mismatched method should still be scalarized\n+    if (t->is_inlinetypeptr() && !call->method()->get_Method()->mismatch() && call->method()->is_scalarized_arg(arg_num)) {\n+      \/\/ We don't pass inline type arguments by reference but instead pass each field of the inline type\n+      if (!arg->is_InlineType()) {\n+        assert(_gvn.type(arg)->is_zero_type() && !t->inline_klass()->is_null_free(), \"Unexpected argument type\");\n+        arg = InlineTypeNode::make_from_oop(this, arg, t->inline_klass());\n+      }\n+      InlineTypeNode* vt = arg->as_InlineType();\n+      vt->pass_fields(this, call, idx, true, !t->maybe_null());\n+      \/\/ If an inline type argument is passed as fields, attach the Method* to the call site\n+      \/\/ to be able to access the extended signature later via attached_method_before_pc().\n+      \/\/ For example, see CompiledMethod::preserve_callee_argument_oops().\n+      call->set_override_symbolic_info(true);\n+      \/\/ Register an evol dependency on the callee method to make sure that this method is deoptimized and\n+      \/\/ re-compiled with a non-scalarized calling convention if the callee method is later marked as mismatched.\n+      C->dependencies()->assert_evol_method(call->method());\n+      arg_num++;\n+      continue;\n+    } else if (arg->is_InlineType()) {\n+      \/\/ Pass inline type argument via oop to callee\n+      arg = arg->as_InlineType()->buffer(this, true);\n+    }\n+    if (t != Type::HALF) {\n+      arg_num++;\n+    }\n+    call->init_req(idx++, arg);\n@@ -1849,7 +2000,0 @@\n-  \/\/ Capture the return value, if any.\n-  Node* ret;\n-  if (call->method() == nullptr ||\n-      call->method()->return_type()->basic_type() == T_VOID)\n-        ret = top();\n-  else  ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-\n@@ -1868,0 +2012,72 @@\n+\n+  \/\/ Capture the return value, if any.\n+  Node* ret;\n+  if (call->method() == nullptr || call->method()->return_type()->basic_type() == T_VOID) {\n+    ret = top();\n+  } else if (call->tf()->returns_inline_type_as_fields()) {\n+    \/\/ Return of multiple values (inline type fields): we create a\n+    \/\/ InlineType node, each field is a projection from the call.\n+    ciInlineKlass* vk = call->method()->return_type()->as_inline_klass();\n+    uint base_input = TypeFunc::Parms;\n+    ret = InlineTypeNode::make_from_multi(this, call, vk, base_input, false, false);\n+  } else {\n+    ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n+    ciType* t = call->method()->return_type();\n+    if (!t->is_loaded() && InlineTypeReturnedAsFields) {\n+      \/\/ The return type is unloaded but the callee might later be C2 compiled and then return\n+      \/\/ in scalarized form when the return type is loaded. Handle this similar to what we do in\n+      \/\/ PhaseMacroExpand::expand_mh_intrinsic_return by calling into the runtime to buffer.\n+      \/\/ It's a bit unfortunate because we will deopt anyway but the interpreter needs an oop.\n+      IdealKit ideal(this);\n+      IdealVariable res(ideal);\n+      ideal.declarations_done();\n+      ideal.if_then(ret, BoolTest::eq, ideal.makecon(TypePtr::NULL_PTR)); {\n+        \/\/ Return value is null\n+        ideal.set(res, ret);\n+      } ideal.else_(); {\n+        \/\/ Return value is non-null\n+        sync_kit(ideal);\n+\n+        \/\/ Change return type of call to scalarized return\n+        const TypeFunc* tf = call->_tf;\n+        const TypeTuple* domain = OptoRuntime::store_inline_type_fields_Type()->domain_cc();\n+        const TypeFunc* new_tf = TypeFunc::make(tf->domain_sig(), tf->domain_cc(), tf->range_sig(), domain);\n+        call->_tf = new_tf;\n+        _gvn.set_type(call, call->Value(&_gvn));\n+        _gvn.set_type(ret, ret->Value(&_gvn));\n+\n+        Node* store_to_buf_call = make_runtime_call(RC_NO_LEAF | RC_NO_IO,\n+                                                    OptoRuntime::store_inline_type_fields_Type(),\n+                                                    StubRoutines::store_inline_type_fields_to_buf(),\n+                                                    nullptr, TypePtr::BOTTOM, ret);\n+\n+        \/\/ We don't know how many values are returned. This assumes the\n+        \/\/ worst case, that all available registers are used.\n+        for (uint i = TypeFunc::Parms+1; i < domain->cnt(); i++) {\n+          if (domain->field_at(i) == Type::HALF) {\n+            store_to_buf_call->init_req(i, top());\n+            continue;\n+          }\n+          Node* proj =_gvn.transform(new ProjNode(call, i));\n+          store_to_buf_call->init_req(i, proj);\n+        }\n+        make_slow_call_ex(store_to_buf_call, env()->Throwable_klass(), false);\n+\n+        Node* buf = _gvn.transform(new ProjNode(store_to_buf_call, TypeFunc::Parms));\n+        const Type* buf_type = TypeOopPtr::make_from_klass(t->as_klass())->join_speculative(TypePtr::NOTNULL);\n+        buf = _gvn.transform(new CheckCastPPNode(control(), buf, buf_type));\n+\n+        ideal.set(res, buf);\n+        ideal.sync_kit(this);\n+      } ideal.end_if();\n+      sync_kit(ideal);\n+      ret = _gvn.transform(ideal.value(res));\n+    }\n+    if (t->is_klass()) {\n+      const Type* type = TypeOopPtr::make_from_klass(t->as_klass());\n+      if (type->is_inlinetypeptr()) {\n+        ret = InlineTypeNode::make_from_oop(this, ret, type->inline_klass());\n+      }\n+    }\n+  }\n+\n@@ -1969,2 +2185,1 @@\n-  CallProjections callprojs;\n-  call->extract_projections(&callprojs, true, do_asserts);\n+  CallProjections* callprojs = call->extract_projections(true, do_asserts);\n@@ -1979,2 +2194,2 @@\n-  if (callprojs.fallthrough_catchproj != nullptr) {\n-    C->gvn_replace_by(callprojs.fallthrough_catchproj, final_ctl);\n+  if (callprojs->fallthrough_catchproj != nullptr) {\n+    C->gvn_replace_by(callprojs->fallthrough_catchproj, final_ctl);\n@@ -1982,1 +2197,1 @@\n-  if (callprojs.fallthrough_memproj != nullptr) {\n+  if (callprojs->fallthrough_memproj != nullptr) {\n@@ -1987,1 +2202,1 @@\n-    C->gvn_replace_by(callprojs.fallthrough_memproj,   final_mem);\n+    C->gvn_replace_by(callprojs->fallthrough_memproj,   final_mem);\n@@ -1990,2 +2205,2 @@\n-  if (callprojs.fallthrough_ioproj != nullptr) {\n-    C->gvn_replace_by(callprojs.fallthrough_ioproj,    final_io);\n+  if (callprojs->fallthrough_ioproj != nullptr) {\n+    C->gvn_replace_by(callprojs->fallthrough_ioproj,    final_io);\n@@ -1995,2 +2210,6 @@\n-  if (callprojs.resproj != nullptr && result != nullptr) {\n-    C->gvn_replace_by(callprojs.resproj, result);\n+  if (callprojs->resproj[0] != nullptr && result != nullptr) {\n+    \/\/ If the inlined code is dead, the result projections for an inline type returned as\n+    \/\/ fields have not been replaced. They will go away once the call is replaced by TOP below.\n+    assert(callprojs->nb_resproj == 1 || (call->tf()->returns_inline_type_as_fields() && stopped()),\n+           \"unexpected number of results\");\n+    C->gvn_replace_by(callprojs->resproj[0], result);\n@@ -2001,2 +2220,2 @@\n-    if (callprojs.catchall_catchproj != nullptr) {\n-      C->gvn_replace_by(callprojs.catchall_catchproj, C->top());\n+    if (callprojs->catchall_catchproj != nullptr) {\n+      C->gvn_replace_by(callprojs->catchall_catchproj, C->top());\n@@ -2004,2 +2223,2 @@\n-    if (callprojs.catchall_memproj != nullptr) {\n-      C->gvn_replace_by(callprojs.catchall_memproj,   C->top());\n+    if (callprojs->catchall_memproj != nullptr) {\n+      C->gvn_replace_by(callprojs->catchall_memproj,   C->top());\n@@ -2007,2 +2226,2 @@\n-    if (callprojs.catchall_ioproj != nullptr) {\n-      C->gvn_replace_by(callprojs.catchall_ioproj,    C->top());\n+    if (callprojs->catchall_ioproj != nullptr) {\n+      C->gvn_replace_by(callprojs->catchall_ioproj,    C->top());\n@@ -2011,2 +2230,2 @@\n-    if (callprojs.exobj != nullptr) {\n-      C->gvn_replace_by(callprojs.exobj, C->top());\n+    if (callprojs->exobj != nullptr) {\n+      C->gvn_replace_by(callprojs->exobj, C->top());\n@@ -2023,2 +2242,2 @@\n-    if (callprojs.catchall_catchproj != nullptr) {\n-      C->gvn_replace_by(callprojs.catchall_catchproj, ekit.control());\n+    if (callprojs->catchall_catchproj != nullptr) {\n+      C->gvn_replace_by(callprojs->catchall_catchproj, ekit.control());\n@@ -2027,1 +2246,1 @@\n-    if (callprojs.catchall_memproj != nullptr) {\n+    if (callprojs->catchall_memproj != nullptr) {\n@@ -2029,1 +2248,1 @@\n-      C->gvn_replace_by(callprojs.catchall_memproj,   ex_mem);\n+      C->gvn_replace_by(callprojs->catchall_memproj,   ex_mem);\n@@ -2032,2 +2251,2 @@\n-    if (callprojs.catchall_ioproj != nullptr) {\n-      C->gvn_replace_by(callprojs.catchall_ioproj,    ekit.i_o());\n+    if (callprojs->catchall_ioproj != nullptr) {\n+      C->gvn_replace_by(callprojs->catchall_ioproj,    ekit.i_o());\n@@ -2037,2 +2256,2 @@\n-    if (callprojs.exobj != nullptr) {\n-      C->gvn_replace_by(callprojs.exobj, ex_oop);\n+    if (callprojs->exobj != nullptr) {\n+      C->gvn_replace_by(callprojs->exobj, ex_oop);\n@@ -2052,1 +2271,1 @@\n-  if (callprojs.fallthrough_catchproj != nullptr && !final_ctl->is_top() && do_replaced_nodes) {\n+  if (callprojs->fallthrough_catchproj != nullptr && !final_ctl->is_top() && do_replaced_nodes) {\n@@ -2252,1 +2471,1 @@\n-    const TypePtr* ptr = (ptr_kind == ProfileMaybeNull && current_type->speculative_maybe_null()) ? TypePtr::BOTTOM : TypePtr::NOTNULL;\n+    const TypePtr* ptr = (ptr_kind != ProfileNeverNull && current_type->speculative_maybe_null()) ? TypePtr::BOTTOM : TypePtr::NOTNULL;\n@@ -2275,1 +2494,1 @@\n-    const TypeOopPtr* spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::OffsetBot, TypeOopPtr::InstanceBot, speculative);\n+    const TypeOopPtr* spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, speculative);\n@@ -2309,2 +2528,9 @@\n-      if (!data->as_BitData()->null_seen()) {\n-        ptr_kind = ProfileNeverNull;\n+      if (java_bc() == Bytecodes::_aastore) {\n+        ciKlass* array_type = nullptr;\n+        ciKlass* element_type = nullptr;\n+        ProfilePtrKind element_ptr = ProfileMaybeNull;\n+        bool flat_array = true;\n+        bool null_free_array = true;\n+        method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+        exact_kls = element_type;\n+        ptr_kind = element_ptr;\n@@ -2312,8 +2538,12 @@\n-        if (TypeProfileCasts) {\n-          assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n-          ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n-          uint i = 0;\n-          for (; i < call->row_limit(); i++) {\n-            ciKlass* receiver = call->receiver(i);\n-            if (receiver != nullptr) {\n-              break;\n+        if (!data->as_BitData()->null_seen()) {\n+          ptr_kind = ProfileNeverNull;\n+        } else {\n+          if (TypeProfileCasts) {\n+            assert(data->is_ReceiverTypeData(), \"bad profile data type\");\n+            ciReceiverTypeData* call = (ciReceiverTypeData*)data->as_ReceiverTypeData();\n+            uint i = 0;\n+            for (; i < call->row_limit(); i++) {\n+              ciKlass* receiver = call->receiver(i);\n+              if (receiver != nullptr) {\n+                break;\n+              }\n@@ -2321,0 +2551,1 @@\n+            ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2322,1 +2553,0 @@\n-          ptr_kind = (i == call->row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;\n@@ -2342,1 +2572,1 @@\n-  int             nargs = tf->domain()->cnt() - TypeFunc::Parms;\n+  int             nargs = tf->domain_sig()->cnt() - TypeFunc::Parms;\n@@ -2345,1 +2575,1 @@\n-    const Type *targ = tf->domain()->field_at(j + TypeFunc::Parms);\n+    const Type *targ = tf->domain_sig()->field_at(j + TypeFunc::Parms);\n@@ -2505,1 +2735,1 @@\n-    uint num_bits = call_type->range()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n+    uint num_bits = call_type->range_sig()->field_at(TypeFunc::Parms)->is_vect()->length_in_bytes() * BitsPerByte;\n@@ -2539,1 +2769,1 @@\n-  assert(call->in(call->req()-1) != nullptr, \"must initialize all parms\");\n+  assert(call->in(call->req()-1) != nullptr || (call->req()-1) > (TypeFunc::Parms+7), \"must initialize all parms\");\n@@ -2587,0 +2817,1 @@\n+\n@@ -2683,0 +2914,9 @@\n+  const TypeKlassPtr* klass_ptr_type = gvn.type(superklass)->is_klassptr();\n+  const TypeAryKlassPtr* ary_klass_t = klass_ptr_type->isa_aryklassptr();\n+  Node* vm_superklass = superklass;\n+  \/\/ TODO 8366668 Compute the VM type here for when we do a direct pointer comparison\n+  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n+    ary_klass_t = ary_klass_t->get_vm_type();\n+    vm_superklass = gvn.makecon(ary_klass_t);\n+  }\n+\n@@ -2720,1 +2960,1 @@\n-        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);\n+        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, vm_superklass, BoolTest::eq, PROB_STATIC_FREQUENT, gvn, T_ADDRESS);\n@@ -2742,1 +2982,2 @@\n-  bool might_be_cache = (chk_off_con == cacheoff_con);\n+  \/\/ TODO 8366668 Re-enable. This breaks test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java\n+  bool might_be_cache = true;\/\/(chk_off_con == cacheoff_con);\n@@ -2793,0 +3034,1 @@\n+        \/\/ TODO 8366668 Do we need adjustments here??\n@@ -2843,0 +3085,2 @@\n+  \/\/ TODO 8366668 Re-enable\n+\/*\n@@ -2847,1 +3091,1 @@\n-\n+*\/\n@@ -2851,1 +3095,1 @@\n-  IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);\n+  IfNode *iff3 = gen_subtype_check_compare(*ctrl, subklass, vm_superklass, BoolTest::eq, PROB_LIKELY(0.36f), gvn, T_ADDRESS);\n@@ -2889,0 +3133,5 @@\n+  const Type* sub_t = _gvn.type(obj_or_subklass);\n+  if (sub_t->make_oopptr() != nullptr && sub_t->make_oopptr()->is_inlinetypeptr()) {\n+    sub_t = TypeKlassPtr::make(sub_t->inline_klass());\n+    obj_or_subklass = makecon(sub_t);\n+  }\n@@ -2894,1 +3143,1 @@\n-    if (!_gvn.type(obj_or_subklass)->isa_klassptr()) {\n+    if (!sub_t->isa_klassptr()) {\n@@ -2912,2 +3161,1 @@\n-                                    float prob,\n-                                    Node* *casted_receiver) {\n+                                    float prob, Node* *casted_receiver) {\n@@ -2915,1 +3163,12 @@\n-\n+  Node* fail = top();\n+  const Type* rec_t = _gvn.type(receiver);\n+  if (rec_t->is_inlinetypeptr()) {\n+    if (klass->equals(rec_t->inline_klass())) {\n+      (*casted_receiver) = receiver; \/\/ Always passes\n+    } else {\n+      (*casted_receiver) = top();    \/\/ Always fails\n+      fail = control();\n+      set_control(top());\n+    }\n+    return fail;\n+  }\n@@ -2917,0 +3176,5 @@\n+  const TypeAryKlassPtr* ary_klass_t = tklass->isa_aryklassptr();\n+    \/\/ TODO 8366668 Compute the VM type\n+  if (ary_klass_t && ary_klass_t->klass_is_exact() && ary_klass_t->exact_klass()->is_obj_array_klass()) {\n+    tklass = ary_klass_t->get_vm_type();\n+  }\n@@ -2918,6 +3182,1 @@\n-  Node* want_klass = makecon(tklass);\n-  Node* cmp = _gvn.transform(new CmpPNode(recv_klass, want_klass));\n-  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n-  IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);\n-  set_control( _gvn.transform(new IfTrueNode (iff)));\n-  Node* fail = _gvn.transform(new IfFalseNode(iff));\n+  fail = type_check(recv_klass, tklass, prob);\n@@ -2927,2 +3186,2 @@\n-    const TypeOopPtr* recvx_type = tklass->as_instance_type();\n-    assert(recvx_type->klass_is_exact(), \"\");\n+    const TypeOopPtr* recv_xtype = tklass->as_instance_type();\n+    assert(recv_xtype->klass_is_exact(), \"\");\n@@ -2930,1 +3189,1 @@\n-    if (!receiver_type->higher_equal(recvx_type)) { \/\/ ignore redundant casts\n+    if (!receiver_type->higher_equal(recv_xtype)) { \/\/ ignore redundant casts\n@@ -2933,2 +3192,7 @@\n-      Node* cast = new CheckCastPPNode(control(), receiver, recvx_type);\n-      (*casted_receiver) = _gvn.transform(cast);\n+      Node* cast = new CheckCastPPNode(control(), receiver, recv_xtype);\n+      Node* res = _gvn.transform(cast);\n+      if (recv_xtype->is_inlinetypeptr()) {\n+        assert(!gvn().type(res)->maybe_null(), \"receiver should never be null\");\n+        res = InlineTypeNode::make_from_oop(this, res, recv_xtype->inline_klass());\n+      }\n+      (*casted_receiver) = res;\n@@ -2943,0 +3207,11 @@\n+Node* GraphKit::type_check(Node* recv_klass, const TypeKlassPtr* tklass,\n+                           float prob) {\n+  Node* want_klass = makecon(tklass);\n+  Node* cmp = _gvn.transform(new CmpPNode(recv_klass, want_klass));\n+  Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+  IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);\n+  set_control(_gvn.transform(new IfTrueNode (iff)));\n+  Node* fail = _gvn.transform(new IfFalseNode(iff));\n+  return fail;\n+}\n+\n@@ -2955,3 +3230,6 @@\n-    if (!receiver_type->higher_equal(recv_type)) { \/\/ ignore redundant casts\n-      Node* cast = new CheckCastPPNode(control(), receiver, recv_type);\n-      (*casted_receiver) = _gvn.transform(cast);\n+    if (receiver_type != nullptr && !receiver_type->higher_equal(recv_type)) { \/\/ ignore redundant casts\n+      Node* cast = _gvn.transform(new CheckCastPPNode(control(), receiver, recv_type));\n+      if (recv_type->is_inlinetypeptr()) {\n+        cast = InlineTypeNode::make_from_oop(this, cast, recv_type->inline_klass());\n+      }\n+      (*casted_receiver) = cast;\n@@ -3066,1 +3344,14 @@\n-  ciKlass* exact_kls = spec_klass == nullptr ? profile_has_unique_klass() : spec_klass;\n+  ciKlass* exact_kls = spec_klass;\n+  if (exact_kls == nullptr) {\n+    if (java_bc() == Bytecodes::_aastore) {\n+      ciKlass* array_type = nullptr;\n+      ciKlass* element_type = nullptr;\n+      ProfilePtrKind element_ptr = ProfileMaybeNull;\n+      bool flat_array = true;\n+      bool null_free_array = true;\n+      method()->array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);\n+      exact_kls = element_type;\n+    } else {\n+      exact_kls = profile_has_unique_klass();\n+    }\n+  }\n@@ -3196,1 +3487,1 @@\n-    if (subk->is_loaded()) {\n+    if (subk != nullptr && subk->is_loaded()) {\n@@ -3252,2 +3543,1 @@\n-Node* GraphKit::gen_checkcast(Node *obj, Node* superklass,\n-                              Node* *failure_control) {\n+Node* GraphKit::gen_checkcast(Node* obj, Node* superklass, Node* *failure_control, bool null_free, bool maybe_larval) {\n@@ -3256,0 +3546,16 @@\n+  const Type* obj_type = _gvn.type(obj);\n+  if (obj_type->is_inlinetypeptr() && !obj_type->maybe_null() && klass_ptr_type->klass_is_exact() && obj_type->inline_klass() == klass_ptr_type->exact_klass(true)) {\n+    \/\/ Special case: larval inline objects must not be scalarized. They are also generally not\n+    \/\/ allowed to participate in most operations except as the first operand of putfield, or as an\n+    \/\/ argument to a constructor invocation with it being a receiver, Unsafe::putXXX with it being\n+    \/\/ the first argument, or Unsafe::finishPrivateBuffer. This allows us to aggressively scalarize\n+    \/\/ value objects in all other places. This special case comes from the limitation of the Java\n+    \/\/ language, Unsafe::makePrivateBuffer returns an Object that is checkcast-ed to the concrete\n+    \/\/ value type. We must do this first because C->static_subtype_check may do nothing when\n+    \/\/ StressReflectiveCode is set.\n+    return obj;\n+  }\n+\n+  \/\/ Else it must be a non-larval object\n+  obj = cast_to_non_larval(obj);\n+\n@@ -3258,0 +3564,2 @@\n+  bool safe_for_replace = (failure_control == nullptr);\n+  assert(!null_free || toop->can_be_inline_type(), \"must be an inline type pointer\");\n@@ -3266,3 +3574,10 @@\n-    const TypeOopPtr* objtp = _gvn.type(obj)->isa_oopptr();\n-    if (objtp != nullptr) {\n-      switch (C->static_subtype_check(improved_klass_ptr_type, objtp->as_klass_type())) {\n+    const TypeKlassPtr* kptr = nullptr;\n+    if (obj_type->isa_oop_ptr()) {\n+      kptr = obj_type->is_oopptr()->as_klass_type();\n+    } else if (obj->is_InlineType()) {\n+      ciInlineKlass* vk = obj_type->inline_klass();\n+      kptr = TypeInstKlassPtr::make(TypePtr::NotNull, vk, Type::Offset(0));\n+    }\n+\n+    if (kptr != nullptr) {\n+      switch (C->static_subtype_check(improved_klass_ptr_type, kptr)) {\n@@ -3273,1 +3588,7 @@\n-        return record_profiled_receiver_for_speculation(obj);\n+        obj = record_profiled_receiver_for_speculation(obj);\n+        if (null_free) {\n+          assert(safe_for_replace, \"must be\");\n+          obj = null_check(obj);\n+        }\n+        assert(stopped() || !toop->is_inlinetypeptr() || obj->is_InlineType(), \"should have been scalarized\");\n+        return obj;\n@@ -3275,0 +3596,4 @@\n+        if (null_free) {\n+          assert(safe_for_replace, \"must be\");\n+          obj = null_check(obj);\n+        }\n@@ -3276,2 +3601,1 @@\n-        \/\/ A non-null value will always produce an exception.\n-        if (!objtp->maybe_null()) {\n+        if (obj_type->isa_oopptr() != nullptr && !obj_type->is_oopptr()->maybe_null()) {\n@@ -3294,1 +3618,0 @@\n-  bool safe_for_replace = false;\n@@ -3299,2 +3622,3 @@\n-    data = method()->method_data()->bci_to_data(bci());\n-    safe_for_replace = true;\n+    if (method()->method_data()->is_mature()) {\n+      data = method()->method_data()->bci_to_data(bci());\n+    }\n@@ -3307,0 +3631,3 @@\n+  _gvn.set_type(region, Type::CONTROL);\n+  _gvn.set_type(phi, toop);\n+\n@@ -3314,0 +3641,7 @@\n+  if (obj->is_InlineType()) {\n+    \/\/ Re-execute if buffering during triggers deoptimization\n+    PreserveReexecuteState preexecs(this);\n+    jvms()->set_should_reexecute(true);\n+    obj = obj->as_InlineType()->buffer(this, safe_for_replace);\n+  }\n+\n@@ -3316,1 +3650,7 @@\n-  Node* not_null_obj = null_check_oop(obj, &null_ctl, never_see_null, safe_for_replace, speculative_not_null);\n+  Node* not_null_obj = nullptr;\n+  if (null_free) {\n+    assert(safe_for_replace, \"must be\");\n+    not_null_obj = null_check(obj);\n+  } else {\n+    not_null_obj = null_check_oop(obj, &null_ctl, never_see_null, safe_for_replace, speculative_not_null);\n+  }\n@@ -3321,0 +3661,3 @@\n+    if (toop->is_inlinetypeptr()) {\n+      return InlineTypeNode::make_null(_gvn, toop->inline_klass());\n+    }\n@@ -3358,0 +3701,3 @@\n+      \/\/ Only improve the super class for constants which allows subsequent sub type checks to possibly be commoned up.\n+      \/\/ The other non-constant cases cannot be improved with a cast node here since they could be folded to top.\n+      \/\/ Additionally, the benefit would only be minor in non-constant cases.\n@@ -3361,1 +3707,0 @@\n-\n@@ -3399,1 +3744,165 @@\n-  return record_profiled_receiver_for_speculation(res);\n+  bool not_inline = !toop->can_be_inline_type();\n+  bool not_flat_in_array = !UseArrayFlattening || not_inline || (toop->is_inlinetypeptr() && !toop->inline_klass()->maybe_flat_in_array());\n+  if (EnableValhalla && (not_inline || not_flat_in_array)) {\n+    \/\/ Check if obj has been loaded from an array\n+    obj = obj->isa_DecodeN() ? obj->in(1) : obj;\n+    Node* array = nullptr;\n+    if (obj->isa_Load()) {\n+      Node* address = obj->in(MemNode::Address);\n+      if (address->isa_AddP()) {\n+        array = address->as_AddP()->in(AddPNode::Base);\n+      }\n+    } else if (obj->is_Phi()) {\n+      Node* region = obj->in(0);\n+      \/\/ TODO make this more robust (see JDK-8231346)\n+      if (region->req() == 3 && region->in(2) != nullptr && region->in(2)->in(0) != nullptr) {\n+        IfNode* iff = region->in(2)->in(0)->isa_If();\n+        if (iff != nullptr) {\n+          iff->is_flat_array_check(&_gvn, &array);\n+        }\n+      }\n+    }\n+    if (array != nullptr) {\n+      const TypeAryPtr* ary_t = _gvn.type(array)->isa_aryptr();\n+      if (ary_t != nullptr) {\n+        if (!ary_t->is_not_null_free() && !ary_t->is_null_free() && not_inline) {\n+          \/\/ Casting array element to a non-inline-type, mark array as not null-free.\n+          Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t->cast_to_not_null_free()));\n+          replace_in_map(array, cast);\n+          array = cast;\n+        }\n+        if (!ary_t->is_not_flat() && !ary_t->is_flat() && not_flat_in_array) {\n+          \/\/ Casting array element to a non-flat-in-array type, mark array as not flat.\n+          Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t->cast_to_not_flat()));\n+          replace_in_map(array, cast);\n+          array = cast;\n+        }\n+      }\n+    }\n+  }\n+\n+  if (!stopped() && !res->is_InlineType()) {\n+    res = record_profiled_receiver_for_speculation(res);\n+    if (toop->is_inlinetypeptr() && !maybe_larval) {\n+      Node* vt = InlineTypeNode::make_from_oop(this, res, toop->inline_klass());\n+      res = vt;\n+      if (safe_for_replace) {\n+        replace_in_map(obj, vt);\n+        replace_in_map(not_null_obj, vt);\n+        replace_in_map(res, vt);\n+      }\n+    }\n+  }\n+  return res;\n+}\n+\n+Node* GraphKit::mark_word_test(Node* obj, uintptr_t mask_val, bool eq, bool check_lock) {\n+  \/\/ Load markword\n+  Node* mark_adr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());\n+  Node* mark = make_load(nullptr, mark_adr, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  if (check_lock && !UseCompactObjectHeaders) {\n+    \/\/ COH: Locking does not override the markword with a tagged pointer. We can directly read from the markword.\n+    \/\/ Check if obj is locked\n+    Node* locked_bit = MakeConX(markWord::unlocked_value);\n+    locked_bit = _gvn.transform(new AndXNode(locked_bit, mark));\n+    Node* cmp = _gvn.transform(new CmpXNode(locked_bit, MakeConX(0)));\n+    Node* is_unlocked = _gvn.transform(new BoolNode(cmp, BoolTest::ne));\n+    IfNode* iff = new IfNode(control(), is_unlocked, PROB_MAX, COUNT_UNKNOWN);\n+    _gvn.transform(iff);\n+    Node* locked_region = new RegionNode(3);\n+    Node* mark_phi = new PhiNode(locked_region, TypeX_X);\n+\n+    \/\/ Unlocked: Use bits from mark word\n+    locked_region->init_req(1, _gvn.transform(new IfTrueNode(iff)));\n+    mark_phi->init_req(1, mark);\n+\n+    \/\/ Locked: Load prototype header from klass\n+    set_control(_gvn.transform(new IfFalseNode(iff)));\n+    \/\/ Make loads control dependent to make sure they are only executed if array is locked\n+    Node* klass_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());\n+    Node* klass = _gvn.transform(LoadKlassNode::make(_gvn, C->immutable_memory(), klass_adr, TypeInstPtr::KLASS, TypeInstKlassPtr::OBJECT));\n+    Node* proto_adr = basic_plus_adr(klass, in_bytes(Klass::prototype_header_offset()));\n+    Node* proto = _gvn.transform(LoadNode::make(_gvn, control(), C->immutable_memory(), proto_adr, proto_adr->bottom_type()->is_ptr(), TypeX_X, TypeX_X->basic_type(), MemNode::unordered));\n+\n+    locked_region->init_req(2, control());\n+    mark_phi->init_req(2, proto);\n+    set_control(_gvn.transform(locked_region));\n+    record_for_igvn(locked_region);\n+\n+    mark = mark_phi;\n+  }\n+\n+  \/\/ Now check if mark word bits are set\n+  Node* mask = MakeConX(mask_val);\n+  Node* masked = _gvn.transform(new AndXNode(_gvn.transform(mark), mask));\n+  record_for_igvn(masked); \/\/ Give it a chance to be optimized out by IGVN\n+  Node* cmp = _gvn.transform(new CmpXNode(masked, mask));\n+  return _gvn.transform(new BoolNode(cmp, eq ? BoolTest::eq : BoolTest::ne));\n+}\n+\n+Node* GraphKit::inline_type_test(Node* obj, bool is_inline) {\n+  return mark_word_test(obj, markWord::inline_type_pattern, is_inline, \/* check_lock = *\/ false);\n+}\n+\n+Node* GraphKit::flat_array_test(Node* array_or_klass, bool flat) {\n+  \/\/ We can't use immutable memory here because the mark word is mutable.\n+  \/\/ PhaseIdealLoop::move_flat_array_check_out_of_loop will make sure the\n+  \/\/ check is moved out of loops (mainly to enable loop unswitching).\n+  Node* cmp = _gvn.transform(new FlatArrayCheckNode(C, memory(Compile::AliasIdxRaw), array_or_klass));\n+  record_for_igvn(cmp); \/\/ Give it a chance to be optimized out by IGVN\n+  return _gvn.transform(new BoolNode(cmp, flat ? BoolTest::eq : BoolTest::ne));\n+}\n+\n+Node* GraphKit::null_free_array_test(Node* array, bool null_free) {\n+  return mark_word_test(array, markWord::null_free_array_bit_in_place, null_free);\n+}\n+\n+Node* GraphKit::null_free_atomic_array_test(Node* array, ciInlineKlass* vk) {\n+  assert(vk->has_atomic_layout() || vk->has_non_atomic_layout(), \"Can't be null-free and flat\");\n+\n+  \/\/ TODO 8350865 Add a stress flag to always access atomic if layout exists?\n+  if (!vk->has_non_atomic_layout()) {\n+    return intcon(1); \/\/ Always atomic\n+  } else if (!vk->has_atomic_layout()) {\n+    return intcon(0); \/\/ Never atomic\n+  }\n+\n+  Node* array_klass = load_object_klass(array);\n+  int layout_kind_offset = in_bytes(FlatArrayKlass::layout_kind_offset());\n+  Node* layout_kind_addr = basic_plus_adr(array_klass, array_klass, layout_kind_offset);\n+  Node* layout_kind = make_load(nullptr, layout_kind_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* cmp = _gvn.transform(new CmpINode(layout_kind, intcon((int)LayoutKind::ATOMIC_FLAT)));\n+  return _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+}\n+\n+\/\/ Deoptimize if 'ary' is a null-free inline type array and 'val' is null\n+Node* GraphKit::inline_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace) {\n+  RegionNode* region = new RegionNode(3);\n+  Node* null_ctl = top();\n+  null_check_oop(val, &null_ctl);\n+  if (null_ctl != top()) {\n+    PreserveJVMState pjvms(this);\n+    set_control(null_ctl);\n+    {\n+      \/\/ Deoptimize if null-free array\n+      BuildCutout unless(this, null_free_array_test(ary, \/* null_free = *\/ false), PROB_MAX);\n+      inc_sp(nargs);\n+      uncommon_trap(Deoptimization::Reason_null_check,\n+                    Deoptimization::Action_none);\n+    }\n+    region->init_req(1, control());\n+  }\n+  region->init_req(2, control());\n+  set_control(_gvn.transform(region));\n+  record_for_igvn(region);\n+  if (_gvn.type(val) == TypePtr::NULL_PTR) {\n+    \/\/ Since we were just successfully storing null, the array can't be null free.\n+    const TypeAryPtr* ary_t = _gvn.type(ary)->is_aryptr();\n+    ary_t = ary_t->cast_to_not_null_free();\n+    Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));\n+    if (safe_for_replace) {\n+      replace_in_map(ary, cast);\n+    }\n+    ary = cast;\n+  }\n+  return ary;\n@@ -3531,0 +4040,1 @@\n+  assert(!obj->is_InlineType(), \"should not unlock on inline type\");\n@@ -3571,1 +4081,8 @@\n-    if (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM)) {\n+    bool can_be_flat = false;\n+    const TypeAryPtr* ary_type = klass_t->as_instance_type()->isa_aryptr();\n+    if (UseArrayFlattening && !xklass && ary_type != nullptr && !ary_type->is_null_free()) {\n+      \/\/ Don't constant fold if the runtime type might be a flat array but the static type is not.\n+      const TypeOopPtr* elem = ary_type->elem()->make_oopptr();\n+      can_be_flat = ary_type->can_be_inline_array() && (!elem->is_inlinetypeptr() || elem->inline_klass()->maybe_flat_in_array());\n+    }\n+    if (!can_be_flat && (xklass || (klass_t->isa_aryklassptr() && klass_t->is_aryklassptr()->elem() != Type::BOTTOM))) {\n@@ -3573,2 +4090,4 @@\n-      if (klass_t->isa_aryklassptr()) {\n-        BasicType elem = klass_t->as_instance_type()->isa_aryptr()->elem()->array_element_basic_type();\n+      if (klass_t->is_flat()) {\n+        lhelper = ary_type->flat_layout_helper();\n+      } else if (klass_t->isa_aryklassptr()) {\n+        BasicType elem = ary_type->elem()->array_element_basic_type();\n@@ -3603,1 +4122,3 @@\n-  kit.set_memory(init_out_raw, alias_idx);\n+  if (init_out_raw != nullptr) {\n+    kit.set_memory(init_out_raw, alias_idx);\n+  }\n@@ -3642,0 +4163,1 @@\n+    _gvn.set_type(minit_in, Type::MEMORY);\n@@ -3649,3 +4171,28 @@\n-      const TypePtr* telemref = oop_type->add_offset(Type::OffsetBot);\n-      int            elemidx  = C->get_alias_index(telemref);\n-      hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+      const TypeAryPtr* arytype = oop_type->is_aryptr();\n+      if (arytype->is_flat()) {\n+        \/\/ Initially all flat array accesses share a single slice\n+        \/\/ but that changes after parsing. Prepare the memory graph so\n+        \/\/ it can optimize flat array accesses properly once they\n+        \/\/ don't share a single slice.\n+        assert(C->flat_accesses_share_alias(), \"should be set at parse time\");\n+        C->set_flat_accesses_share_alias(false);\n+        ciInlineKlass* vk = arytype->elem()->inline_klass();\n+        for (int i = 0, len = vk->nof_nonstatic_fields(); i < len; i++) {\n+          ciField* field = vk->nonstatic_field_at(i);\n+          if (field->offset_in_bytes() >= TrackedInitializationLimit * HeapWordSize)\n+            continue;  \/\/ do not bother to track really large numbers of fields\n+          int off_in_vt = field->offset_in_bytes() - vk->payload_offset();\n+          const TypePtr* adr_type = arytype->with_field_offset(off_in_vt)->add_offset(Type::OffsetBot);\n+          int fieldidx = C->get_alias_index(adr_type, true);\n+          \/\/ Pass nullptr for init_out. Having per flat array element field memory edges as uses of the Initialize node\n+          \/\/ can result in per flat array field Phis to be created which confuses the logic of\n+          \/\/ Compile::adjust_flat_array_access_aliases().\n+          hook_memory_on_init(*this, fieldidx, minit_in, nullptr);\n+        }\n+        C->set_flat_accesses_share_alias(true);\n+        hook_memory_on_init(*this, C->get_alias_index(TypeAryPtr::INLINES), minit_in, minit_out);\n+      } else {\n+        const TypePtr* telemref = oop_type->add_offset(Type::OffsetBot);\n+        int            elemidx  = C->get_alias_index(telemref);\n+        hook_memory_on_init(*this, elemidx, minit_in, minit_out);\n+      }\n@@ -3653,0 +4200,1 @@\n+      set_memory(minit_out, C->get_alias_index(oop_type)); \/\/ mark word\n@@ -3703,1 +4251,2 @@\n-                             bool deoptimize_on_exception) {\n+                             bool deoptimize_on_exception,\n+                             InlineTypeNode* inline_type_node) {\n@@ -3710,1 +4259,1 @@\n-  int   layout_is_con = (layout_val == nullptr);\n+  bool  layout_is_con = (layout_val == nullptr);\n@@ -3761,1 +4310,1 @@\n-  \/\/ since GC and deoptimization can happened.\n+  \/\/ since GC and deoptimization can happen.\n@@ -3768,1 +4317,1 @@\n-                                         initial_slow_test);\n+                                         initial_slow_test, inline_type_node);\n@@ -3774,1 +4323,1 @@\n-\/\/ helper for both newarray and anewarray\n+\/\/ helper for newarray and anewarray\n@@ -3784,1 +4333,2 @@\n-                          bool deoptimize_on_exception) {\n+                          bool deoptimize_on_exception,\n+                          Node* init_val) {\n@@ -3787,1 +4337,1 @@\n-  int   layout_is_con = (layout_val == nullptr);\n+  bool  layout_is_con = (layout_val == nullptr);\n@@ -3817,3 +4367,1 @@\n-    assert(fast_size_limit == 0 || count_leading_zeros(fast_size_limit) > static_cast<unsigned>(LogBytesPerLong - log2_esize),\n-           \"fast_size_limit (%d) overflow when shifted left by %d\", fast_size_limit, LogBytesPerLong - log2_esize);\n-    fast_size_limit <<= (LogBytesPerLong - log2_esize);\n+    fast_size_limit <<= MAX2(LogBytesPerLong - log2_esize, 0);\n@@ -3836,0 +4384,1 @@\n+    bool is_flat_array = Klass::layout_helper_is_flatArray(layout_con);\n@@ -3838,1 +4387,1 @@\n-    assert((hsize & right_n_bits(eshift)) == 0, \"hsize is pre-rounded\");\n+    assert(is_flat_array || (hsize & right_n_bits(eshift)) == 0, \"hsize is pre-rounded\");\n@@ -3927,1 +4476,1 @@\n-  \/\/ since GC and deoptimization can happened.\n+  \/\/ since GC and deoptimization can happen.\n@@ -3936,1 +4485,21 @@\n-  const TypeOopPtr* ary_type = _gvn.type(klass_node)->is_klassptr()->as_instance_type();\n+  const TypeKlassPtr* ary_klass = _gvn.type(klass_node)->isa_klassptr();\n+  const TypeOopPtr* ary_type = ary_klass->as_instance_type();\n+\n+  Node* raw_init_value = nullptr;\n+  if (init_val != nullptr) {\n+    \/\/ TODO 8350865 Fast non-zero init not implemented yet for flat, null-free arrays\n+    if (ary_type->is_flat()) {\n+      initial_slow_test = intcon(1);\n+    }\n+\n+    if (UseCompressedOops) {\n+      \/\/ With compressed oops, the 64-bit init value is built from two 32-bit compressed oops\n+      init_val = _gvn.transform(new EncodePNode(init_val, init_val->bottom_type()->make_narrowoop()));\n+      Node* lower = _gvn.transform(new CastP2XNode(control(), init_val));\n+      Node* upper = _gvn.transform(new LShiftLNode(lower, intcon(32)));\n+      raw_init_value = _gvn.transform(new OrLNode(lower, upper));\n+    } else {\n+      raw_init_value = _gvn.transform(new CastP2XNode(control(), init_val));\n+    }\n+  }\n+\n@@ -3951,2 +4520,2 @@\n-                            length, valid_length_test);\n-\n+                            length, valid_length_test,\n+                            init_val, raw_init_value);\n@@ -4107,1 +4676,1 @@\n-                                                     false, nullptr, 0);\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4110,2 +4679,2 @@\n-                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS),\n-                                                  ciTypeArrayKlass::make(T_BYTE), true, 0);\n+                                                  TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, false, true, true),\n+                                                  ciTypeArrayKlass::make(T_BYTE), true, Type::Offset(0));\n@@ -4124,1 +4693,1 @@\n-                                                     false, nullptr, 0);\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4136,1 +4705,1 @@\n-                                                     false, nullptr, 0);\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4146,1 +4715,1 @@\n-                                                     false, nullptr, 0);\n+                                                     false, nullptr, Type::Offset(0));\n@@ -4259,1 +4828,7 @@\n-    return makecon(con_type);\n+    Node* con = makecon(con_type);\n+    if (field->type()->is_inlinetype()) {\n+      con = InlineTypeNode::make_from_oop(this, con, field->type()->as_inline_klass());\n+    } else if (con_type->is_inlinetypeptr()) {\n+      con = InlineTypeNode::make_from_oop(this, con, con_type->inline_klass());\n+    }\n+    return con;\n@@ -4264,0 +4839,9 @@\n+\/\/---------------------------load_mirror_from_klass----------------------------\n+\/\/ Given a klass oop, load its java mirror (a java.lang.Class oop).\n+Node* GraphKit::load_mirror_from_klass(Node* klass) {\n+  Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));\n+  Node* load = make_load(nullptr, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);\n+  \/\/ mirror = ((OopHandle)mirror)->resolve();\n+  return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);\n+}\n+\n@@ -4265,1 +4849,1 @@\n-  const TypeOopPtr* obj_type = obj->bottom_type()->isa_oopptr();\n+  const Type* obj_type = obj->bottom_type();\n@@ -4267,1 +4851,1 @@\n-  if (obj_type != nullptr && sig_type->is_loaded() && !obj_type->higher_equal(sig_type)) {\n+  if (obj_type->isa_oopptr() && sig_type->is_loaded() && !obj_type->higher_equal(sig_type)) {\n@@ -4270,1 +4854,4 @@\n-    return casted_obj;\n+    obj = casted_obj;\n+  }\n+  if (sig_type->is_inlinetypeptr()) {\n+    obj = InlineTypeNode::make_from_oop(this, obj, sig_type->inline_klass());\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":732,"deletions":145,"binary":false,"changes":877,"status":"modified"},{"patch":"@@ -128,1 +128,6 @@\n-  if (phase->find_unswitch_candidate(this) == nullptr) {\n+\n+  if (head->is_flat_arrays()) {\n+    return false;\n+  }\n+\n+  if (no_unswitch_candidate()) {\n@@ -136,0 +141,7 @@\n+\/\/ Check the absence of any If node that can be used for Loop Unswitching. In that case, no Loop Unswitching can be done.\n+bool IdealLoopTree::no_unswitch_candidate() const {\n+  ResourceMark rm;\n+  Node_List dont_care;\n+  return _phase->find_unswitch_candidates(this, dont_care) == nullptr;\n+}\n+\n@@ -137,2 +149,39 @@\n-\/\/ one in the loop body. Return the \"unswitch candidate\" If to apply Loop Unswitching on.\n-IfNode* PhaseIdealLoop::find_unswitch_candidate(const IdealLoopTree* loop) const {\n+\/\/ one in the loop body as \"unswitch candidate\" to apply Loop Unswitching on.\n+\/\/ Depending on whether we find such a candidate and if we do, whether it's a flat array check, we do the following:\n+\/\/ (1) Candidate is not a flat array check:\n+\/\/     Return the unique unswitch candidate.\n+\/\/ (2) Candidate is a flat array check:\n+\/\/     Collect all remaining non-loop-exiting flat array checks in the loop body in the provided 'flat_array_checks'\n+\/\/     list in order to create an unswitched loop version without any flat array checks and a version with checks\n+\/\/     (i.e. same as original loop). Return the initially found candidate which could be unique if no further flat array\n+\/\/     checks are found.\n+\/\/ (3) No candidate is initially found:\n+\/\/     As in (2), we collect all non-loop-exiting flat array checks in the loop body in the provided 'flat_array_checks'\n+\/\/     list. Pick the first collected flat array check as unswitch candidate, which could be unique, and return it (a).\n+\/\/     If there are no flat array checks, we cannot apply Loop Unswitching (b).\n+\/\/\n+\/\/ Note that for both (2) and (3a), if there are multiple flat array checks, then the candidate's FlatArrayCheckNode is\n+\/\/ later updated in Loop Unswitching to perform a flat array check on all collected flat array checks.\n+IfNode* PhaseIdealLoop::find_unswitch_candidates(const IdealLoopTree* loop, Node_List& flat_array_checks) const {\n+  IfNode* unswitch_candidate = find_unswitch_candidate_from_idoms(loop);\n+  if (unswitch_candidate != nullptr && !unswitch_candidate->is_flat_array_check(&_igvn)) {\n+    \/\/ Case (1)\n+    return unswitch_candidate;\n+  }\n+\n+  collect_flat_array_checks(loop, flat_array_checks);\n+  if (unswitch_candidate != nullptr) {\n+    \/\/ Case (2)\n+    assert(unswitch_candidate->is_flat_array_check(&_igvn), \"is a flat array check\");\n+    return unswitch_candidate;\n+  } else if (flat_array_checks.size() > 0) {\n+    \/\/ Case (3a): Pick first one found as candidate (there could be multiple).\n+    return flat_array_checks[0]->as_If();\n+  }\n+\n+  \/\/ Case (3b): No suitable unswitch candidate found.\n+  return nullptr;\n+}\n+\n+\/\/ Find an unswitch candidate by following the idom chain from the loop back edge.\n+IfNode* PhaseIdealLoop::find_unswitch_candidate_from_idoms(const IdealLoopTree* loop) const {\n@@ -165,0 +214,144 @@\n+\/\/ Collect all flat array checks in the provided 'flat_array_checks' list.\n+void PhaseIdealLoop::collect_flat_array_checks(const IdealLoopTree* loop, Node_List& flat_array_checks) const {\n+  assert(flat_array_checks.size() == 0, \"should be empty initially\");\n+  for (uint i = 0; i < loop->_body.size(); i++) {\n+    Node* next = loop->_body.at(i);\n+    if (next->is_If() && next->as_If()->is_flat_array_check(&_igvn) && loop->is_invariant(next->in(1)) &&\n+        !loop->is_loop_exit(next)) {\n+      flat_array_checks.push(next);\n+    }\n+  }\n+}\n+\n+\/\/ This class represents an \"unswitch candidate\" which is an If that can be used to perform Loop Unswitching on. If the\n+\/\/ candidate is a flat array check candidate, then we also collect all remaining non-loop-exiting flat array checks.\n+\/\/ These are candidates as well. We want to get rid of all these flat array checks in the true-path-loop for the\n+\/\/ following reason:\n+\/\/\n+\/\/ FlatArrayCheckNodes are used with array accesses to switch between a flat and a non-flat array access. We want\n+\/\/ the performance impact on non-flat array accesses to be as small as possible. We therefore create the following\n+\/\/ loops in Loop Unswitching:\n+\/\/ - True-path-loop:  We remove all non-loop-exiting flat array checks to get a loop with only non-flat array accesses\n+\/\/                    (i.e. a fast path loop).\n+\/\/ - False-path-loop: We keep all flat array checks in this loop (i.e. a slow path loop).\n+class UnswitchCandidate : public StackObj {\n+  PhaseIdealLoop* const _phase;\n+  const Node_List& _old_new;\n+  Node* const _original_loop_entry;\n+  \/\/ If _candidate is a flat array check, this list contains all non-loop-exiting flat array checks in the loop body.\n+  Node_List _flat_array_check_candidates;\n+  IfNode* const _candidate;\n+\n+ public:\n+  UnswitchCandidate(IdealLoopTree* loop, const Node_List& old_new)\n+      : _phase(loop->_phase),\n+        _old_new(old_new),\n+        _original_loop_entry(loop->_head->as_Loop()->skip_strip_mined()->in(LoopNode::EntryControl)),\n+        _flat_array_check_candidates(),\n+        _candidate(find_unswitch_candidate(loop)) {}\n+  NONCOPYABLE(UnswitchCandidate);\n+\n+  IfNode* find_unswitch_candidate(IdealLoopTree* loop) {\n+    IfNode* unswitch_candidate = _phase->find_unswitch_candidates(loop, _flat_array_check_candidates);\n+    assert(unswitch_candidate != nullptr, \"guaranteed to exist by policy_unswitching\");\n+    assert(_phase->is_member(loop, unswitch_candidate), \"must be inside original loop\");\n+    return unswitch_candidate;\n+  }\n+\n+  IfNode* candidate() const {\n+    return _candidate;\n+  }\n+\n+  \/\/ Is the candidate a flat array check and are there other flat array checks as well?\n+  bool has_multiple_flat_array_check_candidates() const {\n+    return _flat_array_check_candidates.size() > 1;\n+  }\n+\n+  \/\/ Remove all candidates from the true-path-loop which are now dominated by the loop selector\n+  \/\/ (i.e. 'true_path_loop_proj'). The removed candidates are folded in the next IGVN round.\n+  void update_in_true_path_loop(IfTrueNode* true_path_loop_proj) const {\n+    remove_from_loop(true_path_loop_proj, _candidate);\n+    if (has_multiple_flat_array_check_candidates()) {\n+      remove_flat_array_checks(true_path_loop_proj);\n+    }\n+  }\n+\n+  \/\/ Remove a unique candidate from the false-path-loop which is now dominated by the loop selector\n+  \/\/ (i.e. 'false_path_loop_proj'). The removed candidate is folded in the next IGVN round. If there are multiple\n+  \/\/ candidates (i.e. flat array checks), then we leave them in the false-path-loop and only mark the loop such that it\n+  \/\/ is not unswitched anymore in later loop opts rounds.\n+  void update_in_false_path_loop(IfFalseNode* false_path_loop_proj, LoopNode* false_path_loop) const {\n+    if (has_multiple_flat_array_check_candidates()) {\n+      \/\/ Leave the flat array checks in the false-path-loop and prevent it from being unswitched again based on these\n+      \/\/ checks.\n+      false_path_loop->mark_flat_arrays();\n+    } else {\n+      remove_from_loop(false_path_loop_proj, _old_new[_candidate->_idx]->as_If());\n+    }\n+  }\n+\n+ private:\n+  void remove_from_loop(IfProjNode* dominating_proj, IfNode* candidate) const {\n+    _phase->igvn().rehash_node_delayed(candidate);\n+    _phase->dominated_by(dominating_proj, candidate);\n+  }\n+\n+  void remove_flat_array_checks(IfProjNode* dominating_proj) const {\n+    for (uint i = 0; i < _flat_array_check_candidates.size(); i++) {\n+      IfNode* flat_array_check = _flat_array_check_candidates.at(i)->as_If();\n+      _phase->igvn().rehash_node_delayed(flat_array_check);\n+      _phase->dominated_by(dominating_proj, flat_array_check);\n+    }\n+  }\n+\n+ public:\n+  \/\/ Merge all flat array checks into a single new BoolNode and return it.\n+  BoolNode* merge_flat_array_checks() const {\n+    assert(has_multiple_flat_array_check_candidates(), \"must have multiple flat array checks to merge\");\n+    assert(_candidate->in(1)->as_Bool()->_test._test == BoolTest::ne, \"IfTrue proj must point to flat array\");\n+    BoolNode* merged_flat_array_check_bool = create_bool_node();\n+    create_flat_array_check_node(merged_flat_array_check_bool);\n+    return merged_flat_array_check_bool;\n+  }\n+\n+ private:\n+  BoolNode* create_bool_node() const {\n+    BoolNode* merged_flat_array_check_bool = _candidate->in(1)->clone()->as_Bool();\n+    _phase->register_new_node(merged_flat_array_check_bool, _original_loop_entry);\n+    return merged_flat_array_check_bool;\n+  }\n+\n+  void create_flat_array_check_node(BoolNode* merged_flat_array_check_bool) const {\n+    FlatArrayCheckNode* cloned_flat_array_check = merged_flat_array_check_bool->in(1)->clone()->as_FlatArrayCheck();\n+    _phase->register_new_node(cloned_flat_array_check, _original_loop_entry);\n+    merged_flat_array_check_bool->set_req(1, cloned_flat_array_check);\n+    set_flat_array_check_inputs(cloned_flat_array_check);\n+  }\n+\n+  \/\/ Combine all checks into a single one that fails if one array is flat.\n+  void set_flat_array_check_inputs(FlatArrayCheckNode* cloned_flat_array_check) const {\n+    assert(cloned_flat_array_check->req() == 3, \"unexpected number of inputs for FlatArrayCheck\");\n+    cloned_flat_array_check->add_req_batch(_phase->C->top(), _flat_array_check_candidates.size() - 1);\n+    for (uint i = 0; i < _flat_array_check_candidates.size(); i++) {\n+      Node* array = _flat_array_check_candidates.at(i)->in(1)->in(1)->in(FlatArrayCheckNode::ArrayOrKlass);\n+      cloned_flat_array_check->set_req(FlatArrayCheckNode::ArrayOrKlass + i, array);\n+    }\n+  }\n+\n+ public:\n+#ifndef PRODUCT\n+  void trace_flat_array_checks() const {\n+    if (has_multiple_flat_array_check_candidates()) {\n+      tty->print_cr(\"- Unswitched and Merged Flat Array Checks:\");\n+      for (uint i = 0; i < _flat_array_check_candidates.size(); i++) {\n+        Node* unswitch_iff = _flat_array_check_candidates.at(i);\n+        Node* cloned_unswitch_iff = _old_new[unswitch_iff->_idx];\n+        assert(cloned_unswitch_iff != nullptr, \"must exist\");\n+        tty->print_cr(\"  - %d %s  ->  %d %s\", unswitch_iff->_idx, unswitch_iff->Name(),\n+                      cloned_unswitch_iff->_idx, cloned_unswitch_iff->Name());\n+      }\n+    }\n+  }\n+#endif \/\/ NOT PRODUCT\n+};\n+\n@@ -179,1 +372,3 @@\n-  enum PathToLoop { TRUE_PATH, FALSE_PATH };\n+  enum PathToLoop {\n+    TRUE_PATH, FALSE_PATH\n+  };\n@@ -195,1 +390,1 @@\n-  LoopSelector(IdealLoopTree* loop, IfNode* unswitch_candidate)\n+  LoopSelector(IdealLoopTree* loop, const UnswitchCandidate& unswitch_candidate)\n@@ -206,0 +401,1 @@\n+ private:\n@@ -213,1 +409,2 @@\n-  IfNode* create_unswitching_if(IfNode* unswitch_candidate) {\n+  IfNode* create_unswitching_if(const UnswitchCandidate& unswitch_candidate) {\n+    const uint dom_depth = _phase->dom_depth(_original_loop_entry);\n@@ -215,4 +412,9 @@\n-    BoolNode* unswitch_candidate_bool = unswitch_candidate->in(1)->as_Bool();\n-    IfNode* selector_if = IfNode::make_with_same_profile(unswitch_candidate, _original_loop_entry,\n-                                                         unswitch_candidate_bool);\n-    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, _dom_depth);\n+    IfNode* unswitch_candidate_if = unswitch_candidate.candidate();\n+    BoolNode* selector_bool;\n+    if (unswitch_candidate.has_multiple_flat_array_check_candidates()) {\n+      selector_bool = unswitch_candidate.merge_flat_array_checks();\n+    } else {\n+      selector_bool = unswitch_candidate_if->in(1)->as_Bool();\n+    }\n+    IfNode* selector_if = IfNode::make_with_same_profile(unswitch_candidate_if, _original_loop_entry, selector_bool);\n+    _phase->register_node(selector_if, _outer_loop, _original_loop_entry, dom_depth);\n@@ -222,1 +424,0 @@\n- private:\n@@ -252,1 +453,1 @@\n-  IfNode* const _unswitch_candidate;\n+  const UnswitchCandidate& _unswitch_candidate;\n@@ -256,2 +457,2 @@\n-  UnswitchedLoopSelector(IdealLoopTree* loop)\n-      : _unswitch_candidate(find_unswitch_candidate(loop)),\n+  UnswitchedLoopSelector(IdealLoopTree* loop, const UnswitchCandidate& unswitch_candidate)\n+      : _unswitch_candidate(unswitch_candidate),\n@@ -261,11 +462,2 @@\n- private:\n-  static IfNode* find_unswitch_candidate(IdealLoopTree* loop) {\n-    IfNode* unswitch_candidate = loop->_phase->find_unswitch_candidate(loop);\n-    assert(unswitch_candidate != nullptr, \"guaranteed to exist by policy_unswitching\");\n-    assert(loop->_phase->is_member(loop, unswitch_candidate), \"must be inside original loop\");\n-    return unswitch_candidate;\n-  }\n-\n- public:\n-  IfNode* unswitch_candidate() const {\n-    return _unswitch_candidate;\n+  IfNode* selector_if() const {\n+    return _loop_selector.selector();\n@@ -301,1 +493,0 @@\n-    remove_unswitch_candidate_from_loops(unswitched_loop_selector);\n@@ -366,14 +557,0 @@\n-\n-  \/\/ Remove the unswitch candidate If nodes in both unswitched loop versions which are now dominated by the loop selector\n-  \/\/ If node. Keep the true-path-path in the true-path-loop and the false-path-path in the false-path-loop by setting\n-  \/\/ the bool input accordingly. The unswitch candidate If nodes are folded in the next IGVN round.\n-  void remove_unswitch_candidate_from_loops(const UnswitchedLoopSelector& unswitched_loop_selector) {\n-    const LoopSelector& loop_selector = unswitched_loop_selector.loop_selector();;\n-    IfNode* unswitch_candidate        = unswitched_loop_selector.unswitch_candidate();\n-    _phase->igvn().rehash_node_delayed(unswitch_candidate);\n-    _phase->dominated_by(loop_selector.true_path_loop_proj(), unswitch_candidate);\n-\n-    IfNode* unswitch_candidate_clone = _old_new[unswitch_candidate->_idx]->as_If();\n-    _phase->igvn().rehash_node_delayed(unswitch_candidate_clone);\n-    _phase->dominated_by(loop_selector.false_path_loop_proj(), unswitch_candidate_clone);\n-  }\n@@ -397,1 +574,2 @@\n-  const UnswitchedLoopSelector unswitched_loop_selector(loop);\n+  const UnswitchCandidate unswitch_candidate(loop, old_new);\n+  const UnswitchedLoopSelector unswitched_loop_selector(loop, unswitch_candidate);\n@@ -401,1 +579,4 @@\n-  hoist_invariant_check_casts(loop, old_new, unswitched_loop_selector);\n+  unswitch_candidate.update_in_true_path_loop(unswitched_loop_selector.loop_selector().true_path_loop_proj());\n+  unswitch_candidate.update_in_false_path_loop(unswitched_loop_selector.loop_selector().false_path_loop_proj(),\n+                                               old_new[original_head->_idx]->as_Loop());\n+  hoist_invariant_check_casts(loop, old_new, unswitch_candidate, unswitched_loop_selector.selector_if());\n@@ -407,1 +588,1 @@\n-  NOT_PRODUCT(trace_loop_unswitching_result(unswitched_loop_selector, original_head, new_head);)\n+  NOT_PRODUCT(trace_loop_unswitching_result(unswitched_loop_selector, unswitch_candidate, original_head, new_head);)\n@@ -611,0 +792,1 @@\n+                                                   const UnswitchCandidate& unswitch_candidate,\n@@ -613,2 +795,2 @@\n-    IfNode* unswitch_candidate = unswitched_loop_selector.unswitch_candidate();\n-    IfNode* loop_selector = unswitched_loop_selector.loop_selector().selector();\n+    IfNode* unswitch_candidate_if = unswitch_candidate.candidate();\n+    IfNode* loop_selector = unswitched_loop_selector.selector_if();\n@@ -616,1 +798,1 @@\n-    tty->print_cr(\"- Unswitch-Candidate-If: %d %s\", unswitch_candidate->_idx, unswitch_candidate->Name());\n+    tty->print_cr(\"- Unswitch-Candidate-If: %d %s\", unswitch_candidate_if->_idx, unswitch_candidate_if->Name());\n@@ -620,0 +802,1 @@\n+    unswitch_candidate.trace_flat_array_checks();\n@@ -646,3 +829,2 @@\n-                                                 const UnswitchedLoopSelector& unswitched_loop_selector) {\n-  IfNode* unswitch_candidate = unswitched_loop_selector.unswitch_candidate();\n-  IfNode* loop_selector = unswitched_loop_selector.loop_selector().selector();\n+                                                 const UnswitchCandidate& unswitch_candidate,\n+                                                 const IfNode* loop_selector) {\n@@ -651,2 +833,3 @@\n-  for (DUIterator_Fast imax, i = unswitch_candidate->fast_outs(imax); i < imax; i++) {\n-    IfProjNode* proj = unswitch_candidate->fast_out(i)->as_IfProj();\n+  const IfNode* unswitch_candidate_if = unswitch_candidate.candidate();\n+  for (DUIterator_Fast imax, i = unswitch_candidate_if->fast_outs(imax); i < imax; i++) {\n+    IfProjNode* proj = unswitch_candidate_if->fast_out(i)->as_IfProj();\n@@ -667,3 +850,6 @@\n-      \/\/ Same for the clone\n-      Node* use_clone = old_new[cast->_idx];\n-      _igvn.replace_input_of(use_clone, 1, cast_clone);\n+      \/\/ Same for the false-path-loop if there are not multiple flat array checks (in that case we leave the\n+      \/\/ false-path-loop unchanged).\n+      if (!unswitch_candidate.has_multiple_flat_array_check_candidates()) {\n+        Node* use_clone = old_new[cast->_idx];\n+        _igvn.replace_input_of(use_clone, 1, cast_clone);\n+      }\n@@ -677,1 +863,1 @@\n-  for(int i = loop->_body.size() - 1; i >= 0 ; i--) {\n+  for (int i = loop->_body.size() - 1; i >= 0; i--) {\n@@ -689,1 +875,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":241,"deletions":56,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -421,0 +423,1 @@\n+  bool is_flat = InstanceKlass::cast(k1)->field_is_flat(slot);\n@@ -422,1 +425,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset);\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k1, offset, is_flat);\n@@ -439,1 +442,1 @@\n-  if (m->is_object_initializer()) {\n+  if (m->is_object_constructor()) {\n@@ -798,1 +801,1 @@\n-    case T_OBJECT:      push_object(va_arg(_ap, jobject)); break;\n+    case T_OBJECT: push_object(va_arg(_ap, jobject)); break;\n@@ -965,1 +968,7 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == nullptr || k->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n+  }\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n@@ -979,1 +988,8 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == nullptr) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n+  }\n+\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n@@ -984,0 +1000,1 @@\n+\n@@ -985,1 +1002,1 @@\n-JNI_END\n+  JNI_END\n@@ -997,1 +1014,8 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == nullptr) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n+  }\n+\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n@@ -1002,0 +1026,1 @@\n+\n@@ -1015,1 +1040,8 @@\n-  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(clazz), CHECK_NULL);\n+  oop clazzoop = JNIHandles::resolve_non_null(clazz);\n+  Klass* k = java_lang_Class::as_Klass(clazzoop);\n+  if (k == nullptr) {\n+    ResourceMark rm(THREAD);\n+    THROW_(vmSymbols::java_lang_InstantiationException(), nullptr);\n+  }\n+\n+  instanceOop i = InstanceKlass::allocate_instance(clazzoop, CHECK_NULL);\n@@ -1023,0 +1055,1 @@\n+\n@@ -1773,1 +1806,1 @@\n-  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset());\n+  ret = jfieldIDWorkaround::to_instance_jfieldID(k, fd.offset(), fd.is_flat());\n@@ -1783,0 +1816,1 @@\n+  oop res = nullptr;\n@@ -1788,2 +1822,15 @@\n-  oop loaded_obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);\n-  jobject ret = JNIHandles::make_local(THREAD, loaded_obj);\n+  if (!jfieldIDWorkaround::is_flat_jfieldID(fieldID)) {\n+    res = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(o, offset);\n+  } else {\n+    assert(k->is_instance_klass(), \"Only instance can have flat fields\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    fieldDescriptor fd;\n+    bool found = ik->find_field_from_offset(offset, false, &fd);  \/\/ performance bottleneck\n+    assert(found, \"Field not found\");\n+    InstanceKlass* holder = fd.field_holder();\n+    assert(holder->field_is_flat(fd.index()), \"Must be\");\n+    InlineLayoutInfo* li = holder->inline_layout_info_adr(fd.index());\n+    InlineKlass* field_vklass = li->klass();\n+    res = field_vklass->read_payload_from_addr(o, ik->field_offset(fd.index()), li->kind(), CHECK_NULL);\n+  }\n+  jobject ret = JNIHandles::make_local(THREAD, res);\n@@ -1794,2 +1841,0 @@\n-\n-\n@@ -1881,1 +1926,22 @@\n-  HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, JNIHandles::resolve(value));\n+  if (!jfieldIDWorkaround::is_flat_jfieldID(fieldID)) {\n+    oop v = JNIHandles::resolve(value);\n+    if (v == nullptr) {\n+      InstanceKlass *ik = InstanceKlass::cast(k);\n+      fieldDescriptor fd;\n+      ik->find_field_from_offset(offset, false, &fd);\n+      if (fd.is_null_free_inline_type()) {\n+        THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Cannot store null in a null-restricted field\");\n+      }\n+    }\n+    HeapAccess<ON_UNKNOWN_OOP_REF>::oop_store_at(o, offset, v);\n+  } else {\n+    assert(k->is_instance_klass(), \"Only instances can have flat fields\");\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    fieldDescriptor fd;\n+    ik->find_field_from_offset(offset, false, &fd);\n+    InstanceKlass* holder = fd.field_holder();\n+    InlineLayoutInfo* li = holder->inline_layout_info_adr(fd.index());\n+    InlineKlass* vklass = li->klass();\n+    oop v = JNIHandles::resolve(value);\n+    vklass->write_value_to_addr(v, ((char*)(oopDesc*)o) + offset, li->kind(), true, CHECK);\n+  }\n@@ -2310,1 +2376,3 @@\n-    ret = JNIHandles::make_local(THREAD, a->obj_at(index));\n+    oop res = a->obj_at(index, CHECK_NULL);\n+    assert(res != nullptr || !a->is_null_free_array(), \"Invalid value\");\n+    ret = JNIHandles::make_local(THREAD, res);\n@@ -2327,5 +2395,6 @@\n-  objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n-  oop v = JNIHandles::resolve(value);\n-  if (a->is_within_bounds(index)) {\n-    if (v == nullptr || v->is_a(ObjArrayKlass::cast(a->klass())->element_klass())) {\n-      a->obj_at_put(index, v);\n+   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(array));\n+   oop v = JNIHandles::resolve(value);\n+   if (a->is_within_bounds(index)) {\n+    Klass* ek = a->is_flatArray() ? FlatArrayKlass::cast(a->klass())->element_klass() : RefArrayKlass::cast(a->klass())->element_klass();\n+    if (v == nullptr || v->is_a(ek)) {\n+      a->obj_at_put(index, v, CHECK);\n@@ -2345,6 +2414,6 @@\n-  } else {\n-    ResourceMark rm(THREAD);\n-    stringStream ss;\n-    ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n-    THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n-  }\n+   } else {\n+     ResourceMark rm(THREAD);\n+     stringStream ss;\n+     ss.print(\"Index %d out of bounds for length %d\", index, a->length());\n+     THROW_MSG(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), ss.as_string());\n+   }\n@@ -2726,1 +2795,1 @@\n-  ObjectSynchronizer::jni_enter(obj, thread);\n+  ObjectSynchronizer::jni_enter(obj, CHECK_(JNI_ERR));\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":96,"deletions":27,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -67,0 +68,1 @@\n+#include \"oops\/refArrayOop.inline.hpp\"\n@@ -415,0 +417,148 @@\n+static void validate_array_arguments(Klass* elmClass, jint len, TRAPS) {\n+  if (len < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Array length is negative\");\n+  }\n+  elmClass->initialize(CHECK);\n+  if (elmClass->is_array_klass() || elmClass->is_identity_class()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not a value class\");\n+  }\n+  if (elmClass->is_abstract()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is abstract\");\n+  }\n+}\n+\n+JVM_ENTRY(jarray, JVM_CopyOfSpecialArray(JNIEnv *env, jarray orig, jint from, jint to))\n+  oop o = JNIHandles::resolve_non_null(orig);\n+  assert(o->is_array(), \"Must be\");\n+  oop array = nullptr;\n+  arrayOop org = (arrayOop)o;\n+  arrayHandle oh(THREAD, org);\n+  ObjArrayKlass* ak = ObjArrayKlass::cast(org->klass());\n+  InlineKlass* vk = InlineKlass::cast(ak->element_klass());\n+  int len = to - from;  \/\/ length of the new array\n+  if (ak->is_null_free_array_klass()) {\n+    if ((len != 0) && (from >= org->length() || to > org->length())) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Copying of null-free array with uninitialized elements\");\n+    }\n+  }\n+  if (org->is_flatArray()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(org->klass());\n+    LayoutKind lk = fak->layout_kind();\n+    ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+    switch(lk) {\n+      case LayoutKind::ATOMIC_FLAT:\n+        props = ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+      break;\n+      case LayoutKind::NON_ATOMIC_FLAT:\n+        props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NULL_RESTRICTED | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+      break;\n+      case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+      props = ArrayKlass::ArrayProperties::NON_ATOMIC;\n+      break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n+    array = oopFactory::new_flatArray(vk, len, props, lk, CHECK_NULL);\n+    arrayHandle ah(THREAD, (arrayOop)array);\n+    int end = to < oh()->length() ? to : oh()->length();\n+    for (int i = from; i < end; i++) {\n+      void* src = ((flatArrayOop)oh())->value_at_addr(i, fak->layout_helper());\n+      void* dst = ((flatArrayOop)ah())->value_at_addr(i - from, fak->layout_helper());\n+      vk->copy_payload_to_addr(src, dst, lk, false);\n+    }\n+    array = ah();\n+  } else {\n+    ArrayKlass::ArrayProperties props = org->is_null_free_array() ? ArrayKlass::ArrayProperties::NULL_RESTRICTED : ArrayKlass::ArrayProperties::DEFAULT;\n+    array = oopFactory::new_objArray(vk, len, props,  CHECK_NULL);\n+    int end = to < oh()->length() ? to : oh()->length();\n+    for (int i = from; i < end; i++) {\n+      if (i < ((objArrayOop)oh())->length()) {\n+        ((objArrayOop)array)->obj_at_put(i - from, ((objArrayOop)oh())->obj_at(i));\n+      } else {\n+        assert(!ak->is_null_free_array_klass(), \"Must be a nullable array\");\n+        ((objArrayOop)array)->obj_at_put(i - from, nullptr);\n+      }\n+    }\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedNonAtomicArray(JNIEnv *env, jclass elmClass, jint len, jobject initVal))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  oop init = JNIHandles::resolve(initVal);\n+  if (init == nullptr) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Initial value cannot be null\");\n+  }\n+  Handle init_h(THREAD, init);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  if (klass != init_h()->klass()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Type mismatch between array and initial value\");\n+  }\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  ArrayKlass::ArrayProperties props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NON_ATOMIC | ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n+  objArrayOop array = oopFactory::new_objArray(klass, len, props, CHECK_NULL);\n+  for (int i = 0; i < len; i++) {\n+    array->obj_at_put(i, init_h() \/*, CHECK_NULL*\/ );\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullRestrictedAtomicArray(JNIEnv *env, jclass elmClass, jint len, jobject initVal))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  oop init = JNIHandles::resolve(initVal);\n+  if (init == nullptr) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Initial value cannot be null\");\n+  }\n+  Handle init_h(THREAD, init);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  if (klass != init_h()->klass()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Type mismatch between array and initial value\");\n+  }\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  ArrayKlass::ArrayProperties props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NULL_RESTRICTED);\n+  objArrayOop array = oopFactory::new_objArray(klass, len, props, CHECK_NULL);\n+  for (int i = 0; i < len; i++) {\n+    array->obj_at_put(i, init_h() \/*, CHECK_NULL*\/ );\n+  }\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jarray, JVM_NewNullableAtomicArray(JNIEnv *env, jclass elmClass, jint len))\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  validate_array_arguments(klass, len, CHECK_NULL);\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  ArrayKlass::ArrayProperties props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::DEFAULT);\n+  objArrayOop array = oopFactory::new_objArray(klass, len, props, CHECK_NULL);\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsFlatArray(JNIEnv *env, jobject obj))\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  return oop->is_flatArray();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsNullRestrictedArray(JNIEnv *env, jobject obj))\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  return oop->is_null_free_array();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsAtomicArray(JNIEnv *env, jobject obj))\n+  \/\/ There are multiple cases where an array can\/must support atomic access:\n+  \/\/   - the array is a reference array\n+  \/\/   - the array uses an atomic flat layout: NULLABLE_ATOMIC_FLAT or ATOMIC_FLAT\n+  \/\/   - the array is flat and its component type is naturally atomic\n+  arrayOop oop = arrayOop(JNIHandles::resolve_non_null(obj));\n+  if (oop->is_refArray()) return true;\n+  if (oop->is_flatArray()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(oop->klass());\n+    if (fak->layout_kind() == LayoutKind::ATOMIC_FLAT || fak->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n+      return true;\n+    }\n+    if (fak->element_klass()->is_naturally_atomic()) return true;\n+  }\n+  return false;\n+JVM_END\n@@ -623,2 +773,22 @@\n-  return handle == nullptr ? 0 :\n-         checked_cast<jint>(ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)));\n+  if (handle == nullptr) {\n+    return 0;\n+  }\n+  oop obj = JNIHandles::resolve_non_null(handle);\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+      JavaValue result(T_INT);\n+      JavaCallArguments args;\n+      Handle ho(THREAD, obj);\n+      args.push_oop(ho);\n+      methodHandle method(THREAD, Universe::value_object_hash_code_method());\n+      JavaCalls::call(&result, method, &args, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (!PENDING_EXCEPTION->is_a(vmClasses::Error_klass())) {\n+          Handle e(THREAD, PENDING_EXCEPTION);\n+          CLEAR_PENDING_EXCEPTION;\n+          THROW_MSG_CAUSE_(vmSymbols::java_lang_InternalError(), \"Internal error in hashCode\", e, false);\n+        }\n+      }\n+      return result.get_jint();\n+  } else {\n+    return checked_cast<jint>(ObjectSynchronizer::FastHashCode(THREAD, obj));\n+  }\n@@ -672,0 +842,6 @@\n+  if (klass->is_inline_klass()) {\n+    \/\/ Value instances have no identity, so return the current instance instead of allocating a new one\n+    \/\/ Value classes cannot have finalizers, so the method can return immediately\n+    return JNIHandles::make_local(THREAD, obj());\n+  }\n+\n@@ -1166,1 +1342,2 @@\n-    size = InstanceKlass::cast(klass)->local_interfaces()->length();\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    size = ik->local_interfaces()->length();\n@@ -1200,1 +1377,0 @@\n-\n@@ -1684,1 +1860,1 @@\n-    if (want_constructor && !method->is_object_initializer()) {\n+    if (want_constructor && !method->is_object_constructor()) {\n@@ -1688,1 +1864,1 @@\n-        (method->is_object_initializer() || method->is_static_initializer() ||\n+        (method->is_object_constructor() || method->is_class_initializer() ||\n@@ -1716,0 +1892,1 @@\n+        assert(method->is_object_constructor(), \"must be\");\n@@ -1985,1 +2162,1 @@\n-  if (m->is_object_initializer()) {\n+  if (m->is_object_constructor()) {\n@@ -1988,1 +2165,0 @@\n-    \/\/ new_method accepts <clinit> as Method here\n@@ -2438,1 +2614,1 @@\n-  return method->name() == vmSymbols::object_initializer_name();\n+  return method->is_object_constructor();\n@@ -3247,0 +3423,4 @@\n+JVM_LEAF(jboolean, JVM_IsValhallaEnabled(void))\n+  return EnableValhalla ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n@@ -3326,1 +3506,3 @@\n-    objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n+    objArrayHandle args(THREAD, (objArrayOop)JNIHandles::resolve(args0));\n+    assert(args() == nullptr || !args->is_flatArray(), \"args are never flat or are they???\");\n+\n@@ -3346,0 +3528,2 @@\n+  objArrayHandle args(THREAD, (objArrayOop)JNIHandles::resolve(args0));\n+  assert(args() == nullptr || !args->is_flatArray(), \"args are never flat or are they???\");\n@@ -3347,1 +3531,0 @@\n-  objArrayHandle args(THREAD, objArrayOop(JNIHandles::resolve(args0)));\n@@ -3587,0 +3770,1 @@\n+  refArrayHandle rah(THREAD, (refArrayOop)ah()); \/\/ j.l.Thread is an identity class, arrays are always reference arrays\n@@ -3592,1 +3776,1 @@\n-    oop thread_obj = ah->obj_at(i);\n+    oop thread_obj = rah->obj_at(i);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":196,"deletions":12,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -2729,4 +2729,0 @@\n-  if (!java_lang_Class::is_primitive(k_mirror)) {\n-    \/\/ Reset the deleted  ACC_SUPER bit (deleted in compute_modifier_flags()).\n-    result |= JVM_ACC_SUPER;\n-  }\n@@ -2850,1 +2846,2 @@\n-                                                     flds.access_flags().is_static());\n+                                                     flds.access_flags().is_static(),\n+                                                     flds.field_descriptor().is_flat());\n@@ -2888,2 +2885,3 @@\n-    Array<InstanceKlass*>* interface_list = InstanceKlass::cast(k)->local_interfaces();\n-    const int result_length = (interface_list == nullptr ? 0 : interface_list->length());\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    Array<InstanceKlass*>* interface_list = ik->local_interfaces();\n+    int result_length = (interface_list == nullptr ? 0 : interface_list->length());\n@@ -3085,3 +3083,6 @@\n-  {\n-    jint result = (jint) mirror->identity_hash();\n-    *hash_code_ptr = result;\n+  if (mirror->is_inline_type()) {\n+    \/\/ For inline types, use the klass as a hash code.\n+    \/\/ TBD to improve this (see also JvmtiTagMapKey::get_hash for similar case).\n+    *hash_code_ptr = (jint)((int64_t)mirror->klass() >> 3);\n+  } else {\n+    *hash_code_ptr = (jint)mirror->identity_hash();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -618,2 +618,1 @@\n-    \/\/ At this stage JVM_CONSTANT_UnresolvedClassInError should not be\n-    \/\/ here\n+    \/\/ At this stage JVM_CONSTANT_UnresolvedClassInError should not be here\n@@ -1938,0 +1937,6 @@\n+  \/\/ rewrite constant pool references in the LoadableDescriptors attribute:\n+  if (!rewrite_cp_refs_in_loadable_descriptors_attribute(scratch_class)) {\n+    \/\/ propagate failure back to caller\n+    return false;\n+  }\n+\n@@ -2086,0 +2091,13 @@\n+\/\/ Rewrite constant pool references in the LoadableDescriptors attribute.\n+bool VM_RedefineClasses::rewrite_cp_refs_in_loadable_descriptors_attribute(\n+       InstanceKlass* scratch_class) {\n+\n+  Array<u2>* loadable_descriptors = scratch_class->loadable_descriptors();\n+  assert(loadable_descriptors != nullptr, \"unexpected null loadable_descriptors\");\n+  for (int i = 0; i < loadable_descriptors->length(); i++) {\n+    u2 cp_index = loadable_descriptors->at(i);\n+    loadable_descriptors->at_put(i, find_new_index(cp_index));\n+  }\n+  return true;\n+}\n+\n@@ -3273,0 +3291,8 @@\n+   if (frame_type == 246) {  \/\/ EARLY_LARVAL\n+     \/\/ rewrite_cp_refs in  unset fields and fall through.\n+     rewrite_cp_refs_in_early_larval_stackmaps(stackmap_p, stackmap_end, calc_number_of_entries, frame_type);\n+     \/\/ The larval frames point to the next frame, so advance to the next frame and fall through.\n+     frame_type = *stackmap_p;\n+     stackmap_p++;\n+   }\n+\n@@ -3482,0 +3508,23 @@\n+void VM_RedefineClasses::rewrite_cp_refs_in_early_larval_stackmaps(\n+       address& stackmap_p_ref, address stackmap_end, u2 frame_i,\n+       u1 frame_type) {\n+\n+    u2 num_early_larval_stackmaps = Bytes::get_Java_u2(stackmap_p_ref);\n+    stackmap_p_ref += 2;\n+\n+    for (u2 i = 0; i < num_early_larval_stackmaps; i++) {\n+\n+      u2 name_and_ref_index = Bytes::get_Java_u2(stackmap_p_ref);\n+      u2 new_cp_index = find_new_index(name_and_ref_index);\n+      if (new_cp_index != 0) {\n+        log_debug(redefine, class, stackmap)(\"mapped old name_and_ref_index=%d\", name_and_ref_index);\n+        Bytes::put_Java_u2(stackmap_p_ref, new_cp_index);\n+        name_and_ref_index = new_cp_index;\n+      }\n+      log_debug(redefine, class, stackmap)\n+        (\"frame_i=%u, frame_type=%u, name_and_ref_index=%d\", frame_i, frame_type, name_and_ref_index);\n+\n+      stackmap_p_ref += 2;\n+    }\n+} \/\/ rewrite_cp_refs_in_early_larval_stackmaps\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -73,0 +73,61 @@\n+\n+\/\/ Helper class to store objects to visit.\n+class JvmtiHeapwalkVisitStack {\n+private:\n+  enum {\n+    initial_visit_stack_size = 4000\n+  };\n+\n+  GrowableArray<JvmtiHeapwalkObject>* _visit_stack;\n+  JVMTIBitSet _bitset;\n+\n+  static GrowableArray<JvmtiHeapwalkObject>* create_visit_stack() {\n+    return new (mtServiceability) GrowableArray<JvmtiHeapwalkObject>(initial_visit_stack_size, mtServiceability);\n+  }\n+\n+public:\n+  JvmtiHeapwalkVisitStack(): _visit_stack(create_visit_stack()) {\n+  }\n+  ~JvmtiHeapwalkVisitStack() {\n+    if (_visit_stack != nullptr) {\n+      delete _visit_stack;\n+    }\n+  }\n+\n+  bool is_empty() const {\n+    return _visit_stack->is_empty();\n+  }\n+\n+  void push(const JvmtiHeapwalkObject& obj) {\n+    _visit_stack->push(obj);\n+  }\n+\n+  \/\/ If the object hasn't been visited then push it onto the visit stack\n+  \/\/ so that it will be visited later.\n+  void check_for_visit(const JvmtiHeapwalkObject& obj) {\n+    if (!is_visited(obj)) {\n+      _visit_stack->push(obj);\n+    }\n+  }\n+\n+  JvmtiHeapwalkObject pop() {\n+    return _visit_stack->pop();\n+  }\n+\n+  bool is_visited(const JvmtiHeapwalkObject& obj) \/*const*\/ { \/\/ TODO: _bitset.is_marked() should be const\n+    \/\/ The method is called only for objects from visit_stack to ensure an object is not visited twice.\n+    \/\/ Flat objects can be added to visit_stack only when we visit their holder object, so we cannot get duplicate reference to it.\n+    if (obj.is_flat()) {\n+      return false;\n+    }\n+    return _bitset.is_marked(obj.obj());\n+  }\n+\n+  void mark_visited(const JvmtiHeapwalkObject& obj) {\n+    if (!obj.is_flat()) {\n+      _bitset.mark_obj(obj.obj());\n+    }\n+  }\n+};\n+\n+\n@@ -80,1 +141,2 @@\n-  _posting_events(false) {\n+  _posting_events(false),\n+  _converting_flat_object(false) {\n@@ -86,0 +148,1 @@\n+  _flat_hashmap = new JvmtiFlatTagMapTable();\n@@ -101,0 +164,1 @@\n+  delete _flat_hashmap;\n@@ -109,0 +173,1 @@\n+  _flat_hashmap->clear();\n@@ -127,6 +192,1 @@\n-\/\/ iterate over all entries in the tag map.\n-void JvmtiTagMap::entry_iterate(JvmtiTagMapKeyClosure* closure) {\n-  hashmap()->entry_iterate(closure);\n-}\n-\n-bool JvmtiTagMap::is_empty() {\n+bool JvmtiTagMap::is_empty() const {\n@@ -135,1 +195,1 @@\n-  return hashmap()->is_empty();\n+  return _hashmap->is_empty() && _flat_hashmap->is_empty();\n@@ -169,5 +229,150 @@\n-\/\/ Return the tag value for an object, or 0 if the object is\n-\/\/ not tagged\n-\/\/\n-static inline jlong tag_for(JvmtiTagMap* tag_map, oop o) {\n-  return tag_map->hashmap()->find(o);\n+\/\/ Converts entries from JvmtiFlatTagMapTable to JvmtiTagMapTable in batches.\n+\/\/   1. (JvmtiTagMap is locked)\n+\/\/      reads entries from JvmtiFlatTagMapTable (describe flat value objects);\n+\/\/   2. (JvmtiTagMap is unlocked)\n+\/\/      creates heap-allocated copies of the flat object;\n+\/\/   3. (JvmtiTagMap is locked)\n+\/\/      ensures source entry still exists, removes it from JvmtiFlatTagMapTable, adds new entry to JvmtiTagMapTable.\n+\/\/ If some error occurs in step 2 (OOM?), the process stops.\n+class JvmtiTagMapFlatEntryConverter: public StackObj {\n+private:\n+  struct Entry {\n+    \/\/ source flat value object\n+    Handle holder;\n+    int offset;\n+    InlineKlass* inline_klass;\n+    LayoutKind layout_kind;\n+    \/\/ converted heap-allocated object\n+    Handle dst;\n+\n+    Entry(): holder(), offset(0), inline_klass(nullptr), dst() {}\n+    Entry(Handle holder, int offset, InlineKlass* inline_klass, LayoutKind lk)\n+      : holder(holder), offset(offset), inline_klass(inline_klass), layout_kind(lk), dst() {}\n+  };\n+\n+  int _batch_size;\n+  GrowableArray<Entry> _entries;\n+  bool _has_error;\n+\n+public:\n+  JvmtiTagMapFlatEntryConverter(int batch_size): _batch_size(batch_size), _entries(batch_size, mtServiceability), _has_error(false) { }\n+  ~JvmtiTagMapFlatEntryConverter() {}\n+\n+  \/\/ returns false if there is nothing to convert\n+  bool import_entries(JvmtiFlatTagMapTable* table) {\n+    if (_has_error) {\n+      \/\/ stop the process to avoid infinite loop\n+      return false;\n+    }\n+\n+    class Importer: public JvmtiFlatTagMapKeyClosure {\n+    private:\n+      GrowableArray<Entry>& _entries;\n+      int _batch_size;\n+    public:\n+      Importer(GrowableArray<Entry>& entries, int batch_size): _entries(entries), _batch_size(batch_size) {}\n+\n+      bool do_entry(JvmtiFlatTagMapKey& key, jlong& tag) {\n+        Entry entry(Handle(Thread::current(), key.holder()), key.offset(), key.inline_klass(), key.layout_kind());\n+        _entries.append(entry);\n+\n+        return _entries.length() < _batch_size;\n+      }\n+    } importer(_entries, _batch_size);\n+    table->entry_iterate(&importer);\n+\n+    return !_entries.is_empty();\n+  }\n+\n+  void convert() {\n+    for (int i = 0; i < _entries.length(); i++) {\n+      EXCEPTION_MARK;\n+      Entry& entry = _entries.at(i);\n+      oop obj = entry.inline_klass->read_payload_from_addr(entry.holder(), entry.offset, entry.layout_kind, JavaThread::current());\n+\n+      if (HAS_PENDING_EXCEPTION) {\n+        tty->print_cr(\"Exception in JvmtiTagMapFlatEntryConverter: \");\n+        java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n+        tty->cr();\n+        CLEAR_PENDING_EXCEPTION;\n+        \/\/ stop the conversion\n+        _has_error = true;\n+      } else {\n+        entry.dst = Handle(Thread::current(), obj);\n+      }\n+    }\n+  }\n+\n+  \/\/ returns number of converted entries\n+  int move(JvmtiFlatTagMapTable* src_table, JvmtiTagMapTable* dst_table) {\n+    int count = 0;\n+    for (int i = 0; i < _entries.length(); i++) {\n+      Entry& entry = _entries.at(i);\n+      if (entry.dst() == nullptr) {\n+        \/\/ some error during conversion, skip the entry\n+        continue;\n+      }\n+      JvmtiHeapwalkObject obj(entry.holder(), entry.offset, entry.inline_klass, entry.layout_kind);\n+      jlong tag = src_table->remove(obj);\n+\n+      if (tag != 0) { \/\/ ensure the entry is still in the src_table\n+        dst_table->add(entry.dst(), tag);\n+        count++;\n+      } else {\n+\n+      }\n+    }\n+    \/\/ and clean the array\n+    _entries.clear();\n+    return count;\n+  }\n+};\n+\n+\n+void JvmtiTagMap::convert_flat_object_entries() {\n+  Thread* current = Thread::current();\n+  assert(current->is_Java_thread(), \"must be executed on JavaThread\");\n+\n+  log_debug(jvmti, table)(\"convert_flat_object_entries, main table size = %d, flat table size = %d\",\n+                          _hashmap->number_of_entries(), _flat_hashmap->number_of_entries());\n+\n+  {\n+    MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+    \/\/ If another thread is converting, let it finish.\n+    while (_converting_flat_object) {\n+      ml.wait();\n+    }\n+    if (_flat_hashmap->is_empty()) {\n+      \/\/ nothing to convert\n+      return;\n+    }\n+    _converting_flat_object = true;\n+  }\n+\n+  const int BATCH_SIZE = 1024;\n+  JvmtiTagMapFlatEntryConverter converter(BATCH_SIZE);\n+\n+  int count = 0;\n+  while (true) {\n+    HandleMark hm(current);\n+    {\n+      MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      if (!converter.import_entries(_flat_hashmap)) {\n+        break;\n+      }\n+    }\n+    \/\/ Convert flat objects to heap-allocated without table lock (so agent callbacks can get\/set tags).\n+    converter.convert();\n+    {\n+      MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      count += converter.move(_flat_hashmap, _hashmap);\n+    }\n+  }\n+\n+  log_info(jvmti, table)(\"%d flat value objects are converted, flat table size = %d\",\n+                         count, _flat_hashmap->number_of_entries());\n+  {\n+    MonitorLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+    _converting_flat_object = false;\n+    ml.notify_all();\n+  }\n@@ -176,0 +381,29 @@\n+jlong JvmtiTagMap::find(const JvmtiHeapwalkObject& obj) const {\n+  jlong tag = _hashmap->find(obj);\n+  if (tag == 0 && obj.is_value()) {\n+    tag = _flat_hashmap->find(obj);\n+  }\n+  return tag;\n+}\n+\n+void JvmtiTagMap::add(const JvmtiHeapwalkObject& obj, jlong tag) {\n+  if (obj.is_flat()) {\n+    \/\/ we may have tag for equal (non-flat) object in _hashmap, try to update it 1st\n+    if (!_hashmap->update(obj, tag)) {\n+      \/\/ no entry in _hashmap, add to _flat_hashmap\n+      _flat_hashmap->add(obj, tag);\n+    }\n+  } else {\n+    _hashmap->add(obj, tag);\n+  }\n+}\n+\n+void JvmtiTagMap::remove(const JvmtiHeapwalkObject& obj) {\n+  if (!_hashmap->remove(obj)) {\n+    if (obj.is_value()) {\n+      _flat_hashmap->remove(obj);\n+    }\n+  }\n+}\n+\n+\n@@ -194,2 +428,1 @@\n-  JvmtiTagMapTable* _hashmap;\n-  oop _o;\n+  const JvmtiHeapwalkObject& _o;\n@@ -204,2 +437,2 @@\n-  void inline post_callback_tag_update(oop o, JvmtiTagMapTable* hashmap,\n-                                       jlong obj_tag);\n+  void inline post_callback_tag_update(const JvmtiHeapwalkObject& o, JvmtiTagMap* tag_map, jlong obj_tag);\n+\n@@ -207,1 +440,3 @@\n-  CallbackWrapper(JvmtiTagMap* tag_map, oop o) {\n+  CallbackWrapper(JvmtiTagMap* tag_map, const JvmtiHeapwalkObject& o)\n+    : _tag_map(tag_map), _o(o)\n+  {\n@@ -211,8 +446,8 @@\n-    \/\/ object to tag\n-    _o = o;\n-\n-    _obj_size = (jlong)_o->size() * wordSize;\n-\n-    \/\/ record the context\n-    _tag_map = tag_map;\n-    _hashmap = tag_map->hashmap();\n+    if (!o.is_flat()) {\n+      \/\/ common case: we have oop\n+      _obj_size = (jlong)o.obj()->size() * wordSize;\n+    } else {\n+      \/\/ flat value object, we know its InstanceKlass\n+      assert(_o.inline_klass() != nullptr, \"must be\");\n+      _obj_size = _o.inline_klass()->size() * wordSize;;\n+    }\n@@ -222,1 +457,1 @@\n-    _obj_tag = _hashmap->find(_o);\n+    _obj_tag = _tag_map->find(_o);\n@@ -227,1 +462,1 @@\n-    _klass_tag = tag_for(tag_map, _o->klass()->java_mirror());\n+    _klass_tag = _tag_map->find(_o.klass()->java_mirror());\n@@ -231,1 +466,1 @@\n-    post_callback_tag_update(_o, _hashmap, _obj_tag);\n+    post_callback_tag_update(_o, _tag_map, _obj_tag);\n@@ -241,2 +476,2 @@\n-void inline CallbackWrapper::post_callback_tag_update(oop o,\n-                                                      JvmtiTagMapTable* hashmap,\n+void inline CallbackWrapper::post_callback_tag_update(const JvmtiHeapwalkObject& o,\n+                                                      JvmtiTagMap* tag_map,\n@@ -246,1 +481,1 @@\n-    hashmap->remove(o);\n+    tag_map->remove(o);\n@@ -251,1 +486,1 @@\n-    hashmap->add(o, obj_tag);\n+    tag_map->add(o, obj_tag);\n@@ -273,0 +508,1 @@\n+  const JvmtiHeapwalkObject& _referrer;\n@@ -274,2 +510,0 @@\n-  JvmtiTagMapTable* _referrer_hashmap;\n-  oop _referrer;\n@@ -283,2 +517,2 @@\n-  TwoOopCallbackWrapper(JvmtiTagMap* tag_map, oop referrer, oop o) :\n-    CallbackWrapper(tag_map, o)\n+  TwoOopCallbackWrapper(JvmtiTagMap* tag_map, const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& o) :\n+    CallbackWrapper(tag_map, o), _referrer(referrer)\n@@ -293,5 +527,1 @@\n-      _referrer = referrer;\n-      \/\/ record the context\n-      _referrer_hashmap = tag_map->hashmap();\n-\n-      _referrer_obj_tag = _referrer_hashmap->find(_referrer);\n+      _referrer_obj_tag = tag_map->find(_referrer);\n@@ -303,1 +533,1 @@\n-      _referrer_klass_tag = tag_for(tag_map, _referrer->klass()->java_mirror());\n+      _referrer_klass_tag = tag_map->find(_referrer.klass()->java_mirror());\n@@ -310,1 +540,1 @@\n-                               _referrer_hashmap,\n+                               tag_map(),\n@@ -338,3 +568,1 @@\n-\n-  JvmtiTagMapTable* hashmap = _hashmap;\n-\n+  JvmtiHeapwalkObject obj(o);\n@@ -344,1 +572,1 @@\n-    hashmap->remove(o);\n+    _hashmap->remove(obj);\n@@ -348,1 +576,1 @@\n-    hashmap->add(o, tag);\n+    add(obj, tag);\n@@ -364,1 +592,1 @@\n-  return tag_for(this, o);\n+  return find(o);\n@@ -377,0 +605,2 @@\n+  InlineKlass* _inline_klass; \/\/ nullptr for heap object\n+  LayoutKind _layout_kind;\n@@ -378,2 +608,12 @@\n-  ClassFieldDescriptor(int index, char type, int offset) :\n-    _field_index(index), _field_offset(offset), _field_type(type) {\n+  ClassFieldDescriptor(int index, const FieldStreamBase& fld) :\n+      _field_index(index), _field_offset(fld.offset()), _field_type(fld.signature()->char_at(0)) {\n+    if (fld.is_flat()) {\n+      const fieldDescriptor& fd = fld.field_descriptor();\n+      InstanceKlass* holder_klass = fd.field_holder();\n+      InlineLayoutInfo* layout_info = holder_klass->inline_layout_info_adr(fd.index());\n+      _inline_klass = layout_info->klass();\n+      _layout_kind = layout_info->kind();\n+    } else {\n+      _inline_klass = nullptr;\n+      _layout_kind = LayoutKind::REFERENCE;\n+    }\n@@ -384,0 +624,3 @@\n+  bool is_flat()     const  { return _inline_klass != nullptr; }\n+  InlineKlass* inline_klass() const { return _inline_klass; }\n+  LayoutKind layout_kind() const { return _layout_kind; }\n@@ -402,1 +645,1 @@\n-  void add(int index, char type, int offset);\n+  void add(int index, const FieldStreamBase& fld);\n@@ -413,1 +656,1 @@\n-  static ClassFieldMap* create_map_of_instance_fields(oop obj);\n+  static ClassFieldMap* create_map_of_instance_fields(Klass* k);\n@@ -438,2 +681,2 @@\n-void ClassFieldMap::add(int index, char type, int offset) {\n-  ClassFieldDescriptor* field = new ClassFieldDescriptor(index, type, offset);\n+void ClassFieldMap::add(int index, const FieldStreamBase& fld) {\n+  ClassFieldDescriptor* field = new ClassFieldDescriptor(index, fld);\n@@ -464,1 +707,1 @@\n-    field_map->add(index, fld.signature()->char_at(0), fld.offset());\n+    field_map->add(index, fld);\n@@ -473,2 +716,2 @@\n-ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(oop obj) {\n-  InstanceKlass* ik = InstanceKlass::cast(obj->klass());\n+ClassFieldMap* ClassFieldMap::create_map_of_instance_fields(Klass* k) {\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n@@ -494,1 +737,1 @@\n-      field_map->add(start_index + index, fld.signature()->char_at(0), fld.offset());\n+      field_map->add(start_index + index, fld);\n@@ -524,1 +767,1 @@\n-  \/\/ returns the field map for a given object (returning map cached\n+  \/\/ returns the field map for a given klass (returning map cached\n@@ -526,1 +769,1 @@\n-  static ClassFieldMap* get_map_of_instance_fields(oop obj);\n+  static ClassFieldMap* get_map_of_instance_fields(Klass* k);\n@@ -578,1 +821,1 @@\n-\/\/ returns the instance field map for the given object\n+\/\/ returns the instance field map for the given klass\n@@ -580,1 +823,1 @@\n-ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(oop obj) {\n+ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(Klass *k) {\n@@ -584,1 +827,0 @@\n-  Klass* k = obj->klass();\n@@ -593,1 +835,1 @@\n-    ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(obj);\n+    ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(k);\n@@ -645,1 +887,1 @@\n-static inline bool is_filtered_by_klass_filter(oop obj, Klass* klass_filter) {\n+static inline bool is_filtered_by_klass_filter(const JvmtiHeapwalkObject& obj, Klass* klass_filter) {\n@@ -647,1 +889,1 @@\n-    if (obj->klass() != klass_filter) {\n+    if (obj.klass() != klass_filter) {\n@@ -678,1 +920,1 @@\n-                                         oop str,\n+                                         const JvmtiHeapwalkObject& obj,\n@@ -681,0 +923,2 @@\n+  assert(!obj.is_flat(), \"cannot be flat\");\n+  oop str = obj.obj();\n@@ -729,1 +973,1 @@\n-                                                  oop obj,\n+                                                  const JvmtiHeapwalkObject& obj,\n@@ -732,1 +976,2 @@\n-  assert(obj->is_typeArray(), \"not a primitive array\");\n+  assert(!obj.is_flat(), \"cannot be flat\");\n+  assert(obj.obj()->is_typeArray(), \"not a primitive array\");\n@@ -735,1 +980,1 @@\n-  typeArrayOop array = typeArrayOop(obj);\n+  typeArrayOop array = typeArrayOop(obj.obj());\n@@ -825,1 +1070,1 @@\n-  oop obj,\n+  const JvmtiHeapwalkObject& obj,\n@@ -833,1 +1078,1 @@\n-  ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj);\n+  ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj.klass());\n@@ -847,3 +1092,2 @@\n-    \/\/ get offset and field value\n-    int offset = field->field_offset();\n-    address addr = cast_from_oop<address>(obj) + offset;\n+    \/\/ get field value\n+    address addr = cast_from_oop<address>(obj.obj()) + obj.offset() + field->field_offset();\n@@ -963,1 +1207,2 @@\n-  CallbackWrapper wrapper(tag_map(), o);\n+  JvmtiHeapwalkObject wrapper_obj(o);\n+  CallbackWrapper wrapper(tag_map(), wrapper_obj);\n@@ -1015,0 +1260,4 @@\n+  void visit_object(const JvmtiHeapwalkObject& obj);\n+  void visit_flat_fields(const JvmtiHeapwalkObject& obj);\n+  void visit_flat_array_elements(const JvmtiHeapwalkObject& obj);\n+\n@@ -1030,1 +1279,1 @@\n-  void do_object(oop o);\n+  void do_object(oop obj);\n@@ -1039,4 +1288,1 @@\n-  \/\/ apply class filter\n-  if (is_filtered_by_klass_filter(obj, klass())) return;\n-\n-  if (obj->klass()->java_mirror() == nullptr) {\n+  if (obj != nullptr && obj->klass()->java_mirror() == nullptr) {\n@@ -1049,0 +1295,7 @@\n+  visit_object(obj);\n+}\n+\n+void IterateThroughHeapObjectClosure::visit_object(const JvmtiHeapwalkObject& obj) {\n+  \/\/ apply class filter\n+  if (is_filtered_by_klass_filter(obj, klass())) return;\n+\n@@ -1058,2 +1311,2 @@\n-  bool is_array = obj->is_array();\n-  int len = is_array ? arrayOop(obj)->length() : -1;\n+  bool is_array = obj.klass()->is_array_klass();\n+  int len = is_array ? arrayOop(obj.obj())->length() : -1;\n@@ -1073,1 +1326,1 @@\n-  if (callbacks()->primitive_field_callback != nullptr && obj->is_instance()) {\n+  if (callbacks()->primitive_field_callback != nullptr && obj.klass()->is_instance_klass()) {\n@@ -1076,1 +1329,2 @@\n-    if (obj->klass() == vmClasses::Class_klass()) {\n+    if (obj.klass() == vmClasses::Class_klass()) {\n+      assert(!obj.is_flat(), \"Class object cannot be flattened\");\n@@ -1078,3 +1332,3 @@\n-                                                                    obj,\n-                                                                    cb,\n-                                                                    (void*)user_data());\n+                                                              obj.obj(),\n+                                                              cb,\n+                                                              (void*)user_data());\n@@ -1083,3 +1337,3 @@\n-                                                                      obj,\n-                                                                      cb,\n-                                                                      (void*)user_data());\n+                                                                obj,\n+                                                                cb,\n+                                                                (void*)user_data());\n@@ -1093,1 +1347,1 @@\n-      obj->klass() == vmClasses::String_klass()) {\n+      obj.klass() == vmClasses::String_klass()) {\n@@ -1098,1 +1352,1 @@\n-                (void*)user_data() );\n+                (void*)user_data());\n@@ -1105,1 +1359,1 @@\n-      obj->is_typeArray()) {\n+      obj.klass()->is_typeArray_klass()) {\n@@ -1110,1 +1364,1 @@\n-               (void*)user_data() );\n+               (void*)user_data());\n@@ -1113,1 +1367,81 @@\n-};\n+  \/\/ All info for the object is reported.\n+\n+  \/\/ If the object has flat fields, report them as heap objects.\n+  if (obj.klass()->is_instance_klass()) {\n+    if (InstanceKlass::cast(obj.klass())->has_inline_type_fields()) {\n+      visit_flat_fields(obj);\n+      \/\/ check if iteration has been halted\n+      if (is_iteration_aborted()) {\n+        return;\n+      }\n+    }\n+  }\n+  \/\/ If the object is flat array, report all elements as heap objects.\n+  if (is_array && obj.obj()->is_flatArray()) {\n+    assert(!obj.is_flat(), \"Array object cannot be flattened\");\n+    visit_flat_array_elements(obj);\n+  }\n+}\n+\n+void IterateThroughHeapObjectClosure::visit_flat_fields(const JvmtiHeapwalkObject& obj) {\n+  \/\/ iterate over instance fields\n+  ClassFieldMap* fields = JvmtiCachedClassFieldMap::get_map_of_instance_fields(obj.klass());\n+  for (int i = 0; i < fields->field_count(); i++) {\n+    ClassFieldDescriptor* field = fields->field_at(i);\n+    \/\/ skip non-flat and (for safety) primitive fields\n+    if (!field->is_flat() || is_primitive_field_type(field->field_type())) {\n+      continue;\n+    }\n+\n+    int field_offset = field->field_offset();\n+    if (obj.is_flat()) {\n+      \/\/ the object is inlined, its fields are stored without the header\n+      field_offset += obj.offset() - obj.inline_klass()->payload_offset();\n+    }\n+    \/\/ check for possible nulls\n+    bool can_be_null = field->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+    if (can_be_null) {\n+      address payload = cast_from_oop<address>(obj.obj()) + field_offset;\n+      if (field->inline_klass()->is_payload_marked_as_null(payload)) {\n+        continue;\n+      }\n+    }\n+    JvmtiHeapwalkObject field_obj(obj.obj(), field_offset, field->inline_klass(), field->layout_kind());\n+\n+    visit_object(field_obj);\n+\n+    \/\/ check if iteration has been halted\n+    if (is_iteration_aborted()) {\n+      return;\n+    }\n+  }\n+}\n+\n+void IterateThroughHeapObjectClosure::visit_flat_array_elements(const JvmtiHeapwalkObject& obj) {\n+  assert(!obj.is_flat() && obj.obj()->is_flatArray() , \"sanity check\");\n+  flatArrayOop array = flatArrayOop(obj.obj());\n+  FlatArrayKlass* faklass = FlatArrayKlass::cast(array->klass());\n+  InlineKlass* vk = InlineKlass::cast(faklass->element_klass());\n+  bool need_null_check = faklass->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+\n+  for (int index = 0; index < array->length(); index++) {\n+    address addr = (address)array->value_at_addr(index, faklass->layout_helper());\n+    \/\/ check for null\n+    if (need_null_check) {\n+      if (vk->is_payload_marked_as_null(addr)) {\n+        continue;\n+      }\n+    }\n+\n+    \/\/ offset in the array oop\n+    int offset = (int)(addr - cast_from_oop<address>(array));\n+    JvmtiHeapwalkObject elem(obj.obj(), offset, vk, faklass->layout_kind());\n+\n+    visit_object(elem);\n+\n+    \/\/ check if iteration has been halted\n+    if (is_iteration_aborted()) {\n+      return;\n+    }\n+  }\n+}\n@@ -1139,0 +1473,2 @@\n+  convert_flat_object_entries();\n+\n@@ -1166,0 +1502,2 @@\n+  convert_flat_object_entries();\n+\n@@ -1179,1 +1517,1 @@\n-    hashmap()->remove_dead_entries(objects);\n+    _hashmap->remove_dead_entries(objects);\n@@ -1332,0 +1670,3 @@\n+  \/\/ ensure flat object conversion is completed\n+  convert_flat_object_entries();\n+\n@@ -1340,1 +1681,1 @@\n-    entry_iterate(&collector);\n+    _hashmap->entry_iterate(&collector);\n@@ -1380,1 +1721,1 @@\n-  oop _last_referrer;\n+  JvmtiHeapwalkObject _last_referrer;\n@@ -1393,1 +1734,1 @@\n-    _last_referrer(nullptr),\n+    _last_referrer(),\n@@ -1402,2 +1743,2 @@\n-  oop last_referrer() const               { return _last_referrer; }\n-  void set_last_referrer(oop referrer)    { _last_referrer = referrer; }\n+  JvmtiHeapwalkObject last_referrer() const    { return _last_referrer; }\n+  void set_last_referrer(const JvmtiHeapwalkObject& referrer) { _last_referrer = referrer; }\n@@ -1476,2 +1817,1 @@\n-  static GrowableArray<oop>* _visit_stack;\n-  static JVMTIBitSet* _bitset;\n+  static JvmtiHeapwalkVisitStack* _visit_stack;\n@@ -1482,1 +1822,1 @@\n-  static GrowableArray<oop>* visit_stack()             { return _visit_stack; }\n+  static JvmtiHeapwalkVisitStack* visit_stack()        { return _visit_stack; }\n@@ -1486,2 +1826,2 @@\n-  static inline bool check_for_visit(oop obj) {\n-    if (!_bitset->is_marked(obj)) visit_stack()->push(obj);\n+  static inline bool check_for_visit(const JvmtiHeapwalkObject&obj) {\n+    visit_stack()->check_for_visit(obj);\n@@ -1491,0 +1831,10 @@\n+  \/\/ return element count if the obj is array, -1 otherwise\n+  static jint get_array_length(const JvmtiHeapwalkObject& obj) {\n+    if (!obj.klass()->is_array_klass()) {\n+      return -1;\n+    }\n+    assert(!obj.is_flat(), \"array cannot be flat\");\n+    return (jint)arrayOop(obj.obj())->length();\n+  }\n+\n+\n@@ -1493,1 +1843,1 @@\n-    (jvmtiHeapRootKind root_kind, oop obj);\n+    (jvmtiHeapRootKind root_kind, const JvmtiHeapwalkObject& obj);\n@@ -1496,1 +1846,1 @@\n-     int slot, oop obj);\n+     int slot, const JvmtiHeapwalkObject& obj);\n@@ -1498,1 +1848,1 @@\n-    (jvmtiObjectReferenceKind ref_kind, oop referrer, oop referree, jint index);\n+    (jvmtiObjectReferenceKind ref_kind, const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n@@ -1502,1 +1852,1 @@\n-    (jvmtiHeapReferenceKind ref_kind, oop obj);\n+    (jvmtiHeapReferenceKind ref_kind, const JvmtiHeapwalkObject& obj);\n@@ -1505,1 +1855,1 @@\n-     jmethodID method, jlocation bci, jint slot, oop obj);\n+     jmethodID method, jlocation bci, jint slot, const JvmtiHeapwalkObject& obj);\n@@ -1507,1 +1857,1 @@\n-    (jvmtiHeapReferenceKind ref_kind, oop referrer, oop referree, jint index);\n+    (jvmtiHeapReferenceKind ref_kind, const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n@@ -1511,1 +1861,1 @@\n-    (jvmtiHeapReferenceKind ref_kind, oop obj, jint index, address addr, char type);\n+    (jvmtiHeapReferenceKind ref_kind, const JvmtiHeapwalkObject& obj, jint index, address addr, char type);\n@@ -1516,1 +1866,0 @@\n-                                             GrowableArray<oop>* visit_stack,\n@@ -1519,1 +1868,1 @@\n-                                             JVMTIBitSet* bitset);\n+                                             JvmtiHeapwalkVisitStack* visit_stack);\n@@ -1523,1 +1872,0 @@\n-                                                GrowableArray<oop>* visit_stack,\n@@ -1526,1 +1874,1 @@\n-                                                JVMTIBitSet* bitset);\n+                                                JvmtiHeapwalkVisitStack* visit_stack);\n@@ -1529,1 +1877,1 @@\n-  static inline bool report_simple_root(jvmtiHeapReferenceKind kind, oop o);\n+  static inline bool report_simple_root(jvmtiHeapReferenceKind kind, const JvmtiHeapwalkObject& o);\n@@ -1531,1 +1879,1 @@\n-    jmethodID m, oop o);\n+    jmethodID m, const JvmtiHeapwalkObject& o);\n@@ -1533,1 +1881,1 @@\n-    jmethodID method, jlocation bci, jint slot, oop o);\n+    jmethodID method, jlocation bci, jint slot, const JvmtiHeapwalkObject& o);\n@@ -1536,14 +1884,14 @@\n-  static inline bool report_array_element_reference(oop referrer, oop referree, jint index);\n-  static inline bool report_class_reference(oop referrer, oop referree);\n-  static inline bool report_class_loader_reference(oop referrer, oop referree);\n-  static inline bool report_signers_reference(oop referrer, oop referree);\n-  static inline bool report_protection_domain_reference(oop referrer, oop referree);\n-  static inline bool report_superclass_reference(oop referrer, oop referree);\n-  static inline bool report_interface_reference(oop referrer, oop referree);\n-  static inline bool report_static_field_reference(oop referrer, oop referree, jint slot);\n-  static inline bool report_field_reference(oop referrer, oop referree, jint slot);\n-  static inline bool report_constant_pool_reference(oop referrer, oop referree, jint index);\n-  static inline bool report_primitive_array_values(oop array);\n-  static inline bool report_string_value(oop str);\n-  static inline bool report_primitive_instance_field(oop o, jint index, address value, char type);\n-  static inline bool report_primitive_static_field(oop o, jint index, address value, char type);\n+  static inline bool report_array_element_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n+  static inline bool report_class_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_class_loader_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_signers_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_protection_domain_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_superclass_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_interface_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree);\n+  static inline bool report_static_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot);\n+  static inline bool report_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot);\n+  static inline bool report_constant_pool_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index);\n+  static inline bool report_primitive_array_values(const JvmtiHeapwalkObject& array);\n+  static inline bool report_string_value(const JvmtiHeapwalkObject& str);\n+  static inline bool report_primitive_instance_field(const JvmtiHeapwalkObject& o, jint index, address value, char type);\n+  static inline bool report_primitive_static_field(const JvmtiHeapwalkObject& o, jint index, address value, char type);\n@@ -1558,2 +1906,1 @@\n-GrowableArray<oop>* CallbackInvoker::_visit_stack;\n-JVMTIBitSet* CallbackInvoker::_bitset;\n+JvmtiHeapwalkVisitStack* CallbackInvoker::_visit_stack;\n@@ -1563,1 +1910,0 @@\n-                                                     GrowableArray<oop>* visit_stack,\n@@ -1566,1 +1912,1 @@\n-                                                     JVMTIBitSet* bitset) {\n+                                                     JvmtiHeapwalkVisitStack* visit_stack) {\n@@ -1568,1 +1914,0 @@\n-  _visit_stack = visit_stack;\n@@ -1573,1 +1918,1 @@\n-  _bitset = bitset;\n+  _visit_stack = visit_stack;\n@@ -1578,1 +1923,0 @@\n-                                                        GrowableArray<oop>* visit_stack,\n@@ -1581,1 +1925,1 @@\n-                                                        JVMTIBitSet* bitset) {\n+                                                        JvmtiHeapwalkVisitStack* visit_stack) {\n@@ -1583,1 +1927,0 @@\n-  _visit_stack = visit_stack;\n@@ -1588,1 +1931,1 @@\n-  _bitset = bitset;\n+  _visit_stack = visit_stack;\n@@ -1593,1 +1936,1 @@\n-inline bool CallbackInvoker::invoke_basic_heap_root_callback(jvmtiHeapRootKind root_kind, oop obj) {\n+inline bool CallbackInvoker::invoke_basic_heap_root_callback(jvmtiHeapRootKind root_kind, const JvmtiHeapwalkObject& obj) {\n@@ -1620,1 +1963,1 @@\n-                                                             oop obj) {\n+                                                             const JvmtiHeapwalkObject& obj) {\n@@ -1647,2 +1990,2 @@\n-                                                                    oop referrer,\n-                                                                    oop referree,\n+                                                                    const JvmtiHeapwalkObject& referrer,\n+                                                                    const JvmtiHeapwalkObject& referree,\n@@ -1659,1 +2002,1 @@\n-    referrer_tag = tag_for(tag_map(), referrer);\n+    referrer_tag = tag_map()->find(referrer);\n@@ -1691,1 +2034,1 @@\n-                                                                oop obj) {\n+                                                                const JvmtiHeapwalkObject& obj) {\n@@ -1716,1 +2059,1 @@\n-  jint len = (jint)(obj->is_array() ? arrayOop(obj)->length() : -1);\n+  jint len = get_array_length(obj);\n@@ -1745,1 +2088,1 @@\n-                                                                oop obj) {\n+                                                                const JvmtiHeapwalkObject& obj) {\n@@ -1779,1 +2122,1 @@\n-  jint len = (jint)(obj->is_array() ? arrayOop(obj)->length() : -1);\n+  jint len = get_array_length(obj);\n@@ -1812,2 +2155,2 @@\n-                                                                       oop referrer,\n-                                                                       oop obj,\n+                                                                       const JvmtiHeapwalkObject& referrer,\n+                                                                       const JvmtiHeapwalkObject& obj,\n@@ -1846,1 +2189,1 @@\n-  jint len = (jint)(obj->is_array() ? arrayOop(obj)->length() : -1);\n+  jint len = get_array_length(obj);\n@@ -1869,1 +2212,1 @@\n-inline bool CallbackInvoker::report_simple_root(jvmtiHeapReferenceKind kind, oop obj) {\n+inline bool CallbackInvoker::report_simple_root(jvmtiHeapReferenceKind kind, const JvmtiHeapwalkObject& obj) {\n@@ -1885,2 +2228,2 @@\n-inline bool CallbackInvoker::report_primitive_array_values(oop obj) {\n-  assert(obj->is_typeArray(), \"not a primitive array\");\n+inline bool CallbackInvoker::report_primitive_array_values(const JvmtiHeapwalkObject& obj) {\n+  assert(obj.klass()->is_typeArray_klass(), \"not a primitive array\");\n@@ -1914,2 +2257,2 @@\n-inline bool CallbackInvoker::report_string_value(oop str) {\n-  assert(str->klass() == vmClasses::String_klass(), \"not a string\");\n+inline bool CallbackInvoker::report_string_value(const JvmtiHeapwalkObject& str) {\n+  assert(str.klass() == vmClasses::String_klass(), \"not a string\");\n@@ -1944,1 +2287,1 @@\n-                                                    oop obj,\n+                                                    const JvmtiHeapwalkObject& obj,\n@@ -1992,1 +2335,1 @@\n-inline bool CallbackInvoker::report_primitive_instance_field(oop obj,\n+inline bool CallbackInvoker::report_primitive_instance_field(const JvmtiHeapwalkObject& obj,\n@@ -2004,1 +2347,1 @@\n-inline bool CallbackInvoker::report_primitive_static_field(oop obj,\n+inline bool CallbackInvoker::report_primitive_static_field(const JvmtiHeapwalkObject& obj,\n@@ -2016,1 +2359,1 @@\n-inline bool CallbackInvoker::report_jni_local_root(jlong thread_tag, jlong tid, jint depth, jmethodID m, oop obj) {\n+inline bool CallbackInvoker::report_jni_local_root(jlong thread_tag, jlong tid, jint depth, jmethodID m, const JvmtiHeapwalkObject& obj) {\n@@ -2043,1 +2386,1 @@\n-                                                   oop obj) {\n+                                                   const JvmtiHeapwalkObject& obj) {\n@@ -2064,1 +2407,1 @@\n-inline bool CallbackInvoker::report_class_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_class_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2073,1 +2416,1 @@\n-inline bool CallbackInvoker::report_class_loader_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_class_loader_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2082,1 +2425,1 @@\n-inline bool CallbackInvoker::report_signers_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_signers_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2091,1 +2434,1 @@\n-inline bool CallbackInvoker::report_protection_domain_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_protection_domain_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2100,1 +2443,1 @@\n-inline bool CallbackInvoker::report_superclass_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_superclass_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2110,1 +2453,1 @@\n-inline bool CallbackInvoker::report_interface_reference(oop referrer, oop referree) {\n+inline bool CallbackInvoker::report_interface_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree) {\n@@ -2119,1 +2462,1 @@\n-inline bool CallbackInvoker::report_static_field_reference(oop referrer, oop referree, jint slot) {\n+inline bool CallbackInvoker::report_static_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot) {\n@@ -2128,1 +2471,1 @@\n-inline bool CallbackInvoker::report_array_element_reference(oop referrer, oop referree, jint index) {\n+inline bool CallbackInvoker::report_array_element_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index) {\n@@ -2137,1 +2480,1 @@\n-inline bool CallbackInvoker::report_field_reference(oop referrer, oop referree, jint slot) {\n+inline bool CallbackInvoker::report_field_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint slot) {\n@@ -2146,1 +2489,1 @@\n-inline bool CallbackInvoker::report_constant_pool_reference(oop referrer, oop referree, jint index) {\n+inline bool CallbackInvoker::report_constant_pool_reference(const JvmtiHeapwalkObject& referrer, const JvmtiHeapwalkObject& referree, jint index) {\n@@ -2273,1 +2616,1 @@\n-  _thread_tag = tag_for(_tag_map, _threadObj);\n+  _thread_tag = _tag_map->find(_threadObj);\n@@ -2406,4 +2749,0 @@\n-  enum {\n-    initial_visit_stack_size = 4000\n-  };\n-\n@@ -2413,3 +2752,1 @@\n-  GrowableArray<oop>* _visit_stack;                 \/\/ the visit stack\n-\n-  JVMTIBitSet _bitset;\n+  JvmtiHeapwalkVisitStack _visit_stack;\n@@ -2426,4 +2763,0 @@\n-  GrowableArray<oop>* create_visit_stack() {\n-    return new (mtServiceability) GrowableArray<oop>(initial_visit_stack_size, mtServiceability);\n-  }\n-\n@@ -2441,1 +2774,1 @@\n-  GrowableArray<oop>* visit_stack() const          { return _visit_stack; }\n+  JvmtiHeapwalkVisitStack* visit_stack()           { return &_visit_stack; }\n@@ -2444,4 +2777,5 @@\n-  inline bool iterate_over_array(oop o);\n-  inline bool iterate_over_type_array(oop o);\n-  inline bool iterate_over_class(oop o);\n-  inline bool iterate_over_object(oop o);\n+  inline bool iterate_over_array(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_flat_array(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_type_array(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_class(const JvmtiHeapwalkObject& o);\n+  inline bool iterate_over_object(const JvmtiHeapwalkObject& o);\n@@ -2456,1 +2790,1 @@\n-  inline bool visit(oop o);\n+  inline bool visit(const JvmtiHeapwalkObject& o);\n@@ -2490,3 +2824,1 @@\n-  _visit_stack = create_visit_stack();\n-\n-  CallbackInvoker::initialize_for_basic_heap_walk(tag_map, _visit_stack, user_data, callbacks, &_bitset);\n+  CallbackInvoker::initialize_for_basic_heap_walk(tag_map, user_data, callbacks, &_visit_stack);\n@@ -2508,2 +2840,1 @@\n-  _visit_stack = create_visit_stack();\n-  CallbackInvoker::initialize_for_advanced_heap_walk(tag_map, _visit_stack, user_data, callbacks, &_bitset);\n+  CallbackInvoker::initialize_for_advanced_heap_walk(tag_map, user_data, callbacks, &_visit_stack);\n@@ -2514,5 +2845,0 @@\n-  if (_following_object_refs) {\n-    assert(_visit_stack != nullptr, \"checking\");\n-    delete _visit_stack;\n-    _visit_stack = nullptr;\n-  }\n@@ -2523,2 +2849,3 @@\n-inline bool VM_HeapWalkOperation::iterate_over_array(oop o) {\n-  objArrayOop array = objArrayOop(o);\n+inline bool VM_HeapWalkOperation::iterate_over_array(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Array object cannot be flattened\");\n+  objArrayOop array = objArrayOop(o.obj());\n@@ -2548,0 +2875,38 @@\n+\/\/ similar to iterate_over_array(), but itrates over flat array\n+inline bool VM_HeapWalkOperation::iterate_over_flat_array(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Array object cannot be flattened\");\n+  flatArrayOop array = flatArrayOop(o.obj());\n+  FlatArrayKlass* faklass = FlatArrayKlass::cast(array->klass());\n+  InlineKlass* vk = InlineKlass::cast(faklass->element_klass());\n+  bool need_null_check = faklass->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+\n+  \/\/ array reference to its class\n+  oop mirror = faklass->java_mirror();\n+  if (!CallbackInvoker::report_class_reference(o, mirror)) {\n+    return false;\n+  }\n+\n+  \/\/ iterate over the array and report each reference to a\n+  \/\/ non-null element\n+  for (int index = 0; index < array->length(); index++) {\n+    address addr = (address)array->value_at_addr(index, faklass->layout_helper());\n+\n+    \/\/ check for null\n+    if (need_null_check) {\n+      if (vk->is_payload_marked_as_null(addr)) {\n+        continue;\n+      }\n+    }\n+\n+    \/\/ offset in the array oop\n+    int offset = (int)(addr - cast_from_oop<address>(array));\n+    JvmtiHeapwalkObject elem(o.obj(), offset, vk, faklass->layout_kind());\n+\n+    \/\/ report the array reference\n+    if (!CallbackInvoker::report_array_element_reference(o, elem, index)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2549,2 +2914,3 @@\n-inline bool VM_HeapWalkOperation::iterate_over_type_array(oop o) {\n-  Klass* k = o->klass();\n+inline bool VM_HeapWalkOperation::iterate_over_type_array(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Array object cannot be flattened\");\n+  Klass* k = o.klass();\n@@ -2584,1 +2950,3 @@\n-inline bool VM_HeapWalkOperation::iterate_over_class(oop java_class) {\n+inline bool VM_HeapWalkOperation::iterate_over_class(const JvmtiHeapwalkObject& o) {\n+  assert(!o.is_flat(), \"Klass object cannot be flattened\");\n+  Klass* klass = java_lang_Class::as_Klass(o.obj());\n@@ -2586,1 +2954,0 @@\n-  Klass* klass = java_lang_Class::as_Klass(java_class);\n@@ -2597,1 +2964,2 @@\n-    oop mirror = klass->java_mirror();\n+    oop mirror_oop = klass->java_mirror();\n+    JvmtiHeapwalkObject mirror(mirror_oop);\n@@ -2686,2 +3054,2 @@\n-        oop fld_o = mirror->obj_field(field->field_offset());\n-        assert(verify_static_oop(ik, mirror, field->field_offset()), \"sanity check\");\n+        oop fld_o = mirror_oop->obj_field(field->field_offset());\n+        assert(verify_static_oop(ik, mirror_oop, field->field_offset()), \"sanity check\");\n@@ -2697,1 +3065,1 @@\n-           address addr = cast_from_oop<address>(mirror) + field->field_offset();\n+           address addr = cast_from_oop<address>(mirror_oop) + field->field_offset();\n@@ -2717,1 +3085,1 @@\n-inline bool VM_HeapWalkOperation::iterate_over_object(oop o) {\n+inline bool VM_HeapWalkOperation::iterate_over_object(const JvmtiHeapwalkObject& o) {\n@@ -2719,1 +3087,1 @@\n-  if (!CallbackInvoker::report_class_reference(o, o->klass()->java_mirror())) {\n+  if (!CallbackInvoker::report_class_reference(o, o.klass()->java_mirror())) {\n@@ -2724,1 +3092,1 @@\n-  ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o);\n+  ClassFieldMap* field_map = JvmtiCachedClassFieldMap::get_map_of_instance_fields(o.klass());\n@@ -2728,0 +3096,6 @@\n+    int slot = field->field_index();\n+    int field_offset = field->field_offset();\n+    if (o.is_flat()) {\n+      \/\/ the object is inlined, its fields are stored without the header\n+      field_offset += o.offset() - o.inline_klass()->payload_offset();\n+    }\n@@ -2729,7 +3103,11 @@\n-      oop fld_o = o->obj_field_access<AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF>(field->field_offset());\n-      \/\/ ignore any objects that aren't visible to profiler\n-      if (fld_o != nullptr) {\n-        assert(Universe::heap()->is_in(fld_o), \"unsafe code should not \"\n-               \"have references to Klass* anymore\");\n-        int slot = field->field_index();\n-        if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {\n+      if (field->is_flat()) {\n+        \/\/ check for possible nulls\n+        bool can_be_null = field->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+        if (can_be_null) {\n+          address payload = cast_from_oop<address>(o.obj()) + field_offset;\n+          if (field->inline_klass()->is_payload_marked_as_null(payload)) {\n+            continue;\n+          }\n+        }\n+        JvmtiHeapwalkObject field_obj(o.obj(), field_offset, field->inline_klass(), field->layout_kind());\n+        if (!CallbackInvoker::report_field_reference(o, field_obj, slot)) {\n@@ -2738,0 +3116,9 @@\n+      } else {\n+        oop fld_o = o.obj()->obj_field_access<AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF>(field_offset);\n+        \/\/ ignore any objects that aren't visible to profiler\n+        if (fld_o != nullptr) {\n+          assert(Universe::heap()->is_in(fld_o), \"unsafe code should not have references to Klass* anymore\");\n+          if (!CallbackInvoker::report_field_reference(o, fld_o, slot)) {\n+            return false;\n+          }\n+        }\n@@ -2742,2 +3129,1 @@\n-        address addr = cast_from_oop<address>(o) + field->field_offset();\n-        int slot = field->field_index();\n+        address addr = cast_from_oop<address>(o.obj()) + field_offset;\n@@ -2753,1 +3139,1 @@\n-      o->klass() == vmClasses::String_klass()) {\n+      o.klass() == vmClasses::String_klass()) {\n@@ -2822,1 +3208,1 @@\n-    blk->set_context(tag_for(_tag_map, threadObj), java_lang_Thread::thread_id(threadObj), 0, (jmethodID)nullptr);\n+    blk->set_context(_tag_map->find(threadObj), java_lang_Thread::thread_id(threadObj), 0, (jmethodID)nullptr);\n@@ -2922,1 +3308,1 @@\n-bool VM_HeapWalkOperation::visit(oop o) {\n+bool VM_HeapWalkOperation::visit(const JvmtiHeapwalkObject& o) {\n@@ -2924,2 +3310,2 @@\n-  assert(!_bitset.is_marked(o), \"can't visit same object more than once\");\n-  _bitset.mark_obj(o);\n+  assert(!visit_stack()->is_visited(o), \"can't visit same object more than once\");\n+  visit_stack()->mark_visited(o);\n@@ -2927,0 +3313,1 @@\n+  Klass* klass = o.klass();\n@@ -2928,3 +3315,4 @@\n-  if (o->is_instance()) {\n-    if (o->klass() == vmClasses::Class_klass()) {\n-      if (!java_lang_Class::is_primitive(o)) {\n+  if (klass->is_instance_klass()) {\n+    if (klass == vmClasses::Class_klass()) {\n+      assert(!o.is_flat(), \"Class object cannot be flattened\");\n+      if (!java_lang_Class::is_primitive(o.obj())) {\n@@ -2937,2 +3325,3 @@\n-      if (initial_object().is_null() && java_lang_VirtualThread::is_subclass(o->klass())) {\n-        if (!collect_vthread_stack_refs(o)) {\n+      if (initial_object().is_null() && java_lang_VirtualThread::is_subclass(klass)) {\n+        assert(!o.is_flat(), \"VirtualThread object cannot be flattened\");\n+        if (!collect_vthread_stack_refs(o.obj())) {\n@@ -2946,0 +3335,5 @@\n+  \/\/ flat object array\n+  if (klass->is_flatArray_klass()) {\n+      return iterate_over_flat_array(o);\n+  }\n+\n@@ -2947,1 +3341,1 @@\n-  if (o->is_objArray()) {\n+  if (klass->is_objArray_klass()) {\n@@ -2952,1 +3346,1 @@\n-  if (o->is_typeArray()) {\n+  if (klass->is_typeArray_klass()) {\n@@ -2984,2 +3378,2 @@\n-      oop o = visit_stack()->pop();\n-      if (!_bitset.is_marked(o)) {\n+      const JvmtiHeapwalkObject o = visit_stack()->pop();\n+      if (!visit_stack()->is_visited(o)) {\n@@ -3014,0 +3408,2 @@\n+  convert_flat_object_entries();\n+\n@@ -3036,0 +3432,2 @@\n+  convert_flat_object_entries();\n+\n@@ -3068,0 +3466,2 @@\n+  convert_flat_object_entries();\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":643,"deletions":243,"binary":false,"changes":886,"status":"modified"},{"patch":"@@ -132,13 +132,16 @@\n-  IS_METHOD            = java_lang_invoke_MemberName::MN_IS_METHOD,\n-  IS_CONSTRUCTOR       = java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR,\n-  IS_FIELD             = java_lang_invoke_MemberName::MN_IS_FIELD,\n-  IS_TYPE              = java_lang_invoke_MemberName::MN_IS_TYPE,\n-  CALLER_SENSITIVE     = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,\n-  TRUSTED_FINAL        = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,\n-  HIDDEN_MEMBER        = java_lang_invoke_MemberName::MN_HIDDEN_MEMBER,\n-  REFERENCE_KIND_SHIFT = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,\n-  REFERENCE_KIND_MASK  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,\n-  LM_UNCONDITIONAL     = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n-  LM_MODULE            = java_lang_invoke_MemberName::MN_MODULE_MODE,\n-  LM_TRUSTED           = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n-  ALL_KINDS      = IS_METHOD | IS_CONSTRUCTOR | IS_FIELD | IS_TYPE\n+  IS_METHOD             = java_lang_invoke_MemberName::MN_IS_METHOD,\n+  IS_OBJECT_CONSTRUCTOR = java_lang_invoke_MemberName::MN_IS_OBJECT_CONSTRUCTOR,\n+  IS_FIELD              = java_lang_invoke_MemberName::MN_IS_FIELD,\n+  IS_TYPE               = java_lang_invoke_MemberName::MN_IS_TYPE,\n+  CALLER_SENSITIVE      = java_lang_invoke_MemberName::MN_CALLER_SENSITIVE,\n+  TRUSTED_FINAL         = java_lang_invoke_MemberName::MN_TRUSTED_FINAL,\n+  HIDDEN_MEMBER         = java_lang_invoke_MemberName::MN_HIDDEN_MEMBER,\n+  NULL_RESTRICTED       = java_lang_invoke_MemberName::MN_NULL_RESTRICTED_FIELD,\n+  REFERENCE_KIND_SHIFT  = java_lang_invoke_MemberName::MN_REFERENCE_KIND_SHIFT,\n+  REFERENCE_KIND_MASK   = java_lang_invoke_MemberName::MN_REFERENCE_KIND_MASK,\n+  LAYOUT_SHIFT          = java_lang_invoke_MemberName::MN_LAYOUT_SHIFT,\n+  LAYOUT_MASK           = java_lang_invoke_MemberName::MN_LAYOUT_MASK,\n+  LM_UNCONDITIONAL      = java_lang_invoke_MemberName::MN_UNCONDITIONAL_MODE,\n+  LM_MODULE             = java_lang_invoke_MemberName::MN_MODULE_MODE,\n+  LM_TRUSTED            = java_lang_invoke_MemberName::MN_TRUSTED_MODE,\n+  ALL_KINDS      = IS_METHOD | IS_OBJECT_CONSTRUCTOR | IS_FIELD | IS_TYPE\n@@ -155,1 +158,1 @@\n-    flags |= IS_CONSTRUCTOR;\n+    flags |= IS_OBJECT_CONSTRUCTOR;\n@@ -174,1 +177,1 @@\n-    case IS_CONSTRUCTOR:\n+    case IS_OBJECT_CONSTRUCTOR:\n@@ -315,1 +318,1 @@\n-      assert(!m->is_static_initializer(), \"Cannot be static initializer\");\n+      assert(!m->is_class_initializer(), \"Cannot be static initializer\");\n@@ -317,2 +320,2 @@\n-    } else if (m->is_object_initializer()) {\n-      flags |= IS_CONSTRUCTOR | (JVM_REF_invokeSpecial << REFERENCE_KIND_SHIFT);\n+    } else if (m->is_object_constructor()) {\n+      flags |= IS_OBJECT_CONSTRUCTOR | (JVM_REF_invokeSpecial << REFERENCE_KIND_SHIFT);\n@@ -357,0 +360,6 @@\n+  if (fd.is_flat()) {\n+    int layout_kind = (int)fd.layout_kind();\n+    assert((layout_kind & LAYOUT_MASK) == layout_kind, \"Layout information loss\");\n+    flags |= layout_kind << LAYOUT_SHIFT;\n+  }\n+  if (fd.is_null_free_inline_type()) flags |= NULL_RESTRICTED;\n@@ -807,1 +816,1 @@\n-  case IS_CONSTRUCTOR:\n+  case IS_OBJECT_CONSTRUCTOR:\n@@ -813,1 +822,1 @@\n-        if (name == vmSymbols::object_initializer_name()) {\n+        if (name == vmSymbols::object_initializer_name() && type->is_void_method_signature()) {\n@@ -876,1 +885,1 @@\n-  case IS_CONSTRUCTOR:\n+  case IS_OBJECT_CONSTRUCTOR:\n@@ -989,1 +998,1 @@\n-    template(java_lang_invoke_MemberName,MN_IS_CONSTRUCTOR) \\\n+    template(java_lang_invoke_MemberName,MN_IS_OBJECT_CONSTRUCTOR) \\\n@@ -997,0 +1006,2 @@\n+    template(java_lang_invoke_MemberName,MN_LAYOUT_SHIFT) \\\n+    template(java_lang_invoke_MemberName,MN_LAYOUT_MASK) \\\n@@ -1132,1 +1143,1 @@\n-               (flags & ALL_KINDS) == IS_CONSTRUCTOR) {\n+               (flags & ALL_KINDS) == IS_OBJECT_CONSTRUCTOR) {\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -38,0 +41,3 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -45,0 +51,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -171,1 +178,0 @@\n-\n@@ -250,0 +256,1 @@\n+    assert(_obj == nullptr || !_obj->is_inline_type() || _obj->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n@@ -253,1 +260,0 @@\n-\n@@ -266,0 +272,62 @@\n+#ifdef ASSERT\n+\/*\n+ * Get the field descriptor of the field of the given object at the given offset.\n+ *\/\n+static bool get_field_descriptor(oop p, jlong offset, fieldDescriptor* fd) {\n+  bool found = false;\n+  Klass* k = p->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    found = ik->find_field_from_offset((int)offset, false, fd);\n+    if (!found && ik->is_mirror_instance_klass()) {\n+      Klass* k2 = java_lang_Class::as_Klass(p);\n+      if (k2->is_instance_klass()) {\n+        ik = InstanceKlass::cast(k2);\n+        found = ik->find_field_from_offset((int)offset, true, fd);\n+      }\n+    }\n+  }\n+  return found;\n+}\n+#endif \/\/ ASSERT\n+\n+static void assert_and_log_unsafe_value_access(oop p, jlong offset, InlineKlass* vk) {\n+  Klass* k = p->klass();\n+#ifdef ASSERT\n+  if (k->is_instance_klass()) {\n+    assert_field_offset_sane(p, offset);\n+    fieldDescriptor fd;\n+    bool found = get_field_descriptor(p, offset, &fd);\n+    if (found) {\n+      assert(found, \"value field not found\");\n+      assert(fd.is_flat(), \"field not flat\");\n+    } else {\n+      if (log_is_enabled(Trace, valuetypes)) {\n+        log_trace(valuetypes)(\"not a field in %s at offset \" UINT64_FORMAT_X,\n+                              p->klass()->external_name(), (uint64_t)offset);\n+      }\n+    }\n+  } else if (k->is_flatArray_klass()) {\n+    FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+    int index = (offset - vak->array_header_in_bytes()) \/ vak->element_byte_size();\n+    address dest = (address)((flatArrayOop)p)->value_at_addr(index, vak->layout_helper());\n+    assert(dest == (cast_from_oop<address>(p) + offset), \"invalid offset\");\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+#endif \/\/ ASSERT\n+  if (log_is_enabled(Trace, valuetypes)) {\n+    if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      int index = (offset - vak->array_header_in_bytes()) \/ vak->element_byte_size();\n+      address dest = (address)((flatArrayOop)p)->value_at_addr(index, vak->layout_helper());\n+      log_trace(valuetypes)(\"%s array type %s index %d element size %d offset \" UINT64_FORMAT_X \" at \" INTPTR_FORMAT,\n+                            p->klass()->external_name(), vak->external_name(),\n+                            index, vak->element_byte_size(), (uint64_t)offset, p2i(dest));\n+    } else {\n+      log_trace(valuetypes)(\"%s field type %s at offset \" UINT64_FORMAT_X,\n+                            p->klass()->external_name(), vk->external_name(), (uint64_t)offset);\n+    }\n+  }\n+}\n+\n@@ -280,0 +348,1 @@\n+  assert(!p->is_inline_type() || p->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n@@ -283,0 +352,196 @@\n+UNSAFE_ENTRY(jlong, Unsafe_ValueHeaderSize(JNIEnv *env, jobject unsafe, jclass c)) {\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  return vk->payload_offset();\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jboolean, Unsafe_IsFlatField(JNIEnv *env, jobject unsafe, jobject o)) {\n+  oop f = JNIHandles::resolve_non_null(o);\n+  Klass* k = java_lang_Class::as_Klass(java_lang_reflect_Field::clazz(f));\n+  int slot = java_lang_reflect_Field::slot(f);\n+  return InstanceKlass::cast(k)->field_is_flat(slot);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jboolean, Unsafe_HasNullMarker(JNIEnv *env, jobject unsafe, jobject o)) {\n+  oop f = JNIHandles::resolve_non_null(o);\n+  Klass* k = java_lang_Class::as_Klass(java_lang_reflect_Field::clazz(f));\n+  int slot = java_lang_reflect_Field::slot(f);\n+  return InstanceKlass::cast(k)->field_has_null_marker(slot);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jint, Unsafe_NullMarkerOffset(JNIEnv *env, jobject unsafe, jobject o)) {\n+  oop f = JNIHandles::resolve_non_null(o);\n+  Klass* k = java_lang_Class::as_Klass(java_lang_reflect_Field::clazz(f));\n+  int slot = java_lang_reflect_Field::slot(f);\n+  return InstanceKlass::cast(k)->null_marker_offset(slot);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jint, Unsafe_ArrayLayout(JNIEnv *env, jobject unsafe, jarray array)) {\n+  oop ar = JNIHandles::resolve_non_null(array);\n+  ArrayKlass* ak = ArrayKlass::cast(ar->klass());\n+  if (ak->is_refArray_klass()) {\n+    return (jint)LayoutKind::REFERENCE;\n+  } else if (ak->is_flatArray_klass()) {\n+    return (jint)FlatArrayKlass::cast(ak)->layout_kind();\n+  } else {\n+    ShouldNotReachHere();\n+    return -1;\n+  }\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jint, Unsafe_FieldLayout(JNIEnv *env, jobject unsafe, jobject field)) {\n+  assert(field != nullptr, \"field must not be null\");\n+\n+  oop reflected   = JNIHandles::resolve_non_null(field);\n+  oop mirror      = java_lang_reflect_Field::clazz(reflected);\n+  Klass* k        = java_lang_Class::as_Klass(mirror);\n+  int slot        = java_lang_reflect_Field::slot(reflected);\n+  int modifiers   = java_lang_reflect_Field::modifiers(reflected);\n+\n+  if ((modifiers & JVM_ACC_STATIC) != 0) {\n+    return (jint)LayoutKind::REFERENCE; \/\/ static fields are never flat\n+  } else {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->field_is_flat(slot)) {\n+      return (jint)ik->inline_layout_info(slot).kind();\n+    } else {\n+      return (jint)LayoutKind::REFERENCE;\n+    }\n+  }\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jarray, Unsafe_NewSpecialArray(JNIEnv *env, jobject unsafe, jclass elmClass, jint len, jint layoutKind)) {\n+  oop mirror = JNIHandles::resolve_non_null(elmClass);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  klass->initialize(CHECK_NULL);\n+  if (len < 0) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Array length is negative\");\n+  }\n+  if (klass->is_array_klass() || klass->is_identity_class()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is not a value class\");\n+  }\n+  if (klass->is_abstract()) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Element class is abstract\");\n+  }\n+  LayoutKind lk = static_cast<LayoutKind>(layoutKind);\n+  if (lk <= LayoutKind::REFERENCE || lk >= LayoutKind::UNKNOWN) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), \"Invalid layout kind\");\n+  }\n+  InlineKlass* vk = InlineKlass::cast(klass);\n+  \/\/ WARNING: test below will need modifications when flat layouts supported for fields\n+  \/\/ but not for arrays are introduce (NULLABLE_NON_ATOMIC_FLAT for instance)\n+  if (!UseArrayFlattening || !vk->is_layout_supported(lk)) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), \"Layout not supported\");\n+  }\n+  ArrayKlass::ArrayProperties props = ArrayKlass::ArrayProperties::DEFAULT;\n+  switch(lk) {\n+    case LayoutKind::ATOMIC_FLAT:\n+      props = ArrayKlass::ArrayProperties::NULL_RESTRICTED;\n+    break;\n+    case LayoutKind::NON_ATOMIC_FLAT:\n+      props = (ArrayKlass::ArrayProperties)(ArrayKlass::ArrayProperties::NULL_RESTRICTED | ArrayKlass::ArrayProperties::NON_ATOMIC);\n+    break;\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n+    props = ArrayKlass::ArrayProperties::NON_ATOMIC;\n+    break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  oop array = oopFactory::new_flatArray(vk, len, props, lk, CHECK_NULL);\n+  return (jarray) JNIHandles::make_local(THREAD, array);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {\n+  oop base = JNIHandles::resolve(obj);\n+  if (base == nullptr) {\n+    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n+  }\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  LayoutKind lk = LayoutKind::UNKNOWN;\n+  if (base->is_array()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n+    lk = fak->layout_kind();\n+  } else {\n+    fieldDescriptor fd;\n+    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n+    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n+  }\n+  Handle base_h(THREAD, base);\n+  oop v = vk->read_payload_from_addr(base_h(), offset, lk, CHECK_NULL);\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_GetFlatValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint layoutKind, jclass vc)) {\n+  assert(layoutKind != (int)LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n+  oop base = JNIHandles::resolve(obj);\n+  if (base == nullptr) {\n+    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n+  }\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  LayoutKind lk = (LayoutKind)layoutKind;\n+  Handle base_h(THREAD, base);\n+  oop v = vk->read_payload_from_addr(base_h(), offset, lk, CHECK_NULL);\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {\n+  oop base = JNIHandles::resolve(obj);\n+  if (base == nullptr) {\n+    THROW(vmSymbols::java_lang_NullPointerException());\n+  }\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert(!base->is_inline_type() || base->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  LayoutKind lk = LayoutKind::UNKNOWN;\n+  if (base->is_array()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(base->klass());\n+    lk = fak->layout_kind();\n+  } else {\n+    fieldDescriptor fd;\n+    InstanceKlass::cast(base->klass())->find_field_from_offset(offset, false, &fd);\n+    lk = fd.field_holder()->inline_layout_info(fd.index()).kind();\n+  }\n+  oop v = JNIHandles::resolve(value);\n+  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, lk, true, CHECK);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(void, Unsafe_PutFlatValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint layoutKind, jclass vc, jobject value)) {\n+  assert(layoutKind != (int)LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n+  oop base = JNIHandles::resolve(obj);\n+  if (base == nullptr) {\n+    THROW(vmSymbols::java_lang_NullPointerException());\n+  }\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));\n+  InlineKlass* vk = InlineKlass::cast(k);\n+  assert(!base->is_inline_type() || base->mark().is_larval_state(), \"must be an object instance or a larval inline type\");\n+  assert_and_log_unsafe_value_access(base, offset, vk);\n+  LayoutKind lk = (LayoutKind)layoutKind;\n+  oop v = JNIHandles::resolve(value);\n+  vk->write_value_to_addr(v, ((char*)(oopDesc*)base) + offset, lk, true, CHECK);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n+  oop v = JNIHandles::resolve_non_null(value);\n+  assert(v->is_inline_type(), \"must be an inline type instance\");\n+  Handle vh(THREAD, v);\n+  InlineKlass* vk = InlineKlass::cast(v->klass());\n+  instanceOop new_value = vk->allocate_instance_buffer(CHECK_NULL);\n+  vk->copy_payload_to_addr(vk->payload_addr(vh()), vk->payload_addr(new_value), LayoutKind::BUFFERED, false);\n+  markWord mark = new_value->mark();\n+  new_value->set_mark(mark.enter_larval_state());\n+  return JNIHandles::make_local(THREAD, new_value);\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jobject, Unsafe_FinishPrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {\n+  oop v = JNIHandles::resolve(value);\n+  assert(v->mark().is_larval_state(), \"must be a larval value\");\n+  markWord mark = v->mark();\n+  v->set_mark(mark.exit_larval_state());\n+  return JNIHandles::make_local(THREAD, v);\n+} UNSAFE_END\n+\n@@ -593,0 +858,21 @@\n+UNSAFE_ENTRY(void, Unsafe_NotifyStrictStaticAccess0(JNIEnv *env, jobject unsafe, jobject clazz,\n+                                                    jlong sfoffset, jboolean writing)) {\n+  assert(clazz != nullptr, \"clazz must not be null\");\n+\n+  oop mirror = JNIHandles::resolve_non_null(clazz);\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+\n+  if (klass != nullptr && klass->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(klass);\n+    fieldDescriptor fd;\n+    if (ik->find_local_field_from_offset((int)sfoffset, true, &fd)) {\n+      \/\/ Note: The Unsafe API takes an OFFSET, but the InstanceKlass wants the INDEX.\n+      \/\/ We could surface field indexes into Unsafe, but that's too much churn.\n+      ik->notify_strict_static_access(fd.index(), writing, CHECK);\n+      return;\n+    }\n+  }\n+  THROW(vmSymbols::java_lang_InternalError());\n+}\n+UNSAFE_END\n+\n@@ -601,3 +887,0 @@\n-  } else if (k->is_objArray_klass()) {\n-    base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n-    scale = heapOopSize;\n@@ -609,0 +892,9 @@\n+  } else if (k->is_objArray_klass()) {\n+    Klass* ek = ObjArrayKlass::cast(k)->element_klass();\n+    if (!ek->is_identity_class() && !ek->is_abstract()) {\n+      \/\/ Arrays of a concrete value class type can have multiple layouts\n+      \/\/ There's no good value to return, so throwing an exception is the way out\n+      THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"Arrays of a concrete value class don't have a single base and offset\");\n+    }\n+    base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+    scale = heapOopSize;\n@@ -614,0 +906,15 @@\n+UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset1(JNIEnv *env, jobject unsafe, jarray array)) {\n+  assert(array != nullptr, \"array must not be null\");\n+  oop ar = JNIHandles::resolve_non_null(array);\n+  assert(ar->is_array(), \"Must be an array\");\n+  ArrayKlass* ak = ArrayKlass::cast(ar->klass());\n+  if (ak->is_refArray_klass()) {\n+    return arrayOopDesc::base_offset_in_bytes(T_OBJECT);\n+  } else if (ak->is_flatArray_klass()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(ak);\n+    return fak->array_header_in_bytes();\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+} UNSAFE_END\n+\n@@ -643,0 +950,20 @@\n+UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale1(JNIEnv *env, jobject unsafe, jarray array)) {\n+  assert(array != nullptr, \"array must not be null\");\n+  oop ar = JNIHandles::resolve_non_null(array);\n+  assert(ar->is_array(), \"Must be an array\");\n+  ArrayKlass* ak = ArrayKlass::cast(ar->klass());\n+  if (ak->is_refArray_klass()) {\n+    return heapOopSize;\n+  } else if (ak->is_flatArray_klass()) {\n+    FlatArrayKlass* fak = FlatArrayKlass::cast(ak);\n+    return fak->element_byte_size();\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+} UNSAFE_END\n+\n+UNSAFE_ENTRY(jlong, Unsafe_GetObjectSize0(JNIEnv* env, jobject o, jobject obj))\n+  oop p = JNIHandles::resolve(obj);\n+  return p->size() * HeapWordSize;\n+UNSAFE_END\n+\n@@ -856,0 +1183,2 @@\n+#define OBJ_ARR \"[\" OBJ\n+\n@@ -863,4 +1192,4 @@\n-    {CC \"get\" #Type,      CC \"(\" OBJ \"J)\" #Desc,       FN_PTR(Unsafe_Get##Type)}, \\\n-    {CC \"put\" #Type,      CC \"(\" OBJ \"J\" #Desc \")V\",   FN_PTR(Unsafe_Put##Type)}, \\\n-    {CC \"get\" #Type \"Volatile\",      CC \"(\" OBJ \"J)\" #Desc,       FN_PTR(Unsafe_Get##Type##Volatile)}, \\\n-    {CC \"put\" #Type \"Volatile\",      CC \"(\" OBJ \"J\" #Desc \")V\",   FN_PTR(Unsafe_Put##Type##Volatile)}\n+    {CC \"get\"  #Type,      CC \"(\" OBJ \"J)\" #Desc,                 FN_PTR(Unsafe_Get##Type)}, \\\n+    {CC \"put\"  #Type,      CC \"(\" OBJ \"J\" #Desc \")V\",             FN_PTR(Unsafe_Put##Type)}, \\\n+    {CC \"get\"  #Type \"Volatile\",      CC \"(\" OBJ \"J)\" #Desc,      FN_PTR(Unsafe_Get##Type##Volatile)}, \\\n+    {CC \"put\"  #Type \"Volatile\",      CC \"(\" OBJ \"J\" #Desc \")V\",  FN_PTR(Unsafe_Put##Type##Volatile)}\n@@ -875,0 +1204,14 @@\n+    {CC \"isFlatField0\",         CC \"(\" OBJ \")Z\",          FN_PTR(Unsafe_IsFlatField)},\n+    {CC \"hasNullMarker0\",       CC \"(\" OBJ \")Z\",          FN_PTR(Unsafe_HasNullMarker)},\n+    {CC \"nullMarkerOffset0\",    CC \"(\" OBJ \")I\",          FN_PTR(Unsafe_NullMarkerOffset)},\n+    {CC \"arrayLayout0\",         CC \"(\" OBJ_ARR \")I\",      FN_PTR(Unsafe_ArrayLayout)},\n+    {CC \"fieldLayout0\",         CC \"(\" OBJ \")I\",          FN_PTR(Unsafe_FieldLayout)},\n+    {CC \"newSpecialArray\",      CC \"(\" CLS \"II)[\" OBJ,    FN_PTR(Unsafe_NewSpecialArray)},\n+    {CC \"getValue\",             CC \"(\" OBJ \"J\" CLS \")\" OBJ, FN_PTR(Unsafe_GetValue)},\n+    {CC \"getFlatValue\",         CC \"(\" OBJ \"JI\" CLS \")\" OBJ, FN_PTR(Unsafe_GetFlatValue)},\n+    {CC \"putValue\",             CC \"(\" OBJ \"J\" CLS OBJ \")V\", FN_PTR(Unsafe_PutValue)},\n+    {CC \"putFlatValue\",         CC \"(\" OBJ \"JI\" CLS OBJ \")V\", FN_PTR(Unsafe_PutFlatValue)},\n+    {CC \"makePrivateBuffer\",     CC \"(\" OBJ \")\" OBJ,      FN_PTR(Unsafe_MakePrivateBuffer)},\n+    {CC \"finishPrivateBuffer\",   CC \"(\" OBJ \")\" OBJ,      FN_PTR(Unsafe_FinishPrivateBuffer)},\n+    {CC \"valueHeaderSize\",       CC \"(\" CLS \")J\",         FN_PTR(Unsafe_ValueHeaderSize)},\n+\n@@ -896,0 +1239,1 @@\n+    {CC \"arrayBaseOffset1\",   CC \"(\" OBJ_ARR \")I\",       FN_PTR(Unsafe_ArrayBaseOffset1)},\n@@ -897,0 +1241,2 @@\n+    {CC \"arrayIndexScale1\",   CC \"(\" OBJ_ARR \")I\",       FN_PTR(Unsafe_ArrayIndexScale1)},\n+    {CC \"getObjectSize0\",     CC \"(Ljava\/lang\/Object;)J\", FN_PTR(Unsafe_GetObjectSize0)},\n@@ -921,0 +1267,1 @@\n+    {CC \"notifyStrictStaticAccess0\", CC \"(\" CLS \"JZ)V\",  FN_PTR(Unsafe_NotifyStrictStaticAccess0)},\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":356,"deletions":9,"binary":false,"changes":365,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -61,0 +62,1 @@\n+#include \"oops\/access.hpp\"\n@@ -63,0 +65,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -88,0 +91,1 @@\n+#include \"runtime\/keepStackGCProcessed.hpp\"\n@@ -1948,0 +1952,103 @@\n+WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))\n+  oop aoop = JNIHandles::resolve(thing);\n+  if (!aoop->is_instance()) {\n+    return nullptr;\n+  }\n+  instanceHandle ih(THREAD, (instanceOop) aoop);\n+  InstanceKlass* klass = InstanceKlass::cast(ih->klass());\n+  if (klass->nonstatic_oop_map_count() == 0) {\n+    return nullptr;\n+  }\n+  const OopMapBlock* map = klass->start_of_nonstatic_oop_maps();\n+  const OopMapBlock* const end = map + klass->nonstatic_oop_map_count();\n+  int oop_count = 0;\n+  while (map < end) {\n+    oop_count += map->count();\n+    map++;\n+  }\n+\n+  objArrayHandle result_array =\n+      oopFactory::new_objArray_handle(vmClasses::Object_klass(), oop_count, CHECK_NULL);\n+  map = klass->start_of_nonstatic_oop_maps();\n+  int index = 0;\n+  while (map < end) {\n+    int offset = map->offset();\n+    for (unsigned int j = 0; j < map->count(); j++) {\n+      result_array->obj_at_put(index++, ih->obj_field(offset));\n+      offset += heapOopSize;\n+    }\n+    map++;\n+  }\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+WB_END\n+\n+\/\/ Collect Object oops but not value objects...loaded from heap\n+class CollectObjectOops : public BasicOopIterateClosure {\n+  public:\n+  GrowableArray<Handle>* _array;\n+\n+  CollectObjectOops() {\n+      _array = new GrowableArray<Handle>(128);\n+  }\n+\n+  void add_oop(oop o) {\n+    Handle oh = Handle(Thread::current(), o);\n+    if (oh != nullptr && oh->is_inline_type()) {\n+      oh->oop_iterate(this);\n+    } else {\n+      _array->append(oh);\n+    }\n+  }\n+\n+  template <class T> inline void add_oop(T* p) { add_oop(HeapAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    objArrayHandle result_array =\n+        oopFactory::new_objArray_handle(vmClasses::Object_klass(), _array->length(), CHECK_NULL);\n+    for (int i = 0 ; i < _array->length(); i++) {\n+      result_array->obj_at_put(i, _array->at(i)());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result_array());\n+  }\n+};\n+\n+\/\/ Collect Object oops but not value objects...loaded from frames\n+class CollectFrameObjectOops : public BasicOopIterateClosure {\n+ public:\n+  CollectObjectOops _collect;\n+\n+  template <class T> inline void add_oop(T* p) { _collect.add_oop(RawAccess<>::oop_load(p)); }\n+  void do_oop(oop* o) { add_oop(o); }\n+  void do_oop(narrowOop* v) { add_oop(v); }\n+\n+  jobjectArray create_jni_result(JNIEnv* env, TRAPS) {\n+    return _collect.create_jni_result(env, THREAD);\n+  }\n+};\n+\n+\/\/ Collect Object oops for the given oop, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))\n+  ResourceMark rm(thread);\n+  Handle objh(thread, JNIHandles::resolve(thing));\n+  CollectObjectOops collectOops;\n+  objh->oop_iterate(&collectOops);\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n+\/\/ Collect Object oops for the given frame deep, iterate through value objects\n+WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))\n+  KeepStackGCProcessedMark ksgcpm(THREAD);\n+  ResourceMark rm(THREAD);\n+  CollectFrameObjectOops collectOops;\n+  StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/);\n+  while (depth > 0) { \/\/ Skip the native WB API frame\n+    sfs.next();\n+    frame* f = sfs.current();\n+    f->oops_do(&collectOops, nullptr, sfs.register_map());\n+    depth--;\n+  }\n+  return collectOops.create_jni_result(env, THREAD);\n+WB_END\n+\n@@ -2925,0 +3032,6 @@\n+  {CC\"getObjectsViaKlassOopMaps0\",\n+      CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",    (void*)&WB_getObjectsViaKlassOopMaps},\n+  {CC\"getObjectsViaOopIterator0\",\n+          CC\"(Ljava\/lang\/Object;)[Ljava\/lang\/Object;\",(void*)&WB_getObjectsViaOopIterator},\n+  {CC\"getObjectsViaFrameOopIterator\",\n+      CC\"(I)[Ljava\/lang\/Object;\",                     (void*)&WB_getObjectsViaFrameOopIterator},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include <string.h>\n@@ -365,0 +366,12 @@\n+bool Arguments::patching_migrated_classes(const char* property, const char* value) {\n+  if (strncmp(property, MODULE_PROPERTY_PREFIX, MODULE_PROPERTY_PREFIX_LEN) == 0) {\n+    const char* property_suffix = property + MODULE_PROPERTY_PREFIX_LEN;\n+    if (matches_property_suffix(property_suffix, PATCH, PATCH_LEN)) {\n+      if (strcmp(value, \"java.base-valueclasses.jar\")) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -1804,1 +1817,0 @@\n-static unsigned int patch_mod_count = 0;\n@@ -1811,1 +1823,1 @@\n-  if (!CDSConfig::check_vm_args_consistency(patch_mod_javabase, mode_flag_cmd_line)) {\n+  if (!CDSConfig::check_vm_args_consistency(mode_flag_cmd_line)) {\n@@ -2078,1 +2090,1 @@\n-      add_patch_mod_prefix(module_name, module_equal + 1);\n+      add_patch_mod_prefix(module_name, module_equal + 1, false \/* no append *\/, false \/* no cds *\/);\n@@ -2080,3 +2092,0 @@\n-      if (!create_numbered_module_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n-        return JNI_ENOMEM;\n-      }\n@@ -2090,0 +2099,64 @@\n+\/\/ VALUECLASS_STR must match string used in the build\n+#define VALUECLASS_STR \"valueclasses\"\n+#define VALUECLASS_JAR \"-\" VALUECLASS_STR \".jar\"\n+\n+\/\/ Finalize --patch-module args and --enable-preview related to value class module patches.\n+\/\/ Create all numbered properties passing module patches.\n+int Arguments::finalize_patch_module() {\n+  \/\/ If --enable-preview and EnableValhalla is true, each module may have value classes that\n+  \/\/ are to be patched into the module.\n+  \/\/ For each <module>-valueclasses.jar in <JAVA_HOME>\/lib\/valueclasses\/\n+  \/\/ appends the equivalent of --patch-module <module>=<JAVA_HOME>\/lib\/valueclasses\/<module>-valueclasses.jar\n+  if (enable_preview() && EnableValhalla) {\n+    char * valueclasses_dir = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+    const char * fileSep = os::file_separator();\n+\n+    jio_snprintf(valueclasses_dir, JVM_MAXPATHLEN, \"%s%slib%s\" VALUECLASS_STR \"%s\",\n+                 Arguments::get_java_home(), fileSep, fileSep, fileSep);\n+    DIR* dir = os::opendir(valueclasses_dir);\n+    if (dir != nullptr) {\n+      char * module_name = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+      char * path = AllocateHeap(JVM_MAXPATHLEN, mtArguments);\n+\n+      for (dirent * entry = os::readdir(dir); entry != nullptr; entry = os::readdir(dir)) {\n+        \/\/ Test if file ends-with \"-valueclasses.jar\"\n+        int len = (int)strlen(entry->d_name) - (sizeof(VALUECLASS_JAR) - 1);\n+        if (len <= 0 || strcmp(&entry->d_name[len], VALUECLASS_JAR) != 0) {\n+          continue;         \/\/ too short or not the expected suffix\n+        }\n+\n+        strcpy(module_name, entry->d_name);\n+        module_name[len] = '\\0';     \/\/ truncate to just module-name\n+\n+        jio_snprintf(path, JVM_MAXPATHLEN, \"%s%s\", valueclasses_dir, &entry->d_name);\n+        add_patch_mod_prefix(module_name, path, true \/* append *\/, true \/* cds OK*\/);\n+        log_info(class)(\"--enable-preview appending value classes for module %s: %s\", module_name, entry->d_name);\n+      }\n+      FreeHeap(module_name);\n+      FreeHeap(path);\n+      os::closedir(dir);\n+    }\n+    FreeHeap(valueclasses_dir);\n+  }\n+\n+  \/\/ Create numbered properties for each module that has been patched either\n+  \/\/ by --patch-module or --enable-preview\n+  \/\/ Format is \"jdk.module.patch.<n>=<module_name>=<path>\"\n+  if (_patch_mod_prefix != nullptr) {\n+    char * prop_value = AllocateHeap(JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, mtArguments);\n+    unsigned int patch_mod_count = 0;\n+\n+    for (GrowableArrayIterator<ModulePatchPath *> it = _patch_mod_prefix->begin();\n+            it != _patch_mod_prefix->end(); ++it) {\n+      jio_snprintf(prop_value, JVM_MAXPATHLEN + JVM_MAXPATHLEN + 1, \"%s=%s\",\n+                   (*it)->module_name(), (*it)->path_string());\n+      if (!create_numbered_module_property(\"jdk.module.patch\", prop_value, patch_mod_count++)) {\n+        FreeHeap(prop_value);\n+        return JNI_ENOMEM;\n+      }\n+    }\n+    FreeHeap(prop_value);\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -2358,0 +2431,4 @@\n+      \/\/ --enable-preview enables Valhalla, EnableValhalla VM option will eventually be removed before integration\n+      if (FLAG_SET_CMDLINE(EnableValhalla, true) != JVMFlag::SUCCESS) {\n+        return JNI_EINVAL;\n+      }\n@@ -2837,10 +2914,5 @@\n-void Arguments::add_patch_mod_prefix(const char* module_name, const char* path) {\n-  \/\/ For java.base check for duplicate --patch-module options being specified on the command line.\n-  \/\/ This check is only required for java.base, all other duplicate module specifications\n-  \/\/ will be checked during module system initialization.  The module system initialization\n-  \/\/ will throw an ExceptionInInitializerError if this situation occurs.\n-  if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n-    if (patch_mod_javabase) {\n-      vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n-    } else {\n-      patch_mod_javabase = true;\n+void Arguments::add_patch_mod_prefix(const char* module_name, const char* path, bool allow_append, bool allow_cds) {\n+  if (!allow_cds) {\n+    CDSConfig::set_module_patching_disables_cds();\n+    if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+      CDSConfig::set_java_base_module_patching_disables_cds();\n@@ -2855,1 +2927,18 @@\n-  _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  \/\/ Scan patches for matching module\n+  int i = _patch_mod_prefix->find_if([&](ModulePatchPath* patch) {\n+    return (strcmp(module_name, patch->module_name()) == 0);\n+  });\n+  if (i == -1) {\n+    _patch_mod_prefix->push(new ModulePatchPath(module_name, path));\n+  } else {\n+    if (allow_append) {\n+      \/\/ append path to existing module entry\n+      _patch_mod_prefix->at(i)->append_path(path);\n+    } else {\n+      if (strcmp(module_name, JAVA_BASE_NAME) == 0) {\n+        vm_exit_during_initialization(\"Cannot specify \" JAVA_BASE_NAME \" more than once to --patch-module\");\n+      } else {\n+        vm_exit_during_initialization(\"Cannot specify a module more than once to --patch-module\", module_name);\n+      }\n+    }\n+  }\n@@ -2968,1 +3057,2 @@\n-  if (!check_vm_args_consistency()) {\n+  \/\/ finalize --module-patch and related --enable-preview\n+  if (finalize_patch_module() != JNI_OK) {\n@@ -2972,0 +3062,3 @@\n+  if (!check_vm_args_consistency()) {\n+    return JNI_ERR;\n+  }\n@@ -3857,0 +3950,12 @@\n+  if (!EnableValhalla || (is_interpreter_only() && !CDSConfig::is_dumping_archive() && !UseSharedSpaces)) {\n+    \/\/ Disable calling convention optimizations if inline types are not supported.\n+    \/\/ Also these aren't useful in -Xint. However, don't disable them when dumping or using\n+    \/\/ the CDS archive, as the values must match between dumptime and runtime.\n+    FLAG_SET_DEFAULT(InlineTypePassFieldsAsArgs, false);\n+    FLAG_SET_DEFAULT(InlineTypeReturnedAsFields, false);\n+  }\n+  if (!UseNonAtomicValueFlattening && !UseNullableValueFlattening && !UseAtomicValueFlattening) {\n+    \/\/ Flattening is disabled\n+    FLAG_SET_DEFAULT(UseArrayFlattening, false);\n+    FLAG_SET_DEFAULT(UseFieldFlattening, false);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":123,"deletions":18,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -460,1 +460,1 @@\n-  template<typename FKind> frame new_heap_frame(frame& f, frame& caller);\n+  template<typename FKind> frame new_heap_frame(frame& f, frame& caller, int size_adjust = 0);\n@@ -462,1 +462,1 @@\n-  inline void patch_pd(frame& callee, const frame& caller);\n+  inline void patch_pd(frame& callee, const frame& caller, bool is_bottom_frame);\n@@ -1183,1 +1183,1 @@\n-  patch_pd(hf, caller);\n+  patch_pd(hf, caller, is_bottom_frame);\n@@ -1280,2 +1280,24 @@\n-  const int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f) + frame::metadata_words_at_top;\n-  const int fsize = pointer_delta_as_int(stack_frame_bottom + argsize, stack_frame_top);\n+  int argsize = ContinuationHelper::CompiledFrame::stack_argsize(f) + frame::metadata_words_at_top;\n+  int fsize = pointer_delta_as_int(stack_frame_bottom + argsize, stack_frame_top);\n+\n+  int real_frame_size = 0;\n+  bool augmented = f.was_augmented_on_entry(real_frame_size);\n+  if (augmented) {\n+    \/\/ The args reside inside the frame so clear argsize. If the caller is compiled,\n+    \/\/ this will cause the stack arguments passed by the caller to be freezed when\n+    \/\/ freezing the caller frame itself. If the caller is interpreted this will have\n+    \/\/ the effect of discarding the arg area created in the i2c stub.\n+    argsize = 0;\n+    fsize = real_frame_size - (callee_interpreted ? 0 : callee_argsize);\n+#ifdef ASSERT\n+    nmethod* nm = f.cb()->as_nmethod();\n+    Method* method = nm->method();\n+    address return_pc = ContinuationHelper::CompiledFrame::return_pc(f);\n+    CodeBlob* caller_cb = CodeCache::find_blob_fast(return_pc);\n+    assert(nm->is_compiled_by_c2() || (caller_cb->is_nmethod() && caller_cb->as_nmethod()->is_compiled_by_c2()), \"caller or callee should be c2 compiled\");\n+    assert((!caller_cb->is_nmethod() && nm->is_compiled_by_c2()) ||\n+           (nm->compiler_type() != caller_cb->as_nmethod()->compiler_type()) ||\n+           (nm->is_compiled_by_c2() && !method->is_static() && method->method_holder()->is_inline_klass()),\n+           \"frame should not be extended\");\n+#endif\n+  }\n@@ -1283,1 +1305,1 @@\n-  log_develop_trace(continuations)(\"recurse_freeze_compiled_frame %s _size: %d fsize: %d argsize: %d\",\n+  log_develop_trace(continuations)(\"recurse_freeze_compiled_frame %s _size: %d fsize: %d argsize: %d augmented: %d\",\n@@ -1286,1 +1308,1 @@\n-                             _freeze_size, fsize, argsize);\n+                             _freeze_size, fsize, argsize, augmented);\n@@ -1297,0 +1319,1 @@\n+  assert(!is_bottom_frame || !augmented, \"thaw extended frame without caller?\");\n@@ -1300,1 +1323,1 @@\n-  frame hf = new_heap_frame<ContinuationHelper::CompiledFrame>(f, caller);\n+  frame hf = new_heap_frame<ContinuationHelper::CompiledFrame>(f, caller, augmented ? real_frame_size - f.cb()->as_nmethod()->frame_size() : 0);\n@@ -1962,0 +1985,1 @@\n+  int remove_scalarized_frames(StackChunkFrameStream<ChunkFrames::CompiledOnly>& scfs, int &argsize);\n@@ -1985,1 +2009,1 @@\n-  inline void patch(frame& f, const frame& caller, bool bottom);\n+  inline void patch(frame& f, const frame& caller, bool bottom, bool augmented = false);\n@@ -1995,1 +2019,1 @@\n-  template<typename FKind> frame new_stack_frame(const frame& hf, frame& caller, bool bottom);\n+  template<typename FKind> frame new_stack_frame(const frame& hf, frame& caller, bool bottom, int size_adjust = 0);\n@@ -2072,0 +2096,14 @@\n+int ThawBase::remove_scalarized_frames(StackChunkFrameStream<ChunkFrames::CompiledOnly>& f, int &argsize) {\n+  intptr_t* top = f.sp();\n+\n+  while (f.cb()->as_nmethod()->needs_stack_repair()) {\n+    f.next(SmallRegisterMap::instance(), false \/* stop *\/);\n+  }\n+  assert(!f.is_done(), \"\");\n+  assert(f.is_compiled(), \"\");\n+\n+  intptr_t* bottom = f.sp() + f.cb()->frame_size();\n+  argsize = f.stack_argsize();\n+  return bottom - top;\n+}\n+\n@@ -2093,3 +2131,0 @@\n-    frame_size += f.cb()->frame_size();\n-    argsize = f.stack_argsize();\n-\n@@ -2102,0 +2137,9 @@\n+\n+    if (f.cb()->as_nmethod()->needs_stack_repair()) {\n+      frame_size += remove_scalarized_frames(f, argsize);\n+    } else {\n+      frame_size += f.cb()->frame_size();\n+      argsize = f.stack_argsize();\n+    }\n+  } else if (f.cb()->as_nmethod()->needs_stack_repair()) {\n+    frame_size = remove_scalarized_frames(f, argsize);\n@@ -2381,0 +2425,1 @@\n+  CodeBlob* cb = _stream.cb();\n@@ -2385,3 +2430,8 @@\n-  \/\/ we never leave a compiled caller of an interpreted frame as the top frame in the chunk\n-  \/\/ as it makes detecting that situation and adjusting unextended_sp tricky\n-  if (num_frames == 1 && !_stream.is_done() && FKind::interpreted && _stream.is_compiled()) {\n+  \/\/ We never leave a compiled caller of an interpreted frame as the top frame in the chunk\n+  \/\/ as it makes detecting that situation and adjusting unextended_sp tricky. We also always\n+  \/\/ thaw the caller of a frame that needs_stack_repair, as it would otherwise complicate things:\n+  \/\/ - Regardless of whether the frame was extended or not, we would need to copy the right arg\n+  \/\/   size if its greater than the one given by the normal method signature (non-scalarized).\n+  \/\/ - If the frame was indeed extended, leaving its caller as the top frame would complicate walking\n+  \/\/   the chunk (we need unextended_sp, but we only have sp).\n+  if (num_frames == 1 && !_stream.is_done() && ((FKind::interpreted && _stream.is_compiled()) || (FKind::compiled && cb->as_nmethod_or_null()->needs_stack_repair()))) {\n@@ -2447,1 +2497,1 @@\n-inline void ThawBase::patch(frame& f, const frame& caller, bool bottom) {\n+inline void ThawBase::patch(frame& f, const frame& caller, bool bottom, bool augmented) {\n@@ -2452,1 +2502,1 @@\n-  } else {\n+  } else if (caller.is_compiled_frame()){\n@@ -2455,1 +2505,1 @@\n-    ContinuationHelper::Frame::patch_pc(caller, caller.raw_pc());\n+    ContinuationHelper::Frame::patch_pc(caller, caller.raw_pc(), augmented \/*callee_augmented*\/);\n@@ -2618,0 +2668,10 @@\n+  int fsize = 0;\n+  int added_argsize = 0;\n+  bool augmented = hf.was_augmented_on_entry(fsize);\n+  if (!augmented) {\n+    added_argsize = (is_bottom_frame || caller.is_interpreted_frame()) ? hf.compiled_frame_stack_argsize() : 0;\n+    fsize += added_argsize;\n+  }\n+  assert(!is_bottom_frame || !augmented, \"\");\n+\n+\n@@ -2621,1 +2681,3 @@\n-  frame f = new_stack_frame<ContinuationHelper::CompiledFrame>(hf, caller, is_bottom_frame);\n+  frame f = new_stack_frame<ContinuationHelper::CompiledFrame>(hf, caller, is_bottom_frame, augmented ? fsize - hf.cb()->frame_size() : 0);\n+  assert(f.cb()->frame_size() == (int)(caller.sp() - f.sp()), \"\");\n+\n@@ -2624,5 +2686,0 @@\n-\n-  const int added_argsize = (is_bottom_frame || caller.is_interpreted_frame()) ? hf.compiled_frame_stack_argsize() : 0;\n-  int fsize = ContinuationHelper::CompiledFrame::size(hf) + added_argsize;\n-  assert(fsize <= (int)(caller.unextended_sp() - f.unextended_sp()), \"\");\n-\n@@ -2641,1 +2698,1 @@\n-  patch(f, caller, is_bottom_frame);\n+  patch(f, caller, is_bottom_frame, augmented);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":83,"deletions":26,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -301,0 +304,18 @@\n+\n+static Klass* get_refined_array_klass(Klass* k, frame* fr, RegisterMap* map, ObjectValue* sv, TRAPS) {\n+  \/\/ If it's an array, get the properties\n+  if (k->is_array_klass() && !k->is_typeArray_klass()) {\n+    assert(!k->is_refArray_klass() && !k->is_flatArray_klass(), \"Unexpected refined klass\");\n+    nmethod* nm = fr->cb()->as_nmethod_or_null();\n+    if (nm->is_compiled_by_c2()) {\n+      assert(sv->has_properties(), \"Property information is missing\");\n+      ArrayKlass::ArrayProperties props = static_cast<ArrayKlass::ArrayProperties>(StackValue::create_stack_value(fr, map, sv->properties())->get_jint());\n+      k = ObjArrayKlass::cast(k)->klass_with_properties(props, THREAD);\n+    } else {\n+      \/\/ TODO Graal needs to be fixed. Just go with the default properties for now\n+      k = ObjArrayKlass::cast(k)->klass_with_properties(ArrayKlass::ArrayProperties::DEFAULT, THREAD);\n+    }\n+  }\n+  return k;\n+}\n+\n@@ -302,2 +323,2 @@\n-static void print_objects(JavaThread* deoptee_thread,\n-                          GrowableArray<ScopeValue*>* objects, bool realloc_failures) {\n+static void print_objects(JavaThread* deoptee_thread, frame* deoptee, RegisterMap* map,\n+                          GrowableArray<ScopeValue*>* objects, bool realloc_failures, TRAPS) {\n@@ -319,0 +340,1 @@\n+    k = get_refined_array_klass(k, deoptee, map, sv, THREAD);\n@@ -352,2 +374,13 @@\n-  bool save_oop_result = chunk->at(0)->scope()->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n-  Handle return_value;\n+  ScopeDesc* scope = chunk->at(0)->scope();\n+  bool save_oop_result = scope->return_oop() && !thread->popframe_forcing_deopt_reexecution() && (exec_mode == Deoptimization::Unpack_deopt);\n+  \/\/ In case of the return of multiple values, we must take care\n+  \/\/ of all oop return values.\n+  GrowableArray<Handle> return_oops;\n+  InlineKlass* vk = nullptr;\n+  if (save_oop_result && scope->return_scalarized()) {\n+    vk = InlineKlass::returned_inline_klass(map);\n+    if (vk != nullptr) {\n+      vk->save_oop_fields(map, return_oops);\n+      save_oop_result = false;\n+    }\n+  }\n@@ -359,1 +392,1 @@\n-    return_value = Handle(thread, result);\n+    return_oops.push(Handle(thread, result));\n@@ -366,1 +399,1 @@\n-  if (objects != nullptr) {\n+  if (objects != nullptr || vk != nullptr) {\n@@ -371,1 +404,9 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+      if (vk != nullptr) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, CHECK_AND_CLEAR_(true));\n+      }\n+      if (objects != nullptr) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, CHECK_AND_CLEAR_(true));\n+      }\n@@ -376,1 +417,9 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+      if (vk != nullptr) {\n+        realloc_failures = Deoptimization::realloc_inline_type_result(vk, map, return_oops, THREAD);\n+      }\n+      if (objects != nullptr) {\n+        realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+        guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+        bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+        Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci, THREAD);\n+      }\n@@ -379,5 +428,2 @@\n-    guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n-    bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci);\n-    if (TraceDeoptimization) {\n-      print_objects(deoptee_thread, objects, realloc_failures);\n+    if (TraceDeoptimization && objects != nullptr) {\n+      print_objects(deoptee_thread, &deoptee, &map, objects, realloc_failures, thread);\n@@ -386,1 +432,1 @@\n-  if (save_oop_result) {\n+  if (save_oop_result || vk != nullptr) {\n@@ -388,1 +434,2 @@\n-    deoptee.set_saved_oop_result(&map, return_value());\n+    assert(return_oops.length() == 1, \"no inline type\");\n+    deoptee.set_saved_oop_result(&map, return_oops.pop()());\n@@ -724,1 +771,1 @@\n-  \/\/ If the sender is deoptimized the we must retrieve the address of the handler\n+  \/\/ If the sender is deoptimized we must retrieve the address of the handler\n@@ -1241,2 +1288,10 @@\n-\n-    oop obj = nullptr;\n+    k = get_refined_array_klass(k, fr, reg_map, sv, THREAD);\n+\n+    \/\/ Check if the object may be null and has an additional null_marker input that needs\n+    \/\/ to be checked before using the field values. Skip re-allocation if it is null.\n+    if (k->is_inline_klass() && sv->has_properties()) {\n+      jint null_marker = StackValue::create_stack_value(fr, reg_map, sv->properties())->get_jint();\n+      if (null_marker == 0) {\n+        continue;\n+      }\n+    }\n@@ -1245,0 +1300,1 @@\n+    oop obj = nullptr;\n@@ -1272,0 +1328,4 @@\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* ak = FlatArrayKlass::cast(k);\n+      \/\/ Inline type array must be zeroed because not all memory is reassigned\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1278,2 +1338,2 @@\n-    } else if (k->is_objArray_klass()) {\n-      ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n+    } else if (k->is_refArray_klass()) {\n+      RefArrayKlass* ak = RefArrayKlass::cast(k);\n@@ -1281,1 +1341,1 @@\n-      obj = ak->allocate_instance(sv->field_size(), THREAD);\n+      obj = ak->allocate_instance(sv->field_size(), ak->properties(), THREAD);\n@@ -1303,0 +1363,15 @@\n+\/\/ We're deoptimizing at the return of a call, inline type fields are\n+\/\/ in registers. When we go back to the interpreter, it will expect a\n+\/\/ reference to an inline type instance. Allocate and initialize it from\n+\/\/ the register values here.\n+bool Deoptimization::realloc_inline_type_result(InlineKlass* vk, const RegisterMap& map, GrowableArray<Handle>& return_oops, TRAPS) {\n+  oop new_vt = vk->realloc_result(map, return_oops, THREAD);\n+  if (new_vt == nullptr) {\n+    CLEAR_PENDING_EXCEPTION;\n+    THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);\n+  }\n+  return_oops.clear();\n+  return_oops.push(Handle(THREAD, new_vt));\n+  return false;\n+}\n+\n@@ -1468,0 +1543,3 @@\n+  InstanceKlass* _klass;\n+  bool _is_flat;\n+  bool _is_null_free;\n@@ -1469,4 +1547,1 @@\n-  ReassignedField() {\n-    _offset = 0;\n-    _type = T_ILLEGAL;\n-  }\n+  ReassignedField() : _offset(0), _type(T_ILLEGAL), _klass(nullptr), _is_flat(false), _is_null_free(false) { }\n@@ -1486,0 +1561,6 @@\n+      if (fs.is_flat()) {\n+        field._is_flat = true;\n+        field._is_null_free = fs.is_null_free_inline_type();\n+        \/\/ Resolve klass of flat inline type field\n+        field._klass = InlineKlass::cast(klass->get_inline_type_field_klass(fs.index()));\n+      }\n@@ -1492,2 +1573,3 @@\n-\/\/ Restore fields of an eliminated instance object employing the same field order used by the compiler.\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci) {\n+\/\/ Restore fields of an eliminated instance object employing the same field order used by the\n+\/\/ compiler when it scalarizes an object at safepoints.\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci, int base_offset, TRAPS) {\n@@ -1496,0 +1578,19 @@\n+    BasicType type = fields->at(i)._type;\n+    int offset = base_offset + fields->at(i)._offset;\n+    \/\/ Check for flat inline type field before accessing the ScopeValue because it might not have any fields\n+    if (fields->at(i)._is_flat) {\n+      \/\/ Recursively re-assign flat inline type fields\n+      InstanceKlass* vk = fields->at(i)._klass;\n+      assert(vk != nullptr, \"must be resolved\");\n+      offset -= InlineKlass::cast(vk)->payload_offset(); \/\/ Adjust offset to omit oop header\n+      svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, is_jvmci, offset, CHECK_0);\n+      if (!fields->at(i)._is_null_free) {\n+        ScopeValue* scope_field = sv->field_at(svIndex);\n+        StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n+        int nm_offset = offset + InlineKlass::cast(vk)->null_marker_offset();\n+        obj->bool_field_put(nm_offset, value->get_jint() & 1);\n+        svIndex++;\n+      }\n+      continue; \/\/ Continue because we don't need to increment svIndex\n+    }\n+\n@@ -1498,3 +1599,2 @@\n-    int offset = fields->at(i)._offset;\n-    BasicType type = fields->at(i)._type;\n-      case T_OBJECT: case T_ARRAY:\n+      case T_OBJECT:\n+      case T_ARRAY:\n@@ -1572,0 +1672,1 @@\n+\n@@ -1575,0 +1676,14 @@\n+\/\/ restore fields of an eliminated inline type array\n+void Deoptimization::reassign_flat_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, flatArrayOop obj, FlatArrayKlass* vak, bool is_jvmci, TRAPS) {\n+  InlineKlass* vk = vak->element_klass();\n+  assert(vk->maybe_flat_in_array(), \"should only be used for flat inline type arrays\");\n+  \/\/ Adjust offset to omit oop header\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(T_FLAT_ELEMENT) - InlineKlass::cast(vk)->payload_offset();\n+  \/\/ Initialize all elements of the flat inline type array\n+  for (int i = 0; i < sv->field_size(); i++) {\n+    ScopeValue* val = sv->field_at(i);\n+    int offset = base_offset + (i << Klass::layout_helper_log2_element_size(vak->layout_helper()));\n+    reassign_fields_by_klass(vk, fr, reg_map, val->as_ObjectValue(), 0, (oop)obj, is_jvmci, offset, CHECK);\n+  }\n+}\n+\n@@ -1576,1 +1691,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci, TRAPS) {\n@@ -1581,0 +1696,2 @@\n+    k = get_refined_array_klass(k, fr, reg_map, sv, THREAD);\n+\n@@ -1582,1 +1699,1 @@\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    assert(obj.not_null() || realloc_failures || sv->has_properties(), \"reallocation was missed\");\n@@ -1620,1 +1737,4 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci, 0, CHECK);\n+    } else if (k->is_flatArray_klass()) {\n+      FlatArrayKlass* vak = FlatArrayKlass::cast(k);\n+      reassign_flat_array_elements(fr, reg_map, sv, (flatArrayOop) obj(), vak, is_jvmci, CHECK);\n@@ -1624,1 +1744,1 @@\n-    } else if (k->is_objArray_klass()) {\n+    } else if (k->is_refArray_klass()) {\n@@ -1816,1 +1936,1 @@\n-  \/\/ Deoptimize only if the frame comes from compile code.\n+  \/\/ Deoptimize only if the frame comes from compiled code.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":155,"deletions":35,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -46,1 +47,2 @@\n-  return is_final() && (is_static() || ik->is_hidden() || ik->is_record());\n+  return is_final() && (is_static() || ik->is_hidden() || ik->is_record() || ik->is_inline_klass()\n+                        || (ik->is_abstract() && !ik->is_identity_class() && !ik->is_interface()));\n@@ -101,1 +103,1 @@\n-void fieldDescriptor::print_on(outputStream* st) const {\n+void fieldDescriptor::print_on(outputStream* st, int base_offset) const {\n@@ -107,1 +109,1 @@\n-  st->print(\" @%d \", offset());\n+  st->print(\" @%d \", offset() + base_offset);\n@@ -125,4 +127,1 @@\n-void fieldDescriptor::print_on_for(outputStream* st, oop obj) {\n-  print_on(st);\n-  st->print(\" \");\n-\n+void fieldDescriptor::print_on_for(outputStream* st, oop obj, int indent, int base_offset) {\n@@ -130,0 +129,3 @@\n+  print_on(st, base_offset);\n+  st->print(\" \");\n+  jint as_int = 0;\n@@ -159,6 +161,27 @@\n-      if (obj->obj_field(offset()) != nullptr) {\n-        obj->obj_field(offset())->print_value_on(st);\n-      } else {\n-        st->print(\"null\");\n-      }\n-      break;\n+      if (is_flat()) { \/\/ only some inline types can be flat\n+        InlineKlass* vk = InlineKlass::cast(field_holder()->get_inline_type_field_klass(index()));\n+        st->print(\"Flat inline type field '%s':\", vk->name()->as_C_string());\n+        if (!is_null_free_inline_type()) {\n+          assert(has_null_marker(), \"should have null marker\");\n+          InlineLayoutInfo* li = field_holder()->inline_layout_info_adr(index());\n+          int nm_offset = li->null_marker_offset();\n+          if (obj->byte_field_acquire(nm_offset) == 0) {\n+            st->print(\" null\");\n+            return;\n+          }\n+        }\n+        st->cr();\n+        \/\/ Print fields of flat field (recursively)\n+        int field_offset = offset() - vk->payload_offset();\n+        obj = cast_to_oop(cast_from_oop<address>(obj) + field_offset);\n+        FieldPrinter print_field(st, obj, indent + 1, base_offset + field_offset );\n+        vk->do_nonstatic_fields(&print_field);\n+        if (this->field_flags().has_null_marker()) {\n+          for (int i = 0; i < indent + 1; i++) st->print(\"  \");\n+          st->print_cr(\" - [null_marker] @%d %s\",\n+                    vk->null_marker_offset() - base_offset + field_offset,\n+                    obj->bool_field(vk->null_marker_offset()) ? \"Field marked as non-null\" : \"Field marked as null\");\n+        }\n+        return; \/\/ Do not print underlying representation\n+      }\n+      \/\/ Not flat inline type field, fall through\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -62,0 +63,3 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Runtime1.hpp\"\n+#endif\n@@ -369,0 +373,19 @@\n+\n+#ifdef COMPILER1\n+  if (nm->is_compiled_by_c1() && nm->method()->has_scalarized_args() &&\n+      pc() < nm->verified_inline_entry_point()) {\n+    \/\/ The VEP and VIEP(RO) of C1-compiled methods call into the runtime to buffer scalarized value\n+    \/\/ type args. We can't deoptimize at that point because the buffers have not yet been initialized.\n+    \/\/ Also, if the method is synchronized, we first need to acquire the lock.\n+    \/\/ Don't patch the return pc to delay deoptimization until we enter the method body (the check\n+    \/\/ added in LIRGenerator::do_Base will detect the pending deoptimization by checking the original_pc).\n+#if defined ASSERT && !defined AARCH64   \/\/ Stub call site does not look like NativeCall on AArch64\n+    NativeCall* call = nativeCall_before(this->pc());\n+    address dest = call->destination();\n+    assert(dest == Runtime1::entry_for(StubId::c1_buffer_inline_args_no_receiver_id) ||\n+           dest == Runtime1::entry_for(StubId::c1_buffer_inline_args_id), \"unexpected safepoint in entry point\");\n+#endif\n+    return;\n+  }\n+#endif\n+\n@@ -767,1 +790,1 @@\n-                          OopClosure* f) {\n+                          OopClosure* f, BufferedValueClosure* bvt_f) {\n@@ -779,1 +802,3 @@\n-      _f->do_oop(addr);\n+      if (_f != nullptr) {\n+        _f->do_oop(addr);\n+      }\n@@ -791,1 +816,3 @@\n-        _f->do_oop(addr);\n+        if (_f != nullptr) {\n+          _f->do_oop(addr);\n+        }\n@@ -966,1 +993,1 @@\n-  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f);\n+  InterpreterFrameClosure blk(this, max_locals, m->max_stack(), f, nullptr);\n@@ -978,0 +1005,17 @@\n+void frame::buffered_values_interpreted_do(BufferedValueClosure* f) {\n+  assert(is_interpreted_frame(), \"Not an interpreted frame\");\n+  Thread *thread = Thread::current();\n+  methodHandle m (thread, interpreter_frame_method());\n+  jint      bci = interpreter_frame_bci();\n+\n+  assert(m->is_method(), \"checking frame value\");\n+  assert(!m->is_native() && bci >= 0 && bci < m->code_size(),\n+         \"invalid bci value\");\n+\n+  InterpreterFrameClosure blk(this, m->max_locals(), m->max_stack(), nullptr, f);\n+\n+  \/\/ process locals & expression stack\n+  InterpreterOopMap mask;\n+  m->mask_for(bci, &mask);\n+  mask.iterate_oop(&blk);\n+}\n@@ -1030,0 +1074,1 @@\n+    assert(_offset < _arg_size, \"out of bounds\");\n@@ -1056,5 +1101,1 @@\n-    _arg_size  = ArgumentSizeComputer(signature).size() + (has_receiver ? 1 : 0) + (has_appendix ? 1 : 0);\n-\n-    int arg_size;\n-    _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &arg_size);\n-    assert(arg_size == _arg_size, \"wrong arg size\");\n+    _regs = SharedRuntime::find_callee_arguments(signature, has_receiver, has_appendix, &_arg_size);\n@@ -1440,2 +1481,2 @@\n-                    FormatBuffer<1024>(\"#%d nmethod \" INTPTR_FORMAT \" for method J %s%s\", frame_no,\n-                                       p2i(nm),\n+                    FormatBuffer<1024>(\"#%d nmethod (%s %d) \" INTPTR_FORMAT \" for method J %s%s\", frame_no,\n+                                       nm->is_compiled_by_c1() ? \"c1\" : \"c2\", nm->frame_size(), p2i(nm),\n@@ -1451,0 +1492,5 @@\n+      CompiledEntrySignature ces(m);\n+      ces.compute_calling_conventions(false);\n+      const GrowableArray<SigEntry>* sig_cc = nm->is_compiled_by_c2() ? ces.sig_cc() : ces.sig();\n+      const VMRegPair* regs = nm->is_compiled_by_c2() ? ces.regs_cc() : ces.regs();\n+\n@@ -1452,21 +1498,0 @@\n-      int sizeargs = m->size_of_parameters();\n-\n-      BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);\n-      VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);\n-      {\n-        int sig_index = 0;\n-        if (!m->is_static()) {\n-          sig_bt[sig_index++] = T_OBJECT; \/\/ 'this'\n-        }\n-        for (SignatureStream ss(m->signature()); !ss.at_return_type(); ss.next()) {\n-          BasicType t = ss.type();\n-          assert(type2size[t] == 1 || type2size[t] == 2, \"size is 1 or 2\");\n-          sig_bt[sig_index++] = t;\n-          if (type2size[t] == 2) {\n-            sig_bt[sig_index++] = T_VOID;\n-          }\n-        }\n-        assert(sig_index == sizeargs, \"\");\n-      }\n-      int stack_arg_slots = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs);\n-      assert(stack_arg_slots ==  nm->as_nmethod()->num_stack_arg_slots(false \/* rounded *\/) || nm->is_osr_method(), \"\");\n@@ -1476,1 +1501,1 @@\n-      for (SignatureStream ss(m->signature()); !ss.at_return_type(); ) {\n+      for (ExtendedSignature sig = ExtendedSignature(sig_cc, SigEntryFilter()); !sig.at_end(); ++sig) {\n@@ -1478,3 +1503,1 @@\n-        bool at_old_sp = false;\n-        BasicType t = (at_this ? T_OBJECT : ss.type());\n-        assert(t == sig_bt[sig_index], \"sigs in sync\");\n+        BasicType t = (*sig)._bt;\n@@ -1494,3 +1517,0 @@\n-        if (!at_this) {\n-          ss.next();\n-        }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":59,"deletions":39,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"runtime\/atomic.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+DEF_HANDLE_CONSTR(flatArray, is_flatArray_noinline)\n+DEF_HANDLE_CONSTR(refArray , is_refArray_noinline )\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  VMRegImpl::set_regName();       \/\/ need this before generate_stubs (for printing oop maps).\n@@ -165,1 +166,0 @@\n-  VMRegImpl::set_regName();  \/\/ need this before generate_stubs (for printing oop maps).\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -143,4 +144,4 @@\n-    case T_BOOLEAN: \/\/ fall through\n-    case T_CHAR   : \/\/ fall through\n-    case T_SHORT  : \/\/ fall through\n-    case T_INT    : \/\/ fall through\n+    case T_BOOLEAN  : \/\/ fall through\n+    case T_CHAR     : \/\/ fall through\n+    case T_SHORT    : \/\/ fall through\n+    case T_INT      : \/\/ fall through\n@@ -148,2 +149,3 @@\n-    case T_OBJECT : \/\/ fall through\n-    case T_ARRAY  : \/\/ fall through\n+    case T_OBJECT   : \/\/ fall through\n+    case T_ARRAY    : \/\/ fall through\n+    case T_FLAT_ELEMENT: \/\/ fall through\n@@ -151,5 +153,5 @@\n-    case T_BYTE   : \/\/ fall through\n-    case T_VOID   : return T_INT;\n-    case T_LONG   : return T_LONG;\n-    case T_FLOAT  : return T_FLOAT;\n-    case T_DOUBLE : return T_DOUBLE;\n+    case T_BYTE     : \/\/ fall through\n+    case T_VOID     : return T_INT;\n+    case T_LONG     : return T_LONG;\n+    case T_FLOAT    : return T_FLOAT;\n+    case T_DOUBLE   : return T_DOUBLE;\n@@ -157,2 +159,2 @@\n-    case T_ARRAY  : \/\/ fall through\n-    case T_OBJECT:  return T_OBJECT;\n+    case T_ARRAY    : \/\/ fall through\n+    case T_OBJECT   : return T_OBJECT;\n@@ -379,0 +381,12 @@\n+  jobject value_buffer = nullptr;\n+  if (InlineTypeReturnedAsFields && (result->get_type() == T_OBJECT)) {\n+    \/\/ Pre allocate a buffered inline type in case the result is returned\n+    \/\/ flattened by compiled code\n+    InlineKlass* vk = method->returns_inline_type();\n+    if (vk != nullptr && vk->can_be_returned_as_fields()) {\n+      oop instance = vk->allocate_instance(CHECK);\n+      value_buffer = JNIHandles::make_local(thread, instance);\n+      result->set_jobject(value_buffer);\n+    }\n+  }\n+\n@@ -443,0 +457,1 @@\n+    JNIHandles::destroy_local(value_buffer);\n@@ -591,1 +606,1 @@\n-  if (is_reference_type(return_type)) return_type = T_OBJECT;\n+  if (return_type == T_ARRAY) return_type = T_OBJECT;\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  oop           _return_buffered_value; \/\/ buffered value being returned\n@@ -793,0 +794,3 @@\n+  oop return_buffered_value() const              { return _return_buffered_value; }\n+  void set_return_buffered_value(oop val)        { _return_buffered_value = val; }\n+\n@@ -859,0 +863,1 @@\n+  static ByteSize return_buffered_value_offset() { return byte_offset_of(JavaThread, _return_buffered_value); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -787,0 +788,1 @@\n+    ResourceMark rm;\n@@ -788,1 +790,2 @@\n-    bool return_oop = nm->method()->is_returning_oop();\n+    Method* method = nm->method();\n+    bool return_oop = method->is_returning_oop();\n@@ -790,1 +793,13 @@\n-    Handle return_value;\n+    GrowableArray<Handle> return_values;\n+    InlineKlass* vk = nullptr;\n+    if (InlineTypeReturnedAsFields && return_oop) {\n+      \/\/ Check if an inline type is returned as fields\n+      vk = InlineKlass::returned_inline_klass(map, &return_oop, method);\n+      if (vk != nullptr) {\n+        \/\/ We're at a safepoint at the return of a method that returns\n+        \/\/ multiple values. We must make sure we preserve the oop values\n+        \/\/ across the safepoint.\n+        vk->save_oop_fields(map, return_values);\n+      }\n+    }\n+\n@@ -797,1 +812,1 @@\n-      return_value = Handle(self, result);\n+      return_values.push(Handle(self, result));\n@@ -811,1 +826,6 @@\n-      caller_fr.set_saved_oop_result(&map, return_value());\n+      assert(vk != nullptr || return_values.length() == 1, \"only one return value\");\n+      caller_fr.set_saved_oop_result(&map, return_values.pop()());\n+    }\n+    \/\/ restore oops in scalarized fields\n+    if (vk != nullptr) {\n+      vk->restore_oop_results(map, return_values);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -51,0 +52,3 @@\n+#include \"oops\/access.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -54,0 +58,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -1197,0 +1202,15 @@\n+  \/\/ Substitutability test implementation piggy backs on static call resolution\n+  Bytecodes::Code code = caller->java_code_at(bci);\n+  if (code == Bytecodes::_if_acmpeq || code == Bytecodes::_if_acmpne) {\n+    bc = Bytecodes::_invokestatic;\n+    methodHandle attached_method(THREAD, extract_attached_method(vfst));\n+    assert(attached_method.not_null(), \"must have attached method\");\n+    vmClasses::ValueObjectMethods_klass()->initialize(CHECK_NH);\n+    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, false, CHECK_NH);\n+#ifdef ASSERT\n+    Method* is_subst = vmClasses::ValueObjectMethods_klass()->find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());\n+    assert(callinfo.selected_method() == is_subst, \"must be isSubstitutable method\");\n+#endif\n+    return receiver;\n+  }\n+\n@@ -1232,0 +1252,6 @@\n+    } else {\n+      assert(attached_method->has_scalarized_args(), \"invalid use of attached method\");\n+      if (!attached_method->method_holder()->is_inline_klass()) {\n+        \/\/ Ignore the attached method in this case to not confuse below code\n+        attached_method = methodHandle(current, nullptr);\n+      }\n@@ -1240,0 +1266,1 @@\n+  bool check_null_and_abstract = true;\n@@ -1253,2 +1280,3 @@\n-    if (attached_method.is_null()) {\n-      Method* callee = bytecode.static_target(CHECK_NH);\n+    Method* callee = attached_method();\n+    if (callee == nullptr) {\n+      callee = bytecode.static_target(CHECK_NH);\n@@ -1259,7 +1287,17 @@\n-\n-    \/\/ Retrieve from a compiled argument list\n-    receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n-    assert(oopDesc::is_oop_or_null(receiver()), \"\");\n-\n-    if (receiver.is_null()) {\n-      THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);\n+    bool caller_is_c1 = callerFrame.is_compiled_frame() && callerFrame.cb()->as_nmethod()->is_compiled_by_c1();\n+    if (!caller_is_c1 && callee->is_scalarized_arg(0)) {\n+      \/\/ If the receiver is an inline type that is passed as fields, no oop is available\n+      \/\/ Resolve the call without receiver null checking.\n+      assert(!callee->mismatch(), \"calls with inline type receivers should never mismatch\");\n+      assert(attached_method.not_null() && !attached_method->is_abstract(), \"must have non-abstract attached method\");\n+      if (bc == Bytecodes::_invokeinterface) {\n+        bc = Bytecodes::_invokevirtual; \/\/ C2 optimistically replaces interface calls by virtual calls\n+      }\n+      check_null_and_abstract = false;\n+    } else {\n+      \/\/ Retrieve from a compiled argument list\n+      receiver = Handle(current, callerFrame.retrieve_receiver(&reg_map2));\n+      assert(oopDesc::is_oop_or_null(receiver()), \"\");\n+      if (receiver.is_null()) {\n+        THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);\n+      }\n@@ -1272,1 +1310,1 @@\n-    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, CHECK_NH);\n+    LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);\n@@ -1281,1 +1319,1 @@\n-  if (has_receiver) {\n+  if (has_receiver && check_null_and_abstract) {\n@@ -1309,1 +1347,1 @@\n-methodHandle SharedRuntime::find_callee_method(TRAPS) {\n+methodHandle SharedRuntime::find_callee_method(bool is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1335,0 +1373,4 @@\n+    \/\/ Calls via mismatching methods are always non-scalarized\n+    if (callinfo.resolved_method()->mismatch() && !is_optimized) {\n+      caller_is_c1 = true;\n+    }\n@@ -1342,1 +1384,1 @@\n-methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, TRAPS) {\n+methodHandle SharedRuntime::resolve_helper(bool is_virtual, bool is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1365,0 +1407,4 @@\n+  \/\/ Calls via mismatching methods are always non-scalarized\n+  if (caller_nm->is_compiled_by_c1() || (call_info.resolved_method()->mismatch() && !is_optimized)) {\n+    caller_is_c1 = true;\n+  }\n@@ -1383,1 +1429,1 @@\n-    tty->print(\"resolving %s%s (%s) call to\",\n+    tty->print(\"resolving %s%s (%s) call%s to\",\n@@ -1385,1 +1431,1 @@\n-               Bytecodes::name(invoke_code));\n+               Bytecodes::name(invoke_code), (caller_is_c1) ? \" from C1\" : \"\");\n@@ -1424,1 +1470,1 @@\n-    inline_cache->update(&call_info, receiver->klass());\n+    inline_cache->update(&call_info, receiver->klass(), caller_is_c1);\n@@ -1428,1 +1474,1 @@\n-    callsite->set(callee_method);\n+    callsite->set(callee_method, caller_is_c1);\n@@ -1448,0 +1494,2 @@\n+  bool is_optimized = false;\n+  bool caller_is_c1 = false;\n@@ -1449,1 +1497,1 @@\n-    callee_method = SharedRuntime::handle_ic_miss_helper(CHECK_NULL);\n+    callee_method = SharedRuntime::handle_ic_miss_helper(is_optimized, caller_is_c1, CHECK_NULL);\n@@ -1454,1 +1502,1 @@\n-  return get_resolved_entry(current, callee_method);\n+  return get_resolved_entry(current, callee_method, false, is_optimized, caller_is_c1);\n@@ -1495,1 +1543,5 @@\n-      return callee->get_c2i_entry();\n+      if (caller_frame.is_interpreted_frame()) {\n+        return callee->get_c2i_inline_entry();\n+      } else {\n+        return callee->get_c2i_entry();\n+      }\n@@ -1501,0 +1553,3 @@\n+  bool is_static_call = false;\n+  bool is_optimized = false;\n+  bool caller_is_c1 = false;\n@@ -1503,1 +1558,1 @@\n-    callee_method = SharedRuntime::reresolve_call_site(CHECK_NULL);\n+    callee_method = SharedRuntime::reresolve_call_site(is_static_call, is_optimized, caller_is_c1, CHECK_NULL);\n@@ -1507,1 +1562,1 @@\n-  return get_resolved_entry(current, callee_method);\n+  return get_resolved_entry(current, callee_method, is_static_call, is_optimized, caller_is_c1);\n@@ -1546,1 +1601,2 @@\n-address SharedRuntime::get_resolved_entry(JavaThread* current, methodHandle callee_method) {\n+address SharedRuntime::get_resolved_entry(JavaThread* current, methodHandle callee_method,\n+                                          bool is_static_call, bool is_optimized, bool caller_is_c1) {\n@@ -1552,2 +1608,11 @@\n-  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n-  return callee_method->verified_code_entry();\n+\n+  if (caller_is_c1) {\n+    assert(callee_method->verified_inline_code_entry() != nullptr, \"Jump to zero!\");\n+    return callee_method->verified_inline_code_entry();\n+  } else if (is_static_call || is_optimized) {\n+    assert(callee_method->verified_code_entry() != nullptr, \"Jump to zero!\");\n+    return callee_method->verified_code_entry();\n+  } else {\n+    assert(callee_method->verified_inline_ro_code_entry() != nullptr, \"Jump to zero!\");\n+    return callee_method->verified_inline_ro_code_entry();\n+  }\n@@ -1559,0 +1624,1 @@\n+  bool caller_is_c1 = false;\n@@ -1561,1 +1627,1 @@\n-    callee_method = SharedRuntime::resolve_helper(false, false, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(false, false, caller_is_c1, CHECK_NULL);\n@@ -1565,1 +1631,1 @@\n-  return get_resolved_entry(current, callee_method);\n+  return get_resolved_entry(current, callee_method, true, false, caller_is_c1);\n@@ -1571,0 +1637,1 @@\n+  bool caller_is_c1 = false;\n@@ -1572,1 +1639,1 @@\n-    callee_method = SharedRuntime::resolve_helper(true, false, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(true, false, caller_is_c1, CHECK_NULL);\n@@ -1576,1 +1643,1 @@\n-  return get_resolved_entry(current, callee_method);\n+  return get_resolved_entry(current, callee_method, false, false, caller_is_c1);\n@@ -1584,0 +1651,1 @@\n+  bool caller_is_c1 = false;\n@@ -1585,1 +1653,1 @@\n-    callee_method = SharedRuntime::resolve_helper(true, true, CHECK_NULL);\n+    callee_method = SharedRuntime::resolve_helper(true, true, caller_is_c1, CHECK_NULL);\n@@ -1589,1 +1657,1 @@\n-  return get_resolved_entry(current, callee_method);\n+  return get_resolved_entry(current, callee_method, false, true, caller_is_c1);\n@@ -1592,1 +1660,3 @@\n-methodHandle SharedRuntime::handle_ic_miss_helper(TRAPS) {\n+\n+\n+methodHandle SharedRuntime::handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1610,1 +1680,1 @@\n-    tty->print(\"IC miss (%s) call to\", Bytecodes::name(bc));\n+    tty->print(\"IC miss (%s) call%s to\", Bytecodes::name(bc), (caller_is_c1) ? \" from C1\" : \"\");\n@@ -1642,0 +1712,4 @@\n+  \/\/ Calls via mismatching methods are always non-scalarized\n+  if (caller_nm->is_compiled_by_c1() || call_info.resolved_method()->mismatch()) {\n+    caller_is_c1 = true;\n+  }\n@@ -1645,1 +1719,1 @@\n-  inline_cache->update(&call_info, receiver()->klass());\n+  inline_cache->update(&call_info, receiver()->klass(), caller_is_c1);\n@@ -1656,1 +1730,1 @@\n-methodHandle SharedRuntime::reresolve_call_site(TRAPS) {\n+methodHandle SharedRuntime::reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS) {\n@@ -1666,0 +1740,3 @@\n+  if (caller.is_compiled_frame()) {\n+    caller_is_c1 = caller.cb()->as_nmethod()->is_compiled_by_c1();\n+  }\n@@ -1706,0 +1783,2 @@\n+        is_static_call = false;\n+        is_optimized = false;\n@@ -1708,0 +1787,1 @@\n+            is_static_call = true;\n@@ -1709,0 +1789,1 @@\n+            is_optimized = (iter.type() == relocInfo::opt_virtual_call_type);\n@@ -1713,1 +1794,0 @@\n-\n@@ -1727,2 +1807,1 @@\n-  methodHandle callee_method = find_callee_method(CHECK_(methodHandle()));\n-\n+  methodHandle callee_method = find_callee_method(is_optimized, caller_is_c1, CHECK_(methodHandle()));\n@@ -1735,1 +1814,1 @@\n-    tty->print(\"handle_wrong_method reresolving call to\");\n+    tty->print(\"handle_wrong_method reresolving call%s to\", (caller_is_c1) ? \" from C1\" : \"\");\n@@ -1941,0 +2020,15 @@\n+char* SharedRuntime::generate_identity_exception_message(JavaThread* current, Klass* klass) {\n+  assert(klass->is_inline_klass(), \"Must be a concrete value class\");\n+  const char* desc = \"Cannot synchronize on an instance of value class \";\n+  const char* className = klass->external_name();\n+  size_t msglen = strlen(desc) + strlen(className) + 1;\n+  char* message = NEW_RESOURCE_ARRAY(char, msglen);\n+  if (nullptr == message) {\n+    \/\/ Out of memory: can't create detailed error message\n+    message = const_cast<char*>(klass->external_name());\n+  } else {\n+    jio_snprintf(message, msglen, \"%s%s\", desc, className);\n+  }\n+  return message;\n+}\n+\n@@ -2191,1 +2285,1 @@\n-    _basic_type_bits = 4,\n+    _basic_type_bits = 5,\n@@ -2206,1 +2300,1 @@\n-  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt, int len) {\n+  AdapterFingerPrint(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n@@ -2209,2 +2303,2 @@\n-    assert(len == length(total_args_passed), \"sanity\");\n-    _length = len;\n+    int total_args_passed = total_args_passed_in_sig(sig);\n+    _length = length(total_args_passed);\n@@ -2212,0 +2306,2 @@\n+    BasicType prev_bt = T_ILLEGAL;\n+    int vt_count = 0;\n@@ -2214,4 +2310,27 @@\n-      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n-        int bt = adapter_encoding(sig_bt[sig_index++]);\n-        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt;\n+      for (int byte = 0; byte < _basic_types_per_int; byte++) {\n+        BasicType bt = T_ILLEGAL;\n+        if (sig_index < total_args_passed) {\n+          bt = sig->at(sig_index++)._bt;\n+          if (bt == T_METADATA) {\n+            \/\/ Found start of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+            if (sig_index == 1 && has_ro_adapter) {\n+              \/\/ With a ro_adapter, replace receiver inline type delimiter by T_VOID to prevent matching\n+              \/\/ with other adapters that have the same inline type as first argument and no receiver.\n+              bt = T_VOID;\n+            }\n+            vt_count++;\n+          } else if (bt == T_VOID && prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+            \/\/ Found end of inline type in signature\n+            assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n+            vt_count--;\n+            assert(vt_count >= 0, \"invalid vt_count\");\n+          } else if (vt_count == 0) {\n+            \/\/ Widen fields that are not part of a scalarized inline type argument\n+            bt = adapter_encoding(bt);\n+          }\n+          prev_bt = bt;\n+        }\n+        int bt_val = (bt == T_ILLEGAL) ? 0 : bt;\n+        assert((bt_val & _basic_type_mask) == bt_val, \"must fit in 4 bits\");\n+        value = (value << _basic_type_bits) | bt_val;\n@@ -2221,0 +2340,1 @@\n+    assert(vt_count == 0, \"invalid vt_count\");\n@@ -2228,0 +2348,4 @@\n+  static int total_args_passed_in_sig(const GrowableArray<SigEntry>* sig) {\n+    return (sig != nullptr) ? sig->length() : 0;\n+  }\n+\n@@ -2239,1 +2363,1 @@\n-  static int adapter_encoding(BasicType in) {\n+  static BasicType adapter_encoding(BasicType in) {\n@@ -2245,1 +2369,1 @@\n-        \/\/ There are all promoted to T_INT in the calling convention\n+        \/\/ They are all promoted to T_INT in the calling convention\n@@ -2278,0 +2402,1 @@\n+public:\n@@ -2284,1 +2409,2 @@\n-      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n+      int first_entry = _basic_types_per_int * _basic_type_bits;\n+      for (int j = first_entry; j >= 0; j -= _basic_type_bits) {\n@@ -2294,2 +2420,2 @@\n- public:\n-  static AdapterFingerPrint* allocate(int total_args_passed, BasicType* sig_bt) {\n+  static AdapterFingerPrint* allocate(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false) {\n+    int total_args_passed = total_args_passed_in_sig(sig);\n@@ -2298,1 +2424,1 @@\n-    AdapterFingerPrint* afp = new (size_in_bytes) AdapterFingerPrint(total_args_passed, sig_bt, len);\n+    AdapterFingerPrint* afp = new (size_in_bytes) AdapterFingerPrint(sig, has_ro_adapter);\n@@ -2347,7 +2473,4 @@\n-      switch (arg) {\n-        case T_INT:    st.print(\"I\");    break;\n-        case T_LONG:   long_prev = true; break;\n-        case T_FLOAT:  st.print(\"F\");    break;\n-        case T_DOUBLE: st.print(\"D\");    break;\n-        case T_VOID:   break;\n-        default: ShouldNotReachHere();\n+      if (arg == T_LONG) {\n+        long_prev = true;\n+      } else if (arg != T_VOID) {\n+        st.print(\"%c\", type2char((BasicType)arg));\n@@ -2362,51 +2485,0 @@\n-  BasicType* as_basic_type(int& nargs) {\n-    nargs = 0;\n-    GrowableArray<BasicType> btarray;\n-    bool long_prev = false;\n-\n-    iterate_args([&] (int arg) {\n-      if (long_prev) {\n-        long_prev = false;\n-        if (arg == T_VOID) {\n-          btarray.append(T_LONG);\n-        } else {\n-          btarray.append(T_OBJECT); \/\/ it could be T_ARRAY; it shouldn't matter\n-        }\n-      }\n-      switch (arg) {\n-        case T_INT: \/\/ fallthrough\n-        case T_FLOAT: \/\/ fallthrough\n-        case T_DOUBLE:\n-        case T_VOID:\n-          btarray.append((BasicType)arg);\n-          break;\n-        case T_LONG:\n-          long_prev = true;\n-          break;\n-        default: ShouldNotReachHere();\n-      }\n-    });\n-\n-    if (long_prev) {\n-      btarray.append(T_OBJECT);\n-    }\n-\n-    nargs = btarray.length();\n-    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nargs);\n-    int index = 0;\n-    GrowableArrayIterator<BasicType> iter = btarray.begin();\n-    while (iter != btarray.end()) {\n-      sig_bt[index++] = *iter;\n-      ++iter;\n-    }\n-    assert(index == btarray.length(), \"sanity check\");\n-#ifdef ASSERT\n-    {\n-      AdapterFingerPrint* compare_fp = AdapterFingerPrint::allocate(nargs, sig_bt);\n-      assert(this->equals(compare_fp), \"sanity check\");\n-      AdapterFingerPrint::deallocate(compare_fp);\n-    }\n-#endif\n-    return sig_bt;\n-  }\n-\n@@ -2461,1 +2533,1 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::lookup(int total_args_passed, BasicType* sig_bt) {\n+AdapterHandlerEntry* AdapterHandlerLibrary::lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter) {\n@@ -2464,1 +2536,1 @@\n-  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(total_args_passed, sig_bt);\n+  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(sig, has_ro_adapter);\n@@ -2521,1 +2593,1 @@\n-static const int AdapterHandlerLibrary_size = 16*K;\n+static const int AdapterHandlerLibrary_size = 48*K;\n@@ -2573,1 +2645,3 @@\n-    _no_arg_handler = create_adapter(no_arg_blob, 0, nullptr);\n+    CompiledEntrySignature no_args;\n+    no_args.compute_calling_conventions();\n+    _no_arg_handler = create_adapter(no_arg_blob, no_args, true);\n@@ -2575,2 +2649,4 @@\n-    BasicType obj_args[] = { T_OBJECT };\n-    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args);\n+    CompiledEntrySignature obj_args;\n+    SigEntry::add_entry(obj_args.sig(), T_OBJECT);\n+    obj_args.compute_calling_conventions();\n+    _obj_arg_handler = create_adapter(obj_arg_blob, obj_args, true);\n@@ -2578,2 +2654,4 @@\n-    BasicType int_args[] = { T_INT };\n-    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args);\n+    CompiledEntrySignature int_args;\n+    SigEntry::add_entry(int_args.sig(), T_INT);\n+    int_args.compute_calling_conventions();\n+    _int_arg_handler = create_adapter(int_arg_blob, int_args, true);\n@@ -2581,2 +2659,5 @@\n-    BasicType obj_int_args[] = { T_OBJECT, T_INT };\n-    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args);\n+    CompiledEntrySignature obj_int_args;\n+    SigEntry::add_entry(obj_int_args.sig(), T_OBJECT);\n+    SigEntry::add_entry(obj_int_args.sig(), T_INT);\n+    obj_int_args.compute_calling_conventions();\n+    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, obj_int_args, true);\n@@ -2584,2 +2665,5 @@\n-    BasicType obj_obj_args[] = { T_OBJECT, T_OBJECT };\n-    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args);\n+    CompiledEntrySignature obj_obj_args;\n+    SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT);\n+    SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT);\n+    obj_obj_args.compute_calling_conventions();\n+    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, obj_obj_args, true);\n@@ -2617,0 +2701,3 @@\n+      if (InlineTypePassFieldsAsArgs && method->method_holder()->is_inline_klass()) {\n+        return nullptr;\n+      }\n@@ -2620,1 +2707,10 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          InlineKlass* vk = ss.as_inline_klass(method->method_holder());\n+          if (vk != nullptr) {\n+            return nullptr;\n+          }\n+        }\n+        return _obj_arg_handler;\n+      }\n@@ -2631,1 +2727,1 @@\n-             !method->is_static()) {\n+             !method->is_static() && (!InlineTypePassFieldsAsArgs || !method->method_holder()->is_inline_klass())) {\n@@ -2633,1 +2729,10 @@\n-      case JVM_SIGNATURE_CLASS:\n+      case JVM_SIGNATURE_CLASS: {\n+        if (InlineTypePassFieldsAsArgs) {\n+          SignatureStream ss(method->signature());\n+          InlineKlass* vk = ss.as_inline_klass(method->method_holder());\n+          if (vk != nullptr) {\n+            return nullptr;\n+          }\n+        }\n+        return _obj_obj_arg_handler;\n+      }\n@@ -2647,5 +2752,9 @@\n-class AdapterSignatureIterator : public SignatureIterator {\n- private:\n-  BasicType stack_sig_bt[16];\n-  BasicType* sig_bt;\n-  int index;\n+CompiledEntrySignature::CompiledEntrySignature(Method* method) :\n+  _method(method), _num_inline_args(0), _has_inline_recv(false),\n+  _regs(nullptr), _regs_cc(nullptr), _regs_cc_ro(nullptr),\n+  _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),\n+  _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _supers(nullptr) {\n+  _sig = new GrowableArray<SigEntry>((method != nullptr) ? method->size_of_parameters() : 1);\n+  _sig_cc = new GrowableArray<SigEntry>((method != nullptr) ? method->size_of_parameters() : 1);\n+  _sig_cc_ro = new GrowableArray<SigEntry>((method != nullptr) ? method->size_of_parameters() : 1);\n+}\n@@ -2653,11 +2762,24 @@\n- public:\n-  AdapterSignatureIterator(Symbol* signature,\n-                           fingerprint_t fingerprint,\n-                           bool is_static,\n-                           int total_args_passed) :\n-    SignatureIterator(signature, fingerprint),\n-    index(0)\n-  {\n-    sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n-    if (!is_static) { \/\/ Pass in receiver first\n-      sig_bt[index++] = T_OBJECT;\n+\/\/ See if we can save space by sharing the same entry for VIEP and VIEP(RO),\n+\/\/ or the same entry for VEP and VIEP(RO).\n+CodeOffsets::Entries CompiledEntrySignature::c1_inline_ro_entry_type() const {\n+  if (!has_scalarized_args()) {\n+    \/\/ VEP\/VIEP\/VIEP(RO) all share the same entry. There's no packing.\n+    return CodeOffsets::Verified_Entry;\n+  }\n+  if (_method->is_static()) {\n+    \/\/ Static methods don't need VIEP(RO)\n+    return CodeOffsets::Verified_Entry;\n+  }\n+\n+  if (has_inline_recv()) {\n+    if (num_inline_args() == 1) {\n+      \/\/ Share same entry for VIEP and VIEP(RO).\n+      \/\/ This is quite common: we have an instance method in an InlineKlass that has\n+      \/\/ no inline type args other than <this>.\n+      return CodeOffsets::Verified_Inline_Entry;\n+    } else {\n+      assert(num_inline_args() > 1, \"must be\");\n+      \/\/ No sharing:\n+      \/\/   VIEP(RO) -- <this> is passed as object\n+      \/\/   VEP      -- <this> is passed as fields\n+      return CodeOffsets::Verified_Inline_Entry_RO;\n@@ -2665,1 +2787,0 @@\n-    do_parameters_on(this);\n@@ -2668,2 +2789,9 @@\n-  BasicType* basic_types() {\n-    return sig_bt;\n+  \/\/ Either a static method, or <this> is not an inline type\n+  if (args_on_stack_cc() != args_on_stack_cc_ro()) {\n+    \/\/ No sharing:\n+    \/\/ Some arguments are passed on the stack, and we have inserted reserved entries\n+    \/\/ into the VEP, but we never insert reserved entries into the VIEP(RO).\n+    return CodeOffsets::Verified_Inline_Entry_RO;\n+  } else {\n+    \/\/ Share same entry for VEP and VIEP(RO).\n+    return CodeOffsets::Verified_Entry;\n@@ -2671,0 +2799,1 @@\n+}\n@@ -2672,3 +2801,39 @@\n-#ifdef ASSERT\n-  int slots() {\n-    return index;\n+\/\/ Returns all super methods (transitive) in classes and interfaces that are overridden by the current method.\n+GrowableArray<Method*>* CompiledEntrySignature::get_supers() {\n+  if (_supers != nullptr) {\n+    return _supers;\n+  }\n+  _supers = new GrowableArray<Method*>();\n+  \/\/ Skip private, static, and <init> methods\n+  if (_method->is_private() || _method->is_static() || _method->is_object_constructor()) {\n+    return _supers;\n+  }\n+  Symbol* name = _method->name();\n+  Symbol* signature = _method->signature();\n+  const Klass* holder = _method->method_holder()->super();\n+  Symbol* holder_name = holder->name();\n+  ThreadInVMfromUnknown tiv;\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n+  Handle loader(current, _method->method_holder()->class_loader());\n+\n+  \/\/ Walk up the class hierarchy and search for super methods\n+  while (holder != nullptr) {\n+    Method* super_method = holder->lookup_method(name, signature);\n+    if (super_method == nullptr) {\n+      break;\n+    }\n+    if (!super_method->is_static() && !super_method->is_private() &&\n+        (!super_method->is_package_private() ||\n+         super_method->method_holder()->is_same_class_package(loader(), holder_name))) {\n+      _supers->push(super_method);\n+    }\n+    holder = super_method->method_holder()->super();\n+  }\n+  \/\/ Search interfaces for super methods\n+  Array<InstanceKlass*>* interfaces = _method->method_holder()->transitive_interfaces();\n+  for (int i = 0; i < interfaces->length(); ++i) {\n+    Method* m = interfaces->at(i)->lookup_method(name, signature);\n+    if (m != nullptr && !m->is_static() && m->is_public()) {\n+      _supers->push(m);\n+    }\n@@ -2676,0 +2841,50 @@\n+  return _supers;\n+}\n+\n+\/\/ Iterate over arguments and compute scalarized and non-scalarized signatures\n+void CompiledEntrySignature::compute_calling_conventions(bool init) {\n+  bool has_scalarized = false;\n+  if (_method != nullptr) {\n+    InstanceKlass* holder = _method->method_holder();\n+    int arg_num = 0;\n+    if (!_method->is_static()) {\n+      \/\/ We shouldn't scalarize 'this' in a value class constructor\n+      if (holder->is_inline_klass() && InlineKlass::cast(holder)->can_be_passed_as_fields() && !_method->is_object_constructor() &&\n+          (init || _method->is_scalarized_arg(arg_num))) {\n+        _sig_cc->appendAll(InlineKlass::cast(holder)->extended_sig());\n+        has_scalarized = true;\n+        _has_inline_recv = true;\n+        _num_inline_args++;\n+      } else {\n+        SigEntry::add_entry(_sig_cc, T_OBJECT, holder->name());\n+      }\n+      SigEntry::add_entry(_sig, T_OBJECT, holder->name());\n+      SigEntry::add_entry(_sig_cc_ro, T_OBJECT, holder->name());\n+      arg_num++;\n+    }\n+    for (SignatureStream ss(_method->signature()); !ss.at_return_type(); ss.next()) {\n+      BasicType bt = ss.type();\n+      if (bt == T_OBJECT) {\n+        InlineKlass* vk = ss.as_inline_klass(holder);\n+        if (vk != nullptr && vk->can_be_passed_as_fields() && (init || _method->is_scalarized_arg(arg_num))) {\n+          \/\/ Check for a calling convention mismatch with super method(s)\n+          bool scalar_super = false;\n+          bool non_scalar_super = false;\n+          GrowableArray<Method*>* supers = get_supers();\n+          for (int i = 0; i < supers->length(); ++i) {\n+            Method* super_method = supers->at(i);\n+            if (super_method->is_scalarized_arg(arg_num)) {\n+              scalar_super = true;\n+            } else {\n+              non_scalar_super = true;\n+            }\n+          }\n+#ifdef ASSERT\n+          \/\/ Randomly enable below code paths for stress testing\n+          bool stress = init && StressCallingConvention;\n+          if (stress && (os::random() & 1) == 1) {\n+            non_scalar_super = true;\n+            if ((os::random() & 1) == 1) {\n+              scalar_super = true;\n+            }\n+          }\n@@ -2677,0 +2892,50 @@\n+          if (non_scalar_super) {\n+            \/\/ Found a super method with a non-scalarized argument. Fall back to the non-scalarized calling convention.\n+            if (scalar_super) {\n+              \/\/ Found non-scalar *and* scalar super methods. We can't handle both.\n+              \/\/ Mark the scalar method as mismatch and re-compile call sites to use non-scalarized calling convention.\n+              for (int i = 0; i < supers->length(); ++i) {\n+                Method* super_method = supers->at(i);\n+                if (super_method->is_scalarized_arg(arg_num) DEBUG_ONLY(|| (stress && (os::random() & 1) == 1))) {\n+                  super_method->set_mismatch();\n+                  MutexLocker ml(Compile_lock, Mutex::_safepoint_check_flag);\n+                  JavaThread* thread = JavaThread::current();\n+                  HandleMark hm(thread);\n+                  methodHandle mh(thread, super_method);\n+                  DeoptimizationScope deopt_scope;\n+                  CodeCache::mark_for_deoptimization(&deopt_scope, mh());\n+                  deopt_scope.deoptimize_marked();\n+                }\n+              }\n+            }\n+            \/\/ Fall back to non-scalarized calling convention\n+            SigEntry::add_entry(_sig_cc, T_OBJECT, ss.as_symbol());\n+            SigEntry::add_entry(_sig_cc_ro, T_OBJECT, ss.as_symbol());\n+          } else {\n+            _num_inline_args++;\n+            has_scalarized = true;\n+            int last = _sig_cc->length();\n+            int last_ro = _sig_cc_ro->length();\n+            _sig_cc->appendAll(vk->extended_sig());\n+            _sig_cc_ro->appendAll(vk->extended_sig());\n+            if (bt == T_OBJECT) {\n+              \/\/ Nullable inline type argument, insert InlineTypeNode::NullMarker field right after T_METADATA delimiter\n+              _sig_cc->insert_before(last+1, SigEntry(T_BOOLEAN, -1, nullptr, true));\n+              _sig_cc_ro->insert_before(last_ro+1, SigEntry(T_BOOLEAN, -1, nullptr, true));\n+            }\n+          }\n+        } else {\n+          SigEntry::add_entry(_sig_cc, T_OBJECT, ss.as_symbol());\n+          SigEntry::add_entry(_sig_cc_ro, T_OBJECT, ss.as_symbol());\n+        }\n+        bt = T_OBJECT;\n+      } else {\n+        SigEntry::add_entry(_sig_cc, ss.type(), ss.as_symbol());\n+        SigEntry::add_entry(_sig_cc_ro, ss.type(), ss.as_symbol());\n+      }\n+      SigEntry::add_entry(_sig, bt, ss.as_symbol());\n+      if (bt != T_VOID) {\n+        arg_num++;\n+      }\n+    }\n+  }\n@@ -2678,1 +2943,3 @@\n- private:\n+  \/\/ Compute the non-scalarized calling convention\n+  _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig->length());\n+  _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);\n@@ -2680,5 +2947,16 @@\n-  friend class SignatureIterator;  \/\/ so do_parameters_on can call do_type\n-  void do_type(BasicType type) {\n-    sig_bt[index++] = type;\n-    if (type == T_LONG || type == T_DOUBLE) {\n-      sig_bt[index++] = T_VOID; \/\/ Longs & doubles take 2 Java slots\n+  \/\/ Compute the scalarized calling conventions if there are scalarized inline types in the signature\n+  if (has_scalarized && !_method->is_native()) {\n+    _regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc->length());\n+    _args_on_stack_cc = SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);\n+\n+    _regs_cc_ro = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc_ro->length());\n+    _args_on_stack_cc_ro = SharedRuntime::java_calling_convention(_sig_cc_ro, _regs_cc_ro);\n+\n+    _c1_needs_stack_repair = (_args_on_stack_cc < _args_on_stack) || (_args_on_stack_cc_ro < _args_on_stack);\n+    _c2_needs_stack_repair = (_args_on_stack_cc > _args_on_stack) || (_args_on_stack_cc > _args_on_stack_cc_ro);\n+\n+    \/\/ Upper bound on stack arguments to avoid hitting the argument limit and\n+    \/\/ bailing out of compilation (\"unsupported incoming calling sequence\").\n+    \/\/ TODO we need a reasonable limit (flag?) here\n+    if (MAX2(_args_on_stack_cc, _args_on_stack_cc_ro) <= 60) {\n+      return; \/\/ Success\n@@ -2687,1 +2965,132 @@\n-};\n+  \/\/ No scalarized args\n+  _sig_cc = _sig;\n+  _regs_cc = _regs;\n+  _args_on_stack_cc = _args_on_stack;\n+\n+  _sig_cc_ro = _sig;\n+  _regs_cc_ro = _regs;\n+  _args_on_stack_cc_ro = _args_on_stack;\n+}\n+\n+void CompiledEntrySignature::initialize_from_fingerprint(AdapterFingerPrint* fingerprint) {\n+  int value_object_count = 0;\n+  bool is_receiver = true;\n+  BasicType prev_bt = T_ILLEGAL;\n+  bool long_prev = false;\n+  bool has_scalarized_arguments = false;\n+\n+  fingerprint->iterate_args([&] (int arg) {\n+    BasicType bt = (BasicType)arg;\n+    if (long_prev) {\n+      long_prev = false;\n+      BasicType bt_to_add;\n+      if (bt == T_VOID) {\n+        bt_to_add = T_LONG;\n+      } else {\n+        bt_to_add = T_OBJECT; \/\/ it could be T_ARRAY; it shouldn't matter\n+      }\n+      SigEntry::add_entry(_sig_cc, bt_to_add);\n+      SigEntry::add_entry(_sig_cc_ro, bt_to_add);\n+      if (value_object_count == 0) {\n+        SigEntry::add_entry(_sig, bt_to_add);\n+      }\n+    }\n+    switch (bt) {\n+      case T_VOID:\n+        if (is_receiver) {\n+          \/\/ 'this' when ro adapter is available\n+          assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+          value_object_count++;\n+          has_scalarized_arguments = true;\n+          _has_inline_recv = true;\n+          SigEntry::add_entry(_sig, T_OBJECT);\n+          SigEntry::add_entry(_sig_cc, T_METADATA);\n+          SigEntry::add_entry(_sig_cc_ro, T_METADATA);\n+        } else if (prev_bt != T_LONG && prev_bt != T_DOUBLE) {\n+          assert(InlineTypePassFieldsAsArgs, \"unexpected end of inline type\");\n+          value_object_count--;\n+          SigEntry::add_entry(_sig_cc, T_VOID);\n+          SigEntry::add_entry(_sig_cc_ro, T_VOID);\n+          assert(value_object_count >= 0, \"invalid value object count\");\n+        } else {\n+          \/\/ Nothing to add for _sig: We already added an addition T_VOID in add_entry() when adding T_LONG or T_DOUBLE.\n+        }\n+        break;\n+      case T_INT:\n+      case T_FLOAT:\n+      case T_DOUBLE:\n+        if (value_object_count == 0) {\n+          SigEntry::add_entry(_sig, bt);\n+        }\n+        SigEntry::add_entry(_sig_cc, bt);\n+        SigEntry::add_entry(_sig_cc_ro, bt);\n+        break;\n+      case T_LONG:\n+        long_prev = true;\n+        break;\n+      case T_BOOLEAN:\n+      case T_CHAR:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_OBJECT:\n+      case T_ARRAY:\n+        assert(value_object_count > 0 && !is_receiver, \"must be value object field\");\n+        SigEntry::add_entry(_sig_cc, bt);\n+        SigEntry::add_entry(_sig_cc_ro, bt);\n+        break;\n+      case T_METADATA:\n+        assert(InlineTypePassFieldsAsArgs, \"unexpected start of inline type\");\n+        value_object_count++;\n+        has_scalarized_arguments = true;\n+        SigEntry::add_entry(_sig, T_OBJECT);\n+        SigEntry::add_entry(_sig_cc, T_METADATA);\n+        SigEntry::add_entry(_sig_cc_ro, T_METADATA);\n+        break;\n+      default: {\n+        fatal(\"Unexpected BasicType: %s\", basictype_to_str(bt));\n+      }\n+    }\n+    prev_bt = bt;\n+    is_receiver = false;\n+  });\n+\n+  if (long_prev) {\n+    \/\/ If previous bt was T_LONG and we reached the end of the signature, we know that it must be a T_OBJECT.\n+    SigEntry::add_entry(_sig, T_OBJECT);\n+    SigEntry::add_entry(_sig_cc, T_OBJECT);\n+    SigEntry::add_entry(_sig_cc_ro, T_OBJECT);\n+  }\n+  assert(value_object_count == 0, \"invalid value object count\");\n+\n+  _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig->length());\n+  _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);\n+\n+  \/\/ Compute the scalarized calling conventions if there are scalarized inline types in the signature\n+  if (has_scalarized_arguments) {\n+    _regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc->length());\n+    _args_on_stack_cc = SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);\n+\n+    _regs_cc_ro = NEW_RESOURCE_ARRAY(VMRegPair, _sig_cc_ro->length());\n+    _args_on_stack_cc_ro = SharedRuntime::java_calling_convention(_sig_cc_ro, _regs_cc_ro);\n+\n+    _c1_needs_stack_repair = (_args_on_stack_cc < _args_on_stack) || (_args_on_stack_cc_ro < _args_on_stack);\n+    _c2_needs_stack_repair = (_args_on_stack_cc > _args_on_stack) || (_args_on_stack_cc > _args_on_stack_cc_ro);\n+  } else {\n+    \/\/ No scalarized args\n+    _sig_cc = _sig;\n+    _regs_cc = _regs;\n+    _args_on_stack_cc = _args_on_stack;\n+\n+    _sig_cc_ro = _sig;\n+    _regs_cc_ro = _regs;\n+    _args_on_stack_cc_ro = _args_on_stack;\n+  }\n+\n+#ifdef ASSERT\n+  {\n+    AdapterFingerPrint* compare_fp = AdapterFingerPrint::allocate(_sig_cc, _has_inline_recv);\n+    assert(fingerprint->equals(compare_fp), \"sanity check\");\n+    AdapterFingerPrint::deallocate(compare_fp);\n+  }\n+#endif\n+}\n@@ -2695,1 +3104,1 @@\n-void AdapterHandlerLibrary::verify_adapter_sharing(int total_args_passed, BasicType* sig_bt, AdapterHandlerEntry* cached_entry) {\n+void AdapterHandlerLibrary::verify_adapter_sharing(CompiledEntrySignature& ces, AdapterHandlerEntry* cached_entry) {\n@@ -2699,1 +3108,1 @@\n-  AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, true);\n+  AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, ces, false, true);\n@@ -2724,2 +3133,13 @@\n-  \/\/ Fill in the signature array, for the calling-convention call.\n-  int total_args_passed = method->size_of_parameters(); \/\/ All args on stack\n+  CompiledEntrySignature ces(method());\n+  ces.compute_calling_conventions();\n+  if (ces.has_scalarized_args()) {\n+    if (!method->has_scalarized_args()) {\n+      method->set_has_scalarized_args();\n+    }\n+    if (ces.c1_needs_stack_repair()) {\n+      method->set_c1_needs_stack_repair();\n+    }\n+    if (ces.c2_needs_stack_repair() && !method->c2_needs_stack_repair()) {\n+      method->set_c2_needs_stack_repair();\n+    }\n+  }\n@@ -2727,4 +3147,0 @@\n-  AdapterSignatureIterator si(method->signature(), method->constMethod()->fingerprint(),\n-                              method->is_static(), total_args_passed);\n-  assert(si.slots() == total_args_passed, \"\");\n-  BasicType* sig_bt = si.basic_types();\n@@ -2734,0 +3150,13 @@\n+    if (ces.has_scalarized_args() && method->is_abstract()) {\n+      \/\/ Save a C heap allocated version of the signature for abstract methods with scalarized inline type arguments\n+      address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+      entry = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(nullptr));\n+      entry->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n+                              wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n+                              wrong_method_abstract, wrong_method_abstract);\n+      GrowableArray<SigEntry>* heap_sig = new (mtInternal) GrowableArray<SigEntry>(ces.sig_cc_ro()->length(), mtInternal);\n+      heap_sig->appendAll(ces.sig_cc_ro());\n+      entry->set_sig_cc(heap_sig);\n+      return entry;\n+    }\n+\n@@ -2735,1 +3164,1 @@\n-    entry = lookup(total_args_passed, sig_bt);\n+    entry = lookup(ces.sig_cc(), ces.has_inline_recv());\n@@ -2741,1 +3170,1 @@\n-        verify_adapter_sharing(total_args_passed, sig_bt, entry);\n+        verify_adapter_sharing(ces, entry);\n@@ -2745,1 +3174,1 @@\n-      entry = create_adapter(adapter_blob, total_args_passed, sig_bt);\n+      entry = create_adapter(adapter_blob, ces, \/* allocate_code_blob *\/ true);\n@@ -2773,1 +3202,4 @@\n-      (offsets[3] != -1) ? (i2c_entry + offsets[3]) : nullptr\n+      (offsets[3] != -1) ? (i2c_entry + offsets[3]) : nullptr,\n+      (offsets[4] != -1) ? (i2c_entry + offsets[4]) : nullptr,\n+      (offsets[5] != -1) ? (i2c_entry + offsets[5]) : nullptr,\n+      (offsets[6] != -1) ? (i2c_entry + offsets[6]) : nullptr\n@@ -2806,2 +3238,2 @@\n-                                                  int total_args_passed,\n-                                                  BasicType* sig_bt,\n+                                                  CompiledEntrySignature& ces,\n+                                                  bool allocate_code_blob,\n@@ -2819,2 +3251,0 @@\n-  VMRegPair stack_regs[16];\n-  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n@@ -2823,6 +3253,17 @@\n-  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n-                                         total_args_passed,\n-                                         comp_args_on_stack,\n-                                         sig_bt,\n-                                         regs,\n-                                         handler);\n+                                         ces.args_on_stack(),\n+                                         ces.sig(),\n+                                         ces.regs(),\n+                                         ces.sig_cc(),\n+                                         ces.regs_cc(),\n+                                         ces.sig_cc_ro(),\n+                                         ces.regs_cc_ro(),\n+                                         handler,\n+                                         adapter_blob,\n+                                         allocate_code_blob);\n+\n+  if (ces.has_scalarized_args()) {\n+    \/\/ Save a C heap allocated version of the scalarized signature and store it in the adapter\n+    GrowableArray<SigEntry>* heap_sig = new (mtInternal) GrowableArray<SigEntry>(ces.sig_cc()->length(), mtInternal);\n+    heap_sig->appendAll(ces.sig_cc());\n+    handler->set_sig_cc(heap_sig);\n+  }\n@@ -2844,12 +3285,0 @@\n-  int entry_offset[AdapterBlob::ENTRY_COUNT];\n-  assert(AdapterBlob::ENTRY_COUNT == 4, \"sanity\");\n-  address i2c_entry = handler->get_i2c_entry();\n-  entry_offset[0] = 0; \/\/ i2c_entry offset\n-  entry_offset[1] = (handler->get_c2i_entry() != nullptr) ?\n-                    (handler->get_c2i_entry() - i2c_entry) : -1;\n-  entry_offset[2] = (handler->get_c2i_unverified_entry() != nullptr) ?\n-                    (handler->get_c2i_unverified_entry() - i2c_entry) : -1;\n-  entry_offset[3] = (handler->get_c2i_no_clinit_check_entry() != nullptr) ?\n-                    (handler->get_c2i_no_clinit_check_entry() - i2c_entry) : -1;\n-\n-  adapter_blob = AdapterBlob::create(&buffer, entry_offset);\n@@ -2883,2 +3312,2 @@\n-                                                           int total_args_passed,\n-                                                           BasicType* sig_bt,\n+                                                           CompiledEntrySignature& ces,\n+                                                           bool allocate_code_blob,\n@@ -2886,1 +3315,6 @@\n-  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(total_args_passed, sig_bt);\n+  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(ces.sig_cc(), ces.has_inline_recv());\n+#ifdef ASSERT\n+  \/\/ Verify that we can successfully restore the compiled entry signature object.\n+  CompiledEntrySignature ces_verify;\n+  ces_verify.initialize_from_fingerprint(fp);\n+#endif\n@@ -2888,1 +3322,1 @@\n-  if (!generate_adapter_code(adapter_blob, handler, total_args_passed, sig_bt, is_transient)) {\n+  if (!generate_adapter_code(adapter_blob, handler, ces, allocate_code_blob, is_transient)) {\n@@ -2905,1 +3339,1 @@\n-  set_entry_points(nullptr, nullptr, nullptr, nullptr, false);\n+  set_entry_points(nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, false);\n@@ -2991,3 +3425,3 @@\n-    int nargs;\n-    BasicType* bt = _fingerprint->as_basic_type(nargs);\n-    if (!AdapterHandlerLibrary::generate_adapter_code(adapter_blob, this, nargs, bt, \/* is_transient *\/ false)) {\n+    CompiledEntrySignature ces;\n+    ces.initialize_from_fingerprint(_fingerprint);\n+    if (!AdapterHandlerLibrary::generate_adapter_code(adapter_blob, this, ces, true, false)) {\n@@ -3021,13 +3455,26 @@\n-  _no_arg_handler = lookup(0, nullptr);\n-\n-  BasicType obj_args[] = { T_OBJECT };\n-  _obj_arg_handler = lookup(1, obj_args);\n-\n-  BasicType int_args[] = { T_INT };\n-  _int_arg_handler = lookup(1, int_args);\n-\n-  BasicType obj_int_args[] = { T_OBJECT, T_INT };\n-  _obj_int_arg_handler = lookup(2, obj_int_args);\n-\n-  BasicType obj_obj_args[] = { T_OBJECT, T_OBJECT };\n-  _obj_obj_arg_handler = lookup(2, obj_obj_args);\n+  ResourceMark rm;\n+  CompiledEntrySignature no_args;\n+  no_args.compute_calling_conventions();\n+  _no_arg_handler = lookup(no_args.sig_cc(), no_args.has_inline_recv());\n+\n+  CompiledEntrySignature obj_args;\n+  SigEntry::add_entry(obj_args.sig(), T_OBJECT);\n+  obj_args.compute_calling_conventions();\n+  _obj_arg_handler = lookup(obj_args.sig_cc(), obj_args.has_inline_recv());\n+\n+  CompiledEntrySignature int_args;\n+  SigEntry::add_entry(int_args.sig(), T_INT);\n+  int_args.compute_calling_conventions();\n+  _int_arg_handler = lookup(int_args.sig_cc(), int_args.has_inline_recv());\n+\n+  CompiledEntrySignature obj_int_args;\n+  SigEntry::add_entry(obj_int_args.sig(), T_OBJECT);\n+  SigEntry::add_entry(obj_int_args.sig(), T_INT);\n+  obj_int_args.compute_calling_conventions();\n+  _obj_int_arg_handler = lookup(obj_int_args.sig_cc(), obj_int_args.has_inline_recv());\n+\n+  CompiledEntrySignature obj_obj_args;\n+  SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT);\n+  SigEntry::add_entry(obj_obj_args.sig(), T_OBJECT);\n+  obj_obj_args.compute_calling_conventions();\n+  _obj_obj_arg_handler = lookup(obj_obj_args.sig_cc(), obj_obj_args.has_inline_recv());\n@@ -3052,0 +3499,2 @@\n+  assert(base <= _c2i_inline_entry || _c2i_inline_entry == nullptr, \"\");\n+  assert(base <= _c2i_inline_ro_entry || _c2i_inline_ro_entry == nullptr, \"\");\n@@ -3053,0 +3502,1 @@\n+  assert(base <= _c2i_unverified_inline_entry || _c2i_unverified_inline_entry == nullptr, \"\");\n@@ -3065,0 +3515,4 @@\n+  if (_c2i_inline_entry != nullptr)\n+    _c2i_inline_entry += delta;\n+  if (_c2i_inline_ro_entry != nullptr)\n+    _c2i_inline_ro_entry += delta;\n@@ -3067,0 +3521,2 @@\n+  if (_c2i_unverified_inline_entry != nullptr)\n+    _c2i_unverified_inline_entry += delta;\n@@ -3086,0 +3542,3 @@\n+  if (_sig_cc != nullptr) {\n+    delete _sig_cc;\n+  }\n@@ -3173,0 +3632,1 @@\n+      BasicType stack_sig_bt[16];\n@@ -3174,0 +3634,1 @@\n+      BasicType* sig_bt = (total_args_passed <= 16) ? stack_sig_bt : NEW_RESOURCE_ARRAY(BasicType, total_args_passed);\n@@ -3176,5 +3637,13 @@\n-      AdapterSignatureIterator si(method->signature(), method->constMethod()->fingerprint(),\n-                              method->is_static(), total_args_passed);\n-      BasicType* sig_bt = si.basic_types();\n-      assert(si.slots() == total_args_passed, \"\");\n-      BasicType ret_type = si.return_type();\n+      int i = 0;\n+      if (!method->is_static()) {  \/\/ Pass in receiver first\n+        sig_bt[i++] = T_OBJECT;\n+      }\n+      SignatureStream ss(method->signature());\n+      for (; !ss.at_return_type(); ss.next()) {\n+        sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+        if (ss.type() == T_LONG || ss.type() == T_DOUBLE) {\n+          sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+        }\n+      }\n+      assert(i == total_args_passed, \"\");\n+      BasicType ret_type = ss.type();\n@@ -3463,0 +3932,6 @@\n+  if (get_c2i_entry() != nullptr) {\n+    st->print(\" c2iVE: \" INTPTR_FORMAT, p2i(get_c2i_inline_entry()));\n+  }\n+  if (get_c2i_entry() != nullptr) {\n+    st->print(\" c2iVROE: \" INTPTR_FORMAT, p2i(get_c2i_inline_ro_entry()));\n+  }\n@@ -3464,1 +3939,4 @@\n-    st->print(\" c2iUV: \" INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));\n+    st->print(\" c2iUE: \" INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));\n+  }\n+  if (get_c2i_unverified_entry() != nullptr) {\n+    st->print(\" c2iUVE: \" INTPTR_FORMAT, p2i(get_c2i_unverified_inline_entry()));\n@@ -3553,0 +4031,195 @@\n+\n+\/\/ We are at a compiled code to interpreter call. We need backing\n+\/\/ buffers for all inline type arguments. Allocate an object array to\n+\/\/ hold them (convenient because once we're done with it we don't have\n+\/\/ to worry about freeing it).\n+oop SharedRuntime::allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS) {\n+  assert(InlineTypePassFieldsAsArgs, \"no reason to call this\");\n+  ResourceMark rm;\n+\n+  int nb_slots = 0;\n+  InstanceKlass* holder = callee->method_holder();\n+  allocate_receiver &= !callee->is_static() && holder->is_inline_klass() && callee->is_scalarized_arg(0);\n+  if (allocate_receiver) {\n+    nb_slots++;\n+  }\n+  int arg_num = callee->is_static() ? 0 : 1;\n+  for (SignatureStream ss(callee->signature()); !ss.at_return_type(); ss.next()) {\n+    BasicType bt = ss.type();\n+    if (bt == T_OBJECT && callee->is_scalarized_arg(arg_num)) {\n+      nb_slots++;\n+    }\n+    if (bt != T_VOID) {\n+      arg_num++;\n+    }\n+  }\n+  objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);\n+  objArrayHandle array(THREAD, array_oop);\n+  arg_num = callee->is_static() ? 0 : 1;\n+  int i = 0;\n+  if (allocate_receiver) {\n+    InlineKlass* vk = InlineKlass::cast(holder);\n+    oop res = vk->allocate_instance(CHECK_NULL);\n+    array->obj_at_put(i++, res);\n+  }\n+  for (SignatureStream ss(callee->signature()); !ss.at_return_type(); ss.next()) {\n+    BasicType bt = ss.type();\n+    if (bt == T_OBJECT && callee->is_scalarized_arg(arg_num)) {\n+      InlineKlass* vk = ss.as_inline_klass(holder);\n+      assert(vk != nullptr, \"Unexpected klass\");\n+      oop res = vk->allocate_instance(CHECK_NULL);\n+      array->obj_at_put(i++, res);\n+    }\n+    if (bt != T_VOID) {\n+      arg_num++;\n+    }\n+  }\n+  return array();\n+}\n+\n+JRT_ENTRY(void, SharedRuntime::allocate_inline_types(JavaThread* current, Method* callee_method, bool allocate_receiver))\n+  methodHandle callee(current, callee_method);\n+  oop array = SharedRuntime::allocate_inline_types_impl(current, callee, allocate_receiver, CHECK);\n+  current->set_vm_result_oop(array);\n+  current->set_vm_result_metadata(callee()); \/\/ TODO: required to keep callee live?\n+JRT_END\n+\n+\/\/ We're returning from an interpreted method: load each field into a\n+\/\/ register following the calling convention\n+JRT_LEAF(void, SharedRuntime::load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res))\n+{\n+  assert(res->klass()->is_inline_klass(), \"only inline types here\");\n+  ResourceMark rm;\n+  RegisterMap reg_map(current,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip);\n+  frame stubFrame = current->last_frame();\n+  frame callerFrame = stubFrame.sender(&reg_map);\n+  assert(callerFrame.is_interpreted_frame(), \"should be coming from interpreter\");\n+\n+  InlineKlass* vk = InlineKlass::cast(res->klass());\n+\n+  const Array<SigEntry>* sig_vk = vk->extended_sig();\n+  const Array<VMRegPair>* regs = vk->return_regs();\n+\n+  if (regs == nullptr) {\n+    \/\/ The fields of the inline klass don't fit in registers, bail out\n+    return;\n+  }\n+\n+  int j = 1;\n+  for (int i = 0; i < sig_vk->length(); i++) {\n+    BasicType bt = sig_vk->at(i)._bt;\n+    if (bt == T_METADATA) {\n+      continue;\n+    }\n+    if (bt == T_VOID) {\n+      if (sig_vk->at(i-1)._bt == T_LONG ||\n+          sig_vk->at(i-1)._bt == T_DOUBLE) {\n+        j++;\n+      }\n+      continue;\n+    }\n+    int off = sig_vk->at(i)._offset;\n+    assert(off > 0, \"offset in object should be positive\");\n+    VMRegPair pair = regs->at(j);\n+    address loc = reg_map.location(pair.first(), nullptr);\n+    switch(bt) {\n+    case T_BOOLEAN:\n+      *(jboolean*)loc = res->bool_field(off);\n+      break;\n+    case T_CHAR:\n+      *(jchar*)loc = res->char_field(off);\n+      break;\n+    case T_BYTE:\n+      *(jbyte*)loc = res->byte_field(off);\n+      break;\n+    case T_SHORT:\n+      *(jshort*)loc = res->short_field(off);\n+      break;\n+    case T_INT: {\n+      *(jint*)loc = res->int_field(off);\n+      break;\n+    }\n+    case T_LONG:\n+#ifdef _LP64\n+      *(intptr_t*)loc = res->long_field(off);\n+#else\n+      Unimplemented();\n+#endif\n+      break;\n+    case T_OBJECT:\n+    case T_ARRAY: {\n+      *(oop*)loc = res->obj_field(off);\n+      break;\n+    }\n+    case T_FLOAT:\n+      *(jfloat*)loc = res->float_field(off);\n+      break;\n+    case T_DOUBLE:\n+      *(jdouble*)loc = res->double_field(off);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+    }\n+    j++;\n+  }\n+  assert(j == regs->length(), \"missed a field?\");\n+\n+#ifdef ASSERT\n+  VMRegPair pair = regs->at(0);\n+  address loc = reg_map.location(pair.first(), nullptr);\n+  assert(*(oopDesc**)loc == res, \"overwritten object\");\n+#endif\n+\n+  current->set_vm_result_oop(res);\n+}\n+JRT_END\n+\n+\/\/ We've returned to an interpreted method, the interpreter needs a\n+\/\/ reference to an inline type instance. Allocate it and initialize it\n+\/\/ from field's values in registers.\n+JRT_BLOCK_ENTRY(void, SharedRuntime::store_inline_type_fields_to_buf(JavaThread* current, intptr_t res))\n+{\n+  ResourceMark rm;\n+  RegisterMap reg_map(current,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip);\n+  frame stubFrame = current->last_frame();\n+  frame callerFrame = stubFrame.sender(&reg_map);\n+\n+#ifdef ASSERT\n+  InlineKlass* verif_vk = InlineKlass::returned_inline_klass(reg_map);\n+#endif\n+\n+  if (!is_set_nth_bit(res, 0)) {\n+    \/\/ We're not returning with inline type fields in registers (the\n+    \/\/ calling convention didn't allow it for this inline klass)\n+    assert(!Metaspace::contains((void*)res), \"should be oop or pointer in buffer area\");\n+    current->set_vm_result_oop((oopDesc*)res);\n+    assert(verif_vk == nullptr, \"broken calling convention\");\n+    return;\n+  }\n+\n+  clear_nth_bit(res, 0);\n+  InlineKlass* vk = (InlineKlass*)res;\n+  assert(verif_vk == vk, \"broken calling convention\");\n+  assert(Metaspace::contains((void*)res), \"should be klass\");\n+\n+  \/\/ Allocate handles for every oop field so they are safe in case of\n+  \/\/ a safepoint when allocating\n+  GrowableArray<Handle> handles;\n+  vk->save_oop_fields(reg_map, handles);\n+\n+  \/\/ It's unsafe to safepoint until we are here\n+  JRT_BLOCK;\n+  {\n+    JavaThread* THREAD = current;\n+    oop vt = vk->realloc_result(reg_map, handles, CHECK);\n+    current->set_vm_result_oop(vt);\n+  }\n+  JRT_BLOCK_END;\n+}\n+JRT_END\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":889,"deletions":216,"binary":false,"changes":1105,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"asm\/codeBuffer.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -41,0 +43,1 @@\n+class SigEntry;\n@@ -378,0 +381,2 @@\n+  static char* generate_identity_exception_message(JavaThread* thr, Klass* klass);\n+\n@@ -380,1 +385,1 @@\n-  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, TRAPS);\n+  static methodHandle resolve_helper(bool is_virtual, bool is_optimized, bool& caller_is_c1, TRAPS);\n@@ -388,1 +393,1 @@\n-                                             bool& needs_ic_stub_refill, TRAPS);\n+                                             bool& needs_ic_stub_refill, bool& is_optimized, bool caller_is_c1, TRAPS);\n@@ -394,1 +399,1 @@\n-  static methodHandle reresolve_call_site(TRAPS);\n+  static methodHandle reresolve_call_site(bool& is_static_call, bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -398,1 +403,1 @@\n-  static methodHandle handle_ic_miss_helper(TRAPS);\n+  static methodHandle handle_ic_miss_helper(bool& is_optimized, bool& caller_is_c1, TRAPS);\n@@ -401,1 +406,1 @@\n-  static methodHandle find_callee_method(TRAPS);\n+  static methodHandle find_callee_method(bool is_optimized, bool& caller_is_c1, TRAPS);\n@@ -432,0 +437,8 @@\n+  static int java_calling_convention(const GrowableArray<SigEntry>* sig, VMRegPair* regs) {\n+    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig->length());\n+    int total_args_passed = SigEntry::fill_sig_bt(sig, sig_bt);\n+    return java_calling_convention(sig_bt, regs, total_args_passed);\n+  }\n+  static int java_return_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed);\n+  static const uint java_return_convention_max_int;\n+  static const uint java_return_convention_max_float;\n@@ -478,6 +491,11 @@\n-  static void generate_i2c2i_adapters(MacroAssembler *_masm,\n-                               int total_args_passed,\n-                               int max_arg,\n-                               const BasicType *sig_bt,\n-                               const VMRegPair *regs,\n-                               AdapterHandlerEntry* handler);\n+  static void generate_i2c2i_adapters(MacroAssembler* _masm,\n+                                      int total_args_passed,\n+                                      const GrowableArray<SigEntry>* sig,\n+                                      const VMRegPair* regs,\n+                                      const GrowableArray<SigEntry>* sig_cc,\n+                                      const VMRegPair* regs_cc,\n+                                      const GrowableArray<SigEntry>* sig_cc_ro,\n+                                      const VMRegPair* regs_cc_ro,\n+                                      AdapterHandlerEntry* handler,\n+                                      AdapterBlob*& new_adapter,\n+                                      bool allocate_code_blob);\n@@ -486,2 +504,1 @@\n-                              int total_args_passed,\n-                              const BasicType *sig_bt,\n+                              const GrowableArray<SigEntry>* sig,\n@@ -561,1 +578,2 @@\n-  static address get_resolved_entry        (JavaThread* current, methodHandle callee_method);\n+  static address get_resolved_entry        (JavaThread* current, methodHandle callee_method,\n+                                            bool is_static_call, bool is_optimized, bool caller_is_c1);\n@@ -566,0 +584,3 @@\n+  static void load_inline_type_fields_in_regs(JavaThread* current, oopDesc* res);\n+  static void store_inline_type_fields_to_buf(JavaThread* current, intptr_t res);\n+\n@@ -576,0 +597,2 @@\n+  static void allocate_inline_types(JavaThread* current, Method* callee, bool allocate_receiver);\n+  static oop allocate_inline_types_impl(JavaThread* current, methodHandle callee, bool allocate_receiver, TRAPS);\n@@ -579,0 +602,1 @@\n+  static BufferedInlineTypeBlob* generate_buffered_inline_type_adapter(const InlineKlass* vk);\n@@ -684,1 +708,1 @@\n-  static const int ENTRIES_COUNT = 4;\n+  static const int ENTRIES_COUNT = 7;\n@@ -690,0 +714,2 @@\n+  address _c2i_inline_entry;\n+  address _c2i_inline_ro_entry;\n@@ -691,0 +717,1 @@\n+  address _c2i_unverified_inline_entry;\n@@ -696,0 +723,3 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  const GrowableArray<SigEntry>* _sig_cc;\n+\n@@ -707,0 +737,2 @@\n+    _c2i_inline_entry(nullptr),\n+    _c2i_inline_ro_entry(nullptr),\n@@ -708,0 +740,1 @@\n+    _c2i_unverified_inline_entry(nullptr),\n@@ -709,1 +742,2 @@\n-    _linked(false)\n+    _linked(false),\n+    _sig_cc(nullptr)\n@@ -737,1 +771,4 @@\n-  void set_entry_points(address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry, bool linked = true) {\n+  void set_entry_points(address i2c_entry, address c2i_entry, address c2i_inline_entry, address c2i_inline_ro_entry,\n+                        address c2i_unverified_entry, address c2i_unverified_inline_entry,\n+                        address c2i_no_clinit_check_entry = nullptr,\n+                        bool linked = true) {\n@@ -740,0 +777,2 @@\n+    _c2i_inline_entry = c2i_inline_entry;\n+    _c2i_inline_ro_entry = c2i_inline_ro_entry;\n@@ -741,0 +780,1 @@\n+    _c2i_unverified_inline_entry = c2i_unverified_inline_entry;\n@@ -745,4 +785,7 @@\n-  address get_i2c_entry()                  const { return _i2c_entry; }\n-  address get_c2i_entry()                  const { return _c2i_entry; }\n-  address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }\n-  address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }\n+  address get_i2c_entry()                   const { return _i2c_entry; }\n+  address get_c2i_entry()                   const { return _c2i_entry; }\n+  address get_c2i_inline_entry()            const { return _c2i_inline_entry; }\n+  address get_c2i_inline_ro_entry()         const { return _c2i_inline_ro_entry; }\n+  address get_c2i_unverified_entry()        const { return _c2i_unverified_entry; }\n+  address get_c2i_unverified_inline_entry() const { return _c2i_unverified_inline_entry; }\n+  address get_c2i_no_clinit_check_entry()   const { return _c2i_no_clinit_check_entry; }\n@@ -759,0 +802,4 @@\n+  \/\/ Support for scalarized inline type calling convention\n+  void set_sig_cc(const GrowableArray<SigEntry>* sig)  { _sig_cc = sig; }\n+  const GrowableArray<SigEntry>* get_sig_cc()    const { return _sig_cc; }\n+\n@@ -782,0 +829,2 @@\n+class CompiledEntrySignature;\n+\n@@ -800,2 +849,2 @@\n-                                             int total_args_passed,\n-                                             BasicType* sig_bt,\n+                                             CompiledEntrySignature& ces,\n+                                             bool allocate_code_blob,\n@@ -812,1 +861,1 @@\n-  static AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt);\n+  static AdapterHandlerEntry* lookup(const GrowableArray<SigEntry>* sig, bool has_ro_adapter = false);\n@@ -815,2 +864,2 @@\n-                                    int total_args_passed,\n-                                    BasicType* sig_bt,\n+                                    CompiledEntrySignature& ces,\n+                                    bool allocate_code_blob,\n@@ -820,1 +869,1 @@\n-  static void verify_adapter_sharing(int total_args_passed, BasicType* sig_bt, AdapterHandlerEntry* cached);\n+  static void verify_adapter_sharing(CompiledEntrySignature& ces, AdapterHandlerEntry* cached_entry);\n@@ -838,0 +887,60 @@\n+\/\/ Utility class for computing the calling convention of the 3 types\n+\/\/ of compiled method entries:\n+\/\/     Method::_from_compiled_entry               - sig_cc\n+\/\/     Method::_from_compiled_inline_ro_entry     - sig_cc_ro\n+\/\/     Method::_from_compiled_inline_entry        - sig\n+class CompiledEntrySignature : public StackObj {\n+  Method* _method;\n+  int  _num_inline_args;\n+  bool _has_inline_recv;\n+  GrowableArray<SigEntry>* _sig;\n+  GrowableArray<SigEntry>* _sig_cc;\n+  GrowableArray<SigEntry>* _sig_cc_ro;\n+  VMRegPair* _regs;\n+  VMRegPair* _regs_cc;\n+  VMRegPair* _regs_cc_ro;\n+\n+  int _args_on_stack;\n+  int _args_on_stack_cc;\n+  int _args_on_stack_cc_ro;\n+\n+  bool _c1_needs_stack_repair;\n+  bool _c2_needs_stack_repair;\n+\n+  GrowableArray<Method*>* _supers;\n+\n+public:\n+  Method* method()                     const { return _method; }\n+\n+  \/\/ Used by Method::_from_compiled_inline_entry\n+  GrowableArray<SigEntry>* sig()       const { return _sig; }\n+\n+  \/\/ Used by Method::_from_compiled_entry\n+  GrowableArray<SigEntry>* sig_cc()    const { return _sig_cc; }\n+\n+  \/\/ Used by Method::_from_compiled_inline_ro_entry\n+  GrowableArray<SigEntry>* sig_cc_ro() const { return _sig_cc_ro; }\n+\n+  VMRegPair* regs()                    const { return _regs; }\n+  VMRegPair* regs_cc()                 const { return _regs_cc; }\n+  VMRegPair* regs_cc_ro()              const { return _regs_cc_ro; }\n+\n+  int args_on_stack()                  const { return _args_on_stack; }\n+  int args_on_stack_cc()               const { return _args_on_stack_cc; }\n+  int args_on_stack_cc_ro()            const { return _args_on_stack_cc_ro; }\n+\n+  int  num_inline_args()               const { return _num_inline_args; }\n+  bool has_inline_recv()               const { return _has_inline_recv; }\n+\n+  bool has_scalarized_args()           const { return _sig != _sig_cc; }\n+  bool c1_needs_stack_repair()         const { return _c1_needs_stack_repair; }\n+  bool c2_needs_stack_repair()         const { return _c2_needs_stack_repair; }\n+  CodeOffsets::Entries c1_inline_ro_entry_type() const;\n+\n+  GrowableArray<Method*>* get_supers();\n+\n+  CompiledEntrySignature(Method* method = nullptr);\n+  void compute_calling_conventions(bool init = true);\n+  void initialize_from_fingerprint(AdapterFingerPrint* fingerprint);\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":136,"deletions":27,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -50,1 +52,1 @@\n-\/\/ FieldType  = \"B\" | \"C\" | \"D\" | \"F\" | \"I\" | \"J\" | \"S\" | \"Z\" | \"L\" ClassName \";\" | \"[\" FieldType.\n+\/\/ FieldType  = \"B\" | \"C\" | \"D\" | \"F\" | \"I\" | \"J\" | \"S\" | \"Z\" | \"L\" ClassName \";\" | \"Q\" ValueClassName \";\" | \"[\" FieldType.\n@@ -502,0 +504,14 @@\n+InlineKlass* SignatureStream::as_inline_klass(InstanceKlass* holder) {\n+  ThreadInVMfromUnknown tiv;\n+  JavaThread* THREAD = JavaThread::current();\n+  HandleMark hm(THREAD);\n+  Handle class_loader(THREAD, holder->class_loader());\n+  Klass* k = as_klass(class_loader, SignatureStream::CachedOrNull, THREAD);\n+  assert(!HAS_PENDING_EXCEPTION, \"Should never throw\");\n+  if (k != nullptr && k->is_inline_klass()) {\n+    return InlineKlass::cast(k);\n+  } else {\n+    return nullptr;\n+  }\n+}\n+\n@@ -576,1 +592,0 @@\n-\n@@ -595,1 +610,1 @@\n-bool SignatureVerifier::is_valid_method_signature(Symbol* sig) {\n+bool SignatureVerifier::is_valid_method_signature(const Symbol* sig) {\n@@ -618,1 +633,1 @@\n-bool SignatureVerifier::is_valid_type_signature(Symbol* sig) {\n+bool SignatureVerifier::is_valid_type_signature(const Symbol* sig) {\n@@ -665,0 +680,56 @@\n+\n+\/\/ Adds an argument to the signature\n+void SigEntry::add_entry(GrowableArray<SigEntry>* sig, BasicType bt, Symbol* name, int offset) {\n+  sig->append(SigEntry(bt, offset, name, false));\n+  if (bt == T_LONG || bt == T_DOUBLE) {\n+    sig->append(SigEntry(T_VOID, offset, name, false)); \/\/ Longs and doubles take two stack slots\n+  }\n+}\n+void SigEntry::add_null_marker(GrowableArray<SigEntry>* sig, Symbol* name, int offset) {\n+  sig->append(SigEntry(T_BOOLEAN, offset, name, true));\n+}\n+\n+\/\/ Returns true if the argument at index 'i' is not an inline type delimiter\n+bool SigEntry::skip_value_delimiters(const GrowableArray<SigEntry>* sig, int i) {\n+  return (sig->at(i)._bt != T_METADATA &&\n+          (sig->at(i)._bt != T_VOID || sig->at(i-1)._bt == T_LONG || sig->at(i-1)._bt == T_DOUBLE));\n+}\n+\n+\/\/ Fill basic type array from signature array\n+int SigEntry::fill_sig_bt(const GrowableArray<SigEntry>* sig, BasicType* sig_bt) {\n+  int count = 0;\n+  for (int i = 0; i < sig->length(); i++) {\n+    if (skip_value_delimiters(sig, i)) {\n+      sig_bt[count++] = sig->at(i)._bt;\n+    }\n+  }\n+  return count;\n+}\n+\n+\/\/ Create a temporary symbol from the signature array\n+TempNewSymbol SigEntry::create_symbol(const GrowableArray<SigEntry>* sig) {\n+  ResourceMark rm;\n+  int length = sig->length();\n+  char* sig_str = NEW_RESOURCE_ARRAY(char, 2*length + 3);\n+  int idx = 0;\n+  sig_str[idx++] = '(';\n+  for (int i = 0; i < length; i++) {\n+    BasicType bt = sig->at(i)._bt;\n+    if (bt == T_METADATA || bt == T_VOID) {\n+      \/\/ Ignore\n+    } else {\n+      if (bt == T_ARRAY) {\n+        bt = T_OBJECT; \/\/ We don't know the element type, treat as Object\n+      }\n+      sig_str[idx++] = type2char(bt);\n+      if (bt == T_OBJECT) {\n+        sig_str[idx++] = ';';\n+      }\n+    }\n+  }\n+  sig_str[idx++] = ')';\n+  \/\/ Add a dummy return type. It won't be used but SignatureStream needs it.\n+  sig_str[idx++] = 'V';\n+  sig_str[idx++] = '\\0';\n+  return SymbolTable::new_symbol(sig_str);\n+}\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":75,"deletions":4,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  _callee_augmented = false;\n@@ -64,0 +65,2 @@\n+  } else {\n+    _unextended_sp = _sp;\n@@ -65,1 +68,0 @@\n-  DEBUG_ONLY(else _unextended_sp = nullptr;)\n@@ -89,0 +91,2 @@\n+  } else {\n+    _unextended_sp = _sp;\n@@ -90,1 +94,0 @@\n-  DEBUG_ONLY(else _unextended_sp = nullptr;)\n@@ -93,0 +96,1 @@\n+  _callee_augmented = false;\n@@ -219,0 +223,1 @@\n+  _callee_augmented = false;\n@@ -227,1 +232,8 @@\n-      _unextended_sp = is_interpreted() ? unextended_sp_for_interpreter_frame() : _sp;\n+      if (is_interpreted()) {\n+        _unextended_sp = unextended_sp_for_interpreter_frame();\n+      } else if (cb()->is_nmethod() && cb()->as_nmethod()->needs_stack_repair()) {\n+        _unextended_sp = frame::repair_sender_sp(cb()->as_nmethod(), _unextended_sp, (intptr_t**)(_sp - frame::sender_sp_offset));\n+        _callee_augmented = _unextended_sp != _sp;\n+      } else {\n+        _unextended_sp = _sp;\n+      }\n@@ -231,1 +243,7 @@\n-    _sp += cb()->frame_size();\n+    _sp = _unextended_sp + cb()->frame_size();\n+    if (cb()->is_nmethod() && cb()->as_nmethod()->needs_stack_repair()) {\n+      _unextended_sp = frame::repair_sender_sp(cb()->as_nmethod(), _unextended_sp, (intptr_t**)(_sp - frame::sender_sp_offset));\n+      _callee_augmented = _unextended_sp != _sp;\n+    } else {\n+      _unextended_sp = _sp;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -103,0 +103,5 @@\n+\/\/ TODO: update with 8343767\n+address StubRoutines::_load_inline_type_fields_in_regs = nullptr;\n+address StubRoutines::_store_inline_type_fields_to_buf = nullptr;\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -317,0 +317,16 @@\n+\/\/ These checks are required for wait, notify and exit to avoid inflating the monitor to\n+\/\/ find out this inline type object cannot be locked.\n+#define CHECK_THROW_NOSYNC_IMSE(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;           \\\n+    ResourceMark rm(THREAD);                \\\n+    THROW_MSG(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n+#define CHECK_THROW_NOSYNC_IMSE_0(obj)  \\\n+  if (EnableValhalla && (obj)->mark().is_inline_type()) {  \\\n+    JavaThread* THREAD = current;             \\\n+    ResourceMark rm(THREAD);                  \\\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalMonitorStateException(), obj->klass()->external_name()); \\\n+  }\n+\n@@ -343,0 +359,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -400,0 +417,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"monitor op on inline type\");\n@@ -515,0 +533,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"JITed code should never have locked an instance of a value class\");\n@@ -537,0 +556,1 @@\n+  assert(!EnableValhalla || !obj->klass()->is_inline_klass(), \"This method should never be called on an instance of an inline class\");\n@@ -556,0 +576,1 @@\n+  guarantee(!EnableValhalla || !obj->klass()->is_inline_klass(), \"Attempt to inflate inline type\");\n@@ -603,0 +624,3 @@\n+    if (EnableValhalla && mark.is_inline_type()) {\n+      return;\n+    }\n@@ -659,0 +683,1 @@\n+  JavaThread* THREAD = current;\n@@ -667,0 +692,10 @@\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+    ResourceMark rm(THREAD);\n+    const char* desc = \"Cannot synchronize on an instance of value class \";\n+    const char* className = obj->klass()->external_name();\n+    size_t msglen = strlen(desc) + strlen(className) + 1;\n+    char* message = NEW_RESOURCE_ARRAY(char, msglen);\n+    assert(message != nullptr, \"NEW_RESOURCE_ARRAY should have called vm_exit_out_of_memory and not return nullptr\");\n+    THROW_MSG(vmSymbols::java_lang_IdentityException(), className);\n+  }\n+\n@@ -694,0 +729,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -738,0 +774,1 @@\n+  CHECK_THROW_NOSYNC_IMSE_0(obj);\n@@ -780,0 +817,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -808,0 +846,1 @@\n+  CHECK_THROW_NOSYNC_IMSE(obj);\n@@ -989,0 +1028,4 @@\n+  if (EnableValhalla && obj->klass()->is_inline_klass()) {\n+    \/\/ VM should be calling bootstrap method\n+    ShouldNotReachHere();\n+  }\n@@ -1115,0 +1158,3 @@\n+  if (EnableValhalla && h_obj->mark().is_inline_type()) {\n+    return false;\n+  }\n@@ -1458,0 +1504,3 @@\n+  if (EnableValhalla) {\n+    guarantee(!object->klass()->is_inline_klass(), \"Attempt to inflate inline type\");\n+  }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -411,0 +411,1 @@\n+  initialize_class(vmSymbols::java_lang_IdentityException(), CHECK);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -645,0 +645,4 @@\n+\n+void VM_PrintClassLayout::doit() {\n+  PrintClassLayout::print_class_layout(_out, _class_name);\n+}\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -277,0 +277,10 @@\n+class VM_PrintClassLayout: public VM_Operation {\n+ private:\n+  outputStream* _out;\n+  char* _class_name;\n+ public:\n+  VM_PrintClassLayout(outputStream* st, char* class_name): _out(st), _class_name(class_name) {}\n+  VMOp_Type type() const { return VMOp_PrintClassHierarchy; }\n+  void doit();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/inlineKlass.hpp\"\n@@ -940,1 +942,3 @@\n-           declare_type(ObjArrayKlass, ArrayKlass)                        \\\n+           declare_type(ObjArrayKlass, ArrayKlass)                        \\\n+             declare_type(FlatArrayKlass, ArrayKlass)                     \\\n+             declare_type(RefArrayKlass, ArrayKlass)                      \\\n@@ -943,0 +947,1 @@\n+        declare_type(InlineKlass, InstanceKlass)                          \\\n@@ -1408,1 +1413,1 @@\n-  declare_constant(Klass::_lh_array_tag_obj_value)                        \\\n+  declare_constant(Klass::_lh_array_tag_ref_value)                        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -48,0 +50,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -319,0 +322,22 @@\n+ * HPROF_FLAT_ARRAYS        list of flat arrays\n+ *\n+ *               [flat array sub-records]*\n+ *\n+ *               HPROF_FLAT_ARRAY      flat array\n+ *\n+ *                          id         array object ID (dumped as HPROF_GC_PRIM_ARRAY_DUMP)\n+ *                          id         element class ID (dumped by HPROF_GC_CLASS_DUMP)\n+ *\n+ * HPROF_INLINED_FIELDS     decribes inlined fields\n+ *\n+ *               [class with inlined fields sub-records]*\n+ *\n+ *               HPROF_CLASS_WITH_INLINED_FIELDS\n+ *\n+ *                          id         class ID (dumped as HPROF_GC_CLASS_DUMP)\n+ *\n+ *                          u2         number of instance inlined fields (not including super)\n+ *                          [u2,       inlined field index,\n+ *                           u2,       synthetic field count,\n+ *                           id,       original field name,\n+ *                           id]*      inlined field class ID (dumped by HPROF_GC_CLASS_DUMP)\n@@ -356,0 +381,7 @@\n+  \/\/ inlined object support\n+  HPROF_FLAT_ARRAYS             = 0x12,\n+  HPROF_INLINED_FIELDS          = 0x13,\n+  \/\/ inlined object subrecords\n+  HPROF_FLAT_ARRAY                  = 0x01,\n+  HPROF_CLASS_WITH_INLINED_FIELDS   = 0x01,\n+\n@@ -390,0 +422,65 @@\n+\n+class AbstractDumpWriter;\n+\n+class InlinedObjects {\n+\n+  struct ClassInlinedFields {\n+    const Klass *klass;\n+    uintx base_index;   \/\/ base index of the inlined field names (1st field has index base_index+1).\n+    ClassInlinedFields(const Klass *klass = nullptr, uintx base_index = 0) : klass(klass), base_index(base_index) {}\n+\n+    \/\/ For GrowableArray::find_sorted().\n+    static int compare(const ClassInlinedFields& a, const ClassInlinedFields& b) {\n+      return a.klass - b.klass;\n+    }\n+    \/\/ For GrowableArray::sort().\n+    static int compare(ClassInlinedFields* a, ClassInlinedFields* b) {\n+      return compare(*a, *b);\n+    }\n+  };\n+\n+  uintx _min_string_id;\n+  uintx _max_string_id;\n+\n+  GrowableArray<ClassInlinedFields> *_inlined_field_map;\n+\n+  \/\/ counters for classes with inlined fields and for the fields\n+  int _classes_count;\n+  int _inlined_fields_count;\n+\n+  static InlinedObjects *_instance;\n+\n+  static void inlined_field_names_callback(InlinedObjects* _this, const Klass *klass, uintx base_index, int count);\n+\n+  GrowableArray<oop> *_flat_arrays;\n+\n+public:\n+  InlinedObjects()\n+    : _min_string_id(0), _max_string_id(0),\n+    _inlined_field_map(nullptr),\n+    _classes_count(0), _inlined_fields_count(0),\n+    _flat_arrays(nullptr) {\n+  }\n+\n+  static InlinedObjects* get_instance() {\n+    return _instance;\n+  }\n+\n+  void init();\n+  void release();\n+\n+  void dump_inlined_field_names(AbstractDumpWriter *writer);\n+\n+  uintx get_base_index_for(Klass* k);\n+  uintx get_next_string_id(uintx id);\n+\n+  void dump_classed_with_inlined_fields(AbstractDumpWriter* writer);\n+\n+  void add_flat_array(oop array);\n+  void dump_flat_arrays(AbstractDumpWriter* writer);\n+\n+};\n+\n+InlinedObjects *InlinedObjects::_instance = nullptr;\n+\n+\n@@ -746,1 +843,1 @@\n-  \/\/ returns the size of the instance of the given class\n+  \/\/ calculates the total size of the all fields of the given class.\n@@ -759,2 +856,8 @@\n-  \/\/ dump the raw values of the instance fields of the given object\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry);\n+  \/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+  \/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+  \/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry);\n+  \/\/ dump the raw values of the instance fields of the given inlined object;\n+  \/\/ dump_instance_fields wrapper for inlined objects\n+  static void dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry);\n+\n@@ -764,1 +867,1 @@\n-  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* k, uintx *inlined_fields_index = nullptr);\n@@ -774,0 +877,2 @@\n+  \/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+  static void dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array, DumperClassCacheTable* class_cache);\n@@ -781,0 +886,3 @@\n+  \/\/ extended version to dump flat arrays as primitive arrays;\n+  \/\/ type_size specifies size of the inlined objects.\n+  static int calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size);\n@@ -796,0 +904,10 @@\n+  \/\/ helper methods for inlined fields.\n+  static bool is_inlined_field(const fieldDescriptor& fld) {\n+    return fld.is_flat();\n+  }\n+  static InlineKlass* get_inlined_field_klass(const fieldDescriptor& fld) {\n+    assert(is_inlined_field(fld), \"must be inlined field\");\n+    InstanceKlass* holder_klass = fld.field_holder();\n+    return InlineKlass::cast(holder_klass->get_inline_type_field_klass(fld.index()));\n+  }\n+\n@@ -820,0 +938,1 @@\n+  GrowableArray<InlineKlass*> _inline_klasses;\n@@ -828,0 +947,3 @@\n+  void push_sig_start_inlined() { _sigs_start.push('Q'); }\n+  bool is_inlined(int field_idx){ return _sigs_start.at(field_idx) == 'Q'; }\n+  InlineKlass* inline_klass(int field_idx) { assert(is_inlined(field_idx), \"Not inlined\"); return _inline_klasses.at(field_idx); }\n@@ -876,2 +998,11 @@\n-          Symbol* sig = fld.signature();\n-          entry->_sigs_start.push(sig->char_at(0));\n+          InlineKlass* inlineKlass = nullptr;\n+          if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n+            inlineKlass = DumperSupport::get_inlined_field_klass(fld.field_descriptor());\n+            entry->push_sig_start_inlined();\n+            entry->_instance_size += DumperSupport::instance_size(inlineKlass);\n+          } else {\n+            Symbol* sig = fld.signature();\n+            entry->_sigs_start.push(sig->char_at(0));\n+            entry->_instance_size += DumperSupport::sig2size(sig);\n+          }\n+          entry->_inline_klasses.push(inlineKlass);\n@@ -880,1 +1011,0 @@\n-          entry->_instance_size += DumperSupport::sig2size(sig);\n@@ -990,0 +1120,1 @@\n+\n@@ -1048,1 +1179,1 @@\n-\/\/ returns the size of the instance of the given class\n+\/\/ calculates the total size of the all fields of the given class.\n@@ -1056,1 +1187,5 @@\n-        size += sig2size(fld.signature());\n+        if (is_inlined_field(fld.field_descriptor())) {\n+          size += instance_size(get_inlined_field_klass(fld.field_descriptor()));\n+        } else {\n+          size += sig2size(fld.signature());\n+        }\n@@ -1069,0 +1204,2 @@\n+      assert(!is_inlined_field(fldc.field_descriptor()), \"static fields cannot be inlined\");\n+\n@@ -1111,0 +1248,2 @@\n+      assert(!is_inlined_field(fld.field_descriptor()), \"static fields cannot be inlined\");\n+\n@@ -1147,2 +1286,4 @@\n-\/\/ dump the raw values of the instance fields of the given object\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry) {\n+\/\/ dump the raw values of the instance fields of the given identity or inlined object;\n+\/\/ for identity objects offset is 0 and 'klass' is o->klass(),\n+\/\/ for inlined objects offset is the offset in the holder object, 'klass' is inlined object class.\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry) {\n@@ -1151,1 +1292,8 @@\n-    dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    if (class_cache_entry->is_inlined(idx)) {\n+      InlineKlass* field_klass = class_cache_entry->inline_klass(idx);\n+      int fields_offset = offset + (class_cache_entry->offset(idx) - field_klass->payload_offset());\n+      DumperClassCacheTableEntry* inline_class_cache_entry = class_cache->lookup_or_create(field_klass);\n+      dump_inlined_object_fields(writer, o, fields_offset, class_cache, inline_class_cache_entry);\n+    } else {\n+      dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n+    }\n@@ -1155,1 +1303,6 @@\n-\/\/ dumps the definition of the instance fields for a given class\n+void DumperSupport::dump_inlined_object_fields(AbstractDumpWriter* writer, oop o, int offset, DumperClassCacheTable* class_cache, DumperClassCacheTableEntry* class_cache_entry) {\n+  \/\/ the object is inlined, so all its fields are stored without headers.\n+  dump_instance_fields(writer, o, offset, class_cache, class_cache_entry);\n+}\n+\n+\/\/ gets the count of the instance fields for a given class\n@@ -1160,1 +1313,8 @@\n-    if (!fldc.access_flags().is_static()) field_count++;\n+    if (!fldc.access_flags().is_static()) {\n+      if (is_inlined_field(fldc.field_descriptor())) {\n+        \/\/ add \"synthetic\" fields for inlined fields.\n+        field_count += get_instance_fields_count(get_inlined_field_klass(fldc.field_descriptor()));\n+      } else {\n+        field_count++;\n+      }\n+    }\n@@ -1167,2 +1327,8 @@\n-void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+\/\/ inlined_fields_id is not-nullptr for inlined fields (to get synthetic field name IDs\n+\/\/ by using InlinedObjects::get_next_string_id()).\n+void DumperSupport::dump_instance_field_descriptors(AbstractDumpWriter* writer, InstanceKlass* ik, uintx* inlined_fields_id) {\n+  \/\/ inlined_fields_id != nullptr means ik is a class of inlined field.\n+  \/\/ Inlined field id pointer for this class; lazyly initialized\n+  \/\/ if the class has inlined field(s) and the caller didn't provide inlined_fields_id.\n+  uintx *this_klass_inlined_fields_id = inlined_fields_id;\n+  uintx inlined_id = 0;\n@@ -1173,1 +1339,23 @@\n-      Symbol* sig = fld.signature();\n+      if (is_inlined_field(fld.field_descriptor())) {\n+        \/\/ dump \"synthetic\" fields for inlined fields.\n+        if (this_klass_inlined_fields_id == nullptr) {\n+          inlined_id = InlinedObjects::get_instance()->get_base_index_for(ik);\n+          this_klass_inlined_fields_id = &inlined_id;\n+        }\n+        dump_instance_field_descriptors(writer, get_inlined_field_klass(fld.field_descriptor()), this_klass_inlined_fields_id);\n+      } else {\n+        Symbol* sig = fld.signature();\n+        Symbol* name = nullptr;\n+        \/\/ Use inlined_fields_id provided by caller.\n+        if (inlined_fields_id != nullptr) {\n+          uintx name_id = InlinedObjects::get_instance()->get_next_string_id(*inlined_fields_id);\n+\n+          \/\/ name_id == 0 is returned on error. use original field signature.\n+          if (name_id != 0) {\n+            *inlined_fields_id = name_id;\n+            name = reinterpret_cast<Symbol*>(name_id);\n+          }\n+        }\n+        if (name == nullptr) {\n+          name = fld.name();\n+        }\n@@ -1175,2 +1363,3 @@\n-      writer->write_symbolID(fld.name());   \/\/ name\n-      writer->write_u1(sig2tag(sig));       \/\/ type\n+        writer->write_symbolID(name);         \/\/ name\n+        writer->write_u1(sig2tag(sig));       \/\/ type\n+      }\n@@ -1201,1 +1390,1 @@\n-  dump_instance_fields(writer, o, cache_entry);\n+  dump_instance_fields(writer, o, 0, class_cache, cache_entry);\n@@ -1244,1 +1433,1 @@\n-  writer->write_u4(DumperSupport::instance_size(ik));\n+  writer->write_u4(HeapWordSize * ik->size_helper());\n@@ -1298,4 +1487,1 @@\n-int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n-  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n-  assert(type >= T_BOOLEAN && type <= T_OBJECT, \"invalid array element type\");\n-\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, int type_size, short header_size) {\n@@ -1304,7 +1490,0 @@\n-  int type_size;\n-  if (type == T_OBJECT) {\n-    type_size = sizeof(address);\n-  } else {\n-    type_size = type2aelembytes(type);\n-  }\n-\n@@ -1318,0 +1497,1 @@\n+    BasicType type = ArrayKlass::cast(array->klass())->element_type();\n@@ -1324,0 +1504,16 @@\n+int DumperSupport::calculate_array_max_length(AbstractDumpWriter* writer, arrayOop array, short header_size) {\n+  BasicType type = ArrayKlass::cast(array->klass())->element_type();\n+  assert((type >= T_BOOLEAN && type <= T_OBJECT) || type == T_FLAT_ELEMENT, \"invalid array element type\");\n+  int type_size;\n+  if (type == T_OBJECT) {\n+    type_size = sizeof(address);\n+  } else if (type == T_FLAT_ELEMENT) {\n+      \/\/ TODO: FIXME\n+      fatal(\"Not supported yet\"); \/\/ FIXME: JDK-8325678\n+  } else {\n+    type_size = type2aelembytes(type);\n+  }\n+\n+  return calculate_array_max_length(writer, array, type_size, header_size);\n+}\n+\n@@ -1349,0 +1545,41 @@\n+\/\/ creates HPROF_GC_PRIM_ARRAY_DUMP record for the given flat array\n+void DumperSupport::dump_flat_array(AbstractDumpWriter* writer, flatArrayOop array, DumperClassCacheTable* class_cache) {\n+  FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+  InlineKlass* element_klass = array_klass->element_klass();\n+  int element_size = instance_size(element_klass);\n+  \/*                          id         array object ID\n+   *                          u4         stack trace serial number\n+   *                          u4         number of elements\n+   *                          u1         element type\n+   *\/\n+  short header_size = 1 + sizeof(address) + 2 * 4 + 1;\n+\n+  \/\/ TODO: use T_SHORT\/T_INT\/T_LONG if needed to avoid truncation\n+  BasicType type = T_BYTE;\n+  int type_size = type2aelembytes(type);\n+  int length = calculate_array_max_length(writer, array, element_size, header_size);\n+  u4 length_in_bytes = (u4)(length * element_size);\n+  u4 size = header_size + length_in_bytes;\n+\n+  writer->start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);\n+  writer->write_objectID(array);\n+  writer->write_u4(STACK_TRACE_ID);\n+  \/\/ TODO: round up array length for T_SHORT\/T_INT\/T_LONG\n+  writer->write_u4(length * element_size);\n+  writer->write_u1(type2tag(type));\n+\n+  for (int index = 0; index < length; index++) {\n+    \/\/ need offset in the holder to read inlined object. calculate it from flatArrayOop::value_at_addr()\n+    int offset = (int)((address)array->value_at_addr(index, array_klass->layout_helper())\n+                  - cast_from_oop<address>(array));\n+    DumperClassCacheTableEntry* class_cache_entry = class_cache->lookup_or_create(element_klass);\n+    dump_inlined_object_fields(writer, array, offset, class_cache, class_cache_entry);\n+  }\n+\n+  \/\/ TODO: write padding bytes for T_SHORT\/T_INT\/T_LONG\n+\n+  InlinedObjects::get_instance()->add_flat_array(array);\n+\n+  writer->end_sub_record();\n+}\n+\n@@ -1470,0 +1707,264 @@\n+class InlinedFieldNameDumper : public LockedClassesDo {\n+public:\n+  typedef void (*Callback)(InlinedObjects *owner, const Klass *klass, uintx base_index, int count);\n+\n+private:\n+  AbstractDumpWriter* _writer;\n+  InlinedObjects *_owner;\n+  Callback       _callback;\n+  uintx _index;\n+\n+  void dump_inlined_field_names(GrowableArray<Symbol*>* super_names, Symbol* field_name, InlineKlass* klass) {\n+    super_names->push(field_name);\n+    for (HierarchicalFieldStream<JavaFieldStream> fld(klass); !fld.done(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n+          dump_inlined_field_names(super_names, fld.name(), DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n+        } else {\n+          \/\/ get next string ID.\n+          uintx next_index = _owner->get_next_string_id(_index);\n+          if (next_index == 0) {\n+            \/\/ something went wrong (overflow?)\n+            \/\/ stop generation; the rest of inlined objects will have original field names.\n+            return;\n+          }\n+          _index = next_index;\n+\n+          \/\/ Calculate length.\n+          int len = fld.name()->utf8_length();\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            len += (*it)->utf8_length() + 1;    \/\/ +1 for \".\".\n+          }\n+\n+          DumperSupport::write_header(_writer, HPROF_UTF8, oopSize + len);\n+          _writer->write_symbolID(reinterpret_cast<Symbol*>(_index));\n+          \/\/ Write the string value.\n+          \/\/ 1) super_names.\n+          for (GrowableArrayIterator<Symbol*> it = super_names->begin(); it != super_names->end(); ++it) {\n+            _writer->write_raw((*it)->bytes(), (*it)->utf8_length());\n+            _writer->write_u1('.');\n+          }\n+          \/\/ 2) field name.\n+          _writer->write_raw(fld.name()->bytes(), fld.name()->utf8_length());\n+        }\n+      }\n+    }\n+    super_names->pop();\n+  }\n+\n+  void dump_inlined_field_names(Symbol* field_name, InlineKlass* field_klass) {\n+    GrowableArray<Symbol*> super_names(4, mtServiceability);\n+    dump_inlined_field_names(&super_names, field_name, field_klass);\n+  }\n+\n+public:\n+  InlinedFieldNameDumper(AbstractDumpWriter* writer, InlinedObjects* owner, Callback callback)\n+    : _writer(writer), _owner(owner), _callback(callback), _index(0)  {\n+  }\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    uintx base_index = _index;\n+    int count = 0;\n+\n+    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n+          dump_inlined_field_names(fld.name(), DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n+          count++;\n+        }\n+      }\n+    }\n+\n+    if (count != 0) {\n+      _callback(_owner, k, base_index, count);\n+    }\n+  }\n+};\n+\n+class InlinedFieldsDumper : public LockedClassesDo {\n+private:\n+  AbstractDumpWriter* _writer;\n+\n+public:\n+  InlinedFieldsDumper(AbstractDumpWriter* writer) : _writer(writer) {}\n+\n+  void do_klass(Klass* k) {\n+    if (!k->is_instance_klass()) {\n+      return;\n+    }\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    \/\/ if (ik->has_inline_type_fields()) {\n+    \/\/   return;\n+    \/\/ }\n+\n+    \/\/ We can be at a point where java mirror does not exist yet.\n+    \/\/ So we need to check that the class is at least loaded, to avoid crash from a null mirror.\n+    if (!ik->is_loaded()) {\n+      return;\n+    }\n+\n+    u2 inlined_count = 0;\n+    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n+          inlined_count++;\n+        }\n+      }\n+    }\n+    if (inlined_count != 0) {\n+      _writer->write_u1(HPROF_CLASS_WITH_INLINED_FIELDS);\n+\n+      \/\/ class ID\n+      _writer->write_classID(ik);\n+      \/\/ number of inlined fields\n+      _writer->write_u2(inlined_count);\n+      u2 index = 0;\n+      for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n+        if (!fld.access_flags().is_static()) {\n+          if (DumperSupport::is_inlined_field(fld.field_descriptor())) {\n+            \/\/ inlined field index\n+            _writer->write_u2(index);\n+            \/\/ synthetic field count\n+            u2 field_count = DumperSupport::get_instance_fields_count(DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n+            _writer->write_u2(field_count);\n+            \/\/ original field name\n+            _writer->write_symbolID(fld.name());\n+            \/\/ inlined field class ID\n+            _writer->write_classID(DumperSupport::get_inlined_field_klass(fld.field_descriptor()));\n+\n+            index += field_count;\n+          } else {\n+            index++;\n+          }\n+        }\n+      }\n+    }\n+  }\n+};\n+\n+\n+void InlinedObjects::init() {\n+  _instance = this;\n+\n+  struct Closure : public SymbolClosure {\n+    uintx _min_id = max_uintx;\n+    uintx _max_id = 0;\n+    Closure() : _min_id(max_uintx), _max_id(0) {}\n+\n+    void do_symbol(Symbol** p) {\n+      uintx val = reinterpret_cast<uintx>(*p);\n+      if (val < _min_id) {\n+        _min_id = val;\n+      }\n+      if (val > _max_id) {\n+        _max_id = val;\n+      }\n+    }\n+  } closure;\n+\n+  SymbolTable::symbols_do(&closure);\n+\n+  _min_string_id = closure._min_id;\n+  _max_string_id = closure._max_id;\n+}\n+\n+void InlinedObjects::release() {\n+  _instance = nullptr;\n+\n+  if (_inlined_field_map != nullptr) {\n+    delete _inlined_field_map;\n+    _inlined_field_map = nullptr;\n+  }\n+  if (_flat_arrays != nullptr) {\n+    delete _flat_arrays;\n+    _flat_arrays = nullptr;\n+  }\n+}\n+\n+void InlinedObjects::inlined_field_names_callback(InlinedObjects* _this, const Klass* klass, uintx base_index, int count) {\n+  if (_this->_inlined_field_map == nullptr) {\n+    _this->_inlined_field_map = new (mtServiceability) GrowableArray<ClassInlinedFields>(100, mtServiceability);\n+  }\n+  _this->_inlined_field_map->append(ClassInlinedFields(klass, base_index));\n+\n+  \/\/ counters for dumping classes with inlined fields\n+  _this->_classes_count++;\n+  _this->_inlined_fields_count += count;\n+}\n+\n+void InlinedObjects::dump_inlined_field_names(AbstractDumpWriter* writer) {\n+  InlinedFieldNameDumper nameDumper(writer, this, inlined_field_names_callback);\n+  ClassLoaderDataGraph::classes_do(&nameDumper);\n+\n+  if (_inlined_field_map != nullptr) {\n+    \/\/ prepare the map for  get_base_index_for().\n+    _inlined_field_map->sort(ClassInlinedFields::compare);\n+  }\n+}\n+\n+uintx InlinedObjects::get_base_index_for(Klass* k) {\n+  if (_inlined_field_map != nullptr) {\n+    bool found = false;\n+    int idx = _inlined_field_map->find_sorted<ClassInlinedFields, ClassInlinedFields::compare>(ClassInlinedFields(k, 0), found);\n+    if (found) {\n+        return _inlined_field_map->at(idx).base_index;\n+    }\n+  }\n+\n+  \/\/ return max_uintx, so get_next_string_id returns 0.\n+  return max_uintx;\n+}\n+\n+uintx InlinedObjects::get_next_string_id(uintx id) {\n+  if (++id == _min_string_id) {\n+    return _max_string_id + 1;\n+  }\n+  return id;\n+}\n+\n+void InlinedObjects::dump_classed_with_inlined_fields(AbstractDumpWriter* writer) {\n+  if (_classes_count != 0) {\n+    \/\/ Record for each class contains tag(u1), class ID and count(u2)\n+    \/\/ for each inlined field index(u2), synthetic fields count(u2), original field name and class ID\n+    int size = _classes_count * (1 + sizeof(address) + 2)\n+             + _inlined_fields_count * (2 + 2 + sizeof(address) + sizeof(address));\n+    DumperSupport::write_header(writer, HPROF_INLINED_FIELDS, (u4)size);\n+\n+    InlinedFieldsDumper dumper(writer);\n+    ClassLoaderDataGraph::classes_do(&dumper);\n+  }\n+}\n+\n+void InlinedObjects::add_flat_array(oop array) {\n+  if (_flat_arrays == nullptr) {\n+    _flat_arrays = new (mtServiceability) GrowableArray<oop>(100, mtServiceability);\n+  }\n+  _flat_arrays->append(array);\n+}\n+\n+void InlinedObjects::dump_flat_arrays(AbstractDumpWriter* writer) {\n+  if (_flat_arrays != nullptr) {\n+    \/\/ For each flat array the record contains tag (u1), object ID and class ID.\n+    int size = _flat_arrays->length() * (1 + sizeof(address) + sizeof(address));\n+\n+    DumperSupport::write_header(writer, HPROF_FLAT_ARRAYS, (u4)size);\n+    for (GrowableArrayIterator<oop> it = _flat_arrays->begin(); it != _flat_arrays->end(); ++it) {\n+      flatArrayOop array = flatArrayOop(*it);\n+      FlatArrayKlass* array_klass = FlatArrayKlass::cast(array->klass());\n+      InlineKlass* element_klass = array_klass->element_klass();\n+      writer->write_u1(HPROF_FLAT_ARRAY);\n+      writer->write_objectID(array);\n+      writer->write_classID(element_klass);\n+    }\n+  }\n+}\n+\n+\n@@ -2002,0 +2503,2 @@\n+  } else if (o->is_flatArray()) {\n+    DumperSupport::dump_flat_array(writer(), flatArrayOop(o), &_class_cache);\n@@ -2081,0 +2584,1 @@\n+  InlinedObjects*  _inlined_objects;\n@@ -2091,1 +2595,1 @@\n-  DumpMerger(const char* path, DumpWriter* writer, int dump_seq) :\n+  DumpMerger(const char* path, DumpWriter* writer, InlinedObjects* inlined_objects, int dump_seq) :\n@@ -2093,0 +2597,1 @@\n+    _inlined_objects(inlined_objects),\n@@ -2124,0 +2629,1 @@\n+    _inlined_objects->dump_flat_arrays(_writer);\n@@ -2125,0 +2631,1 @@\n+    _inlined_objects->release();\n@@ -2244,0 +2751,4 @@\n+\n+  \/\/ Inlined object support.\n+  InlinedObjects          _inlined_objects;\n+\n@@ -2324,0 +2835,2 @@\n+  InlinedObjects* inlined_objects() { return &_inlined_objects; }\n+\n@@ -2460,0 +2973,7 @@\n+    \/\/ HPROF_UTF8 records for inlined field names.\n+    inlined_objects()->init();\n+    inlined_objects()->dump_inlined_field_names(writer());\n+\n+    \/\/ HPROF_INLINED_FIELDS\n+    inlined_objects()->dump_classed_with_inlined_fields(writer());\n+\n@@ -2662,1 +3182,1 @@\n-  DumpMerger merger(path, &writer, dumper.dump_seq());\n+  DumpMerger merger(path, &writer, dumper.inlined_objects(), dumper.dump_seq());\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":554,"deletions":34,"binary":false,"changes":588,"status":"modified"},{"patch":"@@ -605,0 +605,9 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Prototyping\n+\/\/ \"Code Missing Here\" macro, un-define when integrating back from prototyping stage and break\n+\/\/ compilation on purpose (i.e. \"forget me not\")\n+#define PROTOTYPE\n+#ifdef PROTOTYPE\n+#define CMH(m)\n+#endif\n+\n@@ -683,5 +692,6 @@\n-  T_ADDRESS     = 15,\n-  T_NARROWOOP   = 16,\n-  T_METADATA    = 17,\n-  T_NARROWKLASS = 18,\n-  T_CONFLICT    = 19, \/\/ for stack value type with conflicting contents\n+  T_FLAT_ELEMENT = 15, \/\/ Not a true BasicType, only used in layout helpers of flat arrays\n+  T_ADDRESS     = 16,\n+  T_NARROWOOP   = 17,\n+  T_METADATA    = 18,\n+  T_NARROWKLASS = 19,\n+  T_CONFLICT    = 20, \/\/ for stack value type with conflicting contents\n@@ -731,0 +741,1 @@\n+  assert(t != T_FLAT_ELEMENT, \"\");  \/\/ Strong assert to detect misuses of T_FLAT_ELEMENT\n@@ -805,1 +816,2 @@\n-  T_VOID_size        = 0\n+  T_VOID_size        = 0,\n+  T_FLAT_ELEMENT_size = 0\n@@ -841,1 +853,2 @@\n-  T_VOID_aelem_bytes        = 0\n+  T_VOID_aelem_bytes        = 0,\n+  T_FLAT_ELEMENT_aelem_bytes = 0\n@@ -931,1 +944,1 @@\n-  vtos = 9,             \/\/ tos not cached\n+  vtos = 9,             \/\/ tos not cached,\n@@ -948,1 +961,1 @@\n-    case T_ARRAY  : \/\/ fall through\n+    case T_ARRAY  :   \/\/ fall through\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -87,1 +88,1 @@\n-        return AccessFlag.maskToAccessFlags(flagsMask(), AccessFlag.Location.INNER_CLASS);\n+        return AccessFlag.maskToAccessFlags(flagsMask(), AccessFlag.Location.INNER_CLASS, ClassFileFormatVersion.CURRENT_PREVIEW_FEATURES);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassInfo.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -80,0 +81,7 @@\n+    \/**\n+     * {@return the expanded unset fields}\n+     *\n+     * @see <a href=\"https:\/\/cr.openjdk.org\/~dlsmith\/jep401\/jep401-20250409\/specs\/strict-fields-jvms.html\">Specs<\/a>\n+     *\/\n+    List<NameAndTypeEntry> unsetFields();\n+\n@@ -92,1 +100,20 @@\n-        return new StackMapDecoder.StackMapFrameImpl(255, target, locals, stack);\n+\n+        return of(target, locals, stack, List.of());\n+    }\n+\n+    \/**\n+     * {@return a new stack map frame}\n+     * @param target the location of the frame\n+     * @param locals the complete list of frame locals\n+     * @param stack the complete frame stack\n+     * @param unsetFields the complete list of unset fields\n+     * @throws IllegalArgumentException if unset fields has entries but no\n+     * {@link SimpleVerificationTypeInfo#UNINITIALIZED_THIS uninitializedThis}\n+     * is present in {@code locals}\n+     *\/\n+    public static StackMapFrameInfo of(Label target,\n+                                       List<VerificationTypeInfo> locals,\n+                                       List<VerificationTypeInfo> stack,\n+                                       List<NameAndTypeEntry> unsetFields) {\n+\n+        return new StackMapDecoder.StackMapFrameImpl(255, target, locals, stack, unsetFields);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -514,0 +514,1 @@\n+ *     | LoadableDescriptorsAttribute?(List<Utf8Entry> loadableDescriptors)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -57,1 +58,1 @@\n-            flags = AccessFlag.maskToAccessFlags(flagsMask, location);\n+            flags = AccessFlag.maskToAccessFlags(flagsMask, location, ClassFileFormatVersion.CURRENT_PREVIEW_FEATURES);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AccessFlagsImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -34,0 +35,1 @@\n+import java.util.HashSet;\n@@ -39,0 +41,1 @@\n+import static java.lang.classfile.ClassFile.*;\n@@ -49,0 +52,3 @@\n+    private WritableField.UnsetField[] strictInstanceFields; \/\/ do not modify array contents\n+    private ClassModel lastStrictCheckClass; \/\/ buf writer has short life, so do not need weak here\n+    private boolean lastStrictCheckResult;\n@@ -71,0 +77,27 @@\n+    public boolean strictFieldsMatch(ClassModel cm) {\n+        \/\/ We have a cache because this check will be called multiple times\n+        \/\/ if a MethodModel is sent wholesale\n+        if (lastStrictCheckClass == cm) {\n+            return lastStrictCheckResult;\n+        }\n+\n+        var result = doStrictFieldsMatchCheck(cm);\n+        lastStrictCheckClass = cm;\n+        lastStrictCheckResult = result;\n+        return result;\n+    }\n+\n+    private boolean doStrictFieldsMatchCheck(ClassModel cm) {\n+        \/\/ TODO only check for preview class files?\n+        \/\/ UTF8 Entry can be used as equality objects\n+        var checks = new HashSet<>(Arrays.asList(getStrictInstanceFields()));\n+        for (var f : cm.fields()) {\n+            if ((f.flags().flagsMask() & (ACC_STATIC | ACC_STRICT_INIT)) == ACC_STRICT_INIT) {\n+                if (!checks.remove(new WritableField.UnsetField(f.fieldName(), f.fieldType()))) {\n+                    return false; \/\/ Field mismatch!\n+                }\n+            }\n+        }\n+        return checks.isEmpty();\n+    }\n+\n@@ -85,0 +118,10 @@\n+    public WritableField.UnsetField[] getStrictInstanceFields() {\n+        assert strictInstanceFields != null : \"should access only after setter call in DirectClassBuilder\";\n+        return strictInstanceFields;\n+    }\n+\n+    public void setStrictInstanceFields(WritableField.UnsetField[] strictInstanceFields) {\n+        this.strictInstanceFields = strictInstanceFields;\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import static java.lang.classfile.ClassFile.PREVIEW_MINOR_VERSION;\n+import static java.lang.classfile.ClassFile.latestMajorVersion;\n@@ -47,0 +49,1 @@\n+    static final WritableField[] EMPTY_WRITABLE_FIELD_ARRAY = {};\n@@ -49,1 +52,1 @@\n-    private Util.Writable[] fields = EMPTY_WRITABLE_ARRAY;\n+    private WritableField[] fields = EMPTY_WRITABLE_FIELD_ARRAY;\n@@ -132,1 +135,1 @@\n-    ClassBuilder withField(Util.Writable field) {\n+    ClassBuilder withField(WritableField field) {\n@@ -171,1 +174,0 @@\n-\n@@ -198,0 +200,7 @@\n+        WritableField.UnsetField[] strictInstanceFields;\n+        if (minorVersion == PREVIEW_MINOR_VERSION && majorVersion >= Util.VALUE_OBJECTS_MAJOR) {\n+            strictInstanceFields = WritableField.filterStrictInstanceFields(constantPool, fields, fieldsCount);\n+        } else {\n+            strictInstanceFields = WritableField.UnsetField.EMPTY_ARRAY;\n+        }\n+        tail.setStrictInstanceFields(strictInstanceFields);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n@@ -378,1 +379,1 @@\n-                boolean codeMatch = dcb.original != null && codeAndExceptionsMatch(codeLength);\n+                boolean codeMatch = dcb.codeAndExceptionsMatch(codeLength, buf);\n@@ -457,1 +458,1 @@\n-    private boolean codeAndExceptionsMatch(int codeLength) {\n+    private boolean codeAndExceptionsMatch(int codeLength, BufWriterImpl buf) {\n@@ -467,0 +468,16 @@\n+\n+            if (codeAttributesMatch) {\n+                var thisIsConstructor = methodInfo.methodName().equalsString(INIT_NAME);\n+                var originalIsConstructor = cai.enclosingMethod.methodName().equalsString(INIT_NAME);\n+                if (thisIsConstructor || originalIsConstructor) {\n+                    if (thisIsConstructor != originalIsConstructor) {\n+                        codeAttributesMatch = false;\n+                    }\n+                }\n+\n+                if (codeAttributesMatch && thisIsConstructor) {\n+                    if (!buf.strictFieldsMatch(cai.classReader.getContainedClass())) {\n+                        codeAttributesMatch = false;\n+                    }\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        implements TerminalFieldBuilder, Util.Writable {\n+        implements TerminalFieldBuilder, WritableField {\n@@ -87,0 +87,16 @@\n+\n+    \/\/ These values must only be accessed after the field is definitely configured\n+    @Override\n+    public Utf8Entry fieldName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Utf8Entry fieldType() {\n+        return desc;\n+    }\n+\n+    @Override\n+    public int fieldFlags() {\n+        return flags;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.ClassModel;\n@@ -38,0 +39,3 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -41,0 +45,1 @@\n+import java.util.ArrayList;\n@@ -46,1 +51,3 @@\n-import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import jdk.internal.access.SharedSecrets;\n+\n+import static java.lang.classfile.ClassFile.*;\n@@ -52,1 +59,2 @@\n-    private static final int\n+    static final int\n+                    EARLY_LARVAL = 246,\n@@ -55,0 +63,1 @@\n+    private static final int BASE_FRAMES_UPPER_LIMIT = SAME_LOCALS_1_STACK_ITEM_EXTENDED; \/\/ not inclusive\n@@ -61,0 +70,1 @@\n+    private final List<NameAndTypeEntry> initFrameUnsets;\n@@ -63,1 +73,2 @@\n-    StackMapDecoder(ClassReader classReader, int pos, LabelContext ctx, List<VerificationTypeInfo> initFrameLocals) {\n+    StackMapDecoder(ClassReader classReader, int pos, LabelContext ctx, List<VerificationTypeInfo> initFrameLocals,\n+                    List<NameAndTypeEntry> initFrameUnsets) {\n@@ -68,0 +79,1 @@\n+        this.initFrameUnsets = initFrameUnsets;\n@@ -104,0 +116,29 @@\n+    static List<NameAndTypeEntry> initFrameUnsets(MethodModel method) {\n+        return initFrameUnsets(method.parent().orElseThrow(),\n+                method.methodName());\n+    }\n+\n+    private static List<NameAndTypeEntry> initFrameUnsets(ClassModel clazz, Utf8Entry methodName) {\n+        if (!methodName.equalsString(ConstantDescs.INIT_NAME))\n+            return List.of();\n+        if (clazz.minorVersion() != PREVIEW_MINOR_VERSION || clazz.majorVersion() < Util.VALUE_OBJECTS_MAJOR)\n+            return List.of();\n+        var l = new ArrayList<NameAndTypeEntry>(clazz.fields().size());\n+        for (var field : clazz.fields()) {\n+            if ((field.flags().flagsMask() & (ACC_STATIC | ACC_STRICT_INIT)) == ACC_STRICT_INIT) { \/\/ instance strict\n+                l.add(TemporaryConstantPool.INSTANCE.nameAndTypeEntry(field.fieldName(), field.fieldType()));\n+            }\n+        }\n+        return List.copyOf(l);\n+    }\n+\n+    private static List<NameAndTypeEntry> initFrameUnsets(MethodInfo mi, WritableField.UnsetField[] unsets) {\n+        if (!mi.methodName().equalsString(ConstantDescs.INIT_NAME))\n+            return List.of();\n+        var l = new ArrayList<NameAndTypeEntry>(unsets.length);\n+        for (var field : unsets) {\n+            l.add(TemporaryConstantPool.INSTANCE.nameAndTypeEntry(field.name(), field.type()));\n+        }\n+        return List.copyOf(l);\n+    }\n+\n@@ -112,0 +153,1 @@\n+        var prevUnsets = initFrameUnsets(mi, buf.getStrictInstanceFields());\n@@ -127,1 +169,1 @@\n-            writeFrame(buf, offset - prevOffset - 1, prevLocals, fr);\n+            writeFrame(buf, offset - prevOffset - 1, prevLocals, prevUnsets, fr);\n@@ -130,0 +172,11 @@\n+            prevUnsets = fr.unsetFields();\n+        }\n+    }\n+\n+    \/\/ In sync with StackMapGenerator::needsLarvalFrame\n+    private static boolean needsLarvalFrameForTransition(List<NameAndTypeEntry> prevUnsets, StackMapFrameInfo fr) {\n+        if (prevUnsets.equals(fr.unsetFields()))\n+            return false;\n+        if (!fr.locals().contains(SimpleVerificationTypeInfo.UNINITIALIZED_THIS)) {\n+            assert fr.unsetFields().isEmpty() : fr; \/\/ should be checked in StackMapFrameInfo constructor\n+            return false;\n@@ -131,0 +184,1 @@\n+        return true;\n@@ -133,1 +187,1 @@\n-    private static void writeFrame(BufWriterImpl out, int offsetDelta, List<VerificationTypeInfo> prevLocals, StackMapFrameInfo fr) {\n+    private static void writeFrame(BufWriterImpl out, int offsetDelta, List<VerificationTypeInfo> prevLocals, List<NameAndTypeEntry> prevUnsets, StackMapFrameInfo fr) {\n@@ -135,0 +189,6 @@\n+        \/\/ enclosing frames\n+        if (needsLarvalFrameForTransition(prevUnsets, fr)) {\n+            out.writeU1(EARLY_LARVAL);\n+            Util.writeListIndices(out, fr.unsetFields());\n+        }\n+        \/\/ base frame\n@@ -184,0 +244,12 @@\n+    \/\/ Copied from BoundAttribute\n+    <E extends PoolEntry> List<E> readEntryList(int p, Class<E> type) {\n+        int cnt = classReader.readU2(p);\n+        p += 2;\n+        var entries = new Object[cnt];\n+        int end = p + (cnt * 2);\n+        for (int i = 0; p < end; i++, p += 2) {\n+            entries[i] = classReader.readEntry(p, type);\n+        }\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(entries);\n+    }\n+\n@@ -187,0 +259,1 @@\n+        List<NameAndTypeEntry> unsetFields = initFrameUnsets;\n@@ -190,1 +263,9 @@\n-            int frameType = classReader.readU1(p++);\n+            int actualFrameType = classReader.readU1(p++);\n+            int frameType = actualFrameType; \/\/ effective frame type for parsing\n+            \/\/ enclosing frames handling\n+            if (frameType == EARLY_LARVAL) {\n+                unsetFields = readEntryList(p, NameAndTypeEntry.class);\n+                p += 2 + unsetFields.size() * 2;\n+                frameType = classReader.readU1(p++);\n+            }\n+            \/\/ base frame handling\n@@ -198,2 +279,2 @@\n-                if (frameType < SAME_LOCALS_1_STACK_ITEM_EXTENDED)\n-                    throw new IllegalArgumentException(\"Invalid stackmap frame type: \" + frameType);\n+                if (frameType < BASE_FRAMES_UPPER_LIMIT)\n+                    throw new IllegalArgumentException(\"Invalid base frame type: \" + frameType);\n@@ -226,4 +307,9 @@\n-            entries[ei] = new StackMapFrameImpl(frameType,\n-                        ctx.getLabel(bci),\n-                        locals,\n-                        stack);\n+            if (actualFrameType != EARLY_LARVAL && !unsetFields.isEmpty() && !locals.contains(SimpleVerificationTypeInfo.UNINITIALIZED_THIS)) {\n+                \/\/ clear unsets post larval\n+                unsetFields = List.of();\n+            }\n+            entries[ei] = new StackMapFrameImpl(actualFrameType,\n+                    ctx.getLabel(bci),\n+                    locals,\n+                    stack,\n+                    unsetFields);\n@@ -302,1 +388,2 @@\n-                                           List<VerificationTypeInfo> stack)\n+                                           List<VerificationTypeInfo> stack,\n+                                           List<NameAndTypeEntry> unsetFields)\n@@ -308,0 +395,18 @@\n+            unsetFields = Util.sanitizeU2List(unsetFields);\n+\n+            uninitializedThisCheck:\n+            if (!unsetFields.isEmpty()) {\n+                for (var local : locals) {\n+                    if (local == SimpleVerificationTypeInfo.UNINITIALIZED_THIS) {\n+                        break uninitializedThisCheck;\n+                    }\n+                }\n+                throw new IllegalArgumentException(\"unset fields requires uninitializedThis in locals\");\n+            }\n+        }\n+\n+        public StackMapFrameImpl(int frameType,\n+                                 Label target,\n+                                 List<VerificationTypeInfo> locals,\n+                                 List<VerificationTypeInfo> stack) {\n+            this(frameType, target, locals, stack, List.of());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":118,"deletions":13,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -515,0 +515,24 @@\n+    public static final class UnboundLoadableDescriptorsAttribute\n+            extends UnboundAttribute<LoadableDescriptorsAttribute>\n+            implements LoadableDescriptorsAttribute {\n+\n+        private static final Utf8Entry NAME = TemporaryConstantPool.INSTANCE.utf8Entry(Attributes.NAME_LOADABLE_DESCRIPTORS);\n+\n+        private final List<Utf8Entry> loadableDescriptors;\n+\n+        public UnboundLoadableDescriptorsAttribute(List<Utf8Entry> loadableDescriptors) {\n+            super(Attributes.loadableDescriptors());\n+            this.loadableDescriptors = List.copyOf(loadableDescriptors);\n+        }\n+\n+        @Override\n+        public List<Utf8Entry> loadableDescriptors() {\n+            return loadableDescriptors;\n+        }\n+\n+        @Override\n+        public Utf8Entry attributeName() {\n+            return NAME;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.lang.classfile.constantpool.ConstantPool;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -38,0 +40,1 @@\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -50,0 +53,1 @@\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n@@ -61,0 +65,2 @@\n+    public static final int VALUE_OBJECTS_MAJOR = ClassFile.latestMajorVersion();\n+\n@@ -255,1 +261,1 @@\n-            if (!f.locations().contains(location)) {\n+            if (!f.locations().contains(location) && !f.locations(ClassFileFormatVersion.CURRENT_PREVIEW_FEATURES).contains(location)) {\n@@ -264,1 +270,2 @@\n-        return (flag.mask() & flagsMask) == flag.mask() && flag.locations().contains(location);\n+        return (flag.mask() & flagsMask) == flag.mask() && (flag.locations().contains(location)\n+                || flag.locations(ClassFileFormatVersion.CURRENT_PREVIEW_FEATURES).contains(location));\n@@ -317,0 +324,8 @@\n+    public static boolean checkConstantPoolsCompatible(ConstantPool one, ConstantPool two) {\n+        if (one.equals(two))\n+            return true;\n+        if (one instanceof ConstantPoolBuilder cpb && cpb.canWriteDirect(two))\n+            return true;\n+        return two instanceof ConstantPoolBuilder cpb && cpb.canWriteDirect(one);\n+    }\n+\n@@ -360,0 +375,11 @@\n+    public static boolean canSkipMethodInflation(ClassReader cr, MethodInfo method, BufWriterImpl buf) {\n+        if (!buf.canWriteDirect(cr)) {\n+            return false;\n+        }\n+        if (method.methodName().equalsString(INIT_NAME) &&\n+                !buf.strictFieldsMatch(((ClassReaderImpl) cr).getContainedClass())) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-requiredVersion=7.5.2+1\n+requiredVersion=7.5.1+1\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import compiler.valhalla.inlinetypes.InlineTypeIRNode;\n@@ -90,1 +91,1 @@\n-    private static final String PREFIX = \"_#\";\n+    public static final String PREFIX = \"_#\";\n@@ -153,0 +154,6 @@\n+    \/\/ Valhalla: Make sure that all Valhalla specific IR nodes are also properly initialized. Doing it here also\n+    \/\/           ensures that the Flag VM is able to pick up the correct compile phases.\n+    static {\n+        InlineTypeIRNode.forceStaticInitialization();\n+    }\n+\n@@ -384,2 +391,6 @@\n-        String regex = START + \"Allocate\\\\b\" + MID + \"allocationKlass:.*\\\\b\" + IS_REPLACED + \"\\\\s.*\" + END;\n-        macroNodes(ALLOC_OF, regex);\n+        allocateOfNodes(ALLOC_OF, IS_REPLACED);\n+    }\n+\n+    public static void allocateOfNodes(String irNodePlaceholder, String allocatee) {\n+        String regex = START + \"Allocate\\\\b\" + MID + \"allocationKlass:.*\\\\b\" + allocatee + \"\\\\s.*\" + END;\n+        macroNodes(irNodePlaceholder, regex);\n@@ -396,0 +407,4 @@\n+        allocateArrayOfNodes(ALLOC_ARRAY_OF, IS_REPLACED);\n+    }\n+\n+    public static void allocateArrayOfNodes(String irNodePlaceholder, String allocatee) {\n@@ -414,1 +429,1 @@\n-        String name_part = \"\\\\[+.(\" + partial_name_prefix + \")?\" + IS_REPLACED + \";\";\n+        String name_part = \"\\\\[+.(\" + partial_name_prefix + \")?\" + allocatee + \";\";\n@@ -416,1 +431,1 @@\n-        macroNodes(ALLOC_ARRAY_OF, regex);\n+        macroNodes(irNodePlaceholder, regex);\n@@ -481,1 +496,1 @@\n-        callOfNodes(CALL_OF, \"Call.*\");\n+        callOfNodes(CALL_OF, \"Call.*\", IS_REPLACED + \" \" );\n@@ -486,1 +501,6 @@\n-        callOfNodes(CALL_OF_METHOD, \"Call.*Java\");\n+        callOfNodes(CALL_OF_METHOD, \"Call.*Java\", IS_REPLACED + \" \");\n+    }\n+\n+    public static final String STATIC_CALL = PREFIX + \"STATIC_CALL\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(STATIC_CALL, \"CallStaticJava\");\n@@ -491,1 +511,19 @@\n-        callOfNodes(STATIC_CALL_OF_METHOD, \"CallStaticJava\");\n+        staticCallOfMethodNodes(STATIC_CALL_OF_METHOD, IS_REPLACED + \" \");\n+    }\n+\n+    public static void staticCallOfMethodNodes(String irNodePlaceholder, String calleeRegex) {\n+        callOfNodes(irNodePlaceholder, \"CallStaticJava\", calleeRegex);\n+    }\n+\n+    public static final String CALL_LEAF_NO_FP = PREFIX + \"CALL_LEAF_NO_FP\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CALL_LEAF_NO_FP, \"CallLeafNoFP\");\n+    }\n+\n+    public static final String CALL_LEAF_NO_FP_OF_METHOD = COMPOSITE_PREFIX + \"CALL_LEAF_NO_FP_OF_METHOD\" + POSTFIX;\n+    static {\n+        callLeafNoFpOfMethodNodes(CALL_LEAF_NO_FP_OF_METHOD, IS_REPLACED);\n+    }\n+\n+    public static void callLeafNoFpOfMethodNodes(String irNodePlaceholder, String calleeRegex) {\n+        callOfNodes(irNodePlaceholder, \"CallLeafNoFP\", calleeRegex);\n@@ -588,0 +626,5 @@\n+    public static final String CMP_N = PREFIX + \"CMP_N\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_N, \"CmpN\");\n+    }\n+\n@@ -722,1 +765,1 @@\n-        callOfNodes(DYNAMIC_CALL_OF_METHOD, \"CallDynamicJava\");\n+        callOfNodes(DYNAMIC_CALL_OF_METHOD, \"CallDynamicJava\", IS_REPLACED);\n@@ -858,0 +901,5 @@\n+    public static final String INLINE_TYPE = PREFIX + \"INLINE_TYPE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(INLINE_TYPE, \"InlineType\");\n+    }\n+\n@@ -904,1 +952,5 @@\n-        loadOfNodes(LOAD_OF_CLASS, \"Load(B|UB|S|US|I|L|F|D|P|N)\");\n+        anyLoadOfNodes(LOAD_OF_CLASS, IS_REPLACED);\n+    }\n+\n+    public static void anyLoadOfNodes(String irNodePlaceholder, String fieldHolder) {\n+        loadOfNodes(irNodePlaceholder, \"Load(B|UB|S|US|I|L|F|D|P|N)\", fieldHolder);\n@@ -914,1 +966,1 @@\n-        loadOfNodes(LOAD_B_OF_CLASS, \"LoadB\");\n+        loadOfNodes(LOAD_B_OF_CLASS, \"LoadB\", IS_REPLACED);\n@@ -924,1 +976,1 @@\n-        loadOfNodes(LOAD_D_OF_CLASS, \"LoadD\");\n+        loadOfNodes(LOAD_D_OF_CLASS, \"LoadD\", IS_REPLACED);\n@@ -934,1 +986,1 @@\n-        loadOfNodes(LOAD_F_OF_CLASS, \"LoadF\");\n+        loadOfNodes(LOAD_F_OF_CLASS, \"LoadF\", IS_REPLACED);\n@@ -944,1 +996,1 @@\n-        loadOfNodes(LOAD_I_OF_CLASS, \"LoadI\");\n+        loadOfNodes(LOAD_I_OF_CLASS, \"LoadI\", IS_REPLACED);\n@@ -969,1 +1021,1 @@\n-        loadOfNodes(LOAD_L_OF_CLASS, \"LoadL\");\n+        loadOfNodes(LOAD_L_OF_CLASS, \"LoadL\", IS_REPLACED);\n@@ -979,1 +1031,1 @@\n-        loadOfNodes(LOAD_N_OF_CLASS, \"LoadN\");\n+        loadOfNodes(LOAD_N_OF_CLASS, \"LoadN\", IS_REPLACED);\n@@ -995,1 +1047,1 @@\n-        loadOfNodes(LOAD_P_OF_CLASS, \"LoadP\");\n+        loadOfNodes(LOAD_P_OF_CLASS, \"LoadP\", IS_REPLACED);\n@@ -1005,1 +1057,1 @@\n-        loadOfNodes(LOAD_S_OF_CLASS, \"LoadS\");\n+        loadOfNodes(LOAD_S_OF_CLASS, \"LoadS\", IS_REPLACED);\n@@ -1015,1 +1067,1 @@\n-        loadOfNodes(LOAD_UB_OF_CLASS, \"LoadUB\");\n+        loadOfNodes(LOAD_UB_OF_CLASS, \"LoadUB\", IS_REPLACED);\n@@ -1025,1 +1077,1 @@\n-        loadOfNodes(LOAD_US_OF_CLASS, \"LoadUS\");\n+        loadOfNodes(LOAD_US_OF_CLASS, \"LoadUS\", IS_REPLACED);\n@@ -1924,1 +1976,1 @@\n-        storeOfNodes(STORE_B_OF_CLASS, \"StoreB\");\n+        storeOfNodes(STORE_B_OF_CLASS, \"StoreB\", IS_REPLACED);\n@@ -1934,1 +1986,1 @@\n-        storeOfNodes(STORE_C_OF_CLASS, \"StoreC\");\n+        storeOfNodes(STORE_C_OF_CLASS, \"StoreC\", IS_REPLACED);\n@@ -1944,1 +1996,1 @@\n-        storeOfNodes(STORE_D_OF_CLASS, \"StoreD\");\n+        storeOfNodes(STORE_D_OF_CLASS, \"StoreD\", IS_REPLACED);\n@@ -1954,1 +2006,1 @@\n-        storeOfNodes(STORE_F_OF_CLASS, \"StoreF\");\n+        storeOfNodes(STORE_F_OF_CLASS, \"StoreF\", IS_REPLACED);\n@@ -1964,1 +2016,1 @@\n-        storeOfNodes(STORE_I_OF_CLASS, \"StoreI\");\n+        storeOfNodes(STORE_I_OF_CLASS, \"StoreI\", IS_REPLACED);\n@@ -1974,1 +2026,1 @@\n-        storeOfNodes(STORE_L_OF_CLASS, \"StoreL\");\n+        storeOfNodes(STORE_L_OF_CLASS, \"StoreL\", IS_REPLACED);\n@@ -1984,1 +2036,1 @@\n-        storeOfNodes(STORE_N_OF_CLASS, \"StoreN\");\n+        storeOfNodes(STORE_N_OF_CLASS, \"StoreN\", IS_REPLACED);\n@@ -1989,1 +2041,5 @@\n-        storeOfNodes(STORE_OF_CLASS, \"Store(B|C|S|I|L|F|D|P|N)\");\n+        anyStoreOfNodes(STORE_OF_CLASS, IS_REPLACED);\n+    }\n+\n+    public static void anyStoreOfNodes(String irNodePlaceholder, String fieldHolder) {\n+        storeOfNodes(irNodePlaceholder, \"Store(B|C|S|I|L|F|D|P|N)\", fieldHolder);\n@@ -2005,1 +2061,1 @@\n-        storeOfNodes(STORE_P_OF_CLASS, \"StoreP\");\n+        storeOfNodes(STORE_P_OF_CLASS, \"StoreP\", IS_REPLACED);\n@@ -2095,1 +2151,2 @@\n-        beforeMatchingNameRegex(SUBTYPE_CHECK, \"SubTypeCheck\");\n+        String regex = START + \"SubTypeCheck\" + MID + END;\n+        macroNodes(SUBTYPE_CHECK, regex);\n@@ -2917,1 +2974,1 @@\n-    private static void beforeMatching(String irNodePlaceholder, String regex) {\n+    public static void beforeMatching(String irNodePlaceholder, String regex) {\n@@ -2953,2 +3010,2 @@\n-    private static void callOfNodes(String irNodePlaceholder, String callRegex) {\n-        String regex = START + callRegex + MID + IS_REPLACED + \" \" +  END;\n+    private static void callOfNodes(String irNodePlaceholder, String callRegex, String calleeRegex) {\n+        String regex = START + callRegex + MID + calleeRegex + END;\n@@ -2962,1 +3019,1 @@\n-    private static void optoOnly(String irNodePlaceholder, String regex) {\n+    public static void optoOnly(String irNodePlaceholder, String regex) {\n@@ -3047,2 +3104,2 @@\n-    private static void loadOfNodes(String irNodePlaceholder, String irNodeRegex) {\n-        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + IS_REPLACED + LOAD_STORE_SUFFIX + END;\n+    private static void loadOfNodes(String irNodePlaceholder, String irNodeRegex, String loadee) {\n+        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + loadee + LOAD_STORE_SUFFIX + END;\n@@ -3052,2 +3109,2 @@\n-    private static void storeOfNodes(String irNodePlaceholder, String irNodeRegex) {\n-        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + IS_REPLACED + LOAD_STORE_SUFFIX + END;\n+    private static void storeOfNodes(String irNodePlaceholder, String irNodeRegex, String storee) {\n+        String regex = START + irNodeRegex + MID + LOAD_STORE_PREFIX + storee + LOAD_STORE_SUFFIX + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":95,"deletions":38,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -652,0 +652,12 @@\n+    \/**\n+     * Checks if deopt of {@code m} is stable at the specified {@code compLevel}.\n+     *\n+     * @param m the method to be checked.\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if deopt of {@code m} is stable at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public static boolean isStableDeopt(Method m, CompLevel compLevel) {\n+        return TestVM.isStableDeopt(m, compLevel);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,465 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test the VM internal metadata for arrays.\n+ * @library \/test\/lib \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:-MonomorphicArrayCheck -XX:-OmitStackTraceInFastThrow\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -Xcomp\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -XX:MultiArrayExpandLimit=0\n+                     compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -Xbatch\n+ *                   -XX:CompileCommand=compileonly,*TestArrayMetadata::* -XX:CompileCommand=dontinline,*TestArrayMetadata::test*\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -Xbatch\n+ *                   -XX:CompileCommand=compileonly,*TestArrayMetadata::* -XX:CompileCommand=dontinline,*TestArrayMetadata::*\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -Xbatch\n+ *                   -XX:CompileCommand=compileonly,*TestArrayMetadata::main -XX:CompileCommand=dontinline,*TestArrayMetadata::test*\n+ *                   compiler.valhalla.inlinetypes.TestArrayMetadata\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestArrayMetadata {\n+\n+    static interface MyInterface {\n+\n+    }\n+\n+    public static Object[] testArrayAllocation1() {\n+        return new Object[1];\n+    }\n+\n+    public static Object[][] testArrayAllocation2() {\n+        return new Object[1][1];\n+    }\n+\n+    public static Class getClass1() {\n+        return Object.class;\n+    }\n+\n+    public static Object[] testArrayAllocation3() {\n+        return (Object[])Array.newInstance(getClass1(), 1);\n+    }\n+\n+    public static Class getClass2() {\n+        return TestArrayMetadata.class;\n+    }\n+\n+    public static Object[] testArrayAllocation4() {\n+        return (TestArrayMetadata[])Array.newInstance(getClass2(), 1);\n+    }\n+\n+    public static Object[] testArrayAllocation5() {\n+        return new MyInterface[1];\n+    }\n+\n+    public static Object[] testArrayAllocation6() {\n+        return new Integer[1];\n+    }\n+\n+    public static Object[] testCheckcast1(Object arg) {\n+        return (Object[])arg;\n+    }\n+\n+    public static Object[] testCheckcast2(Object arg) {\n+        return (TestArrayMetadata[])arg;\n+    }\n+\n+    public static Cloneable testCheckcast3(Object arg) {\n+        return (Cloneable)arg;\n+    }\n+\n+    public static Object testCheckcast4(Object arg) {\n+        return (Object)arg;\n+    }\n+\n+    public static Object[][] testCheckcast5(Object arg) {\n+        return (Object[][])arg;\n+    }\n+\n+    public static MyInterface[] testCheckcast6(Object arg) {\n+        return (MyInterface[])arg;\n+    }\n+\n+    public static Integer[] testCheckcast7(Object arg) {\n+        return (Integer[])arg;\n+    }\n+\n+    public static Class getArrayClass1() {\n+        return Object[].class;\n+    }\n+\n+    public static boolean testIsInstance1(Object arg) {\n+        return getArrayClass1().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass2() {\n+        return TestArrayMetadata[].class;\n+    }\n+\n+    public static boolean testIsInstance2(Object arg) {\n+        return getArrayClass2().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass3() {\n+        return Cloneable.class;\n+    }\n+\n+    public static boolean testIsInstance3(Object arg) {\n+        return getArrayClass3().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass4() {\n+        return Object.class;\n+    }\n+\n+    public static boolean testIsInstance4(Object arg) {\n+        return getArrayClass4().isInstance(arg);\n+    }\n+\n+    public static Class getArrayClass5() {\n+        return Object[][].class;\n+    }\n+\n+    public static boolean testIsInstance5(Object arg) {\n+        return getArrayClass5().isInstance(arg);\n+    }\n+\n+    public static Object[] testCopyOf1(Object[] array, Class<? extends Object[]> clazz) {\n+        return Arrays.copyOf(array, 1, clazz);\n+    }\n+\n+    public static Object[] testCopyOf2(Object[] array) {\n+        return Arrays.copyOf(array, array.length, array.getClass());\n+    }\n+\n+    public static Class testGetSuperclass1(Object[] array) {\n+        return array.getClass().getSuperclass();\n+    }\n+\n+    public static Class testGetSuperclass2() {\n+        return Object[].class.getSuperclass();\n+    }\n+\n+    public static Class testGetSuperclass3() {\n+        return TestArrayMetadata[].class.getSuperclass();\n+    }\n+\n+    public static Object[] testClassCast1(Object array) {\n+        return Object[].class.cast(array);\n+    }\n+\n+    public static Object[] testClassCast2(Object array) {\n+        return TestArrayMetadata[].class.cast(array);\n+    }\n+\n+    public static Object testClassCast3(Class c, Object array) {\n+        return c.cast(array);\n+    }\n+\n+    public static void test5(Object[] array, Object obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test6(Object[][] array, Object[] obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test7(Object[][][] array, Object[][] obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test8(Object[][][][] array, Object[][][] obj) {\n+        array[0] = obj;\n+    }\n+\n+    public static void test9(Object[][] array) {\n+        array[0] = (Object[]) new Object[0];\n+    }\n+\n+    public static void test10(Object[][] array) {\n+        array[0] = new String[0];\n+    }\n+\n+    public static boolean testIsAssignableFrom1(Class clazz1, Class clazz2) {\n+        return clazz1.isAssignableFrom(clazz2);\n+    }\n+\n+    public static boolean testIsAssignableFrom2(Object obj, Class clazz) {\n+        return obj.getClass().isAssignableFrom(clazz);\n+    }\n+\n+    public static boolean testIsAssignableFrom3(Class clazz, Object obj) {\n+        return clazz.isAssignableFrom(obj.getClass());\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100_000; ++i) {\n+            Object[] array1 = testArrayAllocation1();\n+            Object[][] array2 = testArrayAllocation2();\n+            Object[] array3 = testArrayAllocation3();\n+            Object[] array4 = testArrayAllocation4();\n+            Object[] array5 = testArrayAllocation5();\n+            Object[] array6 = testArrayAllocation6();\n+\n+            testCheckcast1(new Object[0]);\n+            testCheckcast1(new TestArrayMetadata[0]);\n+            testCheckcast1(array1);\n+            testCheckcast1(array3);\n+            testCheckcast1(array4);\n+            testCheckcast1(array5);\n+            testCheckcast1(array6);\n+            try {\n+                testCheckcast1(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testCheckcast2(new Object[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testCheckcast2(array1);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            testCheckcast2(new TestArrayMetadata[0]);\n+            testCheckcast2(array4);\n+            try {\n+                testCheckcast2(array5);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testCheckcast2(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            testCheckcast3(new Object[0]);\n+            testCheckcast3(new TestArrayMetadata[0]);\n+            testCheckcast3(array1);\n+            testCheckcast3(array3);\n+            testCheckcast3(array4);\n+            testCheckcast3(array5);\n+            testCheckcast3(array6);\n+            try {\n+                testCheckcast3(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testCheckcast4(new Object[0]);\n+            testCheckcast4(new TestArrayMetadata[0]);\n+            testCheckcast4(array1);\n+            testCheckcast4(array3);\n+            testCheckcast4(array4);\n+            testCheckcast4(array5);\n+            testCheckcast4(array6);\n+            testCheckcast4(42);\n+\n+            testCheckcast5(new Object[0][0]);\n+            testCheckcast5(new TestArrayMetadata[0][0]);\n+            testCheckcast5(array2);\n+            try {\n+                testCheckcast5(42);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testCheckcast6(array5);\n+\n+            testCheckcast7(array6);\n+\n+            testCopyOf1(new Object[1], Object[].class);\n+            testCopyOf1(new TestArrayMetadata[1], Object[].class);\n+            testCopyOf1(new Object[1], TestArrayMetadata[].class);\n+            testCopyOf1(new TestArrayMetadata[1], TestArrayMetadata[].class);\n+            try {\n+                testCopyOf1(new TestArrayMetadata[]{new TestArrayMetadata()}, Integer[].class);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n+\n+            testCopyOf2(new Object[1]);\n+            testCopyOf2(new TestArrayMetadata[1]);\n+\n+            testClassCast1(new Object[0]);\n+            testClassCast1(new TestArrayMetadata[0]);\n+            try {\n+                testClassCast1(new int[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testClassCast2(new TestArrayMetadata[0]);\n+            try {\n+                testClassCast2(new Object[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+            try {\n+                testClassCast2(new int[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            testClassCast3(TestArrayMetadata[].class, new TestArrayMetadata[0]);\n+            testClassCast3(Object[].class, new TestArrayMetadata[0]);\n+            testClassCast3(Object[].class, new Object[0]);\n+            testClassCast3(int[].class, new int[0]);\n+            try {\n+                testClassCast3(TestArrayMetadata[].class, new int[0]);\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ClassCastException e) {\n+                \/\/ Expected\n+            }\n+\n+            Asserts.assertEQ(testGetSuperclass1(new Object[1]), Object.class);\n+            Asserts.assertEQ(testGetSuperclass1(new TestArrayMetadata[1]), Object.class);\n+            Asserts.assertEQ(testGetSuperclass2(), Object.class);\n+            Asserts.assertEQ(testGetSuperclass3(), Object.class);\n+\n+            Asserts.assertTrue(testIsInstance1(new Object[0]));\n+            Asserts.assertTrue(testIsInstance1(new TestArrayMetadata[0]));\n+            Asserts.assertFalse(testIsInstance1(42));\n+            Asserts.assertTrue(testIsInstance1(array1));\n+            Asserts.assertTrue(testIsInstance1(array3));\n+            Asserts.assertTrue(testIsInstance1(array4));\n+            Asserts.assertTrue(testIsInstance1(array5));\n+            Asserts.assertTrue(testIsInstance1(array6));\n+\n+            Asserts.assertFalse(testIsInstance2(new Object[0]));\n+            Asserts.assertTrue(testIsInstance2(new TestArrayMetadata[0]));\n+            Asserts.assertFalse(testIsInstance2(42));\n+            Asserts.assertFalse(testIsInstance2(array1));\n+            Asserts.assertFalse(testIsInstance2(array3));\n+            Asserts.assertTrue(testIsInstance2(array4));\n+            Asserts.assertFalse(testIsInstance2(array5));\n+            Asserts.assertFalse(testIsInstance2(array6));\n+\n+            Asserts.assertTrue(testIsInstance3(new Object[0]));\n+            Asserts.assertTrue(testIsInstance3(new TestArrayMetadata[0]));\n+            Asserts.assertFalse(testIsInstance3(42));\n+            Asserts.assertTrue(testIsInstance3(array1));\n+            Asserts.assertTrue(testIsInstance3(array3));\n+            Asserts.assertTrue(testIsInstance3(array4));\n+            Asserts.assertTrue(testIsInstance3(array5));\n+            Asserts.assertTrue(testIsInstance3(array6));\n+\n+            Asserts.assertTrue(testIsInstance4(new Object[0]));\n+            Asserts.assertTrue(testIsInstance4(new TestArrayMetadata[0]));\n+            Asserts.assertTrue(testIsInstance4(42));\n+            Asserts.assertTrue(testIsInstance4(array1));\n+            Asserts.assertTrue(testIsInstance4(array3));\n+            Asserts.assertTrue(testIsInstance4(array4));\n+            Asserts.assertTrue(testIsInstance4(array5));\n+            Asserts.assertTrue(testIsInstance4(array6));\n+\n+            Asserts.assertTrue(testIsInstance5(new Object[0][0]));\n+            Asserts.assertTrue(testIsInstance5(new TestArrayMetadata[0][0]));\n+            Asserts.assertTrue(testIsInstance5(array2));\n+            Asserts.assertFalse(testIsInstance5(42));\n+\n+            test5(new Object[1], new TestArrayMetadata());\n+            test5((new Object[1][1])[0], (new TestArrayMetadata[1])[0]);\n+            test5(new String[1], \"42\");\n+            test5((new String[1][1])[0], (new String[1])[0]);\n+            test5(array1, new TestArrayMetadata());\n+            test5(array3, new TestArrayMetadata());\n+            test5(array4, new TestArrayMetadata());\n+            try {\n+                test5(array5, new TestArrayMetadata());\n+                throw new RuntimeException(\"No exception thrown\");\n+            } catch (ArrayStoreException e) {\n+                \/\/ Expected\n+            }\n+\n+            test6(new Object[1][1], new TestArrayMetadata[0]);\n+            test6((new Object[1][1][1])[0], (new TestArrayMetadata[1][0])[0]);\n+            test6(new String[1][1], new String[0]);\n+            test6((new String[1][1][1])[0], (new String[1][0])[0]);\n+            test6(array2, new TestArrayMetadata[0]);\n+\n+            test7(new Object[1][1][1], new TestArrayMetadata[0][0]);\n+            test7((new Object[1][1][1][1])[0], (new TestArrayMetadata[1][0][0])[0]);\n+            test7(new String[1][1][1], new String[0][0]);\n+            test7((new String[1][1][1][1])[0], (new String[1][0][0])[0]);\n+\n+            test8(new Object[1][1][1][1], new TestArrayMetadata[0][0][0]);\n+            test8((new Object[1][1][1][1][1])[0], (new TestArrayMetadata[1][0][0][0])[0]);\n+            test8(new String[1][1][1][1], new String[0][0][0]);\n+            test8((new String[1][1][1][1][1])[0], (new String[1][0][0][0])[0]);\n+\n+            test9(new Object[1][1]);\n+            test9(array2);\n+\n+            test10(new String[1][1]);\n+            test10(array2);\n+\n+            Asserts.assertTrue(testIsAssignableFrom1(Object[].class, Object[].class));\n+            Asserts.assertTrue(testIsAssignableFrom1(Object[].class, TestArrayMetadata[].class));\n+            Asserts.assertTrue(testIsAssignableFrom1(int[].class, int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom1(Object[].class, int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom1(Object[].class, TestArrayMetadata.class));\n+\n+            Asserts.assertTrue(testIsAssignableFrom2(new Object[0], Object[].class));\n+            Asserts.assertTrue(testIsAssignableFrom2(new Object[0], TestArrayMetadata[].class));\n+            Asserts.assertTrue(testIsAssignableFrom2(new int[0], int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom2(new Object[0], int[].class));\n+            Asserts.assertFalse(testIsAssignableFrom2(new Object[0], TestArrayMetadata.class));\n+\n+            Asserts.assertTrue(testIsAssignableFrom3(Object[].class, new Object[0]));\n+            Asserts.assertTrue(testIsAssignableFrom3(Object[].class, new TestArrayMetadata[0]));\n+            Asserts.assertTrue(testIsAssignableFrom3(int[].class, new int[0]));\n+            Asserts.assertFalse(testIsAssignableFrom3(Object[].class, new int[0]));\n+            Asserts.assertFalse(testIsAssignableFrom3(Object[].class, new TestArrayMetadata()));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayMetadata.java","additions":465,"deletions":0,"binary":false,"changes":465,"status":"added"},{"patch":"@@ -0,0 +1,1282 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @summary Test support for null markers in (flat) arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ *\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ *\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:CompileCommand=dontinline,*::test* -XX:CompileCommand=dontinline,*::check*\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-MonomorphicArrayCheck -XX:-UseArrayLoadStoreProfile\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ *\/\n+\n+public class TestArrayNullMarkers {\n+\n+    private static final WhiteBox WHITEBOX = WhiteBox.getWhiteBox();\n+    private static final boolean UseArrayFlattening = WHITEBOX.getBooleanVMFlag(\"UseArrayFlattening\");\n+    private static final boolean UseNullableValueFlattening = WHITEBOX.getBooleanVMFlag(\"UseNullableValueFlattening\");\n+    private static final boolean UseNonAtomicValueFlattening = WHITEBOX.getBooleanVMFlag(\"UseNonAtomicValueFlattening\");\n+    private static final boolean UseAtomicValueFlattening = WHITEBOX.getBooleanVMFlag(\"UseAtomicValueFlattening\");\n+    private static final boolean ForceNonTearable = !WHITEBOX.getStringVMFlag(\"ForceNonTearable\").equals(\"\");\n+\n+    \/\/ Is naturally atomic and has null-free, non-atomic, flat (1 bytes), null-free, atomic, flat (1 bytes) and nullable, atomic, flat (4 bytes) layouts\n+    @LooselyConsistentValue\n+    static value class OneByte {\n+        byte b;\n+\n+        public OneByte(byte b) {\n+            this.b = b;\n+        }\n+\n+        static final OneByte DEFAULT = new OneByte((byte)0);\n+    }\n+\n+    \/\/ Has null-free, non-atomic, flat (2 bytes), null-free, atomic, flat (2 bytes) and nullable, atomic, flat (4 bytes) layouts\n+    @LooselyConsistentValue\n+    static value class TwoBytes {\n+        byte b1;\n+        byte b2;\n+\n+        public TwoBytes(byte b1, byte b2) {\n+            this.b1 = b1;\n+            this.b2 = b2;\n+        }\n+\n+        static final TwoBytes DEFAULT = new TwoBytes((byte)0, (byte)0);\n+    }\n+\n+    \/\/ Has null-free, non-atomic, flat (4 bytes), null-free, atomic, flat (4 bytes) and nullable, atomic, flat (8 bytes) layouts\n+    @LooselyConsistentValue\n+    static value class TwoShorts {\n+        short s1;\n+        short s2;\n+\n+        public TwoShorts(short s1, short s2) {\n+            this.s1 = s1;\n+            this.s2 = s2;\n+        }\n+\n+        static final TwoShorts DEFAULT = new TwoShorts((short)0, (short)0);\n+    }\n+\n+    \/\/ Has null-free, non-atomic flat (8 bytes) and null-free, atomic, flat (8 bytes) layouts\n+    @LooselyConsistentValue\n+    static value class TwoInts {\n+        int i1;\n+        int i2;\n+\n+        public TwoInts(int i1, int i2) {\n+            this.i1 = i1;\n+            this.i2 = i2;\n+        }\n+\n+        static final TwoInts DEFAULT = new TwoInts(0, 0);\n+    }\n+\n+    \/\/ Has null-free, non-atomic flat (16 bytes) layout\n+    @LooselyConsistentValue\n+    static value class TwoLongs {\n+        long l1;\n+        long l2;\n+\n+        public TwoLongs(int l1, int l2) {\n+            this.l1 = l1;\n+            this.l2 = l2;\n+        }\n+\n+        static final TwoLongs DEFAULT = new TwoLongs(0, 0);\n+    }\n+\n+    \/\/ Has null-free, non-atomic, flat (5 bytes), null-free, atomic, flat (8 bytes) and nullable, atomic, flat (8 bytes) layouts\n+    @LooselyConsistentValue\n+    static value class ByteAndOop {\n+        byte b;\n+        MyClass obj;\n+\n+        public ByteAndOop(byte b, MyClass obj) {\n+            this.b = b;\n+            this.obj = obj;\n+        }\n+\n+        static final ByteAndOop DEFAULT = new ByteAndOop((byte)0, null);\n+    }\n+\n+    static class MyClass {\n+        int x;\n+\n+        public MyClass(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class IntAndArrayOop {\n+        int i;\n+        MyClass[] array;\n+\n+        public IntAndArrayOop(int i, MyClass[] array) {\n+            this.i = i;\n+            this.array = array;\n+        }\n+\n+        static final IntAndArrayOop DEFAULT = new IntAndArrayOop(0, null);\n+    }\n+\n+    public static void testWrite0(OneByte[] array, int i, OneByte val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite1(TwoBytes[] array, int i, TwoBytes val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite2(TwoShorts[] array, int i, TwoShorts val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite3(TwoInts[] array, int i, TwoInts val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite4(TwoLongs[] array, int i, TwoLongs val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite5(ByteAndOop[] array, int i, ByteAndOop val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite6(Object[] array, int i, Object val) {\n+        array[i] = val;\n+    }\n+\n+    public static OneByte testRead0(OneByte[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoBytes testRead1(TwoBytes[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoShorts testRead2(TwoShorts[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoInts testRead3(TwoInts[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoLongs testRead4(TwoLongs[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static ByteAndOop testRead5(ByteAndOop[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static Object testRead6(Object[] array, int i) {\n+        return array[i];\n+    }\n+\n+    static final OneByte CANARY0 = new OneByte((byte)42);\n+\n+    public static void checkCanary0(OneByte[] array) {\n+        Asserts.assertEQ(array[0], CANARY0);\n+        Asserts.assertEQ(array[2], CANARY0);\n+    }\n+\n+    static final TwoBytes CANARY1 = new TwoBytes((byte)42, (byte)42);\n+\n+    public static void checkCanary1(TwoBytes[] array) {\n+        Asserts.assertEQ(array[0], CANARY1);\n+        Asserts.assertEQ(array[2], CANARY1);\n+    }\n+\n+    static final TwoShorts CANARY2 = new TwoShorts((short)42, (short)42);\n+\n+    public static void checkCanary2(TwoShorts[] array) {\n+        Asserts.assertEQ(array[0], CANARY2);\n+        Asserts.assertEQ(array[2], CANARY2);\n+    }\n+\n+    static final TwoInts CANARY3 = new TwoInts(42, 42);\n+\n+    public static void checkCanary3(TwoInts[] array) {\n+        Asserts.assertEQ(array[0], CANARY3);\n+        Asserts.assertEQ(array[2], CANARY3);\n+    }\n+\n+    static final TwoLongs CANARY4 = new TwoLongs(42, 42);\n+\n+    public static void checkCanary4(TwoLongs[] array) {\n+        Asserts.assertEQ(array[0], CANARY4);\n+        Asserts.assertEQ(array[2], CANARY4);\n+    }\n+\n+    static final ByteAndOop CANARY5 = new ByteAndOop((byte)42, new MyClass(42));\n+\n+    public static void checkCanary5(ByteAndOop[] array) {\n+        Asserts.assertEQ(array[0], CANARY5);\n+        Asserts.assertEQ(array[2], CANARY5);\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsic(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, TwoBytes.DEFAULT);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], TwoBytes.DEFAULT);\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    \/\/ Non-final value to initialize null-restricted arrays\n+    static Object initVal1 = CANARY1;\n+    static TwoBytes initVal2 = CANARY1;\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsicDynamic1(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, initVal1);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], CANARY1);\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsicDynamic2(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, initVal2);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], CANARY1);\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    static byte myByte = 0;\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsicDynamic3(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, size, new TwoBytes(++myByte, myByte));\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertTrue(!ValueClass.isFlatArray(nullFreeArray) || !ValueClass.isAtomicArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], new TwoBytes(myByte, myByte));\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsic(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, TwoBytes.DEFAULT);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], TwoBytes.DEFAULT);\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsicDynamic1(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, initVal1);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], CANARY1);\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsicDynamic2(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, initVal2);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], CANARY1);\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsicDynamic3(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size, new TwoBytes(++myByte, myByte));\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        }\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], new TwoBytes(myByte, myByte));\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullableAtomicArrayIntrinsic(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullableAtomicArray = (TwoBytes[])ValueClass.newNullableAtomicArray(TwoBytes.class, size);\n+        if (!ForceNonTearable) {\n+            Asserts.assertEquals(ValueClass.isFlatArray(nullableAtomicArray), UseArrayFlattening && UseNullableValueFlattening);\n+        }\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray(nullableAtomicArray));\n+        Asserts.assertTrue(ValueClass.isAtomicArray(nullableAtomicArray));\n+        Asserts.assertEquals(nullableAtomicArray[idx], null);\n+        testWrite1(nullableAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullableAtomicArray, idx), val);\n+        return nullableAtomicArray;\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValueEmpty {\n+        static final MyValueEmpty DEFAULT = new MyValueEmpty();\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class ValueHolder1 {\n+        TwoBytes val;\n+\n+        public ValueHolder1(TwoBytes val) {\n+            this.val = val;\n+        }\n+\n+        static final ValueHolder1 DEFAULT = new ValueHolder1(null);\n+    }\n+\n+    \/\/ Test support for replaced arrays\n+    public static void testScalarReplacement1(OneByte valNullFree, OneByte val, boolean trap) {\n+        OneByte[] nullFreeArray = (OneByte[])ValueClass.newNullRestrictedNonAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n+        nullFreeArray[0] = valNullFree;\n+        nullFreeArray[1] = new OneByte((byte)42);\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeArray[0], valNullFree);\n+            Asserts.assertEQ(nullFreeArray[1], new OneByte((byte)42));\n+        }\n+\n+        OneByte[] nullFreeAtomicArray = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n+        nullFreeAtomicArray[0] = valNullFree;\n+        nullFreeAtomicArray[1] = new OneByte((byte)42);\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeAtomicArray[0], valNullFree);\n+            Asserts.assertEQ(nullFreeAtomicArray[1], new OneByte((byte)42));\n+        }\n+\n+        OneByte[] nullableAtomicArray = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 4);\n+        nullableAtomicArray[0] = valNullFree;\n+        nullableAtomicArray[1] = val;\n+        nullableAtomicArray[2] = new OneByte((byte)42);\n+        nullableAtomicArray[3] = null;\n+        if (trap) {\n+            Asserts.assertEQ(nullableAtomicArray[0], valNullFree);\n+            Asserts.assertEQ(nullableAtomicArray[1], val);\n+            Asserts.assertEQ(nullableAtomicArray[2], new OneByte((byte)42));\n+            Asserts.assertEQ(nullableAtomicArray[3], null);\n+        }\n+\n+        OneByte[] nullableArray = new OneByte[4];\n+        nullableArray[0] = valNullFree;\n+        nullableArray[1] = val;\n+        nullableArray[2] = new OneByte((byte)42);\n+        nullableArray[3] = null;\n+        if (trap) {\n+            Asserts.assertEQ(nullableArray[0], valNullFree);\n+            Asserts.assertEQ(nullableArray[1], val);\n+            Asserts.assertEQ(nullableArray[2], new OneByte((byte)42));\n+            Asserts.assertEQ(nullableArray[3], null);\n+        }\n+    }\n+\n+    \/\/ Test support for scalar replaced arrays\n+    public static void testScalarReplacement2(TwoBytes val, boolean trap) {\n+        ValueHolder1[] nullFreeArray = (ValueHolder1[])ValueClass.newNullRestrictedNonAtomicArray(ValueHolder1.class, 1, ValueHolder1.DEFAULT);\n+        nullFreeArray[0] = new ValueHolder1(val);\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeArray[0].val, val);\n+        }\n+\n+        ValueHolder1[] nullFreeAtomicArray = (ValueHolder1[])ValueClass.newNullRestrictedAtomicArray(ValueHolder1.class, 1, ValueHolder1.DEFAULT);\n+        nullFreeAtomicArray[0] = new ValueHolder1(val);\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeAtomicArray[0].val, val);\n+        }\n+\n+        ValueHolder1[] nullableAtomicArray = (ValueHolder1[])ValueClass.newNullableAtomicArray(ValueHolder1.class, 2);\n+        nullableAtomicArray[0] = new ValueHolder1(val);\n+        nullableAtomicArray[1] = ValueHolder1.DEFAULT;\n+        if (trap) {\n+            Asserts.assertEQ(nullableAtomicArray[0].val, val);\n+            Asserts.assertEQ(nullableAtomicArray[1].val, null);\n+        }\n+\n+        ValueHolder1[] nullableArray = new ValueHolder1[2];\n+        nullableArray[0] = new ValueHolder1(val);\n+        nullableArray[1] = ValueHolder1.DEFAULT;\n+        if (trap) {\n+            Asserts.assertEQ(nullableArray[0].val, val);\n+            Asserts.assertEQ(nullableArray[1].val, null);\n+        }\n+    }\n+\n+    static void produceGarbage() {\n+        for (int i = 0; i < 100; ++i) {\n+            Object[] arrays = new Object[1024];\n+            for (int j = 0; j < arrays.length; j++) {\n+                arrays[j] = new int[1024];\n+            }\n+        }\n+        System.gc();\n+    }\n+\n+    static TwoShorts[] array1 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 1, TwoShorts.DEFAULT);\n+    static TwoShorts[] array2 = (TwoShorts[])ValueClass.newNullableAtomicArray(TwoShorts.class, 1);\n+    static {\n+        array2[0] = TwoShorts.DEFAULT;\n+    }\n+    static TwoShorts[] array3 = new TwoShorts[] { TwoShorts.DEFAULT };\n+\n+    \/\/ Catches an issue with type speculation based on profiling\n+    public static void testProfiling() {\n+        array1[0] = new TwoShorts(array1[0].s1, (short)0);\n+        array2[0] = new TwoShorts(array2[0].s1, (short)0);\n+        array3[0] = new TwoShorts(array3[0].s1, (short)0);\n+    }\n+\n+    static final OneByte[] NULL_FREE_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedNonAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n+    static final OneByte[] NULL_FREE_ATOMIC_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 2, OneByte.DEFAULT);\n+    static final OneByte[] NULLABLE_ARRAY_0 = new OneByte[2];\n+    static final OneByte[] NULLABLE_ATOMIC_ARRAY_0 = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 2);\n+\n+    static final TwoBytes[] NULL_FREE_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, 2, TwoBytes.DEFAULT);\n+    static final TwoBytes[] NULL_FREE_ATOMIC_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 2, TwoBytes.DEFAULT);\n+    static final TwoBytes[] NULLABLE_ARRAY_1 = new TwoBytes[2];\n+    static final TwoBytes[] NULLABLE_ATOMIC_ARRAY_1 = (TwoBytes[])ValueClass.newNullableAtomicArray(TwoBytes.class, 2);\n+\n+    static final TwoShorts[] NULL_FREE_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedNonAtomicArray(TwoShorts.class, 2, TwoShorts.DEFAULT);\n+    static final TwoShorts[] NULL_FREE_ATOMIC_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 2, TwoShorts.DEFAULT);\n+    static final TwoShorts[] NULLABLE_ARRAY_2 = new TwoShorts[2];\n+    static final TwoShorts[] NULLABLE_ATOMIC_ARRAY_2 = (TwoShorts[])ValueClass.newNullableAtomicArray(TwoShorts.class, 2);\n+\n+    static final TwoInts[] NULL_FREE_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedNonAtomicArray(TwoInts.class, 1, TwoInts.DEFAULT);\n+    static final TwoInts[] NULL_FREE_ATOMIC_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 1, TwoInts.DEFAULT);\n+    static final TwoInts[] NULLABLE_ARRAY_3 = new TwoInts[1];\n+    static final TwoInts[] NULLABLE_ATOMIC_ARRAY_3 = (TwoInts[])ValueClass.newNullableAtomicArray(TwoInts.class, 1);\n+\n+    static final TwoLongs[] NULL_FREE_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedNonAtomicArray(TwoLongs.class, 1, TwoLongs.DEFAULT);\n+    static final TwoLongs[] NULL_FREE_ATOMIC_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 1, TwoLongs.DEFAULT);\n+    static final TwoLongs[] NULLABLE_ARRAY_4 = new TwoLongs[1];\n+    static final TwoLongs[] NULLABLE_ATOMIC_ARRAY_4 = (TwoLongs[])ValueClass.newNullableAtomicArray(TwoLongs.class, 1);\n+\n+    static final ByteAndOop[] NULL_FREE_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedNonAtomicArray(ByteAndOop.class, 1, ByteAndOop.DEFAULT);\n+    static final ByteAndOop[] NULL_FREE_ATOMIC_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 1, ByteAndOop.DEFAULT);\n+    static final ByteAndOop[] NULLABLE_ARRAY_5 = new ByteAndOop[1];\n+    static final ByteAndOop[] NULLABLE_ATOMIC_ARRAY_5 = (ByteAndOop[])ValueClass.newNullableAtomicArray(ByteAndOop.class, 1);\n+\n+    \/\/ Test access to constant arrays\n+    public static void testConstantArrays(int i) {\n+        OneByte val0 = new OneByte((byte)i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_0[0], OneByte.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_0[0], OneByte.DEFAULT);\n+        Asserts.assertEQ(NULLABLE_ARRAY_0[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_0[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_0[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_0[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_0[0] = val0;\n+        NULL_FREE_ATOMIC_ARRAY_0[0] = val0;\n+        NULLABLE_ARRAY_0[0] = val0;\n+        NULLABLE_ATOMIC_ARRAY_0[0] = val0;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_0[0], val0);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_0[0], val0);\n+        Asserts.assertEQ(NULLABLE_ARRAY_0[0], val0);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_0[0], val0);\n+\n+        NULL_FREE_ARRAY_0[0] = OneByte.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_0[0] = OneByte.DEFAULT;\n+        NULLABLE_ARRAY_0[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_0[0] = null;\n+\n+        TwoBytes val1 = new TwoBytes((byte)i, (byte)i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_1[0], TwoBytes.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_1[0], TwoBytes.DEFAULT);\n+        Asserts.assertEQ(NULLABLE_ARRAY_1[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_1[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_1[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_1[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_1[0] = val1;\n+        NULL_FREE_ATOMIC_ARRAY_1[0] = val1;\n+        NULLABLE_ARRAY_1[0] = val1;\n+        NULLABLE_ATOMIC_ARRAY_1[0] = val1;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_1[0], val1);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_1[0], val1);\n+        Asserts.assertEQ(NULLABLE_ARRAY_1[0], val1);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_1[0], val1);\n+\n+        NULL_FREE_ARRAY_1[0] = TwoBytes.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_1[0] = TwoBytes.DEFAULT;\n+        NULLABLE_ARRAY_1[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_1[0] = null;\n+\n+        TwoShorts val2 = new TwoShorts((short)i, (short)i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_2[0], TwoShorts.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_2[0], TwoShorts.DEFAULT);\n+        Asserts.assertEQ(NULLABLE_ARRAY_2[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_2[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_2[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_2[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_2[0] = val2;\n+        NULL_FREE_ATOMIC_ARRAY_2[0] = val2;\n+        NULLABLE_ARRAY_2[0] = val2;\n+        NULLABLE_ATOMIC_ARRAY_2[0] = val2;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_2[0], val2);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_2[0], val2);\n+        Asserts.assertEQ(NULLABLE_ARRAY_2[0], val2);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_2[0], val2);\n+\n+        NULL_FREE_ARRAY_2[0] = TwoShorts.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_2[0] = TwoShorts.DEFAULT;\n+        NULLABLE_ARRAY_2[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_2[0] = null;\n+\n+        TwoInts val3 = new TwoInts(i, i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_3[0], TwoInts.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_3[0], TwoInts.DEFAULT);\n+        Asserts.assertEQ(NULLABLE_ARRAY_3[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_3[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_3[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_3[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_3[0] = val3;\n+        NULL_FREE_ATOMIC_ARRAY_3[0] = val3;\n+        NULLABLE_ARRAY_3[0] = val3;\n+        NULLABLE_ATOMIC_ARRAY_3[0] = val3;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_3[0], val3);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_3[0], val3);\n+        Asserts.assertEQ(NULLABLE_ARRAY_3[0], val3);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_3[0], val3);\n+\n+        NULL_FREE_ARRAY_3[0] = TwoInts.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_3[0] = TwoInts.DEFAULT;\n+        NULLABLE_ARRAY_3[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_3[0] = null;\n+\n+        TwoLongs val4 = new TwoLongs(i, i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_4[0], TwoLongs.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_4[0], TwoLongs.DEFAULT);\n+        Asserts.assertEQ(NULLABLE_ARRAY_4[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_4[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_4[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_4[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_4[0] = val4;\n+        NULL_FREE_ATOMIC_ARRAY_4[0] = val4;\n+        NULLABLE_ARRAY_4[0] = val4;\n+        NULLABLE_ATOMIC_ARRAY_4[0] = val4;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_4[0], val4);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_4[0], val4);\n+        Asserts.assertEQ(NULLABLE_ARRAY_4[0], val4);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_4[0], val4);\n+\n+        NULL_FREE_ARRAY_4[0] = TwoLongs.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_4[0] = TwoLongs.DEFAULT;\n+        NULLABLE_ARRAY_4[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_4[0] = null;\n+\n+        ByteAndOop val5 = new ByteAndOop((byte)i, new MyClass(i));\n+        Asserts.assertEQ(NULL_FREE_ARRAY_5[0], ByteAndOop.DEFAULT);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_5[0], ByteAndOop.DEFAULT);\n+        Asserts.assertEQ(NULLABLE_ARRAY_5[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_5[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_5[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_5[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_5[0] = val5;\n+        NULL_FREE_ATOMIC_ARRAY_5[0] = val5;\n+        NULLABLE_ARRAY_5[0] = val5;\n+        NULLABLE_ATOMIC_ARRAY_5[0] = val5;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_5[0], val5);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_5[0], val5);\n+        Asserts.assertEQ(NULLABLE_ARRAY_5[0], val5);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_5[0], val5);\n+\n+        NULL_FREE_ARRAY_5[0] = ByteAndOop.DEFAULT;\n+        NULL_FREE_ATOMIC_ARRAY_5[0] = ByteAndOop.DEFAULT;\n+        NULLABLE_ARRAY_5[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_5[0] = null;\n+    }\n+\n+    \/\/ Test correct wiring of memory for flat accesses\n+    public static OneByte testMemoryEffects0() {\n+        NULLABLE_ARRAY_0[1] = CANARY0;\n+        NULLABLE_ATOMIC_ARRAY_0[1] = CANARY0;\n+        return NULLABLE_ARRAY_0[1];\n+    }\n+\n+    public static TwoBytes testMemoryEffects1() {\n+        NULLABLE_ARRAY_1[1] = CANARY1;\n+        NULLABLE_ATOMIC_ARRAY_1[1] = CANARY1;\n+        return NULLABLE_ARRAY_1[1];\n+    }\n+\n+    public static TwoShorts testMemoryEffects2() {\n+        NULLABLE_ARRAY_2[1] = CANARY2;\n+        NULLABLE_ATOMIC_ARRAY_2[1] = CANARY2;\n+        return NULLABLE_ARRAY_2[1];\n+    }\n+\n+    public static void main(String[] args) {\n+        OneByte[] nullFreeArray0 = (OneByte[])ValueClass.newNullRestrictedNonAtomicArray(OneByte.class, 3, OneByte.DEFAULT);\n+        OneByte[] nullFreeAtomicArray0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 3, OneByte.DEFAULT);\n+        OneByte[] nullableArray0 = new OneByte[3];\n+        OneByte[] nullableAtomicArray0 = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 3);\n+\n+        TwoBytes[] nullFreeArray1 = (TwoBytes[])ValueClass.newNullRestrictedNonAtomicArray(TwoBytes.class, 3, TwoBytes.DEFAULT);\n+        TwoBytes[] nullFreeAtomicArray1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 3, TwoBytes.DEFAULT);\n+        TwoBytes[] nullableArray1 = new TwoBytes[3];\n+        TwoBytes[] nullableAtomicArray1 = (TwoBytes[])ValueClass.newNullableAtomicArray(TwoBytes.class, 3);\n+\n+        TwoShorts[] nullFreeArray2 = (TwoShorts[])ValueClass.newNullRestrictedNonAtomicArray(TwoShorts.class, 3, TwoShorts.DEFAULT);\n+        TwoShorts[] nullFreeAtomicArray2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 3, TwoShorts.DEFAULT);\n+        TwoShorts[] nullableArray2 = new TwoShorts[3];\n+        TwoShorts[] nullableAtomicArray2 = (TwoShorts[])ValueClass.newNullableAtomicArray(TwoShorts.class, 3);\n+\n+        TwoInts[] nullFreeArray3 = (TwoInts[])ValueClass.newNullRestrictedNonAtomicArray(TwoInts.class, 3, TwoInts.DEFAULT);\n+        TwoInts[] nullFreeAtomicArray3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 3, TwoInts.DEFAULT);\n+        TwoInts[] nullableArray3 = new TwoInts[3];\n+        TwoInts[] nullableAtomicArray3 = (TwoInts[])ValueClass.newNullableAtomicArray(TwoInts.class, 3);\n+\n+        TwoLongs[] nullFreeArray4 = (TwoLongs[])ValueClass.newNullRestrictedNonAtomicArray(TwoLongs.class, 3, TwoLongs.DEFAULT);\n+        TwoLongs[] nullFreeAtomicArray4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 3, TwoLongs.DEFAULT);\n+        TwoLongs[] nullableArray4 = new TwoLongs[3];\n+        TwoLongs[] nullableAtomicArray4 = (TwoLongs[])ValueClass.newNullableAtomicArray(TwoLongs.class, 3);\n+\n+        ByteAndOop[] nullFreeArray5 = (ByteAndOop[])ValueClass.newNullRestrictedNonAtomicArray(ByteAndOop.class, 3, ByteAndOop.DEFAULT);\n+        ByteAndOop[] nullFreeAtomicArray5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 3, ByteAndOop.DEFAULT);\n+        ByteAndOop[] nullableArray5 = new ByteAndOop[3];\n+        ByteAndOop[] nullableAtomicArray5 = (ByteAndOop[])ValueClass.newNullableAtomicArray(ByteAndOop.class, 3);\n+\n+        IntAndArrayOop[] nullFreeArray6 = (IntAndArrayOop[])ValueClass.newNullRestrictedNonAtomicArray(IntAndArrayOop.class, 3, IntAndArrayOop.DEFAULT);\n+        IntAndArrayOop[] nullFreeAtomicArray6 = (IntAndArrayOop[])ValueClass.newNullRestrictedAtomicArray(IntAndArrayOop.class, 3, IntAndArrayOop.DEFAULT);\n+        IntAndArrayOop[] nullableArray6 = new IntAndArrayOop[3];\n+        IntAndArrayOop[] nullableAtomicArray6 = (IntAndArrayOop[])ValueClass.newNullableAtomicArray(IntAndArrayOop.class, 3);\n+\n+        MyValueEmpty[] nullFreeArrayEmpty = (MyValueEmpty[])ValueClass.newNullRestrictedNonAtomicArray(MyValueEmpty.class, 3, MyValueEmpty.DEFAULT);\n+        MyValueEmpty[] nullFreeAtomicArrayEmpty = (MyValueEmpty[])ValueClass.newNullRestrictedAtomicArray(MyValueEmpty.class, 3, MyValueEmpty.DEFAULT);\n+        MyValueEmpty[] nullableArrayEmpty = new MyValueEmpty[3];\n+        MyValueEmpty[] nullableAtomicArrayEmpty = (MyValueEmpty[])ValueClass.newNullableAtomicArray(MyValueEmpty.class, 3);\n+\n+        \/\/ Write canary values to detect out of bound writes\n+        nullFreeArray0[0] = CANARY0;\n+        nullFreeArray0[2] = CANARY0;\n+        nullFreeAtomicArray0[0] = CANARY0;\n+        nullFreeAtomicArray0[2] = CANARY0;\n+        nullableArray0[0] = CANARY0;\n+        nullableArray0[2] = CANARY0;\n+        nullableAtomicArray0[0] = CANARY0;\n+        nullableAtomicArray0[2] = CANARY0;\n+\n+        nullFreeArray1[0] = CANARY1;\n+        nullFreeArray1[2] = CANARY1;\n+        nullFreeAtomicArray1[0] = CANARY1;\n+        nullFreeAtomicArray1[2] = CANARY1;\n+        nullableArray1[0] = CANARY1;\n+        nullableArray1[2] = CANARY1;\n+        nullableAtomicArray1[0] = CANARY1;\n+        nullableAtomicArray1[2] = CANARY1;\n+\n+        nullFreeArray2[0] = CANARY2;\n+        nullFreeArray2[2] = CANARY2;\n+        nullFreeAtomicArray2[0] = CANARY2;\n+        nullFreeAtomicArray2[2] = CANARY2;\n+        nullableArray2[0] = CANARY2;\n+        nullableArray2[2] = CANARY2;\n+        nullableAtomicArray2[0] = CANARY2;\n+        nullableAtomicArray2[2] = CANARY2;\n+\n+        nullFreeArray3[0] = CANARY3;\n+        nullFreeArray3[2] = CANARY3;\n+        nullFreeAtomicArray3[0] = CANARY3;\n+        nullFreeAtomicArray3[2] = CANARY3;\n+        nullableArray3[0] = CANARY3;\n+        nullableArray3[2] = CANARY3;\n+        nullableAtomicArray3[0] = CANARY3;\n+        nullableAtomicArray3[2] = CANARY3;\n+\n+        nullFreeArray4[0] = CANARY4;\n+        nullFreeArray4[2] = CANARY4;\n+        nullFreeAtomicArray4[0] = CANARY4;\n+        nullFreeAtomicArray4[2] = CANARY4;\n+        nullableArray4[0] = CANARY4;\n+        nullableArray4[2] = CANARY4;\n+        nullableAtomicArray4[0] = CANARY4;\n+        nullableAtomicArray4[2] = CANARY4;\n+\n+        nullFreeArray5[0] = CANARY5;\n+        nullFreeArray5[2] = CANARY5;\n+        nullFreeAtomicArray5[0] = CANARY5;\n+        nullFreeAtomicArray5[2] = CANARY5;\n+        nullableArray5[0] = CANARY5;\n+        nullableArray5[2] = CANARY5;\n+        nullableAtomicArray5[0] = CANARY5;\n+        nullableAtomicArray5[2] = CANARY5;\n+\n+        final int LIMIT = 50_000;\n+        for (int i = -50_000; i < LIMIT; ++i) {\n+            OneByte val0 = new OneByte((byte)i);\n+            TwoBytes val1 = new TwoBytes((byte)i, (byte)(i + 1));\n+            TwoShorts val2 = new TwoShorts((short)i, (short)(i + 1));\n+            TwoInts val3 = new TwoInts(i, i + 1);\n+            TwoLongs val4 = new TwoLongs(i, i + 1);\n+\n+            testWrite0(nullFreeArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullFreeArray0, 1), val0);\n+            checkCanary0(nullFreeArray0);\n+\n+            testWrite0(nullFreeAtomicArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullFreeAtomicArray0, 1), val0);\n+            checkCanary0(nullFreeAtomicArray0);\n+\n+            testWrite0(nullableArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullableArray0, 1), val0);\n+            checkCanary0(nullableArray0);\n+            testWrite0(nullableArray0, 1, null);\n+            Asserts.assertEQ(testRead0(nullableArray0, 1), null);\n+            checkCanary0(nullableArray0);\n+\n+            testWrite0(nullableAtomicArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullableAtomicArray0, 1), val0);\n+            checkCanary0(nullableAtomicArray0);\n+            testWrite0(nullableAtomicArray0, 1, null);\n+            Asserts.assertEQ(testRead0(nullableAtomicArray0, 1), null);\n+            checkCanary0(nullableAtomicArray0);\n+\n+            testWrite1(nullFreeArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullFreeArray1, 1), val1);\n+            checkCanary1(nullFreeArray1);\n+\n+            testWrite1(nullFreeAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullFreeAtomicArray1, 1), val1);\n+            checkCanary1(nullFreeAtomicArray1);\n+\n+            testWrite1(nullableArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullableArray1, 1), val1);\n+            checkCanary1(nullableArray1);\n+            testWrite1(nullableArray1, 1, null);\n+            Asserts.assertEQ(testRead1(nullableArray1, 1), null);\n+            checkCanary1(nullableArray1);\n+\n+            testWrite1(nullableAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullableAtomicArray1, 1), val1);\n+            checkCanary1(nullableAtomicArray1);\n+            testWrite1(nullableAtomicArray1, 1, null);\n+            Asserts.assertEQ(testRead1(nullableAtomicArray1, 1), null);\n+            checkCanary1(nullableAtomicArray1);\n+\n+            testWrite2(nullFreeArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullFreeArray2, 1), val2);\n+            checkCanary2(nullFreeArray2);\n+\n+            testWrite2(nullFreeAtomicArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullFreeAtomicArray2, 1), val2);\n+            checkCanary2(nullFreeAtomicArray2);\n+\n+            testWrite2(nullableArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullableArray2, 1), val2);\n+            checkCanary2(nullableArray2);\n+            testWrite2(nullableArray2, 1, null);\n+            Asserts.assertEQ(testRead2(nullableArray2, 1), null);\n+            checkCanary2(nullableArray2);\n+\n+            testWrite2(nullableAtomicArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullableAtomicArray2, 1), val2);\n+            checkCanary2(nullableAtomicArray2);\n+            testWrite2(nullableAtomicArray2, 1, null);\n+            Asserts.assertEQ(testRead2(nullableAtomicArray2, 1), null);\n+            checkCanary2(nullableAtomicArray2);\n+\n+            testWrite3(nullFreeArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullFreeArray3, 1), val3);\n+            checkCanary3(nullFreeArray3);\n+\n+            testWrite3(nullFreeAtomicArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullFreeAtomicArray3, 1), val3);\n+            checkCanary3(nullFreeAtomicArray3);\n+\n+            testWrite3(nullableArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullableArray3, 1), val3);\n+            checkCanary3(nullableArray3);\n+            testWrite3(nullableArray3, 1, null);\n+            Asserts.assertEQ(testRead3(nullableArray3, 1), null);\n+            checkCanary3(nullableArray3);\n+\n+            testWrite3(nullableAtomicArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullableAtomicArray3, 1), val3);\n+            checkCanary3(nullableAtomicArray3);\n+            testWrite3(nullableAtomicArray3, 1, null);\n+            Asserts.assertEQ(testRead3(nullableAtomicArray3, 1), null);\n+            checkCanary3(nullableAtomicArray3);\n+\n+            testWrite4(nullFreeArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullFreeArray4, 1), val4);\n+            checkCanary4(nullFreeArray4);\n+\n+            testWrite4(nullFreeAtomicArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullFreeAtomicArray4, 1), val4);\n+            checkCanary4(nullFreeAtomicArray4);\n+\n+            testWrite4(nullableArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullableArray4, 1), val4);\n+            checkCanary4(nullableArray4);\n+            testWrite4(nullableArray4, 1, null);\n+            Asserts.assertEQ(testRead4(nullableArray4, 1), null);\n+            checkCanary4(nullableArray4);\n+\n+            testWrite4(nullableAtomicArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullableAtomicArray4, 1), val4);\n+            checkCanary4(nullableAtomicArray4);\n+            testWrite4(nullableAtomicArray4, 1, null);\n+            Asserts.assertEQ(testRead4(nullableAtomicArray4, 1), null);\n+            checkCanary4(nullableAtomicArray4);\n+\n+            ByteAndOop val5 = new ByteAndOop((byte)i, new MyClass(i));\n+            testWrite5(nullFreeArray5, 1, val5);\n+            testWrite5(nullFreeAtomicArray5, 1, val5);\n+            testWrite5(nullableArray5, 1, val5);\n+            testWrite5(nullableAtomicArray5, 1, val5);\n+\n+            IntAndArrayOop val6 = new IntAndArrayOop(i, new MyClass[1]);\n+            nullFreeArray6[1] = val6;\n+            nullFreeArray6[2] = nullFreeArray6[1];\n+            nullFreeAtomicArray6[1] = val6;\n+            nullFreeAtomicArray6[2] = nullFreeAtomicArray6[1];\n+            nullableArray6[1] = val6;\n+            nullableArray6[2] = nullableArray6[1];\n+            nullableAtomicArray6[1] = val6;\n+            nullableAtomicArray6[2] = nullableAtomicArray6[1];\n+            Asserts.assertEQ(nullFreeArray6[0], new IntAndArrayOop(0, null));\n+            Asserts.assertEQ(nullFreeAtomicArray6[0], new IntAndArrayOop(0, null));\n+            Asserts.assertEQ(nullableArray6[0], null);\n+            Asserts.assertEQ(nullableAtomicArray6[0], null);\n+            Asserts.assertEQ(nullFreeArray6[1], val6);\n+            Asserts.assertEQ(nullFreeAtomicArray6[1], val6);\n+            Asserts.assertEQ(nullableArray6[1], val6);\n+            Asserts.assertEQ(nullableAtomicArray6[1], val6);\n+            Asserts.assertEQ(nullFreeArray6[2], val6);\n+            Asserts.assertEQ(nullFreeAtomicArray6[2], val6);\n+            Asserts.assertEQ(nullableArray6[2], val6);\n+            Asserts.assertEQ(nullableAtomicArray6[2], val6);\n+\n+            \/\/ Test empty arrays\n+            MyValueEmpty valEmpty = new MyValueEmpty();\n+            nullFreeArrayEmpty[1] = valEmpty;\n+            nullFreeArrayEmpty[2] = nullFreeArrayEmpty[1];\n+            nullFreeAtomicArrayEmpty[1] = valEmpty;\n+            nullFreeAtomicArrayEmpty[2] = nullFreeAtomicArrayEmpty[1];\n+            nullableArrayEmpty[1] = valEmpty;\n+            nullableArrayEmpty[2] = nullableArrayEmpty[1];\n+            nullableAtomicArrayEmpty[1] = valEmpty;\n+            nullableAtomicArrayEmpty[2] = nullableAtomicArrayEmpty[1];\n+            Asserts.assertEQ(nullFreeArrayEmpty[0], new MyValueEmpty());\n+            Asserts.assertEQ(nullFreeAtomicArrayEmpty[0], new MyValueEmpty());\n+            Asserts.assertEQ(nullableArrayEmpty[0], null);\n+            Asserts.assertEQ(nullableAtomicArrayEmpty[0], null);\n+            Asserts.assertEQ(nullFreeArrayEmpty[1], valEmpty);\n+            Asserts.assertEQ(nullFreeAtomicArrayEmpty[1], valEmpty);\n+            Asserts.assertEQ(nullableArrayEmpty[1], valEmpty);\n+            Asserts.assertEQ(nullableAtomicArrayEmpty[1], valEmpty);\n+            Asserts.assertEQ(nullFreeArrayEmpty[2], valEmpty);\n+            Asserts.assertEQ(nullFreeAtomicArrayEmpty[2], valEmpty);\n+            Asserts.assertEQ(nullableArrayEmpty[2], valEmpty);\n+            Asserts.assertEQ(nullableAtomicArrayEmpty[2], valEmpty);\n+\n+            if (i > (LIMIT - 50)) {\n+                \/\/ After warmup, produce some garbage to trigger GC\n+                produceGarbage();\n+            }\n+\n+            Asserts.assertEQ(testRead5(nullFreeArray5, 1), val5);\n+            checkCanary5(nullFreeArray5);\n+\n+            Asserts.assertEQ(testRead5(nullFreeAtomicArray5, 1), val5);\n+            checkCanary5(nullFreeAtomicArray5);\n+\n+            Asserts.assertEQ(testRead5(nullableArray5, 1), val5);\n+            checkCanary5(nullableArray5);\n+\n+            testWrite5(nullableArray5, 1, null);\n+            Asserts.assertEQ(testRead5(nullableArray5, 1), null);\n+            checkCanary5(nullableArray5);\n+\n+            Asserts.assertEQ(testRead5(nullableAtomicArray5, 1), val5);\n+            checkCanary5(nullableAtomicArray5);\n+\n+            testWrite5(nullableAtomicArray5, 1, null);\n+            Asserts.assertEQ(testRead5(nullableAtomicArray5, 1), null);\n+            checkCanary5(nullableAtomicArray5);\n+\n+            \/\/ Test intrinsics\n+            TwoBytes[] res = testNullRestrictedArrayIntrinsic(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedArrayIntrinsicDynamic1(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedArrayIntrinsicDynamic2(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedArrayIntrinsicDynamic3(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedAtomicArrayIntrinsic(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedAtomicArrayIntrinsicDynamic1(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedAtomicArrayIntrinsicDynamic2(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedAtomicArrayIntrinsicDynamic3(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullableAtomicArrayIntrinsic(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullableAtomicArrayIntrinsic(3, 2, null);\n+            Asserts.assertEQ(testRead1(res, 2), null);\n+\n+            testProfiling();\n+\n+            \/\/ Pollute profile\n+            Object[] objArray = new Object[1];\n+            testWrite6(objArray, 0, objArray);\n+            Asserts.assertEQ(testRead6(objArray, 0), objArray);\n+\n+            testWrite6(nullFreeArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullFreeArray1, 1), val1);\n+            checkCanary1(nullFreeArray1);\n+\n+            testWrite6(nullFreeAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullFreeAtomicArray1, 1), val1);\n+            checkCanary1(nullFreeAtomicArray1);\n+\n+            testWrite6(nullableArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullableArray1, 1), val1);\n+            checkCanary1(nullableArray1);\n+            testWrite6(nullableArray1, 1, null);\n+            Asserts.assertEQ(testRead6(nullableArray1, 1), null);\n+            checkCanary1(nullableArray1);\n+\n+            testWrite6(nullableAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullableAtomicArray1, 1), val1);\n+            checkCanary1(nullableAtomicArray1);\n+            testWrite6(nullableAtomicArray1, 1, null);\n+            Asserts.assertEQ(testRead6(nullableAtomicArray1, 1), null);\n+            checkCanary1(nullableAtomicArray1);\n+\n+            \/\/ Test scalar replacement of array allocations\n+            testScalarReplacement1(val0, null, false);\n+            testScalarReplacement2(val1, false);\n+\n+            \/\/ Test access to constant arrays\n+            testConstantArrays(i);\n+\n+            \/\/ Test correct wiring of memory for flat accesses\n+            Asserts.assertEQ(testMemoryEffects0(), CANARY0);\n+            Asserts.assertEQ(testMemoryEffects1(), CANARY1);\n+            Asserts.assertEQ(testMemoryEffects2(), CANARY2);\n+        }\n+\n+        try {\n+            testWrite0(nullFreeArray0, 0, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary0(nullFreeArray0);\n+        try {\n+            testWrite0(nullFreeAtomicArray0, 0, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary0(nullFreeAtomicArray0);\n+\n+        try {\n+            testWrite1(nullFreeArray1, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary1(nullFreeArray1);\n+        try {\n+            testWrite1(nullFreeAtomicArray1, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary1(nullFreeAtomicArray1);\n+\n+        try {\n+            testWrite2(nullFreeArray2, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary2(nullFreeArray2);\n+        try {\n+            testWrite2(nullFreeAtomicArray2, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary2(nullFreeAtomicArray2);\n+\n+        try {\n+            testWrite3(nullFreeArray3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary3(nullFreeArray3);\n+        try {\n+            testWrite3(nullFreeAtomicArray3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary3(nullFreeAtomicArray3);\n+\n+        try {\n+            testWrite4(nullFreeArray4, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary4(nullFreeArray4);\n+        try {\n+            testWrite4(nullFreeAtomicArray4, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary4(nullFreeAtomicArray4);\n+\n+        try {\n+            testWrite5(nullFreeArray5, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary5(nullFreeArray5);\n+        try {\n+            testWrite5(nullFreeAtomicArray5, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary5(nullFreeAtomicArray5);\n+\n+        \/\/ Test intrinsics\n+        try {\n+            testNullRestrictedArrayIntrinsic(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedArrayIntrinsicDynamic1(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedArrayIntrinsicDynamic2(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedArrayIntrinsicDynamic3(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsic(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsicDynamic1(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsicDynamic2(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsicDynamic3(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        testScalarReplacement1(CANARY0, null, true);\n+        testScalarReplacement2(CANARY1, true);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":1282,"deletions":0,"binary":false,"changes":1282,"status":"added"},{"patch":"@@ -0,0 +1,631 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @summary Test value class calling convention with compiled to compiled calls.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   TestC2CCalls\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls*::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch -XX:-ProfileInterpreter\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls*::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-UseBimorphicInlining -Xbatch -XX:-ProfileInterpreter\n+ *                   -XX:CompileCommand=compileonly,TestC2CCalls::test*\n+ *                   -XX:CompileCommand=dontinline,TestC2CCalls*::test*\n+ *                   TestC2CCalls\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestC2CCalls {\n+    public static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    public static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+    public static final int rI = Utils.getRandomInstance().nextInt() % 1000;\n+\n+    static value class OtherVal {\n+        public int x;\n+\n+        private OtherVal(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    static interface MyInterface1 {\n+        public MyInterface1 test1(OtherVal other, int y);\n+        public MyInterface1 test2(OtherVal other1, OtherVal other2, int y);\n+        public MyInterface1 test3(OtherVal other1, OtherVal other2, int y, boolean deopt);\n+        public MyInterface1 test4(OtherVal other1, OtherVal other2, int y);\n+        public MyInterface1 test5(OtherVal other1, OtherVal other2, int y);\n+        public MyInterface1 test6();\n+        public MyInterface1 test7(int i1, int i2, int i3, int i4, int i5, int i6);\n+        public MyInterface1 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7);\n+        public MyInterface1 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6);\n+        public MyInterface1 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6);\n+\n+        public int getValue();\n+    }\n+\n+    static value class MyValue1 implements MyInterface1 {\n+        public int x;\n+\n+        private MyValue1(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public MyValue1 test1(OtherVal other, int y) {\n+            return new MyValue1(x + other.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test2(OtherVal other1, OtherVal other2, int y) {\n+            return new MyValue1(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test3(OtherVal other1, OtherVal other2, int y, boolean deopt) {\n+            if (!deopt) {\n+              return new MyValue1(x + other1.x + other2.x + y);\n+            } else {\n+              \/\/ Uncommon trap\n+              return test1(other1, y);\n+            }\n+        }\n+\n+        @Override\n+        public MyValue1 test4(OtherVal other1, OtherVal other2, int y) {\n+            return new MyValue1(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test5(OtherVal other1, OtherVal other2, int y) {\n+            return new MyValue1(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue1 test6() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MyValue1 test7(int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue1(x + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue1 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue1(x + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue1 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue1(x + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue1 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue1(x + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static value class MyValue2 implements MyInterface1 {\n+        public int x;\n+\n+        private MyValue2(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public MyValue2 test1(OtherVal other, int y) {\n+            return new MyValue2(x + other.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test2(OtherVal other1, OtherVal other2, int y) {\n+            return new MyValue2(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test3(OtherVal other1, OtherVal other2, int y, boolean deopt) {\n+            if (!deopt) {\n+              return new MyValue2(x + other1.x + other2.x + y);\n+            } else {\n+              \/\/ Uncommon trap\n+              return test1(other1, y);\n+            }\n+        }\n+\n+        @Override\n+        public MyValue2 test4(OtherVal other1, OtherVal other2, int y) {\n+            return new MyValue2(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test5(OtherVal other1, OtherVal other2, int y) {\n+            return new MyValue2(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyValue2 test6() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MyValue2 test7(int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue2(x + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue2 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue2(x + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue2 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue2(x + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue2 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue2(x + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static value class MyValue3 implements MyInterface1 {\n+        public double d1;\n+        public double d2;\n+        public double d3;\n+        public double d4;\n+\n+        private MyValue3(double d) {\n+            this.d1 = d;\n+            this.d2 = d;\n+            this.d3 = d;\n+            this.d4 = d;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return (int)d4;\n+        }\n+\n+        @Override\n+        public MyValue3 test1(OtherVal other, int y) { return new MyValue3(0); }\n+        @Override\n+        public MyValue3 test2(OtherVal other1, OtherVal other2, int y)  { return new MyValue3(0); }\n+        @Override\n+        public MyValue3 test3(OtherVal other1, OtherVal other2, int y, boolean deopt)  { return new MyValue3(0); }\n+        @Override\n+        public MyValue3 test4(OtherVal other1, OtherVal other2, int y)  { return new MyValue3(0); }\n+        @Override\n+        public MyValue3 test5(OtherVal other1, OtherVal other2, int y)  { return new MyValue3(0); }\n+        @Override\n+        public MyValue3 test6()  { return new MyValue3(0); }\n+\n+        @Override\n+        public MyValue3 test7(int i1, int i2, int i3, int i4, int i5, int i6)  {\n+            return new MyValue3(d1 + d2 + d3 + d4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue3 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue3(d1 + d2 + d3 + d4 + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue3 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue3(d1 + d2 + d3 + d4 + other.d1 + other.d2 + other.d3 + other.d4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue3 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue3(d1 + d2 + d3 + d4 + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static value class MyValue4 implements MyInterface1 {\n+        public int x1;\n+        public int x2;\n+        public int x3;\n+        public int x4;\n+\n+        private MyValue4(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+            this.x3 = i;\n+            this.x4 = i;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x4;\n+        }\n+\n+        @Override\n+        public MyValue4 test1(OtherVal other, int y) { return new MyValue4(0); }\n+        @Override\n+        public MyValue4 test2(OtherVal other1, OtherVal other2, int y)  { return new MyValue4(0); }\n+        @Override\n+        public MyValue4 test3(OtherVal other1, OtherVal other2, int y, boolean deopt)  { return new MyValue4(0); }\n+        @Override\n+        public MyValue4 test4(OtherVal other1, OtherVal other2, int y)  { return new MyValue4(0); }\n+        @Override\n+        public MyValue4 test5(OtherVal other1, OtherVal other2, int y)  { return new MyValue4(0); }\n+        @Override\n+        public MyValue4 test6()  { return new MyValue4(0); }\n+\n+        @Override\n+        public MyValue4 test7(int i1, int i2, int i3, int i4, int i5, int i6)  {\n+            return new MyValue4(x1 + x2 + x3 + x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyValue4 test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyValue4(x1 + x2 + x3 + x4 + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyValue4 test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue4(x1 + x2 + x3 + x4 + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyValue4 test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyValue4(x1 + x2 + x3 + x4 + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    static class MyObject implements MyInterface1 {\n+        private final int x;\n+\n+        private MyObject(int x) {\n+            this.x = x;\n+        }\n+\n+        @Override\n+        public int getValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public MyObject test1(OtherVal other, int y) {\n+            return new MyObject(x + other.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test2(OtherVal other1, OtherVal other2, int y) {\n+            return new MyObject(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test3(OtherVal other1, OtherVal other2, int y, boolean deopt) {\n+            if (!deopt) {\n+              return new MyObject(x + other1.x + other2.x + y);\n+            } else {\n+              \/\/ Uncommon trap\n+              return test1(other1, y);\n+            }\n+        }\n+\n+        @Override\n+        public MyObject test4(OtherVal other1, OtherVal other2, int y) {\n+            return new MyObject(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test5(OtherVal other1, OtherVal other2, int y) {\n+            return new MyObject(x + other1.x + other2.x + y);\n+        }\n+\n+        @Override\n+        public MyObject test6() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MyObject test7(int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyObject(x + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        @Override\n+        public MyObject test8(int i1, int i2, int i3, int i4, int i5, int i6, int i7) {\n+            return new MyObject(x + i1 + i2 + i3 + i4 + i5 + i6 + i7);\n+        }\n+\n+        public MyObject test9(MyValue3 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyObject(x + (int)(other.d1 + other.d2 + other.d3 + other.d4) + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+\n+        public MyObject test10(MyValue4 other, int i1, int i2, int i3, int i4, int i5, int i6) {\n+            return new MyObject(x + other.x1 + other.x2 + other.x3 + other.x4 + i1 + i2 + i3 + i4 + i5 + i6);\n+        }\n+    }\n+\n+    \/\/ Test calling methods with value class arguments through an interface\n+    public static int test1(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test1(other, y).getValue();\n+    }\n+\n+    public static int test2(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Test mixing null-tolerant and null-free value class arguments\n+    public static int test3(MyValue1 vt, OtherVal other, int y) {\n+        return vt.test2(other, other, y).getValue();\n+    }\n+\n+    public static int test4(MyObject obj, OtherVal other, int y) {\n+        return obj.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Optimized interface call with value class receiver\n+    public static int test5(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test1(other, y).getValue();\n+    }\n+\n+    public static int test6(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Optimized interface call with object receiver\n+    public static int test7(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test1(other, y).getValue();\n+    }\n+\n+    public static int test8(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test2(other, other, y).getValue();\n+    }\n+\n+    \/\/ Interface calls with deoptimized callee\n+    public static int test9(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test10(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    \/\/ Optimized interface calls with deoptimized callee\n+    public static int test11(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test12(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test13(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    public static int test14(MyInterface1 intf, OtherVal other, int y, boolean deopt) {\n+        return intf.test3(other, other, y, deopt).getValue();\n+    }\n+\n+    \/\/ Interface calls without warmed up \/ compiled callees\n+    public static int test15(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test4(other, other, y).getValue();\n+    }\n+\n+    public static int test16(MyInterface1 intf, OtherVal other, int y) {\n+        return intf.test5(other, other, y).getValue();\n+    }\n+\n+    \/\/ Interface call with no arguments\n+    public static int test17(MyInterface1 intf) {\n+        return intf.test6().getValue();\n+    }\n+\n+    \/\/ Calls that require stack extension\n+    public static int test18(MyInterface1 intf, int y) {\n+        return intf.test7(y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static int test19(MyInterface1 intf, int y) {\n+        return intf.test8(y, y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static int test20(MyInterface1 intf, MyValue3 v, int y) {\n+        return intf.test9(v, y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static int test21(MyInterface1 intf, MyValue4 v, int y) {\n+        return intf.test10(v, y, y, y, y, y, y).getValue();\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Sometimes, exclude some methods from compilation with C2 to stress test the calling convention\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            ArrayList<Method> methods = new ArrayList<Method>();\n+            Collections.addAll(methods, MyValue1.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyValue2.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyValue3.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyValue4.class.getDeclaredMethods());\n+            Collections.addAll(methods, MyObject.class.getDeclaredMethods());\n+            Collections.addAll(methods, TestC2CCalls.class.getDeclaredMethods());\n+            System.out.println(\"Excluding methods from C2 compilation:\");\n+            for (Method m : methods) {\n+                if (Utils.getRandomInstance().nextBoolean()) {\n+                    System.out.println(m);\n+                    WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+                }\n+            }\n+        }\n+\n+        MyValue1 val1 = new MyValue1(rI);\n+        MyValue2 val2 = new MyValue2(rI+1);\n+        MyValue3 val3 = new MyValue3(rI+2);\n+        MyValue4 val4 = new MyValue4(rI+3);\n+        OtherVal other = new OtherVal(rI+4);\n+        MyObject obj = new MyObject(rI+5);\n+\n+        \/\/ Make sure callee methods are compiled\n+        for (int i = 0; i < 10_000; ++i) {\n+            Asserts.assertEQ(val1.test1(other, rI).getValue(), val1.x + other.x + rI);\n+            Asserts.assertEQ(val2.test1(other, rI).getValue(), val2.x + other.x + rI);\n+            Asserts.assertEQ(obj.test1(other, rI).getValue(), obj.x + other.x + rI);\n+            Asserts.assertEQ(val1.test2(other, other, rI).getValue(), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(val2.test2(other, other, rI).getValue(), val2.x + 2*other.x + rI);\n+            Asserts.assertEQ(obj.test2(other, other, rI).getValue(), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(val1.test3(other, other, rI, false).getValue(), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(val2.test3(other, other, rI, false).getValue(), val2.x + 2*other.x + rI);\n+            Asserts.assertEQ(obj.test3(other, other, rI, false).getValue(), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(val1.test7(rI, rI, rI, rI, rI, rI).getValue(), val1.x + 6*rI);\n+            Asserts.assertEQ(val2.test7(rI, rI, rI, rI, rI, rI).getValue(), val2.x + 6*rI);\n+            Asserts.assertEQ(val3.test7(rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val4.test7(rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(obj.test7(rI, rI, rI, rI, rI, rI).getValue(), obj.x + 6*rI);\n+            Asserts.assertEQ(val1.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), val1.x + 7*rI);\n+            Asserts.assertEQ(val2.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), val2.x + 7*rI);\n+            Asserts.assertEQ(val3.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 7*rI));\n+            Asserts.assertEQ(val4.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 7*rI));\n+            Asserts.assertEQ(obj.test8(rI, rI, rI, rI, rI, rI, rI).getValue(), obj.x + 7*rI);\n+            Asserts.assertEQ(val1.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(val1.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val2.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(val2.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val3.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val4.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(obj.test9(val3, rI, rI, rI, rI, rI, rI).getValue(), (int)(obj.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(val1.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(val1.x + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(val2.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(val2.x + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(val3.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val3.d1 + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(val4.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(4*val4.x1 + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(obj.test10(val4, rI, rI, rI, rI, rI, rI).getValue(), (int)(obj.x + 4*val4.x1 + 6*rI));\n+        }\n+\n+        \/\/ Polute call profile\n+        for (int i = 0; i < 100; ++i) {\n+            Asserts.assertEQ(test15(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test16(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test17(obj), obj.x);\n+        }\n+\n+        \/\/ Trigger compilation of caller methods\n+        for (int i = 0; i < 100_000; ++i) {\n+            val1 = new MyValue1(rI+i);\n+            val2 = new MyValue2(rI+i+1);\n+            val3 = new MyValue3(rI+i+2);\n+            val4 = new MyValue4(rI+i+3);\n+            other = new OtherVal(rI+i+4);\n+            obj = new MyObject(rI+i+5);\n+\n+            Asserts.assertEQ(test1(val1, other, rI), val1.x + other.x + rI);\n+            Asserts.assertEQ(test1(obj, other, rI), obj.x + other.x + rI);\n+            Asserts.assertEQ(test2(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test2(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test3(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test4(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test5(val1, other, rI), val1.x + other.x + rI);\n+            Asserts.assertEQ(test6(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test7(obj, other, rI), obj.x + other.x + rI);\n+            Asserts.assertEQ(test8(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test9(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test9(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test10(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test10(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test11(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test12(val1, other, rI, false), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test13(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test14(obj, other, rI, false), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test15(obj, other, rI), obj.x + 2*other.x + rI);\n+            Asserts.assertEQ(test16(val1, other, rI), val1.x + 2*other.x + rI);\n+            Asserts.assertEQ(test17(val1), val1.x);\n+            Asserts.assertEQ(test18(val1, rI), val1.x + 6*rI);\n+            Asserts.assertEQ(test18(val2, rI), val2.x + 6*rI);\n+            Asserts.assertEQ(test18(val3, rI), (int)(4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test18(val4, rI), 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test18(obj, rI), obj.x + 6*rI);\n+            Asserts.assertEQ(test19(val1, rI), val1.x + 7*rI);\n+            Asserts.assertEQ(test19(val2, rI), val2.x + 7*rI);\n+            Asserts.assertEQ(test19(val3, rI), (int)(4*val3.d1 + 7*rI));\n+            Asserts.assertEQ(test19(val4, rI), 4*val4.x1 + 7*rI);\n+            Asserts.assertEQ(test19(obj, rI), obj.x + 7*rI);\n+            Asserts.assertEQ(test20(val1, val3, rI), (int)(val1.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(val2, val3, rI), (int)(val2.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(val3, val3, rI), (int)(4*val3.d1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(val4, val3, rI), (int)(4*val4.x1 + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test20(obj, val3, rI), (int)(obj.x + 4*val3.d1 + 6*rI));\n+            Asserts.assertEQ(test21(val1, val4, rI), val1.x + 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test21(val2, val4, rI), val2.x + 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test21(val3, val4, rI), (int)(4*val3.d1 + 4*val4.x1 + 6*rI));\n+            Asserts.assertEQ(test21(val4, val4, rI), 4*val4.x1 + 4*val4.x1 + 6*rI);\n+            Asserts.assertEQ(test21(obj, val4, rI), obj.x + 4*val4.x1 + 6*rI);\n+        }\n+\n+        \/\/ Trigger deoptimization\n+        Asserts.assertEQ(val1.test3(other, other, rI, true).getValue(), val1.x + other.x + rI);\n+        Asserts.assertEQ(obj.test3(other, other, rI, true).getValue(), obj.x + other.x + rI);\n+\n+        \/\/ Check results of methods still calling the deoptimized methods\n+        Asserts.assertEQ(test9(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test9(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test10(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test10(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test11(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test11(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test12(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test12(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test13(val1, other, rI, false), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test13(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test14(obj, other, rI, false), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test14(val1, other, rI, false), val1.x + 2*other.x + rI);\n+\n+        \/\/ Check with unexpected arguments\n+        Asserts.assertEQ(test1(val2, other, rI), val2.x + other.x + rI);\n+        Asserts.assertEQ(test2(val2, other, rI), val2.x + 2*other.x + rI);\n+        Asserts.assertEQ(test5(val2, other, rI), val2.x + other.x + rI);\n+        Asserts.assertEQ(test6(val2, other, rI), val2.x + 2*other.x + rI);\n+        Asserts.assertEQ(test7(val1, other, rI), val1.x + other.x + rI);\n+        Asserts.assertEQ(test8(val1, other, rI), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test15(val1, other, rI), val1.x + 2*other.x + rI);\n+        Asserts.assertEQ(test16(obj, other, rI), obj.x + 2*other.x + rI);\n+        Asserts.assertEQ(test17(obj), obj.x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC2CCalls.java","additions":631,"deletions":0,"binary":false,"changes":631,"status":"added"},{"patch":"@@ -0,0 +1,1221 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test support for null markers in flat fields.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ *\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:CompileCommand=dontinline,*::testHelper*\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:+InlineTypeReturnedAsFields -XX:+InlineTypePassFieldsAsArgs\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:-InlineTypeReturnedAsFields -XX:-InlineTypePassFieldsAsArgs\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:+InlineTypeReturnedAsFields -XX:-InlineTypePassFieldsAsArgs\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:-InlineTypeReturnedAsFields -XX:+InlineTypePassFieldsAsArgs\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ *\/\n+\n+public class TestFieldNullMarkers {\n+\n+    \/\/ Value class with two nullable flat fields\n+    @LooselyConsistentValue\n+    static value class MyValue1 {\n+        byte x;\n+        MyValue2 val1;\n+        MyValue2 val2;\n+\n+        public MyValue1(byte x, MyValue2 val1, MyValue2 val2) {\n+            this.x = x;\n+            this.val1 = val1;\n+            this.val2 = val2;\n+        }\n+\n+        public String toString() {\n+            return \"x = \" + x + \", val1 = [\" + val1 + \"], val2 = [\" + val2 + \"]\";\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static abstract value class MyAbstract1 {\n+        byte x;\n+\n+        public MyAbstract1(byte x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    \/\/ Empty value class inheriting single field from abstract super class\n+    @LooselyConsistentValue\n+    static value class MyValue2 extends MyAbstract1 {\n+        public MyValue2(byte x) {\n+            super(x);\n+        }\n+\n+        public String toString() {\n+            return \"x = \" + x;\n+        }\n+    }\n+\n+    \/\/ Value class with a hole in the payload that will be used for the null marker\n+    @LooselyConsistentValue\n+    static value class MyValue3 {\n+        byte x;\n+        \/\/ Hole that will be used by the null marker\n+        int i;\n+\n+        public MyValue3(byte x) {\n+            this.x = x;\n+            this.i = x;\n+        }\n+\n+        public String toString() {\n+            return \"x = \" + x + \", i = \" + i;\n+        }\n+    }\n+\n+    \/\/ Value class with two nullable flat fields that have their null markers *not* at the end of the payload\n+    @LooselyConsistentValue\n+    static value class MyValue4 {\n+        MyValue3 val1;\n+        MyValue3 val2;\n+\n+        public MyValue4(MyValue3 val1, MyValue3 val2) {\n+            this.val1 = val1;\n+            this.val2 = val2;\n+        }\n+\n+        public String toString() {\n+            return \"val1 = [\" + val1 + \"], val2 = [\" + val2 + \"]\";\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue5_3 {\n+        byte x;\n+\n+        public MyValue5_3(byte x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue5_2 {\n+        byte x;\n+        MyValue5_3 val;\n+\n+        public MyValue5_2(byte x, MyValue5_3 val) {\n+            this.x = x;\n+            this.val = val;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue5_1 {\n+        byte x;\n+        MyValue5_2 val;\n+\n+        public MyValue5_1(byte x, MyValue5_2 val) {\n+            this.x = x;\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Value class with deep nesting of nullable flat fields\n+    @LooselyConsistentValue\n+    static value class MyValue5 {\n+        byte x;\n+        MyValue5_1 val;\n+\n+        public MyValue5(byte x, MyValue5_1 val) {\n+            this.x = x;\n+            this.val = val;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValueEmpty {\n+\n+    }\n+\n+    \/\/ Value class with flat field of empty value class\n+    @LooselyConsistentValue\n+    static value class MyValue6 {\n+        MyValueEmpty val;\n+\n+        public MyValue6(MyValueEmpty val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as MyValue6 but one more level of nested flat fields\n+    @LooselyConsistentValue\n+    static value class MyValue7 {\n+        MyValue6 val;\n+\n+        public MyValue7(MyValue6 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Some more field types\n+\n+    @LooselyConsistentValue\n+    static value class MyValue8 {\n+        byte b;\n+\n+        public MyValue8(byte b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue9 {\n+        short s;\n+\n+        public MyValue9(short s) {\n+            this.s = s;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue10 {\n+        int i;\n+\n+        public MyValue10(int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue11 {\n+        float f;\n+\n+        public MyValue11(float f) {\n+            this.f = f;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue12 {\n+        char c;\n+\n+        public MyValue12(char c) {\n+            this.c = c;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue13 {\n+        boolean b;\n+\n+        public MyValue13(boolean b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    \/\/ Test value class with nullable and null-free fields\n+    @LooselyConsistentValue\n+    static value class MyValue14 {\n+        @Strict\n+        @NullRestricted\n+        MyValue8 nullfree;\n+        MyValue8 nullable;\n+\n+        public MyValue14(MyValue8 nullfree, MyValue8 nullable) {\n+            this.nullfree = nullfree;\n+            this.nullable = nullable;\n+        }\n+\n+        public static final MyValue14 DEFAULT = new MyValue14(new MyValue8((byte)0), null);\n+    }\n+\n+    static class MyClass {\n+        int x;\n+\n+        public MyClass(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    \/\/ Value class with oop field\n+    @LooselyConsistentValue\n+    static value class MyValue15 {\n+        MyClass obj;\n+\n+        public MyValue15(MyClass obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    \/\/ Value class with two oop fields\n+    @LooselyConsistentValue\n+    static value class MyValue16 {\n+        MyClass obj1;\n+        MyClass obj2;\n+\n+        public MyValue16(MyClass obj1, MyClass obj2) {\n+            this.obj1 = obj1;\n+            this.obj2 = obj2;\n+        }\n+    }\n+\n+    \/\/ Value class with oop field and primitive fields\n+    @LooselyConsistentValue\n+    static value class MyValue17 {\n+        byte b1;\n+        MyClass obj;\n+        byte b2;\n+\n+        public MyValue17(MyClass obj, byte b1, byte b2) {\n+            this.obj = obj;\n+            this.b1 = b1;\n+            this.b2 = b2;\n+        }\n+    }\n+\n+    MyValue1 field1; \/\/ Not flat\n+    MyValue4 field2; \/\/ Not flat\n+    MyValue5 field3; \/\/ Flat\n+    MyValue6 field4; \/\/ Flat\n+    MyValue7 field5; \/\/ Flat\n+    MyValue8 field6; \/\/ Flat\n+    MyValue9 field7; \/\/ Flat\n+    MyValue10 field8; \/\/ Flat\n+    MyValue11 field9; \/\/ Flat\n+    MyValue12 field10; \/\/ Flat\n+    MyValue13 field11; \/\/ Flat\n+\n+    @Strict\n+    @NullRestricted\n+    volatile MyValue8 field12 = new MyValue8((byte)0);\n+\n+    @Strict\n+    @NullRestricted\n+    MyValue14 field13 = MyValue14.DEFAULT; \/\/ Null-free, flat\n+    volatile MyValue14 field14; \/\/ Nullable, atomic, flat\n+    MyValue14 field15;          \/\/ Nullable, (atomic), flat\n+    @Strict\n+    @NullRestricted\n+    volatile MyValue14 field16 = MyValue14.DEFAULT; \/\/ Null-free, atomic, flat\n+\n+    @Strict\n+    @NullRestricted\n+    volatile MyValue15 field17 = new MyValue15(null);\n+    MyValue15 field18;\n+    @Strict\n+    @NullRestricted\n+    volatile MyValue16 field19 = new MyValue16(null, null);\n+    @Strict\n+    @NullRestricted\n+    volatile MyValue17 field20 = new MyValue17(null, (byte)0, (byte)0);\n+    MyValue17 field21;\n+\n+    \/\/ Combinations of strict fields\n+    static class StrictFieldHolder {\n+        @Strict\n+        MyValue8 strictField1;\n+        @Strict\n+        final MyValue8 strictField2;\n+        @Strict\n+        @NullRestricted\n+        MyValue8 strictField3;\n+        @Strict\n+        @NullRestricted\n+        final MyValue8 strictField4;\n+        @Strict\n+        volatile MyValue8 strictField5;\n+        @Strict\n+        @NullRestricted\n+        volatile MyValue8 strictField6;\n+\n+        @Strict\n+        TwoBytes strictField7;\n+        @Strict\n+        final TwoBytes strictField8;\n+        @Strict\n+        @NullRestricted\n+        TwoBytes strictField9;\n+        @Strict\n+        @NullRestricted\n+        final TwoBytes strictField10;\n+        @Strict\n+        volatile TwoBytes strictField11;\n+        @Strict\n+        @NullRestricted\n+        volatile TwoBytes strictField12;\n+\n+        public StrictFieldHolder(MyValue8 val8, MyValue8 val8NullFree, TwoBytes twoBytes, TwoBytes twoBytesNullFree) {\n+            strictField1 = val8;\n+            strictField2 = val8;\n+            strictField3 = val8NullFree;\n+            strictField4 = val8NullFree;\n+            strictField5 = val8NullFree;\n+            strictField6 = val8NullFree;\n+\n+            strictField7 = twoBytes;\n+            strictField8 = twoBytes;\n+            strictField9 = twoBytesNullFree;\n+            strictField10 = twoBytesNullFree;\n+            strictField11 = twoBytesNullFree;\n+            strictField12 = twoBytesNullFree;\n+        }\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    MyValueEmpty emptyField1 = new MyValueEmpty();\n+    @Strict\n+    @NullRestricted\n+    volatile MyValueEmpty emptyField2 = new MyValueEmpty();\n+    MyValueEmpty emptyField3;\n+    volatile MyValueEmpty emptyField4;\n+\n+    static final MyValue1 VAL1 = new MyValue1((byte)42, new MyValue2((byte)43), null);\n+    static final MyValue4 VAL4 = new MyValue4(new MyValue3((byte)42), null);\n+    static final MyValue5 VAL5 = new MyValue5((byte)42, new MyValue5_1((byte)43, new MyValue5_2((byte)44, new MyValue5_3((byte)45))));\n+    static final MyValue6 VAL6 = new MyValue6(new MyValueEmpty());\n+    static final MyValue7 VAL7 = new MyValue7(new MyValue6(new MyValueEmpty()));\n+\n+    \/\/ Using two bytes such that null-free fields will not be naturally atomic\n+    @LooselyConsistentValue\n+    static value class TwoBytes {\n+        byte b1;\n+        byte b2;\n+\n+        public TwoBytes(byte b1, byte b2) {\n+            this.b1 = b1;\n+            this.b2 = b2;\n+        }\n+\n+        public static final TwoBytes DEFAULT = new TwoBytes((byte)0, (byte)0);\n+    }\n+\n+    static private final MyValue8 CANARY_VALUE = new MyValue8((byte)42);\n+\n+    public static class Cage1 {\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        @Strict\n+        @NullRestricted\n+        volatile TwoBytes field = TwoBytes.DEFAULT;\n+\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    public static class Cage2 {\n+        @Strict\n+        @NullRestricted\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        @Strict\n+        @NullRestricted\n+        volatile TwoBytes field = TwoBytes.DEFAULT;\n+\n+        @Strict\n+        @NullRestricted\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    public static class Cage3 {\n+        @Strict\n+        @NullRestricted\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        volatile TwoBytes field;\n+\n+        @Strict\n+        @NullRestricted\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    public static class Cage4 {\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        volatile TwoBytes field;\n+\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    static final Cage1 canaryCage1 = new Cage1();\n+    static final Cage2 canaryCage2 = new Cage2();\n+    static final Cage3 canaryCage3 = new Cage3();\n+    static final Cage4 canaryCage4 = new Cage4();\n+\n+    \/\/ Check that the canary values are not accidentally overwritten\n+    public void testOutOfBoundsAccess(int i) {\n+        TwoBytes val = new TwoBytes((byte)i, (byte)(i+1));\n+        canaryCage1.field = val;\n+        canaryCage1.verify(val);\n+\n+        canaryCage2.field = val;\n+        canaryCage2.verify(val);\n+\n+        canaryCage3.field = val;\n+        canaryCage3.verify(val);\n+\n+        canaryCage3.field = null;\n+        canaryCage3.verify(null);\n+\n+        canaryCage4.field = val;\n+        canaryCage4.verify(val);\n+\n+        canaryCage4.field = null;\n+        canaryCage4.verify(null);\n+    }\n+\n+    \/\/ Test that the calling convention is keeping track of the null marker\n+    public MyValue1 testHelper1(MyValue1 val) {\n+        return val;\n+    }\n+\n+    public void testSet1(MyValue1 val) {\n+        field1 = testHelper1(val);\n+    }\n+\n+    public MyValue1 testGet1() {\n+        return field1;\n+    }\n+\n+    public void testDeopt1(byte x, MyValue1 neverNull, MyValue1 alwaysNull, boolean deopt) {\n+        MyValue2 val2 = new MyValue2(x);\n+        MyValue1 val1 = new MyValue1(x, val2, val2);\n+        if (deopt) {\n+            Asserts.assertEQ(val1.x, x);\n+            Asserts.assertEQ(val1.val1, val2);\n+            Asserts.assertEQ(val1.val2, val2);\n+            Asserts.assertEQ(neverNull.x, x);\n+            Asserts.assertEQ(neverNull.val1, val2);\n+            Asserts.assertEQ(neverNull.val2, val2);\n+            Asserts.assertEQ(alwaysNull.x, x);\n+            Asserts.assertEQ(alwaysNull.val1, null);\n+            Asserts.assertEQ(alwaysNull.val2, null);\n+        }\n+    }\n+\n+    public void testOSR() {\n+        \/\/ Trigger OSR\n+        for (int i = 0; i < 100_000; ++i) {\n+            field1 = null;\n+            Asserts.assertEQ(field1, null);\n+            MyValue2 val2 = new MyValue2((byte)i);\n+            MyValue1 val = new MyValue1((byte)i, val2, null);\n+            field1 = val;\n+            Asserts.assertEQ(field1.x, (byte)i);\n+            Asserts.assertEQ(field1.val1, val2);\n+            Asserts.assertEQ(field1.val2, null);\n+        }\n+    }\n+\n+    public boolean testACmp(MyValue2 val2) {\n+        return field1.val1 == val2;\n+    }\n+\n+    \/\/ Test that the calling convention is keeping track of the null marker\n+    public MyValue4 testHelper2(MyValue4 val) {\n+        return val;\n+    }\n+\n+    public void testSet2(MyValue4 val) {\n+        field2 = testHelper2(val);\n+    }\n+\n+    public MyValue4 testGet2() {\n+        return field2;\n+    }\n+\n+    public void testDeopt2(byte x, MyValue4 neverNull, MyValue4 alwaysNull, boolean deopt) {\n+        MyValue3 val3 = new MyValue3(x);\n+        MyValue4 val4 = new MyValue4(val3, null);\n+        if (deopt) {\n+            Asserts.assertEQ(val4.val1, val3);\n+            Asserts.assertEQ(val4.val2, null);\n+            Asserts.assertEQ(neverNull.val1, val3);\n+            Asserts.assertEQ(neverNull.val2, val3);\n+            Asserts.assertEQ(alwaysNull.val1, null);\n+            Asserts.assertEQ(alwaysNull.val2, null);\n+        }\n+    }\n+\n+    \/\/ Test that the calling convention is keeping track of the null marker\n+    public MyValue5 testHelper3(MyValue5 val) {\n+        return val;\n+    }\n+\n+    public void testSet3(MyValue5 val) {\n+        field3 = testHelper3(val);\n+    }\n+\n+    public MyValue5 testGet3() {\n+        return field3;\n+    }\n+\n+    public void testDeopt3(byte x, MyValue5 val6, MyValue5 val7, MyValue5 val8, MyValue5 val9, boolean deopt) {\n+        MyValue5 val1 = new MyValue5(x, new MyValue5_1(x, new MyValue5_2(x, new MyValue5_3(x))));\n+        MyValue5 val2 = new MyValue5(x, new MyValue5_1(x, new MyValue5_2(x, null)));\n+        MyValue5 val3 = new MyValue5(x, new MyValue5_1(x, null));\n+        MyValue5 val4 = new MyValue5(x, null);\n+        MyValue5 val5 = null;\n+        if (deopt) {\n+            Asserts.assertEQ(val1.x, x);\n+            Asserts.assertEQ(val1.val.x, x);\n+            Asserts.assertEQ(val1.val.val.x, x);\n+            Asserts.assertEQ(val1.val.val.val.x, x);\n+            Asserts.assertEQ(val2.x, x);\n+            Asserts.assertEQ(val2.val.x, x);\n+            Asserts.assertEQ(val2.val.val.x, x);\n+            Asserts.assertEQ(val2.val.val.val, null);\n+            Asserts.assertEQ(val3.x, x);\n+            Asserts.assertEQ(val3.val.x, x);\n+            Asserts.assertEQ(val3.val.val, null);\n+            Asserts.assertEQ(val4.x, x);\n+            Asserts.assertEQ(val4.val, null);\n+            Asserts.assertEQ(val5, null);\n+\n+            Asserts.assertEQ(val6.x, x);\n+            Asserts.assertEQ(val6.val.x, x);\n+            Asserts.assertEQ(val6.val.val.x, x);\n+            Asserts.assertEQ(val6.val.val.val.x, x);\n+            Asserts.assertEQ(val7.x, x);\n+            Asserts.assertEQ(val7.val.x, x);\n+            Asserts.assertEQ(val7.val.val.x, x);\n+            Asserts.assertEQ(val7.val.val.val, null);\n+            Asserts.assertEQ(val8.x, x);\n+            Asserts.assertEQ(val8.val.x, x);\n+            Asserts.assertEQ(val8.val.val, null);\n+            Asserts.assertEQ(val9.x, x);\n+            Asserts.assertEQ(val9.val, null);\n+        }\n+    }\n+\n+    \/\/ Test that the calling convention is keeping track of the null marker\n+    public MyValue6 testHelper4(MyValue6 val) {\n+        return val;\n+    }\n+\n+    public void testSet4(MyValue6 val) {\n+        field4 = testHelper4(val);\n+    }\n+\n+    public MyValue6 testGet4() {\n+        return field4;\n+    }\n+\n+    public void testDeopt4(MyValue6 val4, MyValue6 val5, MyValue6 val6, boolean deopt) {\n+        MyValue6 val1 = new MyValue6(new MyValueEmpty());\n+        MyValue6 val2 = new MyValue6(null);\n+        MyValue6 val3 = null;\n+        if (deopt) {\n+            Asserts.assertEQ(val1.val, new MyValueEmpty());\n+            Asserts.assertEQ(val2.val, null);\n+            Asserts.assertEQ(val3, null);\n+\n+            Asserts.assertEQ(val4.val, new MyValueEmpty());\n+            Asserts.assertEQ(val5.val, null);\n+            Asserts.assertEQ(val6, null);\n+        }\n+    }\n+\n+    \/\/ Test that the calling convention is keeping track of the null marker\n+    public MyValue7 testHelper5(MyValue7 val) {\n+        return val;\n+    }\n+\n+    public void testSet5(MyValue7 val) {\n+        field5 = testHelper5(val);\n+    }\n+\n+    public MyValue7 testGet5() {\n+        return field5;\n+    }\n+\n+    public void testDeopt5(MyValue7 val5, MyValue7 val6, MyValue7 val7, MyValue7 val8, boolean deopt) {\n+        MyValue7 val1 = new MyValue7(new MyValue6(new MyValueEmpty()));\n+        MyValue7 val2 = new MyValue7(new MyValue6(null));\n+        MyValue7 val3 = new MyValue7(null);\n+        MyValue7 val4 = null;\n+        if (deopt) {\n+            Asserts.assertEQ(val1.val, new MyValue6(new MyValueEmpty()));\n+            Asserts.assertEQ(val2.val, new MyValue6(null));\n+            Asserts.assertEQ(val3.val, null);\n+            Asserts.assertEQ(val4, null);\n+\n+            Asserts.assertEQ(val5.val, new MyValue6(new MyValueEmpty()));\n+            Asserts.assertEQ(val6.val, new MyValue6(null));\n+            Asserts.assertEQ(val7.val, null);\n+            Asserts.assertEQ(val8, null);\n+        }\n+    }\n+\n+    \/\/ Make sure that flat field accesses contain a (implicit) null check\n+    public static void testNPE1() {\n+        TestFieldNullMarkers t = null;\n+        try {\n+            MyValue8 v = t.field6;\n+            throw new RuntimeException(\"No NPE thrown!\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    public static void testNPE2() {\n+        TestFieldNullMarkers t = null;\n+        try {\n+            t.field6 = null;\n+            throw new RuntimeException(\"No NPE thrown!\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    public void checkFields(int i) {\n+        Asserts.assertEQ(field6.b, (byte)i);\n+        Asserts.assertEQ(field7.s, (short)i);\n+        Asserts.assertEQ(field8.i, i);\n+        Asserts.assertEQ(field9.f, (float)i);\n+        Asserts.assertEQ(field10.c, (char)i);\n+        Asserts.assertEQ(field11.b, (i % 2) == 0);\n+    }\n+\n+    \/\/ Test that writing and reading a (signed) byte stays in bounds\n+    public void testBounds(int i) {\n+        MyValue8 val = new MyValue8((byte)i);\n+        field6 = val;\n+        int b = field6.b;\n+        if (b < -128 || b > 127) {\n+            throw new RuntimeException(\"Byte value out of bounds: \" + b);\n+        }\n+    }\n+\n+    static void produceGarbage() {\n+        for (int i = 0; i < 100; ++i) {\n+            Object[] arrays = new Object[1024];\n+            for (int j = 0; j < arrays.length; j++) {\n+                arrays[j] = new int[1024];\n+            }\n+        }\n+        System.gc();\n+    }\n+\n+    \/\/ Test that barriers are emitted when writing flat, atomic fields with oops\n+    public void testWriteOopFields1(MyValue15 val) {\n+        field17 = val;\n+        field18 = val;\n+    }\n+\n+    public void testWriteOopFields2(MyValue16 val) {\n+        field19 = val;\n+    }\n+\n+    public void testWriteOopFields3(MyValue17 val) {\n+        field20 = val;\n+        field21 = val;\n+    }\n+\n+    public static class MyHolderClass9 {\n+        @Strict\n+        @NullRestricted\n+        TwoBytes field1 = TwoBytes.DEFAULT;\n+\n+        TwoBytes field2;\n+\n+        @Strict\n+        @NullRestricted\n+        volatile TwoBytes field3 = TwoBytes.DEFAULT;\n+\n+        volatile TwoBytes field4;\n+    }\n+\n+    static final MyHolderClass9 constantHolder = new MyHolderClass9();\n+\n+    \/\/ Test loading a flat field from a constant container (should not be constant folded because fields are immutable)\n+    public void testLoadingFromConstantHolder(int i) {\n+        TwoBytes val = new TwoBytes((byte)i, (byte)(i + 1));\n+        constantHolder.field1 = val;\n+        Asserts.assertEQ(constantHolder.field1, val);\n+\n+        constantHolder.field2 = val;\n+        Asserts.assertEQ(constantHolder.field2, val);\n+\n+        constantHolder.field2 = null;\n+        Asserts.assertEQ(constantHolder.field2, null);\n+\n+        constantHolder.field3 = val;\n+        Asserts.assertEQ(constantHolder.field3, val);\n+\n+        constantHolder.field4 = val;\n+        Asserts.assertEQ(constantHolder.field4, val);\n+\n+        constantHolder.field4 = null;\n+        Asserts.assertEQ(constantHolder.field4, null);\n+    }\n+\n+    public void testStrictFields(StrictFieldHolder holder, MyValue8 val8, MyValue8 val8NullFree, TwoBytes twoBytes, TwoBytes twoBytesNullFree) {\n+        Asserts.assertEQ(holder.strictField1, val8);\n+        Asserts.assertEQ(holder.strictField2, val8);\n+        Asserts.assertEQ(holder.strictField3, val8NullFree);\n+        Asserts.assertEQ(holder.strictField4, val8NullFree);\n+        Asserts.assertEQ(holder.strictField5, val8NullFree);\n+        Asserts.assertEQ(holder.strictField6, val8NullFree);\n+\n+        Asserts.assertEQ(holder.strictField7, twoBytes);\n+        Asserts.assertEQ(holder.strictField8, twoBytes);\n+        Asserts.assertEQ(holder.strictField9, twoBytesNullFree);\n+        Asserts.assertEQ(holder.strictField10, twoBytesNullFree);\n+        Asserts.assertEQ(holder.strictField11, twoBytesNullFree);\n+        Asserts.assertEQ(holder.strictField12, twoBytesNullFree);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFieldNullMarkers t = new TestFieldNullMarkers();\n+        t.testOSR();\n+\n+        final int LIMIT = 50_000;\n+        for (int i = -50_000; i < LIMIT; ++i) {\n+            t.field1 = null;\n+            Asserts.assertEQ(t.testGet1(), null);\n+\n+            boolean useNull = (i % 2) == 0;\n+            MyValue2 val2 = useNull ? null : new MyValue2((byte)i);\n+            MyValue1 val = new MyValue1((byte)i, val2, val2);\n+            t.field1 = val;\n+            Asserts.assertEQ(t.testGet1().x, val.x);\n+            Asserts.assertEQ(t.testGet1().val1, val2);\n+            Asserts.assertEQ(t.testGet1().val2, val2);\n+\n+            Asserts.assertTrue(t.testACmp(val2));\n+\n+            t.testSet1(null);\n+            Asserts.assertEQ(t.field1, null);\n+\n+            t.testSet1(val);\n+            Asserts.assertEQ(t.field1.x, val.x);\n+            Asserts.assertEQ(t.field1.val1, val2);\n+            Asserts.assertEQ(t.field1.val2, val2);\n+\n+            t.testDeopt1((byte)i, null, null, false);\n+\n+            t.field2 = null;\n+            Asserts.assertEQ(t.testGet2(), null);\n+\n+            MyValue3 val3 = useNull ? null : new MyValue3((byte)i);\n+            MyValue4 val4 = new MyValue4(val3, val3);\n+            t.field2 = val4;\n+            Asserts.assertEQ(t.testGet2().val1, val3);\n+            Asserts.assertEQ(t.testGet2().val2, val3);\n+\n+            t.testSet2(null);\n+            Asserts.assertEQ(t.testGet2(), null);\n+\n+            t.testSet2(val4);\n+            Asserts.assertEQ(t.testGet2().val1, val3);\n+            Asserts.assertEQ(t.testGet2().val2, val3);\n+\n+            t.testDeopt2((byte)i, null, null, false);\n+\n+            t.field3 = null;\n+            Asserts.assertEQ(t.testGet3(), null);\n+\n+            boolean useNull_1 = (i % 4) == 0;\n+            boolean useNull_2 = (i % 4) == 1;\n+            boolean useNull_3 = (i % 4) == 2;\n+            MyValue5_3 val5_3 = useNull_3 ? null : new MyValue5_3((byte)i);\n+            MyValue5_2 val5_2 = useNull_2 ? null : new MyValue5_2((byte)i, val5_3);\n+            MyValue5_1 val5_1 = useNull_1 ? null : new MyValue5_1((byte)i, val5_2);\n+            MyValue5 val5 = new MyValue5((byte)i, val5_1);\n+            t.field3 = val5;\n+            Asserts.assertEQ(t.testGet3().x, val5.x);\n+            if (useNull_1) {\n+                Asserts.assertEQ(t.testGet3().val, null);\n+            } else {\n+                Asserts.assertEQ(t.testGet3().val.x, val5_1.x);\n+                if (useNull_2) {\n+                    Asserts.assertEQ(t.testGet3().val.val, null);\n+                } else {\n+                    Asserts.assertEQ(t.testGet3().val.val.x, val5_2.x);\n+                    if (useNull_3) {\n+                        Asserts.assertEQ(t.testGet3().val.val.val, null);\n+                    } else {\n+                        Asserts.assertEQ(t.testGet3().val.val.val.x, val5_3.x);\n+                    }\n+                }\n+            }\n+\n+            t.testSet3(null);\n+            Asserts.assertEQ(t.field3, null);\n+\n+            t.testSet3(val5);\n+            Asserts.assertEQ(t.testGet3().x, val5.x);\n+            if (useNull_1) {\n+                Asserts.assertEQ(t.testGet3().val, null);\n+            } else {\n+                Asserts.assertEQ(t.testGet3().val.x, val5_1.x);\n+                if (useNull_2) {\n+                    Asserts.assertEQ(t.testGet3().val.val, null);\n+                } else {\n+                    Asserts.assertEQ(t.testGet3().val.val.x, val5_2.x);\n+                    if (useNull_3) {\n+                        Asserts.assertEQ(t.testGet3().val.val.val, null);\n+                    } else {\n+                        Asserts.assertEQ(t.testGet3().val.val.val.x, val5_3.x);\n+                    }\n+                }\n+            }\n+            t.testDeopt3((byte)i, null, null, null, null, false);\n+\n+            t.field4 = null;\n+            Asserts.assertEQ(t.testGet4(), null);\n+\n+            MyValueEmpty empty = useNull ? null : new MyValueEmpty();\n+            MyValue6 val6 = new MyValue6(empty);\n+            t.field4 = val6;\n+            Asserts.assertEQ(t.testGet4().val, empty);\n+\n+            t.testSet4(null);\n+            Asserts.assertEQ(t.testGet4(), null);\n+\n+            t.testSet4(val6);\n+            Asserts.assertEQ(t.testGet4().val, empty);\n+\n+            t.testDeopt4(null, null, null, false);\n+\n+            t.field5 = null;\n+            Asserts.assertEQ(t.testGet5(), null);\n+\n+            empty = ((i % 3) == 0) ? null : new MyValueEmpty();\n+            val6 = ((i % 3) == 1) ? null : new MyValue6(empty);\n+            MyValue7 val7 = new MyValue7(val6);\n+            t.field5 = val7;\n+            Asserts.assertEQ(t.testGet5().val, val6);\n+\n+            t.testSet5(null);\n+            Asserts.assertEQ(t.testGet5(), null);\n+\n+            t.testSet5(val7);\n+            Asserts.assertEQ(t.testGet5().val, val6);\n+\n+            t.testDeopt5(null, null, null, null, false);\n+\n+            \/\/ Check accesses with constant value\n+            t.field1 = VAL1;\n+            Asserts.assertEQ(t.field1.x, VAL1.x);\n+            Asserts.assertEQ(t.field1.val1, VAL1.val1);\n+            Asserts.assertEQ(t.field1.val2, VAL1.val2);\n+\n+            t.field2 = VAL4;\n+            Asserts.assertEQ(t.field2.val1, VAL4.val1);\n+            Asserts.assertEQ(t.field2.val2, VAL4.val2);\n+\n+            t.field3 = VAL5;\n+            Asserts.assertEQ(t.field3.x, VAL5.x);\n+            Asserts.assertEQ(t.field3.val.x, VAL5.val.x);\n+            Asserts.assertEQ(t.field3.val.val.x, VAL5.val.val.x);\n+            Asserts.assertEQ(t.field3.val.val.val.x, VAL5.val.val.val.x);\n+\n+            t.field4 = VAL6;\n+            Asserts.assertEQ(t.field4.val, VAL6.val);\n+\n+            t.field5 = VAL7;\n+            Asserts.assertEQ(t.field5.val, VAL7.val);\n+\n+            \/\/ Some more values classes with different flavors of primitive fields\n+            t.field6 = null;\n+            Asserts.assertEQ(t.field6, null);\n+            t.field6 = new MyValue8((byte)i);\n+            Asserts.assertEQ(t.field6.b, (byte)i);\n+            t.field7 = null;\n+            Asserts.assertEQ(t.field7, null);\n+            t.field7 = new MyValue9((short)i);\n+            Asserts.assertEQ(t.field7.s, (short)i);\n+            t.field8 = null;\n+            Asserts.assertEQ(t.field8, null);\n+            t.field8 = new MyValue10(i);\n+            Asserts.assertEQ(t.field8.i, i);\n+            t.field9 = null;\n+            Asserts.assertEQ(t.field9, null);\n+            t.field9 = new MyValue11((float)i);\n+            Asserts.assertEQ(t.field9.f, (float)i);\n+            t.field10 = null;\n+            Asserts.assertEQ(t.field10, null);\n+            t.field10 = new MyValue12((char)i);\n+            Asserts.assertEQ(t.field10.c, (char)i);\n+            t.field11 = null;\n+            Asserts.assertEQ(t.field11, null);\n+            t.field11 = new MyValue13((i % 2) == 0);\n+            Asserts.assertEQ(t.field11.b, (i % 2) == 0);\n+\n+            \/\/ Write the fields again and check that we don't overwrite other fields\n+            t.checkFields(i);\n+            t.field6 = new MyValue8((byte)i);\n+            t.checkFields(i);\n+            t.field7 = new MyValue9((short)i);\n+            t.checkFields(i);\n+            t.field8 = new MyValue10(i);\n+            t.checkFields(i);\n+            t.field9 = new MyValue11((float)i);\n+            t.checkFields(i);\n+            t.field10 = new MyValue12((char)i);\n+            t.checkFields(i);\n+            t.field11 = new MyValue13((i % 2) == 0);\n+            t.checkFields(i);\n+\n+            testNPE1();\n+            testNPE2();\n+\n+            t.testBounds(i);\n+\n+            \/\/ Null-free, flat, atomic\n+            MyValue8 val8 = new MyValue8((byte)i);\n+            t.field12 = val8;\n+            Asserts.assertEQ(t.field12.b, (byte)i);\n+\n+            try {\n+                t.field12 = null;\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+\n+            \/\/ Null-free, flat with both nullable and null-free fields\n+            t.field13 = new MyValue14(val8, val8);\n+            Asserts.assertEQ(t.field13.nullfree, val8);\n+            Asserts.assertEQ(t.field13.nullable, val8);\n+\n+            t.field13 = new MyValue14(val8, null);\n+            Asserts.assertEQ(t.field13.nullfree, val8);\n+            Asserts.assertEQ(t.field13.nullable, null);\n+\n+            try {\n+                t.field13 = new MyValue14(null, null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+            try {\n+                t.field13 = null;\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+\n+            \/\/ Nullable, atomic, flat with both nullable and null-free fields\n+            t.field14 = null;\n+            Asserts.assertEQ(t.field14, null);\n+\n+            t.field14 = new MyValue14(val8, val8);\n+            Asserts.assertEQ(t.field14.nullfree, val8);\n+            Asserts.assertEQ(t.field14.nullable, val8);\n+\n+            t.field14 = new MyValue14(val8, null);\n+            Asserts.assertEQ(t.field14.nullfree, val8);\n+            Asserts.assertEQ(t.field14.nullable, null);\n+\n+            try {\n+                t.field14 = new MyValue14(null, null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+\n+            \/\/ Nullable, (atomic), flat with both nullable and null-free fields\n+            t.field15 = null;\n+            Asserts.assertEQ(t.field15, null);\n+\n+            t.field15 = new MyValue14(val8, val8);\n+            Asserts.assertEQ(t.field15.nullfree, val8);\n+            Asserts.assertEQ(t.field15.nullable, val8);\n+\n+            t.field15 = new MyValue14(val8, null);\n+            Asserts.assertEQ(t.field15.nullfree, val8);\n+            Asserts.assertEQ(t.field15.nullable, null);\n+\n+            try {\n+                t.field15 = new MyValue14(null, null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+\n+            \/\/ Null-free, atomic, flat with both nullable and null-free fields\n+            t.field16 = new MyValue14(val8, val8);\n+            Asserts.assertEQ(t.field16.nullfree, val8);\n+            Asserts.assertEQ(t.field16.nullable, val8);\n+\n+            t.field16 = new MyValue14(val8, null);\n+            Asserts.assertEQ(t.field16.nullfree, val8);\n+            Asserts.assertEQ(t.field16.nullable, null);\n+\n+            try {\n+                t.field16 = new MyValue14(null, null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+            try {\n+                t.field16 = null;\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+\n+            MyValue15 val15 = new MyValue15(new MyClass(i));\n+            t.testWriteOopFields1(val15);\n+            if (i > (LIMIT - 50)) {\n+                \/\/ After warmup, produce some garbage to trigger GC\n+                produceGarbage();\n+            }\n+            Asserts.assertEQ(t.field17.obj.x, i);\n+            Asserts.assertEQ(t.field18.obj.x, i);\n+\n+            MyValue16 val16 = new MyValue16(new MyClass(i), new MyClass(i));\n+            t.testWriteOopFields2(val16);\n+            if (i > (LIMIT - 50)) {\n+                \/\/ After warmup, produce some garbage to trigger GC\n+                produceGarbage();\n+            }\n+            Asserts.assertEQ(t.field19.obj1.x, i);\n+            Asserts.assertEQ(t.field19.obj2.x, i);\n+\n+            MyValue17 val17 = new MyValue17(new MyClass(i), (byte)i, (byte)i);\n+            t.testWriteOopFields3(val17);\n+            if (i > (LIMIT - 50)) {\n+                \/\/ After warmup, produce some garbage to trigger GC\n+                produceGarbage();\n+            }\n+            Asserts.assertEQ(t.field20.obj.x, i);\n+            Asserts.assertEQ(t.field20.b1, (byte)i);\n+            Asserts.assertEQ(t.field20.b2, (byte)i);\n+            Asserts.assertEQ(t.field21.obj.x, i);\n+            Asserts.assertEQ(t.field21.b1, (byte)i);\n+            Asserts.assertEQ(t.field21.b2, (byte)i);\n+\n+            Asserts.assertEQ(t.emptyField1, new MyValueEmpty());\n+            Asserts.assertEQ(t.emptyField2, new MyValueEmpty());\n+\n+            \/\/ Test empty fields\n+            t.emptyField3 = new MyValueEmpty();\n+            t.emptyField4 = new MyValueEmpty();\n+            Asserts.assertEQ(t.emptyField3, new MyValueEmpty());\n+            Asserts.assertEQ(t.emptyField4, new MyValueEmpty());\n+            t.emptyField3 = null;\n+            t.emptyField4 = null;\n+            Asserts.assertEQ(t.emptyField3, null);\n+            Asserts.assertEQ(t.emptyField4, null);\n+\n+            t.testLoadingFromConstantHolder(i);\n+\n+            \/\/ Verify that no out of bounds accesses happen\n+            t.testOutOfBoundsAccess(i);\n+\n+            \/\/ Test strict fields\n+            TwoBytes twoBytes = new TwoBytes((byte)i, (byte)(i + 1));\n+            t.testStrictFields(new StrictFieldHolder(val8, val8, twoBytes, twoBytes), val8, val8, twoBytes, twoBytes);\n+            t.testStrictFields(new StrictFieldHolder(null, val8, null, twoBytes), null, val8, null, twoBytes);\n+        }\n+\n+        \/\/ Trigger deoptimization to check that re-materialization takes the null marker into account\n+        byte x = (byte)42;\n+        t.testDeopt1(x, new MyValue1(x, new MyValue2(x), new MyValue2(x)), new MyValue1(x, null, null), true);\n+        t.testDeopt2(x, new MyValue4(new MyValue3(x), new MyValue3(x)), new MyValue4(null, null), true);\n+\n+        MyValue5 val1 = new MyValue5(x, new MyValue5_1(x, new MyValue5_2(x, new MyValue5_3(x))));\n+        MyValue5 val2 = new MyValue5(x, new MyValue5_1(x, new MyValue5_2(x, null)));\n+        MyValue5 val3 = new MyValue5(x, new MyValue5_1(x, null));\n+        MyValue5 val4 = new MyValue5(x, null);\n+        t.testDeopt3(x, val1, val2, val3, val4, true);\n+\n+        MyValue6 val5 = new MyValue6(new MyValueEmpty());\n+        MyValue6 val6 = new MyValue6(null);\n+        MyValue6 val7 = null;\n+        t.testDeopt4(val5, val6, val7, true);\n+\n+        MyValue7 val8 = new MyValue7(new MyValue6(new MyValueEmpty()));\n+        MyValue7 val9 = new MyValue7(new MyValue6(null));\n+        MyValue7 val10 = new MyValue7(null);\n+        MyValue7 val11 = null;\n+        t.testDeopt5(val8, val9, val10, val11, false);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":1221,"deletions":0,"binary":false,"changes":1221,"status":"added"},{"patch":"@@ -0,0 +1,4685 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.ALLOC_OF_MYVALUE_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.INLINE_ARRAY_NULL_GUARD;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.LOAD_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.LOAD_UNKNOWN_INLINE;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.STORE_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.STORE_UNKNOWN_INLINE;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.SUBSTITUTABILITY_TEST;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+import static compiler.lib.ir_framework.IRNode.ALLOC;\n+import static compiler.lib.ir_framework.IRNode.CLASS_CHECK_TRAP;\n+import static compiler.lib.ir_framework.IRNode.COUNTED_LOOP;\n+import static compiler.lib.ir_framework.IRNode.COUNTED_LOOP_MAIN;\n+import static compiler.lib.ir_framework.IRNode.FIELD_ACCESS;\n+import static compiler.lib.ir_framework.IRNode.LOAD_OF_CLASS;\n+import static compiler.lib.ir_framework.IRNode.LOOP;\n+import static compiler.lib.ir_framework.IRNode.MEMBAR;\n+import static compiler.lib.ir_framework.IRNode.NULL_CHECK_TRAP;\n+import static compiler.lib.ir_framework.IRNode.PREDICATE_TRAP;\n+import static compiler.lib.ir_framework.IRNode.STORE_OF_CLASS;\n+import static compiler.lib.ir_framework.IRNode.UNSTABLE_IF_TRAP;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test inline types in LWorld.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestLWorld\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestLWorld {\n+\n+    public static void main(String[] args) {\n+        \/\/ Make sure Test140Value is loaded but not linked\n+        Class<?> class1 = Test140Value.class;\n+        \/\/ Make sure Test141Value is linked but not initialized\n+        Class<?> class2 = Test141Value.class;\n+        class2.getDeclaredFields();\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:+UseArrayFlattening\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Helper methods\n+\n+    @Strict\n+    @NullRestricted\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+    @Strict\n+    @NullRestricted\n+    private static final MyValue2 testValue2 = MyValue2.createWithFieldsInline(rI, rD);\n+\n+    protected long hash() {\n+        return testValue1.hash();\n+    }\n+\n+    \/\/ Test passing an inline type as an Object\n+    @DontInline\n+    public Object test1_dontinline1(Object o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test1_dontinline2(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public Object test1_inline1(Object o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test1_inline2(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test1() {\n+        MyValue1 vt = testValue1;\n+        vt = (MyValue1)test1_dontinline1(vt);\n+        vt =           test1_dontinline2(vt);\n+        vt = (MyValue1)test1_inline1(vt);\n+        vt =           test1_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        Asserts.assertEQ(test1().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from Object and inline type fields\n+    Object objectField1 = null;\n+    Object objectField2 = null;\n+    Object objectField3 = null;\n+    Object objectField4 = null;\n+    Object objectField5 = null;\n+    Object objectField6 = null;\n+\n+    @Strict\n+    @NullRestricted\n+    MyValue1 valueField1 = testValue1;\n+    @Strict\n+    @NullRestricted\n+    MyValue1 valueField2 = testValue1;\n+    MyValue1 valueField3 = testValue1;\n+    @Strict\n+    @NullRestricted\n+    MyValue1 valueField4 = MyValue1.DEFAULT;\n+    MyValue1 valueField5;\n+\n+    static MyValue1 staticValueField1 = testValue1;\n+    @Strict\n+    @NullRestricted\n+    static MyValue1 staticValueField2 = testValue1;\n+    @Strict\n+    @NullRestricted\n+    static MyValue1 staticValueField3 = MyValue1.DEFAULT;\n+    static MyValue1 staticValueField4;\n+\n+    @DontInline\n+    public Object readValueField5() {\n+        return (Object)valueField5;\n+    }\n+\n+    @DontInline\n+    public Object readStaticValueField4() {\n+        return (Object)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test2(MyValue1 vt1, Object vt2) {\n+        objectField1 = vt1;\n+        objectField2 = (MyValue1)vt2;\n+        objectField3 = testValue1;\n+        objectField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        objectField5 = valueField1;\n+        objectField6 = valueField3;\n+        valueField1 = (MyValue1)objectField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)objectField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5() != null || readStaticValueField4() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)objectField1).hash() + ((MyValue1)objectField2).hash() +\n+               ((MyValue1)objectField3).hash() + ((MyValue1)objectField4).hash() +\n+               ((MyValue1)objectField5).hash() + ((MyValue1)objectField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test2(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    \/\/ Test merging inline types and objects\n+    @Test\n+    public Object test3(int state) {\n+        Object res = null;\n+        if (state == 0) {\n+            res = new NonValueClass(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        } else if (state == 6) {\n+            res = MyValue2.createWithFieldsInline(rI, rD);\n+        } else if (state == 7) {\n+            res = testValue2;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        objectField1 = valueField1;\n+        Object result = null;\n+        result = test3(0);\n+        Asserts.assertEQ(((NonValueClass)result).x, rI);\n+        result = test3(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test3(5);\n+        Asserts.assertEQ(result, null);\n+        result = test3(6);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+        result = test3(7);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+    }\n+\n+    \/\/ Test merging inline types and objects in loops\n+    @Test\n+    public Object test4(int iters) {\n+        Object res = new NonValueClass(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof NonValueClass) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        NonValueClass result1 = (NonValueClass)test4(0);\n+        Asserts.assertEQ(result1.x, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test4(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in object variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS, LOOP})\n+    public long test5(MyValue1 arg, boolean deopt, Method m) {\n+        Object vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        Object vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        Object vt3 = arg;\n+        Object vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier(RunInfo info) {\n+        long result = test5(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with objects\n+    @Test\n+    public boolean test6(Object arg) {\n+        Object vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (Object)valueField1 || vt == objectField1 || vt == null ||\n+            arg == vt || (Object)valueField1 == vt || objectField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        boolean result = test6(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ merge of inline type and non-inline type\n+    @Test\n+    public Object test7(boolean flag) {\n+        Object res = null;\n+        if (flag) {\n+            res = valueField1;\n+        } else {\n+            res = objectField1;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        Asserts.assertEQ(test7(true), valueField1);\n+        Asserts.assertEQ(test7(false), objectField1);\n+    }\n+\n+    @Test\n+    public Object test8(boolean flag) {\n+        Object res = null;\n+        if (flag) {\n+            res = objectField1;\n+        } else {\n+            res = valueField1;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        Asserts.assertEQ(test8(true), objectField1);\n+        Asserts.assertEQ(test8(false), valueField1);\n+    }\n+\n+    \/\/ merge of inline types in a loop, stored in an object local\n+    @Test\n+    public Object test9() {\n+        Object o = valueField1;\n+        for (int i = 1; i < 100; i *= 2) {\n+            MyValue1 v = (MyValue1)o;\n+            o = MyValue1.setX(v, v.x + 1);\n+        }\n+        return o;\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        Asserts.assertEQ(test9(), MyValue1.setX(valueField1, valueField1.x + 7));\n+    }\n+\n+    \/\/ merge of inline types in an object local\n+    @ForceInline\n+    public Object test10_helper() {\n+        return valueField1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test10(boolean flag) {\n+        Object o = null;\n+        if (flag) {\n+            o = valueField1;\n+        } else {\n+            o = test10_helper();\n+        }\n+        valueField1 = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        test10(true);\n+        test10(false);\n+    }\n+\n+    \/\/ Interface tests\n+\n+    @DontInline\n+    public MyInterface test11_dontinline1(MyInterface o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test11_dontinline2(MyInterface o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public MyInterface test11_inline1(MyInterface o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test11_inline2(MyInterface o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    public MyValue1 test11() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        vt = (MyValue1)test11_dontinline1(vt);\n+        vt =           test11_dontinline2(vt);\n+        vt = (MyValue1)test11_inline1(vt);\n+        vt =           test11_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        Asserts.assertEQ(test11().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from interface and inline type fields\n+    MyInterface interfaceField1 = null;\n+    MyInterface interfaceField2 = null;\n+    MyInterface interfaceField3 = null;\n+    MyInterface interfaceField4 = null;\n+    MyInterface interfaceField5 = null;\n+    MyInterface interfaceField6 = null;\n+\n+    @DontInline\n+    public MyInterface readValueField5AsInterface() {\n+        return (MyInterface)valueField5;\n+    }\n+\n+    @DontInline\n+    public MyInterface readStaticValueField4AsInterface() {\n+        return (MyInterface)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test12(MyValue1 vt1, MyInterface vt2) {\n+        interfaceField1 = vt1;\n+        interfaceField2 = (MyValue1)vt2;\n+        interfaceField3 = MyValue1.createWithFieldsInline(rI, rL);\n+        interfaceField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        interfaceField5 = valueField1;\n+        interfaceField6 = valueField3;\n+        valueField1 = (MyValue1)interfaceField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)interfaceField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5AsInterface() != null || readStaticValueField4AsInterface() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)interfaceField1).hash() + ((MyValue1)interfaceField2).hash() +\n+               ((MyValue1)interfaceField3).hash() + ((MyValue1)interfaceField4).hash() +\n+               ((MyValue1)interfaceField5).hash() + ((MyValue1)interfaceField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test12(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    class MyObject1 implements MyInterface {\n+        public int x;\n+\n+        public MyObject1(int x) {\n+            this.x = x;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Test merging inline types and interfaces\n+    @Test\n+    public MyInterface test13(int state) {\n+        MyInterface res = null;\n+        if (state == 0) {\n+            res = new MyObject1(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        objectField1 = valueField1;\n+        MyInterface result = null;\n+        result = test13(0);\n+        Asserts.assertEQ(((MyObject1)result).x, rI);\n+        result = test13(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test13(5);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ Test merging inline types and interfaces in loops\n+    @Test\n+    public MyInterface test14(int iters) {\n+        MyInterface res = new MyObject1(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof MyObject1) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        MyObject1 result1 = (MyObject1)test14(0);\n+        Asserts.assertEQ(result1.x, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test14(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in interface variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS, LOOP})\n+    public long test15(MyValue1 arg, boolean deopt, Method m) {\n+        MyInterface vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyInterface vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyInterface vt3 = arg;\n+        MyInterface vt4 = valueField1;\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier(RunInfo info) {\n+        long result = test15(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with interfaces\n+    @Test\n+    public boolean test16(Object arg) {\n+        MyInterface vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (MyInterface)valueField1 || vt == interfaceField1 || vt == null ||\n+            arg == vt || (MyInterface)valueField1 == vt || interfaceField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        boolean result = test16(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ Test subtype check when casting to inline type\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public MyValue1 test17(MyValue1 vt, Object obj) {\n+        try {\n+            vt = (MyValue1)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test17(vt, new NonValueClass(rI));\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public MyValue1 test18(MyValue1 vt) {\n+        Object obj = vt;\n+        vt = (MyValue1)obj;\n+        return vt;\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test18(vt);\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test19(MyValue1 vt) {\n+        if (vt == null) {\n+            return;\n+        }\n+        Object obj = vt;\n+        try {\n+            MyValue2 vt2 = (MyValue2)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        test19(valueField1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test20(MyValue1 vt) {\n+        if (vt == null) {\n+            return;\n+        }\n+        Object obj = vt;\n+        try {\n+            NonValueClass i = (NonValueClass)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        test20(valueField1);\n+    }\n+\n+    \/\/ Array tests\n+\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 3, MyValue1.DEFAULT);\n+    static {\n+        for (int i = 0; i < 3; ++i) {\n+            testValue1Array[i] = testValue1;\n+        }\n+    }\n+\n+    private static final MyValue1[][] testValue1Array2 = new MyValue1[][] {testValue1Array,\n+                                                                           testValue1Array,\n+                                                                           testValue1Array};\n+\n+    private static final MyValue2[] testValue2Array = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 3, MyValue2.DEFAULT);\n+    static {\n+        for (int i = 0; i < 3; ++i) {\n+            testValue2Array[i] = testValue2;\n+        }\n+    }\n+\n+    private static final NonValueClass[] testNonValueArray = new NonValueClass[42];\n+\n+    \/\/ Test load from (flattened) inline type array disguised as object array\n+    @Test\n+    public Object test21(Object[] oa, int index) {\n+        return oa[index];\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        MyValue1 result = (MyValue1)test21(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test load from (flattened) inline type array disguised as interface array\n+    @Test\n+    public Object test22Interface(MyInterface[] ia, int index) {\n+        return ia[index];\n+    }\n+\n+    @Run(test = \"test22Interface\")\n+    public void test22Interface_verifier() {\n+        MyValue1 result = (MyValue1)test22Interface(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test load from (flattened) inline type array disguised as abstract array\n+    @Test\n+    public Object test22Abstract(MyAbstract[] ia, int index) {\n+        return ia[index];\n+    }\n+\n+    @Run(test = \"test22Abstract\")\n+    public void test22Abstract_verifier() {\n+        MyValue1 result = (MyValue1)test22Abstract(testValue1Array, Math.abs(rI) % 3);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test23_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test23(Object[] oa, MyValue1 vt, int index) {\n+        test23_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test23(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test23(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test24_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test24(Object[] oa, MyValue1 vt, int index) {\n+        test24_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test24(testNonValueArray, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test25_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test25(Object[] oa, MyValue1 vt, int index) {\n+        test25_inline(oa, vt, index);\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test25(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as interface array\n+    @ForceInline\n+    public void test26Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test26Interface(MyInterface[] ia, MyValue1 vt, int index) {\n+      test26Interface_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test26Interface\")\n+    public void test26Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test26Interface(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test26Interface(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test27Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test27Interface(MyInterface[] ia, MyValue1 vt, int index) {\n+        test27Interface_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test27Interface\")\n+    public void test27Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test27Interface(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as abstract array\n+    @ForceInline\n+    public void test26Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test26Abstract(MyAbstract[] ia, MyValue1 vt, int index) {\n+      test26Abstract_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test26Abstract\")\n+    public void test26Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test26Abstract(testValue1Array, vt, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt.hash());\n+        testValue1Array[index] = testValue1;\n+        try {\n+            test26Abstract(testValue2Array, vt, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test27Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test27Abstract(MyAbstract[] ia, MyValue1 vt, int index) {\n+        test27Abstract_inline(ia, vt, index);\n+    }\n+\n+    @Run(test = \"test27Abstract\")\n+    public void test27Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test27Abstract(null, testValue1, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test object store to (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test28_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test28(Object[] oa, Object o, int index) {\n+        test28_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test28(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test28(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test29_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test29(Object[] oa, Object o, int index) {\n+        test29_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test29(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue2Array[index].hash(), testValue2.hash());\n+    }\n+\n+    @ForceInline\n+    public void test30_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test30(Object[] oa, Object o, int index) {\n+        test30_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test30(testNonValueArray, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as interface array\n+    @ForceInline\n+    public void test31Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test31Interface(MyInterface[] ia, MyInterface i, int index) {\n+        test31Interface_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test31Interface\")\n+    public void test31Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test31Interface(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test31Interface(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test32Interface_inline(MyInterface[] ia, MyInterface i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test32Interface(MyInterface[] ia, MyInterface i, int index) {\n+        test32Interface_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test32Interface\")\n+    public void test32Interface_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test32Interface(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test inline store to (flattened) inline type array disguised as abstract array\n+    @ForceInline\n+    public void test31Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test31Abstract(MyAbstract[] ia, MyAbstract i, int index) {\n+        test31Abstract_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test31Abstract\")\n+    public void test31Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test31Abstract(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test31Abstract(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    @ForceInline\n+    public void test32Abstract_inline(MyAbstract[] ia, MyAbstract i, int index) {\n+        ia[index] = i;\n+    }\n+\n+    @Test\n+    public void test32Abstract(MyAbstract[] ia, MyAbstract i, int index) {\n+        test32Abstract_inline(ia, i, index);\n+    }\n+\n+    @Run(test = \"test32Abstract\")\n+    public void test32Abstract_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test32Abstract(testValue2Array, testValue1, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test writing null to a (flattened) inline type array disguised as object array\n+    @ForceInline\n+    public void test33_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test33(Object[] oa, Object o, int index) {\n+        test33_inline(oa, o, index);\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test33(testValue1Array, null, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing constant null to a (flattened) inline type array disguised as object array\n+\n+    @ForceInline\n+    public void test34_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test34(Object[] oa, int index) {\n+        test34_inline(oa, null, index);\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test34(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing constant null to a (flattened) inline type array\n+\n+    private static final MethodHandle setArrayElementNull = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+        \"setArrayElementNull\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class),\n+        CODE -> {\n+            CODE.\n+            aload(1).\n+            iload(2).\n+            aconst_null().\n+            aastore().\n+            return_();\n+        });\n+\n+    @Test\n+    public void test35(MyValue1[] va, int index) throws Throwable {\n+        setArrayElementNull.invoke(this, va, index);\n+    }\n+\n+    @Run(test = \"test35\")\n+    @Warmup(10000)\n+    public void test35_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test35(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Test writing an inline type to a null inline type array\n+    @Test\n+    public void test36(MyValue1[] va, MyValue1 vt, int index) {\n+        va[index] = vt;\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test36(null, testValue1Array[index], index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test incremental inlining\n+    @ForceInline\n+    public void test37_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test37(MyValue1[] va, Object o, int index) {\n+        test37_inline(va, o, index);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        test37(testValue1Array, vt1, index);\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        try {\n+            test37(testValue1Array, testValue2, index);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), vt1.hash());\n+        testValue1Array[index] = testValue1;\n+    }\n+\n+    \/\/ Test merging of inline type arrays\n+\n+    @ForceInline\n+    public Object[] test38_inline() {\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public Object[] test38(Object[] oa, Object o, int i1, int i2, int num) {\n+        Object[] result = null;\n+        switch (num) {\n+        case 0:\n+            result = test38_inline();\n+            break;\n+        case 1:\n+            result = oa;\n+            break;\n+        case 2:\n+            result = testValue1Array;\n+            break;\n+        case 3:\n+            result = testValue2Array;\n+            break;\n+        case 4:\n+            result = testNonValueArray;\n+            break;\n+        case 5:\n+            result = null;\n+            break;\n+        case 6:\n+            result = testValue1Array2;\n+            break;\n+        }\n+        result[i1] = result[i2];\n+        result[i2] = o;\n+        return result;\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        Object[] result = test38(null, testValue1, index, index, 0);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(testValue1Array, testValue1, index, index, 1);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(null, testValue1, index, index, 2);\n+        Asserts.assertEQ(((MyValue1)result[index]).hash(), testValue1.hash());\n+        result = test38(null, testValue2, index, index, 3);\n+        Asserts.assertEQ(((MyValue2)result[index]).hash(), testValue2.hash());\n+        try {\n+            result = test38(null, null, index, index, 3);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test38(null, null, index, index, 4);\n+        try {\n+            result = test38(null, testValue1, index, index, 4);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            result = test38(null, testValue1, index, index, 5);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test38(null, testValue1Array, index, index, 6);\n+        Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test39_inline() {\n+        return (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+    }\n+\n+    \/\/ Same as above but merging into Object instead of Object[]\n+    @Test\n+    public Object test39(Object oa, Object o, int i1, int i2, int num) {\n+        Object result = null;\n+        switch (num) {\n+        case 0:\n+            result = test39_inline();\n+            break;\n+        case 1:\n+            result = oa;\n+            break;\n+        case 2:\n+            result = testValue1Array;\n+            break;\n+        case 3:\n+            result = testValue2Array;\n+            break;\n+        case 4:\n+            result = testNonValueArray;\n+            break;\n+        case 5:\n+            result = null;\n+            break;\n+        case 6:\n+            result = testValue1;\n+            break;\n+        case 7:\n+            result = testValue2;\n+            break;\n+        case 8:\n+            result = MyValue1.createWithFieldsInline(rI, rL);\n+            break;\n+        case 9:\n+            result = new NonValueClass(42);\n+            break;\n+        case 10:\n+            result = testValue1Array2;\n+            break;\n+        }\n+        if (result instanceof Object[]) {\n+            ((Object[])result)[i1] = ((Object[])result)[i2];\n+            ((Object[])result)[i2] = o;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        Object result = test39(null, testValue1, index, index, 0);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(testValue1Array, testValue1, index, index, 1);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 2);\n+        Asserts.assertEQ(((MyValue1[])result)[index].hash(), testValue1.hash());\n+        result = test39(null, testValue2, index, index, 3);\n+        Asserts.assertEQ(((MyValue2[])result)[index].hash(), testValue2.hash());\n+        try {\n+            result = test39(null, null, index, index, 3);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        result = test39(null, null, index, index, 4);\n+        try {\n+            result = test39(null, testValue1, index, index, 4);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        result = test39(null, testValue1, index, index, 5);\n+        Asserts.assertEQ(result, null);\n+        result = test39(null, testValue1, index, index, 6);\n+        Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 7);\n+        Asserts.assertEQ(((MyValue2)result).hash(), testValue2.hash());\n+        result = test39(null, testValue1, index, index, 8);\n+        Asserts.assertEQ(((MyValue1)result).hash(), testValue1.hash());\n+        result = test39(null, testValue1, index, index, 9);\n+        Asserts.assertEQ(((NonValueClass)result).x, 42);\n+        result = test39(null, testValue1Array, index, index, 10);\n+        Asserts.assertEQ(((MyValue1[][])result)[index][index].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Test instanceof with inline types and arrays\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC})\n+    public long test40(Object o, int index) {\n+        if (o instanceof MyValue1) {\n+          return ((MyValue1)o).hashInterpreted();\n+        } else if (o instanceof MyValue1[]) {\n+          return ((MyValue1[])o)[index].hashInterpreted();\n+        } else if (o instanceof MyValue2) {\n+          return ((MyValue2)o).hash();\n+        } else if (o instanceof MyValue2[]) {\n+          return ((MyValue2[])o)[index].hash();\n+        } else if (o instanceof MyValue1[][]) {\n+          return ((MyValue1[][])o)[index][index].hash();\n+        } else if (o instanceof Long) {\n+          return (long)o;\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        long result = test40(testValue1, 0);\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n+        result = test40(testValue1Array, index);\n+        Asserts.assertEQ(result, testValue1.hashInterpreted());\n+        result = test40(testValue2, index);\n+        Asserts.assertEQ(result, testValue2.hash());\n+        result = test40(testValue2Array, index);\n+        Asserts.assertEQ(result, testValue2.hash());\n+        result = test40(testValue1Array2, index);\n+        Asserts.assertEQ(result, testValue1.hash());\n+        result = test40(Long.valueOf(42), index);\n+        Asserts.assertEQ(result, 42L);\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    @DontInline\n+    public void test41_dontinline(Object o) {\n+        Asserts.assertEQ(o, rI);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test41() {\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        vals[0] = testValue1;\n+        test41_dontinline(vals[0].oa[0]);\n+        test41_dontinline(vals[0].oa[0]);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier() {\n+        test41();\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    private static final MyValue1 test42VT1 = MyValue1.createWithFieldsInline(rI, rL);\n+    private static final MyValue1 test42VT2 = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test42() {\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        vals[0] = test42VT1;\n+        vals[1] = test42VT2;\n+        Asserts.assertEQ(vals[0].hash(), test42VT1.hash());\n+        Asserts.assertEQ(vals[1].hash(), test42VT2.hash());\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        if (!info.isWarmUp()) test42(); \/\/ We need -Xcomp behavior\n+    }\n+\n+    \/\/ Test for bug in Escape Analysis\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public long test43(boolean deopt, Method m) {\n+        MyValue1[] vals = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        vals[0] = test42VT1;\n+        vals[1] = test42VT2;\n+\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+            Asserts.assertEQ(vals[0].hash(), test42VT1.hash());\n+            Asserts.assertEQ(vals[1].hash(), test42VT2.hash());\n+        }\n+\n+        return vals[0].hash();\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        test43(!info.isWarmUp(), info.getTest());\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    private static final MethodHandle setArrayElementIncompatible = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+        \"setArrayElementIncompatible\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),\n+        CODE -> {\n+            CODE.\n+            aload(1).\n+            iload(2).\n+            aload(3).\n+            aastore().\n+            return_();\n+        });\n+\n+    @Test\n+    public void test44(MyValue1[] va, int index, MyValue2 v) throws Throwable {\n+        setArrayElementIncompatible.invoke(this, va, index, v);\n+    }\n+\n+    @Run(test = \"test44\")\n+    @Warmup(10000)\n+    public void test44_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test44(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    @ForceInline\n+    public void test45_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    public void test45(MyValue1[] va, int index, MyValue2 v) throws Throwable {\n+        test45_inline(va, v, index);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier() throws Throwable {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test45(testValue1Array, index, testValue2);\n+            throw new RuntimeException(\"No ArrayStoreException thrown\");\n+        } catch (ArrayStoreException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), hash());\n+    }\n+\n+    \/\/ instanceof tests with inline types\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test46(MyValue1 vt) {\n+        Object obj = vt;\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test46(vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test47(MyValue1 vt) {\n+        Object obj = vt;\n+        return obj instanceof MyValue2;\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test47(vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test48(Object obj) {\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test48(vt);\n+        Asserts.assertTrue(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test49(Object obj) {\n+        return obj instanceof MyValue2;\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        MyValue1 vt = testValue1;\n+        boolean result = test49(vt);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public boolean test50(Object obj) {\n+        return obj instanceof MyValue1;\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        Asserts.assertFalse(test49(new NonValueClass(42)));\n+    }\n+\n+    \/\/ Inline type with some non-flattened fields\n+    @LooselyConsistentValue\n+    static value class Test51Value {\n+        Object objectField1;\n+        Object objectField2;\n+        Object objectField3;\n+        Object objectField4;\n+        Object objectField5;\n+        Object objectField6;\n+\n+        @Strict\n+        @NullRestricted\n+        MyValue1 valueField1;\n+        @Strict\n+        @NullRestricted\n+        MyValue1 valueField2;\n+        MyValue1 valueField3;\n+        @Strict\n+        @NullRestricted\n+        MyValue1 valueField4;\n+        MyValue1 valueField5;\n+\n+        public Test51Value() {\n+            objectField1 = null;\n+            objectField2 = null;\n+            objectField3 = null;\n+            objectField4 = null;\n+            objectField5 = null;\n+            objectField6 = null;\n+            valueField1 = testValue1;\n+            valueField2 = testValue1;\n+            valueField3 = testValue1;\n+            valueField4 = MyValue1.createDefaultDontInline();\n+            valueField5 = MyValue1.createDefaultDontInline();\n+        }\n+\n+        public Test51Value(Object o1, Object o2, Object o3, Object o4, Object o5, Object o6,\n+                           MyValue1 vt1, MyValue1 vt2, MyValue1 vt3, MyValue1 vt4, MyValue1 vt5) {\n+            objectField1 = o1;\n+            objectField2 = o2;\n+            objectField3 = o3;\n+            objectField4 = o4;\n+            objectField5 = o5;\n+            objectField6 = o6;\n+            valueField1 = vt1;\n+            valueField2 = vt2;\n+            valueField3 = vt3;\n+            valueField4 = vt4;\n+            valueField5 = vt5;\n+        }\n+\n+        @ForceInline\n+        public long test(Test51Value holder, MyValue1 vt1, Object vt2) {\n+            holder = new Test51Value(vt1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, (MyValue1)vt2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, testValue1, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, MyValue1.createWithFieldsDontInline(rI, rL), holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.valueField1, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.valueField3,\n+                                     holder.valueField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     (MyValue1)holder.objectField1, holder.valueField2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, (MyValue1)vt2, holder.valueField3, holder.valueField4, holder.valueField5);\n+            holder = new Test51Value(holder.objectField1, holder.objectField2, holder.objectField3, holder.objectField4, holder.objectField5, holder.objectField6,\n+                                     holder.valueField1, holder.valueField2, (MyValue1)vt2, holder.valueField4, holder.valueField5);\n+\n+            return ((MyValue1)holder.objectField1).hash() +\n+                   ((MyValue1)holder.objectField2).hash() +\n+                   ((MyValue1)holder.objectField3).hash() +\n+                   ((MyValue1)holder.objectField4).hash() +\n+                   ((MyValue1)holder.objectField5).hash() +\n+                   ((MyValue1)holder.objectField6).hash() +\n+                   holder.valueField1.hash() +\n+                   holder.valueField2.hash() +\n+                   holder.valueField3.hash() +\n+                   holder.valueField4.hashPrimitive();\n+        }\n+    }\n+\n+    \/\/ Pass arguments via fields to avoid exzessive spilling leading to compilation bailouts\n+    @Strict\n+    @NullRestricted\n+    static Test51Value test51_arg1 = new Test51Value();\n+    @Strict\n+    @NullRestricted\n+    static MyValue1 test51_arg2 = MyValue1.DEFAULT;\n+    static Object test51_arg3;\n+\n+    \/\/ Same as test2 but with field holder being an inline type\n+    @Test\n+    public long test51() {\n+        return test51_arg1.test(test51_arg1, test51_arg2, test51_arg3);\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        Test51Value holder = new Test51Value();\n+        Asserts.assertEQ(testValue1.hash(), vt.hash());\n+        Asserts.assertEQ(holder.valueField1.hash(), vt.hash());\n+        test51_arg1 = holder;\n+        test51_arg2 = vt;\n+        test51_arg3 = vt;\n+        long result = test51();\n+        Asserts.assertEQ(result, 9*vt.hash() + def.hashPrimitive());\n+    }\n+\n+    \/\/ Access non-flattened, uninitialized inline type field with inline type holder\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test52(Test51Value holder) {\n+        if ((Object)holder.valueField5 != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        Test51Value vt = new Test51Value(null, null, null, null, null, null,\n+                                         MyValue1.createDefaultInline(), MyValue1.createDefaultInline(), null, MyValue1.createDefaultInline(), null);\n+        test52(vt);\n+    }\n+\n+    \/\/ Merging inline types of different types\n+    @Test\n+    public Object test53(Object o, boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        return b ? vt : o;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        test53(new Object(), false);\n+        MyValue1 result = (MyValue1)test53(new Object(), true);\n+        Asserts.assertEQ(result.hash(), hash());\n+    }\n+\n+    @Test\n+    public Object test54(boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        return b ? vt : testValue2;\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        MyValue1 result1 = (MyValue1)test54(true);\n+        Asserts.assertEQ(result1.hash(), hash());\n+        MyValue2 result2 = (MyValue2)test54(false);\n+        Asserts.assertEQ(result2.hash(), testValue2.hash());\n+    }\n+\n+    @Test\n+    public Object test55(boolean b) {\n+        MyValue1 vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue2 vt2 = MyValue2.createWithFieldsInline(rI, rD);\n+        return b ? vt1 : vt2;\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        MyValue1 result1 = (MyValue1)test55(true);\n+        Asserts.assertEQ(result1.hash(), hash());\n+        MyValue2 result2 = (MyValue2)test55(false);\n+        Asserts.assertEQ(result2.hash(), testValue2.hash());\n+    }\n+\n+    \/\/ Test synchronization on inline types\n+    @Test\n+    public void test56(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test56 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        try {\n+            test56(testValue1);\n+            throw new RuntimeException(\"test56 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test57_inline(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test57 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test57(MyValue1 vt) {\n+        test57_inline(vt);\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        try {\n+            test57(testValue1);\n+            throw new RuntimeException(\"test57 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test58_inline(Object vt) {\n+        synchronized (vt) {\n+            throw new RuntimeException(\"test58 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test58() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test58_inline(vt);\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier() {\n+        try {\n+            test58();\n+            throw new RuntimeException(\"test58 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public void test59(Object o, boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object sync = b ? vt : o;\n+        synchronized (sync) {\n+            if (b) {\n+                throw new RuntimeException(\"test59 failed: synchronization on inline type should not succeed\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() {\n+        test59(new Object(), false);\n+        try {\n+            test59(new Object(), true);\n+            throw new RuntimeException(\"test59 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public void test60(boolean b) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        Object sync = b ? vt : testValue2;\n+        synchronized (sync) {\n+            throw new RuntimeException(\"test60 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        try {\n+            test60(false);\n+            throw new RuntimeException(\"test60 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test60(true);\n+            throw new RuntimeException(\"test60 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test catching the IdentityException in compiled code\n+    @Test\n+    public void test61(Object vt) {\n+        boolean thrown = false;\n+        try {\n+            synchronized (vt) {\n+                throw new RuntimeException(\"test61 failed: no exception thrown\");\n+            }\n+        } catch (IdentityException ex) {\n+            thrown = true;\n+        }\n+        if (!thrown) {\n+            throw new RuntimeException(\"test61 failed: no exception thrown\");\n+        }\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        test61(testValue1);\n+    }\n+\n+    @Test\n+    public void test62(Object o) {\n+        try {\n+            synchronized (o) { }\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+            return;\n+        }\n+        throw new RuntimeException(\"test62 failed: no exception thrown\");\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        test62(testValue1);\n+    }\n+\n+    \/\/ Test synchronization without any instructions in the synchronized block\n+    @Test\n+    public void test63(Object o) {\n+        synchronized (o) { }\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        try {\n+            test63(testValue1);\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+            return;\n+        }\n+        throw new RuntimeException(\"test63 failed: no exception thrown\");\n+    }\n+\n+    \/\/ type system test with interface and inline type\n+    @ForceInline\n+    public MyInterface test64Interface_helper(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    public MyInterface test64Interface(MyValue1 vt) {\n+        return test64Interface_helper(vt);\n+    }\n+\n+    @Run(test = \"test64Interface\")\n+    public void test64Interface_verifier() {\n+        test64Interface(testValue1);\n+    }\n+\n+    \/\/ type system test with abstract and inline type\n+    @ForceInline\n+    public MyAbstract test64Abstract_helper(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    public MyAbstract test64Abstract(MyValue1 vt) {\n+        return test64Abstract_helper(vt);\n+    }\n+\n+    @Run(test = \"test64Abstract\")\n+    public void test64Abstract_verifier() {\n+        test64Abstract(testValue1);\n+    }\n+\n+    \/\/ Array store tests\n+    @Test\n+    public void test65(Object[] array, MyValue1 vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        Object[] array = new Object[1];\n+        test65(array, testValue1);\n+        Asserts.assertEQ(((MyValue1)array[0]).hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test66(Object[] array, MyValue1 vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        test66(array, testValue1);\n+        Asserts.assertEQ(array[0].hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test67(Object[] array, Object vt) {\n+        array[0] = vt;\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1[] array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        test67(array, testValue1);\n+        Asserts.assertEQ(array[0].hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    public void test68(Object[] array, NonValueClass o) {\n+        array[0] = o;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        NonValueClass[] array = new NonValueClass[1];\n+        NonValueClass obj = new NonValueClass(1);\n+        test68(array, obj);\n+        Asserts.assertEQ(array[0], obj);\n+    }\n+\n+    \/\/ Test convertion between an inline type and java.lang.Object without an allocation\n+    @ForceInline\n+    public Object test69_sum(Object a, Object b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public int test69(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test69_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        int result = test69(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Same as test69 but with an Interface\n+    @ForceInline\n+    public MyInterface test70Interface_sum(MyInterface a, MyInterface b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public int test70Interface(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test70Interface_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test70Interface\")\n+    public void test70Interface_verifier() {\n+        int result = test70Interface(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Same as test69 but with an Abstract\n+    @ForceInline\n+    public MyAbstract test70Abstract_sum(MyAbstract a, MyAbstract b) {\n+        int sum = ((MyValue1)a).x + ((MyValue1)b).x;\n+        return MyValue1.setX(((MyValue1)a), sum);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public int test70Abstract(MyValue1[] array) {\n+        MyValue1 result = MyValue1.createDefaultInline();\n+        for (int i = 0; i < array.length; ++i) {\n+            result = (MyValue1)test70Abstract_sum(result, array[i]);\n+        }\n+        return result.x;\n+    }\n+\n+    @Run(test = \"test70Abstract\")\n+    public void test70Abstract_verifier() {\n+        int result = test70Abstract(testValue1Array);\n+        Asserts.assertEQ(result, rI * testValue1Array.length);\n+    }\n+\n+    \/\/ Test that allocated inline type is not used in non-dominated path\n+    public MyValue1 test71_inline(Object obj) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            vt = (MyValue1)Objects.requireNonNull(obj);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public MyValue1 test71() {\n+        return test71_inline(null);\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        MyValue1 vt = test71();\n+        Asserts.assertEquals(vt.hash(), hash());\n+    }\n+\n+    \/\/ Test calling a method on an uninitialized inline type\n+    @LooselyConsistentValue\n+    value class Test72Value {\n+        int x = 0;\n+\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Make sure Test72Value is loaded but not initialized\n+    public void unused(Test72Value vt) { }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public int test72() {\n+        Test72Value vt = new Test72Value();\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test72\")\n+    @Warmup(0)\n+    public void test72_verifier() {\n+        int result = test72();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Tests for loading\/storing unkown values\n+    @Test\n+    public Object test73(Object[] va) {\n+        return va[0];\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        MyValue1 vt = (MyValue1)test73(testValue1Array);\n+        Asserts.assertEquals(testValue1Array[0].hash(), vt.hash());\n+    }\n+\n+    @Test\n+    public void test74(Object[] va, Object vt) {\n+        va[0] = vt;\n+    }\n+\n+    @Run(test = \"test74\")\n+    public void test74_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        test74(va, testValue1);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Verify that mixing instances and arrays with the clone api\n+    \/\/ doesn't break anything\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public Object test75(Object o) {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        Object[] next = va;\n+        Object[] arr = va;\n+        for (int i = 0; i < 10; i++) {\n+            arr = next;\n+            next = new NonValueClass[1];\n+        }\n+        return arr[0];\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        test75(42);\n+    }\n+\n+    \/\/ Casting an NonValueClass to a inline type should throw a ClassCastException\n+    @ForceInline\n+    public MyValue1 test77_helper(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test77(NonValueClass obj) throws Throwable {\n+        return test77_helper(obj);\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() throws Throwable {\n+        try {\n+            test77(new NonValueClass(42));\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test77 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting a null NonValueClass to a nullable inline type should not throw\n+    @ForceInline\n+    public MyValue1 test78_helper(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test78(NonValueClass obj) throws Throwable {\n+        return test78_helper(obj);\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() throws Throwable {\n+        try {\n+            test78(null); \/\/ Should not throw\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test78 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Casting an NonValueClass to a nullable inline type should throw a ClassCastException\n+    @ForceInline\n+    public MyValue1 test79_helper(Object o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test79(NonValueClass obj) throws Throwable {\n+        return test79_helper(obj);\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() throws Throwable {\n+        try {\n+            test79(new NonValueClass(42));\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"test79 failed: unexpected exception\", e);\n+        }\n+    }\n+\n+    \/\/ Test flattened field with non-flattenend (but flattenable) inline type field\n+    @LooselyConsistentValue\n+    static value class Small {\n+        int i;\n+        @Strict\n+        @NullRestricted\n+        Big big; \/\/ Too big to be flattened\n+\n+        private Small() {\n+            i = rI;\n+            big = new Big();\n+        }\n+\n+        private Small(int i, Big big) {\n+            this.i = i;\n+            this.big = big;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Big {\n+        long l0,l1,l2,l3,l4,l5,l6,l7,l8,l9;\n+        long l10,l11,l12,l13,l14,l15,l16,l17,l18,l19;\n+        long l20,l21,l22,l23,l24,l25,l26,l27,l28,l29;\n+\n+        private Big() {\n+            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = rL;\n+            l10 = l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = rL+1;\n+            l20 = l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = rL+2;\n+        }\n+\n+        private Big(long l) {\n+            l0 = l1 = l2 = l3 = l4 = l5 = l6 = l7 = l8 = l9 = l10 =\n+            l11 = l12 = l13 = l14 = l15 = l16 = l17 = l18 = l19 = l20 =\n+            l21 = l22 = l23 = l24 = l25 = l26 = l27 = l28 = l29 = 0;\n+        }\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    Small small = new Small();\n+    @Strict\n+    @NullRestricted\n+    Small smallDefault = new Small(0, new Big(0));\n+    @Strict\n+    @NullRestricted\n+    Big big = new Big();\n+    @Strict\n+    @NullRestricted\n+    Big bigDefault = new Big(0);\n+\n+    @Test\n+    public long test80() {\n+        return small.i + small.big.l0 + smallDefault.i + smallDefault.big.l29 + big.l0 + bigDefault.l29;\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() throws Throwable {\n+        long result = test80();\n+        Asserts.assertEQ(result, rI + 2*rL);\n+    }\n+\n+    \/\/ Test scalarization with exceptional control flow\n+    public int test81Callee(MyValue1 vt)  {\n+        return vt.x;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public int test81()  {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        int result = 0;\n+        for (int i = 0; i < 10; i++) {\n+            try {\n+                result += test81Callee(vt);\n+            } catch (NullPointerException npe) {\n+                result += rI;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        int result = test81();\n+        Asserts.assertEQ(result, 10*rI);\n+    }\n+\n+    \/\/ Test check for null free array when storing to inline tpye array\n+    @Test\n+    public void test82(Object[] dst, Object v) {\n+        dst[0] = v;\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier(RunInfo info) {\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT);\n+        test82(dst, testValue2);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test82(dst, null);\n+                throw new RuntimeException(\"No ArrayStoreException thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test83(Object[] dst, Object v, boolean flag) {\n+        if (dst == null) { \/\/ null check\n+        }\n+        if (flag) {\n+            if (dst.getClass() == MyValue1[].class) { \/\/ trigger split if\n+            }\n+        } else {\n+            dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT); \/\/ constant null free property\n+        }\n+        dst[0] = v;\n+    }\n+\n+    @Run(test = \"test83\")\n+    @Warmup(10000)\n+    public void test83_verifier(RunInfo info) {\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT);\n+        test83(dst, testValue2, false);\n+        test83(dst, testValue2, true);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test83(dst, null, true);\n+                throw new RuntimeException(\"No ArrayStoreException thrown\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    private void rerun_and_recompile_for(Method m, int num, Runnable test) {\n+        for (int i = 1; i < num; i++) {\n+            test.run();\n+\n+            if (!TestFramework.isCompiled(m)) {\n+                TestFramework.compile(m, CompLevel.C2);\n+            }\n+        }\n+    }\n+\n+    \/\/ Tests for the Loop Unswitching optimization\n+    \/\/ Should make 2 copies of the loop, one for non flattened arrays, one for other cases.\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        counts = {COUNTED_LOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"UseArrayFlattening\", \"false\"},\n+        counts = {COUNTED_LOOP_MAIN, \"= 1\"})\n+    public void test84(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test84\")\n+    @Warmup(0)\n+    public void test84_verifier(RunInfo info) {\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+        Arrays.fill(src, testValue2);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () ->  { test84(src, dst);\n+                                         Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        counts = {COUNTED_LOOP, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    public void test85(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test85\")\n+    @Warmup(0)\n+    public void test85_verifier(RunInfo info) {\n+        Object[] src = new Object[100];\n+        Arrays.fill(src, new Object());\n+        src[0] = null;\n+        Object[] dst = new Object[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test85(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        counts = {COUNTED_LOOP, \"= 2\"})\n+    public void test86(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test86\")\n+    @Warmup(0)\n+    public void test86_verifier(RunInfo info) {\n+        MyValue2[] src = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+        Arrays.fill(src, testValue2);\n+        Object[] dst = new Object[100];\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test86(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        counts = {COUNTED_LOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"UseArrayFlattening\", \"false\"},\n+        counts = {COUNTED_LOOP_MAIN, \"= 1\"})\n+    public void test87(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; i++) {\n+            dst[i] = src[i];\n+        }\n+    }\n+\n+    @Run(test = \"test87\")\n+    @Warmup(0)\n+    public void test87_verifier(RunInfo info) {\n+        Object[] src = new Object[100];\n+        Arrays.fill(src, testValue2);\n+        MyValue2[] dst = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test87(src, dst);\n+                                        Asserts.assertTrue(Arrays.equals(src, dst)); });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        counts = {COUNTED_LOOP_MAIN, \"= 2\"})\n+    @IR(applyIf = {\"UseArrayFlattening\", \"false\"},\n+        counts = {COUNTED_LOOP_MAIN, \"= 0\"})\n+    public void test88(Object[] src1, Object[] dst1, Object[] src2, Object[] dst2) {\n+        for (int i = 0; i < src1.length; i++) {\n+            dst1[i] = src1[i];\n+            dst2[i] = src2[i];\n+        }\n+    }\n+\n+    @Run(test = \"test88\")\n+    @Warmup(0)\n+    public void test88_verifier(RunInfo info) {\n+        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+        Arrays.fill(src1, testValue2);\n+        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+        Object[] src2 = new Object[100];\n+        Arrays.fill(src2, new Object());\n+        Object[] dst2 = new Object[100];\n+\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test88(src1, dst1, src2, dst2);\n+                                        Asserts.assertTrue(Arrays.equals(src1, dst1));\n+                                        Asserts.assertTrue(Arrays.equals(src2, dst2)); });\n+    }\n+\n+    @Test\n+    public boolean test89(Object obj) {\n+        return obj.getClass() == NonValueClass.class;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        Asserts.assertTrue(test89(new NonValueClass(42)));\n+        Asserts.assertFalse(test89(new Object()));\n+    }\n+\n+    @Test\n+    public NonValueClass test90(Object obj) {\n+        return (NonValueClass)obj;\n+    }\n+\n+    @Run(test = \"test90\")\n+    public void test90_verifier() {\n+        test90(new NonValueClass(42));\n+        try {\n+            test90(new Object());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public boolean test91(Object obj) {\n+        return obj.getClass() == MyValue2[].class;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        Asserts.assertTrue(test91((MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 1, MyValue2.DEFAULT)));\n+        Asserts.assertTrue(test91(new MyValue2[1]));\n+        Asserts.assertFalse(test91(new Object()));\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Test92Value {\n+        int field;\n+\n+        public Test92Value() {\n+            field = 0x42;\n+        }\n+    }\n+\n+    @Test\n+    \/\/ TODO 8355382 The optimization only applies to null-free, flat arrays\n+    @IR(applyIfAnd = {\"UseArrayFlattening\", \"true\", \"UseNullableValueFlattening\", \"false\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, ALLOC, MEMBAR})\n+    public Object test92(Object[] array) {\n+        \/\/ Dummy loops to ensure we run enough passes of split if\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                for (int k = 0; k < 2; k++) {\n+                }\n+            }\n+        }\n+        return (NonValueClass)array[0];\n+    }\n+\n+    @Run(test = \"test92\")\n+    @Warmup(10000)\n+    public void test92_verifier() {\n+        Object[] array = new Object[1];\n+        Object obj = new NonValueClass(rI);\n+        array[0] = obj;\n+        Object result = test92(array);\n+        Asserts.assertEquals(result, obj);\n+    }\n+\n+    \/\/ If the class check succeeds, the flattened array check that\n+    \/\/ precedes will never succeed and the flat array branch should\n+    \/\/ trigger an uncommon trap.\n+    @Test\n+    public Object test93(Object[] array) {\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+            }\n+        }\n+\n+        return (NonValueClass)array[0];\n+    }\n+\n+    @Run(test = \"test93\")\n+    @Warmup(10000)\n+    public void test93_verifier(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            Object[] array = new Object[1];\n+            array[0] = new NonValueClass(42);\n+            Object result = test93(array);\n+            Asserts.assertEquals(((NonValueClass)result).x, 42);\n+        } else {\n+            Object[] array = (Test92Value[])ValueClass.newNullRestrictedNonAtomicArray(Test92Value.class, 1, new Test92Value());\n+            Method m = info.getTest();\n+            int extra = 3;\n+            for (int j = 0; j < extra; j++) {\n+                for (int i = 0; i < 10; i++) {\n+                    try {\n+                        test93(array);\n+                    } catch (ClassCastException cce) {\n+                    }\n+                }\n+                boolean compiled = TestFramework.isCompiled(m);\n+                boolean compilationSkipped = info.isCompilationSkipped();\n+                Asserts.assertTrue(compilationSkipped || compiled || (j != extra-1));\n+                if (!compilationSkipped && !compiled) {\n+                    TestFramework.compile(m, CompLevel.ANY);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    \/\/ TODO 8355382 The optimization only applies to null-free, flat arrays\n+    @IR(applyIfAnd = {\"UseArrayFlattening\", \"true\", \"UseNullableValueFlattening\", \"false\"},\n+        counts = {CLASS_CHECK_TRAP, \"= 2\", LOOP, \"= 1\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, ALLOC, MEMBAR})\n+    public int test94(Object[] array) {\n+        int res = 0;\n+        for (int i = 1; i < 4; i *= 2) {\n+            Object v = array[i];\n+            res += ((NonValueClass)v).x;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test94\")\n+    @Warmup(10000)\n+    public void test94_verifier() {\n+        Object[] array = new Object[4];\n+        Object obj = new NonValueClass(rI);\n+        array[0] = obj;\n+        array[1] = obj;\n+        array[2] = obj;\n+        array[3] = obj;\n+        int result = test94(array);\n+        Asserts.assertEquals(result, rI * 2);\n+    }\n+\n+    @Test\n+    public boolean test95(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test95\")\n+    @Warmup(10000)\n+    public void test95_verifier() {\n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+        Asserts.assertTrue(test95(o1, o1));\n+        Asserts.assertTrue(test95(null, null));\n+        Asserts.assertFalse(test95(o1, null));\n+        Asserts.assertFalse(test95(o1, o2));\n+    }\n+\n+    @Test\n+    public boolean test96(Object o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test96\")\n+    @Warmup(10000)\n+    public void test96_verifier(RunInfo info) {\n+        Object o1 = new Object();\n+        Object o2 = new Object();\n+        Asserts.assertTrue(test96(o1, o1));\n+        Asserts.assertFalse(test96(o1, o2));\n+        if (!info.isWarmUp()) {\n+            Asserts.assertTrue(test96(null, null));\n+            Asserts.assertFalse(test96(o1, null));\n+        }\n+    }\n+\n+    \/\/ Abstract class tests\n+\n+    @DontInline\n+    public MyAbstract test97_dontinline1(MyAbstract o) {\n+        return o;\n+    }\n+\n+    @DontInline\n+    public MyValue1 test97_dontinline2(MyAbstract o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @ForceInline\n+    public MyAbstract test97_inline1(MyAbstract o) {\n+        return o;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test97_inline2(MyAbstract o) {\n+        return (MyValue1)o;\n+    }\n+\n+    @Test\n+    public MyValue1 test97() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        vt = (MyValue1)test97_dontinline1(vt);\n+        vt =           test97_dontinline2(vt);\n+        vt = (MyValue1)test97_inline1(vt);\n+        vt =           test97_inline2(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void test97_verifier() {\n+        Asserts.assertEQ(test97().hash(), hash());\n+    }\n+\n+    \/\/ Test storing\/loading inline types to\/from abstract and inline type fields\n+    MyAbstract abstractField1 = null;\n+    MyAbstract abstractField2 = null;\n+    MyAbstract abstractField3 = null;\n+    MyAbstract abstractField4 = null;\n+    MyAbstract abstractField5 = null;\n+    MyAbstract abstractField6 = null;\n+\n+    @DontInline\n+    public MyAbstract readValueField5AsAbstract() {\n+        return (MyAbstract)valueField5;\n+    }\n+\n+    @DontInline\n+    public MyAbstract readStaticValueField4AsAbstract() {\n+        return (MyAbstract)staticValueField4;\n+    }\n+\n+    @Test\n+    public long test98(MyValue1 vt1, MyAbstract vt2) {\n+        abstractField1 = vt1;\n+        abstractField2 = (MyValue1)vt2;\n+        abstractField3 = MyValue1.createWithFieldsInline(rI, rL);\n+        abstractField4 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        abstractField5 = valueField1;\n+        abstractField6 = valueField3;\n+        valueField1 = (MyValue1)abstractField1;\n+        valueField2 = (MyValue1)vt2;\n+        valueField3 = (MyValue1)vt2;\n+        staticValueField1 = (MyValue1)abstractField1;\n+        staticValueField2 = (MyValue1)vt1;\n+        \/\/ Don't inline these methods because reading NULL will trigger a deoptimization\n+        if (readValueField5AsAbstract() != null || readStaticValueField4AsAbstract() != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        return ((MyValue1)abstractField1).hash() + ((MyValue1)abstractField2).hash() +\n+               ((MyValue1)abstractField3).hash() + ((MyValue1)abstractField4).hash() +\n+               ((MyValue1)abstractField5).hash() + ((MyValue1)abstractField6).hash() +\n+                valueField1.hash() + valueField2.hash() + valueField3.hash() + valueField4.hashPrimitive() +\n+                staticValueField1.hash() + staticValueField2.hash() + staticValueField3.hashPrimitive();\n+    }\n+\n+    @Run(test = \"test98\")\n+    public void test98_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 def = MyValue1.createDefaultDontInline();\n+        long result = test98(vt, vt);\n+        Asserts.assertEQ(result, 11*vt.hash() + 2*def.hashPrimitive());\n+    }\n+\n+    value class MyObject2 extends MyAbstract {\n+        public int x;\n+\n+        public MyObject2(int x) {\n+            this.x = x;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return x;\n+        }\n+    }\n+\n+    \/\/ Test merging inline types and abstract classes\n+    @Test\n+    public MyAbstract test99(int state) {\n+        MyAbstract res = null;\n+        if (state == 0) {\n+            res = new MyObject2(rI);\n+        } else if (state == 1) {\n+            res = MyValue1.createWithFieldsInline(rI, rL);\n+        } else if (state == 2) {\n+            res = MyValue1.createWithFieldsDontInline(rI, rL);\n+        } else if (state == 3) {\n+            res = (MyValue1)objectField1;\n+        } else if (state == 4) {\n+            res = valueField1;\n+        } else if (state == 5) {\n+            res = null;\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test99\")\n+    public void test99_verifier() {\n+        objectField1 = valueField1;\n+        MyAbstract result = null;\n+        result = test99(0);\n+        Asserts.assertEQ(((MyObject2)result).x, rI);\n+        result = test99(1);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(2);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(3);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(4);\n+        Asserts.assertEQ(((MyValue1)result).hash(), hash());\n+        result = test99(5);\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ Test merging inline types and abstract classes in loops\n+    @Test\n+    public MyAbstract test100(int iters) {\n+        MyAbstract res = new MyObject2(rI);\n+        for (int i = 0; i < iters; ++i) {\n+            if (res instanceof MyObject2) {\n+                res = MyValue1.createWithFieldsInline(rI, rL);\n+            } else {\n+                res = MyValue1.createWithFieldsInline(((MyValue1)res).x + 1, rL);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test100\")\n+    public void test100_verifier() {\n+        MyObject2 result1 = (MyObject2)test100(0);\n+        Asserts.assertEQ(result1.x, rI);\n+        int iters = (Math.abs(rI) % 10) + 1;\n+        MyValue1 result2 = (MyValue1)test100(iters);\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI + iters - 1, rL);\n+        Asserts.assertEQ(result2.hash(), vt.hash());\n+    }\n+\n+    \/\/ Test inline types in abstract class variables that are live at safepoint\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS, LOOP})\n+    public long test101(MyValue1 arg, boolean deopt, Method m) {\n+        MyAbstract vt1 = MyValue1.createWithFieldsInline(rI, rL);\n+        MyAbstract vt2 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyAbstract vt3 = arg;\n+        MyAbstract vt4 = valueField1;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)vt1).hash() + ((MyValue1)vt2).hash() +\n+               ((MyValue1)vt3).hash() + ((MyValue1)vt4).hash();\n+    }\n+\n+    @Run(test = \"test101\")\n+    public void test101_verifier(RunInfo info) {\n+        long result = test101(valueField1, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result, 4*hash());\n+    }\n+\n+    \/\/ Test comparing inline types with abstract classes\n+    @Test\n+    public boolean test102(Object arg) {\n+        MyAbstract vt = MyValue1.createWithFieldsInline(rI, rL);\n+        if (vt == arg || vt == (MyAbstract)valueField1 || vt == abstractField1 || vt == null ||\n+            arg == vt || (MyAbstract)valueField1 == vt || abstractField1 == vt || null == vt) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public void test102_verifier() {\n+        boolean result = test102(null);\n+        Asserts.assertFalse(result);\n+    }\n+\n+    \/\/ An abstract class with a non-static field can never be implemented by an inline type\n+    abstract class NoValueImplementors1 {\n+        int field = 42;\n+    }\n+\n+    class MyObject3 extends NoValueImplementors1 {\n+\n+    }\n+\n+    class MyObject4 extends NoValueImplementors1 {\n+\n+    }\n+\n+    \/\/ Loading from an abstract class array does not require a flatness check if the abstract class has a non-static field\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors1 test103(NoValueImplementors1[] array, int i) {\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test103\")\n+    public void test103_verifier() {\n+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];\n+        MyObject3[] array2 = new MyObject3[3];\n+        MyObject4[] array3 = new MyObject4[3];\n+        NoValueImplementors1 result = test103(array1, 0);\n+        Asserts.assertEquals(result, array1[0]);\n+\n+        result = test103(array2, 1);\n+        Asserts.assertEquals(result, array1[1]);\n+\n+        result = test103(array3, 2);\n+        Asserts.assertEquals(result, array1[2]);\n+    }\n+\n+    \/\/ Storing to an abstract class array does not require a flatness\/null check if the abstract class has a non-static field\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors1 test104(NoValueImplementors1[] array, NoValueImplementors1 v, MyObject3 o, int i) {\n+        array[0] = v;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test104\")\n+    public void test104_verifier() {\n+        MyObject4 v = new MyObject4();\n+        MyObject3 o = new MyObject3();\n+        NoValueImplementors1[] array1 = new NoValueImplementors1[3];\n+        MyObject3[] array2 = new MyObject3[3];\n+        MyObject4[] array3 = new MyObject4[3];\n+        NoValueImplementors1 result = test104(array1, v, o, 0);\n+        Asserts.assertEquals(array1[0], v);\n+        Asserts.assertEquals(array1[1], v);\n+        Asserts.assertEquals(array1[2], o);\n+        Asserts.assertEquals(result, v);\n+\n+        result = test104(array2, o, o, 1);\n+        Asserts.assertEquals(array2[0], o);\n+        Asserts.assertEquals(array2[1], o);\n+        Asserts.assertEquals(array2[2], o);\n+        Asserts.assertEquals(result, o);\n+\n+        result = test104(array3, v, null, 1);\n+        Asserts.assertEquals(array3[0], v);\n+        Asserts.assertEquals(array3[1], v);\n+        Asserts.assertEquals(array3[2], null);\n+        Asserts.assertEquals(result, v);\n+    }\n+\n+    \/\/ An abstract class with a single, non-inline implementor\n+    abstract class NoValueImplementors2 {\n+\n+    }\n+\n+    class MyObject5 extends NoValueImplementors2 {\n+\n+    }\n+\n+    \/\/ Loading from an abstract class array does not require a flatness check if the abstract class has no inline implementor\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors2 test105(NoValueImplementors2[] array, int i) {\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test105\")\n+    public void test105_verifier() {\n+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];\n+        MyObject5[] array2 = new MyObject5[3];\n+        NoValueImplementors2 result = test105(array1, 0);\n+        Asserts.assertEquals(result, array1[0]);\n+\n+        result = test105(array2, 1);\n+        Asserts.assertEquals(result, array1[1]);\n+    }\n+\n+    \/\/ Storing to an abstract class array does not require a flatness\/null check if the abstract class has no inline implementor\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD})\n+    public NoValueImplementors2 test106(NoValueImplementors2[] array, NoValueImplementors2 v, MyObject5 o, int i) {\n+        array[0] = v;\n+        array[1] = array[0];\n+        array[2] = o;\n+        return array[i];\n+    }\n+\n+    @Run(test = \"test106\")\n+    public void test106_verifier() {\n+        MyObject5 v = new MyObject5();\n+        NoValueImplementors2[] array1 = new NoValueImplementors2[3];\n+        MyObject5[] array2 = new MyObject5[3];\n+        NoValueImplementors2 result = test106(array1, v, null, 0);\n+        Asserts.assertEquals(array1[0], v);\n+        Asserts.assertEquals(array1[1], v);\n+        Asserts.assertEquals(array1[2], null);\n+        Asserts.assertEquals(result, v);\n+\n+        result = test106(array2, v, v, 1);\n+        Asserts.assertEquals(array2[0], v);\n+        Asserts.assertEquals(array2[1], v);\n+        Asserts.assertEquals(array2[2], v);\n+        Asserts.assertEquals(result, v);\n+    }\n+\n+    \/\/ More tests for the Loop Unswitching optimization (similar to test84 and following)\n+    Object oFld1, oFld2;\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        failOn = {STORE_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTED_LOOP, \"= 2\", LOAD_UNKNOWN_INLINE, \"= 2\"},\n+         \/\/ Match on CCP since we are removing one of the unswitched loop versions later due to being empty\n+        phase = {CompilePhase.CCP1})\n+    public void test107(Object[] src1, Object[] src2) {\n+        for (int i = 0; i < src1.length; i++) {\n+            oFld1 = src1[i];\n+            oFld2 = src2[i];\n+        }\n+    }\n+\n+    @Run(test = \"test107\")\n+    @Warmup(0)\n+    public void test107_verifier(RunInfo info) {\n+        MyValue2[] src1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+        Arrays.fill(src1, testValue2);\n+        Object[] src2 = new Object[100];\n+        Object obj = new Object();\n+        Arrays.fill(src2, obj);\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test107(src1, src2);\n+                                        Asserts.assertEquals(oFld1, testValue2);\n+                                        Asserts.assertEquals(oFld2, obj);\n+                                        test107(src2, src1);\n+                                        Asserts.assertEquals(oFld1, obj);\n+                                        Asserts.assertEquals(oFld2, testValue2);  });\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        failOn = {LOAD_UNKNOWN_INLINE, INLINE_ARRAY_NULL_GUARD},\n+        counts = {COUNTED_LOOP, \"= 4\", STORE_UNKNOWN_INLINE, \"= 9\"})\n+    public void test108(Object[] dst1, Object[] dst2, Object o1, Object o2) {\n+        for (int i = 0; i < dst1.length; i++) {\n+            dst1[i] = o1;\n+            dst2[i] = o2;\n+        }\n+    }\n+\n+    @Run(test = \"test108\")\n+    @Warmup(0)\n+    public void test108_verifier(RunInfo info) {\n+        MyValue2[] dst1 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 100, MyValue2.DEFAULT);\n+        Object[] dst2 = new Object[100];\n+        Object o1 = new Object();\n+        rerun_and_recompile_for(info.getTest(), 10,\n+                                () -> { test108(dst1, dst2, testValue2, o1);\n+                                        for (int i = 0; i < dst1.length; i++) {\n+                                            Asserts.assertEquals(dst1[i], testValue2);\n+                                            Asserts.assertEquals(dst2[i], o1);\n+                                        }\n+                                        test108(dst2, dst1, o1, testValue2);\n+                                        for (int i = 0; i < dst1.length; i++) {\n+                                            Asserts.assertEquals(dst1[i], testValue2);\n+                                            Asserts.assertEquals(dst2[i], o1);\n+                                        } });\n+    }\n+\n+    \/\/ Escape analysis tests\n+\n+    static interface WrapperInterface {\n+        long value();\n+\n+        final static WrapperInterface ZERO = new LongWrapper(0);\n+\n+        @ForceInline\n+        static WrapperInterface wrap(long val) {\n+            return (val == 0L) ? ZERO : new LongWrapper(val);\n+        }\n+    }\n+\n+    @ForceCompileClassInitializer\n+    @LooselyConsistentValue\n+    static value class LongWrapper implements WrapperInterface {\n+        @Strict\n+        @NullRestricted\n+        final static LongWrapper ZERO = new LongWrapper(0);\n+        private long val;\n+\n+        @ForceInline\n+        LongWrapper(long val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        static LongWrapper wrap(long val) {\n+            return (val == 0L) ? ZERO : new LongWrapper(val);\n+        }\n+\n+        @ForceInline\n+        public long value() {\n+            return val;\n+        }\n+    }\n+\n+    static class InterfaceBox {\n+        WrapperInterface content;\n+\n+        @ForceInline\n+        InterfaceBox(WrapperInterface content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox box_sharp(long val) {\n+            return new InterfaceBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox box(long val) {\n+            return new InterfaceBox(WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class ObjectBox {\n+        Object content;\n+\n+        @ForceInline\n+        ObjectBox(Object content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static ObjectBox box_sharp(long val) {\n+            return new ObjectBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static ObjectBox box(long val) {\n+            return new ObjectBox(WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class RefBox {\n+        LongWrapper content;\n+\n+        @ForceInline\n+        RefBox(LongWrapper content) {\n+            this.content = content;\n+        }\n+\n+        @ForceInline\n+        static RefBox box_sharp(long val) {\n+            return new RefBox(LongWrapper.wrap(val));\n+        }\n+\n+        @ForceInline\n+        static RefBox box(long val) {\n+            return new RefBox((LongWrapper)WrapperInterface.wrap(val));\n+        }\n+    }\n+\n+    static class InlineBox {\n+        @Strict\n+        @NullRestricted\n+        LongWrapper content;\n+\n+        @ForceInline\n+        InlineBox(long val) {\n+            this.content = LongWrapper.wrap(val);\n+        }\n+\n+        @ForceInline\n+        static InlineBox box(long val) {\n+            return new InlineBox(val);\n+        }\n+    }\n+\n+    static class GenericBox<T> {\n+        T content;\n+\n+        @ForceInline\n+        static GenericBox<LongWrapper> box_sharp(long val) {\n+            GenericBox<LongWrapper> res = new GenericBox<>();\n+            res.content = LongWrapper.wrap(val);\n+            return res;\n+        }\n+\n+        @ForceInline\n+        static GenericBox<WrapperInterface> box(long val) {\n+            GenericBox<WrapperInterface> res = new GenericBox<>();\n+            res.content = WrapperInterface.wrap(val);\n+            return res;\n+        }\n+    }\n+\n+    long[] lArr = {0L, rL, 0L, rL, 0L, rL, 0L, rL, 0L, rL};\n+\n+    \/\/ Test removal of allocations when inline type instance is wrapped into box object\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test109() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test109\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test109_verifier() {\n+        long res = test109();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    @IR(failOn = {ALLOC, MEMBAR})\n+    public long test109_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test109_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test109_sharp_verifier() {\n+        long res = test109_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with ObjectBox\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test110() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += ((WrapperInterface)ObjectBox.box(lArr[i]).content).value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test110\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test110_verifier() {\n+        long res = test110();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    @IR(failOn = {ALLOC, MEMBAR})\n+    public long test110_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += ((WrapperInterface)ObjectBox.box_sharp(lArr[i]).content).value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test110_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test110_sharp_verifier() {\n+        long res = test110_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with RefBox\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test111() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += RefBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        long res = test111();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test111_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += RefBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test111_sharp\")\n+    public void test111_sharp_verifier() {\n+        long res = test111_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with InlineBox\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test112() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InlineBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier() {\n+        long res = test112();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test109 but with GenericBox\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test113() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += GenericBox.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test113\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test113_verifier() {\n+        long res = test113();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test113_sharp() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += GenericBox.box_sharp(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test113_sharp\")\n+    @Warmup(10000) \/\/ Make sure interface calls are inlined\n+    public void test113_sharp_verifier() {\n+        long res = test113_sharp();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    static interface WrapperInterface2 {\n+        public long value();\n+\n+        static final InlineWrapper ZERO = new InlineWrapper(0);\n+\n+        @ForceInline\n+        public static WrapperInterface2 wrap(long val) {\n+            return (val == 0) ? ZERO.content : new LongWrapper2(val);\n+        }\n+\n+        @ForceInline\n+        public static WrapperInterface2 wrap_dynamic(long val) {\n+            return (val == 0) ? new LongWrapper2(0) : new LongWrapper2(val);\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class LongWrapper2 implements WrapperInterface2 {\n+        private long val;\n+\n+        @ForceInline\n+        public LongWrapper2(long val) {\n+            this.val = val;\n+        }\n+\n+        @ForceInline\n+        public long value() {\n+            return val;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class InlineWrapper {\n+        WrapperInterface2 content;\n+\n+        @ForceInline\n+        public InlineWrapper(long val) {\n+            content = new LongWrapper2(val);\n+        }\n+    }\n+\n+    static class InterfaceBox2 {\n+        WrapperInterface2 content;\n+\n+        @ForceInline\n+        public InterfaceBox2(long val, boolean def) {\n+            this.content = def ? WrapperInterface2.wrap_dynamic(val) : WrapperInterface2.wrap(val);\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox2 box(long val) {\n+            return new InterfaceBox2(val, false);\n+        }\n+\n+        @ForceInline\n+        static InterfaceBox2 box_dynamic(long val) {\n+            return new InterfaceBox2(val, true);\n+        }\n+    }\n+\n+    \/\/ Same as tests above but with ZERO hidden in field of another inline type\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test114() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox2.box(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test114\")\n+    @Warmup(10000)\n+    public void test114_verifier() {\n+        long res = test114();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    \/\/ Same as test114 but with dynamic instead of constant ZERO field\n+    @Test\n+    @IR(failOn = {ALLOC, MEMBAR},\n+        counts = {PREDICATE_TRAP, \"= 1\"})\n+    public long test115() {\n+        long res = 0;\n+        for (int i = 0; i < lArr.length; i++) {\n+            res += InterfaceBox2.box_dynamic(lArr[i]).content.value();\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test115\")\n+    @Warmup(10000)\n+    public void test115_verifier() {\n+        long res = test115();\n+        Asserts.assertEquals(res, 5*rL);\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    static MyValueEmpty fEmpty1 = new MyValueEmpty();\n+    static MyValueEmpty fEmpty2 = new MyValueEmpty();\n+    @Strict\n+    @NullRestricted\n+           MyValueEmpty fEmpty3 = new MyValueEmpty();\n+           MyValueEmpty fEmpty4 = new MyValueEmpty();\n+\n+    \/\/ Test fields loads\/stores with empty inline types\n+    @Test\n+    public void test116() {\n+        fEmpty1 = fEmpty4;\n+        fEmpty2 = fEmpty1;\n+        fEmpty3 = fEmpty2;\n+        fEmpty4 = fEmpty3;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier() {\n+        test116();\n+        Asserts.assertEquals(fEmpty1, fEmpty2);\n+        Asserts.assertEquals(fEmpty2, fEmpty3);\n+        Asserts.assertEquals(fEmpty3, fEmpty4);\n+    }\n+\n+    \/\/ Test array loads\/stores with empty inline types\n+    @Test\n+    public MyValueEmpty test117(MyValueEmpty[] arr1, MyValueEmpty[] arr2) {\n+        arr1[0] = arr2[0];\n+        arr2[0] = new MyValueEmpty();\n+        return arr1[0];\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        MyValueEmpty[] arr1 = new MyValueEmpty[] { new MyValueEmpty() };\n+        MyValueEmpty res = test117(arr1, arr1);\n+        Asserts.assertEquals(res, new MyValueEmpty());\n+        \/\/ TODO 8366668 Re-enable\n+        \/\/ Asserts.assertEquals(arr1[0], new MyValueEmpty());\n+    }\n+\n+    \/\/ Test acmp with empty inline types\n+    @Test\n+    public boolean test118(MyValueEmpty v1, MyValueEmpty v2, Object o1) {\n+        return (v1 == v2) && (v2 == o1);\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        boolean res = test118(new MyValueEmpty(), new MyValueEmpty(), new MyValueEmpty());\n+        Asserts.assertTrue(res);\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class EmptyContainer {\n+        @Strict\n+        @NullRestricted\n+        private MyValueEmpty empty = new MyValueEmpty();\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MixedContainer {\n+        public int val = 0;\n+        @Strict\n+        @NullRestricted\n+        private EmptyContainer empty = new EmptyContainer();\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    static final MyValueEmpty empty = new MyValueEmpty();\n+\n+    @Strict\n+    @NullRestricted\n+    static final EmptyContainer emptyC = new EmptyContainer();\n+\n+    @Strict\n+    @NullRestricted\n+    static final MixedContainer mixedContainer = new MixedContainer();\n+\n+    \/\/ Test re-allocation of empty inline type array during deoptimization\n+    @Test\n+    public void test119(boolean deopt, Method m) {\n+        MyValueEmpty[]   array1 = new MyValueEmpty[] { empty };\n+        EmptyContainer[] array2 = (EmptyContainer[])ValueClass.newNullRestrictedNonAtomicArray(EmptyContainer.class, 1, emptyC);\n+        array2[0] = emptyC;\n+        MixedContainer[] array3 = (MixedContainer[])ValueClass.newNullRestrictedNonAtomicArray(MixedContainer.class, 1, mixedContainer);\n+        array3[0] = mixedContainer;\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        \/\/ TODO 8366668 Re-enable\n+        \/\/ Asserts.assertEquals(array1[0], empty);\n+        Asserts.assertEquals(array2[0], emptyC);\n+        Asserts.assertEquals(array3[0], mixedContainer);\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier(RunInfo info) {\n+        test119(!info.isWarmUp(), info.getTest());\n+    }\n+\n+    \/\/ Test optimization of empty inline type field stores\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public void test120() {\n+        fEmpty1 = empty;\n+        fEmpty3 = empty;\n+        \/\/ fEmpty2 and fEmpty4 could be null, store can't be removed\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        test120();\n+        Asserts.assertEquals(fEmpty1, empty);\n+    }\n+\n+    \/\/ Test removal of empty inline type field loads\n+    @Test\n+    @IR(failOn = {LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, FIELD_ACCESS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public boolean test121() {\n+        return fEmpty1.equals(fEmpty3);\n+        \/\/ fEmpty2 and fEmpty4 could be null, load can't be removed\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        boolean res = test121();\n+        Asserts.assertTrue(res);\n+    }\n+\n+    \/\/ Verify that empty inline type field loads check for null holder\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC})\n+    public MyValueEmpty test122(TestLWorld t) {\n+        return t.fEmpty3;\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        MyValueEmpty res = test122(this);\n+        Asserts.assertEquals(res, new MyValueEmpty());\n+        try {\n+            test122(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Verify that empty inline type field stores check for null holder\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test123(TestLWorld t) {\n+        t.fEmpty3 = new MyValueEmpty();\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier() {\n+        test123(this);\n+        Asserts.assertEquals(fEmpty3, new MyValueEmpty());\n+        try {\n+            test123(null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ acmp doesn't need substitutability test when one input is known\n+    \/\/ not to be a value type\n+    @Test\n+    @IR(failOn = SUBSTITUTABILITY_TEST)\n+    public boolean test124(NonValueClass o1, Object o2) {\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier() {\n+        NonValueClass obj = new NonValueClass(rI);\n+        test124(obj, obj);\n+        test124(obj, testValue1);\n+    }\n+\n+    \/\/ acmp doesn't need substitutability test when one input is null\n+    @Test\n+    @IR(failOn = {SUBSTITUTABILITY_TEST})\n+    public boolean test125(Object o1) {\n+        Object o2 = null;\n+        return o1 == o2;\n+    }\n+\n+    @Run(test = \"test125\")\n+    public void test125_verifier() {\n+        test125(testValue1);\n+        test125(null);\n+    }\n+\n+    \/\/ Test inline type that can only be scalarized after loop opts\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test126(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test126\")\n+    @Warmup(10000)\n+    public void test126_verifier(RunInfo info) {\n+        long res = test126(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test126(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test126 but with interface type\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test127(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after loop opts\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after loop opts\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test127\")\n+    @Warmup(10000)\n+    public void test127_verifier(RunInfo info) {\n+        long res = test127(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test127(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Test inline type that can only be scalarized after CCP\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test128(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test128\")\n+    @Warmup(10000)\n+    public void test128_verifier(RunInfo info) {\n+        long res = test128(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test128(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Same as test128 but with interface type\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test129(boolean trap) {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 0; i < limit; i++) {\n+            val = nonNull;\n+        }\n+        \/\/ 'val' is always non-null here but that's only known after CCP\n+        if (trap) {\n+            \/\/ Uncommon trap with an inline input that can only be scalarized after CCP\n+            return val.hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test129\")\n+    @Warmup(10000)\n+    public void test129_verifier(RunInfo info) {\n+        long res = test129(false);\n+        Asserts.assertEquals(res, 0L);\n+        if (!info.isWarmUp()) {\n+            res = test129(true);\n+            Asserts.assertEquals(res, testValue2.hash());\n+        }\n+    }\n+\n+    \/\/ Lock on inline type (known after inlining)\n+    @ForceInline\n+    public Object test130_inlinee() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @Test\n+    @IR(failOn = {LOAD_OF_ANY_KLASS},\n+        \/\/ LockNode keeps MyValue1 allocation alive up until macro expansion which in turn keeps MyValue2\n+        \/\/ alloc alive. Although the MyValue1 allocation is removed (unused), MyValue2 is expanded first\n+        \/\/ and therefore stays.\n+        counts = {ALLOC_OF_MYVALUE_KLASS, \"<= 1\", STORE_OF_ANY_KLASS, \"<= 1\"})\n+    public void test130() {\n+        Object obj = test130_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test130 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test130\")\n+    public void test130_verifier() {\n+        try {\n+            test130();\n+            throw new RuntimeException(\"test130 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test130 but with field load instead of allocation\n+    @ForceInline\n+    public Object test131_inlinee() {\n+        return testValue1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test131() {\n+        Object obj = test131_inlinee();\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test131 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test131\")\n+    public void test131_verifier() {\n+        try {\n+            test131();\n+            throw new RuntimeException(\"test131 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test locking on object that is known to be an inline type only after CCP\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public void test132() {\n+        MyValue2 vt = MyValue2.createWithFieldsInline(rI, rD);\n+        Object obj = new NonValueClass(42);\n+\n+        int limit = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            obj = vt;\n+        }\n+        synchronized (obj) {\n+            throw new RuntimeException(\"test132 failed: synchronization on inline type should not succeed\");\n+        }\n+    }\n+\n+    @Run(test = \"test132\")\n+    @Warmup(10000)\n+    public void test132_verifier() {\n+        try {\n+            test132();\n+            throw new RuntimeException(\"test132 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test conditional locking on inline type and non-escaping object\n+    @Test\n+    public void test133(boolean b) {\n+        Object obj = b ? new NonValueClass(rI) : MyValue2.createWithFieldsInline(rI, rD);\n+        synchronized (obj) {\n+            if (!b) {\n+                throw new RuntimeException(\"test133 failed: synchronization on inline type should not succeed\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test133\")\n+    public void test133_verifier() {\n+        test133(true);\n+        try {\n+            test133(false);\n+            throw new RuntimeException(\"test133 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Variant with non-scalarized inline type\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public void test134(boolean b) {\n+        Object obj = null;\n+        if (b) {\n+            obj = MyValue2.createWithFieldsInline(rI, rD);\n+        }\n+        synchronized (obj) {\n+\n+        }\n+    }\n+\n+    @Run(test = \"test134\")\n+    public void test134_verifier() {\n+        try {\n+            test134(true);\n+            throw new RuntimeException(\"test134 failed: no exception thrown\");\n+        } catch (IdentityException ex) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test that acmp of the same inline object is removed\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public boolean test135() {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        return val == val;\n+    }\n+\n+    @Run(test = \"test135\")\n+    public void test135_verifier() {\n+        Asserts.assertTrue(test135());\n+    }\n+\n+    \/\/ Same as test135 but with null\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public boolean test136(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val == val;\n+    }\n+\n+    @Run(test = \"test136\")\n+    public void test136_verifier() {\n+        Asserts.assertTrue(test136(false));\n+        Asserts.assertTrue(test136(true));\n+    }\n+\n+    \/\/ Test that acmp of different inline objects with same content is removed\n+    @Test\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public boolean test137(int i) {\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(i, rD);\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test137\")\n+    public void test137_verifier() {\n+        Asserts.assertTrue(test137(rI));\n+    }\n+\n+    \/\/ Same as test137 but with null\n+    @Test\n+    \/\/ TODO 8228361\n+    \/\/ @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, NULL_CHECK_TRAP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public boolean test138(int i, boolean b) {\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(i, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(i, rD);\n+        if (b) {\n+            val1 = null;\n+            val2 = null;\n+        }\n+        return val1 == val2;\n+    }\n+\n+    @Run(test = \"test138\")\n+    public void test138_verifier() {\n+        Asserts.assertTrue(test138(rI, false));\n+        Asserts.assertTrue(test138(rI, true));\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Test139Value {\n+        Object obj = null;\n+        @Strict\n+        @NullRestricted\n+        MyValueEmpty empty = new MyValueEmpty();\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Test139Wrapper {\n+        @Strict\n+        @NullRestricted\n+        Test139Value value = new Test139Value();\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(failOn = {LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public MyValueEmpty test139() {\n+        Test139Wrapper w = new Test139Wrapper();\n+        return w.value.empty;\n+    }\n+\n+    @Run(test = \"test139\")\n+    public void test139_verifier() {\n+        MyValueEmpty empty = test139();\n+        Asserts.assertEquals(empty, new MyValueEmpty());\n+    }\n+\n+    \/\/ Test calling a method on a loaded but not linked inline type\n+    @LooselyConsistentValue\n+    value class Test140Value {\n+        int x = 0;\n+\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public int test140() {\n+        Test140Value vt = new Test140Value();\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test140\")\n+    @Warmup(0)\n+    public void test140_verifier() {\n+        int result = test140();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Test calling a method on a linked but not initialized inline type\n+    @LooselyConsistentValue\n+    value class Test141Value {\n+        int x = 0;\n+\n+        public int get() {\n+            return x;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public int test141() {\n+        Test141Value vt = new Test141Value();\n+        return vt.get();\n+    }\n+\n+    @Run(test = \"test141\")\n+    @Warmup(0)\n+    public void test141_verifier() {\n+        int result = test141();\n+        Asserts.assertEquals(result, 0);\n+    }\n+\n+    \/\/ Test that virtual calls on inline type receivers are properly inlined\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test142() {\n+        MyValue2 nonNull = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface val = null;\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = nonNull;\n+            }\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test142\")\n+    public void test142_verifier() {\n+        long res = test142();\n+        Asserts.assertEquals(res, testValue2.hash());\n+    }\n+\n+    \/\/ Test merging of buffered inline types\n+    @Test\n+    public Object test144(int i) {\n+        if (i == 0) {\n+            return MyValue1.createDefaultInline();\n+        } else if (i == 1) {\n+            return testValue1;\n+        } else {\n+            return MyValue1.createDefaultInline();\n+        }\n+    }\n+\n+    @Run(test = \"test144\")\n+    public void test144_verifier() {\n+        Asserts.assertEquals(test144(0), MyValue1.createDefaultInline());\n+        Asserts.assertEquals(test144(1), testValue1);\n+        Asserts.assertEquals(test144(2), MyValue1.createDefaultInline());\n+    }\n+\n+    \/\/ Tests writing an array element with a (statically known) incompatible type\n+    private static final MethodHandle setArrayElementIncompatibleRef = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+        \"setArrayElementIncompatibleRef\",\n+        MethodType.methodType(void.class, TestLWorld.class, MyValue1[].class, int.class, MyValue2.class),\n+        CODE -> {\n+            CODE.\n+            aload(1).\n+            iload(2).\n+            aload(3).\n+            aastore().\n+            return_();\n+        });\n+\n+    \/\/ Test inline type connected to result node\n+    @Test\n+    @IR(failOn = {ALLOC})\n+    public MyValue1 test146(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    @Run(test = \"test146\")\n+    @Warmup(10000)\n+    public void test146_verifier() {\n+        Asserts.assertEQ(test146(testValue1), testValue1);\n+    }\n+\n+    @ForceInline\n+    public Object test148_helper(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    \/\/ Same as test146 but with helper method\n+    @Test\n+    public Object test148(Object obj) {\n+        return test148_helper(obj);\n+    }\n+\n+    @Run(test = \"test148\")\n+    @Warmup(10000)\n+    public void test148_verifier() {\n+        Asserts.assertEQ(test148(testValue1), testValue1);\n+    }\n+\n+    @ForceInline\n+    public Object test149_helper(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    \/\/ Same as test147 but with helper method\n+    @Test\n+    public Object test149(Object obj) {\n+        return test149_helper(obj);\n+    }\n+\n+    @Run(test = \"test149\")\n+    @Warmup(10000)\n+    public void test149_verifier() {\n+        Asserts.assertEQ(test149(testValue1), testValue1);\n+        Asserts.assertEQ(test149(null), null);\n+    }\n+\n+    \/\/ Test post-parse call devirtualization with inline type receiver\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test150() {\n+        MyValue2 val = MyValue2.createWithFieldsInline(rI, rD);\n+        MyInterface receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test150\")\n+    public void test150_verifier() {\n+        Asserts.assertEquals(test150(), testValue2.hash());\n+    }\n+\n+    \/\/ Same as test150 but with a real loop and val not being allocated in the scope of the method\n+    @Test\n+    \/\/ Dynamic call does not null check the receiver, so it cannot be strength reduced to a static\n+    \/\/ call without an explicit null check\n+    @IR(failOn = {compiler.lib.ir_framework.IRNode.DYNAMIC_CALL_OF_METHOD, \"MyValue2::hash\"},\n+        counts = {compiler.lib.ir_framework.IRNode.STATIC_CALL_OF_METHOD, \"MyValue2::hash\", \"= 1\"})\n+    public long test151(MyValue2 val) {\n+        val = Objects.requireNonNull(val);\n+        MyAbstract receiver = MyValue1.createWithFieldsInline(rI, rL);\n+\n+        for (int i = 0; i < 100; i++) {\n+            if ((i % 2) == 0) {\n+                receiver = val;\n+            }\n+        }\n+        \/\/ Trigger post parse call devirtualization (strength-reducing\n+        \/\/ virtual calls to direct calls).\n+        return receiver.hash();\n+    }\n+\n+    @Run(test = \"test151\")\n+    @Warmup(0) \/\/ Make sure there is no receiver type profile\n+    public void test151_verifier() {\n+        Asserts.assertEquals(test151(testValue2), testValue2.hash());\n+    }\n+\n+    static interface MyInterface2 {\n+        public int val();\n+    }\n+\n+    static abstract value class MyAbstract2 implements MyInterface2 {\n+\n+    }\n+\n+    static class MyClass152 extends MyAbstract2 {\n+        private int val;\n+\n+        @ForceInline\n+        public MyClass152(int val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public int val() {\n+            return val;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue152 extends MyAbstract2 {\n+        private int unused = 0; \/\/ Make sure sub-offset of val is field non-zero\n+        private int val;\n+\n+        @ForceInline\n+        public MyValue152(int val) {\n+            this.val = val;\n+        }\n+\n+        @Override\n+        public int val() {\n+            return val;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyWrapper152 {\n+        private int unused = 0; \/\/ Make sure sub-offset of val field is non-zero\n+        @Strict\n+        @NullRestricted\n+        MyValue152 val;\n+\n+        @ForceInline\n+        public MyWrapper152(MyInterface2 val) {\n+            this.val = (MyValue152)val;\n+        }\n+    }\n+\n+    \/\/ Test that checkcast with speculative type does not break scalarization in return\n+    @Test\n+    public MyWrapper152 test152(MyInterface2 val) {\n+        return new MyWrapper152(val);\n+    }\n+\n+    @Run(test = \"test152\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test152_verifier() {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test152(val).val, val);\n+    }\n+\n+    @DontInline\n+    static void test153_helper(MyWrapper152 arg) {\n+\n+    }\n+\n+    \/\/ Test that checkcast with speculative type does not prevent scalarization in args\n+    @Test\n+    public void test153(MyInterface2 val) {\n+        test153_helper(new MyWrapper152(val));\n+    }\n+\n+    @Run(test = \"test153\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test153_verifier() {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        test153(val);\n+    }\n+\n+    \/\/ Test that checkcast with speculative type enables scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public int test154(Method m, MyInterface2 val, boolean b1, boolean b2) {\n+        MyInterface2 obj = new MyValue152(rI);\n+        if (b1) {\n+            \/\/ Speculative cast to MyValue152 enables scalarization\n+            obj = (MyAbstract2)val;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.val();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test154\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test154_verifier(RunInfo info) {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test154(info.getTest(), val, false, false), -1);\n+        Asserts.assertEquals(test154(info.getTest(), val, true, false), -1);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test154(info.getTest(), val, false, true), rI);\n+        }\n+    }\n+\n+    \/\/ Same as test154 but with null val\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public int test155(Method m, MyInterface2 val, boolean b1, boolean b2) {\n+        MyInterface2 obj = new MyValue152(rI);\n+        if (b1) {\n+            \/\/ Speculative cast to MyValue152 enables scalarization\n+            obj = (MyAbstract2)val;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return obj.val();\n+        }\n+        return -1;\n+    }\n+\n+    @Run(test = \"test155\")\n+    @Warmup(10000) \/\/ Make sure profile information is available at cast\n+    public void test155_verifier(RunInfo info) {\n+        MyClass152 unused = new MyClass152(rI);\n+        MyValue152 val = new MyValue152(rI);\n+        Asserts.assertEquals(test155(info.getTest(), val, false, false), -1);\n+        Asserts.assertEquals(test155(info.getTest(), val, true, false), -1);\n+        Asserts.assertEquals(test155(info.getTest(), null, true, false), -1);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test155(info.getTest(), val, false, true), rI);\n+        }\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    final static MyValue1 test157Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Test merging buffered inline type from field load with non-buffered inline type\n+    @Test\n+    public MyValue1 test157(long val) {\n+        return (val == 0L) ? test157Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test157\")\n+    public void test157_verifier() {\n+        Asserts.assertEquals(test157(0), test157Cache);\n+        Asserts.assertEquals(test157(rL).hash(), testValue1.hash());\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    static MyValue1 test158Cache = MyValue1.createWithFieldsInline(rI, 0);\n+\n+    \/\/ Same as test157 but with non-final field load\n+    @Test\n+    public MyValue1 test158(long val) {\n+        return (val == 0L) ? test158Cache : MyValue1.createWithFieldsInline(rI, val);\n+    }\n+\n+    @Run(test = \"test158\")\n+    public void test158_verifier() {\n+        Asserts.assertEquals(test158(0), test158Cache);\n+        Asserts.assertEquals(test158(rL).hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Verify that cast that with incompatible types is properly handled\n+    @Test\n+    public void test160(NonValueClass arg) {\n+        Object tmp = arg;\n+        MyValue1 res = (MyValue1)tmp;\n+    }\n+\n+    @Run(test = \"test160\")\n+    @Warmup(10000)\n+    public void test160_verifier(RunInfo info) {\n+        try {\n+            test160(new NonValueClass(42));\n+            throw new RuntimeException(\"No CCE thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        test160(null);\n+    }\n+\n+    abstract value static class AbstractValueClassSingleSubclass {\n+    }\n+\n+    value static class UniqueValueSubClass extends AbstractValueClassSingleSubclass {\n+        int x = 34;\n+    }\n+\n+    static AbstractValueClassSingleSubclass abstractValueClassSingleSubclass = new UniqueValueSubClass();\n+\n+    @Test\n+    public void testUniqueConcreteValueSubKlass(boolean flag) {\n+        \/\/ C2 should recognize that even though we do not know the exact layout of the underlying inline type of the\n+        \/\/ abstract field abstractValueClassSingleSubclass (i.e. cannot scalarize), we only have a unique concrete sub\n+        \/\/ class from which we know at compile time whether it can be scalarized or not. This unique sub class\n+        \/\/ optimization was missing, resulting in a missing InlineTypeNode assertion failure.\n+        doNothing(abstractValueClassSingleSubclass, flag ? 23 : 34);\n+    }\n+\n+    void doNothing(Object a, int i) {}\n+\n+    @Run(test = \"testUniqueConcreteValueSubKlass\")\n+    public void testUniqueConcreteValueSubKlass_verifier() {\n+        testUniqueConcreteValueSubKlass(true);\n+    }\n+\n+    static value class MyValueContainer {\n+        private final Object value;\n+\n+        private MyValueContainer(Object value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    static value class MyValue161 {\n+        int x = 0;\n+    }\n+\n+    \/\/ Test merging value classes with Object fields\n+    @Test\n+    public MyValueContainer test161(boolean b) {\n+        MyValueContainer res = b ? new MyValueContainer(new MyValue161()) : null;\n+        \/\/ Cast to verify that merged values are of correct type\n+        Object obj = b ? (MyValue161)res.value : null;\n+        return res;\n+    }\n+\n+    @Run(test = \"test161\")\n+    public void test161_verifier() {\n+        Asserts.assertEquals(test161(true), new MyValueContainer(new MyValue161()));\n+        Asserts.assertEquals(test161(false), null);\n+    }\n+\n+    @Test\n+    public MyValueContainer test162(boolean b) {\n+        MyValueContainer res = b ? null : new MyValueContainer(new MyValue161());\n+        \/\/ Cast to verify that merged values are of correct type\n+        Object obj = b ? null : (MyValue161)res.value;\n+        return res;\n+    }\n+\n+    @Run(test = \"test162\")\n+    public void test162_verifier() {\n+        Asserts.assertEquals(test162(true), null);\n+        Asserts.assertEquals(test162(false), new MyValueContainer(new MyValue161()));\n+    }\n+\n+    @Test\n+    public MyValueContainer test163(boolean b) {\n+        MyValueContainer res = b ? new MyValueContainer(new MyValue161()) : new MyValueContainer(null);\n+        \/\/ Cast to verify that merged values are of correct type\n+        Object obj = b ? (MyValue161)res.value : (MyValue161)res.value;\n+        return res;\n+    }\n+\n+    @Run(test = \"test163\")\n+    public void test163_verifier() {\n+        Asserts.assertEquals(test163(true), new MyValueContainer(new MyValue161()));\n+        Asserts.assertEquals(test163(false), new MyValueContainer(null));\n+    }\n+\n+    @Test\n+    public MyValueContainer test164(boolean b) {\n+        MyValueContainer res = b ? new MyValueContainer(null) : new MyValueContainer(new MyValue161());\n+        \/\/ Cast to verify that merged values are of correct type\n+        Object obj = b ? (MyValue161)res.value : (MyValue161)res.value;\n+        return res;\n+    }\n+\n+    @Run(test = \"test164\")\n+    public void test164_verifier() {\n+        Asserts.assertEquals(test164(true), new MyValueContainer(null));\n+        Asserts.assertEquals(test164(false), new MyValueContainer(new MyValue161()));\n+    }\n+\n+    @Test\n+    public MyValueContainer test165(boolean b) {\n+        MyValueContainer res = b ? new MyValueContainer(new MyValue161()) : new MyValueContainer(42);\n+        \/\/ Cast to verify that merged values are of correct type\n+        Object obj = b ? (MyValue161)res.value : (Integer)res.value;\n+        return res;\n+    }\n+\n+    @Run(test = \"test165\")\n+    public void test165_verifier() {\n+        Asserts.assertEquals(test165(true), new MyValueContainer(new MyValue161()));\n+        Asserts.assertEquals(test165(false), new MyValueContainer(42));\n+    }\n+\n+    @Test\n+    public MyValueContainer test166(boolean b) {\n+        MyValueContainer res = b ? new MyValueContainer(42) : new MyValueContainer(new MyValue161());\n+        \/\/ Cast to verify that merged values are of correct type\n+        Object obj = b ? (Integer)res.value : (MyValue161)res.value;\n+        return res;\n+    }\n+\n+    @Run(test = \"test166\")\n+    public void test166_verifier() {\n+        Asserts.assertEquals(test166(true), new MyValueContainer(42));\n+        Asserts.assertEquals(test166(false), new MyValueContainer(new MyValue161()));\n+    }\n+\n+    \/\/ Verify that monitor information in JVMState is correct at method exit\n+    @Test\n+    public synchronized Object test167() {\n+        return MyValue1.createWithFieldsInline(rI, rL); \/\/ Might trigger buffering which requires JVMState\n+    }\n+\n+    @Run(test = \"test167\")\n+    public void test167_verifier() {\n+        Asserts.assertEquals(((MyValue1)test167()).hash(), hash());\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class ValueClassWithInt {\n+        int i;\n+\n+        ValueClassWithInt(int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class ValueClassWithDouble {\n+        double d;\n+\n+        ValueClassWithDouble(double d) {\n+            this.d = d;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static abstract value class AbstractValueClassWithByte {\n+        byte b;\n+\n+        AbstractValueClassWithByte(byte b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class SubValueClassWithInt extends AbstractValueClassWithByte {\n+        int i;\n+\n+        SubValueClassWithInt(int i) {\n+            this.i = i;\n+            super((byte)(i + 1));\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class SubValueClassWithDouble extends AbstractValueClassWithByte {\n+        double d;\n+\n+        SubValueClassWithDouble(double d) {\n+            this.d = d;\n+            super((byte)(d + 1));\n+        }\n+    }\n+\n+    \/\/ TODO 8350865 We need more copies of these tests for all ValueClass array factories\n+    static final ValueClassWithInt[] VALUE_CLASS_WITH_INT_ARRAY = (ValueClassWithInt[]) ValueClass.newNullRestrictedNonAtomicArray(ValueClassWithInt.class, 2, new ValueClassWithInt(0));\n+    static final ValueClassWithDouble[] VALUE_CLASS_WITH_DOUBLE_ARRAY = (ValueClassWithDouble[]) ValueClass.newNullRestrictedNonAtomicArray(ValueClassWithDouble.class, 2, new ValueClassWithDouble(0));\n+    static final SubValueClassWithInt[] SUB_VALUE_CLASS_WITH_INT_ARRAY = (SubValueClassWithInt[]) ValueClass.newNullRestrictedNonAtomicArray(SubValueClassWithInt.class, 2, new SubValueClassWithInt(0));\n+    static final SubValueClassWithDouble[] SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY = (SubValueClassWithDouble[]) ValueClass.newNullRestrictedNonAtomicArray(SubValueClassWithDouble.class, 2, new SubValueClassWithDouble(0));\n+\n+\/\/ TODO: Can only be enabled once JDK-8343835 is fixed. Otherwise, we hit the mismatched stores assert.\n+\/\/    static {\n+\/\/        VALUE_CLASS_WITH_INT_ARRAY[0] = new ValueClassWithInt(5);\n+\/\/        VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new ValueClassWithDouble(6);\n+\/\/        SUB_VALUE_CLASS_WITH_INT_ARRAY[0] = new SubValueClassWithInt(7);\n+\/\/        SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new SubValueClassWithDouble(8);\n+\/\/    }\n+\n+    @Test\n+    static void testFlatArrayInexactObjectStore(Object o, boolean flag) {\n+        Object[] oArr;\n+        if (flag) {\n+            oArr = VALUE_CLASS_WITH_INT_ARRAY; \/\/ VALUE_CLASS_WITH_INT_ARRAY is statically known to be flat.\n+        } else {\n+            oArr = VALUE_CLASS_WITH_DOUBLE_ARRAY; \/\/ VALUE_CLASS_WITH_DOUBLE_ARRAY is statically known to be flat.\n+        }\n+        \/\/ The type of 'oArr' is inexact here because we merge two arrays. Since both arrays are flat, 'oArr' is also flat:\n+        \/\/     Type: flat:narrowoop: java\/lang\/Object:NotNull * (flat in array)[int:2]\n+        \/\/ Since the type is inexact, we do not know the exact flat array layout statically and thus need to fall back\n+        \/\/ to call \"store_unknown_inline_Type()\" at runtime where we know the flat array layout\n+        oArr[0] = o;\n+    }\n+\n+    @Test\n+    static Object testFlatArrayInexactObjectLoad(boolean flag) {\n+        Object[] oArr;\n+        if (flag) {\n+            oArr = VALUE_CLASS_WITH_INT_ARRAY; \/\/ VALUE_CLASS_WITH_INT_ARRAY is statically known to be flat.\n+        } else {\n+            oArr = VALUE_CLASS_WITH_DOUBLE_ARRAY; \/\/ VALUE_CLASS_WITH_DOUBLE_ARRAY is statically known to be flat.\n+        }\n+        \/\/ The type of 'oArr' is inexact here because we merge two arrays. Since both arrays are flat, 'oArr' is also flat:\n+        \/\/     Type: flat:narrowoop: java\/lang\/Object:NotNull * (flat in array)[int:2]\n+        \/\/ Since the type is inexact, we do not know the exact flat array layout statically and thus need to fall back\n+        \/\/ to call \"load_unknown_inline_Type()\" at runtime where we know the flat array layout\n+        return oArr[0];\n+    }\n+\n+    @Test\n+    static void testFlatArrayInexactAbstractValueClassStore(AbstractValueClassWithByte abstractValueClassWithByte,\n+                                                            boolean flag) {\n+        AbstractValueClassWithByte[] avArr;\n+        if (flag) {\n+            avArr = SUB_VALUE_CLASS_WITH_INT_ARRAY;\n+        } else {\n+            avArr = SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY;\n+        }\n+        \/\/ Same as testFlatArrayInexactObjectStore() but the inexact type is with an abstract value class:\n+        \/\/    flat:narrowoop: compiler\/valhalla\/inlinetypes\/TestLWorld$AbstractValueClassWithByte:NotNull * (flat in array)[int:2]\n+        avArr[0] = abstractValueClassWithByte;\n+    }\n+\n+    @Test\n+    static AbstractValueClassWithByte testFlatArrayInexactAbstractValueClassLoad(boolean flag) {\n+        AbstractValueClassWithByte[] avArr;\n+        if (flag) {\n+            avArr = SUB_VALUE_CLASS_WITH_INT_ARRAY;\n+        } else {\n+            avArr = SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY;\n+        }\n+        \/\/ Same as testFlatArrayInexactObjectLoad() but the inexact type is with an abstract value class:\n+        \/\/    flat:narrowoop: compiler\/valhalla\/inlinetypes\/TestLWorld$AbstractValueClassWithByte:NotNull * (flat in array)[int:2]\n+        return avArr[0];\n+    }\n+\n+    @Run(test = {\"testFlatArrayInexactObjectStore\",\n+                 \"testFlatArrayInexactObjectLoad\",\n+                 \"testFlatArrayInexactAbstractValueClassStore\",\n+                 \"testFlatArrayInexactAbstractValueClassLoad\"})\n+    static void runFlatArrayInexactLoadAndStore() {\n+        \/\/ TODO: Remove these again once JDK-8343835 is fixed and uncomment static initializer above\n+        VALUE_CLASS_WITH_INT_ARRAY[0] = new ValueClassWithInt(5);\n+        VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new ValueClassWithDouble(6);\n+        SUB_VALUE_CLASS_WITH_INT_ARRAY[0] = new SubValueClassWithInt(7);\n+        SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY[0] = new SubValueClassWithDouble(8);\n+\n+        boolean flag = true;\n+        ValueClassWithInt valueClassWithInt = new ValueClassWithInt(15);\n+        ValueClassWithDouble valueClassWithDouble = new ValueClassWithDouble(16);\n+\n+        testFlatArrayInexactObjectStore(valueClassWithInt, true);\n+        Asserts.assertEQ(valueClassWithInt, VALUE_CLASS_WITH_INT_ARRAY[0]);\n+        testFlatArrayInexactObjectStore(valueClassWithDouble, false);\n+        Asserts.assertEQ(valueClassWithDouble, VALUE_CLASS_WITH_DOUBLE_ARRAY[0]);\n+\n+        Asserts.assertEQ(valueClassWithInt, testFlatArrayInexactObjectLoad(true));\n+        Asserts.assertEQ(valueClassWithDouble, testFlatArrayInexactObjectLoad(false));\n+\n+        SubValueClassWithInt subValueClassWithInt = new SubValueClassWithInt(17);\n+        SubValueClassWithDouble subValueClassWithDouble = new SubValueClassWithDouble(18);\n+\n+        testFlatArrayInexactAbstractValueClassStore(subValueClassWithInt, true);\n+        Asserts.assertEQ(subValueClassWithInt, SUB_VALUE_CLASS_WITH_INT_ARRAY[0]);\n+        testFlatArrayInexactAbstractValueClassStore(subValueClassWithDouble, false);\n+        Asserts.assertEQ(subValueClassWithDouble, SUB_VALUE_CLASS_WITH_DOUBLE_ARRAY[0]);\n+\n+        Asserts.assertEQ(subValueClassWithInt, testFlatArrayInexactAbstractValueClassLoad(true));\n+        Asserts.assertEQ(subValueClassWithDouble, testFlatArrayInexactAbstractValueClassLoad(false));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":4685,"deletions":0,"binary":false,"changes":4685,"status":"added"},{"patch":"@@ -0,0 +1,3351 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.ALLOC_ARRAY_OF_MYVALUE_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.ALLOC_OF_MYVALUE_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.LOAD_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.LOAD_UNKNOWN_INLINE;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.STORE_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.STORE_UNKNOWN_INLINE;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rD;\n+\n+import static compiler.lib.ir_framework.IRNode.ALLOC;\n+import static compiler.lib.ir_framework.IRNode.LOOP;\n+import static compiler.lib.ir_framework.IRNode.PREDICATE_TRAP;\n+import static compiler.lib.ir_framework.IRNode.UNSTABLE_IF_TRAP;\n+\n+import jdk.internal.value.ValueClass;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test nullable value class arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestNullableArrays\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestNullableArrays {\n+\n+    public static void main(String[] args) {\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[2].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\");\n+        scenarios[5].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:-UncommonNullCast\", \"-XX:+StressArrayCopyMacroNode\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+    }\n+\n+    \/\/ Helper methods\n+\n+    protected long hash() {\n+        return hash(rI, rL);\n+    }\n+\n+    protected long hash(int x, long y) {\n+        return MyValue1.createWithFieldsInline(x, y).hash();\n+    }\n+\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    \/\/ Test nullable value class array creation and initialization\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        counts = {ALLOC_ARRAY_OF_MYVALUE_KLASS, \"= 1\"})\n+    @IR(applyIf = {\"UseArrayFlattening\", \"false\"},\n+        counts = {ALLOC_ARRAY_OF_MYVALUE_KLASS, \"= 1\"},\n+        failOn = {LOAD_OF_ANY_KLASS})\n+    public MyValue1[] test1(int len) {\n+        MyValue1[] va = new MyValue1[len];\n+        if (len > 0) {\n+            va[0] = null;\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        int len = Math.abs(rI % 10);\n+        MyValue1[] va = test1(len);\n+        if (len > 0) {\n+            Asserts.assertEQ(va[0], null);\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash());\n+        }\n+    }\n+\n+    \/\/ Test creation of a value class array and element access\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public long test2() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = MyValue1.createWithFieldsInline(rI, rL);\n+        return va[0].hash();\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        long result = test2();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Test receiving a value class array from the interpreter,\n+    \/\/ updating its elements in a loop and computing a hash.\n+    @Test\n+    @IR(failOn = {ALLOC_ARRAY_OF_MYVALUE_KLASS})\n+    public long test3(MyValue1[] va) {\n+        long result = 0;\n+        for (int i = 0; i < 10; ++i) {\n+            if (va[i] != null) {\n+                result += va[i].hash();\n+            }\n+            va[i] = MyValue1.createWithFieldsInline(rI + 1, rL + 1);\n+        }\n+        va[0] = null;\n+        return result;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        MyValue1[] va = new MyValue1[10];\n+        long expected = 0;\n+        for (int i = 1; i < 10; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);\n+            expected += va[i].hash();\n+        }\n+        long result = test3(va);\n+        Asserts.assertEQ(expected, result);\n+        Asserts.assertEQ(va[0], null);\n+        for (int i = 1; i < 10; ++i) {\n+            if (va[i].hash() != hash(rI + 1, rL + 1)) {\n+                Asserts.assertEQ(va[i].hash(), hash(rI + 1, rL + 1));\n+            }\n+        }\n+    }\n+\n+    \/\/ Test returning a value class array received from the interpreter\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, LOOP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public MyValue1[] test4(MyValue1[] va) {\n+        return va;\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        MyValue1[] va = new MyValue1[10];\n+        for (int i = 0; i < 10; ++i) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL + i);\n+        }\n+        va = test4(va);\n+        for (int i = 0; i < 10; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));\n+        }\n+    }\n+\n+    \/\/ Merge value class arrays created from two branches\n+    @Test\n+    public MyValue1[] test5(boolean b) {\n+        MyValue1[] va;\n+        if (b) {\n+            va = new MyValue1[5];\n+            for (int i = 0; i < 5; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+            }\n+            va[4] = null;\n+        } else {\n+            va = new MyValue1[10];\n+            for (int i = 0; i < 10; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);\n+            }\n+            va[9] = null;\n+        }\n+        long sum = va[0].hashInterpreted();\n+        if (b) {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI, sum);\n+        } else {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue1[] va = test5(true);\n+        Asserts.assertEQ(va.length, 5);\n+        Asserts.assertEQ(va[0].hash(), hash(rI, hash()));\n+        for (int i = 1; i < 4; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash());\n+        }\n+        Asserts.assertEQ(va[4], null);\n+        va = test5(false);\n+        Asserts.assertEQ(va.length, 10);\n+        Asserts.assertEQ(va[0].hash(), hash(rI + 1, hash(rI, rL) + 1));\n+        for (int i = 1; i < 9; ++i) {\n+            Asserts.assertEQ(va[i].hash(), hash(rI + i, rL + i));\n+        }\n+        Asserts.assertEQ(va[9], null);\n+    }\n+\n+    \/\/ Test creation of value class array with single element\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public MyValue1 test6() {\n+        MyValue1[] va = new MyValue1[1];\n+        return va[0];\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1[] va = new MyValue1[1];\n+        MyValue1 v = test6();\n+        Asserts.assertEQ(v, null);\n+    }\n+\n+    \/\/ Test initialization of value class arrays\n+    @Test\n+    @IR(failOn = {LOAD_OF_ANY_KLASS})\n+    public MyValue1[] test7(int len) {\n+        return new MyValue1[len];\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        int len = Math.abs(rI % 10);\n+        MyValue1[] va = test7(len);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+            va[i] = null;\n+        }\n+    }\n+\n+    \/\/ Test creation of value class array with zero length\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, LOOP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public MyValue1[] test8() {\n+        return new MyValue1[0];\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        MyValue1[] va = test8();\n+        Asserts.assertEQ(va.length, 0);\n+    }\n+\n+    static MyValue1[] test9_va;\n+\n+    \/\/ Test that value class array loaded from field has correct type\n+    @Test\n+    @IR(failOn = LOOP)\n+    public long test9() {\n+        return test9_va[0].hash();\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        test9_va = new MyValue1[1];\n+        test9_va[0] = testValue1;\n+        long result = test9();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Multi-dimensional arrays\n+    @Test\n+    public MyValue1[][][] test10(int len1, int len2, int len3) {\n+        MyValue1[][][] arr = new MyValue1[len1][len2][len3];\n+        for (int i = 0; i < len1; i++) {\n+            for (int j = 0; j < len2; j++) {\n+                for (int k = 0; k < len3; k++) {\n+                    arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i , rL + j + k);\n+                    if (k == 0) {\n+                        arr[i][j][k] = null;\n+                    }\n+                }\n+            }\n+        }\n+        return arr;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        MyValue1[][][] arr = test10(2, 3, 4);\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                for (int k = 0; k < 4; k++) {\n+                    if (k == 0) {\n+                        Asserts.assertEQ(arr[i][j][k], null);\n+                    } else {\n+                        Asserts.assertEQ(arr[i][j][k].hash(), MyValue1.createWithFieldsDontInline(rI + i , rL + j + k).hash());\n+                    }\n+                    arr[i][j][k] = null;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test11(MyValue1[][][] arr, long[] res) {\n+        int l = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            for (int j = 0; j < arr[i].length; j++) {\n+                for (int k = 0; k < arr[i][j].length; k++) {\n+                    if (arr[i][j][k] != null) {\n+                        res[l] = arr[i][j][k].hash();\n+                    }\n+                    arr[i][j][k] = null;\n+                    l++;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        MyValue1[][][] arr = new MyValue1[2][3][4];\n+        long[] res = new long[2*3*4];\n+        long[] verif = new long[2*3*4];\n+        int l = 0;\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 3; j++) {\n+                for (int k = 0; k < 4; k++) {\n+                    if (j != 2) {\n+                        arr[i][j][k] = MyValue1.createWithFieldsDontInline(rI + i, rL + j + k);\n+                        verif[l] = arr[i][j][k].hash();\n+                    }\n+                    l++;\n+                }\n+            }\n+        }\n+        test11(arr, res);\n+        for (int i = 0; i < verif.length; i++) {\n+            Asserts.assertEQ(res[i], verif[i]);\n+        }\n+    }\n+\n+    \/\/ Array load out of bounds (upper bound) at compile time\n+    @Test\n+    public int test12() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+        }\n+\n+        try {\n+            return va[arraySize + 1].x;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        Asserts.assertEQ(test12(), rI);\n+    }\n+\n+    \/\/ Array load  out of bounds (lower bound) at compile time\n+    @Test\n+    public int test13() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI + i, rL);\n+        }\n+\n+        try {\n+            return va[-arraySize].x;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        Asserts.assertEQ(test13(), rI);\n+    }\n+\n+    \/\/ Array load out of bound not known to compiler (both lower and upper bound)\n+    @Test\n+    public int test14(MyValue1[] va, int index)  {\n+        return va[index].x;\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+\n+        int result;\n+        for (int i = -20; i < 20; i++) {\n+            try {\n+                result = test14(va, i);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                result = rI;\n+            }\n+            Asserts.assertEQ(result, rI);\n+        }\n+    }\n+\n+    \/\/ Array store out of bounds (upper bound) at compile time\n+    @Test\n+    public int test15() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        try {\n+            for (int i = 0; i <= arraySize; i++) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+            }\n+            return rI - 1;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        Asserts.assertEQ(test15(), rI);\n+    }\n+\n+    \/\/ Array store out of bounds (lower bound) at compile time\n+    @Test\n+    public int test16() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        try {\n+            for (int i = -1; i <= arraySize; i++) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+            }\n+            return rI - 1;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return rI;\n+        }\n+    }\n+\n+    @Run(test = \"test16\")\n+    public void test16_verifier() {\n+        Asserts.assertEQ(test16(), rI);\n+    }\n+\n+    \/\/ Array store out of bound not known to compiler (both lower and upper bound)\n+    @Test\n+    public int test17(MyValue1[] va, int index, MyValue1 vt)  {\n+        va[index] = vt;\n+        return va[index].x;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        int arraySize = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[arraySize];\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+        }\n+\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI + 1, rL);\n+        int result;\n+        for (int i = -20; i < 20; i++) {\n+            try {\n+                result = test17(va, i, vt);\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                result = rI + 1;\n+            }\n+            Asserts.assertEQ(result, rI + 1);\n+        }\n+\n+        for (int i = 0; i < arraySize; i++) {\n+            Asserts.assertEQ(va[i].x, rI + 1);\n+        }\n+    }\n+\n+    \/\/ clone() as stub call\n+    @Test\n+    public MyValue1[] test18(MyValue1[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test18\")\n+    public void test18_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va1 = new MyValue1[len];\n+        MyValue1[]  va2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        for (int i = 1; i < len; ++i) {\n+            va1[i] = testValue1;\n+            va2[i] = testValue1;\n+        }\n+        MyValue1[] result1 = test18(va1);\n+        if (len > 0) {\n+            Asserts.assertEQ(result1[0], null);\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(result1[i].hash(), va1[i].hash());\n+        }\n+        \/\/ make sure we do deopt: GraphKit::new_array assumes an\n+        \/\/ array of references\n+        for (int j = 0; j < 10; j++) {\n+            MyValue1[] result2 = test18(va2);\n+\n+            for (int i = 0; i < len; ++i) {\n+                Asserts.assertEQ(result2[i].hash(), va2[i].hash());\n+            }\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            MyValue1[] result2 = test18(va2);\n+            for (int i = 0; i < len; ++i) {\n+                Asserts.assertEQ(result2[i].hash(), va2[i].hash());\n+            }\n+        }\n+    }\n+\n+    \/\/ clone() as series of loads\/stores\n+    static MyValue1[] test19_orig = null;\n+\n+    @Test\n+    public MyValue1[] test19() {\n+        MyValue1[] va = new MyValue1[8];\n+        for (int i = 1; i < va.length; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        test19_orig = va;\n+\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test19\")\n+    public void test19_verifier() {\n+        MyValue1[] result = test19();\n+        Asserts.assertEQ(result[0], null);\n+        for (int i = 1; i < test19_orig.length; ++i) {\n+            Asserts.assertEQ(result[i].hash(), test19_orig[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of value class array with oop fields\n+    @Test\n+    public void test20(MyValue1[] src, MyValue1[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test20\")\n+    public void test20_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[] src2 = new MyValue1[len];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst1 = new MyValue1[len];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst3 = new MyValue1[len];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        if (len > 0) {\n+            src2[0] = testValue1;\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test20(src1, dst1);\n+        test20(src2, dst2);\n+        test20(src3, dst3);\n+        test20(src4, dst4);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+            Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+            Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of value class array with no oop field\n+    @Test\n+    public void test21(MyValue2[] src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src1 = new MyValue2[len];\n+        MyValue2[] src2 = new MyValue2[len];\n+        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst1 = new MyValue2[len];\n+        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        MyValue2[] dst3 = new MyValue2[len];\n+        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, len, MyValue2.DEFAULT);\n+        if (len > 0) {\n+            src2[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test21(src1, dst1);\n+        test21(src2, dst2);\n+        test21(src3, dst3);\n+        test21(src4, dst4);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+            Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+            Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of value class array with oop field and tightly\n+    \/\/ coupled allocation as dest\n+    @Test\n+    public MyValue1[] test22(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[src.length];\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[]  src2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+        }\n+        MyValue1[] dst1 = test22(src1);\n+        MyValue1[] dst2 = test22(src2);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), MyValue1.createDefaultInline().hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of value class array with oop fields and tightly\n+    \/\/ coupled allocation as dest\n+    @Test\n+    public MyValue1[] test23(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[src.length + 10];\n+        System.arraycopy(src, 0, dst, 5, src.length);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[] src2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        for (int i = 0; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+        }\n+        MyValue1[] dst1 = test23(src1);\n+        MyValue1[] dst2 = test23(src2);\n+        for (int i = 0; i < 5; ++i) {\n+            Asserts.assertEQ(dst1[i], null);\n+            Asserts.assertEQ(dst2[i], null);\n+        }\n+        for (int i = 5; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+        }\n+    }\n+\n+    \/\/ arraycopy() of value class array passed as Object\n+    @Test\n+    public void test24(MyValue1[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src1 = new MyValue1[len];\n+        MyValue1[] src2 = new MyValue1[len];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst1 = new MyValue1[len];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        MyValue1[] dst3 = new MyValue1[len];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        if (len > 0) {\n+            src2[0] = testValue1;\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test24(src1, dst1);\n+        test24(src2, dst2);\n+        test24(src3, dst3);\n+        test24(src4, dst4);\n+        if (len > 0) {\n+            Asserts.assertEQ(dst1[0], null);\n+            Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+            Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+            Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with no oop field\n+    @Test\n+    public void test25(MyValue2[] src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier() {\n+        MyValue2[] src1 = new MyValue2[8];\n+        MyValue2[] src2 = new MyValue2[8];\n+        MyValue2[]  src3 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[]  src4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] dst1 = new MyValue2[8];\n+        MyValue2[]  dst2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        MyValue2[] dst3 = new MyValue2[8];\n+        MyValue2[]  dst4 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 8, MyValue2.DEFAULT);\n+        src2[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        for (int i = 1; i < 8; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src3[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src4[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test25(src1, dst1);\n+        test25(src2, dst2);\n+        test25(src3, dst3);\n+        test25(src4, dst4);\n+        Asserts.assertEQ(dst1[0], null);\n+        Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+        Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+        Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        for (int i = 1; i < 8; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with oop fields\n+    @Test\n+    public void test26(MyValue1[] src, MyValue1[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        MyValue1[] src1 = new MyValue1[8];\n+        MyValue1[] src2 = new MyValue1[8];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst1 = new MyValue1[8];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst3 = new MyValue1[8];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        src2[0] = testValue1;\n+        for (int i = 1; i < 8; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test26(src1, dst1);\n+        test26(src2, dst2);\n+        test26(src3, dst3);\n+        test26(src4, dst4);\n+        Asserts.assertEQ(dst1[0], null);\n+        Asserts.assertEQ(dst2[0].hash(), src2[0].hash());\n+        Asserts.assertEQ(dst3[0].hash(), src3[0].hash());\n+        Asserts.assertEQ(dst4[0].hash(), src4[0].hash());\n+        for (int i = 1; i < 8; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ short arraycopy() with oop fields and offsets\n+    @Test\n+    public void test27(MyValue1[] src, MyValue1[] dst) {\n+        System.arraycopy(src, 1, dst, 2, 6);\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        MyValue1[] src1 = new MyValue1[8];\n+        MyValue1[] src2 = new MyValue1[8];\n+        MyValue1[]  src3 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[]  src4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst1 = new MyValue1[8];\n+        MyValue1[]  dst2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        MyValue1[] dst3 = new MyValue1[8];\n+        MyValue1[]  dst4 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        for (int i = 1; i < 8; ++i) {\n+            src1[i] = testValue1;\n+            src2[i] = testValue1;\n+            src3[i] = testValue1;\n+            src4[i] = testValue1;\n+        }\n+        test27(src1, dst1);\n+        test27(src2, dst2);\n+        test27(src3, dst3);\n+        test27(src4, dst4);\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(dst1[i], null);\n+            Asserts.assertEQ(dst2[i].hash(), MyValue1.createDefaultInline().hash());\n+            Asserts.assertEQ(dst3[i], null);\n+            Asserts.assertEQ(dst4[i].hash(), MyValue1.createDefaultInline().hash());\n+        }\n+        for (int i = 2; i < 8; ++i) {\n+            Asserts.assertEQ(src1[i].hash(), dst1[i].hash());\n+            Asserts.assertEQ(src2[i].hash(), dst2[i].hash());\n+            Asserts.assertEQ(src3[i].hash(), dst3[i].hash());\n+            Asserts.assertEQ(src4[i].hash(), dst4[i].hash());\n+        }\n+    }\n+\n+    \/\/ non escaping allocations\n+    \/\/ TODO 8252027: Make sure this is optimized with ZGC\n+    @Test\n+    @IR(applyIf = {\"UseZGC\", \"false\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public MyValue2 test28() {\n+        MyValue2[] src = new MyValue2[10];\n+        src[0] = null;\n+        MyValue2[] dst = (MyValue2[])src.clone();\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue2 v = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 result = test28();\n+        Asserts.assertEQ(result, null);\n+    }\n+\n+    \/\/ non escaping allocations\n+    \/\/ TODO 8227588: shouldn't this have the same IR matching rules as test6?\n+    @Test\n+    @IR(failOn = {ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public MyValue2 test29(MyValue2[] src) {\n+        MyValue2[] dst = new MyValue2[10];\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier(RunInfo info) {\n+        MyValue2[] src1 = new MyValue2[10];\n+        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n+        for (int i = 0; i < 10; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        MyValue2 v = test29(src1);\n+        Asserts.assertEQ(src1[0].hash(), v.hash());\n+        if (!info.isWarmUp()) {\n+            v = test29(src2);\n+            Asserts.assertEQ(src2[0].hash(), v.hash());\n+        }\n+    }\n+\n+    \/\/ non escaping allocation with uncommon trap that needs\n+    \/\/ eliminated value class array element as debug info\n+    @Test\n+    public MyValue2 test30(MyValue2[] src, boolean flag) {\n+        MyValue2[] dst = new MyValue2[10];\n+        System.arraycopy(src, 0, dst, 0, 10);\n+        if (flag) { }\n+        return dst[0];\n+    }\n+\n+    @Run(test = \"test30\")\n+    @Warmup(10000)\n+    public void test30_verifier(RunInfo info) {\n+        MyValue2[] src1 = new MyValue2[10];\n+        MyValue2[] src2 = (MyValue2[])ValueClass.newNullRestrictedNonAtomicArray(MyValue2.class, 10, MyValue2.DEFAULT);\n+        for (int i = 0; i < 10; ++i) {\n+            src1[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+            src2[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        MyValue2 v = test30(src1, !info.isWarmUp());\n+        Asserts.assertEQ(src1[0].hash(), v.hash());\n+        if (!info.isWarmUp()) {\n+            v = test30(src2, true);\n+            Asserts.assertEQ(src2[0].hash(), v.hash());\n+        }\n+    }\n+\n+    \/\/ non escaping allocation with memory phi\n+    @Test\n+    \/\/ TODO 8227588\n+    \/\/ @Test(failOn = ALLOC_OF_MYVALUE_KLASS + ALLOC_ARRAY_OF_MYVALUE_KLASS + LOOP + LOAD_OF_ANY_KLASS + STORE_OF_ANY_KLASS + UNSTABLE_IF_TRAP, PREDICATE_TRAP)\n+    public long test31(boolean b, boolean deopt, Method m) {\n+        MyValue2[] src = new MyValue2[1];\n+        if (b) {\n+            src[0] = MyValue2.createWithFieldsInline(rI, rD);\n+        } else {\n+            src[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return src[0].hash();\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier(RunInfo info) {\n+        MyValue2 v1 = MyValue2.createWithFieldsInline(rI, rD);\n+        long result1 = test31(true, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result1, v1.hash());\n+        MyValue2 v2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        long result2 = test31(false, !info.isWarmUp(), info.getTest());\n+        Asserts.assertEQ(result2, v2.hash());\n+    }\n+\n+    \/\/ Tests with Object arrays and clone\/arraycopy\n+    \/\/ clone() as stub call\n+    @Test\n+    public Object[] test32(Object[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va1 = new MyValue1[len];\n+        MyValue1[] va2 = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, len, MyValue1.DEFAULT);\n+        for (int i = 1; i < len; ++i) {\n+            va1[i] = testValue1;\n+            va2[i] = testValue1;\n+        }\n+        MyValue1[] result1 = (MyValue1[])test32(va1);\n+        MyValue1[] result2 = (MyValue1[])test32(va2);\n+        if (len > 0) {\n+            Asserts.assertEQ(result1[0], null);\n+            Asserts.assertEQ(result2[0].hash(), MyValue1.createDefaultInline().hash());\n+        }\n+        for (int i = 1; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)result1[i]).hash(), ((MyValue1)va1[i]).hash());\n+            Asserts.assertEQ(((MyValue1)result2[i]).hash(), ((MyValue1)va2[i]).hash());\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test33(Object[] va) {\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Object[len];\n+        for (int i = 0; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test33(va);\n+        for (int i = 0; i < len; ++i) {\n+            Asserts.assertEQ(((MyValue1)result[i]).hash(), ((MyValue1)va[i]).hash());\n+        }\n+    }\n+\n+    \/\/ clone() as series of loads\/stores\n+    static Object[] test34_orig = null;\n+\n+    @ForceInline\n+    public Object[] test34_helper(boolean flag) {\n+        Object[] va = null;\n+        if (flag) {\n+            va = new MyValue1[8];\n+            for (int i = 0; i < va.length; ++i) {\n+                va[i] = MyValue1.createWithFieldsDontInline(rI, rL);\n+            }\n+        } else {\n+            va = new Object[8];\n+        }\n+        return va;\n+    }\n+\n+    @Test\n+    public Object[] test34(boolean flag) {\n+        Object[] va = test34_helper(flag);\n+        test34_orig = va;\n+        return va.clone();\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier(RunInfo info) {\n+        test34(false);\n+        for (int i = 0; i < 10; i++) { \/\/ make sure we do deopt\n+            Object[] result = test34(true);\n+            verify(test34_orig, result);\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            Object[] result = test34(true);\n+            verify(test34_orig, result);\n+        }\n+    }\n+\n+    static void verify(Object[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(((MyInterface)src[i]).hash(), ((MyInterface)dst[i]).hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue1[] src, MyValue1[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue1[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue2[] src, MyValue2[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static void verify(MyValue2[] src, Object[] dst) {\n+        for (int i = 0; i < src.length; ++i) {\n+            if (src[i] != null) {\n+                Asserts.assertEQ(src[i].hash(), ((MyInterface)dst[i]).hash());\n+            } else {\n+                Asserts.assertEQ(dst[i], null);\n+            }\n+        }\n+    }\n+\n+    static boolean compile_and_run_again_if_deoptimized(RunInfo info) {\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            if (TestFramework.isCompiled(m)) {\n+                TestFramework.compile(m, CompLevel.C2);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ arraycopy() of value class array of unknown size\n+    @Test\n+    public void test35(Object src, Object dst, int len) {\n+        System.arraycopy(src, 0, dst, 0, len);\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] src = new MyValue1[len];\n+        MyValue1[] dst = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = testValue1;\n+        }\n+        test35(src, dst, src.length);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test35(src, dst, src.length);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test36(Object src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test36\")\n+    public void test36_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test36(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test36(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test37(MyValue2[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test37(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test37(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test38(Object src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test38\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test38_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test38(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test38(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test39(MyValue2[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test39(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test39(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test40(Object[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test40\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test40_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test40(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test40(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test41(Object src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, dst.length);\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue2[] src = new MyValue2[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test41(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test41(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test42(Object[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        Object[] src = new Object[len];\n+        Object[] dst = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test42(src, dst);\n+        verify(src, dst);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    \/\/ short arraycopy()'s\n+    @Test\n+    public void test43(Object src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        MyValue1[] src = new MyValue1[8];\n+        MyValue1[] dst = new MyValue1[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = testValue1;\n+        }\n+        test43(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test43(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test44(Object src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test44(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test44(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test45(MyValue2[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test45(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test45(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test46(Object[] src, MyValue2[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test46\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test46_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test46(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test46(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test47(MyValue2[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test47(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test47(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test48(Object[] src, Object dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test48\")\n+    @Warmup(1) \/\/ Avoid early compilation\n+    public void test48_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        MyValue2[] dst = new MyValue2[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test48(src, dst);\n+        verify(dst, src);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertDeoptimizedByC2(m);\n+            TestFramework.compile(m, CompLevel.C2);\n+            test48(src, dst);\n+            verify(dst, src);\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public void test49(Object src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier(RunInfo info) {\n+        MyValue2[] src = new MyValue2[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test49(src, dst);\n+        verify(src, dst);\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            test49(src, dst);\n+            verify(src, dst);\n+        }\n+    }\n+\n+    @Test\n+    public void test50(Object[] src, Object[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 8);\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier(RunInfo info) {\n+        Object[] src = new Object[8];\n+        Object[] dst = new Object[8];\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = MyValue2.createWithFieldsInline(rI+i, rD+i);\n+        }\n+        test50(src, dst);\n+        verify(src, dst);\n+        if (!info.isWarmUp()) {\n+            Method m = info.getTest();\n+            TestFramework.assertCompiled(m);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1[] test51(MyValue1[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1[].class);\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        MyValue1[] result = test51(va);\n+        verify(va, result);\n+    }\n+\n+    static final MyValue1[] test52_va = new MyValue1[8];\n+\n+    @Test\n+    public MyValue1[] test52() {\n+        return Arrays.copyOf(test52_va, 8, MyValue1[].class);\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        for (int i = 1; i < 8; ++i) {\n+            test52_va[i] = testValue1;\n+        }\n+        MyValue1[] result = test52();\n+        verify(test52_va, result);\n+    }\n+\n+    @Test\n+    public MyValue1[] test53(Object[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1[].class);\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        MyValue1[] result = test53(va);\n+        verify(result, va);\n+    }\n+\n+    @Test\n+    public Object[] test54(MyValue1[] va) {\n+        return Arrays.copyOf(va, va.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test54(va);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public Object[] test55(Object[] va) {\n+        return Arrays.copyOf(va, va.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test55(va);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public MyValue1[] test56(Object[] va) {\n+        return Arrays.copyOf(va, va.length, MyValue1[].class);\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new Object[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        MyValue1[] result = test56(va);\n+        verify(result, va);\n+    }\n+\n+   @Test\n+    public Object[] test57(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length, klass);\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        Object[] result = test57(va, MyValue1[].class);\n+        verify(va, result);\n+    }\n+\n+    @Test\n+    public Object[] test58(MyValue1[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length, klass);\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier(RunInfo info) {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+        }\n+        for (int i = 1; i < 10; i++) {\n+            Object[] result = test58(va, MyValue1[].class);\n+            verify(va, result);\n+        }\n+        if (compile_and_run_again_if_deoptimized(info)) {\n+            Object[] result = test58(va, MyValue1[].class);\n+            verify(va, result);\n+        }\n+    }\n+\n+    @Test\n+    public Object[] test59(MyValue1[] va) {\n+        return Arrays.copyOf(va, va.length+1, MyValue1[].class);\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = va[i];\n+        }\n+        Object[] result = test59(va);\n+        verify(verif, result);\n+    }\n+\n+    @Test\n+    public Object[] test60(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length+1, klass);\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = (MyValue1)va[i];\n+        }\n+        Object[] result = test60(va, MyValue1[].class);\n+        verify(verif, result);\n+    }\n+\n+    @Test\n+    public Object[] test61(Object[] va, Class klass) {\n+        return Arrays.copyOf(va, va.length+1, klass);\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        Object[] va = new NonValueClass[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = new NonValueClass(rI);\n+        }\n+        Object[] result = test61(va, NonValueClass[].class);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(va[i], result[i]);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test62_helper(int i, MyValue1[] va, NonValueClass[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = oa;\n+        } else {\n+            arr = va;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test62(MyValue1[] va, NonValueClass[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test62_helper(i, va, oa);\n+\n+        return Arrays.copyOf(arr, arr.length+1, arr.getClass());\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        NonValueClass[] oa = new NonValueClass[len];\n+        for (int i = 1; i < len; ++i) {\n+            oa[i] = new NonValueClass(rI);\n+        }\n+        test62_helper(42, va, oa);\n+        Object[] result = test62(va, oa);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(oa[i], result[i]);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test63_helper(int i, MyValue1[] va, NonValueClass[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = va;\n+        } else {\n+            arr = oa;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test63(MyValue1[] va, NonValueClass[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test63_helper(i, va, oa);\n+\n+        return Arrays.copyOf(arr, arr.length+1, arr.getClass());\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len+1];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = va[i];\n+        }\n+        NonValueClass[] oa = new NonValueClass[len];\n+        test63_helper(42, va, oa);\n+        Object[] result = test63(va, oa);\n+        verify(verif, result);\n+    }\n+\n+    \/\/ Test initialization of value class arrays: small array\n+    @Test\n+    public MyValue1[] test64() {\n+        return new MyValue1[8];\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1[] va = test64();\n+        for (int i = 0; i < 8; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Test initialization of value class arrays: large array\n+    @Test\n+    public MyValue1[] test65() {\n+        return new MyValue1[32];\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        MyValue1[] va = test65();\n+        for (int i = 0; i < 32; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Check init store elimination\n+    @Test\n+    @IR(counts = {ALLOC_ARRAY_OF_MYVALUE_KLASS, \"= 1\"})\n+    public MyValue1[] test66(MyValue1 vt) {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = vt;\n+        return va;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1[] va = test66(vt);\n+        Asserts.assertEQ(va[0].hashPrimitive(), vt.hashPrimitive());\n+    }\n+\n+    \/\/ Zeroing elimination and arraycopy\n+    @Test\n+    public MyValue1[] test67(MyValue1[] src) {\n+        MyValue1[] dst = new MyValue1[16];\n+        System.arraycopy(src, 0, dst, 0, 13);\n+        return dst;\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier() {\n+        MyValue1[] va = new MyValue1[16];\n+        MyValue1[] var = test67(va);\n+        for (int i = 0; i < 16; ++i) {\n+            Asserts.assertEQ(var[i], null);\n+        }\n+    }\n+\n+    \/\/ A store with a zero value can be eliminated\n+    @Test\n+    public MyValue1[] test68() {\n+        MyValue1[] va = new MyValue1[2];\n+        va[0] = va[1];\n+        return va;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier() {\n+        MyValue1[] va = test68();\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(va[i], null);\n+        }\n+    }\n+\n+    \/\/ Requires individual stores to init array\n+    @Test\n+    public MyValue1[] test69(MyValue1 vt) {\n+        MyValue1[] va = new MyValue1[4];\n+        va[0] = vt;\n+        va[3] = vt;\n+        return va;\n+    }\n+\n+    @Run(test = \"test69\")\n+    public void test69_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1[] va = new MyValue1[4];\n+        va[0] = vt;\n+        va[3] = vt;\n+        MyValue1[] var = test69(vt);\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(va[i], var[i]);\n+        }\n+    }\n+\n+    \/\/ Same as test68 but store is further away from allocation\n+    @Test\n+    public MyValue1[] test70(MyValue1[] other) {\n+        other[1] = other[0];\n+        MyValue1[] va = new MyValue1[2];\n+        other[0] = va[1];\n+        va[0] = va[1];\n+        return va;\n+    }\n+\n+    @Run(test = \"test70\")\n+    public void test70_verifier() {\n+        MyValue1[] va = new MyValue1[2];\n+        MyValue1[] var = test70(va);\n+        for (int i = 0; i < 2; ++i) {\n+            Asserts.assertEQ(va[i], var[i]);\n+        }\n+    }\n+\n+    \/\/ EA needs to consider oop fields in flattened arrays\n+    @Test\n+    public void test71() {\n+        int len = 10;\n+        MyValue2[] src = new MyValue2[len];\n+        MyValue2[] dst = new MyValue2[len];\n+        for (int i = 1; i < len; ++i) {\n+            src[i] = MyValue2.createWithFieldsDontInline(rI+i, rD+i);\n+        }\n+        System.arraycopy(src, 0, dst, 0, src.length);\n+        for (int i = 0; i < len; ++i) {\n+            if (src[i] == null) {\n+                Asserts.assertEQ(dst[i], null);\n+            } else {\n+                Asserts.assertEQ(src[i].hash(), dst[i].hash());\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier() {\n+        test71();\n+    }\n+\n+    \/\/ Test EA with leaf call to 'store_unknown_value'\n+    @Test\n+    public void test72(Object[] o, boolean b, Object element) {\n+        Object[] arr1 = new Object[10];\n+        Object[] arr2 = new Object[10];\n+        if (b) {\n+            arr1 = o;\n+        }\n+        arr1[0] = element;\n+        arr2[0] = element;\n+    }\n+\n+    @Run(test = \"test72\")\n+    public void test72_verifier() {\n+        Object[] arr = new Object[1];\n+        Object elem = new Object();\n+        test72(arr, true, elem);\n+        test72(arr, false, elem);\n+    }\n+\n+    @Test\n+    public void test73(Object[] oa, MyValue1 v, Object o) {\n+        \/\/ TestLWorld.test38 use a C1 Phi node for the array. This test\n+        \/\/ adds the case where the stored value is a C1 Phi node.\n+        Object o2 = (o == null) ? v : o;\n+        oa[0] = v;  \/\/ The stored value is known to be flattenable\n+        oa[1] = o;  \/\/ The stored value may be flattenable\n+        oa[2] = o2; \/\/ The stored value may be flattenable (a C1 Phi node)\n+        oa[0] = oa; \/\/ The stored value is known to be not flattenable (an Object[])\n+    }\n+\n+    @Run(test = \"test73\")\n+    public void test73_verifier() {\n+        MyValue1 v0 = MyValue1.createWithFieldsDontInline(rI, rL);\n+        MyValue1 v1 = MyValue1.createWithFieldsDontInline(rI+1, rL+1);\n+        MyValue1[] arr = new MyValue1[3];\n+        try {\n+            test73(arr, v0, v1);\n+            throw new RuntimeException(\"ArrayStoreException expected\");\n+        } catch (ArrayStoreException t) {\n+            \/\/ expected\n+        }\n+        Asserts.assertEQ(arr[0].hash(), v0.hash());\n+        Asserts.assertEQ(arr[1].hash(), v1.hash());\n+        Asserts.assertEQ(arr[2].hash(), v1.hash());\n+    }\n+\n+    \/\/ Some more array clone tests\n+    @ForceInline\n+    public Object[] test74_helper(int i, MyValue1[] va, NonValueClass[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = oa;\n+        } else {\n+            arr = va;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test74(MyValue1[] va, NonValueClass[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test74_helper(i, va, oa);\n+        return arr.clone();\n+    }\n+\n+    @Run(test = \"test74\")\n+    public void test74_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        NonValueClass[] oa = new NonValueClass[len];\n+        for (int i = 1; i < len; ++i) {\n+            oa[i] = new NonValueClass(rI);\n+        }\n+        test74_helper(42, va, oa);\n+        Object[] result = test74(va, oa);\n+\n+        for (int i = 0; i < va.length; ++i) {\n+            Asserts.assertEQ(oa[i], result[i]);\n+            \/\/ Check that array has correct properties (null-ok)\n+            result[i] = null;\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object[] test75_helper(int i, MyValue1[] va, NonValueClass[] oa) {\n+        Object[] arr = null;\n+        if (i == 10) {\n+            arr = va;\n+        } else {\n+            arr = oa;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    public Object[] test75(MyValue1[] va, NonValueClass[] oa) {\n+        int i = 0;\n+        for (; i < 10; i++);\n+\n+        Object[] arr = test75_helper(i, va, oa);\n+        return arr.clone();\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        int len = Math.abs(rI) % 10;\n+        MyValue1[] va = new MyValue1[len];\n+        MyValue1[] verif = new MyValue1[len];\n+        for (int i = 1; i < len; ++i) {\n+            va[i] = testValue1;\n+            verif[i] = va[i];\n+        }\n+        NonValueClass[] oa = new NonValueClass[len];\n+        test75_helper(42, va, oa);\n+        Object[] result = test75(va, oa);\n+        verify(verif, result);\n+        if (len > 0) {\n+            \/\/ Check that array has correct properties (null-ok)\n+            result[0] = null;\n+        }\n+    }\n+\n+    \/\/ Test mixing nullable and non-nullable arrays\n+    @Test\n+    public Object[] test76(MyValue1[] vva, MyValue1[] vba, MyValue1 vt, Object[] out, int n) {\n+        Object[] result = null;\n+        if (n == 0) {\n+            result = vva;\n+        } else if (n == 1) {\n+            result = vba;\n+        } else if (n == 2) {\n+            result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        } else if (n == 3) {\n+            result = new MyValue1[42];\n+        }\n+        result[0] = vt;\n+        out[0] = result[1];\n+        return result;\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier() {\n+        MyValue1 vt = testValue1;\n+        Object[] out = new Object[1];\n+        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        vva_r[0] = vt;\n+        MyValue1[] vba = new MyValue1[42];\n+        MyValue1[] vba_r = new MyValue1[42];\n+        vba_r[0] = vt;\n+        Object[] result = test76(vva, vba, vt, out, 0);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test76(vva, vba, vt, out, 1);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+        result = test76(vva, vba, vt, out, 2);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test76(vva, vba, vt, out, 3);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+    }\n+\n+    @Test\n+    public Object[] test77(boolean b) {\n+        Object[] va;\n+        if (b) {\n+            va = new MyValue1[5];\n+            for (int i = 0; i < 5; ++i) {\n+                va[i] = testValue1;\n+            }\n+        } else {\n+            va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 10, MyValue1.DEFAULT);\n+            for (int i = 0; i < 10; ++i) {\n+                va[i] = MyValue1.createWithFieldsInline(rI + i, rL + i);\n+            }\n+        }\n+        long sum = ((MyValue1)va[0]).hashInterpreted();\n+        if (b) {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI, sum);\n+        } else {\n+            va[0] = MyValue1.createWithFieldsDontInline(rI + 1, sum + 1);\n+        }\n+        return va;\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier() {\n+        Object[] va = test77(true);\n+        Asserts.assertEQ(va.length, 5);\n+        Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI, hash()));\n+        for (int i = 1; i < 5; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hash(), hash());\n+        }\n+        va = test77(false);\n+        Asserts.assertEQ(va.length, 10);\n+        Asserts.assertEQ(((MyValue1)va[0]).hash(), hash(rI + 1, hash(rI, rL) + 1));\n+        for (int i = 1; i < 10; ++i) {\n+            Asserts.assertEQ(((MyValue1)va[i]).hash(), hash(rI + i, rL + i));\n+        }\n+    }\n+\n+    \/\/ Same as test76 but with non value class array cases\n+    @Test\n+    public Object[] test78(MyValue1[] vva, MyValue1[] vba, Object val, Object[] out, int n) {\n+        Object[] result = null;\n+        if (n == 0) {\n+            result = vva;\n+        } else if (n == 1) {\n+            result = vba;\n+        } else if (n == 2) {\n+            result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        } else if (n == 3) {\n+            result = new MyValue1[42];\n+        } else if (n == 4) {\n+            result = new NonValueClass[42];\n+        }\n+        result[0] = val;\n+        out[0] = result[1];\n+        return result;\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier() {\n+        MyValue1 vt = testValue1;\n+        NonValueClass obj = new NonValueClass(42);\n+        Object[] out = new Object[1];\n+        MyValue1[] vva = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        MyValue1[] vva_r = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        vva_r[0] = vt;\n+        MyValue1[] vba = new MyValue1[42];\n+        MyValue1[] vba_r = new MyValue1[42];\n+        vba_r[0] = vt;\n+        Object[] result = test78(vva, vba, vt, out, 0);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test78(vva, vba, vt, out, 1);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+        result = test78(vva, vba, vt, out, 2);\n+        verify(result, vva_r);\n+        Asserts.assertEQ(out[0], vva_r[1]);\n+        result = test78(vva, vba, vt, out, 3);\n+        verify(result, vba_r);\n+        Asserts.assertEQ(out[0], vba_r[1]);\n+        result = test78(vva, vba, obj, out, 4);\n+        Asserts.assertEQ(result[0], obj);\n+        Asserts.assertEQ(out[0], null);\n+    }\n+\n+    \/\/ Test widening conversions from [Q to [L\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public static MyValue1[] test79(MyValue1[] va) {\n+        return va;\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        va[0] = testValue1;\n+        MyValue1[] res = test79(va);\n+        Asserts.assertEquals(res[0].hash(), testValue1.hash());\n+        try {\n+            res[0] = null;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        res[0] = testValue1;\n+        test79(null); \/\/ Should not throw NPE\n+    }\n+\n+    \/\/ Same as test79 but with explicit cast and Object return\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public static Object[] test80(MyValue1[] va) {\n+        return (MyValue1[])va;\n+    }\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        va[0] = testValue1;\n+        Object[] res = test80(va);\n+        Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());\n+        try {\n+            res[0] = null;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        res[0] = testValue1;\n+        test80(null); \/\/ Should not throw NPE\n+    }\n+\n+    \/\/ Test mixing widened and boxed array type\n+    @Test\n+    public static long test81(MyValue1[] va1, MyValue1[] va2, MyValue1 vt, boolean b, boolean shouldThrow) {\n+        MyValue1[] result = b ? va1 : va2;\n+        try {\n+            result[0] = vt;\n+        } catch (NullPointerException npe) {\n+            \/\/ Ignored\n+        }\n+        return result[1].hash();\n+    }\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] vaB = new MyValue1[2];\n+        va[1] = testValue1;\n+        vaB[1] = testValue1;\n+        long res = test81(va, vaB, testValue1, true, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test81(va, vaB, testValue1, false, false);\n+        Asserts.assertEquals(vaB[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test81(va, va, testValue1, false, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+    }\n+\n+    \/\/ Same as test81 but more cases and null writes\n+    @Test\n+    public static long test82(MyValue1[] va1, MyValue1[] va2, MyValue1 vt1, MyValue1 vt2, int i, boolean shouldThrow) {\n+        MyValue1[] result = null;\n+        if (i == 0) {\n+            result = va1;\n+        } else if (i == 1) {\n+            result = va2;\n+        } else if (i == 2) {\n+            result = new MyValue1[2];\n+            result[1] = vt1;\n+        } else if (i == 3) {\n+            result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+            result[1] = vt1;\n+        }\n+        try {\n+            result[0] = (i <= 1) ? null : vt2;\n+            if (shouldThrow) {\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            }\n+        } catch (NullPointerException npe) {\n+            Asserts.assertTrue(shouldThrow, \"NullPointerException thrown\");\n+        }\n+        result[0] = vt1;\n+        return result[1].hash();\n+    }\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] vaB = new MyValue1[2];\n+        va[1] = testValue1;\n+        vaB[1] = testValue1;\n+        long res = test82(va, vaB, testValue1, testValue1, 0, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, vaB, testValue1, testValue1, 1, false);\n+        Asserts.assertEquals(vaB[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, va, testValue1, testValue1, 1, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, va, testValue1, null, 2, false);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+        res = test82(va, va, testValue1, null, 3, true);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, testValue1.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public static long test83(MyValue1[] va) {\n+        MyValue1[] result = va;\n+        return result[0].hash();\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 42, MyValue1.DEFAULT);\n+        va[0] = testValue1;\n+        long res = test83(va);\n+        Asserts.assertEquals(res, testValue1.hash());\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS, LOOP, UNSTABLE_IF_TRAP, PREDICATE_TRAP},\n+        counts = {STORE_OF_ANY_KLASS, \"= 38\"})\n+    public static MyValue1[] test84(MyValue1 vt1, MyValue1 vt2) {\n+        MyValue1[] result = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        result[0] = vt1;\n+        result[1] = vt2;\n+        return result;\n+    }\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier() {\n+        MyValue1[] res = test84(testValue1, testValue1);\n+        Asserts.assertEquals(res[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res[1].hash(), testValue1.hash());\n+        try {\n+            test84(testValue1, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public static long test85(MyValue1[] va, MyValue1 val) {\n+        va[0] = val;\n+        return va[1].hash();\n+    }\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] vab = new MyValue1[2];\n+        va[1] = testValue1;\n+        vab[1] = testValue1;\n+        long res = test85(va, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        res = test85(vab, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(vab[0].hash(), testValue1.hash());\n+    }\n+\n+    \/\/ Same as test85 but with ref value\n+    @Test\n+    public static long test86(MyValue1[] va, MyValue1 val) {\n+        va[0] = val;\n+        return va[1].hash();\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] vab = new MyValue1[2];\n+        va[1] = testValue1;\n+        vab[1] = testValue1;\n+        long res = test86(va, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        try {\n+            test86(va, null);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+        res = test86(vab, testValue1);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(vab[0].hash(), testValue1.hash());\n+        res = test86(vab, null);\n+        Asserts.assertEquals(res, testValue1.hash());\n+        Asserts.assertEquals(vab[0], null);\n+    }\n+\n+    \/\/ Test initialization of nullable array with constant\n+    @Test\n+    public long test87() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = testValue1;\n+        return va[0].hash();\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier() {\n+        long result = test87();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+\n+    \/\/ Test casting to null restricted array\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public static MyValue1[] test88(Class c, MyValue1[] va) {\n+        return (MyValue1[])c.cast(va);\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        Class c = va.getClass();\n+        va[0] = testValue1;\n+        MyValue1[] res = test88(c, va);\n+        Asserts.assertEquals(res[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res, va);\n+        res[0] = testValue1;\n+        test88(c, null); \/\/ Should not throw NPE\n+        va = new MyValue1[1];\n+        res = test88(c, va);\n+        Asserts.assertEquals(res, va);\n+    }\n+\n+    \/\/ Same as test88 but with Object argument\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, ALLOC_ARRAY_OF_MYVALUE_KLASS, LOOP, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public static MyValue1[] test89(Class c, Object[] va) {\n+        return (MyValue1[])c.cast(va);\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        Class c = va.getClass();\n+        va[0] = testValue1;\n+        MyValue1[] res = test89(c, va);\n+        Asserts.assertEquals(((MyValue1)res[0]).hash(), testValue1.hash());\n+        res[0] = testValue1;\n+        test89(c, null); \/\/ Should not throw NPE\n+        va = new MyValue1[1];\n+        res = test89(c, va);\n+        Asserts.assertEquals(res, va);\n+    }\n+\n+    \/\/ More cast tests\n+    @Test\n+    public static MyValue1[] test90(Object va) {\n+        return (MyValue1[])va;\n+    }\n+\n+    @Run(test = \"test90\")\n+    public void test90_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        MyValue1[] vab = new MyValue1[1];\n+        try {\n+          \/\/ Trigger some ClassCastExceptions so C2 does not add an uncommon trap\n+          test90(new NonValueClass[0]);\n+        } catch (ClassCastException cce) {\n+          \/\/ Expected\n+        }\n+        test90(va);\n+        test90(vab);\n+        test90(null);\n+    }\n+\n+    @Test\n+    public static MyValue1[] test91(Object[] va) {\n+        return (MyValue1[])va;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        MyValue1[] vab = new MyValue1[1];\n+        try {\n+          \/\/ Trigger some ClassCastExceptions so C2 does not add an uncommon trap\n+          test91(new NonValueClass[0]);\n+        } catch (ClassCastException cce) {\n+          \/\/ Expected\n+        }\n+        test91(va);\n+        test91(vab);\n+        test91(null);\n+    }\n+\n+    \/\/ Test if arraycopy intrinsic correctly checks for flattened source array\n+    @Test\n+    public static void test92(MyValue1[] src, MyValue1[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 2);\n+    }\n+\n+    @Run(test = \"test92\")\n+    public void test92_verifier() {\n+        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] vab = new MyValue1[2];\n+        va[0] = testValue1;\n+        vab[0] = testValue1;\n+        test92(va, vab);\n+        Asserts.assertEquals(va[0], vab[0]);\n+        Asserts.assertEquals(va[1], vab[1]);\n+    }\n+\n+    @Test\n+    public static void test93(Object src, MyValue1[] dst) {\n+        System.arraycopy(src, 0, dst, 0, 2);\n+    }\n+\n+    @Run(test = \"test93\")\n+    public void test93_verifier() {\n+        MyValue1[]  va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] vab = new MyValue1[2];\n+        va[0] = testValue1;\n+        vab[0] = testValue1;\n+        test93(va, vab);\n+        Asserts.assertEquals(va[0], vab[0]);\n+        Asserts.assertEquals(va[1], vab[1]);\n+    }\n+\n+    \/\/ Test non-escaping allocation with arraycopy\n+    \/\/ that does not modify loaded array element.\n+    @Test\n+    public static long test94() {\n+        MyValue1[] src = new MyValue1[8];\n+        MyValue1[]  dst = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 8, MyValue1.DEFAULT);\n+        for (int i = 1; i < 8; ++i) {\n+            src[i] = testValue1;\n+        }\n+        System.arraycopy(src, 1, dst, 2, 6);\n+        return dst[0].hash();\n+    }\n+\n+    @Run(test = \"test94\")\n+    public static void test94_verifier() {\n+        long result = test94();\n+        Asserts.assertEquals(result, MyValue1.createDefaultInline().hash());\n+    }\n+\n+    \/\/ Test meeting constant TypeInstPtr with InlineTypeNode\n+    @ForceInline\n+    public long test95_callee() {\n+        MyValue1[] va = new MyValue1[1];\n+        va[0] = testValue1;\n+        return va[0].hashInterpreted();\n+    }\n+\n+    @Test\n+    public long test95() {\n+        return test95_callee();\n+    }\n+\n+    @Run(test = \"test95\")\n+    @Warmup(0)\n+    public void test95_verifier() {\n+        long result = test95();\n+        Asserts.assertEQ(result, hash());\n+    }\n+\n+    \/\/ Matrix multiplication test to exercise type flow analysis with nullable value class arrays\n+    static value class Complex {\n+        private final double re;\n+        private final double im;\n+\n+        Complex(double re, double im) {\n+            this.re = re;\n+            this.im = im;\n+        }\n+\n+        public Complex add(Complex that) {\n+            return new Complex(this.re + that.re, this.im + that.im);\n+        }\n+\n+        public Complex mul(Complex that) {\n+            return new Complex(this.re * that.re - this.im * that.im,\n+                               this.re * that.im + this.im * that.re);\n+        }\n+    }\n+\n+    @Test\n+    public Complex[][] test96(Complex[][] A, Complex[][] B) {\n+        int size = A.length;\n+        Complex[][] R = new Complex[size][size];\n+        for (int i = 0; i < size; i++) {\n+            for (int k = 0; k < size; k++) {\n+                Complex aik = A[i][k];\n+                for (int j = 0; j < size; j++) {\n+                    R[i][j] = B[i][j].add(aik.mul((Complex)B[k][j]));\n+                }\n+            }\n+        }\n+        return R;\n+    }\n+\n+    static Complex[][] test96_A = new Complex[10][10];\n+    static Complex[][] test96_B = new Complex[10][10];\n+    static Complex[][] test96_R;\n+\n+    static {\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = 0; j < 10; j++) {\n+                test96_A[i][j] = new Complex(rI, rI);\n+                test96_B[i][j] = new Complex(rI, rI);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier() {\n+        Complex[][] result = test96(test96_A, test96_B);\n+        if (test96_R == null) {\n+            test96_R = result;\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = 0; j < 10; j++) {\n+                Asserts.assertEQ(result[i][j], test96_R[i][j]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test loads from vararg arrays\n+    @Test\n+    @IR(failOn = {LOAD_UNKNOWN_INLINE})\n+    public static Object test97(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test97\")\n+    public static void test97_verifier() {\n+        Object obj = new Object();\n+        Object result = test97(obj);\n+        Asserts.assertEquals(result, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        myInt[0] = otherObj;\n+        result = test97((Object[])myInt);\n+        Asserts.assertEquals(result, otherObj);\n+    }\n+\n+    @Test\n+    public static Object test98(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test98\")\n+    public static void test98_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        Object result = test98(obj);\n+        Asserts.assertEquals(result, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        myInt[0] = otherObj;\n+        result = test98((Object[])myInt);\n+        Asserts.assertEquals(result, otherObj);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+            MyValue1[] vab = new MyValue1[1];\n+            result = test98((Object[])va);\n+            Asserts.assertEquals(((MyValue1)result).hash(), MyValue1.createDefaultInline().hash());\n+            result = test98((Object[])vab);\n+            Asserts.assertEquals(result, null);\n+        }\n+    }\n+\n+    @Test\n+    public static Object test99(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test99\")\n+    public static void test99_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        Object result = test99(obj);\n+        Asserts.assertEquals(result, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        myInt[0] = otherObj;\n+        result = test99((Object[])myInt);\n+        Asserts.assertEquals(result, otherObj);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test99((Object[])null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static Object test100(Object... args) {\n+        return args[0];\n+    }\n+\n+    @Run(test = \"test100\")\n+    public static void test100_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        Object result = test100(obj);\n+        Asserts.assertEquals(result, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        myInt[0] = otherObj;\n+        result = test100((Object[])myInt);\n+        Asserts.assertEquals(result, otherObj);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test100();\n+                throw new RuntimeException(\"No AIOOBE thrown\");\n+            } catch (ArrayIndexOutOfBoundsException aioobe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Test stores to varag arrays\n+    @Test\n+    @IR(failOn = STORE_UNKNOWN_INLINE)\n+    public static void test101(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test101\")\n+    public static void test101_verifier() {\n+        Object obj = new Object();\n+        test101(obj, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        test101(otherObj, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], otherObj);\n+        test101(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+    }\n+\n+    @Test\n+    public static void test102(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public static void test102_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test102(obj, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        test102(otherObj, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], otherObj);\n+        test102(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+            MyValue1[] vab = new MyValue1[1];\n+            test102(testValue1, (Object[])va);\n+            Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+            test102(testValue1, (Object[])vab);\n+            Asserts.assertEquals(vab[0].hash(), testValue1.hash());\n+            test102(null, (Object[])vab);\n+            Asserts.assertEquals(vab[0], null);\n+        }\n+    }\n+\n+    @Test\n+    public static void test103(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test103\")\n+    public static void test103_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test103(obj, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        test103(otherObj, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], otherObj);\n+        test103(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+            try {\n+                test103(null, (Object[])va);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static void test104(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test104\")\n+    public static void test104_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test104(obj, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        test104(otherObj, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], otherObj);\n+        test104(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test104(testValue1);\n+                throw new RuntimeException(\"No AIOOBE thrown\");\n+            } catch (ArrayIndexOutOfBoundsException aioobe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static void test105(Object val, Object... args) {\n+        args[0] = val;\n+    }\n+\n+    @Run(test = \"test105\")\n+    public static void test105_verifier(RunInfo info) {\n+        Object obj = new Object();\n+        test105(obj, obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        test105(otherObj, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], otherObj);\n+        test105(null, (Object[])myInt);\n+        Asserts.assertEquals(myInt[0], null);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test105(testValue1, (Object[])null);\n+                throw new RuntimeException(\"No NPE thrown\");\n+            } catch (NullPointerException npe) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public static Object[] test106(Object[] dst, Object... args) {\n+        \/\/ Access array to speculate on non-flatness\n+        if (args[0] == null) {\n+            args[0] = testValue1;\n+        }\n+        System.arraycopy(args, 0, dst, 0, args.length);\n+        System.arraycopy(dst, 0, args, 0, dst.length);\n+        Object[] clone = args.clone();\n+        if (clone[0] == null) {\n+            throw new RuntimeException(\"Unexpected null\");\n+        }\n+        return Arrays.copyOf(args, args.length, Object[].class);\n+    }\n+\n+    @Run(test = \"test106\")\n+    public static void test106_verifier(RunInfo info) {\n+        Object[] dst = new Object[1];\n+        Object obj = new Object();\n+        Object[] result = test106(dst, obj);\n+        Asserts.assertEquals(result[0], obj);\n+        NonValueClass[] myInt = new NonValueClass[1];\n+        NonValueClass otherObj = new NonValueClass(rI);\n+        myInt[0] = otherObj;\n+        result = test106(myInt, (Object[])myInt);\n+        Asserts.assertEquals(result[0], otherObj);\n+        if (!info.isWarmUp()) {\n+            MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+            MyValue1[] vab = new MyValue1[1];\n+            result = test106(va, (Object[])va);\n+            Asserts.assertEquals(((MyValue1)result[0]).hash(), MyValue1.createDefaultInline().hash());\n+            result = test106(vab, (Object[])vab);\n+            Asserts.assertEquals(((MyValue1)result[0]).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    \/\/ TODO 8325632 Fails with \"matching stack sizes\" in Scenario 5 with -XX:TypeProfileLevel=222\n+    \/*\n+    \/\/ Test that allocation is not replaced by non-dominating allocation\n+    @ForceInline\n+    public long test107_helper(MyValue1[] va, MyValue1 vt) {\n+        try {\n+            va[0] = vt;\n+        } catch (NullPointerException npe) { }\n+        return va[1].hash();\n+    }\n+\n+    @Test\n+    public void test107() {\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        MyValue1[] tmp = new MyValue1[2];\n+        long res1 = test107_helper(va, testValue1);\n+        long res2 = test107_helper(va, testValue1);\n+        Asserts.assertEquals(va[0].hash(), testValue1.hash());\n+        Asserts.assertEquals(res1, MyValue1.createDefaultInline().hash());\n+        Asserts.assertEquals(res2, MyValue1.createDefaultInline().hash());\n+    }\n+\n+    @Run(test = \"test107\")\n+    public void test107_verifier() {\n+        test107();\n+    }\n+    *\/\n+\n+    @Test\n+    public Object test108(MyValue1[] src, boolean flag) {\n+        MyValue1[] dst = new MyValue1[8];\n+        System.arraycopy(src, 1, dst, 2, 6);\n+        if (flag) {} \/\/ uncommon trap\n+        return dst[2];\n+    }\n+\n+    @Run(test = \"test108\")\n+    @Warmup(10000)\n+    public void test108_verifier(RunInfo info) {\n+        MyValue1[] src = new MyValue1[8];\n+        test108(src, !info.isWarmUp());\n+    }\n+\n+    \/\/ Test LoadNode::can_see_arraycopy_value optimization\n+    @Test\n+    public static void test109() {\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        MyValue1[] dst = new MyValue1[1];\n+        src[0] = testValue1;\n+        System.arraycopy(src, 0, dst, 0, 1);\n+        Asserts.assertEquals(src[0], dst[0]);\n+    }\n+\n+    @Run(test = \"test109\")\n+    public void test109_verifier() {\n+        test109();\n+    }\n+\n+    \/\/ Same as test109 but with Object destination array\n+    @Test\n+    public static void test110() {\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        Object[] dst = new Object[1];\n+        src[0] = testValue1;\n+        System.arraycopy(src, 0, dst, 0, 1);\n+        Asserts.assertEquals(src[0], dst[0]);\n+    }\n+\n+    @Run(test = \"test110\")\n+    public void test110_verifier() {\n+        test110();\n+    }\n+\n+    \/\/ Same as test109 but with Arrays.copyOf\n+    @Test\n+    public static void test111() {\n+        MyValue1[] src = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+        src[0] = testValue1;\n+        MyValue1[] dst = Arrays.copyOf(src, src.length, MyValue1[].class);\n+        Asserts.assertEquals(src[0], dst[0]);\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        test111();\n+    }\n+\n+    static final MyValue1[] refArray = new MyValue1[2];\n+    static final MyValue1[] flatArray = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 1, MyValue1.DEFAULT);\n+\n+    \/\/ Test scalarization\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public int test112(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test112(true), refArray[0].x);\n+        Asserts.assertEquals(test112(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test112(false), testValue1.x);\n+                test112(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test112 but with call to hash()\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public long test113(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test113\")\n+    public void test113_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test113(true), refArray[0].hash());\n+        Asserts.assertEquals(test113(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test113(false), testValue1.hash());\n+                test113(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test114(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test114\")\n+    public void test114_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test114(true).hash(), refArray[0].hash());\n+        Asserts.assertEquals(test114(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            Asserts.assertEquals(test114(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test115(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refArray[0];\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test115\")\n+    public void test115_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test115(true, false, info.getTest()), refArray[0].x);\n+        Asserts.assertEquals(test115(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            try {\n+                Asserts.assertEquals(test115(false, false, info.getTest()), testValue1.x);\n+                test115(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test115(true, true, info.getTest()), refArray[0].x);\n+            Asserts.assertEquals(test115(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test116(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refArray[0];\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test116(true, false, info.getTest()).hash(), refArray[0].hash());\n+        Asserts.assertEquals(test116(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refArray[0] = null;\n+            Asserts.assertEquals(test116(true, false, info.getTest()), null);\n+            refArray[0] = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test116(true, true, info.getTest()).hash(), refArray[0].hash());\n+            Asserts.assertEquals(test116(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public int test117(boolean b) {\n+        MyValue1 val = null;\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test117(true), testValue1.x);\n+        try {\n+            test117(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test118(boolean b) {\n+        MyValue1 val = null;\n+        if (b) {\n+            val = refArray[0];\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test118(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test118(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public int test119(boolean b) {\n+        MyValue1 val = refArray[0];\n+        if (b) {\n+            val = null;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test119(false), testValue1.x);\n+        try {\n+            test119(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test120(boolean b) {\n+        MyValue1 val = refArray[0];\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        refArray[0] = testValue1;\n+        Asserts.assertEquals(test120(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test120(true), null);\n+    }\n+\n+    @ForceInline\n+    public Object test121_helper() {\n+        return flatArray[0];\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        failOn = {ALLOC},\n+        counts = {STORE_OF_ANY_KLASS, \"= 19\"})\n+    public void test121(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = refArray[0];\n+        } else {\n+            o = test121_helper();\n+        }\n+        if (o == null) {\n+            return;\n+        }\n+        flatArray[0] = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        refArray[0] = testValue1;\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatArray[0] = vt;\n+        test121(false);\n+        Asserts.assertEquals(flatArray[0].hash(), vt.hash());\n+        test121(true);\n+        Asserts.assertEquals(flatArray[0].hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test122_helper() {\n+        return refArray[0];\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        failOn = {ALLOC},\n+        counts = {STORE_OF_ANY_KLASS, \"= 19\"})\n+    public void test122(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = flatArray[0];\n+        } else {\n+            o = test122_helper();\n+        }\n+        if (o == null) {\n+            return;\n+        }\n+        flatArray[0] = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        refArray[0] = testValue1;\n+        test122(false);\n+        Asserts.assertEquals(flatArray[0].hash(), testValue1.hash());\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatArray[0] = vt;\n+        test122(true);\n+        Asserts.assertEquals(flatArray[0].hash(), vt.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test123_helper() {\n+        return refArray[0];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public long test123(boolean b, MyValue1 val, Method m, boolean deopt) {\n+        MyValue1[] array = new MyValue1[1];\n+        array[0] = val;\n+        Object res = null;\n+        if (b) {\n+            res = array[0];\n+        } else {\n+            res = test123_helper();\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)res).hash();\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createDefaultInline();\n+        Asserts.assertEquals(test123(true, testValue1, info.getTest(), false), testValue1.hash());\n+        Asserts.assertEquals(test123(false, testValue1, info.getTest(), false), MyValue1.createDefaultInline().hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test123(true, testValue1, info.getTest(), true), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test124_helper(MyValue2 val) {\n+        MyValue2[] array = new MyValue2[1];\n+        array[0] = val;\n+        return array[0];\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public long test124(boolean b, MyValue2 val, Method m, boolean deopt) {\n+        Object res = null;\n+        if (b) {\n+            res = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        } else {\n+            res = test124_helper(val);\n+        }\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue2)res).hash();\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createDefaultInline();\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        Asserts.assertEquals(test124(true, val1, info.getTest(), false), val2.hash());\n+        Asserts.assertEquals(test124(false, val1, info.getTest(), false), val1.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test124(true, val1, info.getTest(), true), val2.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public void test125_helper(Object[] array, MyValue2 val) {\n+        array[0] = val;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS})\n+    public long test125(boolean b, MyValue2 val, Method m, boolean deopt) {\n+        Object[] res = new MyValue2[1];\n+        if (b) {\n+            res[0] = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        } else {\n+            test125_helper(res, val);\n+        }\n+        val = ((MyValue2)res[0]);\n+        if (deopt) {\n+            \/\/ uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test125\")\n+    public void test125_verifier(RunInfo info) {\n+        refArray[0] = MyValue1.createDefaultInline();\n+        MyValue2 val1 = MyValue2.createWithFieldsInline(rI, rD);\n+        MyValue2 val2 = MyValue2.createWithFieldsInline(rI+1, rD+1);\n+        Asserts.assertEquals(test125(true, val1, info.getTest(), false), val2.hash());\n+        Asserts.assertEquals(test125(false, val1, info.getTest(), false), val1.hash());\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test125(true, val1, info.getTest(), true), val2.hash());\n+        }\n+    }\n+\n+    static Object oFld = null;\n+\n+    static value class MyValue126  {\n+        int x;\n+\n+        MyValue126(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    \/\/ Test that result of access to unknown flat array is not marked as null-free\n+    @Test\n+    public void test126(Object[] array, int i) {\n+        oFld = array[i];\n+    }\n+\n+    @Run(test = \"test126\")\n+    @Warmup(0)\n+    public void test126_verifier() {\n+        MyValue126[] array = (MyValue126[]) ValueClass.newNullableAtomicArray(MyValue126.class, 2);\n+        array[1] = new MyValue126(rI);\n+        test126(array, 1);\n+        Asserts.assertEquals(oFld, new MyValue126(rI));\n+        test126(array, 0);\n+        Asserts.assertEquals(oFld, null);\n+    }\n+\n+    \/\/ Same as test126 but different failure mode\n+    @Test\n+    public void test127(Object[] array, int i) {\n+        oFld = (MyValue126)array[i];\n+    }\n+\n+    @Run(test = \"test127\")\n+    @Warmup(0)\n+    public void test127_verifier() {\n+        MyValue126[] array = (MyValue126[]) ValueClass.newNullableAtomicArray(MyValue126.class, 2);\n+        array[1] = new MyValue126(rI);\n+        test127(array, 1);\n+        Asserts.assertEquals(oFld, new MyValue126(rI));\n+        test127(array, 0);\n+        Asserts.assertEquals(oFld, null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":3351,"deletions":0,"binary":false,"changes":3351,"status":"added"},{"patch":"@@ -0,0 +1,3353 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.util.Objects;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.ALLOC_OF_MYVALUE_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.LOAD_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.STORE_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypes.*;\n+\n+import static compiler.lib.ir_framework.IRNode.ALLOC;\n+import static compiler.lib.ir_framework.IRNode.CMP_N;\n+import static compiler.lib.ir_framework.IRNode.CMP_P;\n+import static compiler.lib.ir_framework.IRNode.PREDICATE_TRAP;\n+import static compiler.lib.ir_framework.IRNode.UNSTABLE_IF_TRAP;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test correct handling of nullable value classes.\n+ * @library \/test\/lib \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build test.java.lang.invoke.lib.InstructionHelper\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestNullableInlineTypes\n+ *\/\n+\n+@ForceCompileClassInitializer\n+public class TestNullableInlineTypes {\n+\n+    public static void main(String[] args) {\n+\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:-MonomorphicArrayCheck\", \"-XX:+UseArrayFlattening\");\n+        scenarios[4].addFlags(\"-XX:-MonomorphicArrayCheck\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    static {\n+        \/\/ Make sure RuntimeException is loaded to prevent uncommon traps in IR verified tests\n+        RuntimeException tmp = new RuntimeException(\"42\");\n+        try {\n+            Class<?> clazz = TestNullableInlineTypes.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType test18_mt = MethodType.methodType(void.class, MyValue1.class);\n+            test18_mh1 = lookup.findStatic(clazz, \"test18_target1\", test18_mt);\n+            test18_mh2 = lookup.findStatic(clazz, \"test18_target2\", test18_mt);\n+\n+            MethodType test19_mt = MethodType.methodType(void.class, MyValue1.class);\n+            test19_mh1 = lookup.findStatic(clazz, \"test19_target1\", test19_mt);\n+            test19_mh2 = lookup.findStatic(clazz, \"test19_target2\", test19_mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    private static final MyValue1 testValue1 = MyValue1.createWithFieldsInline(rI, rL);\n+\n+    private static final MyValue1[] testValue1Array = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 3, MyValue1.DEFAULT);\n+    static {\n+        for (int i = 0; i < 3; ++i) {\n+            testValue1Array[i] = testValue1;\n+        }\n+    }\n+\n+    MyValue1 nullField;\n+\n+    @Strict\n+    @NullRestricted\n+    MyValue1 valueField1 = testValue1;\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public long test1(MyValue1 vt) {\n+        long result = 0;\n+        try {\n+            result = vt.hash();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public void test1_verifier() {\n+        long result = test1(null);\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public long test2(MyValue1 vt) {\n+        long result = 0;\n+        try {\n+            result = vt.hashInterpreted();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public void test2_verifier() {\n+        long result = test2(null);\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public long test3() {\n+        long result = 0;\n+        try {\n+            if ((Object)nullField != null) {\n+                throw new RuntimeException(\"nullField should be null\");\n+            }\n+            result = nullField.hash();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test3\")\n+    public void test3_verifier() {\n+        long result = test3();\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test4() {\n+        try {\n+            valueField1 = nullField;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test4\")\n+    public void test4_verifier() {\n+        test4();\n+    }\n+\n+    @Test\n+    \/\/ TODO 8284443 When passing vt to test5_inline and incrementally inlining, we lose the oop\n+    @IR(applyIfOr = {\"InlineTypePassFieldsAsArgs\", \"false\", \"AlwaysIncrementalInline\", \"false\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public MyValue1 test5(MyValue1 vt) {\n+        Object o = vt;\n+        vt = (MyValue1)o;\n+        vt = test5_dontinline(vt);\n+        vt = test5_inline(vt);\n+        return vt;\n+    }\n+\n+    @Run(test = \"test5\")\n+    public void test5_verifier() {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        Asserts.assertEquals(test5(val), val);\n+        Asserts.assertEquals(test5(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValue1 test5_dontinline(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test5_inline(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Test\n+    public MyValue1 test6(Object obj) {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI, rL);\n+        try {\n+            vt = (MyValue1)Objects.requireNonNull(obj);\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test6\")\n+    public void test6_verifier() {\n+        MyValue1 vt = test6(null);\n+        Asserts.assertEquals(vt.hash(), testValue1.hash());\n+    }\n+\n+    @ForceInline\n+    public MyValue1 getNullInline() {\n+        return null;\n+    }\n+\n+    @DontInline\n+    public MyValue1 getNullDontInline() {\n+        return null;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test7() {\n+        nullField = getNullInline();     \/\/ Should not throw\n+        nullField = getNullDontInline(); \/\/ Should not throw\n+        try {\n+            valueField1 = getNullInline();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            valueField1 = getNullDontInline();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test7\")\n+    public void test7_verifier() {\n+        test7();\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test8() {\n+        try {\n+            valueField1 = nullField;\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test8\")\n+    public void test8_verifier() {\n+        test8();\n+    }\n+\n+    \/\/ Merge of two value objects, one being null\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test9(boolean flag) {\n+        MyValue1 v;\n+        if (flag) {\n+            v = valueField1;\n+        } else {\n+            v = nullField;\n+        }\n+        valueField1 = v;\n+    }\n+\n+    @Run(test = \"test9\")\n+    public void test9_verifier() {\n+        test9(true);\n+        try {\n+            test9(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ null constant\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test10(boolean flag) {\n+        MyValue1 val = flag ? valueField1 : null;\n+        valueField1 = val;\n+    }\n+\n+    @Run(test = \"test10\")\n+    public void test10_verifier() {\n+        test10(true);\n+        try {\n+            test10(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ null constant\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test11(boolean flag) {\n+        MyValue1 val = flag ? null : valueField1;\n+        valueField1 = val;\n+    }\n+\n+    @Run(test = \"test11\")\n+    public void test11_verifier() {\n+        test11(false);\n+        try {\n+            test11(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ null return\n+    int test12_cnt;\n+\n+    @DontInline\n+    public MyValue1 test12_helper() {\n+        test12_cnt++;\n+        return nullField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test12() {\n+        valueField1 = test12_helper();\n+    }\n+\n+    @Run(test = \"test12\")\n+    public void test12_verifier() {\n+        try {\n+            test12_cnt = 0;\n+            test12();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (test12_cnt != 1) {\n+            throw new RuntimeException(\"call executed twice\");\n+        }\n+    }\n+\n+    \/\/ null return at virtual call\n+    class A {\n+        public MyValue1 test13_helper() {\n+            return nullField;\n+        }\n+    }\n+\n+    class B extends A {\n+        public MyValue1 test13_helper() {\n+            return nullField;\n+        }\n+    }\n+\n+    class C extends A {\n+        public MyValue1 test13_helper() {\n+            return nullField;\n+        }\n+    }\n+\n+    class D extends C {\n+        public MyValue1 test13_helper() {\n+            return nullField;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test13(A a) {\n+        valueField1 = a.test13_helper();\n+    }\n+\n+    @Run(test = \"test13\")\n+    public void test13_verifier() {\n+        A a = new A();\n+        A b = new B();\n+        A c = new C();\n+        A d = new D();\n+        try {\n+            test13(a);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test13(b);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test13(c);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test13(d);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test writing null to a (flat) value class array\n+    @ForceInline\n+    public void test14_inline(Object[] oa, Object o, int index) {\n+        oa[index] = o;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test14(MyValue1[] va, int index) {\n+        test14_inline(va, nullField, index);\n+    }\n+\n+    @Run(test = \"test14\")\n+    public void test14_verifier() {\n+        int index = Math.abs(rI) % 3;\n+        try {\n+            test14(testValue1Array, index);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        Asserts.assertEQ(testValue1Array[index].hash(), testValue1.hash());\n+    }\n+\n+    @DontInline\n+    MyValue1 getNullField1() {\n+        return nullField;\n+    }\n+\n+    @DontInline\n+    MyValue1 getNullField2() {\n+        return null;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test15() {\n+        nullField = getNullField1(); \/\/ should not throw\n+        try {\n+            valueField1 = getNullField1();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            valueField1 = getNullField2();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Run(test = \"test15\")\n+    public void test15_verifier() {\n+        test15();\n+    }\n+\n+    @DontInline\n+    public boolean test16_dontinline(MyValue1 vt) {\n+        return vt == null;\n+    }\n+\n+    \/\/ Test c2c call passing null for a value class\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public boolean test16(Object arg) throws Exception {\n+        Method test16method = getClass().getMethod(\"test16_dontinline\", MyValue1.class);\n+        return (boolean)test16method.invoke(this, arg);\n+    }\n+\n+    @Run(test = \"test16\")\n+    @Warmup(10000) \/\/ Warmup to make sure 'test17_dontinline' is compiled\n+    public void test16_verifier() throws Exception {\n+        boolean res = test16(null);\n+        Asserts.assertTrue(res);\n+    }\n+\n+    \/\/ Test scalarization of value class with non-flattenable field\n+    @LooselyConsistentValue\n+    final value class Test17Value {\n+        public final MyValue1 valueField;\n+\n+        @ForceInline\n+        public Test17Value(MyValue1 valueField) {\n+            this.valueField = valueField;\n+        }\n+    }\n+\n+    @Test\n+    \/\/ TODO 8284443 When passing testValue1 to the constructor in scalarized form and incrementally inlining, we lose the oop\n+    @IR(applyIfOr = {\"InlineTypePassFieldsAsArgs\", \"false\", \"AlwaysIncrementalInline\", \"false\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public Test17Value test17(boolean b) {\n+        Test17Value vt1 = new Test17Value(null);\n+        Test17Value vt2 = new Test17Value(testValue1);\n+        return b ? vt1 : vt2;\n+    }\n+\n+    @Run(test = \"test17\")\n+    public void test17_verifier() {\n+        test17(true);\n+        test17(false);\n+    }\n+\n+    static final MethodHandle test18_mh1;\n+    static final MethodHandle test18_mh2;\n+\n+    static MyValue1 nullValue;\n+\n+    @DontInline\n+    static void test18_target1(MyValue1 vt) {\n+        nullValue = vt;\n+    }\n+\n+    @ForceInline\n+    static void test18_target2(MyValue1 vt) {\n+        nullValue = vt;\n+    }\n+\n+    \/\/ Test passing null for a value class\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test18() throws Throwable {\n+        test18_mh1.invokeExact(nullValue);\n+        test18_mh2.invokeExact(nullValue);\n+    }\n+\n+    @Run(test = \"test18\")\n+    @Warmup(11000) \/\/ Make sure lambda forms get compiled\n+    public void test18_verifier() {\n+        try {\n+            test18();\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"test18 failed\", t);\n+        }\n+    }\n+\n+    static MethodHandle test19_mh1;\n+    static MethodHandle test19_mh2;\n+\n+    @DontInline\n+    static void test19_target1(MyValue1 vt) {\n+        nullValue = vt;\n+    }\n+\n+    @ForceInline\n+    static void test19_target2(MyValue1 vt) {\n+        nullValue = vt;\n+    }\n+\n+    \/\/ Same as test12 but with non-final mh\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test19() throws Throwable {\n+        test19_mh1.invokeExact(nullValue);\n+        test19_mh2.invokeExact(nullValue);\n+    }\n+\n+    @Run(test = \"test19\")\n+    @Warmup(11000) \/\/ Make sure lambda forms get compiled\n+    public void test19_verifier() {\n+        try {\n+            test19();\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"test19 failed\", t);\n+        }\n+    }\n+\n+    \/\/ Same as test12\/13 but with constant null\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test20(MethodHandle mh) throws Throwable {\n+        mh.invoke(null);\n+    }\n+\n+    @Run(test = \"test20\")\n+    @Warmup(11000) \/\/ Make sure lambda forms get compiled\n+    public void test20_verifier() {\n+        try {\n+            test20(test18_mh1);\n+            test20(test18_mh2);\n+            test20(test19_mh1);\n+            test20(test19_mh2);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"test20 failed\", t);\n+        }\n+    }\n+\n+    \/\/ Test writing null to a flattenable\/non-flattenable value class field in a value class\n+    @LooselyConsistentValue\n+    value class Test21Value {\n+        MyValue1 valueField1;\n+        @Strict\n+        @NullRestricted\n+        MyValue1 valueField2;\n+\n+        @ForceInline\n+        public Test21Value(MyValue1 valueField1, MyValue1 valueField2) {\n+            this.valueField1 = valueField1;\n+            this.valueField2 = valueField2;\n+        }\n+\n+        @ForceInline\n+        public Test21Value test1() {\n+            return new Test21Value(null, this.valueField2); \/\/ Should not throw NPE\n+        }\n+\n+        @ForceInline\n+        public Test21Value test2() {\n+            return new Test21Value(this.valueField1, null); \/\/ Should throw NPE\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public Test21Value test21(Test21Value vt) {\n+        vt = vt.test1();\n+        try {\n+            vt = vt.test2();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test21\")\n+    public void test21_verifier() {\n+        test21(new Test21Value(null, MyValue1.createDefaultInline()));\n+    }\n+\n+    @DontInline\n+    public MyValue1 test22_helper() {\n+        return nullField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test22() {\n+        valueField1 = test22_helper();\n+    }\n+\n+    @Run(test = \"test22\")\n+    public void test22_verifier() {\n+        try {\n+            test22();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"UseArrayFlattening\", \"true\", \"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    @IR(applyIfAnd = {\"UseArrayFlattening\", \"false\", \"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public void test23(MyValue1 val) {\n+        MyValue1[] arr = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, 2, MyValue1.DEFAULT);\n+        arr[0] = val;\n+    }\n+\n+    @Run(test = \"test23\")\n+    public void test23_verifier() {\n+        MyValue1 val = null;\n+        try {\n+            test23(val);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static MyValue1 nullBox;\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public MyValue1 test24() {\n+        return Objects.requireNonNull(nullBox);\n+    }\n+\n+    @Run(test = \"test24\")\n+    public void test24_verifier() {\n+        try {\n+            test24();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @DontInline\n+    public void test25_callee(MyValue1 val) { }\n+\n+    \/\/ Test that when checkcasting from null-ok to null-free and back to null-ok we\n+    \/\/ keep track of the information that the value object can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test25(boolean b, MyValue1 vt1, MyValue1 vt2) {\n+        vt1 = (MyValue1)vt1;\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate here\n+        test25_callee((MyValue1) vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test25\")\n+    public void test25_verifier(RunInfo info) {\n+        int res = test25(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test25(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                test25(true, null, testValue1);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Test that chains of casts are folded and don't trigger an allocation\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public MyValue3 test26(MyValue3 vt) {\n+        return ((MyValue3)((Object)((MyValue3)(MyValue3)((MyValue3)((Object)vt)))));\n+    }\n+\n+    @Run(test = \"test26\")\n+    public void test26_verifier() {\n+        MyValue3 vt = MyValue3.create();\n+        MyValue3 result = test26(vt);\n+        Asserts.assertEquals(result, vt);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public MyValue3 test27(MyValue3 vt) {\n+        return ((MyValue3)((Object)((MyValue3)(MyValue3)((MyValue3)((Object)vt)))));\n+    }\n+\n+    @Run(test = \"test27\")\n+    public void test27_verifier() {\n+        MyValue3 vt = MyValue3.create();\n+        MyValue3 result = (MyValue3) test27(vt);\n+        Asserts.assertEquals(result, vt);\n+    }\n+\n+    \/\/ Some more casting tests\n+    @Test\n+    public MyValue1 test28(MyValue1 vt, MyValue1 vtBox, int i) {\n+        MyValue1 result = null;\n+        if (i == 0) {\n+            result = (MyValue1)vt;\n+            result = null;\n+        } else if (i == 1) {\n+            result = (MyValue1)vt;\n+        } else if (i == 2) {\n+            result = vtBox;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test28\")\n+    public void test28_verifier() {\n+        MyValue1 result = test28(testValue1, null, 0);\n+        Asserts.assertEquals(result, null);\n+        result = test28(testValue1, testValue1, 1);\n+        Asserts.assertEquals(result, testValue1);\n+        result = test28(testValue1, null, 2);\n+        Asserts.assertEquals(result, null);\n+        result = test28(testValue1, testValue1, 2);\n+        Asserts.assertEquals(result, testValue1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public long test29(MyValue1 vt, MyValue1 vtBox) {\n+        long result = 0;\n+        for (int i = 0; i < 100; ++i) {\n+            MyValue1 box;\n+            if (i == 0) {\n+                box = (MyValue1)vt;\n+                box = null;\n+            } else if (i < 99) {\n+                box = (MyValue1)vt;\n+            } else {\n+                box = vtBox;\n+            }\n+            if (box != null) {\n+                result += box.hash();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test29\")\n+    public void test29_verifier() {\n+        long result = test29(testValue1, null);\n+        Asserts.assertEquals(result, testValue1.hash()*98);\n+        result = test29(testValue1, testValue1);\n+        Asserts.assertEquals(result, testValue1.hash()*99);\n+    }\n+\n+    \/\/ Test null check of value object receiver with incremental inlining\n+    public long test30_callee(MyValue1 vt) {\n+        long result = 0;\n+        try {\n+            result = vt.hashInterpreted();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        return result;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public long test30() {\n+        return test30_callee(nullField);\n+    }\n+\n+    @Run(test = \"test30\")\n+    public void test30_verifier() {\n+        long result = test30();\n+        Asserts.assertEquals(result, 0L);\n+    }\n+\n+    \/\/ Test casting null to unloaded value class\n+    value class Test31Value {\n+        private int i = 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public Object test31(Object o) {\n+        return (Test31Value)o;\n+    }\n+\n+    @Run(test = \"test31\")\n+    public void test31_verifier() {\n+        test31(null);\n+    }\n+\n+    private static final MyValue1 constNullRefField = null;\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public MyValue1 test32() {\n+        return constNullRefField;\n+    }\n+\n+    @Run(test = \"test32\")\n+    public void test32_verifier() {\n+        MyValue1 result = test32();\n+        Asserts.assertEquals(result, null);\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Test33Value1 {\n+        int x = 0;\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Test33Value2 {\n+        Test33Value1 vt;\n+\n+        public Test33Value2() {\n+            vt = new Test33Value1();\n+        }\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    public static final Test33Value2 test33Val = new Test33Value2();\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public Test33Value2 test33() {\n+        return test33Val;\n+    }\n+\n+    @Run(test = \"test33\")\n+    public void test33_verifier() {\n+        Test33Value2 result = test33();\n+        Asserts.assertEquals(result, test33Val);\n+    }\n+\n+    \/\/ Verify that static nullable inline-type fields are not\n+    \/\/ treated as never-null by C2 when initialized at compile time.\n+    private static MyValue1 test34Val;\n+\n+    @Test\n+    public void test34(MyValue1 vt) {\n+        if (test34Val == null) {\n+            test34Val = vt;\n+        }\n+    }\n+\n+    @Run(test = \"test34\")\n+    public void test34_verifier(RunInfo info) {\n+        test34(testValue1);\n+        if (!info.isWarmUp()) {\n+            test34Val = null;\n+            test34(testValue1);\n+            Asserts.assertEquals(test34Val, testValue1);\n+        }\n+    }\n+\n+    \/\/ Same as test17 but with non-allocated value object\n+    @Test\n+    public Test17Value test35(boolean b) {\n+        Test17Value vt1 = new Test17Value(null);\n+        if ((Object)vt1.valueField != null) {\n+            throw new RuntimeException(\"Should be null\");\n+        }\n+        MyValue1 vt3 = MyValue1.createWithFieldsInline(rI, rL);\n+        Test17Value vt2 = new Test17Value(vt3);\n+        return b ? vt1 : vt2;\n+    }\n+\n+    @Run(test = \"test35\")\n+    public void test35_verifier() {\n+        test35(true);\n+        test35(false);\n+    }\n+\n+    \/\/ Test that when explicitly null checking a value object, we keep\n+    \/\/ track of the information that the value object can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test37(boolean b, MyValue1 vt1, MyValue1 vt2) {\n+        if (vt1 == null) {\n+            return 0;\n+        }\n+        \/\/ vt1 should be scalarized because it's always non-null\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate vt2 here\n+        test25_callee(vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test37\")\n+    public void test37_verifier() {\n+        int res = test37(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test37(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+    }\n+\n+    \/\/ Test that when explicitly null checking a value object receiver,\n+    \/\/ we keep track of the information that the value object can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test38(boolean b, MyValue1 vt1, MyValue1 vt2) {\n+        vt1.hash(); \/\/ Inlined - Explicit null check\n+        \/\/ vt1 should be scalarized because it's always non-null\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate vt2 here\n+        test25_callee(vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test38\")\n+    public void test38_verifier() {\n+        int res = test38(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test38(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+    }\n+\n+    \/\/ Test that when implicitly null checking a value object receiver,\n+    \/\/ we keep track of the information that the value object can never be null.\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test39(boolean b, MyValue1 vt1, MyValue1 vt2) {\n+        vt1.hashInterpreted(); \/\/ Not inlined - Implicit null check\n+        \/\/ vt1 should be scalarized because it's always non-null\n+        Object obj = b ? vt1 : vt2; \/\/ We should not allocate vt2 here\n+        test25_callee(vt1);\n+        return ((MyValue1)obj).x;\n+    }\n+\n+    @Run(test = \"test39\")\n+    public void test39_verifier() {\n+        int res = test39(true, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+        res = test39(false, testValue1, testValue1);\n+        Asserts.assertEquals(res, testValue1.x);\n+    }\n+\n+    \/\/ Test NPE when casting constant null to a value class\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public MyValue1 test40() {\n+        Object NULL = null;\n+        MyValue1 val = (MyValue1)NULL;\n+        return Objects.requireNonNull(val);\n+    }\n+\n+    @Run(test = \"test40\")\n+    public void test40_verifier() {\n+        try {\n+            test40();\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    MyValue1 refField;\n+    @Strict\n+    @NullRestricted\n+    MyValue1 flatField = MyValue1.DEFAULT;\n+\n+    \/\/ Test scalarization of .ref\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public int test41(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test41\")\n+    public void test41_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test41(true), refField.x);\n+        Asserts.assertEquals(test41(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test41(false), testValue1.x);\n+                test41(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    \/\/ Same as test41 but with call to hash()\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public long test42(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test42\")\n+    public void test42_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test42(true), refField.hash());\n+        Asserts.assertEquals(test42(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test42(false), testValue1.hash());\n+                test42(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test43(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = refField;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test43\")\n+    public void test43_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test43(true).hash(), refField.hash());\n+        Asserts.assertEquals(test43(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test43(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test44(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refField;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test44\")\n+    public void test44_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test44(true, false, info.getTest()), refField.x);\n+        Asserts.assertEquals(test44(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test44(false, false, info.getTest()), testValue1.x);\n+                test44(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test44(true, true, info.getTest()), refField.x);\n+            Asserts.assertEquals(test44(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test45(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = refField;\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test45\")\n+    public void test45_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test45(true, false, info.getTest()).hash(), refField.hash());\n+        Asserts.assertEquals(test45(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test45(true, false, info.getTest()), null);\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test45(true, true, info.getTest()).hash(), refField.hash());\n+            Asserts.assertEquals(test45(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public int test46(boolean b) {\n+        MyValue1 val = null;\n+        if (b) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test46\")\n+    public void test46_verifier() {\n+        Asserts.assertEquals(test46(true), testValue1.x);\n+        try {\n+            test46(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test47(boolean b) {\n+        MyValue1 val = null;\n+        if (b) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test47\")\n+    public void test47_verifier() {\n+        Asserts.assertEquals(test47(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test47(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public int test48(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val.x;\n+    }\n+\n+    @Run(test = \"test48\")\n+    public void test48_verifier() {\n+        Asserts.assertEquals(test48(false), testValue1.x);\n+        try {\n+            test48(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test49(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test49\")\n+    public void test49_verifier() {\n+        Asserts.assertEquals(test49(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test49(true), null);\n+    }\n+\n+    @ForceInline\n+    public Object test50_helper() {\n+        return flatField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public void test50(boolean b) {\n+        Object o = null;\n+        if (b) {\n+            o = testValue1;\n+        } else {\n+            o = test50_helper();\n+        }\n+        flatField = (MyValue1)o;\n+    }\n+\n+    @Run(test = \"test50\")\n+    public void test50_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatField = vt;\n+        test50(false);\n+        Asserts.assertEquals(flatField.hash(), vt.hash());\n+        test50(true);\n+        Asserts.assertEquals(flatField.hash(), testValue1.hash());\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue1Wrapper {\n+        MyValue1 vt;\n+\n+        @ForceInline\n+        public MyValue1Wrapper(MyValue1 vt) {\n+            this.vt = vt;\n+        }\n+\n+        @ForceInline\n+        public long hash() {\n+            return (vt != null) ? vt.hash() : 0;\n+        }\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    MyValue1Wrapper wrapperField = new MyValue1Wrapper(testValue1);\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public long test51(boolean b) {\n+        MyValue1Wrapper val = new MyValue1Wrapper(null);\n+        if (b) {\n+            val = wrapperField;\n+        }\n+        return val.hash();\n+    }\n+\n+    @Run(test = \"test51\")\n+    public void test51_verifier() {\n+        Asserts.assertEquals(test51(true), wrapperField.hash());\n+        Asserts.assertEquals(test51(false), (new MyValue1Wrapper(null)).hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public boolean test52(boolean b) {\n+        MyValue1 val = MyValue1.createDefaultInline();\n+        if (b) {\n+            val = null;\n+        }\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        return w.vt == null;\n+    }\n+\n+    @Run(test = \"test52\")\n+    public void test52_verifier() {\n+        Asserts.assertTrue(test52(true));\n+        Asserts.assertFalse(test52(false));\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public boolean test53(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        return w.vt == null;\n+    }\n+\n+    @Run(test = \"test53\")\n+    public void test53_verifier() {\n+        Asserts.assertTrue(test53(true));\n+        Asserts.assertFalse(test53(false));\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public long test54(boolean b1, boolean b2) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = null;\n+        }\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n+        if (b2) {\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.hash();\n+    }\n+\n+    @Run(test = \"test54\")\n+    public void test54_verifier() {\n+        MyValue1Wrapper w = new MyValue1Wrapper(MyValue1.createWithFieldsInline(rI, rL));\n+        Asserts.assertEquals(test54(false, false), (new MyValue1Wrapper(null)).hash());\n+        Asserts.assertEquals(test54(false, true), w.hash());\n+        Asserts.assertEquals(test54(true, false), (new MyValue1Wrapper(null)).hash());\n+        Asserts.assertEquals(test54(true, true), 0L);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public int test55(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test55\")\n+    public void test55_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test55(true), refField.x);\n+        Asserts.assertEquals(test55(false), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test55(false), testValue1.x);\n+                test55(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public long test56(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt.hash();\n+    }\n+\n+    @Run(test = \"test56\")\n+    public void test56_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test56(true), refField.hash());\n+        Asserts.assertEquals(test56(false), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test56(false), testValue1.hash());\n+                test56(true);\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test57(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test57\")\n+    public void test57_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test57(true).hash(), refField.hash());\n+        Asserts.assertEquals(test57(false).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test57(true), null);\n+        }\n+    }\n+\n+    \/\/ Test scalarization when .ref is referenced in safepoint debug info\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test58(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        if (b1) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test58\")\n+    public void test58_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test58(true, false, info.getTest()), refField.x);\n+        Asserts.assertEquals(test58(false, false, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test58(false, false, info.getTest()), testValue1.x);\n+                test58(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test58(true, true, info.getTest()), refField.x);\n+            Asserts.assertEquals(test58(false, true, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test59(boolean b1, boolean b2, Method m) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        if (b1) {\n+            w = new MyValue1Wrapper(refField);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test59\")\n+    public void test59_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test59(true, false, info.getTest()).hash(), refField.hash());\n+        Asserts.assertEquals(test59(false, false, info.getTest()).hash(), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            Asserts.assertEquals(test59(true, false, info.getTest()), null);\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test59(true, true, info.getTest()).hash(), refField.hash());\n+            Asserts.assertEquals(test59(false, true, info.getTest()).hash(), testValue1.hash());\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public int test60(boolean b) {\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n+        if (b) {\n+            MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test60\")\n+    public void test60_verifier() {\n+        Asserts.assertEquals(test60(true), testValue1.x);\n+        try {\n+            test60(false);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test61(boolean b) {\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n+        if (b) {\n+            MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+            w = new MyValue1Wrapper(val);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test61\")\n+    public void test61_verifier() {\n+        Asserts.assertEquals(test61(true).hash(), testValue1.hash());\n+        Asserts.assertEquals(test61(false), null);\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public int test62(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(null);\n+        }\n+        return w.vt.x;\n+    }\n+\n+    @Run(test = \"test62\")\n+    public void test62_verifier() {\n+        Asserts.assertEquals(test62(false), testValue1.x);\n+        try {\n+            test62(true);\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    public MyValue1 test63(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1Wrapper w = new MyValue1Wrapper(val);\n+        if (b) {\n+            w = new MyValue1Wrapper(null);\n+        }\n+        return w.vt;\n+    }\n+\n+    @Run(test = \"test63\")\n+    public void test63_verifier() {\n+        Asserts.assertEquals(test63(false).hash(), testValue1.hash());\n+        Asserts.assertEquals(test63(true), null);\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test64_helper() {\n+        return flatField;\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public void test64(boolean b) {\n+        MyValue1Wrapper w = new MyValue1Wrapper(null);\n+        if (b) {\n+            w = new MyValue1Wrapper(testValue1);\n+        } else {\n+            w = new MyValue1Wrapper(test64_helper());\n+        }\n+        flatField = w.vt;\n+    }\n+\n+    @Run(test = \"test64\")\n+    public void test64_verifier() {\n+        MyValue1 vt = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        flatField = vt;\n+        test64(false);\n+        Asserts.assertEquals(flatField.hash(), vt.hash());\n+        test64(true);\n+        Asserts.assertEquals(flatField.hash(), testValue1.hash());\n+    }\n+\n+    @Test\n+    @IR(failOn = {ALLOC, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS, UNSTABLE_IF_TRAP, PREDICATE_TRAP})\n+    public long test65(boolean b) {\n+        MyValue1 val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b) {\n+            val = null;\n+        }\n+        if (val != null) {\n+            return val.hashPrimitive();\n+        }\n+        return 42;\n+    }\n+\n+    @Run(test = \"test65\")\n+    public void test65_verifier() {\n+        Asserts.assertEquals(test65(true), 42L);\n+        Asserts.assertEquals(test65(false), MyValue1.createWithFieldsInline(rI, rL).hashPrimitive());\n+    }\n+\n+    @ForceInline\n+    public Object test66_helper(Object arg) {\n+        return arg;\n+    }\n+\n+    \/\/ Test that .ref arg does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test66(boolean b1, boolean b2, MyValue1 arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test66_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test66\")\n+    public void test66_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test66(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test66(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test66(false, false, arg, info.getTest()), testValue1.x);\n+                test66(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test66(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test66(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @DontInline\n+    public MyValue1 test67_helper1() {\n+        return refField;\n+    }\n+\n+    @ForceInline\n+    public Object test67_helper2() {\n+        return test67_helper1();\n+    }\n+\n+    \/\/ Test that .ref return does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public long test67(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test67_helper2();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test67\")\n+    public void test67_verifier(RunInfo info) {\n+        refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test67(true, false, info.getTest()), refField.hash());\n+        Asserts.assertEquals(test67(false, false, info.getTest()), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+            refField = null;\n+            try {\n+                Asserts.assertEquals(test67(false, false, info.getTest()), testValue1.hash());\n+                test67(true, false, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            refField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+            Asserts.assertEquals(test67(true, true, info.getTest()), refField.hash());\n+            Asserts.assertEquals(test67(false, true, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test68_helper(Object arg) {\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Test that scalarization enabled by cast is applied to parsing map\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test68(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test68_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test68\")\n+    public void test68_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test68(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test68(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test68(false, false, arg, info.getTest()), testValue1.x);\n+                test68(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test68(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test68(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test69_helper(Object arg) {\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with ClassCastException\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test69(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test69_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test69\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test69_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test69(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test69(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test69(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test69(false, false, arg, info.getTest()), testValue1.x);\n+                test69(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test69(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test69(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test70_helper(Object arg) {\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with ClassCastException and frequent NullPointerException\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test70(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test70_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test70\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test70_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test70(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test70(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test70(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test70(false, false, arg, info.getTest()), testValue1.x);\n+            test70(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test70(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test70(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test71_helper(Object arg) {\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test68 but with .ref cast\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test71(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test71_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test71\")\n+    public void test71_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test71(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test71(false, false, arg, info.getTest()), testValue1.x);\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test71(false, false, arg, info.getTest()), testValue1.x);\n+                test71(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test71(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test71(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test72_helper(Object arg) {\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test71 but with ClassCastException and hash() call\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public long test72(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test72_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test72\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test72_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test72(true, false, arg, info.getTest()), arg.hash());\n+        Asserts.assertEquals(test72(false, false, arg, info.getTest()), testValue1.hash());\n+        try {\n+            test72(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            try {\n+                Asserts.assertEquals(test72(false, false, arg, info.getTest()), testValue1.hash());\n+                test72(true, false, null, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+            Asserts.assertEquals(test72(true, true, arg, info.getTest()), arg.hash());\n+            Asserts.assertEquals(test72(false, true, arg, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test73_helper(Object arg) {\n+        MyValue1 tmp = (MyValue1)arg; \/\/ Result of cast is unused\n+        return arg;\n+    }\n+\n+    \/\/ Same as test71 but with ClassCastException and frequent NullPointerException\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public int test73(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test73_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).x;\n+    }\n+\n+    @Run(test = \"test73\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test73_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test73(true, false, arg, info.getTest()), arg.x);\n+        Asserts.assertEquals(test73(false, false, arg, info.getTest()), testValue1.x);\n+        try {\n+            test73(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test73(false, false, arg, info.getTest()), testValue1.x);\n+            test73(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test73(true, true, arg, info.getTest()), arg.x);\n+            Asserts.assertEquals(test73(false, true, arg, info.getTest()), testValue1.x);\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test74_helper(Object arg) {\n+        return (MyValue1)arg;\n+    }\n+\n+    \/\/ Same as test73 but result of cast is used and hash() is called\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public long test74(boolean b1, boolean b2, Object arg, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test74_helper(arg);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test74\")\n+    @Warmup(10000) \/\/ Make sure precise profile information is available\n+    public void test74_verifier(RunInfo info) {\n+        MyValue1 arg = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+        Asserts.assertEquals(test74(true, false, arg, info.getTest()), arg.hash());\n+        Asserts.assertEquals(test74(false, false, arg, info.getTest()), testValue1.hash());\n+        try {\n+            test74(true, false, 42, info.getTest());\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            Asserts.assertEquals(test74(false, false, arg, info.getTest()), testValue1.hash());\n+            test74(true, false, null, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test74(true, true, arg, info.getTest()), arg.hash());\n+            Asserts.assertEquals(test74(false, true, arg, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    \/\/ Test new merge path being added for exceptional control flow\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public MyValue1 test75(MyValue1 vt, Object obj) {\n+        try {\n+            vt = (MyValue1)obj;\n+            throw new RuntimeException(\"ClassCastException expected\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test75\")\n+    public void test75_verifier() {\n+        MyValue1 vt = testValue1;\n+        MyValue1 result = test75(vt, Integer.valueOf(rI));\n+        Asserts.assertEquals(result.hash(), vt.hash());\n+    }\n+\n+    @ForceInline\n+    public Object test76_helper() {\n+        return constNullRefField;\n+    }\n+\n+    \/\/ Test that constant null field does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test76(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test76_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        val = Objects.requireNonNull(val);\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test76\")\n+    public void test76_verifier(RunInfo info) {\n+        Asserts.assertEquals(test76(false, false, info.getTest()), testValue1.hash());\n+        try {\n+            test76(true, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test76(false, true, info.getTest()), testValue1.hash());\n+            try {\n+                test76(true, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    private static final Object constObjectValField = MyValue1.createWithFieldsInline(rI+1, rL+1);\n+\n+    @ForceInline\n+    public Object test77_helper() {\n+        return constObjectValField;\n+    }\n+\n+    \/\/ Test that constant object field with value class content does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test77(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test77_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test77\")\n+    public void test77_verifier(RunInfo info) {\n+        Asserts.assertEquals(test77(true, false, info.getTest()), ((MyValue1)constObjectValField).hash());\n+        Asserts.assertEquals(test77(false, false, info.getTest()), testValue1.hash());\n+        if (!info.isWarmUp()) {\n+          Asserts.assertEquals(test77(true, false, info.getTest()), ((MyValue1)constObjectValField).hash());\n+          Asserts.assertEquals(test77(false, false, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test78_helper() {\n+        return null;\n+    }\n+\n+    \/\/ Test that constant null does not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test78(boolean b1, boolean b2, Method m) {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        if (b1) {\n+            val = test78_helper();\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        val = Objects.requireNonNull(val);\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test78\")\n+    public void test78_verifier(RunInfo info) {\n+        Asserts.assertEquals(test78(false, false, info.getTest()), testValue1.hash());\n+        try {\n+            test78(true, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test78(false, true, info.getTest()), testValue1.hash());\n+            try {\n+                test78(true, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test79_helper() {\n+        return null;\n+    }\n+\n+    \/\/ Same as test78 but will trigger different order of PhiNode inputs\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test79(boolean b1, boolean b2, Method m) {\n+        Object val = test79_helper();\n+        if (b1) {\n+            val = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        if (b2) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+        }\n+        val = Objects.requireNonNull(val);\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    @Run(test = \"test79\")\n+    public void test79_verifier(RunInfo info) {\n+        Asserts.assertEquals(test79(true, false, info.getTest()), testValue1.hash());\n+        try {\n+            test79(false, false, info.getTest());\n+            throw new RuntimeException(\"NullPointerException expected\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test79(true, true, info.getTest()), testValue1.hash());\n+            try {\n+                test79(false, true, info.getTest());\n+                throw new RuntimeException(\"NullPointerException expected\");\n+            } catch (NullPointerException e) {\n+                \/\/ Expected\n+            }\n+        }\n+    }\n+\n+\/\/ TODO 8325632 Fails with -XX:+UnlockExperimentalVMOptions -XX:PerMethodSpecTrapLimit=0 -XX:PerMethodTrapLimit=0\n+\/*\n+    @ForceInline\n+    public Object test80_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test that phi nodes referencing themselves (loops) do not block scalarization\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test80() {\n+        Object val = MyValue1.createWithFieldsInline(rI, rL);\n+        for (int i = 0; i < 100; ++i) {\n+            val = test80_helper(val, i);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    private long test80Result = 0;\n+\n+    @Run(test = \"test80\")\n+    public void test80_verifier() {\n+        if (test80Result == 0) {\n+            test80Result = test80();\n+        }\n+        Asserts.assertEquals(test80(), test80Result);\n+    }\n+\n+    @ForceInline\n+    public Object test81_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test nested loops\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test81() {\n+        Object val = null;\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test81_helper(val, i + j + k);\n+                }\n+                val = test81_helper(val, i + j);\n+            }\n+            val = test81_helper(val, i);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    private long test81Result = 0;\n+\n+    @Run(test = \"test81\")\n+    public void test81_verifier() {\n+        if (test81Result == 0) {\n+            test81Result = test81();\n+        }\n+        Asserts.assertEquals(test81(), test81Result);\n+    }\n+\n+    @ForceInline\n+    public Object test82_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return MyValue1.createWithFieldsInline(i, i);\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Test loops with casts\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test82() {\n+        Object val = null;\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test82_helper(val, i + j + k);\n+                }\n+                if (val != null) {\n+                    val = test82_helper(val, i + j);\n+                }\n+            }\n+            val = test82_helper(val, i);\n+        }\n+        return ((MyValue1)val).hash();\n+    }\n+\n+    private long test82Result = 0;\n+\n+    @Run(test = \"test82\")\n+    public void test82_verifier() {\n+        if (test82Result == 0) {\n+            test82Result = test81();\n+        }\n+        Asserts.assertEquals(test82(), test82Result);\n+    }\n+*\/\n+\n+    @ForceInline\n+    public Object test83_helper(boolean b) {\n+        if (b) {\n+            return MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        return null;\n+    }\n+\n+    \/\/ Test that CastPP does not block sclarization in safepoints\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test83(boolean b, Method m) {\n+        Object val = test83_helper(b);\n+        if (val != null) {\n+            \/\/ Uncommon trap\n+            TestFramework.deoptimize(m);\n+            return ((MyValue1)val).hash();\n+        }\n+        return 0;\n+    }\n+\n+    @Run(test = \"test83\")\n+    public void test83_verifier(RunInfo info) {\n+        Asserts.assertEquals(test83(false, info.getTest()), 0L);\n+        if (!info.isWarmUp()) {\n+            Asserts.assertEquals(test83(true, info.getTest()), testValue1.hash());\n+        }\n+    }\n+\n+    @ForceInline\n+    public Object test84_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return new MyValue1Wrapper(MyValue1.createWithFieldsInline(i, i));\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Same as test80 but with wrapper\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test84() {\n+        Object val = new MyValue1Wrapper(MyValue1.createWithFieldsInline(rI, rL));\n+        for (int i = 0; i < 100; ++i) {\n+            val = test84_helper(val, i);\n+        }\n+        return ((MyValue1Wrapper)val).vt.hash();\n+    }\n+\n+    private long test84Result = 0;\n+\n+    @Run(test = \"test84\")\n+    public void test84_verifier() {\n+        if (test84Result == 0) {\n+            test84Result = test84();\n+        }\n+        Asserts.assertEquals(test84(), test84Result);\n+    }\n+\n+    @ForceInline\n+    public Object test85_helper(Object obj, int i) {\n+        if ((i % 2) == 0) {\n+            return new MyValue1Wrapper(MyValue1.createWithFieldsInline(i, i));\n+        }\n+        return obj;\n+    }\n+\n+    \/\/ Same as test81 but with wrapper\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public long test85() {\n+        Object val = new MyValue1Wrapper(null);\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                for (int k = 0; k < 10; ++k) {\n+                    val = test85_helper(val, i + j + k);\n+                }\n+                val = test85_helper(val, i + j);\n+            }\n+            val = test85_helper(val, i);\n+        }\n+        MyValue1 vt = ((MyValue1Wrapper)val).vt;\n+        vt = Objects.requireNonNull(vt);\n+        return vt.hash();\n+    }\n+\n+    private long test85Result = 0;\n+\n+    @Run(test = \"test85\")\n+    public void test85_verifier() {\n+        if (test85Result == 0) {\n+            test85Result = test85();\n+        }\n+        Asserts.assertEquals(test85(), test85Result);\n+    }\n+\n+    static final class ObjectWrapper {\n+        public Object obj;\n+\n+        @ForceInline\n+        public ObjectWrapper(Object obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    \/\/ Test scalarization with phi referencing itself\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS},\n+        counts = {LOAD_OF_ANY_KLASS, \" = 4\"}) \/\/ 4 loads from the non-flattened MyValue1.v4 fields\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS, STORE_OF_ANY_KLASS})\n+    public long test86(MyValue1 vt) {\n+        ObjectWrapper val = new ObjectWrapper(vt);\n+        for (int i = 0; i < 10; ++i) {\n+            for (int j = 0; j < 10; ++j) {\n+                val.obj = val.obj;\n+            }\n+        }\n+        return ((MyValue1)val.obj).hash();\n+    }\n+\n+    @Run(test = \"test86\")\n+    public void test86_verifier() {\n+        test86(testValue1);\n+        Asserts.assertEquals(test86(testValue1), testValue1.hash());\n+    }\n+\n+    @LooselyConsistentValue\n+    public static value class Test87C0 {\n+        int x = 0;\n+    }\n+\n+    @LooselyConsistentValue\n+    public static value class Test87C1 {\n+        @Strict\n+        @NullRestricted\n+        Test87C0 field = new Test87C0();\n+    }\n+\n+    @LooselyConsistentValue\n+    public static value class Test87C2 {\n+        @Strict\n+        @NullRestricted\n+        Test87C1 field = new Test87C1();\n+    }\n+\n+    \/\/ Test merging field loads in return\n+    @Test\n+    public Test87C1 test87(boolean b, Test87C2 v1, Test87C2 v2) {\n+        if (b) {\n+            return v1.field;\n+        } else {\n+            return v2.field;\n+        }\n+    }\n+\n+    @Run(test = \"test87\")\n+    public void test87_verifier() {\n+        Test87C2 v = new Test87C2();\n+        Asserts.assertEQ(test87(true, v, v), v.field);\n+        Asserts.assertEQ(test87(false, v, v), v.field);\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Test88Value {\n+        int x = 0;\n+    }\n+\n+    static class Test88MyClass {\n+        int x = 0;\n+        int y = rI;\n+    }\n+\n+    @ForceInline\n+    Object test88Helper() {\n+        return new Test88Value();\n+    }\n+\n+    \/\/ Test LoadNode::Identity optimization with always failing checkcast\n+    @Test\n+    public int test88() {\n+        Object obj = test88Helper();\n+        return ((Test88MyClass)obj).y;\n+    }\n+\n+    @Run(test = \"test88\")\n+    public void test88_verifier() {\n+        try {\n+            test88();\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Same as test88 but with Phi\n+    @Test\n+    public int test89(boolean b) {\n+        Test88MyClass obj = b ? (Test88MyClass)test88Helper() : (Test88MyClass)test88Helper();\n+        return obj.y;\n+    }\n+\n+    @Run(test = \"test89\")\n+    public void test89_verifier() {\n+        try {\n+            test89(false);\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            test89(true);\n+            throw new RuntimeException(\"No ClassCastException thrown\");\n+        } catch (ClassCastException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean test90_inline(MyValue1 vt) {\n+        return vt == null;\n+    }\n+\n+    \/\/ Test scalarization with speculative NULL type\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS})\n+    public boolean test90(Method m) throws Exception {\n+        Object arg = null;\n+        return (boolean)m.invoke(this, arg);\n+    }\n+\n+    @Run(test = \"test90\")\n+    @Warmup(10000)\n+    public void test90_verifier() throws Exception {\n+        Method m = getClass().getMethod(\"test90_inline\", MyValue1.class);\n+        Asserts.assertTrue(test90(m));\n+    }\n+\n+    \/\/ Test that scalarization does not introduce redundant\/unused checks\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        failOn = {ALLOC_OF_MYVALUE_KLASS, CMP_N, CMP_P})\n+    public Object test91(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @Run(test = \"test91\")\n+    public void test91_verifier() {\n+        Asserts.assertEQ(test91(testValue1), testValue1);\n+    }\n+\n+    MyValue1 test92Field = testValue1;\n+\n+    \/\/ Same as test91 but with field access\n+    @Test\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, CMP_N, CMP_P})\n+    public Object test92() {\n+        return test92Field;\n+    }\n+\n+    @Run(test = \"test92\")\n+    public void test92_verifier() {\n+        Asserts.assertEQ(test92(), testValue1);\n+    }\n+\n+    private static final MethodHandle refCheckCast = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+        \"refCheckCast\",\n+        MethodType.methodType(MyValue2.class, TestNullableInlineTypes.class, MyValue1.class),\n+        CODE -> {\n+            CODE.\n+            aload(1).\n+            checkcast(MyValue2.class.describeConstable().orElseThrow()).\n+            areturn();\n+        });\n+\n+    \/\/ Test checkcast that only passes with null\n+    @Test\n+    public Object test93(MyValue1 vt) throws Throwable {\n+        return refCheckCast.invoke(this, vt);\n+    }\n+\n+    @Run(test = \"test93\")\n+    @Warmup(10000)\n+    public void test93_verifier() throws Throwable {\n+        Asserts.assertEQ(test93(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValue1 test94_helper1(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test94_helper2(MyValue1 vt) {\n+        return test94_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public MyValue1 test94_helper3(Object vt) {\n+        return test94_helper2((MyValue1)vt);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of arguments\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \" <= 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \" <= 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n+    public MyValue1 test94(MyValue1 vt) {\n+        MyValue1 res = test94_helper1(vt);\n+        vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test94_helper1(vt);\n+        test94_helper2(vt);\n+        test94_helper3(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test94\")\n+    public void test94_verifier() {\n+        Asserts.assertEQ(test94(testValue1), testValue1);\n+        Asserts.assertEQ(test94(null), null);\n+    }\n+\n+    @DontInline\n+    public static MyValue1 test95_helper1(MyValue1 vt) {\n+        return vt;\n+    }\n+\n+    @ForceInline\n+    public static MyValue1 test95_helper2(MyValue1 vt) {\n+        return test95_helper1(vt);\n+    }\n+\n+    @ForceInline\n+    public static MyValue1 test95_helper3(Object vt) {\n+        return test95_helper2((MyValue1)vt);\n+    }\n+\n+    \/\/ Same as test94 but with static methods to trigger simple adapter logic\n+    @Test\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"true\"},\n+        counts = {ALLOC, \" <= 2\"}) \/\/ 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n+    @IR(applyIf = {\"InlineTypePassFieldsAsArgs\", \"false\"},\n+        counts = {ALLOC, \" <= 3\"}) \/\/ 1 MyValue1 allocation + 1 MyValue2 allocation + 1 Integer allocation (if not the all-zero value)\n+    public static MyValue1 test95(MyValue1 vt) {\n+        MyValue1 res = test95_helper1(vt);\n+        vt = MyValue1.createWithFieldsInline(rI, rL);\n+        test95_helper1(vt);\n+        test95_helper2(vt);\n+        test95_helper3(vt);\n+        return res;\n+    }\n+\n+    @Run(test = \"test95\")\n+    public void test95_verifier() {\n+        Asserts.assertEQ(test95(testValue1), testValue1);\n+        Asserts.assertEQ(test95(null), null);\n+    }\n+\n+    @DontInline\n+    public MyValue2 test96_helper1(boolean b) {\n+        return b ? null : MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    @ForceInline\n+    public MyValue2 test96_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValue2 test96_helper3(boolean b) {\n+        return b ? null : MyValue2.createWithFieldsInline(rI, rD);\n+    }\n+\n+    \/\/ Test that calling convention optimization prevents buffering of return values\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC, \" <= 1\"}) \/\/ No allocation required if the MyValue2 return is the all-zero value\n+    public MyValue2 test96(int c, boolean b) {\n+        MyValue2 res = null;\n+        if (c == 1) {\n+            res = test96_helper1(b);\n+        } else if (c == 2) {\n+            res = test96_helper2();\n+        } else if (c == 3) {\n+            res = test96_helper3(b);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test96\")\n+    public void test96_verifier() {\n+        Asserts.assertEQ(test96(0, false), null);\n+        Asserts.assertEQ(test96(1, false).hash(), MyValue2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test96(1, true), null);\n+        Asserts.assertEQ(test96(2, false), null);\n+        Asserts.assertEQ(test96(3, false).hash(), MyValue2.createWithFieldsInline(rI, rD).hash());\n+        Asserts.assertEQ(test96(3, true), null);\n+    }\n+\n+    @DontInline\n+    public MyValue3 test97_helper1(boolean b) {\n+        return b ? null : test97_res1;\n+    }\n+\n+    @ForceInline\n+    public MyValue3 test97_helper2() {\n+        return null;\n+    }\n+\n+    @ForceInline\n+    public MyValue3 test97_helper3(boolean b) {\n+        return b ? null : test97_res3;\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    final MyValue3 test97_res1 = MyValue3.create();\n+\n+    @Strict\n+    @NullRestricted\n+    final MyValue3 test97_res3 = MyValue3.create();\n+\n+    \/\/ Same as test96 but with MyValue3 return\n+    @Test\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"true\"},\n+        failOn = {ALLOC})\n+    @IR(applyIf = {\"InlineTypeReturnedAsFields\", \"false\"},\n+        counts = {ALLOC, \" <= 1\"}) \/\/ No allocation required if the MyValue3 return is the all-zero value\n+    public MyValue3 test97(int c, boolean b) {\n+        MyValue3 res = null;\n+        if (c == 1) {\n+            res = test97_helper1(b);\n+        } else if (c == 2) {\n+            res = test97_helper2();\n+        } else if (c == 3) {\n+            res = test97_helper3(b);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = \"test97\")\n+    public void test97_verifier() {\n+        Asserts.assertEQ(test97(0, false), null);\n+        Asserts.assertEQ(test97(1, false), test97_res1);\n+        Asserts.assertEQ(test97(1, true), null);\n+        Asserts.assertEQ(test97(2, false), null);\n+        Asserts.assertEQ(test97(3, false), test97_res3);\n+        Asserts.assertEQ(test97(3, true), null);\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class CircularValue1 {\n+        CircularValue1 val;\n+        int x;\n+\n+        @ForceInline\n+        public CircularValue1(CircularValue1 val) {\n+            this.val = val;\n+            this.x = rI;\n+        }\n+    }\n+\n+    \/\/ Test scalarization of value class with circularity in fields\n+    @Test\n+    public CircularValue1 test98(CircularValue1 val) {\n+        return new CircularValue1(val);\n+    }\n+\n+    @Run(test = \"test98\")\n+    public void test98_verifier()  {\n+        CircularValue1 val = new CircularValue1(null);\n+        CircularValue1 res = test98(val);\n+        Asserts.assertEQ(res.x, rI);\n+        Asserts.assertEQ(res.val, val);\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class CircularValue2 {\n+        @Strict\n+        @NullRestricted\n+        CircularValue1 val;\n+\n+        @ForceInline\n+        public CircularValue2(CircularValue1 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as test98 but with circularity in class of flattened field\n+    @Test\n+    public CircularValue2 test99(CircularValue2 val) {\n+        return new CircularValue2(val.val);\n+    }\n+\n+    @Run(test = \"test99\")\n+    public void test99_verifier()  {\n+        CircularValue1 val1 = new CircularValue1(null);\n+        CircularValue2 val2 = new CircularValue2(val1);\n+        CircularValue2 res = test99(val2);\n+        Asserts.assertEQ(res.val, val1);\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class CircularValue3 {\n+        CircularValue4 val;\n+        int x;\n+\n+        @ForceInline\n+        public CircularValue3(CircularValue4 val, int x) {\n+            this.val = val;\n+            this.x = x;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class CircularValue4 {\n+        @Strict\n+        @NullRestricted\n+        CircularValue3 val;\n+\n+        @ForceInline\n+        public CircularValue4(CircularValue3 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as test94 but with \"indirect\" circularity through field of flattened field\n+    @Test\n+    public CircularValue4 test100(CircularValue4 val) {\n+        return new CircularValue4(new CircularValue3(val, rI));\n+    }\n+\n+    @Run(test = \"test100\")\n+    public void test100_verifier()  {\n+        CircularValue3 val3 = new CircularValue3(null, 42);\n+        CircularValue4 val4 = new CircularValue4(val3);\n+        CircularValue4 res = test100(val4);\n+        Asserts.assertEQ(res.val, new CircularValue3(val4, rI));\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class CircularValue5 {\n+        @Strict\n+        @NullRestricted\n+        CircularValue6 val;\n+        int x;\n+\n+        @ForceInline\n+        public CircularValue5(CircularValue6 val, int x) {\n+            this.val = val;\n+            this.x = x;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class CircularValue6 {\n+        CircularValue5 val;\n+\n+        @ForceInline\n+        public CircularValue6(CircularValue5 val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Same as test100 but with different combination of field types\n+    @Test\n+    public CircularValue6 test101(CircularValue6 val) {\n+        return new CircularValue6(new CircularValue5(val, rI));\n+    }\n+\n+    @Run(test = \"test101\")\n+    public void test101_verifier()  {\n+        CircularValue5 val5 = new CircularValue5(new CircularValue6(null), 42);\n+        CircularValue6 val6 = new CircularValue6(val5);\n+        CircularValue6 res = test101(val6);\n+        Asserts.assertEQ(res.val, new CircularValue5(val6, rI));\n+    }\n+\n+    \/\/ Test merging of fields with different scalarization depth\n+    @Test\n+    public CircularValue1 test102(boolean b) {\n+        CircularValue1 val = new CircularValue1(new CircularValue1(null));\n+        if (b) {\n+            val = null;\n+        }\n+        return val;\n+    }\n+\n+    @Run(test = \"test102\")\n+    public void test102_verifier() {\n+        Asserts.assertEQ(test102(false), new CircularValue1(new CircularValue1(null)));\n+        Asserts.assertEQ(test102(true), null);\n+    }\n+\n+    \/\/ Might be incrementally inlined\n+    public static Object hide(Object obj) {\n+        return (MyValue1)obj;\n+    }\n+\n+    \/\/ Test that the ConstraintCastNode::Ideal transformation propagates null-free information\n+    @Test\n+    public MyValue1 test103() {\n+        Object obj = hide(null);\n+        return (MyValue1)obj;\n+    }\n+\n+    @Run(test = \"test103\")\n+    public void test103_verifier() {\n+        Asserts.assertEQ(test103(), null);\n+    }\n+\n+    \/\/ Test null restricted fields\n+\n+    @LooselyConsistentValue\n+    static value class MyValue104 {\n+        @Strict\n+        @NullRestricted\n+        static MyValue105 field1 = new MyValue105();\n+\n+        @Strict\n+        @NullRestricted\n+        MyValue105 field2;\n+\n+        @Strict\n+        @NullRestricted\n+        static MyValueEmpty field3 = new MyValueEmpty();\n+\n+        @Strict\n+        @NullRestricted\n+        MyValueEmpty field4;\n+\n+        @ForceInline\n+        public MyValue104() {\n+            this.field1 = new MyValue105();\n+            this.field2 = new MyValue105();\n+            this.field3 = new MyValueEmpty();\n+            this.field4 = new MyValueEmpty();\n+        }\n+\n+        @ForceInline\n+        public MyValue104(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+            this.field1 = val1;\n+            this.field2 = val2;\n+            this.field3 = val3;\n+            this.field4 = val4;\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class MyValue105 {\n+        int x = 42;\n+    }\n+\n+    @Strict\n+    @NullRestricted\n+    static MyValue104 field1 = new MyValue104();\n+\n+    @Strict\n+    @NullRestricted\n+    MyValue104 field2 = new MyValue104();\n+\n+    @Strict\n+    @NullRestricted\n+    static MyValueEmpty field3 = new MyValueEmpty();\n+\n+    @Strict\n+    @NullRestricted\n+    MyValueEmpty field4 = new MyValueEmpty();\n+\n+    @Test\n+    void test105(MyValue104 arg) {\n+        field1 = arg;\n+    }\n+\n+    @Run(test = \"test105\")\n+    public void test105_verifier() {\n+        try {\n+            test105(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test106() {\n+        field1 = null;\n+    }\n+\n+    @Run(test = \"test106\")\n+    public void test106_verifier() {\n+        try {\n+            test106();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test107(MyValue104 arg) {\n+        field2 = arg;\n+    }\n+\n+    @Run(test = \"test107\")\n+    public void test107_verifier() {\n+        try {\n+            test107(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test108(TestNullableInlineTypes t, MyValue104 arg) {\n+        t.field2 = arg;\n+    }\n+\n+    @Run(test = \"test108\")\n+    public void test108_verifier() {\n+        try {\n+            test108(null, new MyValue104());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test109() {\n+        TestNullableInlineTypes t = null;\n+        t.field2 = null;\n+    }\n+\n+    @Run(test = \"test109\")\n+    void test109_verifier() {\n+        try {\n+            test109();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test110() {\n+        field2 = null;\n+    }\n+\n+    @Run(test = \"test110\")\n+    public void test110_verifier() {\n+        try {\n+            test110();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test111(MyValueEmpty arg) {\n+        field3 = arg;\n+    }\n+\n+    @Run(test = \"test111\")\n+    public void test111_verifier() {\n+        try {\n+            test111(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test112() {\n+        field3 = null;\n+    }\n+\n+    @Run(test = \"test112\")\n+    public void test112_verifier() {\n+        try {\n+            test112();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test113(MyValueEmpty arg) {\n+        field4 = arg;\n+    }\n+\n+    @Run(test = \"test113\")\n+    public void test113_verifier() {\n+        try {\n+            test113(null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test114(TestNullableInlineTypes t, MyValueEmpty arg) {\n+        t.field4 = arg;\n+    }\n+\n+    @Run(test = \"test114\")\n+    public void test114_verifier() {\n+        try {\n+            test114(null, new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test115(MyValueEmpty arg) {\n+        TestNullableInlineTypes t = null;\n+        t.field4 = arg;\n+    }\n+\n+    @Run(test = \"test115\")\n+    public void test115_verifier() {\n+        try {\n+            test115(new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    void test116() {\n+        field4 = null;\n+    }\n+\n+    @Run(test = \"test116\")\n+    public void test116_verifier() {\n+        try {\n+            test116();\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test117(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test117\")\n+    public void test117_verifier() {\n+        try {\n+            test117(null, new MyValue105(), new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test118(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test118\")\n+    public void test118_verifier() {\n+        try {\n+            test118(new MyValue105(), null, new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test119(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test119\")\n+    public void test119_verifier() {\n+        try {\n+            test119(new MyValue105(), new MyValue105(), null, new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test120(MyValue105 val1, MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test120\")\n+    public void test120_verifier() {\n+        try {\n+            test120(new MyValue105(), new MyValue105(), new MyValueEmpty(), null);\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test121(MyValue105 val2, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(null, val2, val3, val4);\n+    }\n+\n+    @Run(test = \"test121\")\n+    public void test121_verifier() {\n+        try {\n+            test121(new MyValue105(), new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test122(MyValue105 val1, MyValueEmpty val3, MyValueEmpty val4) {\n+        return new MyValue104(val1, null, val3, val4);\n+    }\n+\n+    @Run(test = \"test122\")\n+    public void test122_verifier() {\n+        try {\n+            test122(new MyValue105(), new MyValueEmpty(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test123(MyValue105 val1, MyValue105 val2, MyValueEmpty val4) {\n+        return new MyValue104(val1, val2, null, val4);\n+    }\n+\n+    @Run(test = \"test123\")\n+    public void test123_verifier() {\n+        try {\n+            test123(new MyValue105(), new MyValue105(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    @Test\n+    MyValue104 test124(MyValue105 val1, MyValue105 val2, MyValueEmpty val3) {\n+        return new MyValue104(val1, val2, val3, null);\n+    }\n+\n+    @Run(test = \"test124\")\n+    public void test124_verifier() {\n+        try {\n+            test124(new MyValue105(), new MyValue105(), new MyValueEmpty());\n+            throw new RuntimeException(\"No exception thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static value class CircularValue7 {\n+        CircularValue7 v;\n+        int i;\n+\n+        public CircularValue7(int i) {\n+            this.v = new CircularValue7(); \/\/ When <init> is incrementally inlined: StoreN into object\n+            dontInline(); \/\/ Not inlined -> safepoint which also saves StoreN.\n+            this.i = i;\n+        }\n+\n+        public CircularValue7(boolean ignored) {\n+            this.v = new CircularValue7();\n+            this.i = 23;\n+        }\n+\n+        public CircularValue7() {\n+            this.v = null;\n+            this.i = 34;\n+        }\n+\n+        @DontInline\n+        static void dontInline() {}\n+    }\n+\n+    @Test\n+    @IR(failOn = ALLOC)\n+    int testCircularSafepointUse() {\n+        CircularValue7 v = new CircularValue7(true);  \/\/ v is non escaping -> EA can remove allocation\n+        dontInline(); \/\/ Not inlined -> safepoint\n+        return v.i; \/\/ Use v such that it is still required in the safepoint at dontInline()\n+    }\n+\n+    @DontInline\n+    void dontInline() {}\n+\n+    @Run(test = \"testCircularSafepointUse\")\n+    public void testCircularSafepointUse_verifier() {\n+        Asserts.assertEQ(testCircularSafepointUse(), new CircularValue7(true).i);\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = ALLOC)\n+    int testCircularSafepointUse2(int i) {\n+        \/\/ With AlwaysIncrementalInline:\n+        \/\/ We allocate here because <init> is not inlined at parsing.\n+        \/\/ At late inline: The store of v.v is done with a StoreN into the allocation to make the effect visible.\n+        CircularValue7 v = new CircularValue7(i);\n+        return v.i;\n+    }\n+\n+    @Run(test = \"testCircularSafepointUse2\")\n+    public void testCircularSafepointUse2_verifier() {\n+        int rand = rI;\n+        Asserts.assertEQ(testCircularSafepointUse2(rand), new CircularValue7(rand).i);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":3353,"deletions":0,"binary":false,"changes":3353,"status":"added"},{"patch":"@@ -0,0 +1,320 @@\n+\/*\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.ALLOC_OF_MYVALUE_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.LOAD_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypeIRNode.STORE_OF_ANY_KLASS;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rI;\n+import static compiler.valhalla.inlinetypes.InlineTypes.rL;\n+\n+import static compiler.lib.ir_framework.IRNode.LOAD_OF_CLASS;\n+import static compiler.lib.ir_framework.IRNode.STORE_OF_CLASS;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test on stack replacement (OSR) with value classes.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestOnStackReplacement\n+ *\/\n+\n+public class TestOnStackReplacement {\n+\n+    public static void main(String[] args) throws Throwable {\n+        Scenario[] scenarios = InlineTypes.DEFAULT_SCENARIOS;\n+        scenarios[3].addFlags(\"-XX:-UseArrayFlattening\");\n+\n+        InlineTypes.getFramework()\n+                   .addScenarios(scenarios)\n+                   .addHelperClasses(MyValue1.class,\n+                                     MyValue2.class,\n+                                     MyValue2Inline.class,\n+                                     MyValue3.class,\n+                                     MyValue3Inline.class)\n+                   .start();\n+    }\n+\n+    \/\/ Helper methods\n+\n+    protected long hash() {\n+        return hash(rI, rL);\n+    }\n+\n+    protected long hash(int x, long y) {\n+        return MyValue1.createWithFieldsInline(x, y).hash();\n+    }\n+\n+    \/\/ Test OSR compilation\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public long test1() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(rI, rL);\n+        MyValue1[] va = (MyValue1[])ValueClass.newNullRestrictedNonAtomicArray(MyValue1.class, Math.abs(rI) % 3, MyValue1.DEFAULT);\n+        for (int i = 0; i < va.length; ++i) {\n+            va[i] = MyValue1.createWithFieldsInline(rI, rL);\n+        }\n+        long result = 0;\n+        \/\/ Long loop to trigger OSR compilation\n+        for (int i = 0; i < 50_000; ++i) {\n+            \/\/ Reference local value object in interpreter state\n+            result = v.hash();\n+            for (int j = 0; j < va.length; ++j) {\n+                result += va[j].hash();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(0)\n+    public void test1_verifier() {\n+        long result = test1();\n+        Asserts.assertEQ(result, ((Math.abs(rI) % 3) + 1) * hash());\n+    }\n+\n+    \/\/ Test loop peeling\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    @IR(failOn = {ALLOC_OF_MYVALUE_KLASS, LOAD_OF_ANY_KLASS, STORE_OF_ANY_KLASS})\n+    public void test2() {\n+        MyValue1 v = MyValue1.createWithFieldsInline(0, 1);\n+        \/\/ Trigger OSR compilation and loop peeling\n+        for (int i = 0; i < 50_000; ++i) {\n+            if (v.x != i || v.y != i + 1) {\n+                \/\/ Uncommon trap\n+                throw new RuntimeException(\"test2 failed\");\n+            }\n+            v = MyValue1.createWithFieldsInline(i + 1, i + 2);\n+        }\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(0)\n+    public void test2_verifier() {\n+        test2();\n+    }\n+\n+    \/\/ Test loop peeling and unrolling\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test3() {\n+        MyValue1 v1 = MyValue1.createWithFieldsInline(0, 0);\n+        MyValue1 v2 = MyValue1.createWithFieldsInline(1, 1);\n+        \/\/ Trigger OSR compilation and loop peeling\n+        for (int i = 0; i < 50_000; ++i) {\n+            if (v1.x != 2*i || v2.x != i+1 || v2.y != i+1) {\n+                \/\/ Uncommon trap\n+                throw new RuntimeException(\"test3 failed\");\n+            }\n+            v1 = MyValue1.createWithFieldsInline(2*(i+1), 0);\n+            v2 = MyValue1.createWithFieldsInline(i+2, i+2);\n+        }\n+    }\n+\n+    \/\/@Run(test = \"test3\")\n+    \/\/@Warmup(0)\n+    public void test3_verifier() {\n+        test3();\n+    }\n+\n+    \/\/ OSR compilation with Object local\n+    @DontCompile\n+    public Object test4_init() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @DontCompile\n+    public Object test4_body() {\n+        return MyValue1.createWithFieldsInline(rI, rL);\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public Object test4() {\n+        Object vt = test4_init();\n+        for (int i = 0; i < 50_000; i++) {\n+            if (i % 2 == 1) {\n+                vt = test4_body();\n+            }\n+        }\n+        return vt;\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(0)\n+    public void test4_verifier() {\n+        test4();\n+    }\n+\n+    \/\/ OSR compilation with null value class local\n+\n+    MyValue1 nullField;\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test5() {\n+        MyValue1 vt = nullField;\n+        for (int i = 0; i < 50_000; i++) {\n+            if (vt != null) {\n+                throw new RuntimeException(\"test5 failed: vt should be null\");\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(0)\n+    public void test5_verifier() {\n+        test5();\n+    }\n+\n+    \/\/ Test OSR in method with value class receiver\n+    @LooselyConsistentValue\n+    value class Test6Value {\n+        public int f = 0;\n+\n+        public int test() {\n+            int res = 0;\n+            for (int i = 1; i < 20_000; ++i) {\n+                res -= i;\n+            }\n+            return res;\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test6() {\n+        Test6Value tmp = new Test6Value();\n+        for (int i = 0; i < 100; ++i) {\n+            tmp.test();\n+        }\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(0)\n+    public void test6_verifier() {\n+        test6();\n+    }\n+\n+    \/\/ Similar to test6 but with more fields and reserved stack entry\n+    @LooselyConsistentValue\n+    static value class Test7Value1 {\n+        public int i1 = rI;\n+        public int i2 = rI;\n+        public int i3 = rI;\n+        public int i4 = rI;\n+        public int i5 = rI;\n+        public int i6 = rI;\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Test7Value2 {\n+        public int i1 = rI;\n+        public int i2 = rI;\n+        public int i3 = rI;\n+        public int i4 = rI;\n+        public int i5 = rI;\n+        public int i6 = rI;\n+        public int i7 = rI;\n+        public int i8 = rI;\n+        public int i9 = rI;\n+        public int i10 = rI;\n+        public int i11 = rI;\n+        public int i12 = rI;\n+        public int i13 = rI;\n+        public int i14 = rI;\n+        public int i15 = rI;\n+        public int i16 = rI;\n+        public int i17 = rI;\n+        public int i18 = rI;\n+        public int i19 = rI;\n+        public int i20 = rI;\n+        public int i21 = rI;\n+\n+        @Strict\n+        @NullRestricted\n+        public Test7Value1 vt = new Test7Value1();\n+\n+        public int test(String[] args) {\n+            int res = 0;\n+            for (int i = 1; i < 20_000; ++i) {\n+                res -= i;\n+            }\n+            return res;\n+        }\n+    }\n+\n+    @Test(compLevel = CompLevel.WAIT_FOR_COMPILATION)\n+    public void test7() {\n+        Test7Value2 tmp = new Test7Value2();\n+        for (int i = 0; i < 10; ++i) {\n+            tmp.test(null);\n+        }\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(0)\n+    public void test7_verifier() {\n+        test7();\n+    }\n+\n+    \/\/ Test OSR with scalarized value class return\n+    MyValue3 test8_vt;\n+\n+    @DontInline\n+    public MyValue3 test8_callee(int len) {\n+        test8_vt = MyValue3.create();\n+        int val = 0;\n+        for (int i = 0; i < len; ++i) {\n+            val = i;\n+        }\n+        test8_vt = test8_vt.setI(test8_vt, val);\n+        return test8_vt;\n+    }\n+\n+    @Test\n+    public int test8(int start) {\n+        MyValue3 vt = test8_callee(start);\n+        test8_vt.verify(vt);\n+        int result = 0;\n+        for (int i = 0; i < 50_000; ++i) {\n+            result += i;\n+        }\n+        return result;\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(2)\n+    public void test8_verifier() {\n+        test8(1);\n+        test8(50_000);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":320,"deletions":0,"binary":false,"changes":320,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test that oop fields in scalarized returns are properly handled.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention Interpreted\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C1\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C2\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+StressCallingConvention\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention Interpreted\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+StressCallingConvention\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C1\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+StressCallingConvention\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C2\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:-PreloadClasses\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention Interpreted\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:-PreloadClasses\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C1\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-TieredCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:-PreloadClasses\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention::callee\n+ *                   -XX:CompileCommand=dontinline,TestOopsInReturnConvention*::verify\n+ *                   TestOopsInReturnConvention C2\n+ **\/\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestOopsInReturnConvention {\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+\n+    \/\/ Large value class with oops\n+    static value class LargeValueWithOops {\n+        Object x1;\n+        Object x2;\n+        Object x3;\n+        Object x4;\n+        Object x5;\n+\n+        public LargeValueWithOops(Object obj) {\n+            this.x1 = obj;\n+            this.x2 = obj;\n+            this.x3 = obj;\n+            this.x4 = obj;\n+            this.x5 = obj;\n+        }\n+\n+        public static void verify(LargeValueWithOops val, Object obj, boolean useNull) {\n+            if (useNull) {\n+                Asserts.assertEQ(val, null);\n+            } else {\n+                Asserts.assertEQ(val.x1, obj);\n+                Asserts.assertEQ(val.x2, obj);\n+                Asserts.assertEQ(val.x3, obj);\n+                Asserts.assertEQ(val.x4, obj);\n+                Asserts.assertEQ(val.x5, obj);\n+            }\n+        }\n+    }\n+\n+    \/\/ Pass some unused args to make sure that the (return) registers are trashed\n+    public static LargeValueWithOops callee(int unused1, int unused2, int unused3, int unused4, int unused5, LargeValueWithOops val) {\n+        return val;\n+    }\n+\n+    public static void caller(LargeValueWithOops val, Object obj, boolean useNull) {\n+        \/\/ Below call will return a LargeValueWithOops in scalarized form.\n+        \/\/ If it's null, the x1 - x5 oop fields need to be zeroed to make the GC happy.\n+        val = callee(1, 2, 3, 4, 5, val);\n+        LargeValueWithOops.verify(val, obj, useNull);\n+    }\n+\n+    static class GarbageProducerThread extends Thread {\n+        public void run() {\n+            for (;;) {\n+                \/\/ Produce some garbage and then let the GC do its work\n+                Object[] arrays = new Object[1024];\n+                for (int i = 0; i < arrays.length; i++) {\n+                    arrays[i] = new int[1024];\n+                }\n+                System.gc();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args[0].equals(\"Interpreted\") || args[0].equals(\"C1\")) {\n+            \/\/ Prevent callee method from being C2 compiled to ensure it's interpreted or C1 compiled\n+            Method m = TestOopsInReturnConvention.class.getDeclaredMethod(\"callee\", int.class, int.class, int.class, int.class, int.class, LargeValueWithOops.class);\n+            WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+        }\n+\n+        \/\/ Start another thread that does some allocations and calls System.gc() to trigger frequent GCs\n+        Thread garbage_producer = new GarbageProducerThread();\n+        garbage_producer.setDaemon(true);\n+        garbage_producer.start();\n+\n+        \/\/ Trigger compilation\n+        for (int i = 0; i < 500_000; i++) {\n+            boolean useNull = (i % 2) == 0;\n+            LargeValueWithOops val = useNull ? null : new LargeValueWithOops(i);\n+            caller(val, i, useNull);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOopsInReturnConvention.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,1826 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.classfile.Label;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+\/**\n+ * @test id=Xbatch\n+ * @summary Test construction of value objects.\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=DeoptimizeALot\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=CompileonlyTest\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=compileonly,*TestValueConstruction::test* -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/**\n+ * @test id=DontInlineHelper\n+ * @summary Test construction of value objects.\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:CompileCommand=dontinline,compiler*::helper*\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineMyValueInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=dontinline,*MyValue*::<init> -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineObjectInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=dontinline,*Object::<init> -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineObjectInitDeoptimizeALot\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+DeoptimizeALot -XX:CompileCommand=dontinline,*Object::<init> -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=DontInlineMyAbstractInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=dontinline,*MyAbstract::<init> -Xbatch\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInlining\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInliningCompileOnlyTest\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   -XX:CompileCommand=compileonly,*TestValueConstruction::test* -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/* @test id=StressIncrementalInliningDontInlineMyValueInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   -XX:CompileCommand=dontinline,*MyValue*::<init> -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInliningDontInlineObjectInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   -XX:CompileCommand=dontinline,*Object::<init> -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInliningDontInlineMyAbstractInit\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=inline,TestValueConstruction::checkDeopt\n+ *                   -XX:CompileCommand=dontinline,*MyAbstract::<init> -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+\/*\n+ * @test id=StressIncrementalInliningOnStackReplacement\n+ * @key randomness\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/test\/jdk\/java\/lang\/invoke\/common \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox test.java.lang.invoke.lib.InstructionHelper\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-TieredCompilation -XX:+StressIncrementalInlining\n+ *                   -XX:Tier0BackedgeNotifyFreqLog=0 -XX:Tier2BackedgeNotifyFreqLog=0 -XX:Tier3BackedgeNotifyFreqLog=0\n+ *                   -XX:Tier2BackEdgeThreshold=1 -XX:Tier3BackEdgeThreshold=1 -XX:Tier4BackEdgeThreshold=1 -Xbatch\n+ *                   compiler.valhalla.inlinetypes.TestValueConstruction\n+ *\/\n+\n+public class TestValueConstruction {\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    static boolean VERBOSE = false;\n+    static boolean[] deopt = new boolean[14];\n+    static boolean[] deoptBig = new boolean[24];\n+    static boolean[] deoptHuge = new boolean[37];\n+\n+    static Object o = new Object();\n+\n+    static void reportDeopt(int deoptNum) {\n+        System.out.println(\"Deopt \" + deoptNum + \" triggered\");\n+        if (VERBOSE) {\n+            new Exception().printStackTrace(System.out);\n+        }\n+    }\n+\n+    \/\/ Trigger deopts at various places\n+    static void checkDeopt(int deoptNum) {\n+        if (deopt[deoptNum]) {\n+            \/\/ C2 will add an uncommon trap here\n+            reportDeopt(deoptNum);\n+        }\n+    }\n+\n+    \/\/ Trigger deopts at various places\n+    static void checkDeoptBig(int deoptNum) {\n+        if (deoptBig[deoptNum]) {\n+            \/\/ C2 will add an uncommon trap here\n+            reportDeopt(deoptNum);\n+        }\n+    }\n+\n+    \/\/ Trigger deopts at various places\n+    static void checkDeoptHuge(int deoptNum) {\n+        if (deoptHuge[deoptNum]) {\n+            \/\/ C2 will add an uncommon trap here\n+            reportDeopt(deoptNum);\n+        }\n+    }\n+\n+    static interface MyInterface {\n+\n+    }\n+\n+    static value class MyValue1 implements MyInterface {\n+        int x;\n+\n+        public MyValue1(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public MyValue1(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super();\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static value class MyValue1a extends MyAbstract1 implements MyInterface {\n+        int x;\n+\n+        public MyValue1a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public MyValue1a(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super();\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static abstract value class AMyValue1 implements MyInterface {\n+        int x;\n+\n+        public AMyValue1(int x) {\n+            checkDeopt(3);\n+            this.x = x;\n+            checkDeopt(4);\n+            super();\n+            checkDeopt(5);\n+        }\n+\n+        public AMyValue1(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super();\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static value class MyValue1b extends AMyValue1 implements MyInterface {\n+        int x;\n+\n+        public MyValue1b(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super(x);\n+            checkDeopt(2);\n+        }\n+\n+        public MyValue1b(int x, int deoptNum1, int deoptNum2, int deoptNum3) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            super(x, deoptNum1 + 3, deoptNum2 + 3, deoptNum3 + 3);\n+            checkDeopt(deoptNum3);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+\n+    static abstract value class MyAbstract1 { }\n+\n+    static value class MyValue2 extends MyAbstract1 {\n+        int x;\n+\n+        public MyValue2(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static abstract value class MyAbstract2 {\n+        public MyAbstract2(int x) {\n+            checkDeopt(0);\n+        }\n+    }\n+\n+    static value class MyValue3 extends MyAbstract2 {\n+        int x;\n+\n+        public MyValue3(int x) {\n+            checkDeopt(1);\n+            this(x, 0);\n+            helper1(this, x, 2); \/\/ 'this' escapes through argument\n+            helper2(x, 3); \/\/ 'this' escapes through receiver\n+            checkDeopt(4);\n+        }\n+\n+        public MyValue3(int x, int unused) {\n+            this.x = helper3(x, 5);\n+            super(x);\n+            helper1(this, x, 6); \/\/ 'this' escapes through argument\n+            helper2(x, 7); \/\/ 'this' escapes through receiver\n+            checkDeopt(8);\n+        }\n+\n+        public static void helper1(MyValue3 obj, int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(obj.x, x);\n+        }\n+\n+        public void helper2(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(this.x, x);\n+        }\n+\n+        public static int helper3(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            return x;\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static abstract value class AMyValue3a {\n+        int x;\n+\n+        public AMyValue3a(int x) {\n+            this.x = helper3(x, 5);\n+            super();\n+            helper1(this, x, 6); \/\/ 'this' escapes through argument\n+            helper2(x, 7); \/\/ 'this' escapes through receiver\n+            checkDeopt(8);\n+        }\n+\n+        public static void helper1(AMyValue3a obj, int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(obj.x, x);\n+        }\n+\n+        public void helper2(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(this.x, x);\n+        }\n+\n+        public static int helper3(int x, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            return x;\n+        }\n+    }\n+\n+    static value class MyValue3a extends AMyValue3a {\n+        int y;\n+\n+        public MyValue3a(int y) {\n+            checkDeopt(1);\n+            this.y = helper3(y, 5);\n+            super(y);\n+            helper1(this, y, 2); \/\/ 'this' escapes through argument\n+            helper2(y, 3); \/\/ 'this' escapes through receiver\n+            checkDeopt(4);\n+        }\n+\n+\n+        public static void helper1(MyValue3a obj, int y, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(obj.y, y);\n+        }\n+\n+        public void helper2(int y, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            Asserts.assertEQ(this.y, y);\n+        }\n+\n+        public static int helper3(int y, int deoptNum) {\n+            checkDeopt(deoptNum);\n+            return y;\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + y;\n+        }\n+    }\n+\n+    static value class MyValue4 {\n+        Integer x;\n+\n+        public MyValue4(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    abstract static value class AMyValue4a {\n+        Integer y;\n+\n+        public AMyValue4a(int y) {\n+            checkDeopt(3);\n+            this.y = y;\n+            checkDeopt(4);\n+            super();\n+            checkDeopt(5);\n+        }\n+\n+        public String toString() {\n+            return \"y: \" + y;\n+        }\n+    }\n+\n+    static value class MyValue4a extends AMyValue4a {\n+        Integer x;\n+\n+        public MyValue4a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            super(x);\n+            checkDeopt(2);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static value class MyValue5 extends MyAbstract1 {\n+        int x;\n+\n+        public MyValue5(int x, boolean b) {\n+            checkDeopt(0);\n+            if (b) {\n+                checkDeopt(1);\n+                this.x = 42;\n+                checkDeopt(2);\n+            } else {\n+                checkDeopt(3);\n+                this.x = x;\n+                checkDeopt(4);\n+            }\n+            checkDeopt(5);\n+            super();\n+            checkDeopt(6);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static abstract value class AMyValue5a {\n+        int y;\n+\n+        public AMyValue5a(int y, boolean b) {\n+            checkDeopt(7);\n+            if (b) {\n+                checkDeopt(8);\n+                this.y = 42;\n+                checkDeopt(9);\n+            } else {\n+                checkDeopt(10);\n+                this.y = y;\n+                checkDeopt(11);\n+            }\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n+        }\n+\n+        public String toString() {\n+            return \"y: \" + y;\n+        }\n+    }\n+\n+    static value class MyValue5a extends AMyValue5a {\n+        int x;\n+\n+        public MyValue5a(int x, boolean b) {\n+            checkDeopt(0);\n+            if (b) {\n+                checkDeopt(1);\n+                this.x = 42;\n+                checkDeopt(2);\n+            } else {\n+                checkDeopt(3);\n+                this.x = x;\n+                checkDeopt(4);\n+            }\n+            checkDeopt(5);\n+            super(x, b);\n+            checkDeopt(6);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    static value class MyValue6 {\n+        int x;\n+        MyValue1 val1;\n+        MyValue1 val2;\n+\n+        public MyValue6(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            this.val1 = new MyValue1(x, 2, 3, 4);\n+            checkDeopt(5);\n+            this.val2 = new MyValue1(x + 1, 6, 7, 8);\n+            checkDeopt(9);\n+            super();\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + val1 + \"], val2: [\" + val2 + \"]\";\n+        }\n+    }\n+\n+    static value class MyValue6a {\n+        int x;\n+        MyValue1a val1;\n+        MyValue1a val2;\n+\n+        public MyValue6a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            this.val1 = new MyValue1a(x, 2, 3, 4);\n+            checkDeopt(5);\n+            this.val2 = new MyValue1a(x + 1, 6, 7, 8);\n+            checkDeopt(9);\n+            super();\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + val1 + \"], val2: [\" + val2 + \"]\";\n+        }\n+    }\n+\n+    static value class MyValue6b {\n+        int x;\n+        MyValue1b val1;\n+        MyValue1b val2;\n+\n+        public MyValue6b(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            this.val1 = new MyValue1b(x, 2, 3, 4);\n+            checkDeopt(5);\n+            this.val2 = new MyValue1b(x + 1, 6, 7, 8);\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + val1 + \"], val2: [\" + val2 + \"]\";\n+        }\n+    }\n+\n+    \/\/ Same as MyValue6 but unused MyValue1 construction\n+    static value class MyValue7 {\n+        int x;\n+\n+        public MyValue7(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            new MyValue1(42, 2, 3, 4);\n+            checkDeopt(5);\n+            new MyValue1(43, 6, 7, 8);\n+            checkDeopt(9);\n+            super();\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Same as MyValue6 but unused MyValue1 construction\n+    static value class MyValue7a {\n+        int x;\n+\n+        public MyValue7a(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            new MyValue1a(42, 2, 3, 4);\n+            checkDeopt(5);\n+            new MyValue1a(43, 6, 7, 8);\n+            checkDeopt(9);\n+            super();\n+            checkDeopt(10);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Same as MyValue6 but unused MyValue1 construction\n+    static value class MyValue7b {\n+        int x;\n+\n+        public MyValue7b(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            new MyValue1b(42, 2, 3, 4);\n+            checkDeopt(5);\n+            new MyValue1b(43, 6, 7, 8);\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of the same value class with control flow dependent initialization\n+    static value class MyValue8 {\n+        int x;\n+\n+        public MyValue8(int x) {\n+            checkDeopt(0);\n+            this(x, 0);\n+            checkDeopt(1);\n+        }\n+\n+        public MyValue8(int x, int unused1) {\n+            checkDeopt(2);\n+            if ((x % 2) == 0) {\n+                checkDeopt(3);\n+                this.x = 42;\n+                checkDeopt(4);\n+            } else {\n+                checkDeopt(5);\n+                this.x = x;\n+                checkDeopt(6);\n+            }\n+            checkDeopt(7);\n+            super();\n+            checkDeopt(8);\n+        }\n+\n+        public MyValue8(int x, int unused1, int unused2) {\n+            checkDeopt(3);\n+            this.x = x;\n+            checkDeopt(4);\n+        }\n+\n+        public static MyValue8 valueOf(int x) {\n+            checkDeopt(0);\n+            if ((x % 2) == 0) {\n+                checkDeopt(1);\n+                return new MyValue8(42, 0, 0);\n+            } else {\n+                checkDeopt(2);\n+                return new MyValue8(x, 0, 0);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of the same value class with control flow dependent initialization\n+    static abstract value class AMyValue8a {\n+        int y;\n+\n+        public AMyValue8a(int y) {\n+            checkDeoptBig(9);\n+            this(y, 0);\n+            checkDeoptBig(10);\n+        }\n+\n+        public AMyValue8a(int y, int unused1) {\n+            checkDeoptBig(11);\n+            if ((y % 2) == 0) {\n+                checkDeoptBig(12);\n+                this.y = 42;\n+                checkDeoptBig(13);\n+            } else {\n+                checkDeoptBig(14);\n+                this.y = y;\n+                checkDeoptBig(15);\n+            }\n+            checkDeoptBig(16);\n+            super();\n+            checkDeoptBig(17);\n+        }\n+\n+        public AMyValue8a(int y, int unused1, int unused2) {\n+            checkDeoptBig(12);\n+            this.y = y;\n+            checkDeoptBig(13);\n+        }\n+\n+        public static AMyValue8a valueOf(int y) {\n+            checkDeoptBig(0);\n+            if ((y % 2) == 0) {\n+                checkDeoptBig(1);\n+                return new MyValue8a(42, 0, 0);\n+            } else {\n+                checkDeoptBig(2);\n+                return new MyValue8a(y, 0, 0);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"y: \" + y;\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of the same value class with control flow dependent initialization\n+    static value class MyValue8a extends AMyValue8a {\n+        int x;\n+\n+        public MyValue8a(int x) {\n+            checkDeoptBig(0);\n+            this(x, 0);\n+            checkDeoptBig(1);\n+        }\n+\n+        public MyValue8a(int x, int unused1) {\n+            checkDeoptBig(2);\n+            if ((x % 2) == 0) {\n+                checkDeoptBig(3);\n+                this.x = 42;\n+                checkDeoptBig(4);\n+            } else {\n+                checkDeoptBig(5);\n+                this.x = x;\n+                checkDeoptBig(6);\n+            }\n+            checkDeoptBig(7);\n+            super(unused1);\n+            checkDeoptBig(8);\n+        }\n+\n+        public MyValue8a(int x, int unused1, int unused2) {\n+            checkDeoptBig(3);\n+            this.x = x;\n+            checkDeoptBig(4);\n+            super(x, unused1, unused2);\n+        }\n+\n+        public static MyValue8a valueOf(int x) {\n+            checkDeoptBig(0);\n+            if ((x % 2) == 0) {\n+                checkDeoptBig(1);\n+                return new MyValue8a(42, 0, 0);\n+            } else {\n+                checkDeoptBig(2);\n+                return new MyValue8a(x, 0, 0);\n+            }\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x;\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of a different value class\n+    static value class MyValue9 {\n+        MyValue8 val;\n+\n+        public MyValue9(int x) {\n+            checkDeopt(9);\n+            this(x, 0);\n+            checkDeopt(10);\n+        }\n+\n+        public MyValue9(int i, int unused1) {\n+            checkDeopt(11);\n+            val = new MyValue8(i);\n+            checkDeopt(12);\n+        }\n+\n+        public MyValue9(int x, int unused1, int unused2) {\n+            checkDeopt(5);\n+            this(x, 0, 0, 0);\n+            checkDeopt(6);\n+        }\n+\n+        public MyValue9(int i, int unused1, int unused2, int unused3) {\n+            checkDeopt(7);\n+            val = MyValue8.valueOf(i);\n+            checkDeopt(8);\n+        }\n+\n+        public String toString() {\n+            return \"val: [\" + val + \"]\";\n+        }\n+    }\n+\n+    abstract static value class AMyValue9a {\n+        AMyValue8a valA;\n+\n+        public AMyValue9a(int x) {\n+            checkDeoptHuge(22);\n+            this(x, 0);\n+            checkDeoptHuge(23);\n+        }\n+\n+        public AMyValue9a(int i, int unused1) {\n+            checkDeoptHuge(24);\n+            valA = new MyValue8a(i);\n+            checkDeoptHuge(25);\n+        }\n+\n+        public AMyValue9a(int x, int unused1, int unused2) {\n+            checkDeoptHuge(18);\n+            this(x, 0, 0, 0);\n+            checkDeoptHuge(19);\n+        }\n+\n+        public AMyValue9a(int i, int unused1, int unused2, int unused3) {\n+            checkDeoptHuge(20);\n+            valA = MyValue8a.valueOf(i);\n+            checkDeoptHuge(21);\n+        }\n+\n+        public String toString() {\n+            return \"valA: [\" + valA + \"]\";\n+        }\n+    }\n+\n+    \/\/ Constructor calling another constructor of a different value class\n+    static value class MyValue9a extends AMyValue9a {\n+        MyValue8a val;\n+\n+        public MyValue9a(int x) {\n+            checkDeoptHuge(18);\n+            this(x, 0);\n+            checkDeoptHuge(19);\n+        }\n+\n+        public MyValue9a(int i, int unused1) {\n+            checkDeoptHuge(20);\n+            val = new MyValue8a(i);\n+            checkDeoptHuge(21);\n+            super(i, unused1);\n+            checkDeoptHuge(26);\n+        }\n+\n+        public MyValue9a(int x, int unused1, int unused2) {\n+            checkDeoptHuge(14);\n+            this(x, 0, 0, 0);\n+            checkDeoptHuge(15);\n+        }\n+\n+        public MyValue9a(int i, int unused1, int unused2, int unused3) {\n+            checkDeoptHuge(16);\n+            val = MyValue8a.valueOf(i);\n+            checkDeoptHuge(17);\n+            super(i, unused1, unused2, unused3);\n+            checkDeoptHuge(27);\n+        }\n+\n+        public String toString() {\n+            return \"val: [\" + val + \"]\";\n+        }\n+    }\n+\n+    \/\/ Constructor with a loop\n+    static value class MyValue10 {\n+        int x;\n+        int y;\n+\n+        public MyValue10(int x, int cnt) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            int res = 0;\n+            for (int i = 0; i < cnt; ++i) {\n+                checkDeopt(2);\n+                res += x;\n+                checkDeopt(3);\n+            }\n+            checkDeopt(4);\n+            this.y = res;\n+            checkDeopt(5);\n+            super();\n+            checkDeopt(6);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", y: \" + y;\n+        }\n+    }\n+\n+    \/\/ Constructor with a loop\n+    static abstract value class AMyValue10a {\n+        int a;\n+        int b;\n+\n+        public AMyValue10a(int a, int cnt) {\n+            checkDeopt(7);\n+            this.a = a;\n+            checkDeopt(8);\n+            int res = 0;\n+            for (int i = 0; i < cnt; ++i) {\n+                checkDeopt(9);\n+                res += a;\n+                checkDeopt(10);\n+            }\n+            checkDeopt(11);\n+            this.b = res;\n+            checkDeopt(12);\n+            super();\n+            checkDeopt(13);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + a + \", y: \" + b;\n+        }\n+    }\n+\n+    \/\/ Constructor with a loop\n+    static value class MyValue10a extends AMyValue10a {\n+        int x;\n+        int y;\n+\n+        public MyValue10a(int x, int cnt) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            int res = 0;\n+            for (int i = 0; i < cnt; ++i) {\n+                checkDeopt(2);\n+                res += x;\n+                checkDeopt(3);\n+            }\n+            checkDeopt(4);\n+            this.y = res;\n+            checkDeopt(5);\n+            super(x, cnt);\n+            checkDeopt(6);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", y: \" + y;\n+        }\n+    }\n+\n+    \/\/ Value class with recursive field definitions\n+    static value class MyValue11 {\n+        int x;\n+        MyValue11 val1;\n+        MyValue11 val2;\n+\n+        public MyValue11(int x) {\n+            checkDeopt(0);\n+            this.x = x;\n+            checkDeopt(1);\n+            this.val1 = new MyValue11(x + 1, 2, 3, 4, 5);\n+            checkDeopt(6);\n+            this.val2 = new MyValue11(x + 2, 7, 8, 9, 10);\n+            checkDeopt(11);\n+        }\n+\n+        public MyValue11(int x, int deoptNum1, int deoptNum2, int deoptNum3, int deoptNum4) {\n+            checkDeopt(deoptNum1);\n+            this.x = x;\n+            checkDeopt(deoptNum2);\n+            this.val1 = null;\n+            checkDeopt(deoptNum3);\n+            this.val2 = null;\n+            checkDeopt(deoptNum4);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + (val1 != this ? val1 : \"this\") + \"], val2: [\" + (val2 != this ? val2 : \"this\") + \"]\";\n+        }\n+    }\n+\n+    \/\/ Value class with recursive field definitions\n+    static abstract value class AMyValue11a {\n+        int y;\n+        AMyValue11a valA1;\n+        AMyValue11a valA2;\n+\n+        public AMyValue11a(int y) {\n+            checkDeoptHuge(19);\n+            this.y = y;\n+            checkDeoptHuge(20);\n+            this.valA1 = new MyValue11a(y + 1, 21, 22, 23, 24, 25);\n+            checkDeoptHuge(26);\n+            this.valA2 = new MyValue11a(y + 2, 27, 28, 29, 30, 31);\n+            checkDeoptHuge(36);\n+        }\n+\n+        public AMyValue11a(int y, int deoptNum1, int deoptNum2, int deoptNum3, int deoptNum4) {\n+            checkDeoptHuge(deoptNum1);\n+            this.y = y;\n+            checkDeoptHuge(deoptNum2);\n+            this.valA1 = null;\n+            checkDeoptHuge(deoptNum3);\n+            this.valA2 = null;\n+            checkDeoptHuge(deoptNum4);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + y + \", val1: [\" + (valA1 != this ? valA1 : \"this\") + \"], val2: [\" + (valA2 != this ? valA2 : \"this\") + \"]\";\n+        }\n+    }\n+\n+    \/\/ Value class with recursive field definitions\n+    static value class MyValue11a extends AMyValue11a {\n+        int x;\n+        MyValue11a val1;\n+        MyValue11a val2;\n+\n+        public MyValue11a(int x) {\n+            checkDeoptHuge(0);\n+            this.x = x;\n+            checkDeoptHuge(1);\n+            this.val1 = new MyValue11a(x + 1, 2, 3, 4, 5, 6);\n+            checkDeoptHuge(7);\n+            this.val2 = new MyValue11a(x + 2, 8, 9, 10, 11, 12);\n+            checkDeoptHuge(17);\n+            super(x);\n+            checkDeoptHuge(18);\n+        }\n+\n+        public MyValue11a(int x, int deoptNum1, int deoptNum2, int deoptNum3, int deoptNum4, int deoptNum5) {\n+            checkDeoptHuge(deoptNum1);\n+            this.x = x;\n+            checkDeoptHuge(deoptNum2);\n+            this.val1 = null;\n+            checkDeoptHuge(deoptNum3);\n+            this.val2 = null;\n+            checkDeoptHuge(deoptNum4);\n+            super(x, deoptNum5 + 1, deoptNum5 + 2, deoptNum5 + 3, deoptNum5 + 4);\n+            checkDeoptHuge(deoptNum5);\n+        }\n+\n+        public String toString() {\n+            return \"x: \" + x + \", val1: [\" + (val1 != this ? val1 : \"this\") + \"], val2: [\" + (val2 != this ? val2 : \"this\") + \"]\";\n+        }\n+    }\n+\n+    static value class MyValue12 {\n+        Object o;\n+\n+        public MyValue12() {\n+            checkDeopt(0);\n+            this.o = new Object();\n+            checkDeopt(1);\n+            super();\n+            checkDeopt(2);\n+        }\n+    }\n+\n+    static abstract value class MyAbstract13b {\n+        MyAbstract13b() {\n+            checkDeopt(4);\n+            super();\n+            checkDeopt(5);\n+        }\n+    }\n+\n+    static abstract value class MyAbstract13a extends MyAbstract13b {\n+        MyAbstract13a() {\n+            checkDeopt(2);\n+            super();\n+            checkDeopt(3);\n+        }\n+    }\n+\n+    static value class MyValue13 extends MyAbstract13a {\n+        public MyValue13() {\n+            checkDeopt(0);\n+            super();\n+            checkDeopt(1);\n+        }\n+    }\n+\n+    static value class MyValue14 {\n+        private Object o;\n+\n+        public MyValue14(Object o) {\n+            this.o = o;\n+        }\n+\n+        public static MyValue14 get(Object o) {\n+            return new MyValue14(getO(o));\n+        }\n+\n+        public static Object getO(Object obj) {\n+            return obj;\n+        }\n+    }\n+\n+    static abstract value class MyAbstract15 {\n+        int i;\n+\n+        public MyAbstract15(int i) {\n+            checkDeoptBig(2);\n+            this.i = 34;\n+            checkDeoptBig(3);\n+            super();\n+            checkDeoptBig(4);\n+            MyValue15 v = new MyValue15();\n+            checkDeoptBig(11);\n+            foo(v);\n+            checkDeoptBig(13);\n+        }\n+\n+        MyValue15 foo(MyValue15 v) {\n+            checkDeoptBig(12);\n+            return v;\n+        }\n+\n+        public MyAbstract15() {\n+            checkDeoptBig(17);\n+            this.i = 4;\n+            checkDeoptBig(18);\n+            super();\n+            checkDeoptBig(19);\n+        }\n+    }\n+\n+    static value class MyValue15 extends MyAbstract15 {\n+        int i;\n+\n+        public MyValue15(int i) {\n+            checkDeoptBig(0);\n+            this.i = 3;\n+            checkDeoptBig(1);\n+            super(i);\n+            checkDeoptBig(14);\n+            MyValue15 v = new MyValue15();\n+            checkDeoptBig(21);\n+            getO(v);\n+            checkDeoptBig(23);\n+        }\n+\n+\n+        public MyValue15() {\n+            checkDeoptBig( 15);\n+            this.i = 43;\n+            checkDeoptBig(16);\n+            super();\n+            checkDeoptBig(20);\n+        }\n+\n+        static Object getO(Object o) {\n+            checkDeoptBig(22);\n+            return o;\n+        }\n+    }\n+\n+    static abstract value class MyAbstract16 {\n+        int i;\n+        public MyAbstract16() {\n+            checkDeoptBig(8);\n+            this.i = 4;\n+            checkDeoptBig(9);\n+            super();\n+            checkDeoptBig(10);\n+        }\n+\n+        public MyAbstract16(int i) {\n+            checkDeoptBig(2);\n+            this.i = 34;\n+            checkDeoptBig(3);\n+            super();\n+            checkDeoptBig(4);\n+            getV();\n+            checkDeoptBig(13);\n+        }\n+\n+        public MyAbstract16(boolean ignore) {\n+            checkDeoptBig(17);\n+            this.i = 4;\n+            checkDeoptBig(18);\n+            super();\n+            checkDeoptBig(19);\n+        }\n+\n+        public static MyValue16 getV() {\n+            checkDeoptBig(5);\n+            MyValue16 v = new MyValue16();\n+            checkDeoptBig(12);\n+            return v;\n+        }\n+    }\n+\n+    static value class MyValue16 extends MyAbstract16 {\n+        int i;\n+\n+        public MyValue16(int i) {\n+            checkDeoptBig(0);\n+            this.i = 3;\n+            checkDeoptBig(1);\n+            super(i);\n+            checkDeoptBig(14);\n+            MyValue16 v = new MyValue16(true);\n+            checkDeoptBig(21);\n+            getO(v);\n+            checkDeoptBig(23);\n+        }\n+\n+        public MyValue16() {\n+            checkDeoptBig( 6);\n+            this.i = 34;\n+            checkDeoptBig(7);\n+            super();\n+            checkDeoptBig(11);\n+        }\n+\n+        public MyValue16(boolean ignore) {\n+            checkDeoptBig( 15);\n+            this.i = 43;\n+            checkDeoptBig(16);\n+            super(true);\n+            checkDeoptBig(20);\n+        }\n+\n+        static Object getO(Object o) {\n+            checkDeoptBig(22);\n+            return o;\n+        }\n+    }\n+\n+    public static int test1(int x) {\n+        MyValue1 val = new MyValue1(x);\n+        checkDeopt(3);\n+        return val.x;\n+    }\n+\n+    public static int test1a(int x) {\n+        MyValue1a val = new MyValue1a(x);\n+        checkDeopt(3);\n+        return val.x;\n+    }\n+\n+    public static int test1b(int x) {\n+        MyValue1b val = new MyValue1b(x);\n+        checkDeopt(6);\n+        return val.x;\n+    }\n+\n+    public static MyValue1 helper1(int x) {\n+        return new MyValue1(x);\n+    }\n+\n+    public static MyValue1a helper1a(int x) {\n+        return new MyValue1a(x);\n+    }\n+\n+    public static MyValue1b helper1b(int x) {\n+        return new MyValue1b(x);\n+    }\n+\n+    public static Object test2(int x) {\n+        return helper1(x);\n+    }\n+    public static Object test2a(int x) {\n+        return helper1a(x);\n+    }\n+    public static Object test2b(int x) {\n+        return helper1b(x);\n+    }\n+\n+    public static Object test3(int limit) {\n+        MyValue1 res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            res = new MyValue1(i);\n+            checkDeopt(3);\n+        }\n+        return res;\n+    }\n+\n+    public static Object test3a(int limit) {\n+        MyValue1a res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            res = new MyValue1a(i);\n+            checkDeopt(3);\n+        }\n+        return res;\n+    }\n+\n+    public static Object test3b(int limit) {\n+        MyValue1b res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            res = new MyValue1b(i);\n+            checkDeopt(6);\n+        }\n+        return res;\n+    }\n+\n+    public static MyValue1 test4(int x) {\n+        MyValue1 v = new MyValue1(x);\n+        checkDeopt(3);\n+        v = new MyValue1(x);\n+        return v;\n+    }\n+\n+    public static MyValue1a test4a(int x) {\n+        MyValue1a v = new MyValue1a(x);\n+        checkDeopt(3);\n+        v = new MyValue1a(x);\n+        return v;\n+    }\n+\n+    public static MyValue1b test4b(int x) {\n+        MyValue1b v = new MyValue1b(x);\n+        checkDeopt(6);\n+        v = new MyValue1b(x);\n+        return v;\n+    }\n+\n+    public static int test5(int x) {\n+        MyValue2 val = new MyValue2(x);\n+        checkDeopt(3);\n+        return val.x;\n+    }\n+\n+    public static MyValue2 helper2(int x) {\n+        return new MyValue2(x);\n+    }\n+\n+    public static Object test6(int x) {\n+        return helper2(x);\n+    }\n+\n+    public static Object test7(int limit) {\n+        MyValue2 res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            res = new MyValue2(i);\n+            checkDeopt(3);\n+        }\n+        return res;\n+    }\n+\n+    public static MyValue2 test8(int x) {\n+        MyValue2 v = new MyValue2(x);\n+        checkDeopt(3);\n+        v = new MyValue2(x);\n+        return v;\n+    }\n+\n+    public static int test9(int x) {\n+        MyValue3 val = new MyValue3(x);\n+        checkDeopt(9);\n+        return val.x;\n+    }\n+\n+    public static int test9a(int x) {\n+        MyValue3a val = new MyValue3a(x);\n+        checkDeopt(9);\n+        return val.x + val.y;\n+    }\n+\n+    public static MyValue3 helper3(int x) {\n+        return new MyValue3(x);\n+    }\n+\n+    public static Object test10(int x) {\n+        return helper3(x);\n+    }\n+\n+    public static MyValue3a helper3a(int x) {\n+        return new MyValue3a(x);\n+    }\n+\n+    public static Object test10a(int x) {\n+        return helper3a(x);\n+    }\n+\n+    public static Object test11(int limit) {\n+        MyValue3 res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            checkDeopt(9);\n+            res = new MyValue3(i);\n+        }\n+        return res;\n+    }\n+\n+    public static Object test11a(int limit) {\n+        MyValue3a res = null;\n+        for (int i = 0; i <= 10; ++i) {\n+            checkDeopt(9);\n+            res = new MyValue3a(i);\n+        }\n+        return res;\n+    }\n+\n+    public static MyValue3 test12(int x) {\n+        MyValue3 v = new MyValue3(x);\n+        checkDeopt(9);\n+        v = new MyValue3(x);\n+        return v;\n+    }\n+\n+    public static MyValue3a test12a(int x) {\n+        MyValue3a v = new MyValue3a(x);\n+        checkDeopt(9);\n+        v = new MyValue3a(x);\n+        return v;\n+    }\n+\n+    public static MyValue4 test13(int x) {\n+        return new MyValue4(x);\n+    }\n+\n+    public static MyValue4a test13a(int x) {\n+        return new MyValue4a(x);\n+    }\n+\n+    public static MyValue5 test14(int x, boolean b) {\n+        return new MyValue5(x, b);\n+    }\n+\n+    public static MyValue5a test14a(int x, boolean b) {\n+        return new MyValue5a(x, b);\n+    }\n+\n+    public static Object test15(int x) {\n+        return new MyValue6(x);\n+    }\n+\n+    public static Object test15a(int x) {\n+        return new MyValue6a(x);\n+    }\n+\n+    public static Object test15b(int x) {\n+        return new MyValue6b(x);\n+    }\n+\n+    public static Object test16(int x) {\n+        return new MyValue7(x);\n+    }\n+\n+    public static Object test16a(int x) {\n+        return new MyValue7a(x);\n+    }\n+\n+    public static Object test16b(int x) {\n+        return new MyValue7b(x);\n+    }\n+\n+    public static MyValue8 test17(int x) {\n+        return new MyValue8(x);\n+    }\n+\n+    public static MyValue8a test17a(int x) {\n+        return new MyValue8a(x);\n+    }\n+\n+    public static MyValue8 test18(int x) {\n+        return new MyValue8(x, 0);\n+    }\n+\n+    public static MyValue8a test18a(int x) {\n+        return new MyValue8a(x, 0);\n+    }\n+\n+    public static MyValue8 test19(int x) {\n+        return MyValue8.valueOf(x);\n+    }\n+\n+    public static MyValue8a test19a(int x) {\n+        return MyValue8a.valueOf(x);\n+    }\n+\n+    public static AMyValue8a test19b(int x) {\n+        return AMyValue8a.valueOf(x);\n+    }\n+\n+    public static MyValue9 test20(int x) {\n+        return new MyValue9(x);\n+    }\n+\n+    public static MyValue9a test20a(int x) {\n+        return new MyValue9a(x);\n+    }\n+\n+    public static MyValue9 test21(int x) {\n+        return new MyValue9(x, 0);\n+    }\n+\n+    public static MyValue9a test21a(int x) {\n+        return new MyValue9a(x, 0);\n+    }\n+\n+    public static MyValue9 test22(int x) {\n+        return new MyValue9(x, 0, 0);\n+    }\n+\n+    public static MyValue9a test22a(int x) {\n+        return new MyValue9a(x, 0, 0);\n+    }\n+\n+    public static MyValue9 test23(int x) {\n+        return new MyValue9(x, 0, 0, 0);\n+    }\n+\n+    public static MyValue9a test23a(int x) {\n+        return new MyValue9a(x, 0, 0, 0);\n+    }\n+\n+    public static MyValue10 test24(int x, int cnt) {\n+        return new MyValue10(x, cnt);\n+    }\n+\n+    public static MyValue10a test24a(int x, int cnt) {\n+        return new MyValue10a(x, cnt);\n+    }\n+\n+    public static MyValue11 test25(int x) {\n+        return new MyValue11(x);\n+    }\n+\n+    public static MyValue11a test25a(int x) {\n+        return new MyValue11a(x);\n+    }\n+\n+    public static MyValue12 testObjectCallInsideConstructor() {\n+        return new MyValue12();\n+    }\n+\n+    public static MyValue13 testMultipleAbstract() {\n+        return new MyValue13();\n+    }\n+\n+    public static MyValue14 testCallAsConstructorArgument() {\n+        return MyValue14.get(o);\n+    }\n+\n+    public static MyValue15 testBackAndForthAbstract(int x) {\n+        return new MyValue15(x);\n+    }\n+\n+    public static MyValue16 testBackAndForthAbstract2(int x) {\n+        return new MyValue16(x);\n+    }\n+\n+    private static final MethodHandle MULTIPLE_OCCURRENCES_IN_JVMS = InstructionHelper.buildMethodHandle(MethodHandles.lookup(),\n+            \"multipleOccurrencesInJVMSReturnStack\",\n+            MethodType.methodType(MyValue1.class, int.class),\n+            CODE -> {\n+                Label loopHead = CODE.newLabel();\n+                Label loopExit = CODE.newLabel();\n+                CODE.\n+                        new_(MyValue1.class.describeConstable().get()).\n+                        dup().\n+                        astore(1).\n+                        astore(2).\n+                        iconst_0().\n+                        istore(3).\n+                        labelBinding(loopHead).\n+                        iload(3).\n+                        ldc(100).\n+                        if_icmpge(loopExit).\n+                        iinc(3, 1).\n+                        goto_(loopHead).\n+                        labelBinding(loopExit).\n+                        aload(2).\n+                        iload(0).\n+                        invokespecial(MyValue1.class.describeConstable().get(), \"<init>\", MethodType.methodType(void.class, int.class).describeConstable().get()).\n+                        aload(2).\n+                        areturn();\n+            });\n+\n+    public static MyValue1 testMultipleOccurrencesInJVMS(int x) throws Throwable {\n+        return (MyValue1) MULTIPLE_OCCURRENCES_IN_JVMS.invokeExact(x);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        Random rand = Utils.getRandomInstance();\n+\n+        \/\/ Randomly exclude some constructors from inlining via the WhiteBox API because CompileCommands don't match on different signatures.\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1a.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1b.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1a.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue1b.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue3.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue3.class.getConstructor(int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue8.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue8.class.getConstructor(int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue8.class.getConstructor(int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue9.class.getConstructor(int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue11.class.getConstructor(int.class), rand.nextBoolean());\n+        WHITE_BOX.testSetDontInlineMethod(MyValue11.class.getConstructor(int.class, int.class, int.class, int.class, int.class), rand.nextBoolean());\n+        int randValue = rand.nextInt(0, 4);\n+        if (randValue > 0) {\n+            \/\/ Some variation\n+            WHITE_BOX.testSetDontInlineMethod(MyValue15.class.getConstructor(), rand.nextBoolean());\n+            WHITE_BOX.testSetDontInlineMethod(MyValue15.class.getConstructor(int.class), rand.nextBoolean());\n+            WHITE_BOX.testSetDontInlineMethod(MyValue16.class.getConstructor(), rand.nextBoolean());\n+            WHITE_BOX.testSetDontInlineMethod(MyValue16.class.getConstructor(int.class), rand.nextBoolean());\n+            if (randValue > 1) {\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract15.class.getConstructor(), rand.nextBoolean());\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract15.class.getConstructor(int.class), rand.nextBoolean());\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract16.class.getConstructor(), rand.nextBoolean());\n+                WHITE_BOX.testSetDontInlineMethod(MyAbstract16.class.getConstructor(int.class), rand.nextBoolean());\n+            }\n+        }\n+\n+        Integer deoptNum = Integer.getInteger(\"deoptNum\");\n+        Integer deoptNumBig = Integer.getInteger(\"deoptNumBig\");\n+        Integer deoptNumHuge = Integer.getInteger(\"deoptNumHuge\");\n+        if (deoptNum == null) {\n+            deoptNum = rand.nextInt(deopt.length);\n+            System.out.println(\"deoptNum = \" + deoptNum);\n+        }\n+        if (deoptNumBig == null) {\n+            deoptNumBig = rand.nextInt(deoptBig.length);\n+            System.out.println(\"deoptNumBig = \" + deoptNumBig);\n+        }\n+        if (deoptNumHuge == null) {\n+            deoptNumHuge = rand.nextInt(deoptHuge.length);\n+            System.out.println(\"deoptNumHuge = \" + deoptNumHuge);\n+        }\n+        run(0, true);\n+        for (int x = 1; x <= 50_000; ++x) {\n+            if (x == 50_000) {\n+                \/\/ Last iteration, trigger deoptimization\n+                run(x, true);\n+                deopt[deoptNum] = true;\n+                deoptBig[deoptNumBig] = true;\n+                deoptHuge[deoptNumHuge] = true;\n+                run(x, true);\n+            } else {\n+                run(x, false);\n+            }\n+        }\n+    }\n+\n+    private static void run(int x, boolean doCheck) throws Throwable {\n+        check(test1(x), x, doCheck);\n+        check(test1a(x), x, doCheck);\n+        check(test1b(x), x, doCheck);\n+        check(test2(x), new MyValue1(x), doCheck);\n+        check(test2a(x), new MyValue1a(x), doCheck);\n+        check(test2b(x), new MyValue1b(x), doCheck);\n+        check(test3(10), new MyValue1(10), doCheck);\n+        check(test3a(10), new MyValue1a(10), doCheck);\n+        check(test3b(10), new MyValue1b(10), doCheck);\n+        check(test4(x), new MyValue1(x), doCheck);\n+        check(test4a(x), new MyValue1a(x), doCheck);\n+        check(test4b(x), new MyValue1b(x), doCheck);\n+        check(test5(x), x, doCheck);\n+        check(test5(x), x, doCheck);\n+        check(test6(x), new MyValue2(x), doCheck);\n+        check(test6(x), new MyValue2(x), doCheck);\n+        check(test7(10), new MyValue2(10), doCheck);\n+        check(test8(x), new MyValue2(x), doCheck);\n+        check(test9(x), x, doCheck);\n+        check(test9a(x), x + x, doCheck);\n+        check(test10(x), new MyValue3(x), doCheck);\n+        check(test10a(x), new MyValue3a(x), doCheck);\n+        check(test11(10), new MyValue3(10), doCheck);\n+        check(test11a(10), new MyValue3a(10), doCheck);\n+        check(test12(x), new MyValue3(x), doCheck);\n+        check(test12a(x), new MyValue3a(x), doCheck);\n+        check(test13(x), new MyValue4(x), doCheck);\n+        check(test13a(x), new MyValue4a(x), doCheck);\n+        check(test14(x, (x % 2) == 0), new MyValue5(x, (x % 2) == 0), doCheck);\n+        check(test14a(x, (x % 2) == 0), new MyValue5a(x, (x % 2) == 0), doCheck);\n+        check(test15(x), new MyValue6(x), doCheck);\n+        check(test15a(x), new MyValue6a(x), doCheck);\n+        check(test15b(x), new MyValue6b(x), doCheck);\n+        check(test16(x), new MyValue7(x), doCheck);\n+        check(test16a(x), new MyValue7a(x), doCheck);\n+        check(test16b(x), new MyValue7b(x), doCheck);\n+        check(test17(x), new MyValue8(x), doCheck);\n+        check(test17a(x), new MyValue8a(x), doCheck);\n+        check(test18(x), new MyValue8(x), doCheck);\n+        check(test18a(x), new MyValue8a(x), doCheck);\n+        check(test19(x), new MyValue8(x), doCheck);\n+        check(test19a(x), new MyValue8a(x), doCheck);\n+        check(test19b(x), new MyValue8a(x), doCheck);\n+        check(test20(x), new MyValue9(x), doCheck);\n+        check(test20a(x), new MyValue9a(x), doCheck);\n+        check(test21(x), new MyValue9(x), doCheck);\n+        check(test21a(x), new MyValue9a(x), doCheck);\n+        check(test22(x), new MyValue9(x), doCheck);\n+        check(test22a(x), new MyValue9a(x), doCheck);\n+        check(test23(x), new MyValue9(x), doCheck);\n+        check(test23a(x), new MyValue9a(x), doCheck);\n+        check(test24(x, x % 10), new MyValue10(x, x % 10), doCheck);\n+        check(test24a(x, x % 10), new MyValue10a(x, x % 10), doCheck);\n+        check(test25(x), new MyValue11(x), doCheck);\n+        check(test25a(x), new MyValue11a(x), doCheck);\n+        testObjectCallInsideConstructor(); \/\/ Creates a new Object each time - cannot compare on equality.\n+        check(testMultipleAbstract(), new MyValue13(), doCheck);\n+        check(testCallAsConstructorArgument(), new MyValue14(o), doCheck);\n+        check(testBackAndForthAbstract(x), new MyValue15(x), doCheck);\n+        check(testBackAndForthAbstract2(x), new MyValue16(x), doCheck);\n+        check(testMultipleOccurrencesInJVMS(x), new MyValue1(x), doCheck);\n+    }\n+\n+    private static void check(Object testResult, Object expectedResult, boolean check) {\n+        if (check) {\n+            Asserts.assertEQ(testResult, expectedResult);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":1826,"deletions":0,"binary":false,"changes":1826,"status":"added"},{"patch":"@@ -0,0 +1,686 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @summary Test that Virtual Threads work well with Value Objects.\n+ * @library \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   TestVirtualThreads\n+ *\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=compileonly,TestVirtualThreads*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=exclude,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                    -Xcomp -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=compileonly,TestVirtualThreads*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::test*\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=dontinline,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::dontinline -XX:CompileCommand=compileonly,TestVirtualThreads*::test* -XX:CompileCommand=exclude,*::*Helper\n+ *                   TestVirtualThreads\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:CompileCommand=dontinline,*::* -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads 250000\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xcomp -XX:CompileCommand=dontinline,*::* -XX:CompileCommand=compileonly,TestVirtualThreads*::*\n+ *                   TestVirtualThreads 250000\n+ **\/\n+\n+import java.lang.reflect.Method;\n+\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestVirtualThreads {\n+    static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    static final int COMP_LEVEL_SIMPLE = 1; \/\/ C1\n+    static final int COMP_LEVEL_FULL_OPTIMIZATION = 4; \/\/ C2 or JVMCI\n+    static final Random RAND = Utils.getRandomInstance();\n+    static final int PARK_DURATION = 10;\n+\n+    static value class SmallValue {\n+        int x1;\n+        int x2;\n+\n+        public SmallValue(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != i || x2 != i) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(SmallValue val, String loc, int i, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, i);\n+            }\n+        }\n+    }\n+\n+    \/\/ Large value class\n+    static value class LargeValue {\n+        int x1;\n+        int x2;\n+        int x3;\n+        int x4;\n+        int x5;\n+        int x6;\n+        int x7;\n+\n+        public LargeValue(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+            this.x3 = i;\n+            this.x4 = i;\n+            this.x5 = i;\n+            this.x6 = i;\n+            this.x7 = i;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5 +\n+                   \", x6 = \" + x6 + \", x7 = \" + x7;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != i || x2 != i || x3 != i || x4 != i || x5 != i ||\n+                x6 != i || x7 != i) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(LargeValue val, String loc, int i, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, i);\n+            }\n+        }\n+    }\n+\n+    \/\/ Large value class with fields of different types\n+    static value class LargeValue2 {\n+        byte x1;\n+        short x2;\n+        int x3;\n+        long x4;\n+        double x5;\n+        boolean x6;\n+\n+        public LargeValue2(int i) {\n+            this.x1 = (byte)i;\n+            this.x2 = (short)i;\n+            this.x3 = i;\n+            this.x4 = i;\n+            this.x5 = i;\n+            this.x6 = (i % 2) == 0;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5 +\n+                   \", x6 = \" + x6;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != (byte)i || x2 != (short)i || x3 != i || x4 != i || x5 != i ||\n+                x6 != ((i % 2) == 0)) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(LargeValue2 val, String loc, int i, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, i);\n+            }\n+        }\n+    }\n+\n+    \/\/ Large value class with oops (and different number of fields) that requires stack extension\/repair\n+    static value class LargeValueWithOops {\n+        Object x1;\n+        Object x2;\n+        Object x3;\n+        Object x4;\n+        Object x5;\n+\n+        public LargeValueWithOops(Object obj) {\n+            this.x1 = obj;\n+            this.x2 = obj;\n+            this.x3 = obj;\n+            this.x4 = obj;\n+            this.x5 = obj;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5;\n+        }\n+\n+        public void verify(String loc, Object obj) {\n+            if (x1 != obj || x2 != obj || x3 != obj || x4 != obj || x5 != obj) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for obj = \" + obj + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(LargeValueWithOops val, String loc, Object obj, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for obj = \" + obj + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, obj);\n+            }\n+        }\n+    }\n+\n+    public static value class DoubleValue {\n+        double d;\n+\n+        public DoubleValue(double d) {\n+            this.d = d;\n+        }\n+\n+        public String toString() {\n+            return \"d = \" + d;\n+        }\n+\n+        public void verify(String loc, double d) {\n+            if (this.d != d) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(DoubleValue val, String loc, double d, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d+ \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, d);\n+            }\n+        }\n+    }\n+\n+    public static value class DoubleValue2 {\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+\n+        public DoubleValue2(double d) {\n+            this.d1 = d;\n+            this.d2 = d + 1;\n+            this.d3 = d + 2;\n+            this.d4 = d + 3;\n+            this.d5 = d + 4;\n+        }\n+\n+        public String toString() {\n+            return \"d1 = \" + d1 + \", d2 = \" + d2 + \", d3 = \" + d3 + \", d4= \" + d4 + \", d5= \" + d5;\n+        }\n+\n+        public void verify(String loc, double d) {\n+            if (this.d1 != d || this.d2 != (d+1) || this.d3 != (d+2) || this.d4 != (d+3) || this.d5 != (d+4)) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d + \": \" + this);\n+            }\n+        }\n+\n+        public static void verify(DoubleValue2 val, String loc, double d, boolean useNull) {\n+            if (useNull) {\n+                if (val != null) {\n+                    throw new RuntimeException(\"Incorrect result at \" + loc + \" for d = \" + d + \": \" + val);\n+                }\n+            } else {\n+                val.verify(loc, d);\n+            }\n+        }\n+    }\n+\n+    static abstract value class BaseValue {\n+        public abstract void verify(String loc, int i);\n+    };\n+\n+    static value class ValueExtendsAbstract extends BaseValue {\n+        int x1;\n+        int x2;\n+        int x3;\n+        int x4;\n+        int x5;\n+        int x6;\n+        int x7;\n+\n+        public ValueExtendsAbstract(int i) {\n+            this.x1 = i;\n+            this.x2 = i;\n+            this.x3 = i;\n+            this.x4 = i;\n+            this.x5 = i;\n+            this.x6 = i;\n+            this.x7 = i;\n+        }\n+\n+        public String toString() {\n+            return \"x1 = \" + x1 + \", x2 = \" + x2 + \", x3 = \" + x3 + \", x4 = \" + x4 + \", x5 = \" + x5 +\n+                   \", x6 = \" + x6 + \", x7 = \" + x7;\n+        }\n+\n+        public void verify(String loc, int i) {\n+            if (x1 != i || x2 != i || x3 != i || x4 != i || x5 != i ||\n+                x6 != i || x7 != i) {\n+                throw new RuntimeException(\"Incorrect result at \" + loc + \" for i = \" + i + \": \" + this);\n+            }\n+        }\n+    }\n+\n+    public static void dontInline() { }\n+\n+    public static SmallValue testSmall(SmallValue val, int i, boolean useNull, boolean park) {\n+        SmallValue.verify(val, \"entry\", i, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        SmallValue.verify(val, \"exit\", i, useNull);\n+        return val;\n+    }\n+\n+    public static SmallValue testSmallHelper(int i, boolean useNull, boolean park) {\n+        SmallValue val = useNull ? null : new SmallValue(i);\n+        val = testSmall(val, i, useNull, park);\n+        SmallValue.verify(val, \"helper\", i, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue testLarge(LargeValue val, int i, boolean useNull, boolean park) {\n+        LargeValue.verify(val, \"entry\", i, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue.verify(val, \"exit\", i, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue testLargeHelper(int i, boolean useNull, boolean park) {\n+        LargeValue val = useNull ? null : new LargeValue(i);\n+        val = testLarge(val, i, useNull, park);\n+        LargeValue.verify(val, \"helper\", i, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Version that already has values on the stack even before stack extensions\n+    public static LargeValue testLargeManyArgs(LargeValue val1, LargeValue val2, LargeValue val3, LargeValue val4, int i, boolean useNull, boolean park) {\n+        LargeValue.verify(val1, \"entry\", i, useNull);\n+        LargeValue.verify(val2, \"entry\", i + 1, useNull);\n+        LargeValue.verify(val3, \"entry\", i + 2, useNull);\n+        LargeValue.verify(val4, \"entry\", i + 3, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue.verify(val1, \"exit\", i, useNull);\n+        LargeValue.verify(val2, \"exit\", i + 1, useNull);\n+        LargeValue.verify(val3, \"exit\", i + 2, useNull);\n+        LargeValue.verify(val4, \"exit\", i + 3, useNull);\n+        return val4;\n+    }\n+\n+    public static LargeValue testLargeManyArgsHelper(int i, boolean useNull, boolean park) {\n+        LargeValue val1 = useNull ? null : new LargeValue(i);\n+        LargeValue val2 = useNull ? null : new LargeValue(i + 1);\n+        LargeValue val3 = useNull ? null : new LargeValue(i + 2);\n+        LargeValue val4 = useNull ? null : new LargeValue(i + 3);\n+        LargeValue val = testLargeManyArgs(val1, val2, val3, val4, i, useNull, park);\n+        LargeValue.verify(val, \"helper\", i + 3, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue2 testLarge2(LargeValue2 val, int i, boolean useNull, boolean park) {\n+        LargeValue2.verify(val, \"entry\", i, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue2.verify(val, \"exit\", i, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValue2 testLarge2Helper(int i, boolean useNull, boolean park) {\n+        LargeValue2 val = useNull ? null : new LargeValue2(i);\n+        val = testLarge2(val, i, useNull, park);\n+        LargeValue2.verify(val, \"helper\", i, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Version that already has values on the stack even before stack extensions\n+    public static LargeValue2 testLarge2ManyArgs(LargeValue2 val1, LargeValue2 val2, LargeValue2 val3, LargeValue2 val4, int i, boolean useNull, boolean park) {\n+        LargeValue2.verify(val1, \"entry\", i, useNull);\n+        LargeValue2.verify(val2, \"entry\", i + 1, useNull);\n+        LargeValue2.verify(val3, \"entry\", i + 2, useNull);\n+        LargeValue2.verify(val4, \"entry\", i + 3, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValue2.verify(val1, \"exit\", i, useNull);\n+        LargeValue2.verify(val2, \"exit\", i + 1, useNull);\n+        LargeValue2.verify(val3, \"exit\", i + 2, useNull);\n+        LargeValue2.verify(val4, \"exit\", i + 3, useNull);\n+        return val4;\n+    }\n+\n+    public static LargeValue2 testLarge2ManyArgsHelper(int i, boolean useNull, boolean park) {\n+        LargeValue2 val1 = useNull ? null : new LargeValue2(i);\n+        LargeValue2 val2 = useNull ? null : new LargeValue2(i + 1);\n+        LargeValue2 val3 = useNull ? null : new LargeValue2(i + 2);\n+        LargeValue2 val4 = useNull ? null : new LargeValue2(i + 3);\n+        LargeValue2 val = testLarge2ManyArgs(val1, val2, val3, val4, i, useNull, park);\n+        return val;\n+    }\n+\n+    public static ValueExtendsAbstract testExtendsAbstractHelper(int i, boolean park) {\n+        ValueExtendsAbstract val1 = new ValueExtendsAbstract(i);\n+        ValueExtendsAbstract val2 = new ValueExtendsAbstract(i + 1);\n+        ValueExtendsAbstract val3 = new ValueExtendsAbstract(i + 2);\n+        ValueExtendsAbstract val4 = new ValueExtendsAbstract(i + 3);\n+\n+        val1.verify(\"entry\", i);\n+        val2.verify(\"entry\", i + 1);\n+        val3.verify(\"entry\", i + 2);\n+        val4.verify(\"entry\", i + 3);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        val1.verify(\"exit\", i);\n+        val2.verify(\"exit\", i + 1);\n+        val3.verify(\"exit\", i + 2);\n+        val4.verify(\"exit\", i + 3);\n+        return val4;\n+    }\n+\n+    public static LargeValueWithOops testLargeValueWithOops(LargeValueWithOops val, Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops.verify(val, \"entry\", obj, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValueWithOops.verify(val, \"exit\", obj, useNull);\n+        return val;\n+    }\n+\n+    public static LargeValueWithOops testLargeValueWithOopsHelper(Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops val = useNull ? null : new LargeValueWithOops(obj);\n+        val = testLargeValueWithOops(val, obj, useNull, park);\n+        LargeValueWithOops.verify(val, \"helper\", obj, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Version that already has values on the stack even before stack extensions\n+    public static LargeValueWithOops testLargeValueWithOops2(LargeValueWithOops val1, LargeValueWithOops val2, LargeValueWithOops val3, LargeValueWithOops val4, LargeValueWithOops val5, Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops.verify(val1, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val2, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val3, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val4, \"entry\", obj, useNull);\n+        LargeValueWithOops.verify(val5, \"entry\", obj, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+        LargeValueWithOops.verify(val1, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val2, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val3, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val4, \"exit\", obj, useNull);\n+        LargeValueWithOops.verify(val5, \"exit\", obj, useNull);\n+        return val5;\n+    }\n+\n+    public static LargeValueWithOops testLargeValueWithOops2Helper(Object obj, boolean useNull, boolean park) {\n+        LargeValueWithOops val1 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val2 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val3 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val4 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val5 = useNull ? null : new LargeValueWithOops(obj);\n+        LargeValueWithOops val = testLargeValueWithOops2(val1, val2, val3, val4, val5, obj, useNull, park);\n+        LargeValueWithOops.verify(val, \"helper\", obj, useNull);\n+        return val;\n+    }\n+\n+    \/\/ Pass via fields to not affect number of arguments\n+    static double testDoubleValueDP;\n+    static boolean testDoubleValueUseNullP;\n+    static boolean testDoubleValueParkP;\n+    static double testDoubleValueDV;\n+    static boolean testDoubleValueUseNullV;\n+    static boolean testDoubleValueParkV;\n+\n+    \/\/ This method needs less stack space when scalarized because (some of) the arguments can then be passed in floating point registers\n+    public static DoubleValue testDoubleValue(DoubleValue val1, DoubleValue val2, DoubleValue val3, DoubleValue val4, DoubleValue val5, DoubleValue val6, DoubleValue val7) {\n+        boolean isVirtual = Thread.currentThread().isVirtual();\n+        double d = isVirtual ? testDoubleValueDV : testDoubleValueDP;\n+        boolean useNull = isVirtual ? testDoubleValueUseNullV : testDoubleValueUseNullP;\n+        boolean park = isVirtual ? testDoubleValueParkV : testDoubleValueParkP;\n+\n+        DoubleValue.verify(val1, \"entry\", d, useNull);\n+        DoubleValue.verify(val2, \"entry\", d + 1, useNull);\n+        DoubleValue.verify(val3, \"entry\", d + 2, useNull);\n+        DoubleValue.verify(val4, \"entry\", d + 3, useNull);\n+        DoubleValue.verify(val5, \"entry\", d + 4, useNull);\n+        DoubleValue.verify(val6, \"entry\", d + 4, useNull);\n+        DoubleValue.verify(val7, \"entry\", d + 4, useNull);\n+        if (park) {\n+            LockSupport.parkNanos(PARK_DURATION);\n+        }\n+        DoubleValue.verify(val1, \"exit\", d, useNull);\n+        DoubleValue.verify(val2, \"exit\", d + 1, useNull);\n+        DoubleValue.verify(val3, \"exit\", d + 2, useNull);\n+        DoubleValue.verify(val4, \"exit\", d + 3, useNull);\n+        DoubleValue.verify(val5, \"exit\", d + 4, useNull);\n+        DoubleValue.verify(val6, \"exit\", d + 4, useNull);\n+        DoubleValue.verify(val7, \"exit\", d + 4, useNull);\n+        return val1;\n+    }\n+\n+    public static DoubleValue testDoubleValueHelper(double d, boolean useNull, boolean park) {\n+        if (Thread.currentThread().isVirtual()) {\n+            testDoubleValueDV = d;\n+            testDoubleValueUseNullV = useNull;\n+            testDoubleValueParkV = park;\n+        } else {\n+            testDoubleValueDP = d;\n+            testDoubleValueUseNullP = useNull;\n+            testDoubleValueParkP = park;\n+        }\n+\n+        DoubleValue val1 = useNull ? null : new DoubleValue(d);\n+        DoubleValue val2 = useNull ? null : new DoubleValue(d + 1);\n+        DoubleValue val3 = useNull ? null : new DoubleValue(d + 2);\n+        DoubleValue val4 = useNull ? null : new DoubleValue(d + 3);\n+        DoubleValue val5 = useNull ? null : new DoubleValue(d + 4);\n+        DoubleValue val6 = useNull ? null : new DoubleValue(d + 4);\n+        DoubleValue val7 = useNull ? null : new DoubleValue(d + 4);\n+        val1 = testDoubleValue(val1, val2, val3, val4, val5, val6, val7);\n+        DoubleValue.verify(val1, \"helper\", d, useNull);\n+        return val1;\n+    }\n+\n+    public static DoubleValue2 recurseTestDoubleValue2(double d, boolean useNull, boolean park, int depth) {\n+        if (depth > 0) {\n+            DoubleValue2 val = recurseTestDoubleValue2(d, useNull, park, depth - 1);\n+            DoubleValue2.verify(val, \"entry\", d, useNull);\n+            dontInline(); \/\/ Prevent C2 from optimizing out below checks\n+            DoubleValue2.verify(val, \"exit\", d, useNull);\n+            return val;\n+        } else {\n+            if (park) {\n+                LockSupport.parkNanos(PARK_DURATION);\n+            }\n+            return useNull ? null : new DoubleValue2(d);\n+        }\n+    }\n+\n+    public static DoubleValue2 testDoubleValue2Helper(double d, boolean useNull, boolean park) {\n+        DoubleValue2 val = recurseTestDoubleValue2(d, useNull, park, 4);\n+        DoubleValue2.verify(val, \"helper\", d, useNull);\n+        return val;\n+    }\n+\n+    static class GarbageProducerThread extends Thread {\n+        public void run() {\n+            for (;;) {\n+                \/\/ Produce some garbage and then let the GC do its work\n+                Object[] arrays = new Object[1024];\n+                for (int i = 0; i < arrays.length; i++) {\n+                    arrays[i] = new int[1024];\n+                }\n+                System.gc();\n+            }\n+        }\n+    }\n+\n+    public static void startTest(CountDownLatch cdl, Thread.Builder builder, int iterations) {\n+        builder.start(() -> {\n+            try {\n+                \/\/ Trigger compilation\n+                boolean isVirtual = Thread.currentThread().isVirtual();\n+                for (int i = 0; i < iterations; i++) {\n+                    boolean park = (i % 1000) == 0;\n+                    boolean useNull = RAND.nextBoolean();\n+                    Object val = useNull ? null : new SmallValue(i);\n+                    SmallValue.verify(testSmallHelper(i, useNull, park), \"return\", i, useNull);\n+                    LargeValue.verify(testLargeHelper(i, useNull, park), \"return\", i, useNull);\n+                    LargeValue.verify(testLargeManyArgsHelper(i, useNull, park), \"return\", i + 3, useNull);\n+                    LargeValue2.verify(testLarge2Helper(i, useNull, park), \"return\", i, useNull);\n+                    LargeValue2.verify(testLarge2ManyArgsHelper(i, useNull, park), \"return\", i + 3, useNull);\n+                    testExtendsAbstractHelper(i, park).verify(\"return\", i + 3);\n+                    LargeValueWithOops.verify(testLargeValueWithOopsHelper(val, useNull, park), \"return\", val, useNull);\n+                    LargeValueWithOops.verify(testLargeValueWithOops2Helper(val, useNull, park), \"return\", val, useNull);\n+                    DoubleValue.verify(testDoubleValueHelper(i, useNull, park), \"return\", i, useNull);\n+                    DoubleValue2.verify(testDoubleValue2Helper(i, useNull, park), \"return\", i, useNull);\n+                    if (i % 1000 == 0) {\n+                        System.out.format(\"%s => %s %d of %d%n\", Instant.now(), isVirtual ? \"Virtual: \" : \"Platform:\", i, iterations);\n+                    }\n+                }\n+                cdl.countDown();\n+            } catch (Exception e) {\n+                System.out.println(\"Exception thrown: \" + e);\n+                e.printStackTrace(System.out);\n+                System.exit(1);\n+            }\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Sometimes, exclude some methods from compilation with C1 and\/or C2 to stress test the calling convention\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            ArrayList<Method> methods = new ArrayList<Method>();\n+            Collections.addAll(methods, SmallValue.class.getDeclaredMethods());\n+            Collections.addAll(methods, LargeValue.class.getDeclaredMethods());\n+            Collections.addAll(methods, LargeValue2.class.getDeclaredMethods());\n+            Collections.addAll(methods, LargeValueWithOops.class.getDeclaredMethods());\n+            Collections.addAll(methods, DoubleValue.class.getDeclaredMethods());\n+            Collections.addAll(methods, TestVirtualThreads.class.getDeclaredMethods());\n+            System.out.println(\"Excluding methods from C1 compilation:\");\n+            for (Method m : methods) {\n+                if (Utils.getRandomInstance().nextBoolean()) {\n+                    System.out.println(m);\n+                    WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_SIMPLE, false);\n+                }\n+            }\n+            System.out.println(\"Excluding methods from C2 compilation:\");\n+            for (Method m : methods) {\n+                if (Utils.getRandomInstance().nextBoolean()) {\n+                    System.out.println(m);\n+                    WHITE_BOX.makeMethodNotCompilable(m, COMP_LEVEL_FULL_OPTIMIZATION, false);\n+                }\n+            }\n+        }\n+\n+        \/\/ Start another thread that does some allocations and calls System.gc()\n+        \/\/ to trigger GCs while virtual threads are parked.\n+        Thread garbage_producer = new GarbageProducerThread();\n+        garbage_producer.setDaemon(true);\n+        garbage_producer.start();\n+\n+        int iterations = args.length > 0 ? Integer.parseInt(args[0]) : 300_000;\n+        if (Platform.isDebugBuild()) {\n+            iterations \/= 4;\n+        }\n+        CountDownLatch cdlPlatform = new CountDownLatch(1);\n+        CountDownLatch cdlVirtual = new CountDownLatch(1);\n+        startTest(cdlPlatform, Thread.ofPlatform(), iterations);\n+        startTest(cdlVirtual, Thread.ofVirtual(), iterations);\n+        cdlPlatform.await();\n+        cdlVirtual.await();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestVirtualThreads.java","additions":686,"deletions":0,"binary":false,"changes":686,"status":"added"},{"patch":"@@ -538,0 +538,5 @@\n+java\/lang\/ModuleLayer\/LayerControllerTest.java                  8337048 generic-all\n+java\/lang\/ModuleLayer\/BasicLayerTest.java                       8337048 generic-all\n+\n+java\/lang\/Thread\/virtual\/stress\/Skynet.java#default             8342977 generic-all\n+\n@@ -555,0 +560,1 @@\n+com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreadsWithEliminatedLock.java 8360599 generic-all\n@@ -580,0 +586,2 @@\n+java\/net\/CookieHandler\/B6644726.java                            8365811 generic-all\n+\n@@ -733,0 +741,4 @@\n+com\/sun\/jdi\/cds\/CDSBreakpointTest.java                          8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSDeleteAllBkptsTest.java                      8304168 generic-all\n+com\/sun\/jdi\/cds\/CDSFieldWatchpoints.java                        8304168 generic-all\n+\n@@ -831,0 +843,1 @@\n+\n@@ -836,0 +849,15 @@\n+\n+############################################################################\n+\n+# valhalla\n+java\/lang\/invoke\/VarHandles\/VarHandleTestMethodHandleAccessValue.java 8367346 generic-all\n+\n+jdk\/classfile\/AccessFlagsTest.java 8366270 generic-all\n+jdk\/internal\/misc\/Unsafe\/AddressComputationContractTest.java 8368933 generic-all\n+jdk\/jfr\/event\/runtime\/TestClassLoaderStatsEvent.java 8366820 generic-all\n+\n+sun\/tools\/jhsdb\/BasicLauncherTest.java 8366806 generic-all\n+sun\/tools\/jhsdb\/HeapDumpTest.java 8366806 generic-all\n+sun\/tools\/jhsdb\/HeapDumpTestWithActiveProcess.java 8366806 generic-all\n+sun\/tools\/jhsdb\/JShellHeapDumpTest.java 8366806 generic-all\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @enablePreview\n@@ -50,0 +51,1 @@\n+ * @enablePreview\n@@ -86,0 +88,1 @@\n+    static final Random RAND = Utils.getRandomInstance();\n@@ -112,1 +115,1 @@\n-        if (RANDOM) testRandom(System.currentTimeMillis(), 50);\n+        if (RANDOM) testRandom(RAND.nextLong(), 50);\n@@ -118,2 +121,2 @@\n-        CALL_I_INT, CALL_I_DBL, CALL_I_MANY,\n-        CALL_C_INT, CALL_C_DBL, CALL_C_MANY,\n+        CALL_I_INT, CALL_I_DBL, CALL_I_MANY, CALL_I_VAL,\n+        CALL_C_INT, CALL_C_DBL, CALL_C_MANY, CALL_C_VAL,\n@@ -282,1 +285,1 @@\n-    static final Op[] WARMUP_TRACE = {Op.MH_C_INT, Op.MH_C_MANY, Op.REF_C_INT, Op.REF_C_MANY, Op.CALL_C_INT};\n+    static final Op[] WARMUP_TRACE = {Op.MH_C_INT, Op.MH_C_MANY, Op.REF_C_INT, Op.REF_C_MANY, Op.CALL_C_INT, Op.CALL_C_VAL};\n@@ -602,0 +605,112 @@\n+    \/\/\/\/ Value Classes\n+\n+    static abstract value class BaseValue {\n+        public abstract int res();\n+    };\n+\n+    static value class SmallValue extends BaseValue {\n+        int x1;\n+        int x2;\n+\n+        public SmallValue(int i) {\n+            x1 = i;\n+            x2 = i;\n+        }\n+\n+        public int res() {\n+            return x1 + x2;\n+        }\n+    };\n+\n+    static value class LargeValue extends BaseValue {\n+        int x1;\n+        int x2;\n+        int x3;\n+        int x4;\n+        int x5;\n+        int x6;\n+        int x7;\n+\n+        public LargeValue(int i) {\n+            x1 = i;\n+            x2 = i;\n+            x3 = i;\n+            x4 = i;\n+            x5 = i;\n+            x6 = i;\n+            x7 = i;\n+        }\n+\n+        public int res() {\n+            return x1 + x2 + x3 + x4 + x5 + x6 + x7;\n+        }\n+    };\n+\n+    static value class OopsValue extends BaseValue {\n+        Object x1;\n+        Object x2;\n+        Object x3;\n+        Object x4;\n+        Object x5;\n+        int x6;\n+\n+        public OopsValue(int i) {\n+            x1 = new Object();\n+            x2 = new Object();\n+            x3 = new Object();\n+            x4 = new Object();\n+            x5 = new Object();\n+            x6 = i;\n+        }\n+\n+        public int res() {\n+            return x6;\n+        }\n+    };\n+\n+    public static value class DoubleValue extends BaseValue {\n+        double d1;\n+        double d2;\n+        double d3;\n+        double d4;\n+        double d5;\n+        double d6;\n+        double d7;\n+\n+        public DoubleValue(double d) {\n+            d1 = d;\n+            d2 = d + 1;\n+            d3 = d + 2;\n+            d4 = d + 3;\n+            d5 = d + 4;\n+            d6 = d + 4;\n+            d7 = d + 4;\n+        }\n+\n+        public int res() {\n+            return (int)(d1 + d2 + d3 + d4 + d5 + d6 + d7);\n+        }\n+    };\n+\n+    static value class MixedValue extends BaseValue {\n+        byte x1;\n+        short x2;\n+        int x3;\n+        long x4;\n+        double x5;\n+        boolean x6;\n+\n+        public MixedValue(int i) {\n+            x1 = (byte)i;\n+            x2 = (short)i;\n+            x3 = i;\n+            x4 = i;\n+            x5 = i;\n+            x6 = (i % 2) == 0;\n+        }\n+\n+        public int res() {\n+            return (int)x1 + (int)x2 + (int)x3 + (int)x4 + (int)x5 + (x6 ? 1 : 0);\n+        }\n+    };\n+\n@@ -637,0 +752,2 @@\n+    static final Class<?>[] val_sig = new Class<?>[]{int.class, SmallValue.class,\n+        LargeValue.class, OopsValue.class, DoubleValue.class, MixedValue.class};\n@@ -662,0 +779,2 @@\n+            method.put(Op.CALL_I_VAL,  Fuzz.class.getDeclaredMethod(\"int_val\", val_sig));\n+            method.put(Op.CALL_C_VAL,  Fuzz.class.getDeclaredMethod(\"com_val\", val_sig));\n@@ -706,0 +825,5 @@\n+        SmallValue sv = new SmallValue(res);\n+        LargeValue lv = new LargeValue(res);\n+        OopsValue ov = new OopsValue(res);\n+        DoubleValue dv = new DoubleValue((double)res);\n+        MixedValue mv = new MixedValue(res);\n@@ -717,0 +841,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -743,0 +869,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -754,0 +885,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -780,0 +913,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -791,0 +929,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -817,0 +957,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -828,0 +973,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -854,0 +1001,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -865,0 +1017,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -882,0 +1036,104 @@\n+    @DontInline\n+    BaseValue int_val(final int depth, SmallValue x1, LargeValue x2, OopsValue x3, DoubleValue x4, MixedValue x5) {\n+        int res = x1.res();\n+\n+        int x11 = (int)res, x12 = (int)res, x13 = (int)res, x14 = (int)res;\n+        double d1 = (double)res, d2 = (double)res, d3 = (double)res, d4 = (double)res;\n+        long l1 = (long)res, l2 = (long)res, l3 = (long)res, l4 = (long)res;\n+        float f1 = (float)res, f2 = (float)res, f3 = (float)res, f4 = (float)res;\n+        Object o1 = res, o2 = res, o3 = res, o4 = res;\n+        SmallValue sv = new SmallValue(res);\n+        LargeValue lv = new LargeValue(res);\n+        OopsValue ov = new OopsValue(res);\n+        DoubleValue dv = new DoubleValue((double)res);\n+        MixedValue mv = new MixedValue(res);\n+\n+        for (int c = 1, index0 = index; c > 0; c--, maybeResetIndex(index0)) { \/\/ index0 is the index to which we return when we loop\n+            switch (next(c)) {\n+            case THROW -> throwException();\n+            case LOOP  -> { c += 2; index0 = index; }\n+            case YIELD -> { preYield(); boolean y = Continuation.yield(SCOPE); postYield(y); c++; }\n+            case DONE  -> { break; }\n+            case CALL_I_INT  -> res += int_int(depth+1, (int)res);\n+            case CALL_C_INT  -> res += com_int(depth+1, (int)res);\n+            case CALL_I_DBL  -> res += (int)int_dbl(depth+1, res);\n+            case CALL_C_DBL  -> res += (int)com_dbl(depth+1, res);\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_I_PIN  -> res += int_pin(depth+1, (int)res);\n+            case CALL_C_PIN  -> res += com_pin(depth+1, (int)res);\n+            case CALL_I_MANY -> res += int_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_C_MANY -> res += com_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_I_CTCH -> {try { res += int_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case CALL_C_CTCH -> {try { res += com_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case MH_I_INT, MH_C_INT     -> {try { res += (int)handle(current()).invokeExact(this, depth+1, (int)res);  } catch (Throwable e) { rethrow(e); }}\n+            case MH_I_MANY, MH_C_MANY   -> {try { res += (int)handle(current()).invokeExact(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (Throwable e) { rethrow(e); }}\n+            case REF_I_INT,  REF_C_INT  -> {try { res += (int)method(current()).invoke(this, depth+1, (int)res); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            case REF_I_MANY, REF_C_MANY -> {try { res += (int)method(current()).invoke(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            default -> throw new AssertionError(\"Unknown op: \" + current());\n+            }\n+        }\n+\n+        int positiveRes = (res == Integer.MIN_VALUE) ? Integer.MAX_VALUE : Math.abs(res);\n+        switch (positiveRes % 5) {\n+            case 0 -> { return log(new SmallValue(res)); }\n+            case 1 -> { return log(new LargeValue(res)); }\n+            case 2 -> { return log(new OopsValue(res)); }\n+            case 3 -> { return log(new DoubleValue((double)res)); }\n+            case 4 -> { return log(new MixedValue(res)); }\n+            default -> throw new AssertionError(\"Invalid case\");\n+        }\n+    }\n+\n+    @DontInline\n+    BaseValue com_val(final int depth, SmallValue x1, LargeValue x2, OopsValue x3, DoubleValue x4, MixedValue x5) {\n+        int res = x1.res();\n+\n+        int x11 = (int)res, x12 = (int)res, x13 = (int)res, x14 = (int)res;\n+        double d1 = (double)res, d2 = (double)res, d3 = (double)res, d4 = (double)res;\n+        long l1 = (long)res, l2 = (long)res, l3 = (long)res, l4 = (long)res;\n+        float f1 = (float)res, f2 = (float)res, f3 = (float)res, f4 = (float)res;\n+        Object o1 = res, o2 = res, o3 = res, o4 = res;\n+        SmallValue sv = new SmallValue(res);\n+        LargeValue lv = new LargeValue(res);\n+        OopsValue ov = new OopsValue(res);\n+        DoubleValue dv = new DoubleValue((double)res);\n+        MixedValue mv = new MixedValue(res);\n+\n+        for (int c = 1, index0 = index; c > 0; c--, maybeResetIndex(index0)) { \/\/ index0 is the index to which we return when we loop\n+            switch (next(c)) {\n+            case THROW -> throwException();\n+            case LOOP  -> { c += 2; index0 = index; }\n+            case YIELD -> { preYield(); boolean y = Continuation.yield(SCOPE); postYield(y); c++; }\n+            case DONE  -> { break; }\n+            case CALL_I_INT  -> res += int_int(depth+1, (int)res);\n+            case CALL_C_INT  -> res += com_int(depth+1, (int)res);\n+            case CALL_I_DBL  -> res += (int)int_dbl(depth+1, res);\n+            case CALL_C_DBL  -> res += (int)com_dbl(depth+1, res);\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_I_PIN  -> res += int_pin(depth+1, (int)res);\n+            case CALL_C_PIN  -> res += com_pin(depth+1, (int)res);\n+            case CALL_I_MANY -> res += int_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_C_MANY -> res += com_mny(depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4);\n+            case CALL_I_CTCH -> {try { res += int_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case CALL_C_CTCH -> {try { res += com_int(depth+1, (int)res); } catch (FuzzException e) {}}\n+            case MH_I_INT, MH_C_INT     -> {try { res += (int)handle(current()).invokeExact(this, depth+1, (int)res);  } catch (Throwable e) { rethrow(e); }}\n+            case MH_I_MANY, MH_C_MANY   -> {try { res += (int)handle(current()).invokeExact(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (Throwable e) { rethrow(e); }}\n+            case REF_I_INT,  REF_C_INT  -> {try { res += (int)method(current()).invoke(this, depth+1, (int)res); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            case REF_I_MANY, REF_C_MANY -> {try { res += (int)method(current()).invoke(this, depth+1, x11, d1, l1, f1, o1, x12, d2, l2, f2, o2, x13, d3, l3, f3, o3, x14, d4, l4, f4, o4); } catch (InvocationTargetException e) { rethrow(e.getCause()); } catch (IllegalAccessException e) { assert false; }}\n+            default -> throw new AssertionError(\"Unknown op: \" + current());\n+            }\n+        }\n+\n+        int positiveRes = (res == Integer.MIN_VALUE) ? Integer.MAX_VALUE : Math.abs(res);\n+        switch (positiveRes % 5) {\n+            case 0 -> { return log(new SmallValue(res)); }\n+            case 1 -> { return log(new LargeValue(res)); }\n+            case 2 -> { return log(new OopsValue(res)); }\n+            case 3 -> { return log(new DoubleValue((double)res)); }\n+            case 4 -> { return log(new MixedValue(res)); }\n+            default -> throw new AssertionError(\"Invalid case\");\n+        }\n+    }\n+\n@@ -891,0 +1149,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -904,0 +1167,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -932,0 +1197,5 @@\n+        SmallValue sv = new SmallValue(x);\n+        LargeValue lv = new LargeValue(x);\n+        OopsValue ov = new OopsValue(x);\n+        DoubleValue dv = new DoubleValue((double)x);\n+        MixedValue mv = new MixedValue(x);\n@@ -945,0 +1215,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -972,0 +1244,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -983,0 +1260,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n@@ -1008,0 +1287,5 @@\n+        SmallValue sv = new SmallValue(x1);\n+        LargeValue lv = new LargeValue(x1);\n+        OopsValue ov = new OopsValue(x1);\n+        DoubleValue dv = new DoubleValue((double)x1);\n+        MixedValue mv = new MixedValue(x1);\n@@ -1019,0 +1303,2 @@\n+            case CALL_I_VAL  -> res += int_val(depth+1, sv, lv, ov, dv, mv).res();\n+            case CALL_C_VAL  -> res += com_val(depth+1, sv, lv, ov, dv, mv).res();\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":290,"deletions":4,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+        vmOptFinalFlag(map, \"TieredCompilation\");\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n@@ -72,1 +71,0 @@\n-\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+ *\n+ * READ THIS IF THIS TEST FAILS AFTER ADDING A NEW KEY TO 'compiler.properties':\n+ * The 'examples' subdirectory contains a number of examples which provoke\n+ * the reporting of most of the compiler message keys.\n+ *\n@@ -50,0 +55,1 @@\n+ * -- this is done by the \"\/\/ key:\"-comment in each fine.\n@@ -54,0 +60,4 @@\n+ * -- some keys are only reported by the compiler when specific options are\n+ *      supplied. For the purposes of this test, this can be specified by a\n+ *      comment e.g. like this: \"\/\/ options: -Xlint:empty\"\n+ *\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckExamples.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -409,1 +409,1 @@\n-            private final List<String> excludedFields = Arrays.asList(\"varargsElement\", \"targetType\");\n+            private final List<String> excludedFields = Arrays.asList(\"varargsElement\", \"targetType\", \"factoryProduct\");\n","filename":"test\/langtools\/tools\/javac\/failover\/CheckAttributedTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @ignore Verifier error\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-\n+        @SuppressWarnings(\"initialization\")\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}