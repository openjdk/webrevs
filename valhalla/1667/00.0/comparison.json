{"files":[{"patch":"@@ -482,0 +482,25 @@\n+################################################################################\n+#\n+# Static analyzer\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_STATIC_ANALYZER],\n+[\n+  UTIL_ARG_ENABLE(NAME: static-analyzer, DEFAULT: false, RESULT: STATIC_ANALYZER_ENABLED,\n+      DESC: [enable the GCC static analyzer],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if static analyzer is available])\n+        if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+          AC_MSG_RESULT([yes])\n+        else\n+          AC_MSG_RESULT([no])\n+          AVAILABLE=false\n+        fi\n+      ],\n+      IF_ENABLED: [\n+        STATIC_ANALYZER_CFLAGS=\"-fanalyzer -Wno-analyzer-fd-leak\"\n+        CFLAGS_JDKLIB=\"$CFLAGS_JDKLIB $STATIC_ANALYZER_CFLAGS\"\n+        CFLAGS_JDKEXE=\"$CFLAGS_JDKEXE $STATIC_ANALYZER_CFLAGS\"\n+      ])\n+  AC_SUBST(STATIC_ANALYZER_ENABLED)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -4437,1 +4437,1 @@\n-operand immI8_shift8()\n+operand immIDupV()\n@@ -4439,2 +4439,1 @@\n-  predicate((n->get_int() <= 127 && n->get_int() >= -128) ||\n-            (n->get_int() <= 32512 && n->get_int() >= -32768 && (n->get_int() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->get_int()));\n@@ -4449,1 +4448,1 @@\n-operand immL8_shift8()\n+operand immLDupV()\n@@ -4451,2 +4450,1 @@\n-  predicate((n->get_long() <= 127 && n->get_long() >= -128) ||\n-            (n->get_long() <= 32512 && n->get_long() >= -32768 && (n->get_long() & 0xff) == 0));\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate(n->get_long()));\n@@ -4460,0 +4458,11 @@\n+\/\/ 8 bit signed value (simm8), or #simm8 LSL 8.\n+operand immHDupV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_dup_immediate((int64_t)n->geth()));\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -7102,3 +7111,0 @@\n-\/\/ The \"ldr\" instruction loads a 32-bit word from the constant pool into a\n-\/\/ 32-bit register but only the bottom half will be populated and the top\n-\/\/ 16 bits are zero.\n@@ -7107,3 +7113,3 @@\n-  format %{\n-    \"ldrs $dst, [$constantaddress]\\t# load from constant table: half float=$con\\n\\t\"\n-  %}\n+  format %{ \"mov    rscratch1, $con\\n\\t\"\n+            \"fmov   $dst, rscratch1\"\n+         %}\n@@ -7111,1 +7117,2 @@\n-    __ ldrs(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    __ movw(rscratch1, (uint32_t)$con$$constant);\n+    __ fmovs($dst$$FloatRegister, rscratch1);\n@@ -7113,1 +7120,1 @@\n-  ins_pipe(fp_load_constant_s);\n+  ins_pipe(pipe_class_default);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -711,1 +711,1 @@\n-    snprintf(buf, sizeof buf, \"(bad)\");\n+    os::snprintf_checked(buf, sizeof buf, \"(bad)\");\n@@ -714,1 +714,1 @@\n-    snprintf(buf, sizeof buf, \"%d\", bci);\n+    os::snprintf_checked(buf, sizeof buf, \"%d\", bci);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2367,1 +2367,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n@@ -2425,1 +2425,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n+    os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n@@ -2538,1 +2538,1 @@\n-      snprintf(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n@@ -3010,1 +3010,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n@@ -3012,1 +3012,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n@@ -3014,1 +3014,1 @@\n-      snprintf(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n@@ -3122,1 +3122,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n@@ -3124,1 +3124,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n@@ -3126,1 +3126,1 @@\n-      snprintf(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n+      os::snprintf_checked(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n@@ -6267,1 +6267,1 @@\n-    snprintf(comment, sizeof comment, \"array_equals%c{\", kind);\n+    os::snprintf_checked(comment, sizeof comment, \"array_equals%c{\", kind);\n@@ -6465,1 +6465,1 @@\n-    snprintf(comment, sizeof comment, \"{string_equalsL\");\n+    os::snprintf_checked(comment, sizeof comment, \"{string_equalsL\");\n@@ -6613,1 +6613,1 @@\n-      snprintf(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n+      os::snprintf_checked(buf, sizeof buf, \"zero_words (count = %\" PRIu64 \") {\", cnt);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4561,1 +4561,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_sort\" : \"avx2_sort\");\n@@ -4564,1 +4564,1 @@\n-      snprintf(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n+      os::snprintf_checked(ebuf_, sizeof(ebuf_), VM_Version::supports_avx512_simd_sort() ? \"avx512_partition\" : \"avx2_partition\");\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"utilities\/resizableHashTable.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/macros.hpp\"\n","filename":"src\/hotspot\/share\/asm\/macroAssembler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"jvm.h\"\n@@ -29,0 +28,1 @@\n+#include \"jvm.h\"\n@@ -30,1 +30,0 @@\n-#include \"runtime\/signature_cc.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"runtime\/signature_cc.hpp\"\n","filename":"src\/hotspot\/share\/asm\/macroAssembler_common.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -297,1 +297,1 @@\n-      assert(ik->java_super()->is_loaded(), \"must be\");\n+      assert(ik->super()->is_loaded(), \"must be\");\n@@ -438,1 +438,1 @@\n-}\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -368,2 +368,2 @@\n-    _mapped_static_archive_bottom = (address)MetaspaceObj::shared_metaspace_base();\n-    _mapped_static_archive_top  = (address)MetaspaceObj::shared_metaspace_top();\n+    _mapped_static_archive_bottom = (address)MetaspaceObj::aot_metaspace_base();\n+    _mapped_static_archive_top  = (address)MetaspaceObj::aot_metaspace_top();\n@@ -543,1 +543,1 @@\n-    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_shared_static(bottom)) {\n+    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::in_aot_cache_static_region(bottom)) {\n@@ -556,1 +556,1 @@\n-  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(obj)) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::in_aot_cache(obj)) {\n@@ -566,6 +566,1 @@\n-    if (CDSConfig::is_dumping_adapters()) {\n-      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)ref->obj();\n-      return AdapterHandlerLibrary::is_abstract_method_adapter(entry) ? set_to_null : make_a_copy;\n-    } else {\n-      return set_to_null;\n-    }\n+    return CDSConfig::is_dumping_adapters() ? make_a_copy : set_to_null;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  if (CDSConfig::is_using_full_module_graph() && ik->is_shared() && pkg_entry != nullptr) {\n-    assert(MetaspaceShared::is_in_shared_metaspace(pkg_entry), \"must be\");\n+  if (CDSConfig::is_using_full_module_graph() && ik->in_aot_cache() && pkg_entry != nullptr) {\n+    assert(MetaspaceShared::in_aot_cache(pkg_entry), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-  if (k->java_super() != specified_super) {\n+  if (k->super() != specified_super) {\n@@ -567,1 +567,1 @@\n-          k->java_super()->external_name());\n+          k->super()->external_name());\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  assert(MetaspaceShared::is_in_shared_metaspace(m), \"must be\");\n+  assert(MetaspaceShared::in_aot_cache(m), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-      assert(MetaspaceShared::is_shared_static((void*)k),\n+      assert(MetaspaceShared::in_aot_cache_static_region((void*)k),\n@@ -193,1 +193,1 @@\n-      while (ak != nullptr && ak->is_shared()) {\n+      while (ak != nullptr && ak->in_aot_cache()) {\n@@ -256,1 +256,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(ik)) {\n+  if (MetaspaceShared::in_aot_cache(ik)) {\n@@ -279,1 +279,1 @@\n-  sort_methods(ik->java_super());\n+  sort_methods(ik->super());\n@@ -290,1 +290,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache(name) || is_in_buffer_space(name), \"must be\");\n@@ -296,1 +296,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(name) || is_in_buffer_space(name), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache(name) || is_in_buffer_space(name), \"must be\");\n@@ -373,1 +373,1 @@\n-      if (MetaspaceShared::is_shared_static(elem)) {\n+      if (MetaspaceShared::in_aot_cache_static_region(elem)) {\n@@ -380,1 +380,1 @@\n-        assert(!MetaspaceShared::is_shared_static(oak),\n+        assert(!MetaspaceShared::in_aot_cache_static_region(oak),\n@@ -441,1 +441,1 @@\n-      assert(MetaspaceShared::is_shared_static((void*)elm), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache_static_region((void*)elm), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1220,1 +1220,1 @@\n-        \/\/ regions, or else it would mess up the simple comparison in MetaspaceObj::is_shared().\n+        \/\/ regions, or else it would mess up the simple comparison in MetaspaceObj::in_aot_cache().\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    klass = klass->java_super();\n+    klass = klass->super();\n@@ -1224,1 +1224,1 @@\n-  if (!k->is_shared()) {\n+  if (!k->in_aot_cache()) {\n@@ -1278,1 +1278,1 @@\n-        if (!klass->is_shared()) {\n+        if (!klass->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-void* MetaspaceShared::_shared_metaspace_static_top = nullptr;\n+void* MetaspaceShared::_aot_metaspace_static_top = nullptr;\n@@ -196,2 +196,2 @@\n-    if (ik->java_super()) {\n-      dump(ik->java_super());\n+    if (ik->super()) {\n+      dump(ik->super());\n@@ -1213,1 +1213,1 @@\n-  if (ik->is_shared() && !CDSConfig::is_dumping_final_static_archive()) {\n+  if (ik->in_aot_cache() && !CDSConfig::is_dumping_final_static_archive()) {\n@@ -1262,1 +1262,1 @@\n-void MetaspaceShared::set_shared_metaspace_range(void* base, void *static_top, void* top) {\n+void MetaspaceShared::set_aot_metaspace_range(void* base, void *static_top, void* top) {\n@@ -1264,2 +1264,2 @@\n-  _shared_metaspace_static_top = static_top;\n-  MetaspaceObj::set_shared_metaspace_range(base, top);\n+  _aot_metaspace_static_top = static_top;\n+  MetaspaceObj::set_aot_metaspace_range(base, top);\n@@ -1268,3 +1268,3 @@\n-bool MetaspaceShared::is_shared_dynamic(void* p) {\n-  if ((p < MetaspaceObj::shared_metaspace_top()) &&\n-      (p >= _shared_metaspace_static_top)) {\n+bool MetaspaceShared::in_aot_cache_dynamic_region(void* p) {\n+  if ((p < MetaspaceObj::aot_metaspace_top()) &&\n+      (p >= _aot_metaspace_static_top)) {\n@@ -1277,2 +1277,2 @@\n-bool MetaspaceShared::is_shared_static(void* p) {\n-  if (is_in_shared_metaspace(p) && !is_shared_dynamic(p)) {\n+bool MetaspaceShared::in_aot_cache_static_region(void* p) {\n+  if (in_aot_cache(p) && !in_aot_cache_dynamic_region(p)) {\n@@ -1378,1 +1378,1 @@\n-    set_shared_metaspace_range(cds_base, static_mapinfo->mapped_end(), cds_end);\n+    set_aot_metaspace_range(cds_base, static_mapinfo->mapped_end(), cds_end);\n@@ -1386,1 +1386,1 @@\n-    set_shared_metaspace_range(nullptr, nullptr, nullptr);\n+    set_aot_metaspace_range(nullptr, nullptr, nullptr);\n@@ -1476,1 +1476,1 @@\n-    \/\/ archives, or else it would mess up the simple comparison in MetaspaceObj::is_shared().\n+    \/\/ archives, or else it would mess up the simple comparison in MetaspaceObj::in_aot_cache().\n@@ -2085,3 +2085,3 @@\n-    address base = (address)MetaspaceObj::shared_metaspace_base();\n-    address static_top = (address)_shared_metaspace_static_top;\n-    address top = (address)MetaspaceObj::shared_metaspace_top();\n+    address base = (address)MetaspaceObj::aot_metaspace_base();\n+    address static_top = (address)_aot_metaspace_static_top;\n+    address top = (address)MetaspaceObj::aot_metaspace_top();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  static void* _shared_metaspace_static_top;\n+  static void* _aot_metaspace_static_top;\n@@ -104,2 +104,2 @@\n-  static bool is_in_shared_metaspace(const void* p) {\n-    return MetaspaceObj::is_shared((const MetaspaceObj*)p);\n+  static bool in_aot_cache(const void* p) {\n+    return MetaspaceObj::in_aot_cache((const MetaspaceObj*)p);\n@@ -108,1 +108,1 @@\n-  static void set_shared_metaspace_range(void* base, void *static_top, void* top) NOT_CDS_RETURN;\n+  static void set_aot_metaspace_range(void* base, void *static_top, void* top) NOT_CDS_RETURN;\n@@ -110,2 +110,5 @@\n-  static bool is_shared_dynamic(void* p) NOT_CDS_RETURN_(false);\n-  static bool is_shared_static(void* p) NOT_CDS_RETURN_(false);\n+  \/\/ inside the metaspace of the AOT cache, or the static CDS archive\n+  static bool in_aot_cache_static_region(void* p) NOT_CDS_RETURN_(false);\n+\n+  \/\/ inside the metaspace of the dynamic static CDS archive\n+  static bool in_aot_cache_dynamic_region(void* p) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    os::vsnprintf(e, m - e, fmt, args);\n+    (void) os::vsnprintf(e, m - e, fmt, args);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1683,1 +1683,1 @@\n-      ik = ik->java_super();\n+      ik = ik->super();\n@@ -1702,1 +1702,1 @@\n-    ik = ik->java_super();\n+    ik = ik->super();\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4117,1 +4117,1 @@\n-  const InstanceKlass* const super = ik->java_super();\n+  const InstanceKlass* const super = ik->super();\n@@ -4260,1 +4260,1 @@\n-  const Klass* const super = this_klass->super();\n+  const InstanceKlass* const super = this_klass->super();\n@@ -4263,3 +4263,1 @@\n-    const InstanceKlass* super_ik = InstanceKlass::cast(super);\n-\n-      classfile_icce_error(\"class %s cannot inherit from final class %s\", super_ik, THREAD);\n+      classfile_icce_error(\"class %s cannot inherit from final class %s\", super, THREAD);\n@@ -4270,1 +4268,1 @@\n-    if (super_ik->is_sealed()) {\n+    if (super->is_sealed()) {\n@@ -4273,1 +4271,1 @@\n-      if (!super_ik->has_as_permitted_subclass(this_klass, ss)) {\n+      if (!super->has_as_permitted_subclass(this_klass, ss)) {\n@@ -4283,3 +4281,3 @@\n-        super_ik->name() != vmSymbols::java_lang_Object() &&\n-        super_ik->is_identity_class()) {\n-      classfile_icce_error(\"value class %s cannot inherit from class %s\", super_ik, THREAD);\n+        super->name() != vmSymbols::java_lang_Object() &&\n+        super->is_identity_class()) {\n+      classfile_icce_error(\"value class %s cannot inherit from class %s\", super, THREAD);\n@@ -4290,1 +4288,1 @@\n-      Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);\n+      Reflection::verify_class_access(this_klass, super, false);\n@@ -4294,1 +4292,1 @@\n-                                                      InstanceKlass::cast(super),\n+                                                      super,\n@@ -4390,1 +4388,1 @@\n-      const InstanceKlass* k = this_klass->java_super();\n+      const InstanceKlass* k = this_klass->super();\n@@ -4396,1 +4394,1 @@\n-          super_m = InstanceKlass::cast(k)->lookup_method(name, signature);\n+          super_m = k->lookup_method(name, signature);\n@@ -4422,1 +4420,1 @@\n-          k = super_m->method_holder()->java_super();\n+          k = super_m->method_holder()->super();\n@@ -4426,1 +4424,1 @@\n-        k = k->java_super();\n+        k = k->super();\n@@ -5566,1 +5564,1 @@\n-      if (ik->java_super() != nullptr) {\n+      if (ik->super() != nullptr) {\n@@ -5569,1 +5567,1 @@\n-                   ik->java_super()->external_name());\n+                   ik->super()->external_name());\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -419,1 +419,1 @@\n-    } else if (k->is_shared() && k->is_objArray_klass()) {\n+    } else if (k->in_aot_cache() && k->is_objArray_klass()) {\n@@ -884,1 +884,1 @@\n-  if (!m->is_shared()) {\n+  if (!m->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-    ik = ik->super() == nullptr ? nullptr : InstanceKlass::cast(ik->super());\n+    ik = ik->super() == nullptr ? nullptr : ik->super();\n@@ -697,1 +697,1 @@\n-        ik = ik->java_super();\n+        ik = ik->super();\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -944,1 +944,1 @@\n-  if (!k->is_shared()) {\n+  if (!k->in_aot_cache()) {\n@@ -982,1 +982,1 @@\n-  if (k->is_shared() && k->has_archived_mirror_index()) {\n+  if (k->in_aot_cache() && k->has_archived_mirror_index()) {\n@@ -2650,2 +2650,2 @@\n-  size_t buf_off = os::snprintf_checked(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n-\n+  int buf_off = os::snprintf(buf, buf_size, \"\\tat %s.%s(\", klass_name, method_name);\n+  assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2655,1 +2655,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s@%s\/\", module_name, module_version);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2657,1 +2658,2 @@\n-      buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s\/\", module_name);\n+      assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2672,1 +2674,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s:%d)\", source_file_name, line_number);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2675,1 +2678,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"%s)\", source_file_name);\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n@@ -2678,1 +2682,2 @@\n-        buf_off += os::snprintf_checked(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        buf_off += os::snprintf(buf + buf_off, buf_size - buf_off, \"Unknown Source)\");\n+        assert(static_cast<size_t>(buf_off) < buf_size, \"buffer is wrong size\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -462,1 +462,1 @@\n-      InstanceKlass* superk = klassk->java_super();\n+      InstanceKlass* superk = klassk->super();\n@@ -1044,1 +1044,1 @@\n-  assert(super_type->is_shared(), \"must be\");\n+  assert(super_type->in_aot_cache(), \"must be\");\n@@ -1079,1 +1079,1 @@\n-    bool check_super = check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n+    bool check_super = check_shared_class_super_type(ik, ik->super(),\n@@ -1176,1 +1176,1 @@\n-  assert(ik->is_shared(), \"sanity\");\n+  assert(ik->in_aot_cache(), \"sanity\");\n@@ -1866,1 +1866,1 @@\n-        !klass_being_linked->is_shared()) {\n+        !klass_being_linked->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    !(klass->is_shared() && klass->is_rewritten()));\n+    !(klass->in_aot_cache() && klass->is_rewritten()));\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  _mutable_data(nullptr),\n+  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n@@ -163,0 +163,3 @@\n+  } else {\n+    \/\/ We need unique and valid not null address\n+    assert(_mutable_data == blob_end(), \"sanity\");\n@@ -164,1 +167,0 @@\n-  assert(_mutable_data != nullptr || _mutable_data_size == 0, \"No mutable data => mutable data size is 0\");\n@@ -173,1 +175,1 @@\n-  _mutable_data(nullptr),\n+  _mutable_data(header_begin() + size), \/\/ default value is blob_end()\n@@ -187,1 +189,0 @@\n-  assert(_mutable_data == nullptr && _mutable_data_size == 0, \"invariant\");\n@@ -190,0 +191,1 @@\n+  assert(_mutable_data == blob_end(), \"sanity\");\n@@ -200,1 +202,1 @@\n-    _mutable_data = nullptr;\n+    _mutable_data = blob_end(); \/\/ default value\n@@ -209,7 +211,11 @@\n-  os::free(_mutable_data);\n-  _mutable_data = nullptr;\n-  _mutable_data_size = 0;\n-  delete _oop_maps;\n-  _oop_maps = nullptr;\n-  _relocation_size = 0;\n-\n+  assert(_mutable_data != nullptr, \"should never be null\");\n+  if (_mutable_data != blob_end()) {\n+    os::free(_mutable_data);\n+    _mutable_data = blob_end(); \/\/ Valid not null address\n+    _mutable_data_size = 0;\n+    _relocation_size = 0;\n+  }\n+  if (_oop_maps != nullptr) {\n+    delete _oop_maps;\n+    _oop_maps = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1345,2 +1345,2 @@\n-    \/\/ native wrapper does not have read-only data\n-    _immutable_data          = nullptr;\n+    \/\/ native wrapper does not have read-only data but we need unique not null address\n+    _immutable_data          = blob_end();\n@@ -1532,1 +1532,2 @@\n-      _immutable_data     = nullptr;\n+      \/\/ We need unique not null address\n+      _immutable_data     = blob_end();\n@@ -2168,2 +2169,3 @@\n-\n-  delete _pc_desc_container;\n+  if (_pc_desc_container != nullptr) {\n+    delete _pc_desc_container;\n+  }\n@@ -2172,4 +2174,4 @@\n-  os::free(_immutable_data);\n-  _immutable_data = nullptr;\n-  _immutable_data_size = 0;\n-\n+  if (_immutable_data != blob_end()) {\n+    os::free(_immutable_data);\n+    _immutable_data = blob_end(); \/\/ Valid not null address\n+  }\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1064,1 +1064,3 @@\n-  julong free_memory = os::free_memory();\n+  size_t free_memory = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::free_memory(free_memory);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -973,0 +973,1 @@\n+  assert(ref_processor() != nullptr, \"Sanity\");\n@@ -977,9 +978,0 @@\n-  return PSParallelCompact::invoke_no_policy(clear_all_soft_refs);\n-}\n-\n-\/\/ This method contains no policy. You should probably\n-\/\/ be calling invoke() instead.\n-bool PSParallelCompact::invoke_no_policy(bool clear_all_soft_refs) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-  assert(ref_processor() != nullptr, \"Sanity\");\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -156,0 +156,74 @@\n+inline HeapWord* PSPromotionManager::allocate_in_young_gen(Klass* klass,\n+                                                           size_t obj_size,\n+                                                           uint age) {\n+  HeapWord* result = _young_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_young_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (YoungPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = young_space()->cas_allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _young_lab.flush();\n+\n+    HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n+    if (lab_base != nullptr) {\n+      _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n+      \/\/ Try the young lab allocation again.\n+      result = _young_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, false, &_young_lab);\n+    } else {\n+      _young_gen_is_full = true;\n+    }\n+  }\n+  if (result == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n+    _young_gen_has_alloc_failure = true;\n+  }\n+  return result;\n+}\n+\n+inline HeapWord* PSPromotionManager::allocate_in_old_gen(Klass* klass,\n+                                                         size_t obj_size,\n+                                                         uint age) {\n+#ifndef PRODUCT\n+  if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    return nullptr;\n+  }\n+#endif  \/\/ #ifndef PRODUCT\n+\n+  HeapWord* result = _old_lab.allocate(obj_size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+  if (_old_gen_is_full) {\n+    return nullptr;\n+  }\n+  \/\/ Do we allocate directly, or flush and refill?\n+  if (obj_size > (OldPLABSize \/ 2)) {\n+    \/\/ Allocate this object directly\n+    result = old_gen()->allocate(obj_size);\n+    promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, nullptr);\n+  } else {\n+    \/\/ Flush and fill\n+    _old_lab.flush();\n+\n+    HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n+    if (lab_base != nullptr) {\n+      _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n+      \/\/ Try the old lab allocation again.\n+      result = _old_lab.allocate(obj_size);\n+      promotion_trace_event(cast_to_oop(result), klass, obj_size, age, true, &_old_lab);\n+    }\n+  }\n+  if (result == nullptr) {\n+    _old_gen_is_full = true;\n+  }\n+  return result;\n+}\n+\n@@ -189,25 +263,1 @@\n-      new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-      if (new_obj == nullptr && !_young_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (YoungPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(young_space()->cas_allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, false, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _young_lab.flush();\n-\n-          HeapWord* lab_base = young_space()->cas_allocate(YoungPLABSize);\n-          if (lab_base != nullptr) {\n-            _young_lab.initialize(MemRegion(lab_base, YoungPLABSize));\n-            \/\/ Try the young lab allocation again.\n-            new_obj = cast_to_oop(_young_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, false, &_young_lab);\n-          } else {\n-            _young_gen_is_full = true;\n-          }\n-        }\n-        if (new_obj == nullptr && !_young_gen_is_full && !_young_gen_has_alloc_failure) {\n-          _young_gen_has_alloc_failure = true;\n-        }\n-      }\n+      new_obj = cast_to_oop(allocate_in_young_gen(klass, new_obj_size, age));\n@@ -219,2 +269,2 @@\n-#ifndef PRODUCT\n-    if (ParallelScavengeHeap::heap()->promotion_should_fail()) {\n+    new_obj = cast_to_oop(allocate_in_old_gen(klass, new_obj_size, age));\n+    if (new_obj == nullptr) {\n@@ -223,36 +273,0 @@\n-#endif  \/\/ #ifndef PRODUCT\n-\n-    new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-\n-    if (new_obj == nullptr) {\n-      if (!_old_gen_is_full) {\n-        \/\/ Do we allocate directly, or flush and refill?\n-        if (new_obj_size > (OldPLABSize \/ 2)) {\n-          \/\/ Allocate this object directly\n-          new_obj = cast_to_oop(old_gen()->allocate(new_obj_size));\n-          promotion_trace_event(new_obj, klass, new_obj_size, age, true, nullptr);\n-        } else {\n-          \/\/ Flush and fill\n-          _old_lab.flush();\n-\n-          HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n-          if(lab_base != nullptr) {\n-            _old_lab.initialize(MemRegion(lab_base, OldPLABSize));\n-            \/\/ Try the old lab allocation again.\n-            new_obj = cast_to_oop(_old_lab.allocate(new_obj_size));\n-            promotion_trace_event(new_obj, klass, new_obj_size, age, true, &_old_lab);\n-          }\n-        }\n-      }\n-\n-      \/\/ This is the promotion failed test, and code handling.\n-      \/\/ The code belongs here for two reasons. It is slightly\n-      \/\/ different than the code below, and cannot share the\n-      \/\/ CAS testing code. Keeping the code here also minimizes\n-      \/\/ the impact on the common case fast path code.\n-\n-      if (new_obj == nullptr) {\n-        _old_gen_is_full = true;\n-        return oop_promotion_failed(o, test_mark);\n-      }\n-    }\n@@ -290,1 +304,1 @@\n-    \/\/ So, the is->objArray() test would be very infrequent.\n+    \/\/ So, the objArray test would be very infrequent.\n@@ -292,1 +306,1 @@\n-        new_obj->is_refArray() &&\n+        klass->is_refArray_klass() &&\n@@ -299,2 +313,1 @@\n-      if (StringDedup::is_enabled() &&\n-          java_lang_String::is_instance(new_obj) &&\n+      if (StringDedup::is_enabled_string(klass) &&\n@@ -308,1 +321,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":80,"deletions":68,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"oops\/oopsHierarchy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -34,1 +35,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/modRefBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/z\/zAddress.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"gc\/z\/zAddress.hpp\"\n@@ -37,1 +37,0 @@\n-#include \"utilities\/debug.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"utilities\/debug.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/refArrayOop.hpp\"\n+#include \"oops\/refArrayOop.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zIterator.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1039,1 +1039,1 @@\n-                           resolved_iklass->is_shared() ? \"is_shared\" : \"\",\n+                           resolved_iklass->in_aot_cache() ? \"in_aot_cache\" : \"\",\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-    if (_pool->pool_holder()->is_shared()) {\n+    if (_pool->pool_holder()->in_aot_cache()) {\n@@ -570,2 +570,2 @@\n-  if (klass->is_shared()) {\n-    assert(!klass->is_rewritten(), \"rewritten shared classes cannot be rewritten again\");\n+  if (klass->in_aot_cache()) {\n+    assert(!klass->is_rewritten(), \"rewritten classes in the AOT cache cannot be rewritten again\");\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2015,1 +2015,1 @@\n-    Klass* k = iklass->local_interfaces()->at(index);\n+    InstanceKlass* k = iklass->local_interfaces()->at(index);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -264,1 +264,1 @@\n-  \/\/ When CDS is enabled, all shared metaspace objects are mapped\n+  \/\/ All metsapce objects in the AOT cache (CDS archive) are mapped\n@@ -266,5 +266,5 @@\n-  \/\/ two pointers to quickly determine if something is in the\n-  \/\/ shared metaspace.\n-  \/\/ When CDS is not enabled, both pointers are set to null.\n-  static void* _shared_metaspace_base;  \/\/ (inclusive) low address\n-  static void* _shared_metaspace_top;   \/\/ (exclusive) high address\n+  \/\/ two pointers to quickly determine if a MetaspaceObj is in the\n+  \/\/ AOT cache.\n+  \/\/ When AOT\/CDS is not enabled, both pointers are set to null.\n+  static void* _aot_metaspace_base;  \/\/ (inclusive) low address\n+  static void* _aot_metaspace_top;   \/\/ (exclusive) high address\n@@ -276,1 +276,1 @@\n-  \/\/ non-shared or shared metaspace.\n+  \/\/ regular- or aot metaspace.\n@@ -280,2 +280,2 @@\n-  static bool is_shared(const MetaspaceObj* p) {\n-    \/\/ If no shared metaspace regions are mapped, _shared_metaspace_{base,top} will\n+  static bool in_aot_cache(const MetaspaceObj* p) {\n+    \/\/ If no shared metaspace regions are mapped, _aot_metaspace_{base,top} will\n@@ -283,2 +283,2 @@\n-    return (((void*)p) < _shared_metaspace_top &&\n-            ((void*)p) >= _shared_metaspace_base);\n+    return (((void*)p) < _aot_metaspace_top &&\n+            ((void*)p) >= _aot_metaspace_base);\n@@ -286,1 +286,1 @@\n-  bool is_shared() const { return MetaspaceObj::is_shared(this); }\n+  bool in_aot_cache() const { return MetaspaceObj::in_aot_cache(this); }\n@@ -288,2 +288,2 @@\n-  static bool is_shared(const MetaspaceObj* p) { return false; }\n-  bool is_shared() const { return false; }\n+  static bool in_aot_cache(const MetaspaceObj* p) { return false; }\n+  bool in_aot_cache() const { return false; }\n@@ -294,3 +294,3 @@\n-  static void set_shared_metaspace_range(void* base, void* top) {\n-    _shared_metaspace_base = base;\n-    _shared_metaspace_top = top;\n+  static void set_aot_metaspace_range(void* base, void* top) {\n+    _aot_metaspace_base = base;\n+    _aot_metaspace_top = top;\n@@ -299,2 +299,2 @@\n-  static void* shared_metaspace_base() { return _shared_metaspace_base; }\n-  static void* shared_metaspace_top()  { return _shared_metaspace_top;  }\n+  static void* aot_metaspace_base() { return _aot_metaspace_base; }\n+  static void* aot_metaspace_top()  { return _aot_metaspace_top;  }\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -40,0 +39,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -41,1 +41,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -43,0 +42,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -371,0 +371,1 @@\n+        assert(cie->klass()->is_instance_klass(), \"elements array contains only instance klasses\");\n@@ -409,1 +410,1 @@\n-  Klass* super = ((InstanceKlass*)cie->klass())->java_super();\n+  InstanceKlass* super = InstanceKlass::cast(cie->klass())->super();\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/annotations.hpp\"\n@@ -32,1 +33,0 @@\n-#include \"oops\/annotations.hpp\"\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"oops\/klass.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -39,1 +39,0 @@\n-#include \"oops\/instanceClassLoaderKlass.inline.hpp\"\n@@ -42,0 +41,1 @@\n+#include \"oops\/klass.hpp\"\n@@ -43,1 +43,0 @@\n-#include \"oops\/typeArrayKlass.inline.hpp\"\n@@ -45,0 +44,1 @@\n+#include \"oops\/typeArrayKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"oops\/flatArrayOop.inline.hpp\"\n@@ -39,1 +39,1 @@\n-#include \"oops\/objArrayOop.inline.hpp\"\n+#include \"oops\/objArrayOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/oopFactory.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-    if (MetaspaceShared::is_shared_dynamic((void*)k)) {\n+    if (MetaspaceShared::in_aot_cache_dynamic_region((void*)k)) {\n@@ -289,1 +289,1 @@\n-    } else if (MetaspaceShared::is_shared_static((void*)k)) {\n+    } else if (MetaspaceShared::in_aot_cache_static_region((void*)k)) {\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -388,2 +388,2 @@\n-  assert(on_stack(), \"should always be set for shared constant pools\");\n-  assert(is_shared(), \"should always be set for shared constant pools\");\n+  assert(on_stack(), \"should always be set for constant pools in AOT cache\");\n+  assert(in_aot_cache(), \"should always be set for constant pools in AOT cache\");\n@@ -433,1 +433,1 @@\n-  \/\/ Shared ConstantPools are in the RO region, so the _flags cannot be modified.\n+  \/\/ ConstantPools in AOT cache are in the RO region, so the _flags cannot be modified.\n@@ -435,1 +435,1 @@\n-  \/\/ class redefinition. Since shared ConstantPools cannot be deallocated anyway,\n+  \/\/ class redefinition. Since such ConstantPools cannot be deallocated anyway,\n@@ -437,1 +437,1 @@\n-  _flags |= (_on_stack | _is_shared);\n+  _flags |= (_on_stack | _in_aot_cache);\n@@ -2290,1 +2290,1 @@\n-      assert(!is_shared(), \"should always be set for shared constant pools\");\n+      assert(!in_aot_cache(), \"should always be set for constant pools in AOT cache\");\n@@ -2296,1 +2296,1 @@\n-    if (!is_shared()) {\n+    if (!in_aot_cache()) {\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    _is_shared            = 4,\n+    _in_aot_cache         = 4,\n@@ -215,1 +215,1 @@\n-    assert(!is_shared(), \"should never be called on shared ConstantPools\");\n+    assert(!in_aot_cache(), \"should never be called on ConstantPools in AOT cache\");\n@@ -251,2 +251,2 @@\n-  \/\/ Faster than MetaspaceObj::is_shared() - used by set_on_stack()\n-  bool is_shared() const                     { return (_flags & _is_shared) != 0; }\n+  \/\/ Shadows MetaspaceObj::in_aot_cache(). It's faster and is used by set_on_stack()\n+  bool in_aot_cache() const               { return (_flags & _in_aot_cache) != 0; }\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-  assert(!is_shared(), \"shared caches are not deallocated\");\n+  assert(!in_aot_cache(), \"objects in aot metaspace are not deallocated\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-        result = result->java_super();\n+        result = result->super();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2157,1 +2157,1 @@\n-  os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n+  (void) os::vsnprintf(msg_buffer, sizeof(msg_buffer), format, ap);\n@@ -2160,1 +2160,1 @@\n-  os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n+  (void) os::snprintf(msg_buffer2, sizeof(msg_buffer2), \"%s in method %s\", msg_buffer, method()->name()->as_C_string());\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-      !methods->is_shared()) {\n+      !methods->in_aot_cache()) {\n@@ -638,1 +638,1 @@\n-                                          const Klass* super_klass,\n+                                          const InstanceKlass* super_klass,\n@@ -647,2 +647,2 @@\n-                    InstanceKlass::cast(super_klass)->transitive_interfaces();\n-    if (ti != sti && ti != nullptr && !ti->is_shared()) {\n+                    super_klass->transitive_interfaces();\n+    if (ti != sti && ti != nullptr && !ti->in_aot_cache()) {\n@@ -655,1 +655,1 @@\n-      local_interfaces != nullptr && !local_interfaces->is_shared()) {\n+      local_interfaces != nullptr && !local_interfaces->in_aot_cache()) {\n@@ -662,1 +662,1 @@\n-  if (record_components != nullptr && !record_components->is_shared()) {\n+  if (record_components != nullptr && !record_components->in_aot_cache()) {\n@@ -706,1 +706,1 @@\n-      !method_ordering()->is_shared()) {\n+      !method_ordering()->in_aot_cache()) {\n@@ -714,1 +714,1 @@\n-      !default_methods()->is_shared()) {\n+      !default_methods()->in_aot_cache()) {\n@@ -722,1 +722,1 @@\n-      !default_vtable_indices()->is_shared()) {\n+      !default_vtable_indices()->in_aot_cache()) {\n@@ -735,1 +735,1 @@\n-      !secondary_supers()->is_shared()) {\n+      !secondary_supers()->in_aot_cache()) {\n@@ -744,1 +744,1 @@\n-  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->is_shared()) {\n+  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->in_aot_cache()) {\n@@ -749,1 +749,1 @@\n-  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->is_shared()) {\n+  if (fieldinfo_search_table() != nullptr && !fieldinfo_search_table()->in_aot_cache()) {\n@@ -754,1 +754,1 @@\n-  if (fields_status() != nullptr && !fields_status()->is_shared()) {\n+  if (fields_status() != nullptr && !fields_status()->in_aot_cache()) {\n@@ -768,1 +768,1 @@\n-    if (!constants()->is_shared()) {\n+    if (!constants()->in_aot_cache()) {\n@@ -779,1 +779,1 @@\n-      !inner_classes()->is_shared()) {\n+      !inner_classes()->in_aot_cache()) {\n@@ -786,1 +786,1 @@\n-      !nest_members()->is_shared()) {\n+      !nest_members()->in_aot_cache()) {\n@@ -793,1 +793,1 @@\n-      !permitted_subclasses()->is_shared()) {\n+      !permitted_subclasses()->in_aot_cache()) {\n@@ -800,1 +800,1 @@\n-      !loadable_descriptors()->is_shared()) {\n+      !loadable_descriptors()->in_aot_cache()) {\n@@ -806,1 +806,1 @@\n-  if (annotations() != nullptr && !annotations()->is_shared()) {\n+  if (annotations() != nullptr && !annotations()->in_aot_cache()) {\n@@ -823,1 +823,1 @@\n-         java_super() == vmClasses::Record_klass();\n+         super() == vmClasses::Record_klass();\n@@ -838,1 +838,1 @@\n-  InstanceKlass* s = java_super();\n+  InstanceKlass* s = super();\n@@ -840,1 +840,1 @@\n-          (s != nullptr && s->java_super() == vmClasses::Enum_klass()));\n+          (s != nullptr && s->super() == vmClasses::Enum_klass()));\n@@ -904,1 +904,1 @@\n-  InstanceKlass* s = java_super();\n+  InstanceKlass* s = super();\n@@ -1055,1 +1055,1 @@\n-  Klass* super_klass = super();\n+  InstanceKlass* super_klass = super();\n@@ -1070,2 +1070,1 @@\n-    InstanceKlass* ik_super = InstanceKlass::cast(super_klass);\n-    ik_super->link_class_impl(CHECK_false);\n+    super_klass->link_class_impl(CHECK_false);\n@@ -1115,1 +1114,1 @@\n-        if (is_shared()) {\n+        if (in_aot_cache()) {\n@@ -1134,1 +1133,1 @@\n-      } else if (is_shared()) {\n+      } else if (in_aot_cache()) {\n@@ -1152,1 +1151,1 @@\n-      if (is_shared() && verified_at_dump_time() &&\n+      if (in_aot_cache() && verified_at_dump_time() &&\n@@ -1194,1 +1193,1 @@\n-    assert(is_shared(), \"rewriting an unshared class?\");\n+    assert(in_aot_cache(), \"rewriting an unshared class?\");\n@@ -1704,1 +1703,1 @@\n-  InstanceKlass* super_ik = ik->java_super();\n+  InstanceKlass* super_ik = ik->super();\n@@ -1915,1 +1914,1 @@\n-    assert(is_shared(), \"must be\");\n+    assert(in_aot_cache(), \"must be\");\n@@ -2030,1 +2029,1 @@\n-    Klass* intf1 = local_interfaces()->at(i);\n+    InstanceKlass* intf1 = local_interfaces()->at(i);\n@@ -2033,1 +2032,1 @@\n-    if (InstanceKlass::cast(intf1)->find_local_field(name, sig, fd)) {\n+    if (intf1->find_local_field(name, sig, fd)) {\n@@ -2038,1 +2037,1 @@\n-    Klass* intf2 = InstanceKlass::cast(intf1)->find_interface_field(name, sig, fd);\n+    Klass* intf2 = intf1->find_interface_field(name, sig, fd);\n@@ -2057,2 +2056,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, fd);\n+  { InstanceKlass* supr = super();\n+    if (supr != nullptr) return supr->find_field(name, sig, fd);\n@@ -2077,2 +2076,2 @@\n-  { Klass* supr = super();\n-    if (supr != nullptr) return InstanceKlass::cast(supr)->find_field(name, sig, is_static, fd);\n+  { InstanceKlass* supr = super();\n+    if (supr != nullptr) return supr->find_field(name, sig, is_static, fd);\n@@ -2106,1 +2105,1 @@\n-  Klass* klass = const_cast<InstanceKlass*>(this);\n+  const InstanceKlass* klass = this;\n@@ -2108,1 +2107,1 @@\n-    if (InstanceKlass::cast(klass)->find_local_field_from_offset(offset, is_static, fd)) {\n+    if (klass->find_local_field_from_offset(offset, is_static, fd)) {\n@@ -2154,1 +2153,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = this->super();\n@@ -2171,1 +2170,1 @@\n-  InstanceKlass* super = superklass();\n+  InstanceKlass* super = this->super();\n@@ -2466,1 +2465,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2468,5 +2467,5 @@\n-    Method* const method = InstanceKlass::cast(klass)->find_method_impl(name,\n-                                                                        signature,\n-                                                                        overpass_local_mode,\n-                                                                        StaticLookupMode::find,\n-                                                                        private_mode);\n+    Method* const method = klass->find_method_impl(name,\n+                                                   signature,\n+                                                   overpass_local_mode,\n+                                                   StaticLookupMode::find,\n+                                                   private_mode);\n@@ -2489,1 +2488,1 @@\n-  const Klass* klass = this;\n+  const InstanceKlass* klass = this;\n@@ -2491,1 +2490,1 @@\n-    if (InstanceKlass::cast(klass)->has_been_redefined()) {\n+    if (klass->has_been_redefined()) {\n@@ -2568,1 +2567,1 @@\n-    if (ik->is_shared()) buf[i++] = 'S';\n+    if (ik->in_aot_cache()) buf[i++] = 'S';\n@@ -3003,1 +3002,1 @@\n-             MetaspaceShared::is_in_shared_metaspace(_package_entry)) {\n+             MetaspaceShared::in_aot_cache(_package_entry)) {\n@@ -3095,1 +3094,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(this)) {\n+  if (MetaspaceShared::in_aot_cache(this)) {\n@@ -3103,1 +3102,1 @@\n-  if (java_super() != nullptr && !java_super()->can_be_verified_at_dumptime()) {\n+  if (super() != nullptr && !super()->can_be_verified_at_dumptime()) {\n@@ -3338,1 +3337,1 @@\n-  if (!is_shared()) {\n+  if (!in_aot_cache()) {\n@@ -3342,1 +3341,1 @@\n-  if (is_shared() && _package_entry != nullptr) {\n+  if (in_aot_cache() && _package_entry != nullptr) {\n@@ -3345,1 +3344,1 @@\n-      assert(MetaspaceShared::is_in_shared_metaspace(_package_entry), \"must be\");\n+      assert(MetaspaceShared::in_aot_cache(_package_entry), \"must be\");\n@@ -4270,2 +4269,2 @@\n-    assert(this->is_shared(), \"must be\");\n-    if (MetaspaceShared::is_shared_dynamic((void*)this)) {\n+    assert(this->in_aot_cache(), \"must be\");\n+    if (MetaspaceShared::in_aot_cache_dynamic_region((void*)this)) {\n@@ -4285,1 +4284,1 @@\n-                       p2i(this),  p2i(superklass()));\n+                       p2i(this),  p2i(super()));\n@@ -4293,1 +4292,1 @@\n-                           p2i(InstanceKlass::cast(local_interfaces()->at(i))));\n+                           p2i(local_interfaces()->at(i)));\n@@ -4506,1 +4505,0 @@\n-\n@@ -4511,1 +4509,1 @@\n-JNIid::JNIid(Klass* holder, int offset, JNIid* next) {\n+JNIid::JNIid(InstanceKlass* holder, int offset, JNIid* next) {\n@@ -4518,1 +4516,0 @@\n-\n@@ -4536,2 +4533,1 @@\n-\n-void JNIid::verify(Klass* holder) {\n+void JNIid::verify(InstanceKlass* holder) {\n@@ -4540,1 +4536,1 @@\n-  end_field_offset = first_field_offset + (InstanceKlass::cast(holder)->static_field_size() * wordSize);\n+  end_field_offset = first_field_offset + (holder->static_field_size() * wordSize);\n@@ -4557,1 +4553,1 @@\n-  bool good_state = is_shared() ? (_init_state <= state)\n+  bool good_state = in_aot_cache() ? (_init_state <= state)\n@@ -4658,1 +4654,1 @@\n-      if (pvcp->is_shared()) {\n+      if (pvcp->in_aot_cache()) {\n@@ -4770,1 +4766,1 @@\n-  if (cp_ref->is_shared()) {\n+  if (cp_ref->in_aot_cache()) {\n@@ -4853,1 +4849,1 @@\n-    _current = _current->superklass(); \/\/ backtrack; no more sibling subclasses left\n+    _current = _current->java_super(); \/\/ backtrack; no more sibling subclasses left\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":68,"deletions":72,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -1028,0 +1028,6 @@\n+  \/\/ This hides Klass::super(). The _super of an InstanceKlass is\n+  \/\/ always an InstanceKlass (or nullptr)\n+  InstanceKlass* super() const {\n+    return (Klass::super() == nullptr) ? nullptr : InstanceKlass::cast(Klass::super());\n+  }\n+\n@@ -1029,1 +1035,1 @@\n-    return (super() == nullptr) ? nullptr : cast(super());\n+    return InstanceKlass::super();\n@@ -1120,1 +1126,1 @@\n-                                    const Klass* super_klass,\n+                                    const InstanceKlass* super_klass,\n@@ -1339,1 +1345,1 @@\n-  Klass*             _holder;\n+  InstanceKlass*     _holder;\n@@ -1348,1 +1354,1 @@\n-  Klass* holder() const           { return _holder; }\n+  InstanceKlass* holder() const   { return _holder; }\n@@ -1352,1 +1358,1 @@\n-  JNIid(Klass* holder, int offset, JNIid* next);\n+  JNIid(InstanceKlass* holder, int offset, JNIid* next);\n@@ -1366,1 +1372,1 @@\n-  void verify(Klass* holder);\n+  void verify(InstanceKlass* holder);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -597,6 +597,0 @@\n-\/\/ superklass links\n-InstanceKlass* Klass::superklass() const {\n-  assert(super() == nullptr || super()->is_instance_klass(), \"must be instance klass\");\n-  return _super == nullptr ? nullptr : InstanceKlass::cast(_super);\n-}\n-\n@@ -665,2 +659,2 @@\n-  \/\/ add ourselves to superklass' subklass list\n-  InstanceKlass* super = superklass();\n+  \/\/ add ourselves to super' subklass list\n+  InstanceKlass* super = java_super();\n@@ -669,1 +663,1 @@\n-          && (super->superklass() == nullptr || !is_interface())),\n+          && (super->java_super() == nullptr || !is_interface())),\n@@ -678,1 +672,1 @@\n-      \/\/ set our sibling to be the superklass' previous first subklass\n+      \/\/ set our sibling to be the super' previous first subklass\n@@ -797,1 +791,1 @@\n-  set_is_shared();\n+  set_in_aot_cache();\n@@ -850,1 +844,1 @@\n-  assert(is_shared(), \"must be set\");\n+  assert(in_aot_cache(), \"must be set\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  u2     _shared_class_flags;\n+  u2 _shared_class_flags;\n@@ -183,1 +183,1 @@\n-    _is_shared_class                       = 1 << 0,  \/\/ shadows MetaspaceObj::is_shared\n+    _in_aot_cache                          = 1 << 0,\n@@ -224,1 +224,3 @@\n-  \/\/ If this is not what your code expects, you're probably looking for Klass::java_super().\n+  \/\/ If this is not what your code expects, you're probably looking for:\n+  \/\/ - Klass::java_super() - if you have a Klass*\n+  \/\/ - InstanceKlass::super() - if you have an InstanceKlass* ik, ik->super() returns InstanceKlass*.\n@@ -304,1 +306,0 @@\n-  InstanceKlass* superklass() const;\n@@ -384,2 +385,2 @@\n-  bool is_shared() const                { \/\/ shadows MetaspaceObj::is_shared)()\n-    CDS_ONLY(return (_shared_class_flags & _is_shared_class) != 0;)\n+  bool in_aot_cache() const                { \/\/ shadows MetaspaceObj::in_aot_cache)()\n+    CDS_ONLY(return (_shared_class_flags & _in_aot_cache) != 0;)\n@@ -389,2 +390,2 @@\n-  void set_is_shared() {\n-    CDS_ONLY(_shared_class_flags |= _is_shared_class;)\n+  void set_in_aot_cache() {\n+    CDS_ONLY(_shared_class_flags |= _in_aot_cache;)\n@@ -634,1 +635,1 @@\n-    assert(is_shared(), \"use this for shared classes only\");\n+    assert(in_aot_cache(), \"use this for shared classes only\");\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  return _klass->is_shared() && !MetaspaceShared::remapped_readwrite() && _klass->verified_at_dump_time();\n+  return _klass->in_aot_cache() && !MetaspaceShared::remapped_readwrite() && _klass->verified_at_dump_time();\n@@ -68,1 +68,1 @@\n-    GrowableArray<Method*>* all_mirandas, const Klass* super,\n+    GrowableArray<Method*>* all_mirandas, const InstanceKlass* super,\n@@ -166,1 +166,1 @@\n-  bool is_shared = _klass->is_shared();\n+  bool in_aot_cache = _klass->in_aot_cache();\n@@ -181,1 +181,1 @@\n-    assert(!is_shared, \"sanity\");\n+    assert(!in_aot_cache, \"sanity\");\n@@ -349,1 +349,1 @@\n-    superk = superk->super() == nullptr ? nullptr : InstanceKlass::cast(superk->super());\n+    superk = superk->super();\n@@ -634,1 +634,1 @@\n-                                         const Klass* super,\n+                                         const InstanceKlass* super,\n@@ -686,1 +686,1 @@\n-  const Klass* k = super;\n+  const InstanceKlass* ik = super;\n@@ -691,1 +691,1 @@\n-  while (k != nullptr) {\n+  while (ik != nullptr) {\n@@ -693,1 +693,1 @@\n-    super_method = InstanceKlass::cast(k)->lookup_method(name, signature);\n+    super_method = ik->lookup_method(name, signature);\n@@ -725,1 +725,1 @@\n-      k = superk->super(); \/\/ haven't found an override match yet; continue to look\n+      ik = superk->super(); \/\/ haven't found an override match yet; continue to look\n@@ -744,3 +744,2 @@\n-  const InstanceKlass *sk = InstanceKlass::cast(super);\n-  if (sk->has_miranda_methods()) {\n-    if (sk->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n+  if (super->has_miranda_methods()) {\n+    if (super->lookup_method_in_all_interfaces(name, signature, Klass::DefaultsLookupMode::find) != nullptr) {\n@@ -840,1 +839,1 @@\n-                             Array<Method*>* default_methods, const Klass* super,\n+                             Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -869,6 +868,5 @@\n-  for (const Klass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super())\n-  {\n-     Method* found_mth = InstanceKlass::cast(cursuper)->find_local_method(name, signature,\n-                                                                          Klass::OverpassLookupMode::find,\n-                                                                          Klass::StaticLookupMode::skip,\n-                                                                          Klass::PrivateLookupMode::skip);\n+  for (const InstanceKlass* cursuper = super; cursuper != nullptr; cursuper = cursuper->super()) {\n+     Method* found_mth = cursuper->find_local_method(name, signature,\n+                                                     Klass::OverpassLookupMode::find,\n+                                                     Klass::StaticLookupMode::skip,\n+                                                     Klass::PrivateLookupMode::skip);\n@@ -896,1 +894,1 @@\n-    Array<Method*>* default_methods, const Klass* super, bool is_interface) {\n+    Array<Method*>* default_methods, const InstanceKlass* super, bool is_interface) {\n@@ -916,2 +914,1 @@\n-        const InstanceKlass *sk = InstanceKlass::cast(super);\n-        if (sk->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n+        if (super->lookup_method_in_all_interfaces(im->name(), im->signature(), Klass::DefaultsLookupMode::find) == nullptr) {\n@@ -931,1 +928,1 @@\n-                               const Klass* super,\n+                               const InstanceKlass* super,\n@@ -1095,1 +1092,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace((void*)&_method) &&\n+  if (MetaspaceShared::in_aot_cache((void*)&_method) &&\n@@ -1281,1 +1278,1 @@\n-               m->is_shared(),\n+               m->in_aot_cache(),\n@@ -1589,2 +1586,1 @@\n-    InstanceKlass* sk = InstanceKlass::cast(super);\n-    klassVtable vt = sk->vtable();\n+    klassVtable vt = super->vtable();\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":24,"deletions":28,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                                                   const Klass* super,\n+                                                   const InstanceKlass* super,\n@@ -119,1 +119,1 @@\n-                                     const Klass* super,\n+                                     const InstanceKlass* super,\n@@ -138,1 +138,1 @@\n-                         Array<Method*>* default_methods, const Klass* super,\n+                         Array<Method*>* default_methods, const InstanceKlass* super,\n@@ -146,1 +146,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n@@ -151,1 +151,1 @@\n-      const Klass* super,\n+      const InstanceKlass* super,\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -155,0 +155,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::throw_AbstractMethodError_entry();\n+  }\n@@ -160,0 +163,3 @@\n+  if (is_abstract()) {\n+    return SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  }\n@@ -455,1 +461,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n+  if (in_aot_cache() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n@@ -466,1 +472,1 @@\n-  if (is_shared() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n+  if (in_aot_cache() && !MetaspaceShared::remapped_readwrite() && method_holder()->verified_at_dump_time()) {\n@@ -1239,1 +1245,1 @@\n-  if (!CDSConfig::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+  if (!CDSConfig::is_dumping_adapters()) {\n@@ -1292,1 +1298,1 @@\n-    if (adapter()->is_shared()) {\n+    if (adapter()->in_aot_cache()) {\n@@ -1327,1 +1333,6 @@\n-  if (_adapter == nullptr) {\n+  if (is_abstract()) {\n+    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+    h_method->_from_compiled_entry = wrong_method_abstract;\n+    h_method->_from_compiled_inline_entry = wrong_method_abstract;\n+    h_method->_from_compiled_inline_ro_entry = wrong_method_abstract;\n+  } else if (_adapter == nullptr) {\n@@ -1330,0 +1341,3 @@\n+    h_method->_from_compiled_entry = adapter()->get_c2i_entry();\n+    h_method->_from_compiled_inline_entry = adapter()->get_c2i_inline_entry();\n+    h_method->_from_compiled_inline_ro_entry = adapter()->get_c2i_inline_ro_entry();\n@@ -1350,0 +1364,1 @@\n+  assert(!mh->is_abstract(), \"abstract methods do not have adapters\");\n@@ -1368,3 +1383,0 @@\n-  mh->_from_compiled_entry = adapter->get_c2i_entry();\n-  mh->_from_compiled_inline_entry = adapter->get_c2i_inline_entry();\n-  mh->_from_compiled_inline_ro_entry = adapter->get_c2i_inline_ro_entry();\n@@ -2234,1 +2246,1 @@\n-  } else if (m->is_shared()) {\n+  } else if (m->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,27 @@\n+  \/\/ Notes on copy constructor, copy assignment operator, and copy_from().\n+  \/\/ These are necessary for generating deterministic CDS archives.\n+  \/\/\n+  \/\/ We have some unused padding on 64-bit platforms (4 bytes at the tail end).\n+  \/\/\n+  \/\/ When ResolvedFieldEntries in a ConstantPoolCache are allocated from the metaspace,\n+  \/\/ their entire content (including the padding) is filled with zeros. They are\n+  \/\/ then initialized with initialize_resolved_entries_array() in cpCache.cpp from a\n+  \/\/ GrowableArray.\n+  \/\/\n+  \/\/ The GrowableArray is initialized in rewriter.cpp, using ResolvedFieldEntries that\n+  \/\/ are originally allocated from the C++ stack. Functions like GrowableArray::expand_to()\n+  \/\/ will also allocate ResolvedFieldEntries from the stack. These may have random bits\n+  \/\/ in the padding as the C++ compiler is allowed to leave the padding in uninitialized\n+  \/\/ states.\n+  \/\/\n+  \/\/ If we use the default copy constructor and\/or default copy assignment operator,\n+  \/\/ the random padding will be copied into the GrowableArray, from there\n+  \/\/ to the ConstantPoolCache, and eventually to the CDS archive. As a result, the\n+  \/\/ CDS archive will contain random bits, causing failures in\n+  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java (usually on Windows).\n+  \/\/\n+  \/\/ By using copy_from(), we can prevent the random padding from being copied,\n+  \/\/ ensuring that the ResolvedFieldEntries in a ConstantPoolCache (and thus the\n+  \/\/ CDS archive) will have all zeros in the padding.\n+\n+  \/\/ Copy constructor\n@@ -87,0 +114,1 @@\n+  \/\/ Copy assignment operator\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -362,0 +362,9 @@\n+  product(bool, UseAutoVectorizationPredicate, true, DIAGNOSTIC,            \\\n+          \"Use AutoVectorization predicate (for speculative compilation)\")  \\\n+                                                                            \\\n+  product(bool, UseAutoVectorizationSpeculativeAliasingChecks, true, DIAGNOSTIC, \\\n+          \"Allow the use Multiversioning or Predicate to add aliasing\"      \\\n+          \"runtime checks. Runtime checks will only be inserted if either\"  \\\n+          \"LoopMultiversioning or UseAutoVectorizationPredicate are\"        \\\n+          \"enabled.\")                                                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4648,1 +4648,3 @@\n-  add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  if (UseAutoVectorizationPredicate) {\n+    add_parse_predicate(Deoptimization::Reason_auto_vectorization_check, nargs);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -665,0 +665,2 @@\n+\/\/ For more descriptions on multiversioning:\n+\/\/ See: PhaseIdealLoop::maybe_multiversion_for_auto_vectorization_runtime_checks\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"classfile\/javaClasses.hpp\"\n@@ -48,1 +47,0 @@\n-#include \"memory\/allocation.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"classfile\/classLoaderData.hpp\"\n@@ -65,1 +64,0 @@\n-#include \"oops\/recordComponent.hpp\"\n@@ -69,0 +67,1 @@\n+#include \"oops\/recordComponent.hpp\"\n@@ -78,0 +77,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -80,0 +80,1 @@\n+#include \"runtime\/handshake.hpp\"\n@@ -82,2 +83,0 @@\n-#include \"runtime\/deoptimization.hpp\"\n-#include \"runtime\/handshake.hpp\"\n@@ -97,1 +96,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n@@ -1357,2 +1356,1 @@\n-      InstanceKlass* ik = InstanceKlass::cast(klass);\n-      Klass* k = ik->local_interfaces()->at(index);\n+      InstanceKlass* k = InstanceKlass::cast(klass)->local_interfaces()->at(index);\n@@ -3610,1 +3608,1 @@\n-  if (!caller_ik->is_shared()) {\n+  if (!caller_ik->in_aot_cache()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"classfile\/klassFactory.hpp\"\n+#include \"classfile\/klassFactory.hpp\"\n@@ -58,1 +58,1 @@\n-#include \"prims\/resolvedMethodTable.hpp\"\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -1360,1 +1360,3 @@\n-\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1362,2 +1364,2 @@\n-      (\"loading name=%s kind=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), _class_load_kind, os::available_memory() >> 10);\n+      (\"loading name=%s kind=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), _class_load_kind, avail_mem >> 10);\n@@ -1527,1 +1529,2 @@\n-\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -1529,1 +1532,1 @@\n-      (\"loaded name=%s (avail_mem=\" UINT64_FORMAT \"K)\", the_class->external_name(), os::available_memory() >> 10);\n+      (\"loaded name=%s (avail_mem=%zuK)\", the_class->external_name(), avail_mem >> 10);\n@@ -4487,0 +4490,3 @@\n+    size_t avail_mem = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::available_memory(avail_mem);\n@@ -4488,2 +4494,2 @@\n-      (\"redefined name=%s, count=%d (avail_mem=\" UINT64_FORMAT \"K)\",\n-       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), os::available_memory() >> 10);\n+      (\"redefined name=%s, count=%d (avail_mem=%zuK)\",\n+       the_class->external_name(), java_lang_Class::classRedefinedCount(the_class->java_mirror()), avail_mem >> 10);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"prims\/jvmtiEventController.hpp\"\n@@ -64,1 +63,1 @@\n-#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n@@ -67,2 +66,1 @@\n-#include \"runtime\/vmThread.hpp\"\n-#include \"utilities\/objectBitSet.inline.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -71,0 +69,1 @@\n+#include \"utilities\/objectBitSet.inline.hpp\"\n@@ -698,1 +697,1 @@\n-  for (InstanceKlass* super_klass = ik->java_super(); super_klass != nullptr; super_klass = super_klass->java_super()) {\n+  for (InstanceKlass* super_klass = ik->super(); super_klass != nullptr; super_klass = super_klass->super()) {\n@@ -725,1 +724,1 @@\n-  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->super()) {\n@@ -730,1 +729,1 @@\n-  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->java_super()) {\n+  for (InstanceKlass* klass = ik; klass != nullptr; klass = klass->super()) {\n@@ -2969,4 +2968,4 @@\n-    InstanceKlass* java_super = ik->java_super();\n-    if (java_super != nullptr && java_super != vmClasses::Object_klass()) {\n-      oop super = java_super->java_mirror();\n-      if (!CallbackInvoker::report_superclass_reference(mirror, super)) {\n+    InstanceKlass* super_klass = ik->super();\n+    if (super_klass != nullptr && super_klass != vmClasses::Object_klass()) {\n+      oop super_oop = super_klass->java_mirror();\n+      if (!CallbackInvoker::report_superclass_reference(mirror, super_oop)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -55,1 +55,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -60,0 +59,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -37,2 +39,0 @@\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n@@ -62,1 +62,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n@@ -55,1 +56,0 @@\n-#include \"memory\/iterator.inline.hpp\"\n@@ -73,1 +73,0 @@\n-#include \"oops\/objArrayOop.inline.hpp\"\n@@ -134,1 +133,1 @@\n-#include \"osContainer_linux.hpp\"\n+#include \"osContainer_linux.hpp\"\n@@ -2265,1 +2264,1 @@\n-  return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n+  return (jboolean)MetaspaceShared::in_aot_cache(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n@@ -2616,2 +2615,2 @@\n-  LINUX_ONLY(return os::Linux::physical_memory();)\n-  return os::physical_memory();\n+  LINUX_ONLY(return static_cast<jlong>(os::Linux::physical_memory());)\n+  return static_cast<jlong>(os::physical_memory());\n@@ -2622,1 +2621,4 @@\n-  return os::available_memory();\n+  size_t avail_mem = 0;\n+  \/\/ Return value ignored - defaulting to 0 on failure.\n+  (void)os::available_memory(avail_mem);\n+  return static_cast<jlong>(avail_mem);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -583,0 +583,2 @@\n+  { \"PretenureSizeThreshold\",       JDK_Version::undefined(), JDK_Version::jdk(26), JDK_Version::jdk(27) },\n+\n@@ -1533,1 +1535,1 @@\n-      phys_mem = os::physical_memory();\n+      phys_mem = static_cast<julong>(os::physical_memory());\n@@ -1539,1 +1541,1 @@\n-    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(os::physical_memory(), (julong)MaxRAM)\n+    phys_mem = FLAG_IS_DEFAULT(MaxRAM) ? MIN2(static_cast<julong>(os::physical_memory()), (julong)MaxRAM)\n@@ -1661,1 +1663,2 @@\n-  julong total_memory = os::physical_memory();\n+  size_t phys_mem = os::physical_memory();\n+  julong total_memory = static_cast<julong>(phys_mem);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/barrierSet.hpp\"\n@@ -42,1 +42,1 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n@@ -60,1 +60,1 @@\n-#include \"runtime\/smallRegisterMap.inline.hpp\"\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"interpreter\/bytecode.hpp\"\n@@ -53,0 +52,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -55,1 +55,1 @@\n-#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -60,1 +60,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -74,1 +73,0 @@\n-#include \"runtime\/fieldDescriptor.hpp\"\n@@ -97,1 +95,1 @@\n-#include \"runtime\/vframeArray.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n@@ -1554,1 +1552,1 @@\n-  InstanceKlass* super = klass->superklass();\n+  InstanceKlass* super = klass->super();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -32,2 +34,0 @@\n-#include \"oops\/fieldStreams.inline.hpp\"\n-#include \"oops\/inlineKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -42,1 +43,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n@@ -54,1 +54,1 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,4 +198,1 @@\n-  \/\/ Initialize TrainingData only we're recording\/replaying\n-  if (TrainingData::have_data() || TrainingData::need_data()) {\n-   TrainingData::initialize();\n-  }\n+  TrainingData::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n@@ -423,1 +423,1 @@\n-              entry_point = method->adapter()->get_i2c_entry();\n+              entry_point = method->get_i2c_entry();\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n@@ -92,2 +92,1 @@\n-#include \"runtime\/vframeArray.hpp\"\n-#include \"runtime\/vmThread.hpp\"\n+#include \"runtime\/vframeArray.hpp\"\n@@ -96,0 +95,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -1144,1 +1144,1 @@\n-                         InstanceKlass::cast(exception->klass())->external_name());\n+                         exception->klass()->external_name());\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#include \"runtime\/stackWatermarkSet.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/inlineKlass.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"oops\/inlineKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"jvm.h\"\n+#include \"jvm.h\"\n@@ -51,0 +51,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -53,1 +54,1 @@\n-#include \"metaprogramming\/primitiveConversions.hpp\"\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -59,1 +60,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -2585,1 +2585,0 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = nullptr;\n@@ -2621,14 +2620,0 @@\n-void AdapterHandlerLibrary::create_abstract_method_handler() {\n-  assert_lock_strong(AdapterHandlerLibrary_lock);\n-  \/\/ Create a special handler for abstract methods.  Abstract methods\n-  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-  \/\/ throw AbstractMethodError just in case.\n-  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-  \/\/ AbstractMethodError for invalid invocations.\n-  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-  _abstract_method_handler = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(nullptr));\n-  _abstract_method_handler->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n-                                             wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,\n-                                             wrong_method_abstract, wrong_method_abstract);\n-}\n-\n@@ -2638,1 +2623,0 @@\n-    MutexLocker mu(AdapterHandlerLibrary_lock);\n@@ -2641,1 +2625,0 @@\n-    create_abstract_method_handler();\n@@ -2713,3 +2696,0 @@\n-  if (method->is_abstract()) {\n-    return nullptr;\n-  }\n@@ -3138,0 +3118,1 @@\n+  assert(!method->is_abstract(), \"abstract methods do not have adapters\");\n@@ -3164,2 +3145,0 @@\n-  } else if (method->is_abstract()) {\n-    return _abstract_method_handler;\n@@ -3190,1 +3169,1 @@\n-      if (!entry->is_shared() && VerifyAdapterSharing) {\n+      if (!entry->in_aot_cache() && VerifyAdapterSharing) {\n@@ -3979,7 +3958,0 @@\n-bool AdapterHandlerLibrary::is_abstract_method_adapter(AdapterHandlerEntry* entry) {\n-  if (entry == _abstract_method_handler) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":33,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -835,1 +835,0 @@\n-  static AdapterHandlerEntry* _abstract_method_handler;\n@@ -853,1 +852,0 @@\n-  static void create_abstract_method_handler();\n@@ -883,2 +881,0 @@\n-  static bool is_abstract_method_adapter(AdapterHandlerEntry* adapter);\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/inlineKlass.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"oops\/inlineKlass.inline.hpp\"\n@@ -44,1 +44,0 @@\n-#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n@@ -37,1 +38,0 @@\n-#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/objectMonitor.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n@@ -94,1 +94,1 @@\n-#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -99,1 +99,1 @@\n-#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"logging\/logStream.hpp\"\n+#include \"logging\/logStream.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/vmOperation.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -59,1 +58,1 @@\n-#include \"oops\/constMethod.hpp\"\n+#include \"oops\/constMethod.hpp\"\n@@ -104,1 +103,1 @@\n-#include \"runtime\/vmStructs.hpp\"\n+#include \"runtime\/vmStructs.hpp\"\n@@ -326,1 +325,1 @@\n-  nonstatic_field(JNIid,                       _holder,                                       Klass*)                                \\\n+  nonstatic_field(JNIid,                       _holder,                                       InstanceKlass*)                        \\\n@@ -353,2 +352,2 @@\n-     static_field(MetaspaceObj,                _shared_metaspace_base,                        void*)                                 \\\n-     static_field(MetaspaceObj,                _shared_metaspace_top,                         void*)                                 \\\n+     static_field(MetaspaceObj,                _aot_metaspace_base,                           void*)                                 \\\n+     static_field(MetaspaceObj,                _aot_metaspace_top,                            void*)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -871,1 +871,1 @@\n-  static void dump_instance_class(AbstractDumpWriter* writer, Klass* k);\n+  static void dump_instance_class(AbstractDumpWriter* writer, InstanceKlass* ik);\n@@ -1396,3 +1396,1 @@\n-void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-\n+void DumperSupport::dump_instance_class(AbstractDumpWriter* writer, InstanceKlass* ik) {\n@@ -1419,2 +1417,2 @@\n-  InstanceKlass* java_super = ik->java_super();\n-  if (java_super == nullptr) {\n+  InstanceKlass* super = ik->super();\n+  if (super == nullptr) {\n@@ -1423,1 +1421,1 @@\n-    writer->write_classID(java_super);\n+    writer->write_classID(super);\n@@ -2009,1 +2007,1 @@\n-      DumperSupport::dump_instance_class(writer(), k);\n+      DumperSupport::dump_instance_class(writer(), InstanceKlass::cast(k));\n@@ -2621,1 +2619,1 @@\n-  os::snprintf(path, buf_size, \"%s.p%d\", base_path, seq);\n+  os::snprintf_checked(path, buf_size, \"%s.p%d\", base_path, seq);\n@@ -3135,1 +3133,4 @@\n-    julong max_threads = os::free_memory() \/ (20 * M);\n+    size_t free_memory = 0;\n+    \/\/ Return value ignored - defaulting to 0 on failure.\n+    (void)os::free_memory(free_memory);\n+    julong max_threads = free_memory \/ (20 * M);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+\/\/ offset_of was a workaround for UB with offsetof uses that are no longer an\n+\/\/ issue.  This can be removed once all uses have been converted.\n+#define offset_of(klass, field) offsetof(klass, field)\n@@ -653,12 +656,4 @@\n-\/\/ the fancy casts are a hopefully portable way\n-\/\/ to do unsigned 32 to 64 bit type conversion\n-inline void set_low (jlong* value, jint low )    { *value &= (jlong)0xffffffff << 32;\n-                                                   *value |= (jlong)(julong)(juint)low; }\n-\n-inline void set_high(jlong* value, jint high)    { *value &= (jlong)(julong)(juint)0xffffffff;\n-                                                   *value |= (jlong)high       << 32; }\n-\n-  jlong result = 0; \/\/ initialization to avoid warning\n-  set_high(&result, h);\n-  set_low(&result,  l);\n-  return result;\n+  \/\/ First cast jint values to juint, so cast to julong will zero-extend.\n+  julong high = (julong)(juint)h << 32;\n+  julong low = (julong)(juint)l;\n+  return (jlong)(high | low);\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-     * of the inner class}  It is in the range of unsigned short, {@code [0,\n-     * 0xFFFF]}.\n+     * of the inner class}  It is a {@link java.lang.classfile##u2 u2} value.\n@@ -108,0 +107,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n@@ -120,1 +121,3 @@\n-     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass} represents a primitive type\n+     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass}\n+     *         represents a primitive type, or if {@code flags} is not {@link\n+     *         java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassInfo.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+     * @throws IllegalArgumentException if the number of types in {@code locals}\n+     *         or {@code stack} exceeds the limit of {@link java.lang.classfile##u2 u2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n- * will cause a {@code NullPointerException}, unless otherwise specified. <\/p>\n+ * will cause a {@code NullPointerException}, unless otherwise specified.\n@@ -276,0 +276,8 @@\n+ * The Class-File API performs checks to ensure arguments are representable in\n+ * the {@code class} file format.  A value that is lost when it is built to a\n+ * {@code class} file and re-parsed to a model is rejected with an {@link\n+ * IllegalArgumentException}.  For example, a negative value or a value over\n+ * {@code 65535} is lost when built to a {@link ##u2 u2} item, with\n+ * the range {@code [0, 65535]}.  In particular, any variable-sized table\n+ * exceeding its maximum representable size is rejected.\n+ * <p>\n@@ -277,3 +285,4 @@\n- * (except for null arguments checks). All builders and classfile elements factory\n- * methods accepts the provided information without implicit validation.\n- * However, fatal inconsistencies (like for example invalid code sequence or\n+ * (except for null and representable arguments checks). All builders and\n+ * classfile elements factory methods accepts the provided information without\n+ * implicit validation, as long as they are representable in the {@code class}\n+ * file format.  However, fatal inconsistencies (like invalid code sequence or\n@@ -282,1 +291,1 @@\n- * {@link IllegalArgumentException}.\n+ * {@code IllegalArgumentException}.\n@@ -297,3 +306,3 @@\n- * directly from raw values, with no additional conversions or validations.\n- * Following example uses intentionally wrong class name form and it is applied\n- * without any validation or conversion.\n+ * directly from raw values, with no additional conversions or validations, as\n+ * long as they are representable.  Following example uses intentionally wrong\n+ * class name form, which is applied without any validation or conversion.\n@@ -454,0 +463,23 @@\n+ * <h3 id=\"data-types\">Conventional data types<\/h3>\n+ * Chapter {@jvms 4} of the <cite>Java Virtual Machine Specification<\/cite>\n+ * defines a few conventional data types in the {@code class} file format.\n+ * They are consistently represented as {@code int} in the API model.\n+ * Out-of-bound values provided for these data types to the API result in {@link\n+ * IllegalArgumentException}.\n+ * <dl>\n+ * <dt id=\"u1\">{@code u1}<\/dt>\n+ * <dd>One-byte {@linkplain Byte#toUnsignedInt(byte) unsigned} integer, in the\n+ * range {@code [0, 255]}.\n+ * <br>See {@link java.io.DataInput#readUnsignedByte()}.<\/dd>\n+ * <dt id=\"u2\">{@code u2}<\/dt>\n+ * <dd>Two-byte {@linkplain Short#toUnsignedInt(short) unsigned} integer, in the\n+ * range {@code [0, 65535]}.\n+ * <br>Equivalent to a Java {@link Character char}.  Frequently used for flag\n+ * fields and indices and sizes of list structures.\n+ * <br>See {@link java.io.DataInput#readUnsignedShort()}.<\/dd>\n+ * <dt id=\"u4\">{@code u4}<\/dt>\n+ * <dd>Four-byte {@linkplain Integer#toUnsignedLong(int) unsigned} integer, in\n+ * the range {@code [0, 4294967295]}.\n+ * <br>See {@link java.io.DataInput#readInt()}.<\/dd>\n+ * <\/dl>\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    public  AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n+    public AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n@@ -47,1 +47,1 @@\n-        this.flagsMask = mask;\n+        this.flagsMask = Util.checkFlags(mask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AccessFlagsImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,3 +322,1 @@\n-        if (utflen > 65535) {\n-            throw new IllegalArgumentException(\"string too long\");\n-        }\n+        Util.checkU2(utflen, \"utf8 length\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+        Util.checkU2(handlersSize, \"exception handlers\");\n@@ -191,1 +192,1 @@\n-            writeExceptionHandlers(buf, pos);\n+            writeExceptionHandlers(buf, pos, handlersSize);\n@@ -195,2 +196,1 @@\n-    private void writeExceptionHandlers(BufWriterImpl buf, int pos) {\n-        int handlersSize = handlers.size();\n+    private void writeExceptionHandlers(BufWriterImpl buf, int pos, int handlersSize) {\n@@ -231,0 +231,1 @@\n+                        Util.checkU2(crSize, \"character range count\");\n@@ -266,0 +267,1 @@\n+                        Util.checkU2(lvSize, \"local variable count\");\n@@ -295,0 +297,1 @@\n+                        Util.checkU2(lvtSize, \"local variable type count\");\n@@ -445,1 +448,1 @@\n-            b.writeU2(buf.size() \/ 4);\n+            b.writeU2(Util.checkU2(buf.size() \/ 4, \"line number count\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -74,1 +74,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -393,3 +393,3 @@\n-            locals = List.copyOf(locals);\n-            stack = List.copyOf(stack);\n-            unsetFields = List.copyOf(unsetFields);\n+            locals = Util.sanitizeU2List(locals);\n+            stack = Util.sanitizeU2List(stack);\n+            unsetFields = Util.sanitizeU2List(unsetFields);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-            this.exceptions = List.copyOf(exceptions);\n+            this.exceptions = Util.sanitizeU2List(exceptions);\n@@ -247,1 +247,1 @@\n-            this.entries = List.copyOf(entries);\n+            this.entries = Util.sanitizeU2List(entries);\n@@ -271,1 +271,1 @@\n-            this.innerClasses = List.copyOf(innerClasses);\n+            this.innerClasses = Util.sanitizeU2List(innerClasses);\n@@ -295,1 +295,1 @@\n-            this.components = List.copyOf(components);\n+            this.components = Util.sanitizeU2List(components);\n@@ -350,1 +350,1 @@\n-            this.parameters = List.copyOf(parameters);\n+            this.parameters = Util.sanitizeU1List(parameters);\n@@ -424,1 +424,1 @@\n-            this.hashes = List.copyOf(hashes);\n+            this.hashes = Util.sanitizeU2List(hashes);\n@@ -449,1 +449,1 @@\n-        private final Collection<PackageEntry> packages;\n+        private final List<PackageEntry> packages;\n@@ -453,1 +453,1 @@\n-            this.packages = List.copyOf(packages);\n+            this.packages = Util.sanitizeU2List(packages);\n@@ -458,1 +458,1 @@\n-            return List.copyOf(packages);\n+            return packages;\n@@ -477,1 +477,1 @@\n-            resolutionFlags = flags;\n+            resolutionFlags = Util.checkU2(flags, \"resolution flags\");\n@@ -501,1 +501,1 @@\n-            this.permittedSubclasses = List.copyOf(permittedSubclasses);\n+            this.permittedSubclasses = Util.sanitizeU2List(permittedSubclasses);\n@@ -549,1 +549,1 @@\n-            this.memberEntries = List.copyOf(memberEntries);\n+            this.memberEntries = Util.sanitizeU2List(memberEntries);\n@@ -669,1 +669,1 @@\n-            this.ranges = List.copyOf(ranges);\n+            this.ranges = Util.sanitizeU2List(ranges);\n@@ -693,1 +693,1 @@\n-            this.lines = List.copyOf(lines);\n+            this.lines = Util.sanitizeU2List(lines);\n@@ -717,1 +717,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -741,1 +741,1 @@\n-            this.locals = List.copyOf(locals);\n+            this.locals = Util.sanitizeU2List(locals);\n@@ -765,1 +765,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -789,1 +789,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -813,7 +813,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -843,7 +837,1 @@\n-            \/\/ deep copy\n-            var array = elements.toArray().clone();\n-            for (int i = 0; i < array.length; i++) {\n-                array[i] = List.copyOf((List<?>) array[i]);\n-            }\n-\n-            this.elements = SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+            this.elements = Util.sanitizeParameterAnnotations(elements);\n@@ -873,1 +861,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -897,1 +885,1 @@\n-            this.elements = List.copyOf(elements);\n+            this.elements = Util.sanitizeU2List(elements);\n@@ -915,1 +903,8 @@\n-            implements CharacterRangeInfo { }\n+            implements CharacterRangeInfo {\n+\n+        public UnboundCharacterRangeInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(endPc, \"end pc\");\n+            Util.checkU2(flags, \"flags\");\n+        }\n+    }\n@@ -926,0 +921,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -930,1 +926,6 @@\n-            implements LineNumberInfo { }\n+            implements LineNumberInfo {\n+        public UnboundLineNumberInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(lineNumber, \"line number\");\n+        }\n+    }\n@@ -958,0 +959,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -967,1 +969,2 @@\n-            exportsTo = List.copyOf(exportsTo);\n+            Util.checkFlags(exportsFlagsMask);\n+            exportsTo = Util.sanitizeU2List(exportsTo);\n@@ -984,1 +987,2 @@\n-            opensTo = List.copyOf(opensTo);\n+            Util.checkFlags(opensFlagsMask);\n+            opensTo = Util.sanitizeU2List(opensTo);\n@@ -993,1 +997,1 @@\n-            providesWith = List.copyOf(providesWith);\n+            providesWith = Util.sanitizeU2List(providesWith);\n@@ -1002,0 +1006,1 @@\n+            Util.checkFlags(requiresFlagsMask);\n@@ -1013,1 +1018,1 @@\n-            attributes = List.copyOf(attributes);\n+            attributes = Util.sanitizeU2List(attributes);\n@@ -1023,1 +1028,1 @@\n-            targetPath = List.copyOf(targetPath);\n+            targetPath = Util.sanitizeU1List(targetPath);\n@@ -1055,1 +1060,1 @@\n-            this.moduleFlags = moduleFlags;\n+            this.moduleFlags = Util.checkFlags(moduleFlags);\n@@ -1057,5 +1062,5 @@\n-            this.requires = List.copyOf(requires);\n-            this.exports = List.copyOf(exports);\n-            this.opens = List.copyOf(opens);\n-            this.uses = List.copyOf(uses);\n-            this.provides = List.copyOf(provides);\n+            this.requires = Util.sanitizeU2List(requires);\n+            this.exports = Util.sanitizeU2List(exports);\n+            this.opens = Util.sanitizeU2List(opens);\n+            this.uses = Util.sanitizeU2List(uses);\n+            this.provides = Util.sanitizeU2List(provides);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":53,"deletions":48,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-public class Util {\n+public final class Util {\n@@ -155,0 +155,27 @@\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U1, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU1List(List<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU1(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input list to make it immutable, and verify its size can\n+    \/\/\/ be represented with U2, throwing IAE otherwise.\n+    public static <T> List<T> sanitizeU2List(Collection<T> input) {\n+        var copy = List.copyOf(input);\n+        checkU2(copy.size(), \"list size\");\n+        return copy;\n+    }\n+\n+    \/\/\/ Sanitizes an input nested list of parameter annotations.\n+    public static List<List<Annotation>> sanitizeParameterAnnotations(List<List<Annotation>> input) {\n+        var array = input.toArray().clone();\n+        checkU1(array.length, \"parameter count\");\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = sanitizeU2List((List<?>) array[i]);\n+        }\n+\n+        return SharedSecrets.getJavaUtilCollectionAccess().listFromTrustedArray(array);\n+    }\n+\n@@ -195,0 +222,25 @@\n+    \/\/\/ Ensures the given value won't be truncated when written as a u1\n+    public static int checkU1(int incoming, String valueName) {\n+        if ((incoming & ~0xFF) != 0) {\n+            throw outOfRangeException(incoming, valueName, \"u1\");\n+        }\n+        return incoming;\n+    }\n+\n+    \/\/\/ Ensures the given value won't be truncated when written as a u2\n+    public static char checkU2(int incoming, String valueName) {\n+        if ((incoming & ~0xFFFF) != 0)\n+            throw outOfRangeException(incoming, valueName, \"u2\");\n+        return (char) incoming;\n+    }\n+\n+    public static IllegalArgumentException outOfRangeException(int value, String fieldName, String typeName) {\n+        return new IllegalArgumentException(\n+                String.format(\"%s out of range of %d: %d\", fieldName, typeName, value));\n+    }\n+\n+    \/\/\/ Ensures the given mask won't be truncated when written as an access flag\n+    public static char checkFlags(int mask) {\n+        return checkU2(mask, \"access flags\");\n+    }\n+\n@@ -244,0 +296,1 @@\n+        Util.checkU2(size, \"attributes count\");\n@@ -252,0 +305,1 @@\n+        Util.checkU2(size, \"member count\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+    vm.cds.nocoops.archive.available \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2956,0 +2956,10 @@\n+    public static final String REPLICATE_HF = PREFIX + \"REPLICATE_HF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF, \"replicateHF\");\n+    }\n+\n+    public static final String REPLICATE_HF_IMM8 = PREFIX + \"REPLICATE_HF_IMM8\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(REPLICATE_HF_IMM8, \"replicateHF_imm8_gt128b\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -50,0 +51,1 @@\n+import java.util.stream.Stream;\n@@ -336,0 +338,65 @@\n+    \/**\n+     * Add the cross-product (cartesian product) of sets of flags as Scenarios. Unlike when when constructing\n+     * scenarios directly a string can contain multiple flags separated with a space. This allows grouping\n+     * flags that have to be specified togeher. Further, an empty string in a set stands in for \"no flag\".\n+     * <p>\n+     * Example:\n+     * <pre>\n+     *     addCrossProductScenarios(Set.of(\"\", \"-Xint\", \"-Xbatch -XX:-TieredCompilation\"),\n+     *                              Set.of(\"-XX:+UseNewCode\", \"-XX:UseNewCode2\"))\n+     * <\/pre>\n+     *   produces the following Scenarios\n+     * <pre>\n+     *     Scenario(0, \"-XX:+UseNewCode\")\n+     *     Scenario(1, \"-XX:+UseNewCode2\")\n+     *     Scenario(2, \"-Xint\", \"-XX:+UseNewCode\")\n+     *     Scenario(3, \"-Xint\", \"-XX:+UseNewCode2\")\n+     *     Scenario(4, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode\")\n+     *     Scenario(5, \"-Xbatch -XX:-TieredCompilation\", \"-XX:+UseNewCode2\")\n+     * <\/pre>\n+     *\n+     * @param sets sets of flags to generate the cross product for.\n+     * @return the same framework instance.\n+     *\/\n+    @SafeVarargs\n+    final public TestFramework addCrossProductScenarios(Set<String>... flagSets) {\n+        TestFormat.checkAndReport(flagSets != null &&\n+                                  Arrays.stream(flagSets).noneMatch(Objects::isNull) &&\n+                                  Arrays.stream(flagSets).flatMap(Set::stream).noneMatch(Objects::isNull),\n+                                  \"Flags must not be null\");\n+        if (flagSets.length == 0) {\n+            return this;\n+        }\n+\n+        int initIdx = 0;\n+        if (this.scenarioIndices != null && !this.scenarioIndices.isEmpty()) {\n+            initIdx = this.scenarioIndices.stream().max(Comparator.comparingInt(Integer::intValue)).get() + 1;\n+        }\n+        AtomicInteger idx = new AtomicInteger(initIdx);\n+\n+        Stream<List<String>> crossProduct = Arrays.stream(flagSets)\n+            .reduce(\n+                Stream.of(Collections.<String>emptyList()), \/\/ Initialize Stream<List<String>> acc with a Stream containing an empty list of Strings.\n+                (Stream<List<String>> acc, Set<String> set) ->\n+                    acc.flatMap(lAcc -> \/\/ For each List<String>> lAcc in acc...\n+                        set.stream().map(flag -> { \/\/ ...and each flag in the current set...\n+                            List<String> newList = new ArrayList<>(lAcc); \/\/ ...create a new list containing lAcc...\n+                            newList.add(flag); \/\/ ...and append the flag.\n+                            return newList;\n+                        }) \/\/ This results in one List<List<String>> for each lAcc...\n+                    ), \/\/ ...that get flattend into one big List<List<String>>.\n+                (a, b) -> Stream.concat(a, b)); \/\/ combiner; if any reduction steps are executed in parallel, just concat two streams.\n+\n+        Scenario[] newScenarios = crossProduct\n+            .map(flags -> new Scenario( \/\/ For each List<String> flags in crossProduct create a new Scenario.\n+                idx.getAndIncrement(),\n+                flags.stream() \/\/ Process flags\n+                     .map(s -> Set.of(s.split(\"[ ]\"))) \/\/ Split muliple flags in the same string into separate strings.\n+                     .flatMap(Collection::stream) \/\/ Flatten the Stream<List<String>> into Stream<String>>.\n+                     .filter(s -> !s.isEmpty()) \/\/ Remove empty string flags.\n+                     .collect(Collectors.toList())\n+                     .toArray(new String[0])))\n+            .collect(Collectors.toList()).toArray(new Scenario[0]);\n+        return addScenarios(newScenarios);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * @run main\/othervm compiler.valhalla.inlinetypes.TestArrayMetadata\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestArrayMetadata\n+ * @run main\/othervm\/timeout=300 -XX:+IgnoreUnrecognizedVMOptions\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xcomp\n+ * @run main\/othervm\/timeout=300 -Xcomp\n@@ -37,1 +37,1 @@\n- * @run main\/othervm -XX:MultiArrayExpandLimit=0\n+ * @run main\/othervm\/timeout=300 -XX:MultiArrayExpandLimit=0\n@@ -39,1 +39,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbatch\n@@ -42,1 +42,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbatch\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbatch\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayMetadata.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -52,1 +52,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -58,1 +58,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -61,1 +61,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -64,1 +64,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -67,1 +67,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -71,1 +71,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -75,1 +75,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -39,1 +39,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestC2CCalls.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n- * @run main\/othervm compiler.valhalla.inlinetypes.TestFieldNullMarkers\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -49,1 +49,1 @@\n- * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -53,1 +53,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -55,1 +55,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n@@ -57,1 +57,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -60,1 +60,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -63,1 +63,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -66,1 +66,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -69,1 +69,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -72,1 +72,1 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ * @run main\/othervm\/timeout=300 -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n- * @run main\/othervm\/timeout=450 compiler.valhalla.inlinetypes.TestLWorld\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestLWorld\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestNullableArrays\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestNullableArrays\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableArrays.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n- * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestNullableInlineTypes\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestNullableInlineTypes\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestNullableInlineTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * @run main\/othervm\/timeout=300 compiler.valhalla.inlinetypes.TestOnStackReplacement\n+ * @run main\/othervm\/timeout=600 compiler.valhalla.inlinetypes.TestOnStackReplacement\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOnStackReplacement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -36,1 +36,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -46,1 +46,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -51,1 +51,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -56,1 +56,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -61,1 +61,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -66,1 +66,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -71,1 +71,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestOopsInReturnConvention.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n@@ -57,1 +57,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeALot\n@@ -69,1 +69,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -83,1 +83,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n@@ -96,1 +96,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -109,1 +109,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -122,1 +122,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+IgnoreUnrecognizedVMOptions\n@@ -135,1 +135,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -148,1 +148,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch\n@@ -161,1 +161,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -174,1 +174,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -188,1 +188,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -202,1 +202,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -216,1 +216,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestValueConstruction.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -35,1 +35,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -38,1 +38,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -41,1 +41,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -44,1 +44,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -47,1 +47,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -50,1 +50,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -53,1 +53,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -56,1 +56,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -59,1 +59,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -62,1 +62,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -65,1 +65,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n@@ -68,1 +68,1 @@\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ * @run main\/othervm\/timeout=300 -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestVirtualThreads.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-java\/awt\/Frame\/BogusFocusableWindowState\/BogusFocusableWindowState.java 8361521 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                Fuzz\n@@ -56,3 +56,3 @@\n- * @run main\/othervm\/timeout=300 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n- *                               -XX:+PreserveFramePointer\n- *                               Fuzz\n+ * @run main\/othervm\/timeout=1200 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                                -XX:+PreserveFramePointer\n+ *                                Fuzz\n@@ -90,2 +90,1 @@\n-    static float timeoutFactor = Float.parseFloat(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n-    static int COMPILATION_TIMEOUT = (int)(5_000 * timeoutFactor); \/\/ ms\n+    static int COMPILATION_TIMEOUT = (int)(5_000 * Utils.TIMEOUT_FACTOR); \/\/ ms\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+        map.put(\"vm.cds.nocoops.archive.available\", this::vmCDSNocoopsArchiveAvailable);\n@@ -444,0 +445,10 @@\n+    \/**\n+     * Check for CDS no compressed oops archive existence.\n+     *\n+     * @return true if CDS archive classes_nocoops.jsa exists in the JDK to be tested.\n+     *\/\n+    protected String vmCDSNocoopsArchiveAvailable() {\n+        Path archive = Paths.get(System.getProperty(\"java.home\"), \"lib\", \"server\", \"classes_nocoops.jsa\");\n+        return \"\" + (\"true\".equals(vmCDS()) && Files.exists(archive));\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+jdk\/jshell\/ToolSimpleTest.java                                                  8366582    generic-all\n+jdk\/jshell\/ToolLocalSimpleTest.java                                             8366582    generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm CheckExamples\n+ * @run main\/othervm\/timeout=480 CheckExamples\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckExamples.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main CheckAttributedTree -q -r -et ERRONEOUS .\n+ * @run main\/timeout=480 CheckAttributedTree -q -r -et ERRONEOUS .\n","filename":"test\/langtools\/tools\/javac\/failover\/CheckAttributedTree.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ *      8362237\n@@ -718,0 +719,23 @@\n+    \/*\n+     * Tests in which main throws a traceless exception.\n+     *\/\n+    @Test\n+    public void testTracelessTargetException(Path base) throws IOException {\n+        tb.writeJavaFiles(base, \"\"\"\n+            class TestLauncherException extends RuntimeException {\n+                TestLauncherException() {\n+                    super(\"No trace\", null, true, false); \/\/ No writable trace\n+                }\n+\n+                public static void main(String... args) {\n+                    throw new TestLauncherException();\n+                }\n+            }\n+            \"\"\");\n+        Path file = base.resolve(\"TestLauncherException.java\");\n+        SourceLauncherTest.Result r = run(file, List.of(), List.of(\"3\"));\n+        checkEmpty(\"stdout\", r.stdOut());\n+        checkEmpty(\"stderr\", r.stdErr());\n+        checkTrace(\"exception\", r.exception(), \"TestLauncherException: No trace\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -231,3 +231,0 @@\n-    \/\/ This property is passed to child test processes\n-    public static final String TestTimeoutFactor = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-\n@@ -436,1 +433,1 @@\n-        cmd.add(\"-Dtest.timeout.factor=\" + TestTimeoutFactor);\n+        cmd.add(\"-Dtest.timeout.factor=\" + Utils.TIMEOUT_FACTOR);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}