{"files":[{"patch":"@@ -27,0 +27,3 @@\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n@@ -35,0 +38,2 @@\n+\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -41,4 +46,15 @@\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n+ * Models the {@link Attributes#loadableDescriptors() LoadableDescriptors}\n+ * attribute (JVMS {@jvms 4.7.32}), which suggests the JVM may load mentioned\n+ * types before the {@code class} file carrying this attribute is loaded.\n+ * <p>\n+ * This attribute only appears on classes, and does not permit {@linkplain\n+ * AttributeMapper#allowMultiple multiple instances} in a class.  It has a\n+ * data dependency on the {@linkplain AttributeMapper.AttributeStability#CP_REFS\n+ * constant pool}.\n+ * <p>\n+ * The attribute was introduced in the Java SE Platform version XX, major\n+ * version {@value ClassFile#JAVA_25_VERSION}. (FIXME)\n+ *\n+ * @see Attributes#loadableDescriptors()\n+ * @jvms 4.7.32 The {@code LoadableDescriptors} Attribute\n+ * @since Valhalla\n@@ -46,1 +62,1 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+@PreviewFeature(feature = PreviewFeature.Feature.VALUE_OBJECTS)\n@@ -56,0 +72,7 @@\n+    \/**\n+     * {@return the list of loadable descriptors, as nominal descriptors}\n+     *\/\n+    default List<ClassDesc> loadableDescriptorSymbols() {\n+        return Util.mappedList(loadableDescriptors(), Util::fieldTypeSymbol);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LoadableDescriptorsAttribute.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -44,2 +44,1 @@\n-import static java.lang.constant.ConstantDescs.CLASS_INIT_NAME;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -279,2 +278,8 @@\n-            case LoadableDescriptorsAttribute lda ->\n-                2 + 2 * lda.loadableDescriptors().size();\n+            case LoadableDescriptorsAttribute lda -> {\n+                for (var desc : lda.loadableDescriptorSymbols()) {\n+                    if (desc.equals(CD_void)) {\n+                        errors.add(new VerifyError(\"illegal signature %s\".formatted(desc)));\n+                    }\n+                }\n+                yield 2 + 2 * lda.loadableDescriptors().size();\n+            }\n@@ -351,2 +356,2 @@\n-            case StackMapTableAttribute smta ->\n-                2 + subSize(smta.entries(), frame -> stackMapFrameSize(frame));\n+            case StackMapTableAttribute _ ->\n+                -1; \/\/ Not sufficient info for assert unset size\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -28,0 +30,3 @@\n+import java.util.Set;\n+\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -40,0 +45,1 @@\n+    private Set<NameAndTypeEntry> _assert_unset_fields;\n@@ -42,1 +48,2 @@\n-    public VerificationFrame(int offset, int flags, int locals_size, int stack_size, int max_locals, int max_stack, VerificationType[] locals, VerificationType[] stack, VerifierImpl v) {\n+    public VerificationFrame(int offset, int flags, int locals_size, int stack_size, int max_locals, int max_stack,\n+                             VerificationType[] locals, VerificationType[] stack, Set<NameAndTypeEntry> assert_unset_fields, VerifierImpl v) {\n@@ -52,0 +59,1 @@\n+        this._assert_unset_fields = assert_unset_fields;\n@@ -112,0 +120,44 @@\n+    Set<NameAndTypeEntry> assert_unset_fields() {\n+        return _assert_unset_fields;\n+    }\n+\n+    void set_assert_unset_fields(Set<NameAndTypeEntry> table) {\n+        _assert_unset_fields = table;\n+    }\n+\n+    \/\/ Called when verifying putfields to mark strict instance fields as satisfied\n+    boolean satisfy_unset_field(Utf8Entry name, Utf8Entry signature) {\n+        var nat = TemporaryConstantPool.INSTANCE.nameAndTypeEntry(name, signature);\n+        return _assert_unset_fields.remove(nat);\n+    }\n+\n+    \/\/ Verify that all strict fields have been initialized\n+    \/\/ Strict fields must be initialized before the super constructor is called\n+    boolean verify_unset_fields_satisfied() {\n+        return _assert_unset_fields.isEmpty();\n+    }\n+\n+    \/\/ Merge incoming unset strict fields from StackMapTable with\n+    \/\/ initial strict instance fields\n+    Set<NameAndTypeEntry> merge_unset_fields(Set<NameAndTypeEntry> new_fields) {\n+        \/\/ ClassFile API: We track all strict fields in another structure, noop here\n+        return new_fields;\n+    }\n+\n+    boolean verify_unset_fields_compatibility(Set<NameAndTypeEntry> target_table) {\n+        for (var e : _assert_unset_fields) {\n+            if (!target_table.contains(e))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    void unsatisfied_strict_fields_error(VerificationWrapper klass, int bci) {\n+        _verifier.verifyError(\"All strict final fields must be initialized before super(): %d field(s), %s\"\n+                .formatted(_assert_unset_fields.size(), _assert_unset_fields));\n+    }\n+\n+    void print_strict_fields(Set<NameAndTypeEntry> table) {\n+        \/\/ ignore, we don't do stdout\/err\n+    }\n+\n@@ -184,1 +236,1 @@\n-    VerificationFrame(int max_locals, int max_stack, VerifierImpl verifier) {\n+    VerificationFrame(int max_locals, int max_stack, Set<NameAndTypeEntry> initial_strict_fields, VerifierImpl verifier) {\n@@ -201,0 +253,1 @@\n+        _assert_unset_fields = initial_strict_fields;\n@@ -206,1 +259,1 @@\n-                _verifier);\n+                _assert_unset_fields, _verifier);\n@@ -302,0 +355,10 @@\n+        \/\/ Check that assert unset fields are compatible\n+        boolean compatible = verify_unset_fields_compatibility(target.assert_unset_fields());\n+        if (!compatible) {\n+            print_strict_fields(assert_unset_fields());\n+            print_strict_fields(target.assert_unset_fields());\n+            _verifier.verifyError(\"Strict fields mismatch from %s to %s\".formatted(\n+                    assert_unset_fields(), target.assert_unset_fields()), this, target);\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationFrame.java","additions":66,"deletions":3,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -28,0 +29,1 @@\n+import java.util.HashSet;\n@@ -29,0 +31,1 @@\n+import java.util.Set;\n@@ -132,0 +135,1 @@\n+            frame.set_assert_unset_fields(stackmap_frame.assert_unset_fields());\n@@ -153,0 +157,2 @@\n+        final Set<NameAndTypeEntry> strictFields;\n+        Set<NameAndTypeEntry> _assert_unset_fields_buffer;\n@@ -209,0 +215,1 @@\n+                              Set<NameAndTypeEntry> initial_strict_fields,\n@@ -218,0 +225,2 @@\n+            strictFields = Set.copyOf(initial_strict_fields);\n+            _assert_unset_fields_buffer = initial_strict_fields;\n@@ -290,0 +299,35 @@\n+            if (frame_type == EARLY_LARVAL) {\n+                int num_unset_fields = _stream.get_u2();\n+                Set<NameAndTypeEntry> new_fields = new HashSet<>();\n+                for (int i = 0; i < num_unset_fields; i++) {\n+                    int index = _stream.get_u2();\n+                    if (!_cp.is_within_bounds(index) || _cp.tagAt(index) != VerifierImpl.JVM_CONSTANT_NameAndType) {\n+                        _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                                \"Invalid constant pool index in early larval frame: %d\".formatted(index)));\n+                    }\n+                    var tmp = _cp.cp.entryByIndex(index, NameAndTypeEntry.class);\n+                    if (!strictFields.contains(tmp)) {\n+                        _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                                \"Strict fields not a subset of initial strict instance fields: %s\".formatted(tmp)));\n+                    } else {\n+                        new_fields.add(tmp);\n+                    }\n+                }\n+                \/\/ Only modify strict instance fields the frame has uninitialized this\n+                if (_prev_frame.flag_this_uninit()) {\n+                    _assert_unset_fields_buffer = _prev_frame.merge_unset_fields(new_fields);\n+                } else if (!new_fields.isEmpty()) {\n+                    _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                            \"Cannot have uninitialized strict fields after class initialization\"));\n+                }\n+                \/\/ Continue reading frame data\n+                if (at_end()) {\n+                    _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                            \"Early larval frame must be followed by a base frame\"));\n+                }\n+                frame_type = _stream.get_u1();\n+                if (frame_type == EARLY_LARVAL) {\n+                    _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                            \"Early larval frame must be followed by a base frame\"));\n+                }\n+            }\n@@ -300,1 +344,1 @@\n-                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), 0, _max_locals, _max_stack, locals, null, _verifier);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), 0, _max_locals, _max_stack, locals, null, _assert_unset_fields_buffer, _verifier);\n@@ -325,1 +369,1 @@\n-                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _assert_unset_fields_buffer, _verifier);\n@@ -354,1 +398,1 @@\n-                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _assert_unset_fields_buffer, _verifier);\n@@ -388,1 +432,1 @@\n-                frame = new VerificationFrame(offset, flags, new_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                frame = new VerificationFrame(offset, flags, new_length, 0, _max_locals, _max_stack, locals, null, _assert_unset_fields_buffer, _verifier);\n@@ -419,1 +463,1 @@\n-                frame = new VerificationFrame(offset, flags[0], real_length, 0, _max_locals, _max_stack, locals, null, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_length, 0, _max_locals, _max_stack, locals, null, _assert_unset_fields_buffer, _verifier);\n@@ -461,1 +505,1 @@\n-                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, _max_locals, _max_stack, locals, stack, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, _max_locals, _max_stack, locals, stack, _assert_unset_fields_buffer, _verifier);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.classfile.FieldModel;\n@@ -48,1 +49,1 @@\n-    private final ClassModel clm;\n+    final ClassModel clm;\n@@ -76,1 +77,1 @@\n-    boolean findField(String name, String sig) {\n+    FieldModel findField(String name, String sig) {\n@@ -79,2 +80,2 @@\n-                return true;\n-        return false;\n+                return f;\n+        return null;\n@@ -164,1 +165,1 @@\n-        private final ConstantPool cp;\n+        final ConstantPool cp;\n@@ -203,0 +204,4 @@\n+\n+        boolean is_within_bounds(int i) {\n+            return i >= 1 && i <= cp.size();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationWrapper.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -30,0 +31,5 @@\n+\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n@@ -32,0 +38,1 @@\n+import java.util.HashSet;\n@@ -33,0 +40,2 @@\n+import java.util.Objects;\n+import java.util.Set;\n@@ -37,0 +46,1 @@\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -245,0 +255,5 @@\n+    static boolean supports_strict_fields(VerificationWrapper klass) {\n+        int ver = klass.majorVersion();\n+        return ver >= 67 && klass.clm.minorVersion() == ClassFile.PREVIEW_MINOR_VERSION;\n+    }\n+\n@@ -306,1 +321,13 @@\n-        VerificationFrame current_frame = new VerificationFrame(max_locals, max_stack, this);\n+\n+        \/\/ Collect the initial strict instance fields\n+        Set<NameAndTypeEntry> strict_fields = new HashSet<>();\n+        if (m.name().equals(ConstantDescs.INIT_NAME)) {\n+            for (var fs : current_class().clm.fields()) {\n+                if (fs.flags().has(AccessFlag.STRICT_INIT) && !fs.flags().has(AccessFlag.STATIC)) {\n+                    var new_field = TemporaryConstantPool.INSTANCE.nameAndTypeEntry(fs.fieldName(), fs.fieldType());\n+                    strict_fields.add(new_field);\n+                }\n+            }\n+        }\n+\n+        VerificationFrame current_frame = new VerificationFrame(max_locals, max_stack, strict_fields, this);\n@@ -320,1 +347,1 @@\n-                (char) max_locals, (char) max_stack, cp, this);\n+                (char) max_locals, (char) max_stack, strict_fields, cp, this);\n@@ -1500,4 +1527,18 @@\n-                if (stack_object_type.is_uninitialized_this(this) &&\n-                        target_class_type.equals(current_type()) &&\n-                        _klass.findField(field_name, field_sig)) {\n-                    stack_object_type = current_type();\n+                FieldModel fd = _klass.findField(field_name, field_sig);\n+                boolean is_local_field = fd != null &&\n+                        target_class_type.equals(current_type());\n+                if (stack_object_type.is_uninitialized_this(this)) {\n+                    if (is_local_field) {\n+                        \/\/ Set the type to the current type so the is_assignable check passes.\n+                        stack_object_type = current_type();\n+\n+                        if (fd.flags().has(AccessFlag.STRICT_INIT)) {\n+                            current_frame.satisfy_unset_field(fd.fieldName(), fd.fieldType());\n+                        }\n+                    }\n+                } else if (supports_strict_fields(_klass)) {\n+                    \/\/ `strict` fields are not writable, but only local fields produce verification errors\n+                    if (is_local_field && fd.flags().has(AccessFlag.STRICT_INIT) && fd.flags().has(AccessFlag.FINAL)) {\n+                        verifyError(\"Bad code %d %s\".formatted(bci,\n+                                \"Illegal use of putfield on a strict field: %s:%s\".formatted(fd.fieldName(), fd.fieldType())));\n+                    }\n@@ -1531,0 +1572,5 @@\n+            } else if (ref_class_type.name().equals(superk_name)) {\n+                \/\/ Strict final fields must be satisfied by this point\n+                if (!current_frame.verify_unset_fields_satisfied()) {\n+                    current_frame.unsatisfied_strict_fields_error(current_class(), bci);\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":52,"deletions":6,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+            throw new AssertionError();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -363,0 +363,2 @@\n+        var errors = ClassFile.of().verify(classBytes);\n+        assertEquals(List.of(), errors, \"Errors detected\");\n","filename":"test\/jdk\/jdk\/classfile\/StrictStackMapsTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @run junit\/othervm --enable-preview VerifierSelfTest\n@@ -219,1 +220,0 @@\n-                                   .with(new CloneAttribute(StackMapTableAttribute.of(List.of())))\n@@ -339,1 +339,0 @@\n-                Wrong StackMapTable attribute length in Code attribute for method ParserVerificationTestClass::m()\n@@ -344,1 +343,0 @@\n-                Multiple StackMapTable attributes in Code attribute for method ParserVerificationTestClass::m()\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}