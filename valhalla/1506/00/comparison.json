{"files":[{"patch":"@@ -253,1 +253,1 @@\n-     * @since 23\n+     * @since Valhalla\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attributes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.lang.classfile.AttributeMapper;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n@@ -35,0 +38,2 @@\n+\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -41,4 +46,15 @@\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n+ * Models the {@link Attributes#loadableDescriptors() LoadableDescriptors}\n+ * attribute (JVMS {@jvms 4.7.32}), which suggests the JVM may load mentioned\n+ * types before the {@code class} file carrying this attribute is loaded.\n+ * <p>\n+ * This attribute only appears on classes, and does not permit {@linkplain\n+ * AttributeMapper#allowMultiple multiple instances} in a class.  It has a\n+ * data dependency on the {@linkplain AttributeMapper.AttributeStability#CP_REFS\n+ * constant pool}.\n+ * <p>\n+ * The attribute was introduced in the Java SE Platform version XX, major\n+ * version {@value ClassFile#JAVA_25_VERSION}. (FIXME)\n+ *\n+ * @see Attributes#loadableDescriptors()\n+ * @jvms 4.7.32 The {@code LoadableDescriptors} Attribute\n+ * @since Valhalla\n@@ -46,1 +62,1 @@\n-@PreviewFeature(feature = PreviewFeature.Feature.CLASSFILE_API)\n+@PreviewFeature(feature = PreviewFeature.Feature.VALUE_OBJECTS)\n@@ -56,0 +72,7 @@\n+    \/**\n+     * {@return the list of loadable descriptors, as nominal descriptors}\n+     *\/\n+    default List<ClassDesc> loadableDescriptorSymbols() {\n+        return Util.mappedList(loadableDescriptors(), Util::fieldTypeSymbol);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LoadableDescriptorsAttribute.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,1 @@\n-import static java.lang.constant.ConstantDescs.CLASS_INIT_NAME;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -47,6 +46,5 @@\n-\/**\n- * ParserVerifier performs selected checks of the class file format according to\n- * {@jvms 4.8 Format Checking}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/classFileParser.cpp\">hotspot\/share\/classfile\/classFileParser.cpp<\/a>\n- *\/\n+\/\/\/ ParserVerifier performs selected checks of the class file format according to\n+\/\/\/ {@jvms 4.8 Format Checking}.\n+\/\/\/\n+\/\/\/ From `classFileParser.cpp`.\n+\/\/\/\n@@ -280,2 +278,8 @@\n-            case LoadableDescriptorsAttribute lda ->\n-                2 + 2 * lda.loadableDescriptors().size();\n+            case LoadableDescriptorsAttribute lda -> {\n+                for (var desc : lda.loadableDescriptorSymbols()) {\n+                    if (desc.equals(CD_void)) {\n+                        errors.add(new VerifyError(\"illegal signature %s\".formatted(desc)));\n+                    }\n+                }\n+                yield 2 + 2 * lda.loadableDescriptors().size();\n+            }\n@@ -352,2 +356,2 @@\n-            case StackMapTableAttribute smta ->\n-                2 + subSize(smta.entries(), frame -> stackMapFrameSize(frame));\n+            case StackMapTableAttribute _ ->\n+                -1; \/\/ Not sufficient info for assert unset size\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,4 +32,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.hpp\">hotspot\/share\/interpreter\/bytecodes.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/interpreter\/bytecodes.cpp\">hotspot\/share\/interpreter\/bytecodes.cpp<\/a>\n- *\/\n+\/\/\/ From `bytecodes.cpp`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationBytecodes.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n@@ -28,0 +30,1 @@\n+import java.util.Set;\n@@ -29,4 +32,3 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.hpp\">hotspot\/share\/classfile\/stackMapFrame.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapFrame.cpp\">hotspot\/share\/classfile\/stackMapFrame.cpp<\/a>\n- *\/\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n+\n+\/\/\/ From `stackMapFrame.cpp`.\n@@ -43,0 +45,1 @@\n+    private Set<NameAndTypeEntry> _assert_unset_fields;\n@@ -45,1 +48,2 @@\n-    public VerificationFrame(int offset, int flags, int locals_size, int stack_size, int max_locals, int max_stack, VerificationType[] locals, VerificationType[] stack, VerifierImpl v) {\n+    public VerificationFrame(int offset, int flags, int locals_size, int stack_size, int max_locals, int max_stack,\n+                             VerificationType[] locals, VerificationType[] stack, Set<NameAndTypeEntry> assert_unset_fields, VerifierImpl v) {\n@@ -55,0 +59,1 @@\n+        this._assert_unset_fields = assert_unset_fields;\n@@ -115,0 +120,44 @@\n+    Set<NameAndTypeEntry> assert_unset_fields() {\n+        return _assert_unset_fields;\n+    }\n+\n+    void set_assert_unset_fields(Set<NameAndTypeEntry> table) {\n+        _assert_unset_fields = table;\n+    }\n+\n+    \/\/ Called when verifying putfields to mark strict instance fields as satisfied\n+    boolean satisfy_unset_field(Utf8Entry name, Utf8Entry signature) {\n+        var nat = TemporaryConstantPool.INSTANCE.nameAndTypeEntry(name, signature);\n+        return _assert_unset_fields.remove(nat);\n+    }\n+\n+    \/\/ Verify that all strict fields have been initialized\n+    \/\/ Strict fields must be initialized before the super constructor is called\n+    boolean verify_unset_fields_satisfied() {\n+        return _assert_unset_fields.isEmpty();\n+    }\n+\n+    \/\/ Merge incoming unset strict fields from StackMapTable with\n+    \/\/ initial strict instance fields\n+    Set<NameAndTypeEntry> merge_unset_fields(Set<NameAndTypeEntry> new_fields) {\n+        \/\/ ClassFile API: We track all strict fields in another structure, noop here\n+        return new_fields;\n+    }\n+\n+    boolean verify_unset_fields_compatibility(Set<NameAndTypeEntry> target_table) {\n+        for (var e : _assert_unset_fields) {\n+            if (!target_table.contains(e))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    void unsatisfied_strict_fields_error(VerificationWrapper klass, int bci) {\n+        _verifier.verifyError(\"All strict final fields must be initialized before super(): %d field(s), %s\"\n+                .formatted(_assert_unset_fields.size(), _assert_unset_fields));\n+    }\n+\n+    void print_strict_fields(Set<NameAndTypeEntry> table) {\n+        \/\/ ignore, we don't do stdout\/err\n+    }\n+\n@@ -187,1 +236,1 @@\n-    VerificationFrame(int max_locals, int max_stack, VerifierImpl verifier) {\n+    VerificationFrame(int max_locals, int max_stack, Set<NameAndTypeEntry> initial_strict_fields, VerifierImpl verifier) {\n@@ -204,0 +253,1 @@\n+        _assert_unset_fields = initial_strict_fields;\n@@ -209,1 +259,1 @@\n-                _verifier);\n+                _assert_unset_fields, _verifier);\n@@ -305,0 +355,10 @@\n+        \/\/ Check that assert unset fields are compatible\n+        boolean compatible = verify_unset_fields_compatibility(target.assert_unset_fields());\n+        if (!compatible) {\n+            print_strict_fields(assert_unset_fields());\n+            print_strict_fields(target.assert_unset_fields());\n+            _verifier.verifyError(\"Strict fields mismatch from %s to %s\".formatted(\n+                    assert_unset_fields(), target.assert_unset_fields()), this, target);\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationFrame.java","additions":68,"deletions":8,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+\/\/\/ Relevant parts from `signatures.cpp`, such as `SignatureStream`.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationSignature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,6 @@\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n@@ -31,4 +37,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.hpp\">hotspot\/share\/classfile\/stackMapTable.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/stackMapTable.cpp\">hotspot\/share\/classfile\/stackMapTable.cpp<\/a>\n- *\/\n+\/\/\/ From `stackMapTable.cpp`.\n@@ -39,1 +42,1 @@\n-    private final VerificationFrame[] _frame_array;\n+    private final List<VerificationFrame> _frame_array;\n@@ -47,1 +50,1 @@\n-        return _frame_array[index].offset();\n+        return _frame_array.get(index).offset();\n@@ -79,1 +82,1 @@\n-    VerificationTable(byte[] stackmap_data, VerificationFrame init_frame, int max_locals, int max_stack, byte[] code_data, int code_len,\n+    VerificationTable(StackMapReader reader,\n@@ -82,4 +85,3 @@\n-        var reader = new StackMapReader(stackmap_data, code_data, code_len, cp, v);\n-        _code_length = code_len;\n-        _frame_count = reader.get_frame_count();\n-        _frame_array = new VerificationFrame[_frame_count];\n+        _code_length = reader.code_length();\n+        int _frame_count = reader.get_frame_count();\n+        _frame_array = new ArrayList<>(_frame_count);\n@@ -87,7 +89,4 @@\n-            VerificationFrame pre_frame = init_frame;\n-            for (int i = 0; i < _frame_count; i++) {\n-                VerificationFrame frame = reader.next(pre_frame, i == 0, max_locals, max_stack);\n-                _frame_array[i] = frame;\n-                int offset = frame.offset();\n-                if (offset >= code_len || code_data[offset] == 0) {\n-                    _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            while (!reader.at_end()) {\n+                VerificationFrame frame = reader.next();\n+                if (frame != null) {\n+                    _frame_array.add(frame);\n@@ -95,1 +94,0 @@\n-                pre_frame = frame;\n@@ -99,0 +97,1 @@\n+        this._frame_count = _frame_array.size();\n@@ -104,1 +103,1 @@\n-            if (_frame_array[i].offset() == offset) {\n+            if (_frame_array.get(i).offset() == offset) {\n@@ -120,1 +119,1 @@\n-        VerificationFrame stackmap_frame = _frame_array[frame_index];\n+        VerificationFrame stackmap_frame = _frame_array.get(frame_index);\n@@ -136,0 +135,1 @@\n+            frame.set_assert_unset_fields(stackmap_frame.assert_unset_fields());\n@@ -154,0 +154,6 @@\n+        private int _parsed_frame_count;\n+        private VerificationFrame _prev_frame;\n+        char _max_locals, _max_stack;\n+        final Set<NameAndTypeEntry> strictFields;\n+        Set<NameAndTypeEntry> _assert_unset_fields_buffer;\n+        boolean _first;\n@@ -172,0 +178,27 @@\n+        public VerificationFrame prev_frame() {\n+            return _prev_frame;\n+        }\n+\n+        public byte[] code_data() {\n+            return _code_data;\n+        }\n+\n+        public int code_length() {\n+            return _code_length;\n+        }\n+\n+        public boolean at_end() {\n+            return _stream.at_end();\n+        }\n+\n+        public VerificationFrame next() {\n+            _parsed_frame_count++;\n+            check_size();\n+            VerificationFrame frame = next_helper();\n+            if (frame != null) {\n+                check_offset(frame);\n+                _prev_frame = frame;\n+            }\n+            return frame;\n+        }\n+\n@@ -173,2 +206,2 @@\n-            if (!_stream.at_end()) {\n-                _verifier.classError(\"wrong attribute size\");\n+            if (_frame_count != _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n@@ -180,1 +213,4 @@\n-        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len, VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n+        public StackMapReader(byte[] stackmapData, byte[] code_data, int code_len,\n+                              VerificationFrame init_frame, char max_locals, char max_stack,\n+                              Set<NameAndTypeEntry> initial_strict_fields,\n+                              VerificationWrapper.ConstantPoolWrapper cp, VerifierImpl context) {\n@@ -183,0 +219,9 @@\n+            _code_data = code_data;\n+            _code_length = code_len;\n+            _parsed_frame_count = 0;\n+            _prev_frame = init_frame;\n+            _max_locals = max_locals;\n+            _max_stack = max_stack;\n+            strictFields = Set.copyOf(initial_strict_fields);\n+            _assert_unset_fields_buffer = initial_strict_fields;\n+            _first = true;\n@@ -184,0 +229,1 @@\n+                _cp = cp;\n@@ -186,0 +232,1 @@\n+                _cp = null;\n@@ -188,3 +235,13 @@\n-            _code_data = code_data;\n-            _code_length = code_len;\n-            _cp = cp;\n+        }\n+\n+        void check_offset(VerificationFrame frame) {\n+            int offset = frame.offset();\n+            if (offset >= _code_length || _code_data[offset] == 0) {\n+                _verifier.verifyError(\"StackMapTable error: bad offset\");\n+            }\n+        }\n+\n+        void check_size() {\n+            if (_frame_count < _parsed_frame_count) {\n+                _verifier.verifyError(\"wrong attribute size\");\n+            }\n@@ -237,1 +294,1 @@\n-        public VerificationFrame next(VerificationFrame pre_frame, boolean first, int max_locals, int max_stack) {\n+        VerificationFrame next_helper() {\n@@ -242,0 +299,35 @@\n+            if (frame_type == EARLY_LARVAL) {\n+                int num_unset_fields = _stream.get_u2();\n+                Set<NameAndTypeEntry> new_fields = new HashSet<>();\n+                for (int i = 0; i < num_unset_fields; i++) {\n+                    int index = _stream.get_u2();\n+                    if (!_cp.is_within_bounds(index) || _cp.tagAt(index) != VerifierImpl.JVM_CONSTANT_NameAndType) {\n+                        _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                                \"Invalid constant pool index in early larval frame: %d\".formatted(index)));\n+                    }\n+                    var tmp = _cp.cp.entryByIndex(index, NameAndTypeEntry.class);\n+                    if (!strictFields.contains(tmp)) {\n+                        _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                                \"Strict fields not a subset of initial strict instance fields: %s\".formatted(tmp)));\n+                    } else {\n+                        new_fields.add(tmp);\n+                    }\n+                }\n+                \/\/ Only modify strict instance fields the frame has uninitialized this\n+                if (_prev_frame.flag_this_uninit()) {\n+                    _assert_unset_fields_buffer = _prev_frame.merge_unset_fields(new_fields);\n+                } else if (!new_fields.isEmpty()) {\n+                    _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                            \"Cannot have uninitialized strict fields after class initialization\"));\n+                }\n+                \/\/ Continue reading frame data\n+                if (at_end()) {\n+                    _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                            \"Early larval frame must be followed by a base frame\"));\n+                }\n+                frame_type = _stream.get_u1();\n+                if (frame_type == EARLY_LARVAL) {\n+                    _prev_frame.verifier().verifyError(\"Invalid use of strict instance fields %d %s %s\".formatted(_prev_frame.offset(), _prev_frame,\n+                            \"Early larval frame must be followed by a base frame\"));\n+                }\n+            }\n@@ -243,1 +335,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -245,2 +337,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -249,2 +341,2 @@\n-                    offset = pre_frame.offset() + frame_type + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type + 1;\n+                    locals = _prev_frame.locals();\n@@ -252,3 +344,3 @@\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), 0, _max_locals, _max_stack, locals, null, _assert_unset_fields_buffer, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -256,0 +348,1 @@\n+                _first = false;\n@@ -259,1 +352,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -261,2 +354,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -265,2 +358,2 @@\n-                    offset = pre_frame.offset() + frame_type - 63;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + frame_type - 63;\n+                    locals = _prev_frame.locals();\n@@ -275,4 +368,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _assert_unset_fields_buffer, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -280,0 +373,1 @@\n+                _first = false;\n@@ -287,1 +381,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -289,2 +383,2 @@\n-                    if (pre_frame.locals_size() > 0) {\n-                        locals = new VerificationType[pre_frame.locals_size()];\n+                    if (_prev_frame.locals_size() > 0) {\n+                        locals = new VerificationType[_prev_frame.locals_size()];\n@@ -293,2 +387,2 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n-                    locals = pre_frame.locals();\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n+                    locals = _prev_frame.locals();\n@@ -303,4 +397,4 @@\n-                check_verification_type_array_size(stack_size, max_stack);\n-                frame = new VerificationFrame(offset, pre_frame.flags(), pre_frame.locals_size(), stack_size, max_locals, max_stack, locals, stack, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                check_verification_type_array_size(stack_size, _max_stack);\n+                frame = new VerificationFrame(offset, _prev_frame.flags(), _prev_frame.locals_size(), stack_size, _max_locals, _max_stack, locals, stack, _assert_unset_fields_buffer, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -308,0 +402,1 @@\n+                _first = false;\n@@ -311,2 +406,2 @@\n-                locals = pre_frame.locals();\n-                int length = pre_frame.locals_size();\n+                locals = _prev_frame.locals();\n+                int length = _prev_frame.locals_size();\n@@ -315,1 +410,1 @@\n-                int flags = pre_frame.flags();\n+                int flags = _prev_frame.flags();\n@@ -318,1 +413,1 @@\n-                    check_verification_type_array_size(new_length, max_locals);\n+                    check_verification_type_array_size(new_length, _max_locals);\n@@ -327,1 +422,1 @@\n-                if (first) {\n+                if (_first) {\n@@ -335,1 +430,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -337,3 +432,3 @@\n-                frame = new VerificationFrame(offset, flags, new_length, 0, max_locals, max_stack, locals, null, _verifier);\n-                if (first && locals != null) {\n-                    frame.copy_locals(pre_frame);\n+                frame = new VerificationFrame(offset, flags, new_length, 0, _max_locals, _max_stack, locals, null, _assert_unset_fields_buffer, _verifier);\n+                if (_first && locals != null) {\n+                    frame.copy_locals(_prev_frame);\n@@ -341,0 +436,1 @@\n+                _first = false;\n@@ -344,1 +440,1 @@\n-                int real_length = pre_frame.locals_size();\n+                int real_length = _prev_frame.locals_size();\n@@ -347,1 +443,1 @@\n-                VerificationType[] pre_locals = pre_frame.locals();\n+                VerificationType[] pre_locals = _prev_frame.locals();\n@@ -349,1 +445,1 @@\n-                for (i=0; i<pre_frame.locals_size(); i++) {\n+                for (i=0; i< _prev_frame.locals_size(); i++) {\n@@ -352,1 +448,1 @@\n-                int[] flags = new int[]{pre_frame.flags()};\n+                int[] flags = new int[]{_prev_frame.flags()};\n@@ -361,2 +457,2 @@\n-                check_verification_type_array_size(real_length, max_locals);\n-                if (first) {\n+                check_verification_type_array_size(real_length, _max_locals);\n+                if (_first) {\n@@ -365,1 +461,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -367,1 +463,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_length, 0, max_locals, max_stack, locals, null, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_length, 0, _max_locals, _max_stack, locals, null, _assert_unset_fields_buffer, _verifier);\n+                _first = false;\n@@ -382,1 +479,1 @@\n-                            locals[real_locals_size].to_category2_2nd(_verifier);\n+                                locals[real_locals_size].to_category2_2nd(_verifier);\n@@ -387,1 +484,1 @@\n-                check_verification_type_array_size(real_locals_size, max_locals);\n+                check_verification_type_array_size(real_locals_size, _max_locals);\n@@ -402,2 +499,2 @@\n-                check_verification_type_array_size(real_stack_size, max_stack);\n-                if (first) {\n+                check_verification_type_array_size(real_stack_size, _max_stack);\n+                if (_first) {\n@@ -406,1 +503,1 @@\n-                    offset = pre_frame.offset() + offset_delta + 1;\n+                    offset = _prev_frame.offset() + offset_delta + 1;\n@@ -408,1 +505,2 @@\n-                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, max_locals, max_stack, locals, stack, _verifier);\n+                frame = new VerificationFrame(offset, flags[0], real_locals_size, real_stack_size, _max_locals, _max_stack, locals, stack, _assert_unset_fields_buffer, _verifier);\n+                _first = false;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationTable.java","additions":175,"deletions":77,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,1 @@\n-\/**\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.hpp\">hotspot\/share\/classfile\/verificationType.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verificationType.cpp\">hotspot\/share\/classfile\/verificationType.cpp<\/a>\n- *\/\n+\/\/\/ From `verificationType.cpp`.\n@@ -335,1 +332,1 @@\n-                        return is_reference_assignable_from(from, context);\n+                        return is_reference_assignable_from(from, context, null);\n@@ -382,1 +379,2 @@\n-    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String name, String from_name, boolean from_is_array, boolean from_is_object) {\n+    boolean resolve_and_check_assignability(ClassHierarchyImpl assignResolver, String target_name, String from_name,\n+                                            boolean from_is_array, boolean from_is_object, boolean[] target_is_interface) {\n@@ -384,3 +382,9 @@\n-        var desc = Util.toClassDesc(name);\n-        if (assignResolver.isInterface(desc)) {\n-            return !from_is_array || \"java\/lang\/Cloneable\".equals(name) || \"java\/io\/Serializable\".equals(name);\n+        var targetClass = Util.toClassDesc(target_name);\n+        boolean isInterface = assignResolver.isInterface(targetClass);\n+\n+        if (target_is_interface != null) {\n+            target_is_interface[0] = isInterface;\n+        }\n+\n+        if (isInterface) {\n+            return !from_is_array || \"java\/lang\/Cloneable\".equals(target_name) || \"java\/io\/Serializable\".equals(target_name);\n@@ -388,1 +392,1 @@\n-            return assignResolver.isAssignableFrom(desc, Util.toClassDesc(from_name));\n+            return assignResolver.isAssignableFrom(targetClass, Util.toClassDesc(from_name));\n@@ -393,1 +397,1 @@\n-    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context) {\n+    boolean is_reference_assignable_from(VerificationType from, VerifierImpl context, boolean[] target_is_interface) {\n@@ -405,1 +409,1 @@\n-            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object());\n+            return resolve_and_check_assignability(clsTree, name(), from.name(), from.is_array(), from.is_object(), target_is_interface);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationType.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.classfile.FieldModel;\n@@ -48,1 +49,1 @@\n-    private final ClassModel clm;\n+    final ClassModel clm;\n@@ -76,1 +77,1 @@\n-    boolean findField(String name, String sig) {\n+    FieldModel findField(String name, String sig) {\n@@ -79,2 +80,2 @@\n-                return true;\n-        return false;\n+                return f;\n+        return null;\n@@ -164,1 +165,1 @@\n-        private final ConstantPool cp;\n+        final ConstantPool cp;\n@@ -203,0 +204,4 @@\n+\n+        boolean is_within_bounds(int i) {\n+            return i >= 1 && i <= cp.size();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationWrapper.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.classfile.ClassFile;\n@@ -30,0 +31,5 @@\n+\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n@@ -32,0 +38,1 @@\n+import java.util.HashSet;\n@@ -33,0 +40,2 @@\n+import java.util.Objects;\n+import java.util.Set;\n@@ -37,0 +46,1 @@\n+import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -45,10 +55,6 @@\n-\/**\n- * VerifierImpl performs selected checks and verifications of the class file\n- * format according to {@jvms 4.8 Format Checking},\n- * {@jvms 4.9 Constraints on Java Virtual Machine code},\n- * {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n- *\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/java.base\/share\/native\/include\/classfile_constants.h.template\">java.base\/share\/native\/include\/classfile_constants.h.template<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.hpp\">hotspot\/share\/classfile\/verifier.hpp<\/a>\n- * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/verifier.cpp\">hotspot\/share\/classfile\/verifier.cpp<\/a>\n- *\/\n+\/\/\/ VerifierImpl performs selected checks and verifications of the class file\n+\/\/\/ format according to {@jvms 4.8 Format Checking},\n+\/\/\/ {@jvms 4.9 Constraints on Java Virtual Machine code},\n+\/\/\/ {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n+\/\/\/\n+\/\/\/ From `verifier.cpp`.\n@@ -145,5 +151,2 @@\n-        String name = klass.thisClassName();\n-        return !java_lang_Object.equals(name) &&\n-                !java_lang_Class.equals(name) &&\n-                !java_lang_String.equals(name) &&\n-                !java_lang_Throwable.equals(name);\n+        \/\/ 8330606 Not applicable here\n+        return true;\n@@ -252,0 +255,5 @@\n+    static boolean supports_strict_fields(VerificationWrapper klass) {\n+        int ver = klass.majorVersion();\n+        return ver >= 67 && klass.clm.minorVersion() == ClassFile.PREVIEW_MINOR_VERSION;\n+    }\n+\n@@ -313,1 +321,13 @@\n-        VerificationFrame current_frame = new VerificationFrame(max_locals, max_stack, this);\n+\n+        \/\/ Collect the initial strict instance fields\n+        Set<NameAndTypeEntry> strict_fields = new HashSet<>();\n+        if (m.name().equals(ConstantDescs.INIT_NAME)) {\n+            for (var fs : current_class().clm.fields()) {\n+                if (fs.flags().has(AccessFlag.STRICT_INIT) && !fs.flags().has(AccessFlag.STATIC)) {\n+                    var new_field = TemporaryConstantPool.INSTANCE.nameAndTypeEntry(fs.fieldName(), fs.fieldType());\n+                    strict_fields.add(new_field);\n+                }\n+            }\n+        }\n+\n+        VerificationFrame current_frame = new VerificationFrame(max_locals, max_stack, strict_fields, this);\n@@ -326,1 +346,3 @@\n-        VerificationTable stackmap_table = new VerificationTable(stackmap_data, current_frame, max_locals, max_stack, code_data, code_length, cp, this);\n+        var reader = new VerificationTable.StackMapReader(stackmap_data, code_data, code_length, current_frame,\n+                (char) max_locals, (char) max_stack, strict_fields, cp, this);\n+        VerificationTable stackmap_table = new VerificationTable(reader, cp, this);\n@@ -1273,0 +1295,1 @@\n+                \/\/ 8267118 Not applicable here\n@@ -1356,1 +1379,1 @@\n-        if ((types & (1 << tag))== 0) {\n+        if (tag > JVM_CONSTANT_ExternalMax || (types & (1 << tag))== 0) {\n@@ -1435,2 +1458,2 @@\n-            keys = high - low + 1;\n-            if (keys < 0) {\n+            long keys64 = ((long) high - low) + 1;\n+            if (keys64 > 65535) {  \/\/ Max code length\n@@ -1439,0 +1462,1 @@\n+            keys = (int) keys64;\n@@ -1495,0 +1519,1 @@\n+                \/\/ 8270398 Not applicable here\n@@ -1504,4 +1529,18 @@\n-                if (stack_object_type.is_uninitialized_this(this) &&\n-                        target_class_type.equals(current_type()) &&\n-                        _klass.findField(field_name, field_sig)) {\n-                    stack_object_type = current_type();\n+                FieldModel fd = _klass.findField(field_name, field_sig);\n+                boolean is_local_field = fd != null &&\n+                        target_class_type.equals(current_type());\n+                if (stack_object_type.is_uninitialized_this(this)) {\n+                    if (is_local_field) {\n+                        \/\/ Set the type to the current type so the is_assignable check passes.\n+                        stack_object_type = current_type();\n+\n+                        if (fd.flags().has(AccessFlag.STRICT_INIT)) {\n+                            current_frame.satisfy_unset_field(fd.fieldName(), fd.fieldType());\n+                        }\n+                    }\n+                } else if (supports_strict_fields(_klass)) {\n+                    \/\/ `strict` fields are not writable, but only local fields produce verification errors\n+                    if (is_local_field && fd.flags().has(AccessFlag.STRICT_INIT) && fd.flags().has(AccessFlag.FINAL)) {\n+                        verifyError(\"Bad code %d %s\".formatted(bci,\n+                                \"Illegal use of putfield on a strict field: %s:%s\".formatted(fd.fieldName(), fd.fieldType())));\n+                    }\n@@ -1535,0 +1574,5 @@\n+            } else if (ref_class_type.name().equals(superk_name)) {\n+                \/\/ Strict final fields must be satisfied by this point\n+                if (!current_frame.verify_unset_fields_satisfied()) {\n+                    current_frame.unsatisfied_strict_fields_error(current_class(), bci);\n+                }\n@@ -1646,3 +1690,16 @@\n-            boolean have_imr_indirect = cp.tagAt(index) == JVM_CONSTANT_InterfaceMethodref;\n-            boolean subtype = ref_class_type.is_assignable_from(current_type(), this);\n-            if (!subtype) {\n+\n+            \/\/ We know it is not current class, direct superinterface or immediate superclass. That means it\n+            \/\/ could be:\n+            \/\/ - a totally unrelated class or interface\n+            \/\/ - an indirect superinterface\n+            \/\/ - an indirect superclass (including Object)\n+            \/\/ We use the assignability test to see if it is a superclass, or else an interface, and keep track\n+            \/\/ of the latter. Note that subtype can be true if we are dealing with an interface that is not actually\n+            \/\/ implemented as assignability treats all interfaces as Object.\n+\n+            boolean[] is_interface = {false}; \/\/ This can only be set true if the assignability check will return true\n+                                              \/\/ and we loaded the class. For any other \"true\" returns (e.g. same class\n+                                              \/\/ or Object) we either can't get here (same class already excluded above)\n+                                              \/\/ or we know it is not an interface (i.e. Object).\n+            boolean subtype = ref_class_type.is_reference_assignable_from(current_type(), this, is_interface);\n+            if (!subtype) {  \/\/ Totally unrelated class\n@@ -1650,2 +1707,6 @@\n-            } else if (have_imr_indirect) {\n-                verifyError(\"Bad invokespecial instruction: interface method reference is in an indirect superinterface.\");\n+            } else {\n+                \/\/ Indirect superclass (including Object), indirect interface, or unrelated interface.\n+                \/\/ Any interface use is an error.\n+                if (is_interface[0]) {\n+                    verifyError(\"Bad invokespecial instruction: interface method to invoke is not in a direct superinterface.\");\n+                }\n@@ -1820,1 +1881,1 @@\n-            verifyError(\"Method expects a return value\");\n+            verifyError(\"Method does not expect a return value\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":92,"deletions":31,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+The Class-File Verifier\n+===\n+The Class-File API provides a verifier, a debug utility that reports as many\n+verification errors as possible in a class file.\n+\n+Currently, the verifier closely follows the C++ code that implements the hotspot\n+verifier. However, there are a few differences:\n+- The Class-File API verifier tries to collect as many errors as possible, while\n+  the hotspot verifier fails fast.\n+- The hotspot verifier has access to other classes and can check access control;\n+  the Class-File API verifier cannot.\n+\n+Thus, this verifier cannot serve as a complete implementation of the verifier\n+specified in the JVMS because it has no access to other class files or loaded\n+classes.  However, it is still in our interest to make this verifier up to date:\n+for example, this should not fail upon encountering new language features, and\n+should at best include all new checks hotspot has as long as the required\n+information are accessible to the Class-File API.\n+\n+Last sync: jdk-26+5, July 3rd 2025\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/verifier.md","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -151,0 +151,1 @@\n+            throw new AssertionError();\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/verifier\/StrictStaticTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -363,0 +363,2 @@\n+        var errors = ClassFile.of().verify(classBytes);\n+        assertEquals(List.of(), errors, \"Errors detected\");\n","filename":"test\/jdk\/jdk\/classfile\/StrictStackMapsTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8333812\n+ * @bug 8333812 8361526\n@@ -29,0 +29,1 @@\n+ * @run junit\/othervm --enable-preview VerifierSelfTest\n@@ -34,0 +35,2 @@\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_8_VERSION;\n@@ -36,0 +39,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -45,0 +49,1 @@\n+import java.util.Map;\n@@ -210,1 +215,0 @@\n-                                   .with(new CloneAttribute(StackMapTableAttribute.of(List.of())))\n@@ -330,1 +334,0 @@\n-                Wrong StackMapTable attribute length in Code attribute for method ParserVerificationTestClass::m()\n@@ -335,1 +338,0 @@\n-                Multiple StackMapTable attributes in Code attribute for method ParserVerificationTestClass::m()\n@@ -416,0 +418,23 @@\n+\n+    @Test \/\/ JDK-8350029\n+    void testInvokeSpecialInterfacePatch() {\n+        var runClass = ClassDesc.of(\"Run\");\n+        var testClass = ClassDesc.of(\"Test\");\n+        var runnableClass = Runnable.class.describeConstable().orElseThrow();\n+        var chr = ClassHierarchyResolver.of(List.of(), Map.of(runClass, CD_Object))\n+                .orElse(ClassHierarchyResolver.defaultResolver()).cached();\n+        var context = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(chr));\n+\n+        for (var isInterface : new boolean[] {true, false}) {\n+            var bytes = context.build(testClass, clb -> clb\n+                    .withVersion(JAVA_8_VERSION, 0)\n+                    .withSuperclass(runClass)\n+                    .withMethodBody(\"test\", MethodTypeDesc.of(CD_void, testClass), ACC_STATIC, cob -> cob\n+                            .aload(0)\n+                            .invokespecial(runnableClass, \"run\", MTD_void, isInterface)\n+                            .return_()));\n+            var errors = context.verify(bytes);\n+            assertNotEquals(List.of(), errors, \"invokespecial, isInterface = \" + isInterface);\n+            assertTrue(errors.getFirst().getMessage().contains(\"interface method to invoke is not in a direct superinterface\"), errors.getFirst().getMessage());\n+        }\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"}]}