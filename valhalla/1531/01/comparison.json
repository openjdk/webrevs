{"files":[{"patch":"@@ -507,0 +507,4 @@\n+  ciWrapper* make_early_larval_wrapper(ciType* type) {\n+    return _factory->make_early_larval_wrapper(type);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  virtual bool is_wrapper() const           { return false; }\n+  virtual bool is_early_larval() const      { return false; }\n@@ -115,4 +115,0 @@\n-  ciWrapper*               as_wrapper() {\n-    assert(is_wrapper(), \"bad cast\");\n-    return (ciWrapper*)this;\n-  }\n","filename":"src\/hotspot\/share\/ci\/ciMetadata.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -635,0 +635,6 @@\n+ciWrapper* ciObjectFactory::make_early_larval_wrapper(ciType* type) {\n+  ciWrapper* wrapper = new (arena()) ciWrapper(type, ciWrapper::EarlyLarval);\n+  init_ident_of(wrapper);\n+  return wrapper;\n+}\n+\n@@ -636,1 +642,1 @@\n-  ciWrapper* wrapper = new (arena()) ciWrapper(type);\n+  ciWrapper* wrapper = new (arena()) ciWrapper(type, ciWrapper::NullFree);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+  ciWrapper* make_early_larval_wrapper(ciType* type);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,0 +143,13 @@\n+\n+ciWrapper::ciWrapper(ciType* type, int properties)\n+    : ciType(type->basic_type()),\n+      _type(type),\n+      _properties(properties) {\n+  assert(!type->is_wrapper(), \"Thou shall not double wrap!\");\n+  assert(type->is_inlinetype()\n+             \/\/ An abstract value type is an instance_klass\n+             || (type->is_instance_klass() && type->as_instance_klass()->flags().is_abstract() && !type->as_instance_klass()->flags().is_identity())\n+             \/\/ An unloaded inline type is an instance_klass (see ciEnv::get_klass_by_name_impl())\n+             || (type->is_instance_klass() && !type->is_loaded()),\n+         \"should only be used for inline types\");\n+}\n","filename":"src\/hotspot\/share\/ci\/ciType.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  virtual bool is_wrapper() const           { return false; }\n@@ -116,1 +117,0 @@\n-\/\/ Currently it is only used to mark inline klasses as null-free.\n@@ -122,0 +122,5 @@\n+  enum Property {\n+    NullFree = 1,\n+    EarlyLarval = NullFree << 1,\n+  };\n+  int _properties;\n@@ -123,7 +128,1 @@\n-  ciWrapper(ciType* type) : ciType(type->basic_type()) {\n-    assert(type->is_inlinetype()\n-          \/\/ An unloaded inline type is an instance_klass (see ciEnv::get_klass_by_name_impl())\n-          || (type->is_instance_klass() && !type->is_loaded()),\n-          \"should only be used for inline types\");\n-    _type = type;\n-  }\n+  ciWrapper(ciType* type, int properties);\n@@ -131,1 +130,1 @@\n-  const char* type_string() { return \"ciWrapper\"; }\n+  const char* type_string() override { return \"ciWrapper\"; }\n@@ -133,1 +132,1 @@\n-  void print_impl(outputStream* st) { _type->print_impl(st); }\n+  void print_impl(outputStream* st) override { _type->print_impl(st); }\n@@ -136,3 +135,4 @@\n-  bool is_wrapper()   const { return true; }\n-  ciType* unwrap()          { return _type; }\n-  bool is_null_free() const { return true; }\n+  ciType* unwrap() override { return _type; }\n+  bool is_null_free() const override { return (_properties & (NullFree | EarlyLarval)) != 0; }\n+  bool is_early_larval() const override { return (_properties & EarlyLarval) != 0; }\n+  bool is_wrapper() const override { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciType.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -278,0 +278,2 @@\n+  assert(t1->is_early_larval() == t2->is_early_larval(), \"States should be compatible.\");\n+  bool is_early_larval = t1->is_early_larval();\n@@ -352,0 +354,3 @@\n+    if (is_early_larval) {\n+      result = analyzer->mark_as_early_larval(result);\n+    }\n@@ -415,3 +420,10 @@\n-    if (holder->is_inlinetype()) {\n-      \/\/ The receiver is null-free\n-      holder = mark_as_null_free(holder);\n+    if (method()->is_object_constructor()) {\n+      if (holder->is_inlinetype() || (holder->is_instance_klass() && holder->as_instance_klass()->flags().is_abstract() && !holder->as_instance_klass()->flags().is_identity())) {\n+        \/\/ The receiver is early larval (so also null-free)\n+        holder = mark_as_early_larval(holder);\n+      }\n+    } else {\n+      if (holder->is_inlinetype()) {\n+        \/\/ The receiver is null-free\n+        holder = mark_as_null_free(holder);\n+      }\n@@ -725,1 +737,11 @@\n-      \/\/ Check this?\n+      if (type_at_tos()->is_early_larval()) {\n+        \/\/ Call with larval receiver accepted by verifier\n+        \/\/ => this is <init> and the receiver is no longer larval after that.\n+        Cell limit = limit_cell();\n+        for (Cell c = start_cell(); c < limit; c = next_cell(c)) {\n+          if (type_at(c)->ident() == type_at_tos()->ident()) {\n+            assert(type_at(c) == type_at_tos(), \"Sin! Abomination!\");\n+            set_type_at(c, type_at_tos()->unwrap());\n+          }\n+        }\n+      }\n@@ -833,0 +855,4 @@\n+    if (klass->is_inlinetype()) {\n+      push(outer()->mark_as_early_larval(klass));\n+      return;\n+    }\n@@ -3211,0 +3237,6 @@\n+ciType* ciTypeFlow::mark_as_early_larval(ciType* type) {\n+  \/\/ Wrap the type to carry the information that it is null-free\n+  return env()->make_early_larval_wrapper(type);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -856,0 +856,1 @@\n+  ciType* mark_as_early_larval(ciType* type);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-  Node* check_interpreter_type(Node* l, const Type* type, SafePointNode* &bad_type_exit);\n+  Node* check_interpreter_type(Node* l, const Type* type, SafePointNode* &bad_type_exit, bool is_larval);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-                                    SafePointNode* &bad_type_exit) {\n+                                    SafePointNode* &bad_type_exit, bool is_early_larval) {\n@@ -187,4 +187,1 @@\n-    \/\/ In an OSR compilation, we cannot know if a value object in the incoming state is larval or\n-    \/\/ not. As a result, we must pass maybe_larval == true to not eagerly scalarize the result if\n-    \/\/ the target type is a value class.\n-    l = gen_checkcast(l, makecon(tp->as_klass_type()->cast_to_exactness(true)), &bad_type_ctrl, false, true);\n+    l = gen_checkcast(l, makecon(tp->as_klass_type()->cast_to_exactness(true)), &bad_type_ctrl, false, is_early_larval);\n@@ -381,1 +378,2 @@\n-    set_local(index, check_interpreter_type(l, type, bad_type_exit));\n+    bool is_early_larval = osr_block->flow()->local_type_at(index)->is_early_larval();\n+    set_local(index, check_interpreter_type(l, type, bad_type_exit, is_early_larval));\n@@ -389,1 +387,2 @@\n-    set_stack(index, check_interpreter_type(l, type, bad_type_exit));\n+    bool is_early_larval = osr_block->flow()->stack_type_at(index)->is_early_larval();\n+    set_stack(index, check_interpreter_type(l, type, bad_type_exit, is_early_larval));\n@@ -629,7 +628,3 @@\n-      \/\/ If the parameter is a value object, try to scalarize it if we know that it is not larval.\n-      \/\/ There are 2 cases when a parameter may be larval:\n-      \/\/ - In an OSR compilation, we do not know if a value object in the incoming state is larval\n-      \/\/   or not. We must be conservative and not eagerly scalarize them.\n-      \/\/ - In a normal compilation, all parameters are non-larval except the receiver of a\n-      \/\/   constructor, which must be a larval object.\n-      if (!is_osr_parse() && !(method()->is_object_constructor() && i == 0)) {\n+      \/\/ If the parameter is a value object, try to scalarize it if we know that it is unrestricted (not early larval)\n+      \/\/ Parameters are non-larval except the receiver of a constructor, which must be an early larval object.\n+      if (!(method()->is_object_constructor() && i == 0)) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8361352\n+ * @summary In OSR compilation, we must correctly determine the initialization\n+ * state of value objects coming from above the OSR start, and not consider\n+ * everything as potentially early larval. Value objects that are known to be\n+ * unrestricted (late larval of fully initialized) are immutable, and can be\n+ * scalarized.\n+ * @library \/test\/jdk\/java\/lang\/invoke\/common\n+ * @enablePreview\n+ * @requires vm.debug\n+ * @run main compiler.valhalla.inlinetypes.LarvalDetectionAboveOSR\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import test.java.lang.invoke.lib.InstructionHelper;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.TypeKind;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileSystems;\n+import java.util.ArrayList;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static test.java.lang.invoke.lib.InstructionHelper.classDesc;\n+\n+public class LarvalDetectionAboveOSR {\n+    public static ArrayList<String> runInSeparateVM(String scenario, String compile_pattern) throws Throwable {\n+        String separator = FileSystems.getDefault().getSeparator();\n+        String path = System.getProperty(\"java.home\") + separator + \"bin\" + separator + \"java\";\n+\n+        String javaFile = LarvalDetectionAboveOSR.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n+        String classpath = javaFile.replace(\"LarvalDetectionAboveOSR.java\", \"\");\n+        ProcessBuilder processBuilder = new ProcessBuilder(\n+                path, \"-cp\", classpath,\n+                \"--enable-preview\", \"-XX:-TieredCompilation\",\n+                \"-XX:CompileCommand=compileonly,\" + compile_pattern,\n+                \"-XX:CompileCommand=printcompilation,*::*\",\n+                \"-XX:CompileCommand=PrintIdealPhase,*::*,BEFORE_MACRO_EXPANSION\",\n+                \"-XX:+PrintEliminateAllocations\",\n+                LarvalDetectionAboveOSR.class.getCanonicalName(), scenario\n+        );\n+        Process process = processBuilder.start();\n+        processBuilder.redirectErrorStream(true);\n+\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n+        BufferedReader error_reader = new BufferedReader(new InputStreamReader(process.getErrorStream()));\n+        var lines = new ArrayList<String>();\n+        var error_lines = new ArrayList<String>();\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            lines.add(line);\n+        }\n+        while ((line = error_reader.readLine()) != null) {\n+            error_lines.add(line);\n+        }\n+        process.waitFor();\n+\n+        if (process.exitValue() != 0) {\n+            System.out.println(\"stdout:\");\n+            System.out.println(String.join(\"\\n\", lines));\n+            System.out.println(\"stderr:\");\n+            System.out.println(String.join(\"\\n\", error_lines));\n+            throw new RuntimeException(\"Process exited with status: \" + process.exitValue());\n+        }\n+\n+        return lines;\n+    }\n+\n+    static class CompilationBlock {\n+        public boolean is_osr;\n+        public ArrayList<String> lines = new ArrayList<>();\n+\n+        CompilationBlock(boolean osr) {\n+            is_osr = osr;\n+        }\n+    }\n+\n+    static Pattern print_compilation_regex = Pattern.compile(\"\\\\d+\\\\s+\\\\d+\\\\s+(%\\\\s+)?compiler\\\\.valhalla\\\\.inlinetypes\\\\.\\\\S*::[a-zA-Z0-9_]* (@ \\\\d+ )?\\\\(\\\\d+ bytes\\\\)\");\n+    static Pattern allocate_elimination_regex = Pattern.compile(\"\\\\+{4} Eliminated: \\\\d+ Allocate\");\n+    static Pattern allocate_regex = Pattern.compile(\"\\\\s*\\\\d+ {2}Allocate {2}={3}.*\");\n+\n+    static ArrayList<CompilationBlock> splitLines(ArrayList<String> lines) {\n+        var blocks = new ArrayList<CompilationBlock>();\n+        for (String line : lines) {\n+            Matcher m = print_compilation_regex.matcher(line);\n+            if (m.matches()) {\n+                blocks.add(new CompilationBlock(line.contains(\"%\")));\n+            } else if (!blocks.isEmpty()) {\n+                blocks.getLast().lines.add(line);\n+            }\n+        }\n+        return blocks;\n+    }\n+\n+    static void analyzeLines(ArrayList<String> lines) {\n+        var blocks = splitLines(lines);\n+        int blocks_actually_checked = 0;\n+        for (CompilationBlock block : blocks) {\n+            if (checkBlock(block)) {\n+                blocks_actually_checked++;\n+            }\n+        }\n+        if (blocks_actually_checked == 0) {\n+            throw new RuntimeException(\"Found no OSR logging block to check.\");\n+        }\n+    }\n+\n+    static boolean checkBlock(CompilationBlock block) {\n+        if (!block.is_osr) return false;  \/\/ It's about OSR here!\n+\n+        int eliminated_allocations = 0;\n+        int i = 0;\n+        while (i < block.lines.size()) {\n+            String line = block.lines.get(i);\n+            i++;\n+            if (line.equals(\"AFTER: BEFORE_MACRO_EXPANSION\")) {\n+                break;\n+            }\n+            if (allocate_elimination_regex.matcher(line).matches()) {\n+                eliminated_allocations++;\n+            }\n+        }\n+        if (eliminated_allocations == 0) {\n+            throw new RuntimeException(\"No allocation elimination found, there should be some.\");\n+        }\n+        if (i >= block.lines.size()) {\n+            throw new RuntimeException(\"Cannot find BEFORE_MACRO_EXPANSION printout\");\n+        }\n+        while (i < block.lines.size()) {\n+            if (allocate_regex.matcher(block.lines.get(i)).matches()) {\n+                throw new RuntimeException(\"Found allocation in line: \" + block.lines.get(i));\n+            }\n+            i++;\n+        }\n+        return true;\n+    }\n+\n+    public static short test() {\n+        ByteBuffer bf = ByteBuffer.allocate(8);\n+        return bf.getShort(0);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args.length != 0) {\n+            switch (args[0]) {\n+                case \"without_new\" -> MyNumber.main_without_new();\n+                case \"with_new\" -> MyNumber.main_with_new();\n+                case \"bytecode\" -> Bytecode.test();\n+                default -> throw new RuntimeException(\"Wrong scenario: \" + args[0]);\n+            }\n+            return;\n+        }\n+        analyzeLines(runInSeparateVM(\"without_new\", \"compiler.valhalla.inlinetypes.MyNumber::loop*\"));\n+        analyzeLines(runInSeparateVM(\"with_new\", \"compiler.valhalla.inlinetypes.MyNumber::loop*\"));\n+        analyzeLines(runInSeparateVM(\"bytecode\", \"compiler.valhalla.inlinetypes.Bytecode$Code_0::meth\"));\n+    }\n+}\n+\n+value class MyNumber {\n+    public long l;\n+    static int MANY = 1_000_000_000;\n+\n+    MyNumber(long l) {\n+        this.l = l;\n+    }\n+\n+    MyNumber add(long v) {\n+        return new MyNumber(l + v);\n+    }\n+\n+    static long loop_without_new(MyNumber dec) {\n+        for (int i = 0; i < MANY; ++i) {\n+            dec = dec.add(i);\n+        }\n+        return dec.l;\n+    }\n+\n+    public static void main_without_new() {\n+        for (int i = 0; i < 10; ++i) {\n+            MyNumber dec = new MyNumber(123);\n+            loop_without_new(dec);\n+        }\n+    }\n+\n+    static long loop_with_new() {\n+        MyNumber dec = new MyNumber(123);\n+        for (int i = 0; i < MANY; ++i) {\n+            dec = dec.add(i);\n+        }\n+        return dec.l;\n+    }\n+\n+    public static void main_with_new() {\n+        for (int i = 0; i < 10; ++i) {\n+            loop_with_new();\n+        }\n+    }\n+}\n+\n+class Bytecode {\n+    static MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    static void test() throws Throwable {\n+        var myNumber = MyNumber.class;\n+        final ClassDesc myNumberDesc = classDesc(myNumber);\n+\n+        MethodHandle meth = InstructionHelper.buildMethodHandle(\n+                LOOKUP,\n+                \"meth\",\n+                MethodType.methodType(myNumber, int.class),\n+                CODE -> {\n+                    Label loop = CODE.newLabel();\n+                    CODE\n+                            .new_(myNumberDesc)\n+                            .dup()\n+                            \/\/ stack: early larval (this one we init), early larval (this one we store in local 10)\n+                            .astore(10)\n+                            .iconst_0()\n+                            .i2l()\n+                            .invokespecial(myNumberDesc, \"<init>\", MethodTypeDesc.ofDescriptor(\"(J)V\"))\n+                            \/\/ local 10 should also be initialized, it is now not early larval, so scalarization is allowed\n+\n+                            \/\/ local(11) = 0\n+                            .iconst_0()\n+                            .istore(11)\n+\n+                            .labelBinding(loop)\n+                            \/\/ local(10) = local(10).add((long)local(11))\n+                            .aload(10)\n+                            .iload(11)\n+                            .i2l()\n+                            .invokevirtual(myNumberDesc, \"add\", MethodTypeDesc.ofDescriptor(\"(J)Lcompiler\/valhalla\/inlinetypes\/MyNumber;\"))\n+                            .astore(10)\n+\n+                            \/\/ local(11)++\n+                            .iload(11)\n+                            .iconst_1()\n+                            .iadd()\n+                            .dup()\n+                            \/\/ if local(11) < param(0) goto loop\n+                            .istore(11)\n+                            .iload(0)\n+                            .if_icmplt(loop)\n+\n+                            .aload(10)\n+                            .return_(TypeKind.from(myNumberDesc));\n+                });\n+        var _ = (MyNumber)meth.invokeExact(MyNumber.MANY);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/LarvalDetectionAboveOSR.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.valhalla.loops.osr;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"--enable-preview\"})\n+@Warmup(iterations = 0)\n+@Measurement(iterations = 10)\n+public class LarvalDetectionAboveOSR {\n+    @Benchmark\n+    public long test() {\n+        return MyNumber.loop();\n+    }\n+}\n+\n+value class MyNumber {\n+    static int MANY = 1_000_000_000;\n+    private long d0;\n+\n+    MyNumber(long d0) {\n+        this.d0 = d0;\n+    }\n+\n+    MyNumber add(long v) {\n+        return new MyNumber(d0 + v);\n+    }\n+\n+    public static long loop() {\n+        MyNumber dec = new MyNumber(123);\n+        for (int i = 0; i < MANY; ++i) {\n+            dec = dec.add(i);\n+        }\n+        return dec.d0;\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/valhalla\/loops\/osr\/LarvalDetectionAboveOSR.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}