{"files":[{"patch":"@@ -2336,0 +2336,2 @@\n+    \/\/ TODO 8350865 Flat no longer implies null-free, so we need to check for flat dest. Can we do better here?\n+    __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n@@ -2421,1 +2423,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-\/\/ TODO 8341767 (same applies to g1StoreLSpecialTwoOops)\n+\/\/ TODO 8350865 (same applies to g1StoreLSpecialTwoOops)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/g1\/g1_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1956,0 +1956,1 @@\n+    \/\/ TODO 8350865 This is also used for profiling code, right? And in that case we don't care about null but just want to know if the array is flat or not.\n@@ -3191,0 +3192,2 @@\n+    \/\/ TODO 8350865 Flat no longer implies null-free, so we need to check for flat dest. Can we do better here?\n+    __ test_flat_array_oop(obj, tmp, *slow_path->entry());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-\/\/ TODO 8341767 (same applies to g1StoreLSpecialTwoOops)\n+\/\/ TODO 8350865 (same applies to g1StoreLSpecialTwoOops)\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1_x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1088,0 +1088,1 @@\n+    \/\/ TODO 8350865 This is currently dead code\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1677,1 +1677,1 @@\n-    BasicType bt = vk->payload_size_to_basic_type();\n+    BasicType bt = vk->atomic_size_to_basic_type(field->is_null_free());\n@@ -1939,1 +1939,1 @@\n-    if (x->array()->is_loaded_flat_array()) {\n+    if (is_loaded_flat_array) {\n@@ -1964,0 +1964,1 @@\n+    \/\/ TODO 8350865 This is currently dead code\n@@ -2148,1 +2149,1 @@\n-    BasicType bt = vk->payload_size_to_basic_type();\n+    BasicType bt = vk->atomic_size_to_basic_type(field->is_null_free());\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -436,0 +436,1 @@\n+  \/\/ TODO 8350865 This is dead code since 8325660 because null-free arrays can only be created via the factory methods that are not yet implemented in C1. Should probably be fixed by 8265122.\n@@ -448,1 +449,0 @@\n-  \/\/  Limitation here, only non-atomic layouts are supported\n@@ -477,1 +477,1 @@\n-static void profile_flat_array(JavaThread* current, bool load) {\n+static void profile_flat_array(JavaThread* current, bool load, bool null_free) {\n@@ -498,0 +498,3 @@\n+      if (null_free) {\n+        load_data->set_null_free_array();\n+      }\n@@ -503,0 +506,3 @@\n+      if (null_free) {\n+        store_data->set_null_free_array();\n+      }\n@@ -509,1 +515,1 @@\n-  profile_flat_array(current, true);\n+  profile_flat_array(current, true, array->is_null_free_array());\n@@ -518,1 +524,0 @@\n-\n@@ -520,0 +525,1 @@\n+  \/\/ TOOD 8350865 We can call here with a non-flat array because of LIR_Assembler::emit_opFlattenedArrayCheck\n@@ -521,1 +527,1 @@\n-    profile_flat_array(current, false);\n+    profile_flat_array(current, false, array->is_null_free_array());\n@@ -525,2 +531,1 @@\n-  if (value == nullptr) {\n-    assert(array->klass()->is_flatArray_klass() || array->klass()->is_null_free_array_klass(), \"should not be called\");\n+  if (value == nullptr && array->is_null_free_array()) {\n@@ -534,1 +539,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -122,0 +122,5 @@\n+bool ciArray::is_null_free() {\n+  VM_ENTRY_MARK;\n+  return get_oop()->is_null_free_array();\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciArray.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  virtual bool is_null_free() { return false; }\n+  virtual bool is_null_free();\n","filename":"src\/hotspot\/share\/ci\/ciArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool null_free) {\n+ciArrayKlass* ciArrayKlass::make(ciType* element_type, bool flat, bool null_free, bool atomic) {\n@@ -112,1 +112,1 @@\n-  if (null_free && klass->is_loaded() && klass->is_inlinetype()) {\n+  if (klass->is_loaded() && klass->is_inlinetype()) {\n@@ -117,4 +117,22 @@\n-      if (vk->flat_array()) {\n-        \/\/ Current limitation: returns only non-atomic flat arrays, atomic layout not supported here\n-        ak = vk->flat_array_klass(LayoutKind::NON_ATOMIC_FLAT, THREAD);\n-      } else {\n+      if (flat && vk->flat_array()) {\n+        LayoutKind lk;\n+        if (null_free) {\n+          if (vk->is_naturally_atomic()) {\n+            atomic = vk->has_atomic_layout();\n+          }\n+          if (!atomic && !vk->has_non_atomic_layout()) {\n+            \/\/ TODO 8350865 Impossible type\n+            lk = vk->has_atomic_layout() ? LayoutKind::ATOMIC_FLAT : LayoutKind::NULLABLE_ATOMIC_FLAT;\n+          } else {\n+            lk = atomic ? LayoutKind::ATOMIC_FLAT : LayoutKind::NON_ATOMIC_FLAT;\n+          }\n+        } else {\n+          if (!vk->has_nullable_atomic_layout()) {\n+            \/\/ TODO 8350865 Impossible type, null-able flat is always atomic.\n+            lk = vk->has_atomic_layout() ? LayoutKind::ATOMIC_FLAT : LayoutKind::NON_ATOMIC_FLAT;\n+          } else {\n+            lk = LayoutKind::NULLABLE_ATOMIC_FLAT;\n+          }\n+        }\n+        ak = vk->flat_array_klass(lk, THREAD);\n+      } else if (null_free) {\n@@ -122,0 +140,2 @@\n+      } else {\n+        return ciObjArrayKlass::make(klass);\n@@ -146,0 +166,3 @@\n+bool ciArrayKlass::is_elem_null_free() const {\n+  GUARDED_VM_ENTRY(return !is_type_array_klass() && get_Klass()->is_null_free_array_klass();)\n+}\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  static ciArrayKlass* make(ciType* klass, bool null_free = false);\n+  static ciArrayKlass* make(ciType* klass, bool flat = false, bool null_free = false, bool atomic = false);\n@@ -66,1 +66,1 @@\n-  virtual bool is_elem_null_free() const { return false; }\n+  bool is_elem_null_free() const;\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-  bool is_null_free() { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciFlatArray.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,2 +74,0 @@\n-\n-  virtual bool is_elem_null_free() const { return true; }\n","filename":"src\/hotspot\/share\/ci\/ciFlatArrayKlass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,2 +144,18 @@\n-\/\/ Convert payload size in bytes to corresponding BasicType\n-BasicType ciInlineKlass::payload_size_to_basic_type() const {\n+bool ciInlineKlass::has_non_atomic_layout() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->has_non_atomic_layout();)\n+}\n+\n+bool ciInlineKlass::has_atomic_layout() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->has_atomic_layout();)\n+}\n+\n+bool ciInlineKlass::has_nullable_atomic_layout() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->has_nullable_atomic_layout();)\n+}\n+\n+int ciInlineKlass::null_marker_offset_in_payload() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->null_marker_offset_in_payload();)\n+}\n+\n+\/\/ Convert size of atomic layout in bytes to corresponding BasicType\n+BasicType ciInlineKlass::atomic_size_to_basic_type(bool null_free) const {\n@@ -147,1 +163,4 @@\n-  int size = get_InlineKlass()->payload_size_in_bytes();\n+  InlineKlass* vk = get_InlineKlass();\n+  assert(!null_free || vk->has_atomic_layout(), \"No null-free atomic layout available\");\n+  assert( null_free || vk->has_nullable_atomic_layout(), \"No nullable atomic layout available\");\n+  int size = null_free ? vk->atomic_size_in_bytes() : vk->nullable_atomic_size_in_bytes();\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -92,1 +92,5 @@\n-  BasicType payload_size_to_basic_type() const;\n+  bool has_non_atomic_layout() const;\n+  bool has_atomic_layout() const;\n+  bool has_nullable_atomic_layout() const;\n+  int null_marker_offset_in_payload() const;\n+  BasicType atomic_size_to_basic_type(bool null_free) const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,5 +47,0 @@\n-\n-bool ciObjArray::is_null_free() {\n-  VM_ENTRY_MARK;\n-  return get_objArrayOop()->is_null_free_array();\n-}\n","filename":"src\/hotspot\/share\/ci\/ciObjArray.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  bool is_null_free();\n","filename":"src\/hotspot\/share\/ci\/ciObjArray.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -196,4 +196,0 @@\n-\n-bool ciObjArrayKlass::is_elem_null_free() const {\n-  GUARDED_VM_ENTRY(return get_Klass()->is_null_free_array_klass();)\n-}\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-\n-  virtual bool is_elem_null_free() const;\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -515,1 +515,1 @@\n-      \/\/ array\n+      \/\/ TODO 8350865 I think we need to handle null-free\/flat arrays here\n@@ -1134,0 +1134,1 @@\n+            \/\/ TODO 8350865 I think we need to handle null-free\/flat arrays here\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -265,0 +265,2 @@\n+  case vmIntrinsics::_newNullRestrictedAtomicArray:\n+  case vmIntrinsics::_newNullableAtomicArray:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -325,2 +325,1 @@\n-  do_intrinsic(_newNullRestrictedArray,   jdk_internal_value_ValueClass, newNullRestrictedArray_name, newNullRestrictedArray_signature, F_SN) \\\n-   do_signature(newNullRestrictedArray_signature,                 \"(Ljava\/lang\/Class;I)[Ljava\/lang\/Object;\")            \\\n+  do_intrinsic(_newNullRestrictedArray, jdk_internal_value_ValueClass, newNullRestrictedArray_name, newArray_signature2, F_SN) \\\n@@ -328,0 +327,5 @@\n+  do_intrinsic(_newNullRestrictedAtomicArray, jdk_internal_value_ValueClass, newNullRestrictedAtomicArray_name, newArray_signature2, F_SN) \\\n+   do_name(     newNullRestrictedAtomicArray_name,                \"newNullRestrictedAtomicArray\")                       \\\n+  do_intrinsic(_newNullableAtomicArray, jdk_internal_value_ValueClass, _newNullableAtomicArray_name, newArray_signature2, F_SN) \\\n+   do_name(    _newNullableAtomicArray_name,                      \"newNullableAtomicArray\")                             \\\n+   do_signature(newArray_signature2,                              \"(Ljava\/lang\/Class;I)[Ljava\/lang\/Object;\")            \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  \/\/ TODO 8341767\n+  \/\/ TODO 8350865\n@@ -63,1 +63,0 @@\n-        assert(!is_array, \"array access not supported\");\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/modRefBarrierSetC2.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-      _consumer->accept_uint(fi.layout_kind());\n+      _consumer->accept_uint((uint32_t)fi.layout_kind());\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  assert(lk == NON_ATOMIC_FLAT || lk == ATOMIC_FLAT || lk == NULLABLE_ATOMIC_FLAT, \"Must be a flat layout\");\n+  assert(lk == LayoutKind::NON_ATOMIC_FLAT || lk == LayoutKind::ATOMIC_FLAT || lk == LayoutKind::NULLABLE_ATOMIC_FLAT, \"Must be a flat layout\");\n@@ -75,2 +75,2 @@\n-    case NON_ATOMIC_FLAT:\n-    case ATOMIC_FLAT:\n+    case LayoutKind::NON_ATOMIC_FLAT:\n+    case LayoutKind::ATOMIC_FLAT:\n@@ -80,1 +80,1 @@\n-    case NULLABLE_ATOMIC_FLAT:\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n@@ -161,1 +161,1 @@\n-  bool null_free = lk != NULLABLE_ATOMIC_FLAT;\n+  bool null_free = lk != LayoutKind::NULLABLE_ATOMIC_FLAT;\n@@ -293,1 +293,1 @@\n-        bool need_null_check = fsk->layout_kind() == NULLABLE_ATOMIC_FLAT && fdk->layout_kind() != NULLABLE_ATOMIC_FLAT;\n+        bool need_null_check = fsk->layout_kind() == LayoutKind::NULLABLE_ATOMIC_FLAT && fdk->layout_kind() != LayoutKind::NULLABLE_ATOMIC_FLAT;\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+  static ByteSize layout_kind_offset() { return in_ByteSize(offset_of(FlatArrayKlass, _layout_kind)); }\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    case BUFFERED:\n+    case LayoutKind::BUFFERED:\n@@ -200,1 +200,1 @@\n-    case NULLABLE_ATOMIC_FLAT: {\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT: {\n@@ -223,3 +223,3 @@\n-    case BUFFERED:\n-    case ATOMIC_FLAT:\n-    case NON_ATOMIC_FLAT: {\n+    case LayoutKind::BUFFERED:\n+    case LayoutKind::ATOMIC_FLAT:\n+    case LayoutKind::NON_ATOMIC_FLAT: {\n@@ -243,1 +243,1 @@\n-    case NULLABLE_ATOMIC_FLAT: {\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT: {\n@@ -248,3 +248,3 @@\n-    case BUFFERED:\n-    case ATOMIC_FLAT:\n-    case NON_ATOMIC_FLAT: {\n+    case LayoutKind::BUFFERED:\n+    case LayoutKind::ATOMIC_FLAT:\n+    case LayoutKind::NON_ATOMIC_FLAT: {\n@@ -257,1 +257,1 @@\n-      if (lk == NULLABLE_ATOMIC_FLAT) {\n+      if (lk == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n@@ -273,1 +273,1 @@\n-    if (lk != NULLABLE_ATOMIC_FLAT) {\n+    if (lk != LayoutKind::NULLABLE_ATOMIC_FLAT) {\n@@ -290,1 +290,1 @@\n-    if (lk == NULLABLE_ATOMIC_FLAT) {\n+    if (lk == LayoutKind::NULLABLE_ATOMIC_FLAT) {\n@@ -315,0 +315,4 @@\n+  \/\/ No flat layout?\n+  if (!has_nullable_atomic_layout() && !has_atomic_layout() && !has_non_atomic_layout()) {\n+    return false;\n+  }\n@@ -339,1 +343,1 @@\n-    case NON_ATOMIC_FLAT:\n+    case LayoutKind::NON_ATOMIC_FLAT:\n@@ -343,1 +347,1 @@\n-    case ATOMIC_FLAT:\n+    case LayoutKind::ATOMIC_FLAT:\n@@ -347,1 +351,1 @@\n-    case NULLABLE_ATOMIC_FLAT:\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n@@ -370,1 +374,1 @@\n-    case NON_ATOMIC_FLAT:\n+    case LayoutKind::NON_ATOMIC_FLAT:\n@@ -374,1 +378,1 @@\n-    case ATOMIC_FLAT:\n+    case LayoutKind::ATOMIC_FLAT:\n@@ -378,1 +382,1 @@\n-    case NULLABLE_ATOMIC_FLAT:\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-enum LayoutKind {\n+enum class LayoutKind : uint32_t {\n","filename":"src\/hotspot\/share\/oops\/layoutKind.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-    case ATOMIC_FLAT:\n-    case NON_ATOMIC_FLAT:\n+    case LayoutKind::ATOMIC_FLAT:\n+    case LayoutKind::NON_ATOMIC_FLAT:\n@@ -109,1 +109,1 @@\n-    case NULLABLE_ATOMIC_FLAT:\n+    case LayoutKind::NULLABLE_ATOMIC_FLAT:\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -295,1 +295,2 @@\n-    if (src_elem != dest_elem || ary_src->is_flat() != ary_dest->is_flat() || dest_elem == T_VOID) {\n+    \/\/ TODO 8350865 What about atomicity?\n+    if (src_elem != dest_elem || ary_src->is_null_free() != ary_dest->is_null_free() || ary_src->is_flat() != ary_dest->is_flat() || dest_elem == T_VOID) {\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -759,0 +759,2 @@\n+  case vmIntrinsics::_newNullRestrictedAtomicArray:\n+  case vmIntrinsics::_newNullableAtomicArray:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1545,1 +1545,1 @@\n-        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_null_free());\n+        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, Type::Offset(offset), tk->is_not_flat(), tk->is_not_null_free(), tk->is_flat(), tk->is_null_free());\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/flatArrayKlass.hpp\"\n@@ -1834,1 +1835,0 @@\n-  assert(!arytype->is_flat() || elembt == T_OBJECT, \"element type of flat arrays are T_OBJECT\");\n@@ -1862,0 +1862,10 @@\n+Node* GraphKit::flat_array_element_address(Node*& array, Node* idx, ciInlineKlass* vk, bool is_null_free,\n+                                           bool is_not_null_free, bool is_atomic) {\n+  ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* flat *\/ true, is_null_free, is_atomic);\n+  const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n+  arytype = arytype->cast_to_exactness(true);\n+  arytype = arytype->cast_to_not_null_free(is_not_null_free);\n+  array = _gvn.transform(new CheckCastPPNode(control(), array, arytype));\n+  return array_element_address(array, idx, T_FLAT_ELEMENT, arytype->size(), control());\n+}\n+\n@@ -3689,1 +3699,1 @@\n-  if (EnableValhalla && not_flat_in_array) {\n+  if (EnableValhalla && (not_inline || not_flat_in_array)) {\n@@ -3710,2 +3720,2 @@\n-      if (ary_t != nullptr && !ary_t->is_flat()) {\n-        if (!ary_t->is_not_null_free() && not_inline) {\n+      if (ary_t != nullptr) {\n+        if (!ary_t->is_not_null_free() && !ary_t->is_null_free() && not_inline) {\n@@ -3715,2 +3725,4 @@\n-        } else if (!ary_t->is_not_flat()) {\n-          \/\/ Casting array element to a non-flat type, mark array as not flat.\n+          array = cast;\n+        }\n+        if (!ary_t->is_not_flat() && !ary_t->is_flat() && not_flat_in_array) {\n+          \/\/ Casting array element to a non-flat-in-array type, mark array as not flat.\n@@ -3719,0 +3731,1 @@\n+          array = cast;\n@@ -3799,0 +3812,18 @@\n+Node* GraphKit::null_free_atomic_array_test(Node* array, ciInlineKlass* vk) {\n+  assert(vk->has_atomic_layout() || vk->has_non_atomic_layout(), \"Can't be null-free and flat\");\n+\n+  \/\/ TODO 8350865 Add a stress flag to always access atomic if layout exists?\n+  if (!vk->has_non_atomic_layout()) {\n+    return intcon(1); \/\/ Always atomic\n+  } else if (!vk->has_atomic_layout()) {\n+    return intcon(0); \/\/ Never atomic\n+  }\n+\n+  Node* array_klass = load_object_klass(array);\n+  int layout_kind_offset = in_bytes(FlatArrayKlass::layout_kind_offset());\n+  Node* layout_kind_addr = basic_plus_adr(array_klass, array_klass, layout_kind_offset);\n+  Node* layout_kind = make_load(nullptr, layout_kind_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* cmp = _gvn.transform(new CmpINode(layout_kind, intcon((int)LayoutKind::ATOMIC_FLAT)));\n+  return _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n+}\n+\n@@ -4412,5 +4443,1 @@\n-  \/\/ Inline type array variants:\n-  \/\/ - null-ok:         ciObjArrayKlass  with is_elem_null_free() = false\n-  \/\/ - null-free:       ciObjArrayKlass  with is_elem_null_free() = true\n-  \/\/ - null-free, flat: ciFlatArrayKlass with is_elem_null_free() = true\n-  \/\/ Check if array is a null-free, non-flat inline type array\n+  \/\/ Check if the array is a null-free, non-flat inline type array\n@@ -4420,14 +4447,12 @@\n-  if (ary_ptr != nullptr && ary_ptr->klass_is_exact()) {\n-    \/\/ Array type is known\n-    if (ary_ptr->is_null_free() && !ary_ptr->is_flat()) {\n-      ciInlineKlass* vk = ary_ptr->elem()->inline_klass();\n-      default_value = InlineTypeNode::default_oop(gvn(), vk);\n-      if (UseCompressedOops) {\n-        \/\/ With compressed oops, the 64-bit init value is built from two 32-bit compressed oops\n-        default_value = _gvn.transform(new EncodePNode(default_value, default_value->bottom_type()->make_narrowoop()));\n-        Node* lower = _gvn.transform(new CastP2XNode(control(), default_value));\n-        Node* upper = _gvn.transform(new LShiftLNode(lower, intcon(32)));\n-        raw_default_value = _gvn.transform(new OrLNode(lower, upper));\n-      } else {\n-        raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));\n-      }\n+  if (ary_ptr != nullptr && ary_ptr->klass_is_exact() &&\n+      ary_ptr->is_null_free() && !ary_ptr->is_flat() && ary_ptr->elem()->make_ptr()->is_inlinetypeptr()) {\n+    ciInlineKlass* vk = ary_ptr->elem()->inline_klass();\n+    default_value = InlineTypeNode::default_oop(gvn(), vk);\n+    if (UseCompressedOops) {\n+      \/\/ With compressed oops, the 64-bit init value is built from two 32-bit compressed oops\n+      default_value = _gvn.transform(new EncodePNode(default_value, default_value->bottom_type()->make_narrowoop()));\n+      Node* lower = _gvn.transform(new CastP2XNode(control(), default_value));\n+      Node* upper = _gvn.transform(new LShiftLNode(lower, intcon(32)));\n+      raw_default_value = _gvn.transform(new OrLNode(lower, upper));\n+    } else {\n+      raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -646,0 +646,2 @@\n+  Node* flat_array_element_address(Node*& array, Node* idx, ciInlineKlass* vk, bool is_null_free,\n+                                   bool is_not_null_free, bool is_atomic);\n@@ -831,0 +833,1 @@\n+  Node* null_free_atomic_array_test(Node* array, ciInlineKlass* vk);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/idealKit.hpp\"\n@@ -525,1 +526,1 @@\n-      value = make_from_flat_impl(kit, ft->as_inline_klass(), base, ptr, holder, offset, false, nm_offset, decorators, visited);\n+      value = make_from_flat_impl(kit, ft->as_inline_klass(), base, ptr, nullptr, holder, offset, false, nm_offset, decorators, visited);\n@@ -530,1 +531,1 @@\n-      if (base->is_Con() && !is_array && !mismatched) {\n+      if (base->is_Con() && oop_ptr->is_inlinetypeptr() && !is_array && !mismatched) {\n@@ -615,1 +616,1 @@\n-        \/\/ TODO 8341767 Should we add the membar to the CastI2N and give it a type?\n+        \/\/ TODO 8350865 Should we add the membar to the CastI2N and give it a type?\n@@ -701,1 +702,1 @@\n-void InlineTypeNode::store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, bool atomic, int null_marker_offset, DecoratorSet decorators) const {\n+void InlineTypeNode::store_flat(GraphKit* kit, Node* base, Node* ptr, Node* idx, ciInstanceKlass* holder, int holder_offset, bool atomic, int null_marker_offset, DecoratorSet decorators) const {\n@@ -705,0 +706,1 @@\n+  ciInlineKlass* vk = inline_klass();\n@@ -709,1 +711,1 @@\n-    bool is_naturally_atomic = inline_klass()->is_empty() || (null_free && inline_klass()->nof_declared_nonstatic_fields() == 1);\n+    bool is_naturally_atomic = vk->is_empty() || (null_free && vk->nof_declared_nonstatic_fields() == 1);\n@@ -715,3 +717,3 @@\n-    \/\/ 64-bit because the next smaller size would be 32-bit which could only hold one narrow oop that would then be\n-    \/\/ written by a normal narrow oop store. These properties are asserted in 'convert_to_payload'.\n-    BasicType bt = inline_klass()->payload_size_to_basic_type();\n+    \/\/ 64-bit because the next smaller (power-of-two) size would be 32-bit which could only hold one narrow oop that\n+    \/\/ would then be written by a normal narrow oop store. These properties are asserted in 'convert_to_payload'.\n+    BasicType bt = vk->atomic_size_to_basic_type(null_free);\n@@ -722,1 +724,1 @@\n-    Node* adr = kit->basic_plus_adr(base, ptr, holder_offset);\n+\n@@ -729,1 +731,0 @@\n-      bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n@@ -731,1 +732,104 @@\n-      kit->access_store_at(base, adr, TypeRawPtr::BOTTOM, payload, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, true, this);\n+\n+      bool is_array = (kit->gvn().type(base)->isa_aryptr() != nullptr);\n+\n+      if (!is_array) {\n+        Node* adr = kit->basic_plus_adr(base, ptr, holder_offset);\n+        kit->access_store_at(base, adr, TypeRawPtr::BOTTOM, payload, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, true, this);\n+      } else {\n+        assert(holder_offset == 0, \"sanity\");\n+\n+        RegionNode* region = new RegionNode(3);\n+        kit->gvn().set_type(region, Type::CONTROL);\n+        kit->record_for_igvn(region);\n+\n+        Node* bol = kit->null_free_array_test(base); \/\/ Argument evaluation order is undefined in C++ and since this sets control, it needs to come first\n+        IfNode* iff = kit->create_and_map_if(kit->control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+\n+        Node* input_memory_state = kit->reset_memory();\n+        kit->set_all_memory(input_memory_state);\n+\n+        Node* mem = PhiNode::make(region, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n+        kit->gvn().set_type(mem, Type::MEMORY);\n+        kit->record_for_igvn(mem);\n+\n+        PhiNode* io = PhiNode::make(region, kit->i_o(), Type::ABIO);\n+        kit->gvn().set_type(io, Type::ABIO);\n+        kit->record_for_igvn(io);\n+\n+        kit->set_control(kit->IfFalse(iff));\n+        region->init_req(1, kit->control());\n+\n+        \/\/ Nullable\n+        if (!kit->stopped()) {\n+          assert(!null_free && vk->has_nullable_atomic_layout(), \"Flat array can't be nullable\");\n+          kit->access_store_at(base, ptr, TypeRawPtr::BOTTOM, payload, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, true, this);\n+          mem->init_req(1, kit->reset_memory());\n+          io->init_req(1, kit->i_o());\n+        }\n+\n+        kit->set_control(kit->IfTrue(iff));\n+\n+        \/\/ Null-free\n+        if (!kit->stopped()) {\n+          kit->set_all_memory(input_memory_state);\n+\n+          \/\/ Check if it's atomic\n+          RegionNode* region_null_free = new RegionNode(3);\n+          kit->gvn().set_type(region_null_free, Type::CONTROL);\n+          kit->record_for_igvn(region_null_free);\n+\n+          Node* mem_null_free = PhiNode::make(region_null_free, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n+          kit->gvn().set_type(mem_null_free, Type::MEMORY);\n+          kit->record_for_igvn(mem_null_free);\n+\n+          PhiNode* io_null_free = PhiNode::make(region_null_free, kit->i_o(), Type::ABIO);\n+          kit->gvn().set_type(io_null_free, Type::ABIO);\n+          kit->record_for_igvn(io_null_free);\n+\n+          Node* bol = kit->null_free_atomic_array_test(base, vk);\n+          IfNode* iff = kit->create_and_map_if(kit->control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+\n+          kit->set_control(kit->IfTrue(iff));\n+          region_null_free->init_req(1, kit->control());\n+\n+          \/\/ Atomic\n+          if (!kit->stopped()) {\n+            BasicType bt_null_free = vk->atomic_size_to_basic_type(\/* null_free *\/ true);\n+            const Type* val_type_null_free = Type::get_const_basic_type(bt_null_free);\n+            kit->set_all_memory(input_memory_state);\n+\n+            if (bt == T_LONG && bt_null_free != T_LONG) {\n+              payload = kit->gvn().transform(new ConvL2INode(payload));\n+            }\n+\n+            Node* cast = base;\n+            Node* adr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n+            kit->access_store_at(cast, adr, TypeRawPtr::BOTTOM, payload, val_type_null_free, bt_null_free, is_array ? (decorators | IS_ARRAY) : decorators, true, this);\n+            mem_null_free->init_req(1, kit->reset_memory());\n+            io_null_free->init_req(1, kit->i_o());\n+          }\n+\n+          kit->set_control(kit->IfFalse(iff));\n+          region_null_free->init_req(2, kit->control());\n+\n+          \/\/ Non-Atomic\n+          if (!kit->stopped()) {\n+            kit->set_all_memory(input_memory_state);\n+\n+            Node* cast = base;\n+            Node* adr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n+            store(kit, cast, adr, holder, holder_offset - vk->payload_offset(), -1, decorators);\n+\n+            mem_null_free->init_req(2, kit->reset_memory());\n+            io_null_free->init_req(2, kit->i_o());\n+          }\n+\n+          mem->init_req(2, kit->gvn().transform(mem_null_free));\n+          io->init_req(2, kit->gvn().transform(io_null_free));\n+          region->init_req(2, kit->gvn().transform(region_null_free));\n+        }\n+\n+        kit->set_control(kit->gvn().transform(region));\n+        kit->set_all_memory(kit->gvn().transform(mem));\n+        kit->set_i_o(kit->gvn().transform(io));\n+      }\n@@ -740,0 +844,1 @@\n+      Node* adr = kit->basic_plus_adr(base, ptr, holder_offset);\n@@ -747,6 +852,1 @@\n-\n-  if (!null_free) {\n-    \/\/ Nullable, store the null marker\n-    Node* adr = kit->basic_plus_adr(base, ptr, null_marker_offset);\n-    kit->store_to_memory(kit->control(), adr, get_is_init(), T_BOOLEAN, MemNode::unordered);\n-  }\n+  assert(null_free, \"Nullable flat implies atomic\");\n@@ -757,1 +857,1 @@\n-    holder = inline_klass();\n+    holder = vk;\n@@ -759,1 +859,1 @@\n-  holder_offset -= inline_klass()->payload_offset();\n+  holder_offset -= vk->payload_offset();\n@@ -775,1 +875,1 @@\n-      value->as_InlineType()->store_flat(kit, base, ptr, holder, offset, false, nm_offset, decorators);\n+      value->as_InlineType()->store_flat(kit, base, ptr, nullptr, holder, offset, false, nm_offset, decorators);\n@@ -1208,1 +1308,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset,\n+InlineTypeNode* InlineTypeNode::make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, Node* idx, ciInstanceKlass* holder, int holder_offset,\n@@ -1212,1 +1312,1 @@\n-  return make_from_flat_impl(kit, vk, obj, ptr, holder, holder_offset, atomic, null_marker_offset, decorators, visited);\n+  return make_from_flat_impl(kit, vk, obj, ptr, idx, holder, holder_offset, atomic, null_marker_offset, decorators, visited);\n@@ -1216,1 +1316,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset,\n+InlineTypeNode* InlineTypeNode::make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, Node* idx, ciInstanceKlass* holder, int holder_offset,\n@@ -1232,1 +1332,1 @@\n-    BasicType bt = vk->payload_size_to_basic_type();\n+    BasicType bt = vk->atomic_size_to_basic_type(null_free);\n@@ -1234,1 +1334,0 @@\n-    Node* adr = kit->basic_plus_adr(obj, ptr, holder_offset);\n@@ -1236,0 +1335,1 @@\n+\n@@ -1237,4 +1337,6 @@\n-    Node* payload = kit->access_load_at(obj, adr, TypeRawPtr::BOTTOM, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, kit->control());\n-    vt->convert_from_payload(kit, bt, payload, 0, null_free, null_marker_offset - holder_offset);\n-    return kit->gvn().transform(vt)->as_InlineType();\n-  }\n+    Node* payload = nullptr;\n+    if (!is_array) {\n+      Node* adr = kit->basic_plus_adr(obj, ptr, holder_offset);\n+      payload = kit->access_load_at(obj, adr, TypeRawPtr::BOTTOM, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, kit->control());\n+    } else {\n+      assert(holder_offset == 0, \"sanity\");\n@@ -1242,5 +1344,87 @@\n-  if (!null_free) {\n-    \/\/ Nullable, read the null marker\n-    Node* adr = kit->basic_plus_adr(obj, ptr, null_marker_offset);\n-    Node* is_init = kit->make_load(kit->control(), adr, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n-    vt->set_req(IsInit, is_init);\n+      RegionNode* region = new RegionNode(3);\n+      kit->gvn().set_type(region, Type::CONTROL);\n+      kit->record_for_igvn(region);\n+\n+      payload = PhiNode::make(region, nullptr, val_type);\n+      kit->gvn().set_type(payload, val_type);\n+      kit->record_for_igvn(payload);\n+\n+      Node* bol = kit->null_free_array_test(obj); \/\/ Argument evaluation order is undefined in C++ and since this sets control, it needs to come first\n+      IfNode* iff = kit->create_and_map_if(kit->control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+\n+      kit->set_control(kit->IfFalse(iff));\n+      region->init_req(1, kit->control());\n+\n+      \/\/ Nullable\n+      if (!kit->stopped()) {\n+        assert(!null_free && vk->has_nullable_atomic_layout(), \"Flat array can't be nullable\");\n+        Node* load = kit->access_load_at(obj, ptr, TypeRawPtr::BOTTOM, val_type, bt, is_array ? (decorators | IS_ARRAY) : decorators, kit->control());\n+        payload->init_req(1, load);\n+      }\n+\n+      kit->set_control(kit->IfTrue(iff));\n+\n+      \/\/ Null-free\n+      if (!kit->stopped()) {\n+        \/\/ Check if it's atomic\n+        RegionNode* region_null_free = new RegionNode(3);\n+        kit->gvn().set_type(region_null_free, Type::CONTROL);\n+        kit->record_for_igvn(region_null_free);\n+\n+        Node* payload_null_free = PhiNode::make(region_null_free, nullptr, val_type);\n+        kit->gvn().set_type(payload_null_free, val_type);\n+        kit->record_for_igvn(payload_null_free);\n+\n+        bol = kit->null_free_atomic_array_test(obj, vk);\n+        IfNode* iff = kit->create_and_map_if(kit->control(), bol, PROB_FAIR, COUNT_UNKNOWN);\n+\n+        kit->set_control(kit->IfTrue(iff));\n+        region_null_free->init_req(1, kit->control());\n+\n+        \/\/ Atomic\n+        if (!kit->stopped()) {\n+          BasicType bt_null_free = vk->atomic_size_to_basic_type(\/* null_free *\/ true);\n+          const Type* val_type_null_free = Type::get_const_basic_type(bt_null_free);\n+\n+          Node* cast = obj;\n+          Node* adr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n+          Node* load = kit->access_load_at(cast, adr, TypeRawPtr::BOTTOM, val_type_null_free, bt_null_free, is_array ? (decorators | IS_ARRAY) : decorators, kit->control());\n+          if (bt == T_LONG && bt_null_free != T_LONG) {\n+            load = kit->gvn().transform(new ConvI2LNode(load));\n+          }\n+          \/\/ Set the null marker if not known to be null-free\n+          if (!null_free) {\n+            load = set_payload_value(&kit->gvn(), load, bt, kit->intcon(1), T_BYTE, null_marker_offset);\n+          }\n+          payload_null_free->init_req(1, load);\n+        }\n+\n+        kit->set_control(kit->IfFalse(iff));\n+        region_null_free->init_req(2, kit->control());\n+\n+        \/\/ Non-Atomic\n+        if (!kit->stopped()) {\n+          \/\/ TODO 8350865 Is the conversion to\/from payload folded? We should wire this directly\n+\n+          InlineTypeNode* vt_atomic = make_uninitialized(kit->gvn(), vk, true);\n+          Node* cast = obj;\n+          Node* adr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n+          vt_atomic->load(kit, cast, adr, holder, visited, holder_offset - vk->payload_offset(), decorators);\n+\n+          Node* tmp_payload = (bt == T_LONG) ? kit->longcon(0) : kit->intcon(0);\n+          int oop_off_1 = -1;\n+          int oop_off_2 = -1;\n+          tmp_payload = vt_atomic->convert_to_payload(kit, bt, tmp_payload, 0, null_free, null_marker_offset, oop_off_1, oop_off_2);\n+\n+          payload_null_free->init_req(2, tmp_payload);\n+        }\n+\n+        region->init_req(2, kit->gvn().transform(region_null_free));\n+        payload->init_req(2, kit->gvn().transform(payload_null_free));\n+      }\n+\n+      kit->set_control(kit->gvn().transform(region));\n+    }\n+\n+    vt->convert_from_payload(kit, bt, kit->gvn().transform(payload), 0, null_free, null_marker_offset - holder_offset);\n+    return kit->gvn().transform(vt)->as_InlineType();\n@@ -1248,0 +1432,1 @@\n+  assert(null_free, \"Nullable flat implies atomic\");\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":219,"deletions":34,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  static InlineTypeNode* make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder, int holder_offset, bool atomic, int null_marker_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, Node* idx, ciInstanceKlass* holder, int holder_offset, bool atomic, int null_marker_offset, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n@@ -100,1 +100,1 @@\n-  static InlineTypeNode* make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, ciInstanceKlass* holder = nullptr, int holder_offset = 0,\n+  static InlineTypeNode* make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* obj, Node* ptr, Node* idx, ciInstanceKlass* holder = nullptr, int holder_offset = 0,\n@@ -146,1 +146,1 @@\n-  void store_flat(GraphKit* kit, Node* base, Node* ptr, ciInstanceKlass* holder, int holder_offset, bool atomic, int null_marker_offset, DecoratorSet decorators) const;\n+  void store_flat(GraphKit* kit, Node* base, Node* ptr, Node* idx, ciInstanceKlass* holder, int holder_offset, bool atomic, int null_marker_offset, DecoratorSet decorators) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -521,1 +521,3 @@\n-  case vmIntrinsics::_newNullRestrictedArray:   return inline_newNullRestrictedArray();\n+  case vmIntrinsics::_newNullRestrictedArray:     return inline_newArray(\/* null_free *\/ true, \/* atomic *\/ false);\n+  case vmIntrinsics::_newNullRestrictedAtomicArray: return inline_newArray(\/* null_free *\/ true, \/* atomic *\/ true);\n+  case vmIntrinsics::_newNullableAtomicArray:     return inline_newArray(\/* null_free *\/ false, \/* atomic *\/ true);\n@@ -2590,1 +2592,1 @@\n-          p = InlineTypeNode::make_from_flat(this, inline_klass, base, base, holder, offset, false, -1, decorators);\n+          p = InlineTypeNode::make_from_flat(this, inline_klass, base, base, nullptr, holder, offset, false, -1, decorators);\n@@ -2592,1 +2594,1 @@\n-          p = InlineTypeNode::make_from_flat(this, inline_klass, base, adr, nullptr, 0, false, -1, decorators);\n+          p = InlineTypeNode::make_from_flat(this, inline_klass, base, adr, nullptr, nullptr, 0, false, -1, decorators);\n@@ -2643,1 +2645,1 @@\n-        val->as_InlineType()->store_flat(this, base, base, holder, offset, false, -1, decorators);\n+        val->as_InlineType()->store_flat(this, base, base, nullptr, holder, offset, false, -1, decorators);\n@@ -2645,1 +2647,1 @@\n-        val->as_InlineType()->store_flat(this, base, adr, nullptr, 0, false, -1, decorators);\n+        val->as_InlineType()->store_flat(this, base, adr, nullptr, nullptr, 0, false, -1, decorators);\n@@ -4498,1 +4500,0 @@\n-\/\/-----------------------inline_newNullRestrictedArray--------------------------\n@@ -4500,1 +4501,4 @@\n-bool LibraryCallKit::inline_newNullRestrictedArray() {\n+\/\/ public static native Object[] newNullRestrictedAtomicArray(Class<?> componentType, int length);\n+\/\/ public static native Object[] newNullableAtomicArray(Class<?> componentType, int length);\n+bool LibraryCallKit::inline_newArray(bool null_free, bool atomic) {\n+  assert(null_free || atomic, \"nullable implies atomic\");\n@@ -4510,1 +4514,17 @@\n-        ciArrayKlass* array_klass = ciArrayKlass::make(t, true);\n+        ciInlineKlass* vk = t->as_inline_klass();\n+        bool flat = vk->flat_in_array();\n+        if (flat && atomic) {\n+          \/\/ Only flat if we have a corresponding atomic layout\n+          flat = null_free ? vk->has_atomic_layout() : vk->has_nullable_atomic_layout();\n+        }\n+        \/\/ TODO 8350865 refactor\n+        if (flat && !atomic) {\n+          flat = vk->has_non_atomic_layout();\n+        }\n+\n+        \/\/ TOOD 8350865 ZGC needs card marks on initializing default value stores\n+        if (UseZGC && null_free && !flat) {\n+          return false;\n+        }\n+\n+        ciArrayKlass* array_klass = ciArrayKlass::make(t, flat, null_free, atomic);\n@@ -4513,2 +4533,6 @@\n-          array_klass_type = array_klass_type->cast_to_null_free();\n-          Node* obj = new_array(makecon(array_klass_type), length, 0, nullptr, false);  \/\/ no arguments to push\n+          Node* obj = new_array(makecon(array_klass_type), length, 0);\n+          const TypeAryPtr* arytype = gvn().type(obj)->is_aryptr();\n+          assert(arytype->is_null_free() == null_free, \"inconsistency\");\n+          assert(arytype->is_not_null_free() == !null_free, \"inconsistency\");\n+          assert(arytype->is_flat() == flat, \"inconsistency\");\n+          assert(arytype->is_aryptr()->is_not_flat() == !flat, \"inconsistency\");\n@@ -4516,1 +4540,0 @@\n-          assert(gvn().type(obj)->is_aryptr()->is_null_free(), \"must be null-free\");\n@@ -4726,0 +4749,1 @@\n+        \/\/ TODO 8350865 This is not correct anymore. Write tests and fix logic similar to arraycopy.\n@@ -6292,0 +6316,4 @@\n+    \/\/ TODO 8350865 Fix below logic. Also handle atomicity.\n+    generate_fair_guard(flat_array_test(src), slow_region);\n+    generate_fair_guard(flat_array_test(dest), slow_region);\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-  bool inline_newNullRestrictedArray();\n+  bool inline_newArray(bool null_free, bool atomic);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -585,1 +585,1 @@\n-      \/\/ TODO 8341767 Fix this\n+      \/\/ TODO 8350865 Fix this\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1555,0 +1555,7 @@\n+    \/\/ TODO 8350865 Fix below logic. Also handle atomicity.\n+    \/\/ We need to be careful here because 'adjust_for_flat_array' will adjust offsets\/length etc. which then does not work anymore for the slow call to SharedRuntime::slow_arraycopy_C.\n+    if (!(top_src->is_flat() && top_dest->is_flat())) {\n+      generate_flat_array_guard(&ctrl, src, merge_mem, slow_region);\n+      generate_flat_array_guard(&ctrl, dest, merge_mem, slow_region);\n+    }\n+\n@@ -1575,1 +1582,1 @@\n-  if (top_dest->is_flat()) {\n+  if (top_src->is_flat() && top_dest->is_flat()) {\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -630,2 +630,3 @@\n-               t->isa_aryptr() != nullptr && !t->is_aryptr()->is_null_free() && !t->is_aryptr()->is_not_null_free()) {\n-      \/\/ Speculate on varargs Object array being not null-free (and therefore also not flat)\n+               t->isa_aryptr() != nullptr && !t->is_aryptr()->is_null_free() && !t->is_aryptr()->is_flat() &&\n+               (!t->is_aryptr()->is_not_null_free() || !t->is_aryptr()->is_not_flat())) {\n+      \/\/ Speculate on varargs Object array being not null-free and not flat\n@@ -634,1 +635,1 @@\n-      spec_type = spec_type->remove_speculative()->is_aryptr()->cast_to_not_null_free();\n+      spec_type = spec_type->remove_speculative()->is_aryptr()->cast_to_not_null_free()->cast_to_not_flat();\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,14 +84,0 @@\n-  if (array_type->is_flat()) {\n-    \/\/ Load from flat inline type array\n-    Node* inline_type;\n-    if (element_ptr->klass_is_exact()) {\n-      inline_type = InlineTypeNode::make_from_flat(this, elemtype->inline_klass(), array, adr);\n-    } else {\n-      \/\/ Element type of flat array is not exact. Therefore, we cannot determine the flat array layout statically.\n-      \/\/ Emit a runtime call to load the element from the flat array.\n-      inline_type = load_from_unknown_flat_array(array, array_index, element_ptr);\n-      inline_type = record_profile_for_speculation_at_array_load(inline_type);\n-    }\n-    push(inline_type);\n-    return;\n-  }\n@@ -101,1 +87,1 @@\n-    assert(UseArrayFlattening && is_reference_type(bt) && element_ptr->can_be_inline_type() && !array_type->is_not_null_free() &&\n+    assert(UseArrayFlattening && is_reference_type(bt) && element_ptr->can_be_inline_type() &&\n@@ -108,1 +94,0 @@\n-      assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n@@ -110,12 +95,15 @@\n-      const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n-      DecoratorSet decorator_set = IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD;\n-      if (needs_range_check(array_type->size(), array_index)) {\n-        \/\/ We've emitted a RangeCheck but now insert an additional check between the range check and the actual load.\n-        \/\/ We cannot pin the load to two separate nodes. Instead, we pin it conservatively here such that it cannot\n-        \/\/ possibly float above the range check at any point.\n-        decorator_set |= C2_UNKNOWN_CONTROL_LOAD;\n-      }\n-      Node* ld = access_load_at(array, adr, adr_type, element_ptr, bt, decorator_set);\n-      if (element_ptr->is_inlinetypeptr()) {\n-        assert(element_ptr->maybe_null(), \"null free array should be handled above\");\n-        ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass(), false);\n+      if (!array_type->is_flat()) {\n+        assert(array_type->is_flat() || control()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n+        const TypeAryPtr* adr_type = TypeAryPtr::get_array_body_type(bt);\n+        DecoratorSet decorator_set = IN_HEAP | IS_ARRAY | C2_CONTROL_DEPENDENT_LOAD;\n+        if (needs_range_check(array_type->size(), array_index)) {\n+          \/\/ We've emitted a RangeCheck but now insert an additional check between the range check and the actual load.\n+          \/\/ We cannot pin the load to two separate nodes. Instead, we pin it conservatively here such that it cannot\n+          \/\/ possibly float above the range check at any point.\n+          decorator_set |= C2_UNKNOWN_CONTROL_LOAD;\n+        }\n+        Node* ld = access_load_at(array, adr, adr_type, element_ptr, bt, decorator_set);\n+        if (element_ptr->is_inlinetypeptr()) {\n+          ld = InlineTypeNode::make_from_oop(this, ld, element_ptr->inline_klass(), !element_ptr->maybe_null());\n+        }\n+        ideal.set(res, ld);\n@@ -124,1 +112,0 @@\n-      ideal.set(res, ld);\n@@ -128,21 +115,23 @@\n-      if (element_ptr->is_inlinetypeptr()) {\n-        \/\/ Element type is known, cast and load from flat array layout.\n-        ciInlineKlass* vk = element_ptr->inline_klass();\n-        assert(vk->flat_in_array() && element_ptr->maybe_null(), \"never\/always flat - should be optimized\");\n-        ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* null_free *\/ true);\n-        const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n-        Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, arytype));\n-        Node* casted_adr = array_element_address(cast, array_index, T_OBJECT, array_type->size(), control());\n-        \/\/ Re-execute flat array load if buffering triggers deoptimization\n-        PreserveReexecuteState preexecs(this);\n-        jvms()->set_should_reexecute(true);\n-        inc_sp(2);\n-        Node* vt = InlineTypeNode::make_from_flat(this, vk, cast, casted_adr)->buffer(this, false);\n-        ideal.set(res, vt);\n-        ideal.sync_kit(this);\n-      } else {\n-        \/\/ Element type is unknown, and thus we cannot statically determine the exact flat array layout. Emit a\n-        \/\/ runtime call to correctly load the inline type element from the flat array.\n-        Node* inline_type = load_from_unknown_flat_array(array, array_index, element_ptr);\n-        ideal.sync_kit(this);\n-        ideal.set(res, inline_type);\n+      if (!array_type->is_not_flat()) {\n+        if (element_ptr->is_inlinetypeptr()) {\n+          \/\/ Element type is known, cast and load from flat array layout.\n+          ciInlineKlass* vk = element_ptr->inline_klass();\n+          bool is_null_free = array_type->is_null_free() || !vk->has_nullable_atomic_layout();\n+          bool is_not_null_free = array_type->is_not_null_free() || (!vk->has_atomic_layout() && !vk->has_non_atomic_layout());\n+          if (is_null_free) {\n+            \/\/ TODO 8350865 Impossible type\n+            is_not_null_free = false;\n+          }\n+          bool is_naturally_atomic = vk->is_empty() || (is_null_free && vk->nof_declared_nonstatic_fields() == 1);\n+          bool may_need_atomicity = !is_naturally_atomic && ((!is_not_null_free && vk->has_atomic_layout()) || (!is_null_free && vk->has_nullable_atomic_layout()));\n+\n+          adr = flat_array_element_address(array, array_index, vk, is_null_free, is_not_null_free, may_need_atomicity);\n+          int nm_offset = is_null_free ? -1 : vk->null_marker_offset_in_payload();\n+          Node* vt = InlineTypeNode::make_from_flat(this, vk, array, adr, array_index, nullptr, 0, may_need_atomicity, nm_offset);\n+          ideal.set(res, vt);\n+        } else {\n+          \/\/ Element type is unknown, and thus we cannot statically determine the exact flat array layout. Emit a\n+          \/\/ runtime call to correctly load the inline type element from the flat array.\n+          Node* inline_type = load_from_unknown_flat_array(array, array_index, element_ptr);\n+          ideal.set(res, inline_type);\n+        }\n@@ -150,0 +139,1 @@\n+      ideal.sync_kit(this);\n@@ -158,5 +148,0 @@\n-  if (array_type->is_null_free()) {\n-    \/\/ Load from non-flat inline type array (elements can never be null)\n-    bt = T_OBJECT;\n-  }\n-\n@@ -234,4 +219,4 @@\n-    bool not_null_free = !stored_value_casted_type->maybe_null() &&\n-                         !stored_value_casted_type->is_oopptr()->can_be_inline_type();\n-    bool not_flat = not_null_free || (stored_value_casted_type->is_inlinetypeptr() &&\n-                                      !stored_value_casted_type->inline_klass()->flat_in_array());\n+    bool not_inline = !stored_value_casted_type->maybe_null() && !stored_value_casted_type->is_oopptr()->can_be_inline_type();\n+    bool not_null_free = not_inline;\n+    bool not_flat = not_inline || ( stored_value_casted_type->is_inlinetypeptr() &&\n+                                   !stored_value_casted_type->inline_klass()->flat_in_array());\n@@ -239,1 +224,1 @@\n-      \/\/ Storing a non-inline type, mark array as not null-free (-> not flat).\n+      \/\/ Storing a non-inline type, mark array as not null-free.\n@@ -244,1 +229,2 @@\n-    } else if (!array_type->is_not_flat() && not_flat) {\n+    }\n+    if (!array_type->is_not_flat() && not_flat) {\n@@ -252,18 +238,1 @@\n-    if (array_type->is_flat()) {\n-      \/\/ Store to flat inline type array\n-      assert(!stored_value_casted_type->maybe_null(), \"should be guaranteed by array store check\");\n-      if (array_type->klass_is_exact()) {\n-        \/\/ Store to exact flat inline type array where we know the flat array layout statically.\n-        \/\/ Re-execute flat array store if buffering triggers deoptimization\n-        PreserveReexecuteState preexecs(this);\n-        inc_sp(3);\n-        jvms()->set_should_reexecute(true);\n-        stored_value_casted->as_InlineType()->store_flat(this, array, adr, nullptr, 0, false, -1, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n-      } else {\n-        \/\/ Element type of flat array is not exact. Therefore, we cannot determine the flat array layout statically.\n-        \/\/ Emit a runtime call to store the element to the flat array.\n-        store_to_unknown_flat_array(array, array_index, stored_value_casted);\n-      }\n-      return;\n-    }\n-    if (array_type->is_null_free()) {\n+    if (!array_type->is_flat() && array_type->is_null_free()) {\n@@ -272,1 +241,1 @@\n-      if (elemtype->inline_klass()->is_empty()) {\n+      if (elemtype->is_inlinetypeptr() && elemtype->inline_klass()->is_empty()) {\n@@ -276,1 +245,1 @@\n-    } else if (!array_type->is_not_flat() && (stored_value_casted_type != TypePtr::NULL_PTR || StressReflectiveCode)) {\n+    } else if (!array_type->is_not_flat()) {\n@@ -279,1 +248,3 @@\n-             !array_type->klass_is_exact() && !array_type->is_not_null_free(), \"array can't be a flat array\");\n+             (!array_type->klass_is_exact() || array_type->is_flat()), \"array can't be a flat array\");\n+      \/\/ TODO 8350865 Depending on the available layouts, we can avoid this check in below flat\/not-flat branches. Also the safe_for_replace arg is now always true.\n+      array = inline_array_null_guard(array, stored_value_casted, 3, true);\n@@ -283,14 +254,3 @@\n-        assert(ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n-        sync_kit(ideal);\n-        Node* cast_array = inline_array_null_guard(array, stored_value_casted, 3);\n-        inc_sp(3);\n-        access_store_at(cast_array, adr, adr_type, stored_value_casted, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n-        dec_sp(3);\n-        ideal.sync_kit(this);\n-      } ideal.else_(); {\n-        sync_kit(ideal);\n-        \/\/ flat array\n-        Node* null_ctl = top();\n-        Node* null_checked_stored_value_casted = null_check_oop(stored_value_casted, &null_ctl);\n-        if (null_ctl != top()) {\n-          PreserveJVMState pjvms(this);\n+        if (!array_type->is_flat()) {\n+          sync_kit(ideal);\n+          assert(array_type->is_flat() || ideal.ctrl()->in(0)->as_If()->is_flat_array_check(&_gvn), \"Should be found\");\n@@ -298,2 +258,1 @@\n-          set_control(null_ctl);\n-          uncommon_trap(Deoptimization::Reason_null_check, Deoptimization::Action_none);\n+          access_store_at(array, adr, adr_type, stored_value_casted, elemtype, bt, MO_UNORDERED | IN_HEAP | IS_ARRAY, false);\n@@ -301,0 +260,1 @@\n+          ideal.sync_kit(this);\n@@ -302,9 +262,13 @@\n-        \/\/ Try to determine the inline klass\n-        ciInlineKlass* inline_Klass = nullptr;\n-        if (stored_value_casted_type->is_inlinetypeptr()) {\n-          inline_Klass = stored_value_casted_type->inline_klass();\n-        } else if (elemtype->is_inlinetypeptr()) {\n-          inline_Klass = elemtype->inline_klass();\n-        }\n-        if (!stopped()) {\n-          if (inline_Klass != nullptr) {\n+      } ideal.else_(); {\n+        \/\/ Flat array\n+        sync_kit(ideal);\n+        if (!array_type->is_not_flat()) {\n+          \/\/ Try to determine the inline klass type of the stored value\n+          ciInlineKlass* vk = nullptr;\n+          if (stored_value_casted_type->is_inlinetypeptr()) {\n+            vk = stored_value_casted_type->inline_klass();\n+          } else if (elemtype->is_inlinetypeptr()) {\n+            vk = elemtype->inline_klass();\n+          }\n+\n+          if (vk != nullptr) {\n@@ -312,10 +276,5 @@\n-            assert(inline_Klass->flat_in_array() && elemtype->maybe_null(), \"never\/always flat - should be optimized\");\n-            ciArrayKlass* array_klass = ciArrayKlass::make(inline_Klass, \/* null_free *\/ true);\n-            const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n-            Node* casted_array = _gvn.transform(new CheckCastPPNode(control(), array, arytype));\n-            Node* casted_adr = array_element_address(casted_array, array_index, T_OBJECT, arytype->size(), control());\n-            if (!null_checked_stored_value_casted->is_InlineType()) {\n-              assert(!gvn().type(null_checked_stored_value_casted)->maybe_null(),\n-                     \"inline type array elements should never be null\");\n-              null_checked_stored_value_casted = InlineTypeNode::make_from_oop(this, null_checked_stored_value_casted,\n-                                                                               inline_Klass);\n+            bool is_null_free = array_type->is_null_free() || !vk->has_nullable_atomic_layout();\n+            bool is_not_null_free = array_type->is_not_null_free() || (!vk->has_atomic_layout() && !vk->has_non_atomic_layout());\n+            if (is_null_free) {\n+              \/\/ TODO 8350865 Impossible type\n+              is_not_null_free = false;\n@@ -323,0 +282,3 @@\n+            bool is_naturally_atomic = vk->is_empty() || (is_null_free && vk->nof_declared_nonstatic_fields() == 1);\n+            bool may_need_atomicity = !is_naturally_atomic && ((!is_not_null_free && vk->has_atomic_layout()) || (!is_null_free && vk->has_nullable_atomic_layout()));\n+\n@@ -325,1 +287,0 @@\n-            inc_sp(3);\n@@ -327,1 +288,9 @@\n-            null_checked_stored_value_casted->as_InlineType()->store_flat(this, casted_array, casted_adr, nullptr, 0, false, -1, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n+            inc_sp(3);\n+\n+            if (!stored_value_casted->is_InlineType()) {\n+              assert(_gvn.type(stored_value_casted) == TypePtr::NULL_PTR, \"Unexpected value\");\n+              stored_value_casted = InlineTypeNode::make_null(_gvn, vk);\n+            }\n+            adr = flat_array_element_address(array, array_index, vk, is_null_free, is_not_null_free, may_need_atomicity);\n+            int nm_offset = is_null_free ? -1 : vk->null_marker_offset_in_payload();\n+            stored_value_casted->as_InlineType()->store_flat(this, array, adr, array_index, nullptr, 0, may_need_atomicity, nm_offset, MO_UNORDERED | IN_HEAP | IS_ARRAY);\n@@ -330,1 +299,1 @@\n-            store_to_unknown_flat_array(array, array_index, null_checked_stored_value_casted);\n+            store_to_unknown_flat_array(array, array_index, stored_value_casted);\n@@ -501,2 +470,2 @@\n-  \/\/ whether we have a non-null-free or non-flat array. Since non-null-free implies non-flat, we check this first.\n-  \/\/ Speculating on a non-null-free array doesn't help aaload but could be profitable for a subsequent aastore.\n+  \/\/ whether we have a non-null-free or non-flat array. Speculating on a non-null-free array doesn't help aaload but could\n+  \/\/ be profitable for a subsequent aastore.\n@@ -506,1 +475,0 @@\n-\n@@ -568,1 +536,1 @@\n-\/\/ Speculate that the array is non-null-free. This will imply non-flatness. We emit a trap when this turns out to be\n+\/\/ Speculate that the array is non-null-free. We emit a trap when this turns out to be\n@@ -601,2 +569,2 @@\n-\/\/ Speculate that the array is non-flat. We emit a trap when this turns out to be wrong. On the fast path, we add a\n-\/\/ CheckCastPP to use the non-flat type.\n+\/\/ Speculate that the array is non-flat. We emit a trap when this turns out to be wrong.\n+\/\/ On the fast path, we add a CheckCastPP to use the non-flat type.\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":94,"deletions":126,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-    ld = InlineTypeNode::make_from_flat(this, field_klass->as_inline_klass(), obj, obj, field->holder(), offset, needs_atomic_access, field->null_marker_offset());\n+    ld = InlineTypeNode::make_from_flat(this, field_klass->as_inline_klass(), obj, obj, nullptr, field->holder(), offset, needs_atomic_access, field->null_marker_offset());\n@@ -274,1 +274,2 @@\n-      val = InlineTypeNode::make_from_oop(this, val, vk, field->is_null_free());\n+      assert(gvn().type(val) == TypePtr::NULL_PTR, \"Unexpected value\");\n+      val = InlineTypeNode::make_null(gvn(), vk);\n@@ -279,1 +280,1 @@\n-    val->as_InlineType()->store_flat(this, obj, obj, field->holder(), offset, needs_atomic_access, field->null_marker_offset(), IN_HEAP | MO_UNORDERED);\n+    val->as_InlineType()->store_flat(this, obj, obj, nullptr, field->holder(), offset, needs_atomic_access, field->null_marker_offset(), IN_HEAP | MO_UNORDERED);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  bool null_free;\n+  bool null_free = arytype->is_null_free();\n@@ -263,1 +263,0 @@\n-    null_free = arytype->is_flat() || !elem_ptr->maybe_null();\n@@ -265,4 +264,1 @@\n-  } else {\n-    \/\/ TODO: Should move to TypeAry::is_null_free() with JDK-8345681\n-    TypePtr::PTR ptr = elem_ptr->ptr();\n-    null_free = ((ptr == TypePtr::NotNull) || (ptr == TypePtr::AnyNull));\n+  }\n@@ -270,15 +266,14 @@\n-    \/\/ If the element type is exact, the array can be null-free (i.e. the element type is NotNull) if:\n-    \/\/   - The elements are inline types\n-    \/\/   - The array is from an autobox cache.\n-    \/\/ If the element type is inexact, it could represent multiple null-free arrays. Since autobox cache arrays\n-    \/\/ are local to very few cache classes and are only used in the valueOf() methods, they are always exact and are not\n-    \/\/ merged or hidden behind super types. Therefore, an inexact null-free array always represents some kind of\n-    \/\/ inline type array - either of an abstract value class or Object.\n-    if (null_free) {\n-      ciKlass* klass = elem_ptr->is_instptr()->instance_klass();\n-      if (klass->exact_klass()) {\n-        assert(elem_ptr->is_inlinetypeptr() || arytype->is_autobox_cache(), \"elements must be inline type or autobox cache\");\n-      } else {\n-        assert(!arytype->is_autobox_cache() && elem_ptr->can_be_inline_type() &&\n-               (klass->is_java_lang_Object() || klass->is_abstract()), \"cannot have inexact non-inline type elements\");\n-      }\n+  \/\/ If the element type is exact, the array can be null-free (i.e. the element type is NotNull) if:\n+  \/\/   - The elements are inline types\n+  \/\/   - The array is from an autobox cache.\n+  \/\/ If the element type is inexact, it could represent multiple null-free arrays. Since autobox cache arrays\n+  \/\/ are local to very few cache classes and are only used in the valueOf() methods, they are always exact and are not\n+  \/\/ merged or hidden behind super types. Therefore, an inexact null-free array always represents some kind of\n+  \/\/ inline type array - either of an abstract value class or Object.\n+  if (null_free) {\n+    ciKlass* klass = elem_ptr->is_instptr()->instance_klass();\n+    if (klass->exact_klass()) {\n+      assert(elem_ptr->is_inlinetypeptr() || arytype->is_autobox_cache(), \"elements must be inline type or autobox cache\");\n+    } else {\n+      assert(!arytype->is_autobox_cache() && elem_ptr->can_be_inline_type() &&\n+             (klass->is_java_lang_Object() || klass->is_abstract()), \"cannot have inexact non-inline type elements\");\n@@ -286,1 +281,0 @@\n-#endif \/\/ ASSERT\n@@ -288,0 +282,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2262,1 +2262,0 @@\n-  assert(buffer != nullptr, \"can't store null into flat array\");\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1100,0 +1100,3 @@\n+  \/\/ TODO 8350865 This currently triggers a verification failure, the code around \"\/\/ Even though MyValue is final\" needs adjustments\n+  if ((this_t->isa_ptr() && this_t->is_ptr()->is_not_flat()) ||\n+      (this_t->_dual->isa_ptr() && this_t->_dual->is_ptr()->is_not_flat())) return mt;\n@@ -2794,2 +2797,5 @@\n-      \/\/ Even though MyValue is final, [LMyValue is not exact because null-free [LMyValue is a subtype.\n-      if (tinst->is_inlinetypeptr() && (tinst->ptr() == TypePtr::BotPTR || tinst->ptr() == TypePtr::TopPTR)) {\n+      \/\/ Even though MyValue is final, [LMyValue is only exact if the array\n+      \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n+      \/\/ TODO 8350865 If we know that the array can't be null-free, it's allowed to be exact, right?\n+      \/\/ If so, we should add '&& !_not_null_free'\n+      if (tinst->is_inlinetypeptr() && (tinst->ptr() != TypePtr::NotNull)) {\n@@ -4068,2 +4074,3 @@\n-    bool not_null_free = !exact_etype->can_be_inline_type();\n-    bool not_flat = !UseArrayFlattening || not_null_free || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flat_in_array());\n+    bool not_inline = !exact_etype->can_be_inline_type();\n+    bool not_null_free = not_inline;\n+    bool not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flat_in_array());\n@@ -4089,1 +4096,3 @@\n-    etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    if (klass->as_array_klass()->is_elem_null_free()) {\n+      etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n@@ -4146,2 +4155,6 @@\n-    etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n-    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ true);\n+    bool is_null_free = o->as_array()->is_null_free();\n+    if (is_null_free) {\n+      etype = etype->join_speculative(TypePtr::NOTNULL)->is_oopptr();\n+    }\n+    const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o->as_array()->length()), \/* stable= *\/ false, \/* flat= *\/ true,\n+                                        \/* not_flat= *\/ false, \/* not_null_free= *\/ !is_null_free);\n@@ -5300,2 +5313,2 @@\n-  assert(!not_null_free || !is_flat(), \"inconsistency\");\n-  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), \/* not_flat= *\/ not_null_free ? true : is_not_flat(), not_null_free);\n+  assert(!not_null_free || !is_null_free(), \"inconsistency\");\n+  const TypeAry* new_ary = TypeAry::make(elem(), size(), is_stable(), is_flat(), is_not_flat(), not_null_free);\n@@ -5319,4 +5332,0 @@\n-  } else if (from->is_not_null_free()) {\n-    return cast_to_not_null_free(); \/\/ Implies not flat\n-  } else if (from->is_not_flat()) {\n-    return cast_to_not_flat();\n@@ -5324,1 +5333,8 @@\n-  return this;\n+  const TypeAryPtr* res = this;\n+  if (from->is_not_null_free()) {\n+    res = res->cast_to_not_null_free();\n+  }\n+  if (from->is_not_flat()) {\n+    res = res->cast_to_not_flat();\n+  }\n+  return res;\n@@ -5622,0 +5638,1 @@\n+  bool res_null_free = this_ary->is_null_free() && other_ary->is_null_free();\n@@ -5688,2 +5705,2 @@\n-        \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n-        if (res_xk && !res_not_null_free) {\n+        \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n+        if (res_xk && !res_null_free && !res_not_null_free) {\n@@ -5707,2 +5724,4 @@\n-        \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n-        if (res_xk && !res_not_null_free) {\n+        \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n+        \/\/ TODO 8350865 If both types are exact and have the same null-free property, the result should be exact, right? Same above for the Constant case.\n+        \/\/ && elem->make_ptr() != nullptr && elem->make_ptr()->is_inlinetypeptr() && (this_ary->is_null_free() != other_ary->is_null_free()\n+        if (res_xk && !res_null_free && !res_not_null_free) {\n@@ -5725,1 +5744,2 @@\n-  return new TypeAryPtr(dual_ptr(), _const_oop, _ary->dual()->is_ary(), _klass, _klass_is_exact, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());\n+  bool xk = _klass_is_exact;\n+  return new TypeAryPtr(dual_ptr(), _const_oop, _ary->dual()->is_ary(), _klass, xk, dual_offset(), dual_field_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());\n@@ -6251,1 +6271,3 @@\n-        \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n+        \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n+        \/\/ TODO 8350865 If we know that the array can't be null-free, it's allowed to be exact, right?\n+        \/\/ If so, we should add '|| is_not_null_free()'\n@@ -6256,1 +6278,1 @@\n-  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_null_free());\n+  return TypeAryKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, elem, klass(), Offset(0), is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n@@ -6608,1 +6630,1 @@\n-        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n+        return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free());\n@@ -6627,1 +6649,1 @@\n-          return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_null_free());\n+          return TypeAryKlassPtr::make(ptr, tp->elem(), tp->klass(), offset, tp->is_not_flat(), tp->is_not_null_free(), tp->is_flat(), tp->is_null_free());\n@@ -6764,2 +6786,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free) {\n-  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset, not_flat, not_null_free, null_free))->hashcons();\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free) {\n+  return (TypeAryKlassPtr*)(new TypeAryKlassPtr(ptr, elem, k, offset, not_flat, not_null_free, flat, null_free))->hashcons();\n@@ -6768,1 +6790,1 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool null_free) {\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free) {\n@@ -6773,1 +6795,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free);\n@@ -6777,1 +6799,1 @@\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, null_free);\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, flat, null_free);\n@@ -6780,2 +6802,2 @@\n-    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass);\n-    return TypeAryKlassPtr::make(ptr, etype, k, offset, not_flat, not_null_free, null_free);\n+    const TypeKlassPtr* etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n+    return TypeAryKlassPtr::make(ptr, etype, nullptr, offset, not_flat, not_null_free, flat, null_free);\n@@ -6790,1 +6812,1 @@\n-  bool not_null_free = (ptr == Constant) ? !null_free : !k->is_flat_array_klass() && (k->is_type_array_klass() || !k->as_array_klass()->element_klass()->can_be_inline_klass(false));\n+  bool flat = k->is_flat_array_klass();\n@@ -6792,3 +6814,6 @@\n-  bool not_flat = !UseArrayFlattening || not_null_free || (k->as_array_klass()->element_klass() != nullptr &&\n-                                                     k->as_array_klass()->element_klass()->is_inlinetype() &&\n-                                                     !k->as_array_klass()->element_klass()->flat_in_array());\n+  bool not_inline = k->is_type_array_klass() || !k->as_array_klass()->element_klass()->can_be_inline_klass(false);\n+  bool not_null_free = (ptr == Constant) ? !null_free : not_inline;\n+  bool not_flat = (ptr == Constant) ? !flat : (!UseArrayFlattening || not_inline ||\n+                   (k->as_array_klass()->element_klass() != nullptr &&\n+                    k->as_array_klass()->element_klass()->is_inlinetype() &&\n+                   !k->as_array_klass()->element_klass()->flat_in_array()));\n@@ -6796,1 +6821,1 @@\n-  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, null_free);\n+  return TypeAryKlassPtr::make(ptr, k, offset, interface_handling, not_flat, not_null_free, flat, null_free);\n@@ -6812,0 +6837,1 @@\n+    _flat == p->_flat &&\n@@ -6819,1 +6845,1 @@\n-      (uint)(_not_null_free ? 44 : 0) + (uint)(_null_free ? 45 : 0);\n+      (uint)(_not_null_free ? 44 : 0) + (uint)(_flat ? 45 : 0) + (uint)(_null_free ? 46 : 0);\n@@ -6838,1 +6864,3 @@\n-      k_ary = ciArrayKlass::make(el->inline_klass(), \/* null_free *\/ true);\n+      \/\/ TODO 8350865 We assume atomic if the atomic layout is available\n+      bool atomic = is_null_free() ? el->inline_klass()->has_atomic_layout() : el->inline_klass()->has_nullable_atomic_layout();\n+      k_ary = ciArrayKlass::make(el->inline_klass(), \/* flat *\/ true, is_null_free(), atomic);\n@@ -6891,1 +6919,3 @@\n-    k = ciArrayKlass::make(k, is_null_free());\n+    \/\/ TODO 8350865 We assume atomic if the atomic layout is available\n+    bool atomic = k->is_inlinetype() && (is_null_free() ? k->as_inline_klass()->has_atomic_layout() : k->as_inline_klass()->has_nullable_atomic_layout());\n+    k = ciArrayKlass::make(k, is_flat(), is_null_free(), atomic);\n@@ -6911,1 +6941,1 @@\n-  return make(_ptr, elem(), klass(), xadd_offset(offset), is_not_flat(), is_not_null_free(), _null_free);\n+  return make(_ptr, elem(), klass(), xadd_offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free);\n@@ -6915,1 +6945,1 @@\n-  return make(_ptr, elem(), klass(), Offset(offset), is_not_flat(), is_not_null_free(), _null_free);\n+  return make(_ptr, elem(), klass(), Offset(offset), is_not_flat(), is_not_null_free(), _flat, _null_free);\n@@ -6922,1 +6952,1 @@\n-  return make(ptr, elem(), _klass, _offset, is_not_flat(), is_not_null_free(), _null_free);\n+  return make(ptr, elem(), _klass, _offset, is_not_flat(), is_not_null_free(), _flat, _null_free);\n@@ -6931,1 +6961,3 @@\n-  \/\/ is null-free due to null-free [LMyValue <: null-able [LMyValue.\n+  \/\/ is (not) null-free due to null-free [LMyValue <: null-able [LMyValue.\n+  \/\/ TODO 8350865 If we know that the array can't be null-free, it's allowed to be exact, right?\n+  \/\/ If so, we should add '&& !is_not_null_free()'\n@@ -6963,2 +6995,3 @@\n-      not_null_free = !exact_etype->can_be_inline_type();\n-      not_flat = !UseArrayFlattening || not_null_free || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flat_in_array());\n+      bool not_inline = !exact_etype->can_be_inline_type();\n+      not_null_free = not_inline;\n+      not_flat = !UseArrayFlattening || not_inline || (exact_etype->is_inlinetypeptr() && !exact_etype->inline_klass()->flat_in_array());\n@@ -6967,1 +7000,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _null_free);\n+  return make(klass_is_exact ? Constant : NotNull, elem, k, _offset, not_flat, not_null_free, _flat, _null_free);\n@@ -6971,1 +7004,1 @@\n-  return make(_ptr, elem(), klass(), _offset, is_not_flat(), false, true);\n+  return make(_ptr, elem(), klass(), _offset, is_not_flat(), false, is_flat(), true);\n@@ -7036,1 +7069,1 @@\n-      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), is_null_free());\n+      return make(ptr, _elem, klass(), offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n@@ -7080,0 +7113,1 @@\n+    bool flat = meet_flat(tap->_flat);\n@@ -7082,0 +7116,1 @@\n+      flat = false;\n@@ -7085,0 +7120,1 @@\n+        flat = _flat;\n@@ -7087,0 +7123,1 @@\n+        flat = tap->_flat;\n@@ -7090,0 +7127,1 @@\n+        flat = _flat || tap->_flat;\n@@ -7092,1 +7130,1 @@\n-    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, null_free);\n+    return make(ptr, elem, res_klass, off, res_not_flat, res_not_null_free, flat, null_free);\n@@ -7110,1 +7148,1 @@\n-        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_null_free());\n+        return TypeAryKlassPtr::make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n@@ -7130,1 +7168,1 @@\n-          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_null_free());\n+          return make(ptr, _elem, _klass, offset, is_not_flat(), is_not_null_free(), is_flat(), is_null_free());\n@@ -7271,1 +7309,1 @@\n-  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_null_free());\n+  return new TypeAryKlassPtr(dual_ptr(), elem()->dual(), klass(), dual_offset(), !is_not_flat(), !is_not_null_free(), dual_flat(), dual_null_free());\n@@ -7281,1 +7319,3 @@\n-    k = ciArrayKlass::make(k, _null_free);\n+    \/\/ TODO 8350865 We assume atomic if the atomic layout is available\n+    bool atomic = k->is_inlinetype() && (is_null_free() ? k->as_inline_klass()->has_atomic_layout() : k->as_inline_klass()->has_nullable_atomic_layout());\n+    k = ciArrayKlass::make(k, is_flat(), is_null_free(), atomic);\n@@ -7328,1 +7368,1 @@\n-  if (is_flat()) st->print(\":flat\");\n+  if (_flat) st->print(\":flat\");\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":93,"deletions":53,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -1542,1 +1542,1 @@\n-  bool is_null_free()     const { return is_flat() || (_ary->_elem->make_ptr() != nullptr && _ary->_elem->make_ptr()->is_inlinetypeptr() && (_ary->_elem->make_ptr()->ptr() == NotNull || _ary->_elem->make_ptr()->ptr() == AnyNull)); }\n+  bool is_null_free()     const { return _ary->_elem->make_ptr() != nullptr && (_ary->_elem->make_ptr()->ptr() == NotNull || _ary->_elem->make_ptr()->ptr() == AnyNull); }\n@@ -1868,0 +1868,1 @@\n+  const bool _flat;\n@@ -1871,2 +1872,2 @@\n-  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, Offset offset, bool not_flat, int not_null_free, bool null_free)\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, _array_interfaces, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _null_free(null_free) {\n+  TypeAryKlassPtr(PTR ptr, const Type *elem, ciKlass* klass, Offset offset, bool not_flat, int not_null_free, bool flat, bool null_free)\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, _array_interfaces, offset), _elem(elem), _not_flat(not_flat), _not_null_free(not_null_free), _flat(flat), _null_free(null_free) {\n@@ -1882,0 +1883,8 @@\n+  bool dual_flat() const {\n+    return _flat;\n+  }\n+\n+  bool meet_flat(bool other) const {\n+    return _flat && other;\n+  }\n+\n@@ -1895,1 +1904,1 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool null_free);\n+  static const TypeAryKlassPtr* make(PTR ptr, ciKlass* k, Offset offset, InterfaceHandling interface_handling, bool not_flat, bool not_null_free, bool flat, bool null_free);\n@@ -1903,1 +1912,1 @@\n-  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool null_free);\n+  static const TypeAryKlassPtr* make(PTR ptr, const Type* elem, ciKlass* k, Offset offset, bool not_flat, bool not_null_free, bool flat, bool null_free);\n@@ -1931,1 +1940,1 @@\n-  bool is_flat()          const { return klass() != nullptr && klass()->is_flat_array_klass(); }\n+  bool is_flat()          const { return _flat; }\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-    int layout_kind = fd.layout_kind();\n+    int layout_kind = (int)fd.layout_kind();\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -381,1 +381,1 @@\n-    return LayoutKind::REFERENCE;\n+    return (jint)LayoutKind::REFERENCE;\n@@ -443,1 +443,1 @@\n-  assert(layoutKind != LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n+  assert(layoutKind != (int)LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n@@ -480,1 +480,1 @@\n-  assert(layoutKind != LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n+  assert(layoutKind != (int)LayoutKind::REFERENCE, \"This method handles only flat layouts\");\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3849,2 +3849,7 @@\n-    InlineTypePassFieldsAsArgs = false;\n-    InlineTypeReturnedAsFields = false;\n+    FLAG_SET_DEFAULT(InlineTypePassFieldsAsArgs, false);\n+    FLAG_SET_DEFAULT(InlineTypeReturnedAsFields, false);\n+  }\n+  if (!UseNonAtomicValueFlattening && !UseNullableValueFlattening && !UseAtomicValueFlattening) {\n+    \/\/ Flattening is disabled\n+    FLAG_SET_DEFAULT(UseArrayFlattening, false);\n+    FLAG_SET_DEFAULT(UseFieldFlattening, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+    @IntrinsicCandidate\n@@ -125,0 +126,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/ValueClass.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1058 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @key randomness\n+ * @summary Test support for null markers in (flat) arrays.\n+ * @library \/test\/lib \/\n+ * @requires (os.simpleArch == \"x64\" | os.simpleArch == \"aarch64\")\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+  * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:CompileCommand=dontinline,*::test* -XX:CompileCommand=dontinline,*::check*\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:-MonomorphicArrayCheck -XX:-UseArrayLoadStoreProfile\n+ *                   compiler.valhalla.inlinetypes.TestArrayNullMarkers\n+ *\/\n+\n+public class TestArrayNullMarkers {\n+\n+    private static final WhiteBox WHITEBOX = WhiteBox.getWhiteBox();\n+    private static final boolean UseArrayFlattening = WHITEBOX.getBooleanVMFlag(\"UseArrayFlattening\");\n+    private static final boolean UseNullableValueFlattening = WHITEBOX.getBooleanVMFlag(\"UseNullableValueFlattening\");\n+    private static final boolean UseNonAtomicValueFlattening = WHITEBOX.getBooleanVMFlag(\"UseNonAtomicValueFlattening\");\n+    private static final boolean UseAtomicValueFlattening = WHITEBOX.getBooleanVMFlag(\"UseAtomicValueFlattening\");\n+\n+    \/\/ Is naturally atomic and has null-free, non-atomic, flat (1 bytes), null-free, atomic, flat (1 bytes) and nullable, atomic, flat (4 bytes) layouts\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class OneByte {\n+        byte b;\n+\n+        public OneByte(byte b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    \/\/ Has null-free, non-atomic, flat (2 bytes), null-free, atomic, flat (2 bytes) and nullable, atomic, flat (4 bytes) layouts\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TwoBytes {\n+        byte b1;\n+        byte b2;\n+\n+        public TwoBytes(byte b1, byte b2) {\n+            this.b1 = b1;\n+            this.b2 = b2;\n+        }\n+    }\n+\n+    \/\/ Has null-free, non-atomic, flat (4 bytes), null-free, atomic, flat (4 bytes) and nullable, atomic, flat (8 bytes) layouts\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TwoShorts {\n+        short s1;\n+        short s2;\n+\n+        public TwoShorts(short s1, short s2) {\n+            this.s1 = s1;\n+            this.s2 = s2;\n+        }\n+    }\n+\n+    \/\/ Has null-free, non-atomic flat (8 bytes) and null-free, atomic, flat (8 bytes) layouts\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TwoInts {\n+        int i1;\n+        int i2;\n+\n+        public TwoInts(int i1, int i2) {\n+            this.i1 = i1;\n+            this.i2 = i2;\n+        }\n+    }\n+\n+    \/\/ Has null-free, non-atomic flat (16 bytes) layout\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TwoLongs {\n+        long l1;\n+        long l2;\n+\n+        public TwoLongs(int l1, int l2) {\n+            this.l1 = l1;\n+            this.l2 = l2;\n+        }\n+    }\n+\n+    \/\/ Has null-free, non-atomic, flat (5 bytes), null-free, atomic, flat (8 bytes) and nullable, atomic, flat (8 bytes) layouts\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ByteAndOop {\n+        byte b;\n+        MyClass obj;\n+\n+        public ByteAndOop(byte b, MyClass obj) {\n+            this.b = b;\n+            this.obj = obj;\n+        }\n+    }\n+\n+    static class MyClass {\n+        int x;\n+\n+        public MyClass(int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    public static void testWrite0(OneByte[] array, int i, OneByte val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite1(TwoBytes[] array, int i, TwoBytes val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite2(TwoShorts[] array, int i, TwoShorts val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite3(TwoInts[] array, int i, TwoInts val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite4(TwoLongs[] array, int i, TwoLongs val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite5(ByteAndOop[] array, int i, ByteAndOop val) {\n+        array[i] = val;\n+    }\n+\n+    public static void testWrite6(Object[] array, int i, Object val) {\n+        array[i] = val;\n+    }\n+\n+    public static OneByte testRead0(OneByte[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoBytes testRead1(TwoBytes[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoShorts testRead2(TwoShorts[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoInts testRead3(TwoInts[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static TwoLongs testRead4(TwoLongs[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static ByteAndOop testRead5(ByteAndOop[] array, int i) {\n+        return array[i];\n+    }\n+\n+    public static Object testRead6(Object[] array, int i) {\n+        return array[i];\n+    }\n+\n+    static final OneByte CANARY0 = new OneByte((byte)42);\n+\n+    public static void checkCanary0(OneByte[] array) {\n+        Asserts.assertEQ(array[0], CANARY0);\n+        Asserts.assertEQ(array[2], CANARY0);\n+    }\n+\n+    static final TwoBytes CANARY1 = new TwoBytes((byte)42, (byte)42);\n+\n+    public static void checkCanary1(TwoBytes[] array) {\n+        Asserts.assertEQ(array[0], CANARY1);\n+        Asserts.assertEQ(array[2], CANARY1);\n+    }\n+\n+    static final TwoShorts CANARY2 = new TwoShorts((short)42, (short)42);\n+\n+    public static void checkCanary2(TwoShorts[] array) {\n+        Asserts.assertEQ(array[0], CANARY2);\n+        Asserts.assertEQ(array[2], CANARY2);\n+    }\n+\n+    static final TwoInts CANARY3 = new TwoInts(42, 42);\n+\n+    public static void checkCanary3(TwoInts[] array) {\n+        Asserts.assertEQ(array[0], CANARY3);\n+        Asserts.assertEQ(array[2], CANARY3);\n+    }\n+\n+    static final TwoLongs CANARY4 = new TwoLongs(42, 42);\n+\n+    public static void checkCanary4(TwoLongs[] array) {\n+        Asserts.assertEQ(array[0], CANARY4);\n+        Asserts.assertEQ(array[2], CANARY4);\n+    }\n+\n+    static final ByteAndOop CANARY5 = new ByteAndOop((byte)42, new MyClass(42));\n+\n+    public static void checkCanary5(ByteAndOop[] array) {\n+        Asserts.assertEQ(array[0], CANARY5);\n+        Asserts.assertEQ(array[2], CANARY5);\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedArrayIntrinsic(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeArray = (TwoBytes[])ValueClass.newNullRestrictedArray(TwoBytes.class, size);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeArray), UseArrayFlattening && UseNonAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeArray));\n+        Asserts.assertEquals(nullFreeArray[idx], new TwoBytes((byte)0, (byte)0));\n+        testWrite1(nullFreeArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeArray, idx), val);\n+        return nullFreeArray;\n+    }\n+\n+    public static TwoBytes[] testNullRestrictedAtomicArrayIntrinsic(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullFreeAtomicArray = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, size);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullFreeAtomicArray), UseArrayFlattening && UseAtomicValueFlattening);\n+        Asserts.assertTrue(ValueClass.isNullRestrictedArray(nullFreeAtomicArray));\n+        Asserts.assertEquals(nullFreeAtomicArray[idx], new TwoBytes((byte)0, (byte)0));\n+        testWrite1(nullFreeAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullFreeAtomicArray, idx), val);\n+        return nullFreeAtomicArray;\n+    }\n+\n+    public static TwoBytes[] testNullableAtomicArrayIntrinsic(int size, int idx, TwoBytes val) {\n+        TwoBytes[] nullableAtomicArray = (TwoBytes[])ValueClass.newNullableAtomicArray(TwoBytes.class, size);\n+        Asserts.assertEquals(ValueClass.isFlatArray(nullableAtomicArray), UseArrayFlattening && UseNullableValueFlattening);\n+        Asserts.assertFalse(ValueClass.isNullRestrictedArray(nullableAtomicArray));\n+        Asserts.assertEquals(nullableAtomicArray[idx], null);\n+        testWrite1(nullableAtomicArray, idx, val);\n+        Asserts.assertEQ(testRead1(nullableAtomicArray, idx), val);\n+        return nullableAtomicArray;\n+    }\n+\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class ValueHolder1 {\n+        TwoBytes val;\n+\n+        public ValueHolder1(TwoBytes val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    \/\/ Test support for replaced arrays\n+    public static void testScalarReplacement1(boolean trap) {\n+        OneByte[] nullFreeArray = (OneByte[])ValueClass.newNullRestrictedArray(OneByte.class, 1);\n+        OneByte val = new OneByte((byte)42);\n+        nullFreeArray[0] = val;\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeArray[0], val);\n+        }\n+\n+        OneByte[] nullFreeAtomicArray = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 1);\n+        nullFreeAtomicArray[0] = val;\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeAtomicArray[0], val);\n+        }\n+\n+        OneByte[] nullableAtomicArray = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 2);\n+        nullableAtomicArray[0] = val;\n+        nullableAtomicArray[1] = null;\n+        if (trap) {\n+            Asserts.assertEQ(nullableAtomicArray[0], val);\n+            Asserts.assertEQ(nullableAtomicArray[1], null);\n+        }\n+\n+        OneByte[] nullableArray = new OneByte[2];\n+        nullableArray[0] = val;\n+        nullableArray[1] = null;\n+        if (trap) {\n+            Asserts.assertEQ(nullableArray[0], val);\n+            Asserts.assertEQ(nullableArray[1], null);\n+        }\n+    }\n+\n+    \/\/ Test support for scalar replaced arrays\n+    public static void testScalarReplacement2(boolean trap) {\n+        ValueHolder1[] nullFreeArray = (ValueHolder1[])ValueClass.newNullRestrictedArray(ValueHolder1.class, 1);\n+        TwoBytes val = new TwoBytes((byte)42, (byte)43);\n+        nullFreeArray[0] = new ValueHolder1(val);\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeArray[0].val, val);\n+        }\n+\n+        ValueHolder1[] nullFreeAtomicArray = (ValueHolder1[])ValueClass.newNullRestrictedAtomicArray(ValueHolder1.class, 1);\n+        nullFreeAtomicArray[0] = new ValueHolder1(val);\n+        if (trap) {\n+            Asserts.assertEQ(nullFreeAtomicArray[0].val, val);\n+        }\n+\n+        ValueHolder1[] nullableAtomicArray = (ValueHolder1[])ValueClass.newNullableAtomicArray(ValueHolder1.class, 2);\n+        nullableAtomicArray[0] = new ValueHolder1(val);\n+        nullableAtomicArray[1] = new ValueHolder1(null);\n+        if (trap) {\n+            Asserts.assertEQ(nullableAtomicArray[0].val, val);\n+            Asserts.assertEQ(nullableAtomicArray[1].val, null);\n+        }\n+\n+        ValueHolder1[] nullableArray = new ValueHolder1[2];\n+        nullableArray[0] = new ValueHolder1(val);\n+        nullableArray[1] = new ValueHolder1(null);\n+        if (trap) {\n+            Asserts.assertEQ(nullableArray[0].val, val);\n+            Asserts.assertEQ(nullableArray[1].val, null);\n+        }\n+    }\n+\n+    static void produceGarbage() {\n+        for (int i = 0; i < 100; ++i) {\n+            Object[] arrays = new Object[1024];\n+            for (int j = 0; j < arrays.length; j++) {\n+                arrays[j] = new int[1024];\n+            }\n+        }\n+        System.gc();\n+    }\n+\n+    static TwoShorts[] array1 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 1);\n+    static TwoShorts[] array2 = (TwoShorts[])ValueClass.newNullableAtomicArray(TwoShorts.class, 1);\n+    static {\n+        array2[0] = new TwoShorts((short)0, (short)0);\n+    }\n+    static TwoShorts[] array3 = new TwoShorts[] { new TwoShorts((short)0, (short)0) };\n+\n+    \/\/ Catches an issue with type speculation based on profiling\n+    public static void testProfiling() {\n+        array1[0] = new TwoShorts(array1[0].s1, (short)0);\n+        array2[0] = new TwoShorts(array2[0].s1, (short)0);\n+        array3[0] = new TwoShorts(array3[0].s1, (short)0);\n+    }\n+\n+    static final OneByte[] NULL_FREE_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedArray(OneByte.class, 2);\n+    static final OneByte[] NULL_FREE_ATOMIC_ARRAY_0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 2);\n+    static final OneByte[] NULLABLE_ARRAY_0 = new OneByte[2];\n+    static final OneByte[] NULLABLE_ATOMIC_ARRAY_0 = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 2);\n+\n+    static final TwoBytes[] NULL_FREE_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedArray(TwoBytes.class, 2);\n+    static final TwoBytes[] NULL_FREE_ATOMIC_ARRAY_1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 2);\n+    static final TwoBytes[] NULLABLE_ARRAY_1 = new TwoBytes[2];\n+    static final TwoBytes[] NULLABLE_ATOMIC_ARRAY_1 = (TwoBytes[])ValueClass.newNullableAtomicArray(TwoBytes.class, 2);\n+\n+    static final TwoShorts[] NULL_FREE_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedArray(TwoShorts.class, 2);\n+    static final TwoShorts[] NULL_FREE_ATOMIC_ARRAY_2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 2);\n+    static final TwoShorts[] NULLABLE_ARRAY_2 = new TwoShorts[2];\n+    static final TwoShorts[] NULLABLE_ATOMIC_ARRAY_2 = (TwoShorts[])ValueClass.newNullableAtomicArray(TwoShorts.class, 2);\n+\n+    static final TwoInts[] NULL_FREE_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedArray(TwoInts.class, 1);\n+    static final TwoInts[] NULL_FREE_ATOMIC_ARRAY_3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 1);\n+    static final TwoInts[] NULLABLE_ARRAY_3 = new TwoInts[1];\n+    static final TwoInts[] NULLABLE_ATOMIC_ARRAY_3 = (TwoInts[])ValueClass.newNullableAtomicArray(TwoInts.class, 1);\n+\n+    static final TwoLongs[] NULL_FREE_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedArray(TwoLongs.class, 1);\n+    static final TwoLongs[] NULL_FREE_ATOMIC_ARRAY_4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 1);\n+    static final TwoLongs[] NULLABLE_ARRAY_4 = new TwoLongs[1];\n+    static final TwoLongs[] NULLABLE_ATOMIC_ARRAY_4 = (TwoLongs[])ValueClass.newNullableAtomicArray(TwoLongs.class, 1);\n+\n+    static final ByteAndOop[] NULL_FREE_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedArray(ByteAndOop.class, 1);\n+    static final ByteAndOop[] NULL_FREE_ATOMIC_ARRAY_5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 1);\n+    static final ByteAndOop[] NULLABLE_ARRAY_5 = new ByteAndOop[1];\n+    static final ByteAndOop[] NULLABLE_ATOMIC_ARRAY_5 = (ByteAndOop[])ValueClass.newNullableAtomicArray(ByteAndOop.class, 1);\n+\n+    \/\/ Test access to constant arrays\n+    public static void testConstantArrays(int i) {\n+        OneByte default0 = new OneByte((byte)0);\n+        OneByte val0 = new OneByte((byte)i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_0[0], default0);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_0[0], default0);\n+        Asserts.assertEQ(NULLABLE_ARRAY_0[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_0[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_0[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_0[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_0[0] = val0;\n+        NULL_FREE_ATOMIC_ARRAY_0[0] = val0;\n+        NULLABLE_ARRAY_0[0] = val0;\n+        NULLABLE_ATOMIC_ARRAY_0[0] = val0;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_0[0], val0);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_0[0], val0);\n+        Asserts.assertEQ(NULLABLE_ARRAY_0[0], val0);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_0[0], val0);\n+\n+        NULL_FREE_ARRAY_0[0] = default0;\n+        NULL_FREE_ATOMIC_ARRAY_0[0] = default0;\n+        NULLABLE_ARRAY_0[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_0[0] = null;\n+\n+        TwoBytes default1 = new TwoBytes((byte)0, (byte)0);\n+        TwoBytes val1 = new TwoBytes((byte)i, (byte)i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_1[0], default1);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_1[0], default1);\n+        Asserts.assertEQ(NULLABLE_ARRAY_1[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_1[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_1[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_1[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_1[0] = val1;\n+        NULL_FREE_ATOMIC_ARRAY_1[0] = val1;\n+        NULLABLE_ARRAY_1[0] = val1;\n+        NULLABLE_ATOMIC_ARRAY_1[0] = val1;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_1[0], val1);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_1[0], val1);\n+        Asserts.assertEQ(NULLABLE_ARRAY_1[0], val1);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_1[0], val1);\n+\n+        NULL_FREE_ARRAY_1[0] = default1;\n+        NULL_FREE_ATOMIC_ARRAY_1[0] = default1;\n+        NULLABLE_ARRAY_1[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_1[0] = null;\n+\n+        TwoShorts default2 = new TwoShorts((short)0, (short)0);\n+        TwoShorts val2 = new TwoShorts((short)i, (short)i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_2[0], default2);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_2[0], default2);\n+        Asserts.assertEQ(NULLABLE_ARRAY_2[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_2[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_2[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_2[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_2[0] = val2;\n+        NULL_FREE_ATOMIC_ARRAY_2[0] = val2;\n+        NULLABLE_ARRAY_2[0] = val2;\n+        NULLABLE_ATOMIC_ARRAY_2[0] = val2;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_2[0], val2);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_2[0], val2);\n+        Asserts.assertEQ(NULLABLE_ARRAY_2[0], val2);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_2[0], val2);\n+\n+        NULL_FREE_ARRAY_2[0] = default2;\n+        NULL_FREE_ATOMIC_ARRAY_2[0] = default2;\n+        NULLABLE_ARRAY_2[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_2[0] = null;\n+\n+        TwoInts default3 = new TwoInts(0, 0);\n+        TwoInts val3 = new TwoInts(i, i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_3[0], default3);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_3[0], default3);\n+        Asserts.assertEQ(NULLABLE_ARRAY_3[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_3[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_3[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_3[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_3[0] = val3;\n+        NULL_FREE_ATOMIC_ARRAY_3[0] = val3;\n+        NULLABLE_ARRAY_3[0] = val3;\n+        NULLABLE_ATOMIC_ARRAY_3[0] = val3;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_3[0], val3);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_3[0], val3);\n+        Asserts.assertEQ(NULLABLE_ARRAY_3[0], val3);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_3[0], val3);\n+\n+        NULL_FREE_ARRAY_3[0] = default3;\n+        NULL_FREE_ATOMIC_ARRAY_3[0] = default3;\n+        NULLABLE_ARRAY_3[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_3[0] = null;\n+\n+        TwoLongs default4 = new TwoLongs(0, 0);\n+        TwoLongs val4 = new TwoLongs(i, i);\n+        Asserts.assertEQ(NULL_FREE_ARRAY_4[0], default4);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_4[0], default4);\n+        Asserts.assertEQ(NULLABLE_ARRAY_4[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_4[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_4[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_4[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_4[0] = val4;\n+        NULL_FREE_ATOMIC_ARRAY_4[0] = val4;\n+        NULLABLE_ARRAY_4[0] = val4;\n+        NULLABLE_ATOMIC_ARRAY_4[0] = val4;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_4[0], val4);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_4[0], val4);\n+        Asserts.assertEQ(NULLABLE_ARRAY_4[0], val4);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_4[0], val4);\n+\n+        NULL_FREE_ARRAY_4[0] = default4;\n+        NULL_FREE_ATOMIC_ARRAY_4[0] = default4;\n+        NULLABLE_ARRAY_4[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_4[0] = null;\n+\n+        ByteAndOop default5 = new ByteAndOop((byte)0, null);\n+        ByteAndOop val5 = new ByteAndOop((byte)i, new MyClass(i));\n+        Asserts.assertEQ(NULL_FREE_ARRAY_5[0], default5);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_5[0], default5);\n+        Asserts.assertEQ(NULLABLE_ARRAY_5[0], null);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_5[0], null);\n+\n+        try {\n+            NULL_FREE_ARRAY_5[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            NULL_FREE_ATOMIC_ARRAY_5[0] = null;\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        NULL_FREE_ARRAY_5[0] = val5;\n+        NULL_FREE_ATOMIC_ARRAY_5[0] = val5;\n+        NULLABLE_ARRAY_5[0] = val5;\n+        NULLABLE_ATOMIC_ARRAY_5[0] = val5;\n+\n+        Asserts.assertEQ(NULL_FREE_ARRAY_5[0], val5);\n+        Asserts.assertEQ(NULL_FREE_ATOMIC_ARRAY_5[0], val5);\n+        Asserts.assertEQ(NULLABLE_ARRAY_5[0], val5);\n+        Asserts.assertEQ(NULLABLE_ATOMIC_ARRAY_5[0], val5);\n+\n+        NULL_FREE_ARRAY_5[0] = default5;\n+        NULL_FREE_ATOMIC_ARRAY_5[0] = default5;\n+        NULLABLE_ARRAY_5[0] = null;\n+        NULLABLE_ATOMIC_ARRAY_5[0] = null;\n+    }\n+\n+    \/\/ Test correct wiring of memory for flat accesses\n+    public static OneByte testMemoryEffects0() {\n+        NULLABLE_ARRAY_0[1] = CANARY0;\n+        NULLABLE_ATOMIC_ARRAY_0[1] = CANARY0;\n+        return NULLABLE_ARRAY_0[1];\n+    }\n+\n+    public static TwoBytes testMemoryEffects1() {\n+        NULLABLE_ARRAY_1[1] = CANARY1;\n+        NULLABLE_ATOMIC_ARRAY_1[1] = CANARY1;\n+        return NULLABLE_ARRAY_1[1];\n+    }\n+\n+    public static TwoShorts testMemoryEffects2() {\n+        NULLABLE_ARRAY_2[1] = CANARY2;\n+        NULLABLE_ATOMIC_ARRAY_2[1] = CANARY2;\n+        return NULLABLE_ARRAY_2[1];\n+    }\n+\n+    public static void main(String[] args) {\n+        OneByte[] nullFreeArray0 = (OneByte[])ValueClass.newNullRestrictedArray(OneByte.class, 3);\n+        OneByte[] nullFreeAtomicArray0 = (OneByte[])ValueClass.newNullRestrictedAtomicArray(OneByte.class, 3);\n+        OneByte[] nullableArray0 = new OneByte[3];\n+        OneByte[] nullableAtomicArray0 = (OneByte[])ValueClass.newNullableAtomicArray(OneByte.class, 3);\n+\n+        TwoBytes[] nullFreeArray1 = (TwoBytes[])ValueClass.newNullRestrictedArray(TwoBytes.class, 3);\n+        TwoBytes[] nullFreeAtomicArray1 = (TwoBytes[])ValueClass.newNullRestrictedAtomicArray(TwoBytes.class, 3);\n+        TwoBytes[] nullableArray1 = new TwoBytes[3];\n+        TwoBytes[] nullableAtomicArray1 = (TwoBytes[])ValueClass.newNullableAtomicArray(TwoBytes.class, 3);\n+\n+        TwoShorts[] nullFreeArray2 = (TwoShorts[])ValueClass.newNullRestrictedArray(TwoShorts.class, 3);\n+        TwoShorts[] nullFreeAtomicArray2 = (TwoShorts[])ValueClass.newNullRestrictedAtomicArray(TwoShorts.class, 3);\n+        TwoShorts[] nullableArray2 = new TwoShorts[3];\n+        TwoShorts[] nullableAtomicArray2 = (TwoShorts[])ValueClass.newNullableAtomicArray(TwoShorts.class, 3);\n+\n+        TwoInts[] nullFreeArray3 = (TwoInts[])ValueClass.newNullRestrictedArray(TwoInts.class, 3);\n+        TwoInts[] nullFreeAtomicArray3 = (TwoInts[])ValueClass.newNullRestrictedAtomicArray(TwoInts.class, 3);\n+        TwoInts[] nullableArray3 = new TwoInts[3];\n+        TwoInts[] nullableAtomicArray3 = (TwoInts[])ValueClass.newNullableAtomicArray(TwoInts.class, 3);\n+\n+        TwoLongs[] nullFreeArray4 = (TwoLongs[])ValueClass.newNullRestrictedArray(TwoLongs.class, 3);\n+        TwoLongs[] nullFreeAtomicArray4 = (TwoLongs[])ValueClass.newNullRestrictedAtomicArray(TwoLongs.class, 3);\n+        TwoLongs[] nullableArray4 = new TwoLongs[3];\n+        TwoLongs[] nullableAtomicArray4 = (TwoLongs[])ValueClass.newNullableAtomicArray(TwoLongs.class, 3);\n+\n+        ByteAndOop[] nullFreeArray5 = (ByteAndOop[])ValueClass.newNullRestrictedArray(ByteAndOop.class, 3);\n+        ByteAndOop[] nullFreeAtomicArray5 = (ByteAndOop[])ValueClass.newNullRestrictedAtomicArray(ByteAndOop.class, 3);\n+        ByteAndOop[] nullableArray5 = new ByteAndOop[3];\n+        ByteAndOop[] nullableAtomicArray5 = (ByteAndOop[])ValueClass.newNullableAtomicArray(ByteAndOop.class, 3);\n+\n+        \/\/ Write canary values to detect out of bound writes\n+        nullFreeArray0[0] = CANARY0;\n+        nullFreeArray0[2] = CANARY0;\n+        nullFreeAtomicArray0[0] = CANARY0;\n+        nullFreeAtomicArray0[2] = CANARY0;\n+        nullableArray0[0] = CANARY0;\n+        nullableArray0[2] = CANARY0;\n+        nullableAtomicArray0[0] = CANARY0;\n+        nullableAtomicArray0[2] = CANARY0;\n+\n+        nullFreeArray1[0] = CANARY1;\n+        nullFreeArray1[2] = CANARY1;\n+        nullFreeAtomicArray1[0] = CANARY1;\n+        nullFreeAtomicArray1[2] = CANARY1;\n+        nullableArray1[0] = CANARY1;\n+        nullableArray1[2] = CANARY1;\n+        nullableAtomicArray1[0] = CANARY1;\n+        nullableAtomicArray1[2] = CANARY1;\n+\n+        nullFreeArray2[0] = CANARY2;\n+        nullFreeArray2[2] = CANARY2;\n+        nullFreeAtomicArray2[0] = CANARY2;\n+        nullFreeAtomicArray2[2] = CANARY2;\n+        nullableArray2[0] = CANARY2;\n+        nullableArray2[2] = CANARY2;\n+        nullableAtomicArray2[0] = CANARY2;\n+        nullableAtomicArray2[2] = CANARY2;\n+\n+        nullFreeArray3[0] = CANARY3;\n+        nullFreeArray3[2] = CANARY3;\n+        nullFreeAtomicArray3[0] = CANARY3;\n+        nullFreeAtomicArray3[2] = CANARY3;\n+        nullableArray3[0] = CANARY3;\n+        nullableArray3[2] = CANARY3;\n+        nullableAtomicArray3[0] = CANARY3;\n+        nullableAtomicArray3[2] = CANARY3;\n+\n+        nullFreeArray4[0] = CANARY4;\n+        nullFreeArray4[2] = CANARY4;\n+        nullFreeAtomicArray4[0] = CANARY4;\n+        nullFreeAtomicArray4[2] = CANARY4;\n+        nullableArray4[0] = CANARY4;\n+        nullableArray4[2] = CANARY4;\n+        nullableAtomicArray4[0] = CANARY4;\n+        nullableAtomicArray4[2] = CANARY4;\n+\n+        nullFreeArray5[0] = CANARY5;\n+        nullFreeArray5[2] = CANARY5;\n+        nullFreeAtomicArray5[0] = CANARY5;\n+        nullFreeAtomicArray5[2] = CANARY5;\n+        nullableArray5[0] = CANARY5;\n+        nullableArray5[2] = CANARY5;\n+        nullableAtomicArray5[0] = CANARY5;\n+        nullableAtomicArray5[2] = CANARY5;\n+\n+        final int LIMIT = 50_000;\n+        for (int i = -50_000; i < LIMIT; ++i) {\n+            OneByte val0 = new OneByte((byte)i);\n+            TwoBytes val1 = new TwoBytes((byte)i, (byte)(i + 1));\n+            TwoShorts val2 = new TwoShorts((short)i, (short)(i + 1));\n+            TwoInts val3 = new TwoInts(i, i + 1);\n+            TwoLongs val4 = new TwoLongs(i, i + 1);\n+\n+            testWrite0(nullFreeArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullFreeArray0, 1), val0);\n+            checkCanary0(nullFreeArray0);\n+\n+            testWrite0(nullFreeAtomicArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullFreeAtomicArray0, 1), val0);\n+            checkCanary0(nullFreeAtomicArray0);\n+\n+            testWrite0(nullableArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullableArray0, 1), val0);\n+            checkCanary0(nullableArray0);\n+            testWrite0(nullableArray0, 1, null);\n+            Asserts.assertEQ(testRead0(nullableArray0, 1), null);\n+            checkCanary0(nullableArray0);\n+\n+            testWrite0(nullableAtomicArray0, 1, val0);\n+            Asserts.assertEQ(testRead0(nullableAtomicArray0, 1), val0);\n+            checkCanary0(nullableAtomicArray0);\n+            testWrite0(nullableAtomicArray0, 1, null);\n+            Asserts.assertEQ(testRead0(nullableAtomicArray0, 1), null);\n+            checkCanary0(nullableAtomicArray0);\n+\n+            testWrite1(nullFreeArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullFreeArray1, 1), val1);\n+            checkCanary1(nullFreeArray1);\n+\n+            testWrite1(nullFreeAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullFreeAtomicArray1, 1), val1);\n+            checkCanary1(nullFreeAtomicArray1);\n+\n+            testWrite1(nullableArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullableArray1, 1), val1);\n+            checkCanary1(nullableArray1);\n+            testWrite1(nullableArray1, 1, null);\n+            Asserts.assertEQ(testRead1(nullableArray1, 1), null);\n+            checkCanary1(nullableArray1);\n+\n+            testWrite1(nullableAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead1(nullableAtomicArray1, 1), val1);\n+            checkCanary1(nullableAtomicArray1);\n+            testWrite1(nullableAtomicArray1, 1, null);\n+            Asserts.assertEQ(testRead1(nullableAtomicArray1, 1), null);\n+            checkCanary1(nullableAtomicArray1);\n+\n+            testWrite2(nullFreeArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullFreeArray2, 1), val2);\n+            checkCanary2(nullFreeArray2);\n+\n+            testWrite2(nullFreeAtomicArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullFreeAtomicArray2, 1), val2);\n+            checkCanary2(nullFreeAtomicArray2);\n+\n+            testWrite2(nullableArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullableArray2, 1), val2);\n+            checkCanary2(nullableArray2);\n+            testWrite2(nullableArray2, 1, null);\n+            Asserts.assertEQ(testRead2(nullableArray2, 1), null);\n+            checkCanary2(nullableArray2);\n+\n+            testWrite2(nullableAtomicArray2, 1, val2);\n+            Asserts.assertEQ(testRead2(nullableAtomicArray2, 1), val2);\n+            checkCanary2(nullableAtomicArray2);\n+            testWrite2(nullableAtomicArray2, 1, null);\n+            Asserts.assertEQ(testRead2(nullableAtomicArray2, 1), null);\n+            checkCanary2(nullableAtomicArray2);\n+\n+            testWrite3(nullFreeArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullFreeArray3, 1), val3);\n+            checkCanary3(nullFreeArray3);\n+\n+            testWrite3(nullFreeAtomicArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullFreeAtomicArray3, 1), val3);\n+            checkCanary3(nullFreeAtomicArray3);\n+\n+            testWrite3(nullableArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullableArray3, 1), val3);\n+            checkCanary3(nullableArray3);\n+            testWrite3(nullableArray3, 1, null);\n+            Asserts.assertEQ(testRead3(nullableArray3, 1), null);\n+            checkCanary3(nullableArray3);\n+\n+            testWrite3(nullableAtomicArray3, 1, val3);\n+            Asserts.assertEQ(testRead3(nullableAtomicArray3, 1), val3);\n+            checkCanary3(nullableAtomicArray3);\n+            testWrite3(nullableAtomicArray3, 1, null);\n+            Asserts.assertEQ(testRead3(nullableAtomicArray3, 1), null);\n+            checkCanary3(nullableAtomicArray3);\n+\n+            testWrite4(nullFreeArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullFreeArray4, 1), val4);\n+            checkCanary4(nullFreeArray4);\n+\n+            testWrite4(nullFreeAtomicArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullFreeAtomicArray4, 1), val4);\n+            checkCanary4(nullFreeAtomicArray4);\n+\n+            testWrite4(nullableArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullableArray4, 1), val4);\n+            checkCanary4(nullableArray4);\n+            testWrite4(nullableArray4, 1, null);\n+            Asserts.assertEQ(testRead4(nullableArray4, 1), null);\n+            checkCanary4(nullableArray4);\n+\n+            testWrite4(nullableAtomicArray4, 1, val4);\n+            Asserts.assertEQ(testRead4(nullableAtomicArray4, 1), val4);\n+            checkCanary4(nullableAtomicArray4);\n+            testWrite4(nullableAtomicArray4, 1, null);\n+            Asserts.assertEQ(testRead4(nullableAtomicArray4, 1), null);\n+            checkCanary4(nullableAtomicArray4);\n+\n+            ByteAndOop val5 = new ByteAndOop((byte)i, new MyClass(i));\n+            testWrite5(nullFreeArray5, 1, val5);\n+            testWrite5(nullFreeAtomicArray5, 1, val5);\n+            testWrite5(nullableArray5, 1, val5);\n+            testWrite5(nullableAtomicArray5, 1, val5);\n+\n+            if (i > (LIMIT - 50)) {\n+                \/\/ After warmup, produce some garbage to trigger GC\n+                produceGarbage();\n+            }\n+\n+            Asserts.assertEQ(testRead5(nullFreeArray5, 1), val5);\n+            checkCanary5(nullFreeArray5);\n+\n+            Asserts.assertEQ(testRead5(nullFreeAtomicArray5, 1), val5);\n+            checkCanary5(nullFreeAtomicArray5);\n+\n+            Asserts.assertEQ(testRead5(nullableArray5, 1), val5);\n+            checkCanary5(nullableArray5);\n+\n+            testWrite5(nullableArray5, 1, null);\n+            Asserts.assertEQ(testRead5(nullableArray5, 1), null);\n+            checkCanary5(nullableArray5);\n+\n+            Asserts.assertEQ(testRead5(nullableAtomicArray5, 1), val5);\n+            checkCanary5(nullableAtomicArray5);\n+\n+            testWrite5(nullableAtomicArray5, 1, null);\n+            Asserts.assertEQ(testRead5(nullableAtomicArray5, 1), null);\n+            checkCanary5(nullableAtomicArray5);\n+\n+            \/\/ Test intrinsics\n+            TwoBytes[] res = testNullRestrictedArrayIntrinsic(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullRestrictedAtomicArrayIntrinsic(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullableAtomicArrayIntrinsic(3, 1, val1);\n+            Asserts.assertEQ(testRead1(res, 1), val1);\n+            res = testNullableAtomicArrayIntrinsic(3, 2, null);\n+            Asserts.assertEQ(testRead1(res, 2), null);\n+\n+            testProfiling();\n+\n+            \/\/ Pollute profile\n+            Object[] objArray = new Object[1];\n+            testWrite6(objArray, 0, objArray);\n+            Asserts.assertEQ(testRead6(objArray, 0), objArray);\n+\n+            testWrite6(nullFreeArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullFreeArray1, 1), val1);\n+            checkCanary1(nullFreeArray1);\n+\n+            testWrite6(nullFreeAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullFreeAtomicArray1, 1), val1);\n+            checkCanary1(nullFreeAtomicArray1);\n+\n+            testWrite6(nullableArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullableArray1, 1), val1);\n+            checkCanary1(nullableArray1);\n+            testWrite6(nullableArray1, 1, null);\n+            Asserts.assertEQ(testRead6(nullableArray1, 1), null);\n+            checkCanary1(nullableArray1);\n+\n+            testWrite6(nullableAtomicArray1, 1, val1);\n+            Asserts.assertEQ(testRead6(nullableAtomicArray1, 1), val1);\n+            checkCanary1(nullableAtomicArray1);\n+            testWrite6(nullableAtomicArray1, 1, null);\n+            Asserts.assertEQ(testRead6(nullableAtomicArray1, 1), null);\n+            checkCanary1(nullableAtomicArray1);\n+\n+            \/\/ Test scalar replacement of array allocations\n+            testScalarReplacement1(false);\n+            testScalarReplacement2(false);\n+\n+            \/\/ Test access to constant arrays\n+            testConstantArrays(i);\n+\n+            \/\/ Test correct wiring of memory for flat accesses\n+            Asserts.assertEQ(testMemoryEffects0(), CANARY0);\n+            Asserts.assertEQ(testMemoryEffects1(), CANARY1);\n+            Asserts.assertEQ(testMemoryEffects2(), CANARY2);\n+        }\n+\n+        try {\n+            testWrite0(nullFreeArray0, 0, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary0(nullFreeArray0);\n+        try {\n+            testWrite0(nullFreeAtomicArray0, 0, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary0(nullFreeAtomicArray0);\n+\n+        try {\n+            testWrite1(nullFreeArray1, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary1(nullFreeArray1);\n+        try {\n+            testWrite1(nullFreeAtomicArray1, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary1(nullFreeAtomicArray1);\n+\n+        try {\n+            testWrite2(nullFreeArray2, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary2(nullFreeArray2);\n+        try {\n+            testWrite2(nullFreeAtomicArray2, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary2(nullFreeAtomicArray2);\n+\n+        try {\n+            testWrite3(nullFreeArray3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary3(nullFreeArray3);\n+        try {\n+            testWrite3(nullFreeAtomicArray3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary3(nullFreeAtomicArray3);\n+\n+        try {\n+            testWrite4(nullFreeArray4, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary4(nullFreeArray4);\n+        try {\n+            testWrite4(nullFreeAtomicArray4, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary4(nullFreeAtomicArray4);\n+\n+        try {\n+            testWrite5(nullFreeArray5, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary5(nullFreeArray5);\n+        try {\n+            testWrite5(nullFreeAtomicArray5, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        checkCanary5(nullFreeAtomicArray5);\n+\n+        \/\/ Test intrinsics\n+        try {\n+            testNullRestrictedArrayIntrinsic(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+        try {\n+            testNullRestrictedAtomicArrayIntrinsic(3, 1, null);\n+            throw new RuntimeException(\"No NPE thrown\");\n+        } catch (NullPointerException e) {\n+            \/\/ Expected\n+        }\n+\n+        testScalarReplacement1(true);\n+        testScalarReplacement2(true);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrayNullMarkers.java","additions":1058,"deletions":0,"binary":false,"changes":1058,"status":"added"},{"patch":"@@ -1882,1 +1882,1 @@\n-    \/\/ Verify that casting an array element to a non-flattenable type marks the array as not-flat\n+    \/\/ Verify that casting an array element to a non-flattenable type marks the array as not flat\n@@ -1903,1 +1903,1 @@\n-    \/\/ Same as test79 but with not-flattenable value class\n+    \/\/ Same as test79 but with not flattenable value class\n@@ -1924,1 +1924,1 @@\n-    \/\/ Verify that writing an object of a non-inline, non-null type to an array marks the array as not-null-free and not-flat\n+    \/\/ Verify that writing an object of a non-inline, non-null type to an array marks the array as not null-free and not flat\n@@ -1954,1 +1954,1 @@\n-    \/\/ Verify that writing an object of a non-flattenable value class to an array marks the array as not-flat\n+    \/\/ Verify that writing an object of a non-flattenable value class to an array marks the array as not flat\n@@ -1984,1 +1984,1 @@\n-    \/\/ Verify that casting an array element to a non-value class type type marks the array as not-null-free and not-flat\n+    \/\/ Verify that casting an array element to a non-value class type type marks the array as not null-free and not flat\n@@ -2007,1 +2007,1 @@\n-    \/\/ Verify that writing constant null into an array marks the array as not-null-free and not-flat\n+    \/\/ Verify that writing constant null into an array marks the array as not null-free\n@@ -2009,2 +2009,8 @@\n-    @IR(failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n-        counts = {INLINE_ARRAY_NULL_GUARD, \"= 1\"})\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        failOn = {ALLOC_G, ALLOCA_G},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 1\", \/\/ Null check on first store, no check on second store\n+                  STORE_UNKNOWN_INLINE, \"= 2\",\n+                  LOAD_UNKNOWN_INLINE, \"= 1\"})\n+    @IR(applyIf = {\"UseArrayFlattening\", \"false\"},\n+        failOn = {ALLOC_G, ALLOCA_G, STORE_UNKNOWN_INLINE, LOAD_UNKNOWN_INLINE},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 1\"}) \/\/ Null check on first store, no check on second store\n@@ -2038,1 +2044,1 @@\n-    \/\/ Same as test84 but with branches\n+    \/\/ Similar to test84 but with branches\n@@ -2040,1 +2046,6 @@\n-    @IR(failOn = {ALLOC_G, ALLOCA_G, LOAD_UNKNOWN_INLINE, STORE_UNKNOWN_INLINE},\n+    @IR(applyIf = {\"UseArrayFlattening\", \"true\"},\n+        failOn = {ALLOC_G, ALLOCA_G},\n+        counts = {INLINE_ARRAY_NULL_GUARD, \"= 2\",\n+                  STORE_UNKNOWN_INLINE, \"<= 3\"})\n+    @IR(applyIf = {\"UseArrayFlattening\", \"false\"},\n+        failOn = {ALLOC_G, ALLOCA_G, STORE_UNKNOWN_INLINE, LOAD_UNKNOWN_INLINE},\n@@ -2075,1 +2086,1 @@\n-    \/\/ Same as test85 but with not-flattenable value class array\n+    \/\/ Same as test85 but with not flattenable value class array\n@@ -2632,1 +2643,2 @@\n-    @IR(failOn = INTRINSIC_SLOW_PATH)\n+    \/\/ TODO 8350865 Re-enable\n+    \/\/ @IR(failOn = INTRINSIC_SLOW_PATH)\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestArrays.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,199 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.valhalla.inlinetypes;\n-\n-import java.lang.invoke.*;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.internal.misc.Unsafe;\n-\n-import jdk.internal.value.ValueClass;\n-import jdk.internal.vm.annotation.ImplicitlyConstructible;\n-import jdk.internal.vm.annotation.LooselyConsistentValue;\n-import jdk.internal.vm.annotation.NullRestricted;\n-\n-\/**\n- * @test TestBufferTearing\n- * @key randomness\n- * @summary Detect tearing on value class buffer writes due to missing barriers.\n- * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- *          java.base\/jdk.internal.value\n- *          java.base\/jdk.internal.vm.annotation\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- *\n- * @run main\/othervm -XX:+UseNullableValueFlattening\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:+UseNullableValueFlattening\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:+UseNullableValueFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- * @run main\/othervm -XX:+UseNullableValueFlattening\n- *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n- *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n- *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n- *                   compiler.valhalla.inlinetypes.TestBufferTearing\n- *\/\n-\n-@ImplicitlyConstructible\n-@LooselyConsistentValue\n-value class MyValue {\n-    \/\/ Make sure the payload size is <= 64-bit to enable flattening\n-    short x;\n-    short y;\n-\n-    private static final Unsafe U = Unsafe.getUnsafe();\n-    private static final long X_OFFSET;\n-    private static final long Y_OFFSET;\n-    static {\n-        try {\n-            Field xField = MyValue.class.getDeclaredField(\"x\");\n-            X_OFFSET = U.objectFieldOffset(xField);\n-            Field yField = MyValue.class.getDeclaredField(\"y\");\n-            Y_OFFSET = U.objectFieldOffset(yField);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    MyValue(short x, short y) {\n-        this.x = x;\n-        this.y = y;\n-    }\n-\n-    MyValue incrementAndCheck() {\n-        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n-        return new MyValue((short)(x + 1), (short)(y + 1));\n-    }\n-\n-    MyValue incrementAndCheckUnsafe() {\n-        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n-        MyValue vt = U.makePrivateBuffer(this);\n-        U.putShort(vt, X_OFFSET, (short)(x + 1));\n-        U.putShort(vt, Y_OFFSET, (short)(y + 1));\n-        return U.finishPrivateBuffer(vt);\n-    }\n-}\n-\n-public class TestBufferTearing {\n-    \/\/ Null-free, volatile -> atomic access\n-    @NullRestricted\n-    volatile static MyValue field1;\n-    @NullRestricted\n-    volatile MyValue field2;\n-\n-    \/\/ Nullable fields are always atomic\n-    static MyValue field3 = new MyValue((short)0, (short)0);\n-    MyValue field4 = new MyValue((short)0, (short)0);\n-\n-    MyValue[] array1 = (MyValue[])ValueClass.newNullRestrictedArray(MyValue.class, 1);\n-    MyValue[] array2 = new MyValue[] { new MyValue((short)0, (short)0) };\n-\n-    static final MethodHandle incrementAndCheck_mh;\n-\n-    static {\n-        try {\n-            Class<?> clazz = MyValue.class;\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-\n-            MethodType mt = MethodType.methodType(MyValue.class);\n-            incrementAndCheck_mh = lookup.findVirtual(clazz, \"incrementAndCheck\", mt);\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Method handle lookup failed\");\n-        }\n-    }\n-\n-    static class Runner extends Thread {\n-        TestBufferTearing test;\n-\n-        public Runner(TestBufferTearing test) {\n-            this.test = test;\n-        }\n-\n-        public void run() {\n-            for (int i = 0; i < 1_000_000; ++i) {\n-                test.field1 = test.field1.incrementAndCheck();\n-                test.field2 = test.field2.incrementAndCheck();\n-                test.field3 = test.field3.incrementAndCheck();\n-                test.field4 = test.field4.incrementAndCheck();\n-                \/\/ TODO 8341767 Re-enable once we support flat array element accesses\n-                \/\/test.array1[0] = test.array1[0].incrementAndCheck();\n-                \/\/test.array2[0] = test.array2[0].incrementAndCheck();\n-\n-                test.field1 = test.field1.incrementAndCheckUnsafe();\n-                test.field2 = test.field2.incrementAndCheckUnsafe();\n-                test.field3 = test.field3.incrementAndCheckUnsafe();\n-                test.field4 = test.field4.incrementAndCheckUnsafe();\n-                \/\/test.array1[0] = test.array1[0].incrementAndCheckUnsafe();\n-                \/\/test.array2[0] = test.array2[0].incrementAndCheckUnsafe();\n-                try {\n-                    test.field1 = (MyValue)incrementAndCheck_mh.invokeExact(test.field1);\n-                    test.field2 = (MyValue)incrementAndCheck_mh.invokeExact(test.field2);\n-                    test.field3 = (MyValue)incrementAndCheck_mh.invokeExact(test.field1);\n-                    test.field4 = (MyValue)incrementAndCheck_mh.invokeExact(test.field2);\n-                    \/\/test.array1[0] = (MyValue)incrementAndCheck_mh.invokeExact(test.array1[0]);\n-                    \/\/test.array2[0] = (MyValue)incrementAndCheck_mh.invokeExact(test.array2[0]);\n-                } catch (Throwable t) {\n-                    throw new RuntimeException(\"Test failed\", t);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Create threads that concurrently update some value class (array) fields\n-        \/\/ and check the fields of the value classes for consistency to detect tearing.\n-        TestBufferTearing test = new TestBufferTearing();\n-        Thread runner = null;\n-        for (int i = 0; i < 10; ++i) {\n-            runner = new Runner(test);\n-            runner.start();\n-        }\n-        runner.join();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBufferTearing.java","additions":0,"deletions":199,"binary":false,"changes":199,"status":"deleted"},{"patch":"@@ -43,1 +43,11 @@\n- * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm -Xbatch -XX:-UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:-UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n@@ -45,0 +55,5 @@\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:-UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ * @run main\/othervm -Xbatch -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening -XX:+UseNonAtomicValueFlattening\n+ *                   compiler.valhalla.inlinetypes.TestFieldNullMarkers\n+ *\n@@ -376,0 +391,104 @@\n+    \/\/ Using two bytes such that null-free fields will not be naturally atomic\n+    @ImplicitlyConstructible\n+    @LooselyConsistentValue\n+    static value class TwoBytes {\n+        byte b1;\n+        byte b2;\n+\n+        public TwoBytes(byte b1, byte b2) {\n+            this.b1 = b1;\n+            this.b2 = b2;\n+        }\n+    }\n+\n+    static private final MyValue8 CANARY_VALUE = new MyValue8((byte)42);\n+\n+    public static class Cage1 {\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        @NullRestricted\n+        volatile TwoBytes field;\n+\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    public static class Cage2 {\n+        @NullRestricted\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        @NullRestricted\n+        volatile TwoBytes field;\n+\n+        @NullRestricted\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    public static class Cage3 {\n+        @NullRestricted\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        volatile TwoBytes field;\n+\n+        @NullRestricted\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    public static class Cage4 {\n+        MyValue8 canary1 = CANARY_VALUE;\n+\n+        volatile TwoBytes field;\n+\n+        MyValue8 canary2 = CANARY_VALUE;\n+\n+        public void verify(TwoBytes val) {\n+            Asserts.assertEQ(canary1, CANARY_VALUE);\n+            Asserts.assertEQ(field, val);\n+            Asserts.assertEQ(canary2, CANARY_VALUE);\n+        }\n+    }\n+\n+    static final Cage1 canaryCage1 = new Cage1();\n+    static final Cage2 canaryCage2 = new Cage2();\n+    static final Cage3 canaryCage3 = new Cage3();\n+    static final Cage4 canaryCage4 = new Cage4();\n+\n+    \/\/ Check that the canary values are not accidentally overwritten\n+    public void testOutOfBoundsAccess(int i) {\n+        TwoBytes val = new TwoBytes((byte)i, (byte)(i+1));\n+        canaryCage1.field = val;\n+        canaryCage1.verify(val);\n+\n+        canaryCage2.field = val;\n+        canaryCage2.verify(val);\n+\n+        canaryCage3.field = val;\n+        canaryCage3.verify(val);\n+\n+        canaryCage3.field = null;\n+        canaryCage3.verify(null);\n+\n+        canaryCage4.field = val;\n+        canaryCage4.verify(val);\n+\n+        canaryCage4.field = null;\n+        canaryCage4.verify(null);\n+    }\n+\n@@ -559,22 +678,0 @@\n-    @ImplicitlyConstructible\n-    @LooselyConsistentValue\n-    static value class MyHolderClass8 {\n-        MyValue8 val8;\n-\n-        public MyHolderClass8(MyValue8 val8) {\n-            this.val8 = val8;\n-        }\n-    }\n-\n-    \/\/ Test support for null markers in scalar replaced flat (null-free) array\n-    public static void testFlatArray1(boolean trap) {\n-        MyHolderClass8[] array = (MyHolderClass8[])ValueClass.newNullRestrictedArray(MyHolderClass8.class, 2);\n-        MyValue8 val8 = new MyValue8((byte)42);\n-        array[0] = new MyHolderClass8(val8);\n-        array[1] = new MyHolderClass8(null);\n-        if (trap) {\n-            Asserts.assertEQ(array[0].val8, val8);\n-            Asserts.assertEQ(array[1].val8, null);\n-        }\n-    }\n-\n@@ -646,0 +743,36 @@\n+    public static class MyHolderClass9 {\n+        @NullRestricted\n+        TwoBytes field1;\n+\n+        TwoBytes field2;\n+\n+        @NullRestricted\n+        volatile TwoBytes field3;\n+\n+        volatile TwoBytes field4;\n+    }\n+\n+    static final MyHolderClass9 constantHolder = new MyHolderClass9();\n+\n+    \/\/ Test loading a flat field from a constant container (should not be constant folded because fields are immutable)\n+    public void testLoadingFromConstantHolder(int i) {\n+        TwoBytes val = new TwoBytes((byte)i, (byte)(i + 1));\n+        constantHolder.field1 = val;\n+        Asserts.assertEQ(constantHolder.field1, val);\n+\n+        constantHolder.field2 = val;\n+        Asserts.assertEQ(constantHolder.field2, val);\n+\n+        constantHolder.field2 = null;\n+        Asserts.assertEQ(constantHolder.field2, null);\n+\n+        constantHolder.field3 = val;\n+        Asserts.assertEQ(constantHolder.field3, val);\n+\n+        constantHolder.field4 = val;\n+        Asserts.assertEQ(constantHolder.field4, val);\n+\n+        constantHolder.field4 = null;\n+        Asserts.assertEQ(constantHolder.field4, null);\n+    }\n+\n@@ -839,3 +972,0 @@\n-            \/\/ Test flat (null-free) arrays\n-            testFlatArray1(false);\n-\n@@ -971,0 +1101,5 @@\n+\n+            t.testLoadingFromConstantHolder(i);\n+\n+            \/\/ Verify that no out of bounds accesses happen\n+            t.testOutOfBoundsAccess(i);\n@@ -994,2 +1129,0 @@\n-\n-        testFlatArray1(true);\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFieldNullMarkers.java","additions":161,"deletions":28,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        \/\/ TODO 8350865 Scenarios are equivalent, FlatArrayElementMaxSize does not exist anymore\n@@ -161,0 +162,1 @@\n+    \/\/ TODO 8350865 FlatArrayElementMaxSize does not exist anymore\n@@ -273,0 +275,1 @@\n+    \/\/ TODO 8350865 FlatArrayElementMaxSize does not exist anymore\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestFlatInArraysFolding.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @summary VM option \"InlineFieldMaxFlatSize\" does not work well.\n+ * @summary VM option \"UseFieldFlattening\" does not work well.\n@@ -88,2 +88,1 @@\n-    \/\/ TODO: Fails after JDK-8345995\n-    \/\/@IR(counts = {IRNode.LOAD_N, \"2\"})\n+    @IR(counts = {IRNode.LOAD_N, \"2\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestInlineFieldNonFlattened.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4551,0 +4551,1 @@\n+    \/\/ TODO 8350865 We need more copies of these tests for all ValueClass array factories\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorld.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+        counts = {NULL_CHECK_TRAP, \"= 2\", STORE_UNKNOWN_INLINE, \"= 1\"})\n@@ -507,1 +507,1 @@\n-        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+        counts = {NULL_CHECK_TRAP, \"= 2\", STORE_UNKNOWN_INLINE, \"= 1\"})\n@@ -530,1 +530,1 @@\n-        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+        counts = {NULL_CHECK_TRAP, \"= 2\", STORE_UNKNOWN_INLINE, \"= 1\"})\n@@ -553,1 +553,1 @@\n-        counts = {NULL_CHECK_TRAP, \"= 3\", STORE_UNKNOWN_INLINE, \"= 1\"})\n+        counts = {NULL_CHECK_TRAP, \"= 2\", STORE_UNKNOWN_INLINE, \"= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- *                   -XX:+SafepointALot -XX:-TieredCompilation TestSafepointAtPollReturn\n+ *                   -XX:+SafepointALot -XX:-TieredCompilation -XX:+UseTLAB TestSafepointAtPollReturn\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestSafepointAtPollReturn.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.valhalla.inlinetypes;\n+\n+import java.lang.invoke.*;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.misc.Unsafe;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.internal.vm.annotation.ImplicitlyConstructible;\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+\n+\/**\n+ * @test TestTearing\n+ * @key randomness\n+ * @summary Detect tearing on flat writes and buffering due to missing barriers.\n+ * @library \/testlibrary \/test\/lib \/compiler\/whitebox \/\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ * @run main\/othervm -XX:-UseFieldFlattening -XX:-UseArrayFlattening\n+ *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ *\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ * @run main\/othervm -XX:+UseNullableValueFlattening -XX:+UseAtomicValueFlattening\n+ *                   -XX:CompileCommand=dontinline,*::incrementAndCheck*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+StressLCM\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+AlwaysIncrementalInline\n+ *                   compiler.valhalla.inlinetypes.TestTearing\n+ *\/\n+\n+@ImplicitlyConstructible\n+@LooselyConsistentValue\n+value class MyValue {\n+    \/\/ Make sure the payload size is <= 64-bit to enable atomic flattening\n+    short x;\n+    short y;\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final long X_OFFSET;\n+    private static final long Y_OFFSET;\n+    static {\n+        try {\n+            Field xField = MyValue.class.getDeclaredField(\"x\");\n+            X_OFFSET = U.objectFieldOffset(xField);\n+            Field yField = MyValue.class.getDeclaredField(\"y\");\n+            Y_OFFSET = U.objectFieldOffset(yField);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    MyValue(short x, short y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    MyValue incrementAndCheck() {\n+        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n+        return new MyValue((short)(x + 1), (short)(y + 1));\n+    }\n+\n+    MyValue incrementAndCheckUnsafe() {\n+        Asserts.assertEQ(x, y, \"Inconsistent field values\");\n+        MyValue vt = U.makePrivateBuffer(this);\n+        U.putShort(vt, X_OFFSET, (short)(x + 1));\n+        U.putShort(vt, Y_OFFSET, (short)(y + 1));\n+        return U.finishPrivateBuffer(vt);\n+    }\n+}\n+\n+public class TestTearing {\n+    \/\/ Null-free, volatile -> atomic access\n+    @NullRestricted\n+    volatile static MyValue field1;\n+    @NullRestricted\n+    volatile MyValue field2;\n+\n+    \/\/ Nullable fields are always atomic\n+    static MyValue field3 = new MyValue((short)0, (short)0);\n+    MyValue field4 = new MyValue((short)0, (short)0);\n+\n+    static final MyValue[] array1 = (MyValue[])ValueClass.newNullRestrictedAtomicArray(MyValue.class, 1);\n+    static final MyValue[] array2 = (MyValue[])ValueClass.newNullableAtomicArray(MyValue.class, 1);\n+    static {\n+        array2[0] = new MyValue((short)0, (short)0);\n+    }\n+    static final MyValue[] array3 = new MyValue[] { new MyValue((short)0, (short)0) };\n+\n+    static final MethodHandle incrementAndCheck_mh;\n+\n+    static {\n+        try {\n+            Class<?> clazz = MyValue.class;\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(MyValue.class);\n+            incrementAndCheck_mh = lookup.findVirtual(clazz, \"incrementAndCheck\", mt);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(\"Method handle lookup failed\");\n+        }\n+    }\n+\n+    static class Runner extends Thread {\n+        TestTearing test;\n+\n+        public Runner(TestTearing test) {\n+            this.test = test;\n+        }\n+\n+        public void run() {\n+            for (int i = 0; i < 1_000_000; ++i) {\n+                test.field1 = test.field1.incrementAndCheck();\n+                test.field2 = test.field2.incrementAndCheck();\n+                test.field3 = test.field3.incrementAndCheck();\n+                test.field4 = test.field4.incrementAndCheck();\n+                array1[0] = array1[0].incrementAndCheck();\n+                array2[0] = array2[0].incrementAndCheck();\n+                array3[0] = array3[0].incrementAndCheck();\n+\n+                test.field1 = test.field1.incrementAndCheckUnsafe();\n+                test.field2 = test.field2.incrementAndCheckUnsafe();\n+                test.field3 = test.field3.incrementAndCheckUnsafe();\n+                test.field4 = test.field4.incrementAndCheckUnsafe();\n+                array1[0] = array1[0].incrementAndCheckUnsafe();\n+                array2[0] = array2[0].incrementAndCheckUnsafe();\n+                array3[0] = array3[0].incrementAndCheckUnsafe();\n+\n+                try {\n+                    test.field1 = (MyValue)incrementAndCheck_mh.invokeExact(test.field1);\n+                    test.field2 = (MyValue)incrementAndCheck_mh.invokeExact(test.field2);\n+                    test.field3 = (MyValue)incrementAndCheck_mh.invokeExact(test.field1);\n+                    test.field4 = (MyValue)incrementAndCheck_mh.invokeExact(test.field2);\n+                    array1[0] = (MyValue)incrementAndCheck_mh.invokeExact(array1[0]);\n+                    array2[0] = (MyValue)incrementAndCheck_mh.invokeExact(array2[0]);\n+                    array3[0] = (MyValue)incrementAndCheck_mh.invokeExact(array3[0]);\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(\"Test failed\", t);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create threads that concurrently update some value class (array) fields\n+        \/\/ and check the fields of the value classes for consistency to detect tearing.\n+        TestTearing test = new TestTearing();\n+        Thread runner = null;\n+        for (int i = 0; i < 10; ++i) {\n+            runner = new Runner(test);\n+            runner.start();\n+        }\n+        runner.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestTearing.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -51,2 +51,2 @@\n- * @run main\/othervm -Xint -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n- * @run main\/othervm -Xint -XX:-UseArrayFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ * @run main\/othervm -XX:+UseArrayFlattening -XX:+UseFieldFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n+ * @run main\/othervm -XX:-UseArrayFlattening -XX:+UseAtomicValueFlattening -XX:+UseNullableValueFlattening runtime.valhalla.inlinetypes.FlatArraysTest\n@@ -55,2 +55,0 @@\n-\/\/ TODO 8341767 Remove -Xint\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/FlatArraysTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-\/\/ TODO 8341767 Remove -Xint\n+\/\/ TODO 8350865 Implement unsafe intrinsics for nullable flat fields\/arrays in C2\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/UnsafeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}