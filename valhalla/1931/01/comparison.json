{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -724,2 +725,9 @@\n-      out->print(\" %d %s\", (int)(dp_to_di(pdata->dp() + in_bytes(offset)) \/ sizeof(intptr_t)),\n-                           CURRENT_ENV->replay_name(k));\n+      if (Arguments::is_valhalla_enabled() && k->is_obj_array_klass()) {\n+        \/\/ For value class arrays, we also record the array property to load the correct array class during replay.\n+        ArrayKlass::ArrayProperties array_properties = k->as_obj_array_klass()->properties();\n+        out->print(\" %d %s %d\", static_cast<int>(dp_to_di(pdata->dp() + in_bytes(offset)) \/ sizeof(intptr_t)),\n+                                      CURRENT_ENV->replay_name(k), static_cast<int>(array_properties));\n+      } else {\n+        out->print(\" %d %s\", static_cast<int>(dp_to_di(pdata->dp() + in_bytes(offset)) \/ sizeof(intptr_t)),\n+                             CURRENT_ENV->replay_name(k));\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -866,0 +866,6 @@\n+      if (had_error()) {\n+        return;\n+      }\n+      if (Arguments::is_valhalla_enabled() && _version >= 3 && k->is_objArray_klass()) {\n+        k = create_concrete_object_array_klass(ObjArrayKlass::cast(k), THREAD);\n+      }\n@@ -886,0 +892,13 @@\n+  ObjArrayKlass* create_concrete_object_array_klass(ObjArrayKlass* obj_array_klass, TRAPS) {\n+    ArrayKlass::ArrayProperties array_properties =\n+    static_cast<ArrayKlass::ArrayProperties>(parse_int(\"array_properties\"));\n+    if (array_properties != ArrayKlass::DEFAULT &&\n+        array_properties != ArrayKlass::NULL_RESTRICTED &&\n+        array_properties != ArrayKlass::NON_ATOMIC &&\n+        array_properties != (ArrayKlass::NULL_RESTRICTED | ArrayKlass::NON_ATOMIC)) {\n+      guarantee(false, \"invalid array_properties: %d, fall back to DEFAULT\", array_properties);\n+    }\n+\n+    return obj_array_klass->klass_with_properties(array_properties, THREAD);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -137,1 +137,2 @@\n-#define REPLAY_VERSION 2 \/\/ current version, bump up for incompatible changes\n+\/\/ 3: value class array support (8375548)\n+#define REPLAY_VERSION 3 \/\/ current version, bump up for incompatible changes\n","filename":"src\/hotspot\/share\/ci\/ciReplay.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+\n+public class ErrorFile {\n+    private final String errorFile;\n+\n+    public ErrorFile(String errorFile) {\n+        this.errorFile = errorFile;\n+    }\n+\n+    public boolean find(String toMatch) {\n+        try (var br = Files.newBufferedReader(Paths.get(errorFile))) {\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                if (line.contains(toMatch)) {\n+                    return true;\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + errorFile + \" data: \" + e, e);\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/ErrorFile.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PrintIdeal {\n+    private final String logFile;\n+    private final List<String> idealGraph;\n+\n+    public PrintIdeal(String logFile) {\n+        this.logFile = logFile;\n+        this.idealGraph = new ArrayList<>();\n+    }\n+\n+    public List<String> vmFlags() {\n+        return new ArrayList<>(List.of(\n+                \"-XX:LogFile='\" + logFile + \"'\",\n+                \"-XX:+LogCompilation\",\n+                \"-XX:+PrintIdeal\"\n+        ));\n+    }\n+\n+    public void parse() {\n+        idealGraph.clear();\n+        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n+            String line;\n+            boolean printIdealLine = false;\n+            while ((line = br.readLine()) != null) {\n+                if (printIdealLine) {\n+                    if (line.startsWith(\"<\/ideal\")) {\n+                        break;\n+                    }\n+                    idealGraph.add(line);\n+                } else {\n+                    printIdealLine = line.startsWith(\"<ideal\");\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n+        }\n+        Asserts.assertFalse(idealGraph.isEmpty(), \"did not find PrintIdeal output\");\n+    }\n+\n+    public String find(String toMatch) {\n+        return idealGraph.stream()\n+                .filter(line -> line.contains(toMatch))\n+                .findFirst()\n+                .orElse(\"\");\n+    }\n+\n+    public int count(String toMatch) {\n+        return (int) idealGraph.stream()\n+                .filter(line -> line.contains(toMatch))\n+                .count();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/PrintIdeal.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ReplayFile {\n+    private final Path replayFilePath;\n+    private final List<String> replayFile;\n+\n+    public ReplayFile(String replayFileName) {\n+        try {\n+            this.replayFilePath = Paths.get(replayFileName);\n+            this.replayFile = Files.readAllLines(replayFilePath);\n+        } catch (IOException ioe) {\n+            throw new Error(\"Failed to read\/write replay data: \" + ioe, ioe);\n+        }\n+    }\n+\n+    public void removeLineStartingWith(String oldLine) {\n+        replaceLineStartingWith(oldLine, \"\");\n+    }\n+\n+    public String findLineStartingWith(String toFind) {\n+        return replayFile.stream()\n+                .filter(line -> line.startsWith(toFind))\n+                .findFirst()\n+                .orElse(\"\");\n+    }\n+\n+    public void replaceLineStartingWith(String oldLine, String newLine) {\n+        boolean foundOldLine = false;\n+        List<String> newReplayFile = new ArrayList<>();\n+        for (String line : replayFile) {\n+            if (line.startsWith(oldLine)) {\n+                foundOldLine = true;\n+                if (!newLine.isEmpty()) {\n+                    \/\/ Only add if non-empty. Otherwise, line removal.\n+                    newReplayFile.add(newLine);\n+                }\n+            } else {\n+                newReplayFile.add(line);\n+            }\n+        }\n+        Asserts.assertTrue(foundOldLine, \"Did not find oldLine \\\"\" + oldLine + \"\\\" in \" + replayFilePath);\n+        try {\n+            Files.write(replayFilePath, newReplayFile, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException ioe) {\n+            throw new Error(\"Failed to read\/write replay data: \" + ioe, ioe);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/ReplayFile.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,6 +41,0 @@\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-import java.util.ArrayList;\n@@ -51,2 +45,2 @@\n-    private static final String[] COMMAND_LINE = new String[] {\"-XX:LogFile='\" + LOG_FILE + \"'\", \"-XX:+LogCompilation\", \"-XX:+PrintIdeal\",\n-                                                               \"-XX:CompileCommand=dontinline,compiler.ciReplay.Test::dontInline\"};\n+    private final PrintIdeal printIdeal = new PrintIdeal(LOG_FILE);\n+\n@@ -64,1 +58,5 @@\n-        positiveTest(COMMAND_LINE);\n+        List<String> vmFlags = printIdeal.vmFlags();\n+        vmFlags.add(\"-XX:CompileCommand=dontinline,*Test::dontInline\");\n+        String[] commandLine = vmFlags.toArray(new String[0]);\n+        positiveTest(commandLine);\n+        printIdeal.parse();\n@@ -68,0 +66,1 @@\n+        ReplayFile replayFile = new ReplayFile(getReplayFileName());\n@@ -69,17 +68,1 @@\n-        try {\n-            Path replayFilePath = Paths.get(REPLAY_FILE_NAME);\n-            List<String> replayContent = Files.readAllLines(replayFilePath);\n-            List<String> newReplayContent = new ArrayList<>();\n-            boolean foundFoo = false;\n-            for (String line : replayContent) {\n-                if (!line.startsWith(\"ciInstanceKlass compiler\/ciReplay\/Foo\")) {\n-                    newReplayContent.add(line);\n-                } else {\n-                    foundFoo = true;\n-                }\n-            }\n-            Asserts.assertTrue(foundFoo, \"Did not find ciInstanceKlass compiler\/ciReplay\/Foo entry\");\n-            Files.write(replayFilePath, newReplayContent, StandardOpenOption.TRUNCATE_EXISTING);\n-        } catch (IOException ioe) {\n-            throw new Error(\"Failed to read\/write replay data: \" + ioe, ioe);\n-        }\n+        replayFile.removeLineStartingWith(\"ciInstanceKlass compiler\/ciReplay\/TestUnresolvedClasses$Foo\");\n@@ -87,1 +70,2 @@\n-        positiveTest(COMMAND_LINE);\n+        positiveTest(commandLine);\n+        printIdeal.parse();\n@@ -98,19 +82,5 @@\n-        try (var br = Files.newBufferedReader(Paths.get(LOG_FILE))) {\n-            String line;\n-            boolean printIdealLine = false;\n-            while ((line = br.readLine()) != null) {\n-                if (printIdealLine) {\n-                    if (line.startsWith(\"<\/ideal\")) {\n-                        break;\n-                    }\n-                    if (line.contains(toMatch)) {\n-                        Asserts.assertTrue(line.contains(\"CallStaticJava\"), \"must be CallStaticJava node\");\n-                        Asserts.assertTrue(shouldMatch, \"Should not have found \" + toMatch);\n-                        return;\n-                    }\n-                } else {\n-                    printIdealLine = line.startsWith(\"<ideal\");\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new Error(\"Failed to read \" + LOG_FILE + \" data: \" + e, e);\n+        String line = printIdeal.find(toMatch);\n+        if (shouldMatch) {\n+            Asserts.assertTrue(line.contains(\"CallStaticJava\"), \"must be CallStaticJava node\");\n+        } else {\n+            Asserts.assertTrue(line.isEmpty(), \"Should not have found \" + toMatch);\n@@ -118,1 +88,0 @@\n-        Asserts.assertFalse(shouldMatch, \"Should have found \" + toMatch);\n@@ -120,1 +89,0 @@\n-}\n@@ -122,2 +90,2 @@\n-class Test {\n-    static Foo f = new Foo();\n+    private static class Test {\n+        static Foo f = new Foo();\n@@ -125,3 +93,4 @@\n-    public static void main(String[] args) {\n-        for (int i = 0; i < 10000; i++) {\n-            test();\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 10000; i++) {\n+                test();\n+            }\n@@ -129,1 +98,0 @@\n-    }\n@@ -131,6 +99,6 @@\n-    public static void test() {\n-        f.bar();\n-        \/\/ At replay compilation: Should emit UCT for f.bar() because class Foo is unloaded. Parsing stops here.\n-        \/\/ dontInline() is not parsed anymore.\n-        dontInline();\n-    }\n+        public static void test() {\n+            f.bar();\n+            \/\/ At replay compilation: Should emit UCT for f.bar() because class Foo is unloaded. Parsing stops here.\n+            \/\/ dontInline() is not parsed anymore.\n+            dontInline();\n+        }\n@@ -138,2 +106,3 @@\n-    \/\/ Not inlined\n-    public static void dontInline() {\n+        \/\/ Not inlined\n+        public static void dontInline() {\n+        }\n@@ -141,1 +110,0 @@\n-}\n@@ -143,3 +111,4 @@\n-class Foo {\n-    public int bar() {\n-        return 3;\n+    private static class Foo {\n+        public int bar() {\n+            return 3;\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestUnresolvedClasses.java","additions":36,"deletions":67,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8375548\n+ * @enablePreview\n+ * @library \/ \/test\/lib\n+ * @summary Testing that compiler replay correctly loads sub classes of ObjArrayKlass.\n+ * @requires vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\" &\n+ *           vm.debug == true & vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.base\/jdk.internal.value\n+ *          java.base\/jdk.internal.vm.annotation\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+TieredCompilation\n+ *                   compiler.ciReplay.TestValueClassArrays\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.internal.value.ValueClass;\n+import jdk.test.lib.Asserts;\n+\n+public class TestValueClassArrays extends DumpReplayBase {\n+    private static final String LOG_FILE = \"hotspot.log\";\n+    private static final String ERROR_FILE = \"error.log\";\n+    private final PrintIdeal printIdeal;\n+    private final String[] defaultReplayRunFlags;\n+\n+    public static void main(String[] args) {\n+        new TestValueClassArrays().runTest(\"-XX:CompileCommand=dontinline,*::*\",\n+                                           \"--enable-preview\",\n+                                           \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                                           \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                                           TIERED_DISABLED_VM_OPTION);\n+    }\n+\n+    private TestValueClassArrays() {\n+        printIdeal = new PrintIdeal(LOG_FILE);\n+        defaultReplayRunFlags = defaultReplayRunFlags();\n+    }\n+\n+\n+    private String[] defaultReplayRunFlags() {\n+        List<String> vmFlags = printIdeal.vmFlags();\n+        Collections.addAll(vmFlags,\n+                           \"-XX:+ReplayIgnoreInitErrors\",\n+                           \"-XX:CompileCommand=dontinline,*::*\",\n+                           \"--enable-preview\",\n+                           \"--add-exports\", \"java.base\/jdk.internal.value=ALL-UNNAMED\",\n+                           \"--add-exports\", \"java.base\/jdk.internal.vm.annotation=ALL-UNNAMED\",\n+                           \"-XX:ErrorFile=\" + ERROR_FILE,\n+                           TIERED_DISABLED_VM_OPTION\n+        );\n+        return vmFlags.toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public void testAction() {\n+        testArrayAccessSpeculation();\n+        testNoProfilingNoSpeculation();\n+        testInvalidArrayProperty();\n+        remove(LOG_FILE);\n+        remove(ERROR_FILE);\n+    }\n+\n+    \/**\n+     * Check that we emit traps for speculation on array stores and loads as captured in the profiling.\n+     *\/\n+    private void testArrayAccessSpeculation() {\n+        positiveTest(defaultReplayRunFlags);\n+        printIdeal.parse();\n+        int countClassCheck = printIdeal.count(\"class_check\");\n+        Asserts.assertEQ(countClassCheck, 8, \"not found all class checks for speculation on array accesses\");\n+    }\n+\n+    \/**\n+     * Check that we do not emit traps for speculation on array stores and loads since we disabled array profiling.\n+     *\/\n+    private void testNoProfilingNoSpeculation() {\n+        String[] noProfilingFlags = Arrays.copyOf(defaultReplayRunFlags, defaultReplayRunFlags.length + 1);\n+        noProfilingFlags[defaultReplayRunFlags.length] = \"-XX:-UseArrayLoadStoreProfile\";\n+        positiveTest(noProfilingFlags);\n+        printIdeal.parse();\n+        String empty = printIdeal.find(\"class_check\");\n+        Asserts.assertTrue(empty.isEmpty(), \"should not find UCTs for speculation without array profiling\");\n+    }\n+\n+    \/**\n+     * Replace the \"array property\" in the \"ciMethodData\" with an invalid value -1 to make compiler replay fail\n+     * with an assertion.\n+     *\/\n+    private void testInvalidArrayProperty() {\n+        invalidateCiMethodDataInReplayFile();\n+        negativeTest(defaultReplayRunFlags);\n+        ErrorFile errorFile = new ErrorFile(ERROR_FILE);\n+        Asserts.assertTrue(errorFile.find(\"guarantee(false) failed: invalid array_properties: -1, fall back to DEFAULT\"));\n+    }\n+\n+    private void invalidateCiMethodDataInReplayFile() {\n+        ReplayFile replayFile = new ReplayFile(getReplayFileName());\n+        String ciMethodData = replayFile.findLineStartingWith(\n+                \"ciMethodData compiler\/ciReplay\/TestValueClassArrays$Test test\");\n+        Pattern pattern = Pattern.compile(\"(\\\\[Lcompiler\/ciReplay\/TestValueClassArrays\\\\$Test\\\\$A;) (\\\\d+)\");\n+        Matcher matcher = pattern.matcher(ciMethodData);\n+        Asserts.assertTrue(matcher.find(), \"must find array_property\");\n+        String replacement = matcher.group(1) + \" -1\";\n+        String newCiMethodData = matcher.replaceFirst(Matcher.quoteReplacement(replacement));\n+        replayFile.replaceLineStartingWith(ciMethodData, newCiMethodData);\n+    }\n+\n+    @Override\n+    public String getTestClass() {\n+        return Test.class.getName();\n+    }\n+\n+\n+    private static class Test {\n+        static A[] oArrDefault = new A[2];\n+        static A[] oArrNullableAtomicArray = (A[]) ValueClass.newNullableAtomicArray(A.class, 2);\n+        static A[] oArrNullRestrictedAtomicArray = (A[]) ValueClass.newNullRestrictedAtomicArray(A.class, 2, new A(1));\n+        static A[] oArrNullRestrictedNonAtomicArray = (A[]) ValueClass.newNullRestrictedNonAtomicArray(A.class, 2, new A(2));\n+\n+        static A o1, o2, o3, o4;\n+        static A a = new A(10);\n+\n+        public static void main(String[] args) {\n+            oArrDefault[0] = new A(3);\n+            oArrNullableAtomicArray[0] = new A(4);\n+            oArrNullRestrictedAtomicArray[0] = new A(5);\n+            oArrNullRestrictedNonAtomicArray[0] = new A(6);\n+            for (int i = 0; i < 10000; i++) {\n+                test();\n+            }\n+        }\n+\n+        static void test() {\n+            o1 = oArrDefault[0];\n+            oArrDefault[1] = a;\n+            o2 = oArrNullableAtomicArray[0];\n+            oArrNullableAtomicArray[1] = a;\n+            o3 = oArrNullRestrictedAtomicArray[0];\n+            oArrNullRestrictedAtomicArray[1] = a;\n+            o4 = oArrNullRestrictedNonAtomicArray[0];\n+            oArrNullRestrictedNonAtomicArray[1] = a;\n+        }\n+\n+        static value class A {\n+            int x;\n+            public A(int x) {\n+                this.x = x;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestValueClassArrays.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"}]}