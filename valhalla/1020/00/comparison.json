{"files":[{"patch":"@@ -253,4 +253,0 @@\n-  case vmIntrinsics::_asPrimaryType:\n-  case vmIntrinsics::_asPrimaryTypeArg:\n-  case vmIntrinsics::_asValueType:\n-  case vmIntrinsics::_asValueTypeArg:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -302,6 +302,0 @@\n-  do_intrinsic(_asPrimaryType,            java_lang_Class,        asPrimaryType_name, void_class_signature,      F_R)   \\\n-  do_intrinsic(_asPrimaryTypeArg,         jdk_internal_value_PrimitiveClass, asPrimaryType_name, class_class_signature, F_S) \\\n-   do_name(     asPrimaryType_name,                              \"asPrimaryType\")                                       \\\n-  do_intrinsic(_asValueType,              java_lang_Class,        asValueType_name, void_class_signature,        F_R)   \\\n-  do_intrinsic(_asValueTypeArg,           jdk_internal_value_PrimitiveClass, asValueType_name,   class_class_signature, F_S) \\\n-   do_name(     asValueType_name,                                \"asValueType\")                                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -744,4 +744,0 @@\n-  case vmIntrinsics::_asPrimaryType:\n-  case vmIntrinsics::_asPrimaryTypeArg:\n-  case vmIntrinsics::_asValueType:\n-  case vmIntrinsics::_asValueTypeArg:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -540,5 +540,0 @@\n-  case vmIntrinsics::_asPrimaryType:\n-  case vmIntrinsics::_asPrimaryTypeArg:\n-  case vmIntrinsics::_asValueType:\n-  case vmIntrinsics::_asValueTypeArg:           return inline_primitive_Class_conversion(intrinsic_id());\n-\n@@ -4106,28 +4101,0 @@\n-\/\/-------------------------inline_primitive_Class_conversion-------------------\n-\/\/               Class<T> java.lang.Class                  .asPrimaryType()\n-\/\/ public static Class<T> jdk.internal.value.PrimitiveClass.asPrimaryType(Class<T>)\n-\/\/               Class<T> java.lang.Class                  .asValueType()\n-\/\/ public static Class<T> jdk.internal.value.PrimitiveClass.asValueType(Class<T>)\n-bool LibraryCallKit::inline_primitive_Class_conversion(vmIntrinsics::ID id) {\n-  Node* mirror = argument(0); \/\/ Receiver\/argument Class\n-  const TypeInstPtr* mirror_con = _gvn.type(mirror)->isa_instptr();\n-  if (mirror_con == nullptr) {\n-    return false;\n-  }\n-\n-  \/\/ JDK-8325660: Code has been modified because secondary mirror are gone in JEP 401\n-  ciType* tm = mirror_con->java_mirror_type();\n-  if (tm != nullptr) {\n-    Node* result = mirror;\n-    if (id == vmIntrinsics::_asValueType || id == vmIntrinsics::_asValueTypeArg) {\n-      if (!tm->is_inlinetype()) {\n-        return false; \/\/ Throw UnsupportedOperationException\n-      } else {\n-        result = _gvn.makecon(TypeInstPtr::make(tm->as_inline_klass()->java_mirror()));\n-      }\n-    }\n-    set_result(result);\n-    return true;\n-  }\n-  return false;\n-}\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -269,16 +268,2 @@\n-        String s = getName();\n-        if (isPrimitive()) {\n-            return s;\n-        }\n-        \/\/ Avoid invokedynamic based String concat, might be not available\n-        \/\/ Prepend type of class\n-        s = (isInterface() ? \"interface \" : \"class \").concat(s);\n-        if (isValue()) {\n-            \/\/ prepend value class type\n-            s = (isPrimitiveClass() ? \"primitive \" : \"value \").concat(s);\n-            if (isPrimitiveClass() && isPrimaryType()) {\n-                \/\/ Append .ref\n-                s = s.concat(\".ref\");\n-            }\n-        }\n-        return s;\n+        String kind = isInterface() ? \"interface \" : isPrimitive() ? \"\" : \"class \";\n+        return kind.concat(getName());\n@@ -348,1 +333,1 @@\n-                    sb.append(isPrimitiveClass() ? \"primitive \" : \"value \");\n+                    sb.append(\"value \");\n@@ -656,28 +641,0 @@\n-    \/\/ set by VM if this class is an exotic type such as primitive class\n-    \/\/ otherwise, these two fields are null\n-    private transient Class<T> primaryType;\n-    private transient Class<T> secondaryType;\n-\n-    \/**\n-     * Returns {@code true} if this class is a primitive class.\n-     * <p>\n-     * Each primitive class has a {@linkplain #isPrimaryType() primary type}\n-     * representing the <em>primitive reference type<\/em> and a\n-     * {@linkplain #isPrimitiveValueType() secondary type} representing\n-     * the <em>primitive value type<\/em>.  The primitive reference type\n-     * and primitive value type can be obtained by calling the\n-     * {@link #asPrimaryType()} and {@link #asValueType} method\n-     * of a primitive class respectively.\n-     * <p>\n-     * A primitive class is a {@linkplain #isValue() value class}.\n-     *\n-     * @return {@code true} if this class is a primitive class, otherwise {@code false}\n-     * @see #isValue()\n-     * @see #asPrimaryType()\n-     * @see #asValueType()\n-     * @since Valhalla\n-     *\/\n-    \/* package *\/ boolean isPrimitiveClass() {\n-        return (this.getModifiers() & PrimitiveClass.PRIMITIVE_CLASS) != 0;\n-    }\n-\n@@ -709,72 +666,1 @@\n-        return (this.getModifiers() & Modifier.VALUE) != 0;\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the primary type\n-     * of this class or interface.\n-     * <p>\n-     * If this {@code Class} object represents a primitive type or an array type,\n-     * then this method returns this class.\n-     * <p>\n-     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n-     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n-     * type of this primitive class.\n-     * <p>\n-     * Otherwise, this {@code Class} object represents a non-primitive class or interface\n-     * and this method returns this class.\n-     *\n-     * @return the {@code Class} representing the primary type of\n-     *         this class or interface\n-     * @since Valhalla\n-     *\/\n-    @IntrinsicCandidate\n-    \/* package *\/ Class<?> asPrimaryType() {\n-        return isPrimitiveClass() ? primaryType : this;\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n-     * of this class if this class is a {@linkplain #isPrimitiveClass() primitive class}.\n-     *\n-     * @apiNote Alternatively, this method returns null if this class is not\n-     *          a primitive class rather than throwing UOE.\n-     *\n-     * @return the {@code Class} representing the {@linkplain #isPrimitiveValueType()\n-     * primitive value type} of this class if this class is a primitive class\n-     * @throws UnsupportedOperationException if this class or interface\n-     *         is not a primitive class\n-     * @since Valhalla\n-     *\/\n-    @IntrinsicCandidate\n-    \/* package *\/ Class<?> asValueType() {\n-        if (isPrimitiveClass())\n-            return secondaryType;\n-\n-        throw new UnsupportedOperationException(this.getName().concat(\" is not a primitive class\"));\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@code Class} object represents the primary type\n-     * of this class or interface.\n-     * <p>\n-     * If this {@code Class} object represents a primitive type or an array type,\n-     * then this method returns {@code true}.\n-     * <p>\n-     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass()\n-     * primitive}, then this method returns {@code true} if this {@code Class}\n-     * object represents a primitive reference type, or returns {@code false}\n-     * if this {@code Class} object represents a primitive value type.\n-     * <p>\n-     * If this {@code Class} object represents a non-primitive class or interface,\n-     * then this method returns {@code true}.\n-     *\n-     * @return {@code true} if this {@code Class} object represents\n-     * the primary type of this class or interface\n-     * @since Valhalla\n-     *\/\n-    \/* package *\/ boolean isPrimaryType() {\n-        if (isPrimitiveClass()) {\n-            return this == primaryType;\n-        }\n-        return true;\n-    }\n+        if (isPrimitive() || isArray() || isInterface()) return false;\n@@ -782,10 +668,1 @@\n-    \/**\n-     * Returns {@code true} if this {@code Class} object represents\n-     * a {@linkplain #isPrimitiveClass() primitive} value type.\n-     *\n-     * @return {@code true} if this {@code Class} object represents\n-     * the value type of a primitive class\n-     * @since Valhalla\n-     *\/\n-    \/* package *\/ boolean isPrimitiveValueType() {\n-        return isPrimitiveClass() && this == secondaryType;\n+        return (this.getModifiers() & Modifier.IDENTITY) == 0;\n@@ -1787,2 +1664,0 @@\n-        boolean isValueFactoryMethod() { return !isPartial() && ConstantDescs.VNEW_NAME.equals(name); }\n-\n@@ -1790,1 +1665,0 @@\n-                                        && !isValueFactoryMethod()\n@@ -1848,1 +1722,1 @@\n-            if (!enclosingInfo.isObjectConstructor() && !enclosingInfo.isValueFactoryMethod())\n+            if (!enclosingInfo.isObjectConstructor())\n@@ -2031,1 +1905,1 @@\n-                return cl.getTypeName().concat(\"[]\".repeat(dimensions));\n+                return cl.getName().concat(\"[]\".repeat(dimensions));\n@@ -2034,6 +1908,1 @@\n-        if (isPrimitiveClass()) {\n-            \/\/ TODO: null-default\n-            return isPrimaryType() ? getName().concat(\".ref\") : getName();\n-        } else {\n-            return getName();\n-        }\n+        return getName();\n@@ -3979,1 +3848,1 @@\n-        throw new NoSuchMethodException(methodToString(isValue() ? \"<vnew>\" : \"<init>\", parameterTypes));\n+        throw new NoSuchMethodException(methodToString(\"<init>\", parameterTypes));\n@@ -4284,3 +4153,0 @@\n-        if (isPrimitiveValueType() && obj == null)\n-            throw new NullPointerException(getName() + \" is a primitive value type\");\n-\n@@ -4793,1 +4659,0 @@\n-        char typeDesc = isPrimitiveValueType() ? 'Q' : 'L';\n@@ -4798,1 +4663,1 @@\n-                    .append(typeDesc)\n+                    .append('L')\n@@ -4807,1 +4672,1 @@\n-                    .append(typeDesc)\n+                    .append('L')\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":11,"deletions":146,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2670,18 +2670,0 @@\n-            @Override\n-            public Class<?> asPrimaryType(Class<?> clazz) {\n-                return clazz.asPrimaryType();\n-            }\n-            public Class<?> asValueType(Class<?> clazz) {\n-                return clazz.asValueType();\n-            }\n-\n-            public boolean isPrimaryType(Class<?> clazz) {\n-                return clazz.isPrimaryType();\n-            }\n-            public boolean isPrimitiveValueType(Class<?> clazz) {\n-                return clazz.isPrimitiveValueType();\n-            }\n-            public boolean isPrimitiveClass(Class<?> clazz) {\n-                return clazz.isPrimitiveClass();\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n@@ -76,1 +74,1 @@\n-            Class<?> clazz = findClass(lookup, internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n+            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n@@ -81,12 +79,1 @@\n-        return findClass(lookup, internalToBinary(dropFirstAndLastChar(descriptor)));\n-    }\n-\n-    private Class<?> findClass(MethodHandles.Lookup lookup, String name) throws ReflectiveOperationException {\n-        Class<?> c = lookup.findClass(name);\n-        if (isValue) {\n-            if (!PrimitiveClass.isPrimitiveClass(c)) {\n-                throw new LinkageError(c.getName() + \" is not a primitive class\");\n-            }\n-            return PrimitiveClass.asValueType(c);\n-        }\n-        return c;\n+        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDescImpl.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -311,9 +311,0 @@\n-    \/**\n-     * The special name of value object factory methods, {@value}. A value\n-     * object factory method has this special name and is {@code void}.\n-     *\n-     * TODO jvms ref\n-     * @since 21\n-     *\/\n-    public static final String VNEW_NAME = \"<vnew>\";\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private static final Set<String> pointyNames = Set.of(ConstantDescs.INIT_NAME, ConstantDescs.VNEW_NAME, ConstantDescs.CLASS_INIT_NAME);\n+    private static final Set<String> pointyNames = Set.of(ConstantDescs.INIT_NAME, ConstantDescs.CLASS_INIT_NAME);\n@@ -229,1 +229,0 @@\n-    private static final char JVM_SIGNATURE_VALUE_TYPE = 'Q';\n@@ -269,1 +268,0 @@\n-                case JVM_SIGNATURE_VALUE_TYPE:\n@@ -357,1 +355,0 @@\n-                case JVM_SIGNATURE_VALUE_TYPE:\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -235,1 +235,0 @@\n-     * For static value class instance factory methods, return {@value ConstantDescs#VNEW_NAME}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDesc.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -279,1 +278,1 @@\n-            if (!PrimitiveClass.asPrimaryType(implClass).isAssignableFrom(PrimitiveClass.asPrimaryType(receiverClass))) {\n+            if (!implClass.isAssignableFrom(receiverClass)) {\n@@ -332,1 +331,1 @@\n-            if (!PrimitiveClass.asPrimaryType(descriptorParamType).isAssignableFrom(PrimitiveClass.asPrimaryType(dynamicParamType))) {\n+            if (!descriptorParamType.isAssignableFrom(dynamicParamType)) {\n@@ -413,2 +412,1 @@\n-            \/\/ val projection can be converted to ref projection; or vice verse\n-            return PrimitiveClass.asPrimaryType(fromType) == PrimitiveClass.asPrimaryType(toType);\n+            return fromType == toType;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -83,2 +82,1 @@\n-            Class<?> receiverType = PrimitiveClass.isPrimitiveClass(refc) ? PrimitiveClass.asValueType(refc) : refc;\n-            mtype = mtype.insertParameterTypes(0, receiverType);\n+            mtype = mtype.insertParameterTypes(0, refc);\n@@ -132,1 +130,1 @@\n-        if (member.isObjectConstructor() && member.getMethodType().returnType() == void.class)\n+        if (member.isObjectConstructor())\n@@ -137,1 +135,1 @@\n-        assert(ctor.isObjectConstructor() && !ctor.getDeclaringClass().isValue()) : ctor;\n+        assert(ctor.isObjectConstructor()) : ctor;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n@@ -123,11 +121,0 @@\n-        } else if (member.isStaticValueFactoryMethod()) {\n-            assert defc.isValue();\n-            MethodType methodType = getMethodType();\n-            Class<?> rtype = PrimitiveClass.isPrimitiveClass(defc) ? PrimitiveClass.asValueType(defc) : defc;\n-            if (MethodHandleNatives.refKindIsMethod(refKind) &&\n-                    methodType.returnType() != rtype) {\n-                \/\/ static vnew factory\n-                throw new IllegalArgumentException(\"static factory must be of \" + defc.getName());\n-            }\n-            return isPublic ? defc.getConstructor(methodType.parameterArray())\n-                            : defc.getDeclaredConstructor(methodType.parameterArray());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -962,1 +962,1 @@\n-        if (member.isObjectConstructor() || member.isStaticValueFactoryMethod())  return false;\n+        if (member.isObjectConstructor())  return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -95,2 +94,1 @@\n-     *  For an identity object constructor, it is {@code \"<init>\"}.\n-     *  For a value class static factory method, it is {@code \"<vnew>\"}.\n+     *  For a constructor, it is always {@code \"<init>\"}.\n@@ -186,1 +184,0 @@\n-        Class<?> c = PrimitiveClass.isPrimitiveClass(clazz) ? PrimitiveClass.asValueType(clazz) : clazz;\n@@ -188,1 +185,1 @@\n-            return itype.changeReturnType(c);\n+            return itype.changeReturnType(clazz);\n@@ -190,1 +187,1 @@\n-            return itype.insertParameterTypes(0, c);\n+            return itype.insertParameterTypes(0, clazz);\n@@ -445,1 +442,1 @@\n-            return PrimitiveClass.isPrimitiveValueType(type) || (type.isValue() && !PrimitiveClass.isPrimitiveClass(type));\n+            return type.isValue();\n@@ -481,5 +478,0 @@\n-    \/** Query whether this member is an object constructor or static <init> factory *\/\n-    public boolean isStaticValueFactoryMethod() {\n-        return VALUE_FACTORY_NAME.equals(name) && isMethod();\n-    }\n-\n@@ -645,1 +637,1 @@\n-        this.name = this.clazz.isValue() ? VALUE_FACTORY_NAME : CONSTRUCTOR_NAME;\n+        this.name = CONSTRUCTOR_NAME;\n@@ -647,5 +639,1 @@\n-            Class<?> rtype = void.class;\n-            if (isStatic()) {  \/\/ a value class static factory, not a true constructor\n-                rtype = getDeclaringClass();\n-            }\n-            this.type = new Object[] { rtype, ctor.getParameterTypes() };\n+            this.type = new Object[] { void.class, ctor.getParameterTypes() };\n@@ -785,1 +773,0 @@\n-     *  It will be a value class instance factory method if and only if the name is {@code \"<vnew>\"}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -165,3 +165,1 @@\n-     * or {@value java.lang.constant.ConstantDescs#VNEW_NAME}\n-     * if the underlying member was a value class static\n-     * factory method, else it is a simple method name or field name.\n+     * else it is a simple method name or field name.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleInfo.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -710,2 +709,2 @@\n-     * with special names ({@value ConstantDescs#INIT_NAME},\n-     * {@value ConstantDescs#VNEW_NAME} and {@value ConstantDescs#CLASS_INIT_NAME}).\n+     * with special names ({@value ConstantDescs#INIT_NAME}, and {@value\n+     * ConstantDescs#CLASS_INIT_NAME}).\n@@ -1631,1 +1630,0 @@\n-            assert PrimitiveClass.isPrimaryType(lookupClass);\n@@ -3524,1 +3522,1 @@\n-            assert(ctor.isObjectConstructor() || ctor.isStaticValueFactoryMethod());\n+            assert(ctor.isObjectConstructor());\n@@ -3527,10 +3525,1 @@\n-            Class<?> defc = c.getDeclaringClass();\n-            if (ctor.isObjectConstructor()) {\n-                assert(ctor.getMethodType().returnType() == void.class);\n-                return lookup.getDirectConstructorNoSecurityManager(defc, ctor);\n-            } else {\n-                \/\/ static init factory is a static method\n-                assert(ctor.isMethod() && ctor.getMethodType().returnType() == defc && ctor.getReferenceKind() == REF_invokeStatic) : ctor.toString();\n-                assert(!MethodHandleNatives.isCallerSensitive(ctor));  \/\/ must not be caller-sensitive\n-                return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), defc, ctor, lookup);\n-            }\n+            return lookup.getDirectConstructorNoSecurityManager(c.getDeclaringClass(), ctor);\n@@ -3808,1 +3797,1 @@\n-            if (isIllegalMethodName(refKind, name)) {\n+            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial) {\n@@ -3831,12 +3820,0 @@\n-        \/*\n-         * \"<init>\" can only be invoked via invokespecial\n-         * \"<vnew>\" factory can only invoked via invokestatic\n-         *\/\n-        boolean isIllegalMethodName(byte refKind, String name) {\n-            if (name.startsWith(\"<\")) {\n-                return MemberName.VALUE_FACTORY_NAME.equals(name) ? refKind != REF_invokeStatic\n-                                                                  : refKind != REF_newInvokeSpecial;\n-            }\n-            return false;\n-        }\n-\n@@ -3845,3 +3822,2 @@\n-            if (isIllegalMethodName(refKind, name)) {\n-                throw new NoSuchMethodException(\"illegal method name: \" + name + \" \" + refKind);\n-            }\n+            if (name.startsWith(\"<\") && refKind != REF_newInvokeSpecial)\n+                throw new NoSuchMethodException(\"illegal method name: \" + name + \" ref kind \" + refKind);\n@@ -3951,1 +3927,1 @@\n-            if (!fullPrivilegeLookup && PrimitiveClass.asPrimaryType(defc) != PrimitiveClass.asPrimaryType(refc)) {\n+            if (!fullPrivilegeLookup && defc != refc) {\n@@ -4038,1 +4014,1 @@\n-                               (PrimitiveClass.asPrimaryType(defc) == PrimitiveClass.asPrimaryType(refc) ||\n+                               (defc == refc ||\n@@ -4043,1 +4019,1 @@\n-                           (PrimitiveClass.asPrimaryType(defc) == PrimitiveClass.asPrimaryType(refc) ||\n+                           (defc == refc ||\n@@ -5174,1 +5150,1 @@\n-            if (!PrimitiveClass.isPrimitiveValueType(type) && value == null)\n+            if (value == null)\n@@ -5219,0 +5195,1 @@\n+        \/\/ TODO: implicitly constructible value class\n@@ -5221,4 +5198,0 @@\n-        } else if (PrimitiveClass.isPrimitiveValueType(type)) {\n-            \/\/ singleton default value\n-            Object value = ValueClass.zeroInstance(type);\n-            return identity(type).bindTo(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":12,"deletions":39,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n@@ -44,1 +41,0 @@\n-import java.util.concurrent.ConcurrentMap;\n@@ -47,1 +43,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -943,1 +938,1 @@\n-                \")\" + toSimpleName(rtype));\n+                \")\" + rtype.getSimpleName());\n@@ -945,1 +940,1 @@\n-            sj.add(toSimpleName(ptypes[i]));\n+            sj.add(ptypes[i].getSimpleName());\n@@ -950,7 +945,0 @@\n-    static String toSimpleName(Class<?> c) {\n-        if (PrimitiveClass.isPrimitiveClass(c) && PrimitiveClass.isPrimaryType(c)) {\n-            return c.getSimpleName() + \".ref\";\n-        } else {\n-            return c.getSimpleName();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -1697,6 +1696,0 @@\n-            \/\/ the field type (value) is mapped to the return type of MethodType\n-            \/\/ the receiver type is mapped to a parameter type of MethodType\n-            \/\/ So use the value type if it's a primitive class\n-            if (receiver != null && PrimitiveClass.isPrimitiveClass(receiver)) {\n-                receiver = PrimitiveClass.asValueType(receiver);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -131,1 +130,0 @@\n-        assert PrimitiveClass.isPrimaryType(declaringClass);\n@@ -370,1 +368,1 @@\n-        sb.append(getDeclaringClassTypeName());\n+        sb.append(getDeclaringClass().getTypeName());\n@@ -376,1 +374,1 @@\n-        sb.append(getDeclaringClassTypeName());\n+        sb.append(getDeclaringClass().getTypeName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -796,8 +795,0 @@\n-\n-    String getDeclaringClassTypeName() {\n-        Class<?> c = getDeclaringClass();\n-        if (PrimitiveClass.isPrimitiveClass(c)) {\n-            c = PrimitiveClass.asValueType(c);\n-        }\n-        return c.getTypeName();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -135,1 +134,0 @@\n-        assert PrimitiveClass.isPrimaryType(declaringClass);\n@@ -357,1 +355,1 @@\n-            + getDeclaringClassTypeName() + \".\"\n+            + getDeclaringClass().getTypeName() + \".\"\n@@ -363,9 +361,1 @@\n-        return \"field \" + getDeclaringClassTypeName() + \".\" + getName();\n-    }\n-\n-    String getDeclaringClassTypeName() {\n-        Class<?> c = getDeclaringClass();\n-        if (PrimitiveClass.isPrimitiveClass(c)) {\n-            c = PrimitiveClass.asValueType(c);\n-        }\n-        return c.getTypeName();\n+        return \"field \" + getDeclaringClass().getTypeName() + \".\" + getName();\n@@ -399,1 +389,1 @@\n-            + getDeclaringClassTypeName() + \".\"\n+            + getDeclaringClass().getTypeName() + \".\"\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -137,1 +136,0 @@\n-        assert PrimitiveClass.isPrimaryType(declaringClass);\n@@ -427,1 +425,1 @@\n-        sb.append(getDeclaringClassTypeName()).append('.');\n+        sb.append(getDeclaringClass().getTypeName()).append('.');\n@@ -433,1 +431,1 @@\n-        return \"method \" + getDeclaringClassTypeName() +\n+        return \"method \" + getDeclaringClass().getTypeName() +\n@@ -496,1 +494,1 @@\n-        sb.append(getDeclaringClassTypeName()).append('.');\n+        sb.append(getDeclaringClass().getTypeName()).append('.');\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-        return (mod & VALUE) != 0;\n+        return (mod & IDENTITY) == 0;\n@@ -343,1 +343,1 @@\n-    public static final int VALUE            = 0x00000040;\n+   public static final int VALUE            = 0x00000040;\n@@ -422,2 +422,1 @@\n-        Modifier.IDENTITY       | Modifier.VALUE        |\n-        Modifier.STRICT;\n+        Modifier.IDENTITY       | Modifier.STRICT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -878,1 +877,1 @@\n-            if (type == null || PrimitiveClass.asPrimaryType(type) != PrimitiveClass.asPrimaryType(c)) {\n+            if (type != c) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -902,5 +901,1 @@\n-                String internalName = dotToSlash(type.getName());\n-                if (PrimitiveClass.isPrimitiveValueType(type)) {\n-                    internalName = 'Q' + internalName + \";\";\n-                }\n-                mv.visitTypeInsn(CHECKCAST, internalName);\n+                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));\n@@ -974,7 +969,0 @@\n-            if (PrimitiveClass.isPrimitiveValueType(cl)) {\n-                mv.visitMethodInsn(INVOKESTATIC,\n-                      \"jdk\/internal\/value\/PrimitiveClass\",\n-                      \"asValueType\", \"(Ljava\/lang\/Class;)Ljava\/lang\/Class;\",\n-                      false);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n@@ -421,2 +419,1 @@\n-        Class<?> receiverType = PrimitiveClass.isPrimitiveClass(recordClass)\n-                ? PrimitiveClass.asValueType(recordClass) : recordClass;\n+        Class<?> receiverType = recordClass;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -141,1 +140,1 @@\n-                  .filter(ft -> isValueClass(ft) && !result.contains(ft))\n+                  .filter(ft -> ft.isValue() && !result.contains(ft))\n@@ -175,2 +174,1 @@\n-            \/\/ ensure the reference type of a primitive class not used in the method handle\n-            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+            assert type.isValue();\n@@ -204,2 +202,1 @@\n-            \/\/ ensure the reference type of a primitive class not used in the method handle\n-            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+            assert type.isValue();\n@@ -239,3 +236,0 @@\n-                if (PrimitiveClass.isPrimitiveClass(type)) {\n-                    type = PrimitiveClass.asValueType(type);\n-                }\n@@ -369,1 +363,1 @@\n-            assert isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type);\n+            assert type.isValue();\n@@ -1132,3 +1126,0 @@\n-            if (PrimitiveClass.isPrimitiveClass(type)) {\n-                type = PrimitiveClass.asValueType(type);\n-            }\n@@ -1175,1 +1166,1 @@\n-        if (type.isPrimitive())\n+        if (type.isPrimitive()) {\n@@ -1177,2 +1168,2 @@\n-\n-        if (isValueClass(type) || PrimitiveClass.isPrimitiveValueType(type)) {\n+        }\n+        if (type.isValue()) {\n@@ -1213,1 +1204,1 @@\n-        Class<?> c = o.getClass();\n+        Class<?> type = o.getClass();\n@@ -1217,2 +1208,2 @@\n-            if (!c.isValue())\n-                throw new InternalError(\"must be value or primitive class: \" + c.getName());\n+            if (!type.isValue())\n+                throw new InternalError(\"must be value class: \" + type.getName());\n@@ -1220,1 +1211,0 @@\n-            Class<?> type = PrimitiveClass.isPrimitiveClass(c) ? PrimitiveClass.asValueType(c) : c;\n@@ -1230,7 +1220,0 @@\n-    \/**\n-     * Returns true if the given type is a value class.\n-     *\/\n-    private static boolean isValueClass(Class<?> type) {\n-        return type.isValue() && !PrimitiveClass.isPrimitiveClass(type);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ValueObjectMethods.java","additions":10,"deletions":27,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -571,33 +571,0 @@\n-    \/**\n-     * {@return the primary class for a primitive class}\n-     *\n-     * @param klass a class\n-     *\/\n-    Class<?> asPrimaryType(Class<?> klass);\n-\n-    \/**\n-     * {@return the value type of a primitive class}\n-     *\n-     * @param klass a class\n-     *\/\n-    Class<?> asValueType(Class<?> klass);\n-\n-    \/**\n-     * {@return true if the class is the primary type of a primitive class}\n-     *\n-     * @param klass a class\n-     *\/\n-    boolean isPrimaryType(Class<?> klass);\n-\n-    \/**\n-     * {@return true if the class is the primary type of a primitive class}\n-     *\n-     * @param klass a class\n-     *\/\n-    boolean isPrimitiveValueType(Class<?> klass);\n-\n-    \/**\n-     * Returns {@code true} if this class is a primitive class.\n-     *\/\n-    boolean isPrimitiveClass(Class<?> klass);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -276,1 +275,2 @@\n-        if (ref == null && PrimitiveClass.isPrimitiveValueType(type)) {\n+        \/\/ TODO: implicit constructible value object\n+        if (ref == null && type.isValue()) {\n@@ -286,1 +286,2 @@\n-        if (ref == null && PrimitiveClass.isPrimitiveValueType(type)) {\n+        \/\/ TODO: implicit constructible value object\n+        if (ref == null && type.isValue()) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n@@ -54,1 +52,0 @@\n-    private boolean    isStaticFactory;\n@@ -74,1 +71,0 @@\n-        boolean isStaticFactory = declaringClass.isValue();\n@@ -79,1 +75,1 @@\n-                     isStaticFactory ? PrimitiveClass.asValueType(declaringClass) : Void.TYPE,\n+                     Void.TYPE,\n@@ -82,1 +78,0 @@\n-                     isStaticFactory,\n@@ -95,1 +90,0 @@\n-                                       boolean isStaticFactory,\n@@ -106,1 +100,0 @@\n-        this.isStaticFactory = isStaticFactory;\n@@ -399,1 +392,1 @@\n-        if (isConstructor && !isStaticFactory) {\n+        if (isConstructor) {\n@@ -589,1 +582,1 @@\n-        if (isConstructor && !isStaticFactory) {\n+        if (isConstructor) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/SerializationConstructorAccessorGenerator.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.value;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n-\n-import java.lang.constant.ClassDesc;\n-\n-\/**\n- * Utilities to access Primitive Classes as described in JEP 401.\n- *\/\n-public class PrimitiveClass {\n-\n-    \/**\n-     * ACC_PRIMITIVE modifier defined by JEP 401. Subject to change.\n-     *\/\n-    public static final int PRIMITIVE_CLASS = 0x00000800;\n-\n-    private static final JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n-\n-\n-    \/**\n-     * Returns a {@code Class} object representing the primary type\n-     * of this class or interface.\n-     * <p>\n-     * If this {@code Class} object represents a primitive type or an array type,\n-     * then this method returns this class.\n-     * <p>\n-     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass(Class)\n-     * primitive class}, then this method returns the <em>primitive reference type<\/em>\n-     * type of this primitive class.\n-     * <p>\n-     * Otherwise, this {@code Class} object represents a non-primitive class or interface\n-     * and this method returns this class.\n-     *\n-     * @param aClass a class\n-     * @return the {@code Class} representing the primary type of\n-     *         this class or interface\n-     * @since Valhalla\n-     *\/\n-    @IntrinsicCandidate\n-    public static Class<?> asPrimaryType(Class<?> aClass) {\n-        return javaLangAccess.asPrimaryType(aClass);\n-    }\n-\n-    \/**\n-     * Returns a {@code Class} object representing the <em>primitive value type<\/em>\n-     * of this class if this class is a {@linkplain #isPrimitiveClass(Class)}  primitive class}.\n-     *\n-     * @apiNote Alternatively, this method returns null if this class is not\n-     *          a primitive class rather than throwing UOE.\n-     *\n-     * @param aClass a class\n-     * @return the {@code Class} representing the {@linkplain #isPrimitiveValueType(Class)\n-     * primitive value type} of this class if this class is a primitive class\n-     * @throws UnsupportedOperationException if this class or interface\n-     *         is not a primitive class\n-     * @since Valhalla\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    @IntrinsicCandidate\n-    public static Class<?> asValueType(Class<?> aClass) {\n-        return javaLangAccess.asValueType(aClass);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@code Class} object represents the primary type\n-     * of this class or interface.\n-     * <p>\n-     * If this {@code Class} object represents a primitive type or an array type,\n-     * then this method returns {@code true}.\n-     * <p>\n-     * If this {@code Class} object represents a {@linkplain #isPrimitiveClass(Class)\n-     * primitive}, then this method returns {@code true} if this {@code Class}\n-     * object represents a primitive reference type, or returns {@code false}\n-     * if this {@code Class} object represents a primitive value type.\n-     * <p>\n-     * If this {@code Class} object represents a non-primitive class or interface,\n-     * then this method returns {@code true}.\n-     *\n-     * @param aClass a class\n-     * @return {@code true} if this {@code Class} object represents\n-     * the primary type of this class or interface\n-     * @since Valhalla\n-     *\/\n-    public static boolean isPrimaryType(Class<?> aClass) {\n-        return javaLangAccess.isPrimaryType(aClass);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@code Class} object represents\n-     * a {@linkplain #isPrimitiveClass(Class)  primitive} value type.\n-     *\n-     * @return {@code true} if this {@code Class} object represents\n-     * the value type of a primitive class\n-     * @since Valhalla\n-     *\/\n-    public static boolean isPrimitiveValueType(Class<?> aClass) {\n-        return javaLangAccess.isPrimitiveValueType(aClass);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this class is a primitive class.\n-     * <p>\n-     * Each primitive class has a {@linkplain #isPrimaryType(Class)  primary type}\n-     * representing the <em>primitive reference type<\/em> and a\n-     * {@linkplain #isPrimitiveValueType(Class)  secondary type} representing\n-     * the <em>primitive value type<\/em>.  The primitive reference type\n-     * and primitive value type can be obtained by calling the\n-     * {@link #asPrimaryType(Class)} and {@link PrimitiveClass#asValueType} method\n-     * of a primitive class respectively.\n-     * <p>\n-     * A primitive class is a {@linkplain Class#isValue() value class}.\n-     *\n-     * @param aClass a class\n-     * @return {@code true} if this class is a primitive class, otherwise {@code false}\n-     * @see Class#isValue()\n-     * @see #asPrimaryType(Class)\n-     * @see #asValueType(Class)\n-     * @since Valhalla\n-     *\/\n-    public static boolean isPrimitiveClass(Class<?> aClass) {\n-        return javaLangAccess.isPrimitiveClass(aClass);\n-    }\n-\n-    \/**\n-     * Returns whether this {@linkplain ClassDesc} describes a\n-     * {@linkplain #isPrimitiveValueType(Class)}  primitive value type}.\n-     *\n-     * @return whether this {@linkplain ClassDesc} describes a primitive value type.\n-     * @since Valhalla\n-     *\/\n-    public static boolean isPrimitiveValueClassDesc(ClassDesc classDesc) {\n-        return classDesc.descriptorString().startsWith(\"Q\");\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/value\/PrimitiveClass.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n@@ -89,1 +87,1 @@\n-        if (c == 'L' || c == 'Q') {\n+        if (c == 'L') {\n@@ -95,2 +93,1 @@\n-                Class<?> clz = Class.forName(name, false, loader);\n-                return c == 'Q' ? PrimitiveClass.asValueType(clz) : PrimitiveClass.asPrimaryType(clz);\n+                return Class.forName(name, false, loader);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/BytecodeDescriptor.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -110,1 +109,1 @@\n-        if (PrimitiveClass.asPrimaryType(defc) == lookupClass  &&\n+        if (defc == lookupClass  &&\n@@ -145,1 +144,1 @@\n-            assert (canAccess && PrimitiveClass.asPrimaryType(refc) == PrimitiveClass.asPrimaryType(defc)) || !canAccess;\n+            assert (canAccess && refc == defc) || !canAccess;\n@@ -153,1 +152,1 @@\n-        return (PrimitiveClass.asPrimaryType(refc) == PrimitiveClass.asPrimaryType(lookupClass) ||\n+        return (refc == lookupClass ||\n@@ -278,1 +277,1 @@\n-        if (PrimitiveClass.asPrimaryType(type) == PrimitiveClass.asPrimaryType(refc)) {\n+        if (type == refc) {\n@@ -326,1 +325,0 @@\n-\n@@ -339,1 +337,1 @@\n-        return (PrimitiveClass.asPrimaryType(type) == res);\n+        return (type == res);\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.value.PrimitiveClass;\n@@ -654,3 +653,0 @@\n-        if (PrimitiveClass.isPrimitiveClass(f.getDeclaringClass())) {\n-            throw new UnsupportedOperationException(\"can't get field offset on a primitive class: \" + f);\n-        }\n@@ -696,3 +692,0 @@\n-        if (PrimitiveClass.isPrimitiveClass(f.getDeclaringClass())) {\n-            throw new UnsupportedOperationException(\"can't get static field offset on a primitive class: \" + f);\n-        }\n@@ -730,3 +723,0 @@\n-        if (PrimitiveClass.isPrimitiveClass(f.getDeclaringClass())) {\n-            throw new UnsupportedOperationException(\"can't get base address on a primitive class: \" + f);\n-        }\n","filename":"src\/jdk.unsupported\/share\/classes\/sun\/misc\/Unsafe.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary LambdaMetaFactory rejects value or identity superinterface\n- * @modules jdk.compiler\n- * @library \/test\/lib\n- * @build jdk.test.lib.Utils\n- *        jdk.test.lib.compiler.CompilerUtils\n- * @run junit LambdaMetaFactoryTest\n- *\/\n-\n-import jdk.test.lib.compiler.CompilerUtils;\n-import jdk.test.lib.Utils;\n-\n-import java.io.IOException;\n-import java.lang.invoke.LambdaConversionException;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import org.junit.jupiter.api.*;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-public class LambdaMetaFactoryTest {\n-    private static final Path SRC_DIR = Paths.get(Utils.TEST_SRC);\n-    private static final Path CLASSES_DIR = Paths.get(\"classes\");\n-\n-    @BeforeAll\n-    static void setup() throws IOException {\n-        \/\/ IdentityRunnable and ValueRunnable under the src directory are non-identity\n-        \/\/ and non-value interface to get Test class to compile\n-        assertTrue(CompilerUtils.compile(SRC_DIR.resolve(\"src\"), CLASSES_DIR));\n-\n-        \/\/ compile the proper version of IdentityRunnable and ValueRunnable\n-        assertTrue(CompilerUtils.compile(SRC_DIR.resolve(\"patch\"), CLASSES_DIR));\n-    }\n-\n-    @Test\n-    public void testValueRunnable() throws Throwable {\n-        URLClassLoader loader = new URLClassLoader(\"loader\",\n-                                                   new URL[]{ CLASSES_DIR.toUri().toURL()},\n-                                                   ClassLoader.getPlatformClassLoader());\n-        Class<?> testClass = Class.forName(\"Test\", false, loader);\n-        Method m = testClass.getMethod(\"testValueRunnable\");\n-        try {\n-            m.invoke(null);\n-        } catch (InvocationTargetException e) {\n-            Throwable bme = e.getCause();\n-            assertTrue(bme.getCause() instanceof LambdaConversionException);\n-            assertTrue(bme.getCause().getMessage().contains(\"ValueRunnable is a value interface\"));\n-        }\n-    }\n-\n-    @Test\n-    public void testIdentityRunnable() throws Throwable {\n-        URLClassLoader loader = new URLClassLoader(\"loader\",\n-                                                   new URL[]{ CLASSES_DIR.toUri().toURL()},\n-                                                   ClassLoader.getPlatformClassLoader());\n-        Class<?> testClass = Class.forName(\"Test\", false, loader);\n-        Method m = testClass.getMethod(\"testIdentityRunnable\");\n-        try {\n-            m.invoke(null);\n-        } catch (InvocationTargetException e) {\n-            Throwable bme = e.getCause();\n-            assertTrue(bme.getCause() instanceof LambdaConversionException);\n-            assertTrue(bme.getCause().getMessage().contains(\"IdentityRunnable is an identity interface\"));\n-        }\n-    }\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaMetaFactory\/LambdaMetaFactoryTest.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public identity interface IdentityRunnable {\n-    void run();\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaMetaFactory\/patch\/IdentityRunnable.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public value interface ValueRunnable {\n-     void run();\n-}\n","filename":"test\/jdk\/valhalla\/valuetypes\/LambdaMetaFactory\/patch\/ValueRunnable.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -46,2 +46,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ObjectMethodsViaCondy.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,7 +32,0 @@\n-import java.lang.constant.DirectMethodHandleDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandleInfo;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n@@ -41,2 +34,0 @@\n-import jdk.internal.value.PrimitiveClass;\n-\n","filename":"test\/jdk\/valhalla\/valuetypes\/ValueConstantDesc.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}