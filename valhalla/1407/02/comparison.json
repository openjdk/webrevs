{"files":[{"patch":"@@ -98,2 +98,2 @@\n-bool ciInlineKlass::has_non_atomic_layout() const {\n-  GUARDED_VM_ENTRY(return get_InlineKlass()->has_non_atomic_layout();)\n+bool ciInlineKlass::has_null_free_non_atomic_layout() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->has_null_free_non_atomic_layout();)\n@@ -102,2 +102,2 @@\n-bool ciInlineKlass::has_atomic_layout() const {\n-  GUARDED_VM_ENTRY(return get_InlineKlass()->has_atomic_layout();)\n+bool ciInlineKlass::has_null_free_atomic_layout() const {\n+  GUARDED_VM_ENTRY(return get_InlineKlass()->has_null_free_atomic_layout();)\n@@ -118,1 +118,1 @@\n-  assert(!null_free || vk->has_atomic_layout(), \"No null-free atomic layout available\");\n+  assert(!null_free || vk->has_null_free_atomic_layout(), \"No null-free atomic layout available\");\n@@ -120,1 +120,1 @@\n-  int size = null_free ? vk->atomic_size_in_bytes() : vk->nullable_atomic_size_in_bytes();\n+  int size = null_free ? vk->null_free_atomic_size_in_bytes() : vk->nullable_atomic_size_in_bytes();\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-  bool has_non_atomic_layout() const;\n-  bool has_atomic_layout() const;\n+  bool has_null_free_non_atomic_layout() const;\n+  bool has_null_free_atomic_layout() const;\n","filename":"src\/hotspot\/share\/ci\/ciInlineKlass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -5517,4 +5517,5 @@\n-    vk->set_non_atomic_size_in_bytes(_layout_info->_non_atomic_size_in_bytes);\n-    vk->set_non_atomic_alignment(_layout_info->_non_atomic_alignment);\n-    vk->set_atomic_size_in_bytes(_layout_info->_atomic_layout_size_in_bytes);\n-    vk->set_nullable_size_in_bytes(_layout_info->_nullable_layout_size_in_bytes);\n+    vk->set_null_free_non_atomic_size_in_bytes(_layout_info->_null_free_non_atomic_size_in_bytes);\n+    vk->set_null_free_non_atomic_alignment(_layout_info->_null_free_non_atomic_alignment);\n+    vk->set_null_free_atomic_size_in_bytes(_layout_info->_null_free_atomic_layout_size_in_bytes);\n+    vk->set_nullable_atomic_size_in_bytes(_layout_info->_nullable_atomic_layout_size_in_bytes);\n+    vk->set_nullable_non_atomic_size_in_bytes(_layout_info->_nullable_non_atomic_layout_size_in_bytes);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,4 +83,5 @@\n-  int _non_atomic_size_in_bytes;\n-  int _non_atomic_alignment;\n-  int _atomic_layout_size_in_bytes;\n-  int _nullable_layout_size_in_bytes;\n+  int _null_free_non_atomic_size_in_bytes;\n+  int _null_free_non_atomic_alignment;\n+  int _null_free_atomic_layout_size_in_bytes;\n+  int _nullable_atomic_layout_size_in_bytes;\n+  int _nullable_non_atomic_layout_size_in_bytes;\n@@ -98,2 +99,3 @@\n-                      _non_atomic_size_in_bytes(-1), _non_atomic_alignment(-1),\n-                      _atomic_layout_size_in_bytes(-1), _nullable_layout_size_in_bytes(-1),\n+                      _null_free_non_atomic_size_in_bytes(-1), _null_free_non_atomic_alignment(-1),\n+                      _null_free_atomic_layout_size_in_bytes(-1), _nullable_atomic_layout_size_in_bytes(-1),\n+                      _nullable_non_atomic_layout_size_in_bytes(-1),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,1 +41,6 @@\n-                                         bool use_atomic_flat) {\n+                                         bool can_use_atomic_flat) {\n+\n+  \/\/ The can_use_atomic_flat argument indicates if an atomic flat layout can be used for this field.\n+  \/\/ This argument will be false if the container is a loosely consistent value class. Using an atomic layout\n+  \/\/ in a container that has no atomicity guarantee creates a risk to see this field's value be subject to\n+  \/\/ tearing even if the field's class was declared atomic (non loosely consistent).\n@@ -68,2 +73,2 @@\n-      if (vk->is_naturally_atomic() && vk->has_non_atomic_layout()) return LayoutKind::NULL_FREE_NON_ATOMIC_FLAT;\n-      return (vk->has_atomic_layout() && use_atomic_flat) ? LayoutKind::NULL_FREE_ATOMIC_FLAT : LayoutKind::REFERENCE;\n+      if (vk->is_naturally_atomic() && vk->has_null_free_non_atomic_layout()) return LayoutKind::NULL_FREE_NON_ATOMIC_FLAT;\n+      return (vk->has_null_free_atomic_layout() && can_use_atomic_flat) ? LayoutKind::NULL_FREE_ATOMIC_FLAT : LayoutKind::REFERENCE;\n@@ -71,1 +76,1 @@\n-      return vk->has_non_atomic_layout() ? LayoutKind::NULL_FREE_NON_ATOMIC_FLAT : LayoutKind::REFERENCE;\n+      return vk->has_null_free_non_atomic_layout() ? LayoutKind::NULL_FREE_NON_ATOMIC_FLAT : LayoutKind::REFERENCE;\n@@ -74,0 +79,10 @@\n+    \/\/ To preserve the consistency between the null-marker and the field content, the NULLABLE_NON_ATOMIC_FLAT\n+    \/\/ can only be used in containers that have atomicity quarantees (can_use_atomic_flat argument set to true)\n+    if (field_info.access_flags().is_strict() && field_info.access_flags().is_final() && can_use_atomic_flat) {\n+      if (vk->has_nullable_non_atomic_layout()) return LayoutKind::NULLABLE_NON_ATOMIC_FLAT;\n+    }\n+    \/\/ Another special case where NULLABLE_NON_ATOMIC_FLAT can be used: nullable empty values, because the\n+    \/\/ payload of those values contains only the null-marker\n+    if (vk->is_empty_inline_type() && vk->has_nullable_non_atomic_layout()) {\n+      return LayoutKind::NULLABLE_NON_ATOMIC_FLAT;\n+    }\n@@ -75,1 +90,1 @@\n-      return use_atomic_flat ? LayoutKind::NULLABLE_ATOMIC_FLAT : LayoutKind::REFERENCE;\n+      return can_use_atomic_flat ? LayoutKind::NULLABLE_ATOMIC_FLAT : LayoutKind::REFERENCE;\n@@ -85,2 +100,2 @@\n-      *size = vk->non_atomic_size_in_bytes();\n-      *alignment = vk->non_atomic_alignment();\n+      *size = vk->null_free_non_atomic_size_in_bytes();\n+      *alignment = vk->null_free_non_atomic_alignment();\n@@ -89,1 +104,1 @@\n-      *size = vk->atomic_size_in_bytes();\n+      *size = vk->null_free_atomic_size_in_bytes();\n@@ -95,1 +110,5 @@\n-    break;\n+      break;\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n+      *size = vk->nullable_non_atomic_size_in_bytes();\n+      *alignment = vk->null_free_non_atomic_alignment();\n+      break;\n@@ -736,4 +755,5 @@\n-  _non_atomic_layout_size_in_bytes(-1),\n-  _non_atomic_layout_alignment(-1),\n-  _atomic_layout_size_in_bytes(-1),\n-  _nullable_layout_size_in_bytes(-1),\n+  _null_free_non_atomic_layout_size_in_bytes(-1),\n+  _null_free_non_atomic_layout_alignment(-1),\n+  _null_free_atomic_layout_size_in_bytes(-1),\n+  _nullable_atomic_layout_size_in_bytes(-1),\n+  _nullable_non_atomic_layout_size_in_bytes(-1),\n@@ -1141,2 +1161,2 @@\n-      _non_atomic_layout_size_in_bytes = _payload_size_in_bytes;\n-      _non_atomic_layout_alignment = _payload_alignment;\n+      _null_free_non_atomic_layout_size_in_bytes = _payload_size_in_bytes;\n+      _null_free_non_atomic_layout_alignment = _payload_alignment;\n@@ -1149,1 +1169,1 @@\n-        _atomic_layout_size_in_bytes = atomic_size;\n+        _null_free_atomic_layout_size_in_bytes = atomic_size;\n@@ -1153,2 +1173,2 @@\n-    \/\/ Next step is the nullable layout: the layout must include a null marker and must also be atomic\n-    if (UseNullableValueFlattening) {\n+    \/\/ Next step is the nullable layouts: they must include a null marker\n+    if (UseNullableValueFlattening || UseNullableNonAtomicValueFlattening) {\n@@ -1156,1 +1176,0 @@\n-      \/\/ FIXME: could it be possible to re-use the .empty field as a null marker for empty values?\n@@ -1185,2 +1204,2 @@\n-\n-      \/\/ Now that the null marker is there, the size of the nullable layout must computed (remember, must be atomic too)\n+      assert(null_marker_offset != -1, \"Sanity check\");\n+      \/\/ Now that the null marker is there, the size of the nullable layout must computed\n@@ -1188,3 +1207,2 @@\n-      int nullable_size = round_up_power_of_2(new_raw_size);\n-      if (nullable_size <= (int)MAX_ATOMIC_OP_SIZE) {\n-        _nullable_layout_size_in_bytes = nullable_size;\n+      if (UseNullableNonAtomicValueFlattening) {\n+        _nullable_non_atomic_layout_size_in_bytes = new_raw_size;\n@@ -1192,1 +1210,11 @@\n-      } else {\n+        _null_free_non_atomic_layout_alignment = _payload_alignment;\n+      }\n+      if (UseNullableValueFlattening) {\n+        \/\/ For the nullable atomic layout, the size mut be compatible with the platform capabilities\n+        int nullable_atomic_size = round_up_power_of_2(new_raw_size);\n+        if (nullable_atomic_size <= (int)MAX_ATOMIC_OP_SIZE) {\n+          _nullable_atomic_layout_size_in_bytes = nullable_atomic_size;\n+          _null_marker_offset = null_marker_offset;\n+        }\n+      }\n+      if (_null_marker_offset == -1) { \/\/ No nullable layout has been accepted\n@@ -1198,1 +1226,0 @@\n-        _null_marker_offset = -1;\n@@ -1201,1 +1228,1 @@\n-    \/\/ If the inline class has an atomic or nullable (which is also atomic) layout,\n+    \/\/ If the inline class has an atomic or nullable atomic layout,\n@@ -1203,1 +1230,1 @@\n-    \/\/ could remain  simple (single instruction without intermediate copy). This might required\n+    \/\/ could remain simple (single instruction without intermediate copy). This might required\n@@ -1209,2 +1236,2 @@\n-    if (has_atomic_layout() && _payload_alignment < atomic_layout_size_in_bytes()) {\n-      required_alignment = atomic_layout_size_in_bytes();\n+    if (has_null_free_atomic_layout() && _payload_alignment < null_free_atomic_layout_size_in_bytes()) {\n+      required_alignment = null_free_atomic_layout_size_in_bytes();\n@@ -1212,2 +1239,2 @@\n-    if (has_nullable_atomic_layout() && _payload_alignment < nullable_layout_size_in_bytes()) {\n-      required_alignment = nullable_layout_size_in_bytes();\n+    if (has_nullable_atomic_layout() && _payload_alignment < nullable_atomic_layout_size_in_bytes()) {\n+      required_alignment = nullable_atomic_layout_size_in_bytes();\n@@ -1221,1 +1248,1 @@\n-        if (has_nullable_atomic_layout()) {\n+        if (has_nullable_atomic_layout() || has_nullable_non_atomic_layout()) {\n@@ -1227,2 +1254,2 @@\n-        _atomic_layout_size_in_bytes = -1;\n-        if (has_nullable_atomic_layout() && !_is_empty_inline_class) {  \/\/ empty values don't have a dedicated NULL_MARKER block\n+        _null_free_atomic_layout_size_in_bytes = -1;\n+        if (has_nullable_atomic_layout() && !has_nullable_non_atomic_layout() && !_is_empty_inline_class) {  \/\/ empty values don't have a dedicated NULL_MARKER block\n@@ -1230,0 +1257,1 @@\n+          _null_marker_offset = -1;\n@@ -1231,2 +1259,1 @@\n-        _nullable_layout_size_in_bytes = -1;\n-        _null_marker_offset = -1;\n+        _nullable_atomic_layout_size_in_bytes = -1;\n@@ -1241,2 +1268,2 @@\n-    if (has_nullable_atomic_layout() && payload_layout_size_in_bytes() < nullable_layout_size_in_bytes()) {\n-      _payload_size_in_bytes = nullable_layout_size_in_bytes();\n+    if (has_nullable_atomic_layout() && payload_layout_size_in_bytes() < nullable_atomic_layout_size_in_bytes()) {\n+      _payload_size_in_bytes = nullable_atomic_layout_size_in_bytes();\n@@ -1483,4 +1510,5 @@\n-    _info->_non_atomic_size_in_bytes = _non_atomic_layout_size_in_bytes;\n-    _info->_non_atomic_alignment = _non_atomic_layout_alignment;\n-    _info->_atomic_layout_size_in_bytes = _atomic_layout_size_in_bytes;\n-    _info->_nullable_layout_size_in_bytes = _nullable_layout_size_in_bytes;\n+    _info->_null_free_non_atomic_size_in_bytes = _null_free_non_atomic_layout_size_in_bytes;\n+    _info->_null_free_non_atomic_alignment = _null_free_non_atomic_layout_alignment;\n+    _info->_null_free_atomic_layout_size_in_bytes = _null_free_atomic_layout_size_in_bytes;\n+    _info->_nullable_atomic_layout_size_in_bytes = _nullable_atomic_layout_size_in_bytes;\n+    _info->_nullable_non_atomic_layout_size_in_bytes = _nullable_non_atomic_layout_size_in_bytes;\n@@ -1555,1 +1583,1 @@\n-      if (has_non_atomic_flat_layout()) {\n+      if (has_null_free_non_atomic_flat_layout()) {\n@@ -1558,1 +1586,1 @@\n-                    _non_atomic_layout_size_in_bytes, _non_atomic_layout_alignment);\n+                    _null_free_non_atomic_layout_size_in_bytes, _null_free_non_atomic_layout_alignment);\n@@ -1563,1 +1591,1 @@\n-      if (has_atomic_layout()) {\n+      if (has_null_free_atomic_layout()) {\n@@ -1566,1 +1594,1 @@\n-                    _atomic_layout_size_in_bytes, _atomic_layout_size_in_bytes);\n+                    _null_free_atomic_layout_size_in_bytes, _null_free_atomic_layout_size_in_bytes);\n@@ -1574,1 +1602,1 @@\n-                    _nullable_layout_size_in_bytes, _nullable_layout_size_in_bytes);\n+                    _nullable_atomic_layout_size_in_bytes, _nullable_atomic_layout_size_in_bytes);\n@@ -1579,0 +1607,8 @@\n+      if (has_nullable_non_atomic_layout()) {\n+        st.print_cr(\"%s layout: %d\/%d\",\n+                    LayoutKindHelper::layout_kind_as_string(LayoutKind::NULLABLE_NON_ATOMIC_FLAT),\n+                    _nullable_non_atomic_layout_size_in_bytes, _null_free_non_atomic_layout_alignment);\n+      } else {\n+        st.print_cr(\"%s layout: -\/-\",\n+                    LayoutKindHelper::layout_kind_as_string(LayoutKind::NULLABLE_NON_ATOMIC_FLAT));\n+      }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":84,"deletions":48,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,4 +296,5 @@\n-  int _non_atomic_layout_size_in_bytes;\n-  int _non_atomic_layout_alignment;\n-  int _atomic_layout_size_in_bytes;\n-  int _nullable_layout_size_in_bytes;\n+  int _null_free_non_atomic_layout_size_in_bytes;\n+  int _null_free_non_atomic_layout_alignment;\n+  int _null_free_atomic_layout_size_in_bytes;\n+  int _nullable_atomic_layout_size_in_bytes;\n+  int _nullable_non_atomic_layout_size_in_bytes;\n@@ -321,1 +322,1 @@\n-  int payload_offset() const               { assert(_payload_offset != -1, \"Uninitialized\"); return _payload_offset; }\n+  int  payload_offset() const                  { assert(_payload_offset != -1, \"Uninitialized\"); return _payload_offset; }\n@@ -324,7 +325,9 @@\n-  bool has_non_atomic_flat_layout() const      { return _non_atomic_layout_size_in_bytes != -1; }\n-  int  non_atomic_layout_size_in_bytes() const { return _non_atomic_layout_size_in_bytes; }\n-  int  non_atomic_layout_alignment() const     { return _non_atomic_layout_alignment; }\n-  bool has_atomic_layout() const               { return _atomic_layout_size_in_bytes != -1; }\n-  int  atomic_layout_size_in_bytes() const     { return _atomic_layout_size_in_bytes; }\n-  bool has_nullable_atomic_layout() const      { return _nullable_layout_size_in_bytes != -1; }\n-  int  nullable_layout_size_in_bytes() const   { return _nullable_layout_size_in_bytes; }\n+  bool has_null_free_non_atomic_flat_layout() const      { return _null_free_non_atomic_layout_size_in_bytes != -1; }\n+  int  null_free_non_atomic_layout_size_in_bytes() const { return _null_free_non_atomic_layout_size_in_bytes; }\n+  int  null_free_non_atomic_layout_alignment() const     { return _null_free_non_atomic_layout_alignment; }\n+  bool has_null_free_atomic_layout() const               { return _null_free_atomic_layout_size_in_bytes != -1; }\n+  int  null_free_atomic_layout_size_in_bytes() const     { return _null_free_atomic_layout_size_in_bytes; }\n+  bool has_nullable_atomic_layout() const      { return _nullable_atomic_layout_size_in_bytes != -1; }\n+  int  nullable_atomic_layout_size_in_bytes() const { return _nullable_atomic_layout_size_in_bytes; }\n+  bool has_nullable_non_atomic_layout() const  { return _nullable_non_atomic_layout_size_in_bytes != -1; }\n+  int  nullable_non_atomic_layout_size_in_bytes() const { return _nullable_non_atomic_layout_size_in_bytes; }\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+  assert(lk != LayoutKind::NULLABLE_NON_ATOMIC_FLAT, \"Layout not supported by arrays yet (needs frozen arrays)\");\n@@ -86,0 +87,2 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n+      ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/oops\/flatArrayKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,4 +67,5 @@\n-    _non_atomic_size_in_bytes(-1),\n-    _non_atomic_alignment(-1),\n-    _atomic_size_in_bytes(-1),\n-    _nullable_size_in_bytes(-1),\n+    _null_free_non_atomic_size_in_bytes(-1),\n+    _null_free_non_atomic_alignment(-1),\n+    _null_free_atomic_size_in_bytes(-1),\n+    _nullable_atomic_size_in_bytes(-1),\n+    _nullable_non_atomic_size_in_bytes(-1),\n@@ -135,2 +136,2 @@\n-      assert(has_non_atomic_layout(), \"Layout not available\");\n-      return non_atomic_size_in_bytes();\n+      assert(has_null_free_non_atomic_layout(), \"Layout not available\");\n+      return null_free_non_atomic_size_in_bytes();\n@@ -139,2 +140,2 @@\n-      assert(has_atomic_layout(), \"Layout not available\");\n-      return atomic_size_in_bytes();\n+      assert(has_null_free_atomic_layout(), \"Layout not available\");\n+      return null_free_atomic_size_in_bytes();\n@@ -146,0 +147,4 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n+      assert(has_nullable_non_atomic_layout(), \"Layout not available\");\n+      return nullable_non_atomic_size_in_bytes();\n+      break;\n@@ -157,2 +162,2 @@\n-      assert(has_non_atomic_layout(), \"Layout not available\");\n-      return non_atomic_alignment();\n+      assert(has_null_free_non_atomic_layout(), \"Layout not available\");\n+      return null_free_non_atomic_alignment();\n@@ -161,2 +166,2 @@\n-      assert(has_atomic_layout(), \"Layout not available\");\n-      return atomic_size_in_bytes();\n+      assert(has_null_free_atomic_layout(), \"Layout not available\");\n+      return null_free_atomic_size_in_bytes();\n@@ -168,0 +173,4 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n+      assert(has_nullable_non_atomic_layout(), \"Layout not available\");\n+      return null_free_non_atomic_alignment();\n+    break;\n@@ -179,1 +188,1 @@\n-      return has_non_atomic_layout();\n+      return has_null_free_non_atomic_layout();\n@@ -182,1 +191,1 @@\n-      return has_atomic_layout();\n+      return has_null_free_atomic_layout();\n@@ -187,0 +196,3 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n+      return has_nullable_non_atomic_layout();\n+      break;\n@@ -199,0 +211,1 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n@@ -241,0 +254,1 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n@@ -303,1 +317,1 @@\n-  if (!has_nullable_atomic_layout() && !has_atomic_layout() && !has_non_atomic_layout()) {\n+  if (!has_nullable_atomic_layout() && !has_null_free_atomic_layout() && !has_null_free_non_atomic_layout()) {\n@@ -320,1 +334,1 @@\n-  return has_nullable_atomic_layout() && has_atomic_layout() && has_non_atomic_layout();\n+  return has_nullable_atomic_layout() && has_null_free_atomic_layout() && has_null_free_non_atomic_layout();\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,4 +91,5 @@\n-    int _non_atomic_size_in_bytes; \/\/ size of null-free non-atomic flat layout\n-    int _non_atomic_alignment;     \/\/ alignment requirement for null-free non-atomic layout\n-    int _atomic_size_in_bytes;     \/\/ size and alignment requirement for a null-free atomic layout, -1 if no atomic flat layout is possible\n-    int _nullable_size_in_bytes;   \/\/ size and alignment requirement for a nullable layout (always atomic), -1 if no nullable flat layout is possible\n+    int _null_free_non_atomic_size_in_bytes; \/\/ size of null-free non-atomic flat layout\n+    int _null_free_non_atomic_alignment;     \/\/ alignment requirement for null-free non-atomic layout\n+    int _null_free_atomic_size_in_bytes;     \/\/ size and alignment requirement for a null-free atomic layout, -1 if no atomic flat layout is possible\n+    int _nullable_atomic_size_in_bytes;      \/\/ size and alignment requirement for a nullable layout (always atomic), -1 if no nullable flat layout is possible\n+    int _nullable_non_atomic_size_in_bytes;  \/\/ size and alignment requirement for a nullable non-atomic layout, -1 if not available\n@@ -165,3 +166,3 @@\n-  int non_atomic_size_in_bytes() const                        { return members()._non_atomic_size_in_bytes; }\n-  void set_non_atomic_size_in_bytes(int size)                 { members()._non_atomic_size_in_bytes = size; }\n-  bool has_non_atomic_layout() const                          { return non_atomic_size_in_bytes() != -1; }\n+  int null_free_non_atomic_size_in_bytes() const              { return members()._null_free_non_atomic_size_in_bytes; }\n+  void set_null_free_non_atomic_size_in_bytes(int size)       { members()._null_free_non_atomic_size_in_bytes = size; }\n+  bool has_null_free_non_atomic_layout() const                { return null_free_non_atomic_size_in_bytes() != -1; }\n@@ -169,2 +170,2 @@\n-  int non_atomic_alignment() const                            { return members()._non_atomic_alignment; }\n-  void set_non_atomic_alignment(int alignment)                { members()._non_atomic_alignment = alignment; }\n+  int null_free_non_atomic_alignment() const                  { return members()._null_free_non_atomic_alignment; }\n+  void set_null_free_non_atomic_alignment(int alignment)      { members()._null_free_non_atomic_alignment = alignment; }\n@@ -172,3 +173,3 @@\n-  int atomic_size_in_bytes() const                            { return members()._atomic_size_in_bytes; }\n-  void set_atomic_size_in_bytes(int size)                     { members()._atomic_size_in_bytes = size; }\n-  bool has_atomic_layout() const                              { return atomic_size_in_bytes() != -1; }\n+  int null_free_atomic_size_in_bytes() const                  { return members()._null_free_atomic_size_in_bytes; }\n+  void set_null_free_atomic_size_in_bytes(int size)           { members()._null_free_atomic_size_in_bytes = size; }\n+  bool has_null_free_atomic_layout() const                    { return null_free_atomic_size_in_bytes() != -1; }\n@@ -176,3 +177,2 @@\n-  \/\/ FIXME: These names are not consistent w.r.t the atomic part.\n-  int nullable_atomic_size_in_bytes() const                   { return members()._nullable_size_in_bytes; }\n-  void set_nullable_size_in_bytes(int size)                   { members()._nullable_size_in_bytes = size; }\n+  int nullable_atomic_size_in_bytes() const                   { return members()._nullable_atomic_size_in_bytes; }\n+  void set_nullable_atomic_size_in_bytes(int size)            { members()._nullable_atomic_size_in_bytes = size; }\n@@ -181,0 +181,4 @@\n+  int nullable_non_atomic_size_in_bytes() const               { return members()._nullable_non_atomic_size_in_bytes; }\n+  void set_nullable_non_atomic_size_in_bytes(int size)        { members()._nullable_non_atomic_size_in_bytes = size; }\n+  bool has_nullable_non_atomic_layout() const                 { return nullable_non_atomic_size_in_bytes() != -1; }\n+\n@@ -185,0 +189,4 @@\n+  bool supports_nullable_layouts() const {\n+    return has_nullable_non_atomic_layout() || has_nullable_atomic_layout();\n+  }\n+\n@@ -186,1 +194,1 @@\n-    assert(has_nullable_atomic_layout(), \" Must have\");\n+    assert(supports_nullable_layouts(), \" Must do\");\n@@ -191,0 +199,1 @@\n+    assert(supports_nullable_layouts(), \" Must do\");\n@@ -195,0 +204,1 @@\n+    assert(supports_nullable_layouts(), \" Must do\");\n@@ -199,0 +209,1 @@\n+    assert(supports_nullable_layouts(), \" Must do\");\n","filename":"src\/hotspot\/share\/oops\/inlineKlass.hpp","additions":28,"deletions":17,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1466,1 +1466,1 @@\n-      if (vk->has_nullable_atomic_layout()) {\n+      if (vk->supports_nullable_layouts()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n+      return \"NULLABLE_NON_ATOMIC_FLAT\";\n","filename":"src\/hotspot\/share\/oops\/layoutKind.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-\/\/ REFERENCE : this layout uses a pointer to a heap allocated instance (no flattening).\n+\/\/ REFERENCE : This layout uses a pointer to a heap allocated instance (no flattening).\n@@ -41,1 +41,1 @@\n-\/\/ NULL_FREE_NON_ATOMIC_FLAT : this layout is the simplest form of flattening. Any field embedded inside the flat field\n+\/\/ NULL_FREE_NON_ATOMIC_FLAT : This layout is the simplest form of flattening. Any field embedded inside the flat field\n@@ -44,1 +44,1 @@\n-\/\/ NULL_FREE_ATOMIC_FLAT : this flat layout is designed for atomic updates, with size and alignment that make use of\n+\/\/ NULL_FREE_ATOMIC_FLAT : This flat layout is designed for atomic updates, with size and alignment that make use of\n@@ -48,1 +48,1 @@\n-\/\/ NULLABLE_ATOMIC_FLAT : this is the flat layout designed for JEP 401. It is designed for atomic updates,\n+\/\/ NULLABLE_ATOMIC_FLAT : This is the flat layout designed for JEP 401. It is designed for atomic updates,\n@@ -69,0 +69,11 @@\n+\/\/ NULLABLE_NON_ATOMIC_FLAT: This is a special layout, only used for strict final non-static fields. Because strict\n+\/\/             final non-static fields cannot be updated after the call to the super constructor, there's no\n+\/\/             concurrency issue on those fields, so they can be flattened even if they are nullable. During the\n+\/\/             construction of the instance, the uninitializedThis reference cannot escape before the call to\n+\/\/             the super's constructor, so no concurrent reads are possible when the field is initialized. After\n+\/\/             the call to the super's constructor, no update is possible because the field is strict and final,\n+\/\/             so no write possible during a read. This field has a null marker similar to the one of the\n+\/\/             NULLABLE_ATOMIC_FLAT layout. However, there's no requirement to read the null marker and the\n+\/\/             rest of the value atomically. If the null marker indicates a non-null value, the fields of the\n+\/\/             field's value can be read independently. Same rules for a putfield, no atomicity requirement,\n+\/\/             as long as all fields and the null marker are up to date at the end of the putfield.\n@@ -82,1 +93,2 @@\n-  UNKNOWN                   = 5     \/\/ used for uninitialized fields of type LayoutKind\n+  NULLABLE_NON_ATOMIC_FLAT  = 5,    \/\/ flat, include a null marker, non-atomic, only used for strict final non-static fields\n+  UNKNOWN                   = 6     \/\/ used for uninitialized fields of type LayoutKind\n@@ -89,1 +101,2 @@\n-                 || lk == LayoutKind::NULL_FREE_ATOMIC_FLAT || lk == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+                 || lk == LayoutKind::NULL_FREE_ATOMIC_FLAT\n+                 || lk == LayoutKind::NULLABLE_ATOMIC_FLAT || lk == LayoutKind::NULLABLE_NON_ATOMIC_FLAT;\n@@ -95,1 +108,1 @@\n-    return lk == LayoutKind::NULLABLE_ATOMIC_FLAT;\n+    return lk == LayoutKind::NULLABLE_ATOMIC_FLAT || lk == LayoutKind::NULLABLE_NON_ATOMIC_FLAT;\n","filename":"src\/hotspot\/share\/oops\/layoutKind.hpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,2 @@\n+    case LayoutKind::NULLABLE_NON_ATOMIC_FLAT:\n+      ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-      if (vk->has_non_atomic_layout()) {\n+      if (vk->has_null_free_non_atomic_layout()) {\n@@ -195,1 +195,1 @@\n-      } else if (vk->has_atomic_layout()) {\n+      } else if (vk->has_null_free_atomic_layout()) {\n@@ -202,1 +202,1 @@\n-      if (vk->is_naturally_atomic() && vk->has_non_atomic_layout()) {\n+      if (vk->is_naturally_atomic() && vk->has_null_free_non_atomic_layout()) {\n@@ -204,1 +204,1 @@\n-      } else if (vk->has_atomic_layout()) {\n+      } else if (vk->has_null_free_atomic_layout()) {\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1884,1 +1884,1 @@\n-  if (!elem_vk->has_atomic_layout() && !elem_vk->has_nullable_atomic_layout()) {\n+  if (!elem_vk->has_null_free_atomic_layout() && !elem_vk->has_nullable_atomic_layout()) {\n@@ -1886,1 +1886,1 @@\n-  } else if (!elem_vk->has_nullable_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+  } else if (!elem_vk->has_nullable_atomic_layout() && !elem_vk->has_null_free_non_atomic_layout()) {\n@@ -1888,1 +1888,1 @@\n-  } else if (!elem_vk->has_atomic_layout() && !elem_vk->has_non_atomic_layout()) {\n+  } else if (!elem_vk->has_null_free_atomic_layout() && !elem_vk->has_null_free_non_atomic_layout()) {\n@@ -3886,1 +3886,1 @@\n-  assert(vk->has_atomic_layout() || vk->has_non_atomic_layout(), \"Can't be null-free and flat\");\n+  assert(vk->has_null_free_atomic_layout() || vk->has_null_free_non_atomic_layout(), \"Can't be null-free and flat\");\n@@ -3889,1 +3889,1 @@\n-  if (!vk->has_non_atomic_layout()) {\n+  if (!vk->has_null_free_non_atomic_layout()) {\n@@ -3891,1 +3891,1 @@\n-  } else if (!vk->has_atomic_layout()) {\n+  } else if (!vk->has_null_free_atomic_layout()) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-      assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n+      assert(vk->has_null_free_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n@@ -591,1 +591,1 @@\n-      assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n+      assert(vk->has_null_free_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n@@ -1256,1 +1256,1 @@\n-      assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n+      assert(vk->has_null_free_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n@@ -1270,1 +1270,1 @@\n-      assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n+      assert(vk->has_null_free_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -840,0 +840,3 @@\n+  product(bool, UseNullableNonAtomicValueFlattening, false,                 \\\n+           \"Allow the JVM to flatten some strict final non-static fields\")  \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java EmptyValueTest.java\n+ * @run main\/othervm -XX:+UseNullableNonAtomicValueFlattening EmptyValueTest\n+ *\/\n+\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import runtime.valhalla.inlinetypes.field_layout.FieldLayoutAnalyzer;\n+\n+public class EmptyValueTest {\n+\n+    static class TestRunner {\n+        public static void main(String[] args) throws Exception {\n+            Class testClass = Class.forName(\"EmptyValueTest\");\n+            Asserts.assertNotNull(testClass);\n+            Method[] testMethods = testClass.getMethods();\n+            for (Method test : testMethods) {\n+                if (test.getName().startsWith(\"test_\")) {\n+                    Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+                    Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+                    System.out.println(\"Running \" + test.getName());\n+                    test.invoke(null);\n+                }\n+            }\n+        }\n+    }\n+\n+    static value class Empty0 {}\n+\n+    static class Container0 {\n+      Empty0 empty;\n+    }\n+\n+    static public void test_0() {\n+      Container0 c = new Container0();\n+      Asserts.assertNull(c.empty);\n+      c.empty = new Empty0();\n+      Asserts.assertNotNull(c.empty);\n+      c.empty = null;\n+      Asserts.assertNull(c.empty);\n+    }\n+\n+    static public void check_0(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"EmptyValueTest$Container0\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"empty\", false);\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f.layoutKind());\n+    }\n+\n+    static value class WrappedEmpty1 {\n+      @Strict\n+      @NullRestricted\n+      Empty0 empty = new Empty0();\n+    }\n+\n+    static class Container1 {\n+      WrappedEmpty1 we = new WrappedEmpty1();\n+    }\n+\n+    static public void test_1() {\n+      Container1 c = new Container1();\n+    }\n+\n+    static public void check_1(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"EmptyValueTest$Container1\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"we\", false);\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_ATOMIC_FLAT, f.layoutKind());\n+    }\n+\n+    static class Container2 {\n+      @Strict\n+      @NullRestricted\n+      WrappedEmpty1 we = new WrappedEmpty1();\n+    }\n+\n+    static public void test_2() {\n+      Container2 c = new Container2();\n+    }\n+\n+    static public void check_2(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"EmptyValueTest$Container2\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"we\", false);\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULL_FREE_NON_ATOMIC_FLAT, f.layoutKind());\n+    }\n+\n+    static ProcessBuilder exec(String... args) throws Exception {\n+        List<String> argsList = new ArrayList<>();\n+        Collections.addAll(argsList, \"--enable-preview\");\n+        Collections.addAll(argsList, \"-Xint\");\n+        Collections.addAll(argsList, \"-XX:+UnlockDiagnosticVMOptions\");\n+        Collections.addAll(argsList, \"-XX:+PrintFieldLayout\");\n+        Collections.addAll(argsList, \"-Xshare:off\");\n+        Collections.addAll(argsList, \"-Xmx256m\");\n+        Collections.addAll(argsList, \"-XX:+UseNullableNonAtomicValueFlattening\");\n+        Collections.addAll(argsList, \"-cp\", System.getProperty(\"java.class.path\") + System.getProperty(\"path.separator\") + \".\");\n+        Collections.addAll(argsList, args);\n+        return ProcessTools.createTestJavaProcessBuilder(argsList);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Generate test classes\n+        EmptyValueTest sft = new EmptyValueTest();\n+\n+        \/\/ Execute the test runner in charge of loading all test classes\n+        ProcessBuilder pb = exec(\"EmptyValueTest$TestRunner\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+\n+        if (out.getExitValue() != 0) {\n+            System.out.print(out.getOutput());\n+        }\n+        Asserts.assertEquals(out.getExitValue(), 0, \"Something went wrong while running the tests\");\n+\n+        \/\/ To help during test development\n+        System.out.print(out.getOutput());\n+\n+        \/\/ Get and parse the test output\n+        FieldLayoutAnalyzer.LogOutput lo = new FieldLayoutAnalyzer.LogOutput(out.asLines());\n+        FieldLayoutAnalyzer fla =  FieldLayoutAnalyzer.createFieldLayoutAnalyzer(lo);\n+\n+        \/\/ Running tests verification method (check that tests produced the right configuration)\n+        Class testClass = EmptyValueTest.class;\n+        Method[] testMethods = testClass.getMethods();\n+        for (Method test : testMethods) {\n+            if (test.getName().startsWith(\"check_\")) {\n+                Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+                Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+                test.invoke(null, fla);\n+            }\n+        }\n+\n+        \/\/ Verify that all layouts are correct\n+        fla.check();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/EmptyValueTest.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  static class LogOutput {\n+  public static class LogOutput {\n@@ -81,1 +81,1 @@\n-  static public enum LayoutKind {\n+  public static enum LayoutKind {\n@@ -85,1 +85,2 @@\n-    NULLABLE_ATOMIC_FLAT(true);\n+    NULLABLE_ATOMIC_FLAT(true),\n+    NULLABLE_NON_ATOMIC_FLAT(true);\n@@ -99,0 +100,1 @@\n+        case \"NULLABLE_NON_ATOMIC_FLAT\"  : return NULLABLE_NON_ATOMIC_FLAT;\n@@ -141,4 +143,0 @@\n-      \/\/ for(String  s : fieldLine) {\n-      \/\/   System.out.print(\"[\"+s+\"]\");  \/\/ debugging statement to be removed\n-      \/\/ }\n-      \/\/ System.out.println();\n@@ -189,1 +187,1 @@\n-  static class ClassLayout {\n+  public static class ClassLayout {\n@@ -201,2 +199,4 @@\n-    int nullableLayoutSize;          \/\/ -1 if no nullable layout\n-    int nullableLayoutAlignment;     \/\/ -1 if no nullable layout\n+    int nullableAtomicLayoutSize;          \/\/ -1 if no nullable layout\n+    int nullableAtomicLayoutAlignment;     \/\/ -1 if no nullable layout\n+    int nullableNonAtomicLayoutSize;\n+    int nullableNonAtomicLayoutAlignment;\n@@ -215,1 +215,2 @@\n-    boolean hasNullableLayout() { return nullableLayoutSize != -1; }\n+    boolean hasNullableAtomicLayout() { return nullableAtomicLayoutSize != -1; }\n+    boolean hasNullableNonAtomicLayout() { return nullableNonAtomicLayoutSize != -1; }\n@@ -229,2 +230,5 @@\n-          Asserts.assertTrue(nullableLayoutSize != -1);\n-          return nullableLayoutSize;\n+          Asserts.assertTrue(nullableAtomicLayoutSize != -1);\n+          return nullableAtomicLayoutSize;\n+        case NULLABLE_NON_ATOMIC_FLAT:\n+          Asserts.assertTrue(nullableNonAtomicLayoutSize != -1);\n+          return nullableNonAtomicLayoutSize;\n@@ -247,2 +251,5 @@\n-          Asserts.assertTrue(nullableLayoutSize != -1);\n-          return nullableLayoutAlignment;\n+          Asserts.assertTrue(nullableAtomicLayoutSize != -1);\n+          return nullableAtomicLayoutAlignment;\n+        case NULLABLE_NON_ATOMIC_FLAT:\n+          Asserts.assertTrue(nullableNonAtomicLayoutSize != -1);\n+          return nullableNonAtomicLayoutAlignment;\n@@ -336,1 +343,1 @@\n-        \/\/ NULLABLE_ATOMIC_FLAT layout: x\/y\n+        \/\/ Nullable atomic flat layout: x\/y\n@@ -338,2 +345,2 @@\n-        String[] nullableLayoutLine = lo.getCurrentLine().split(\"\\\\s+\");\n-        size_align = nullableLayoutLine[2].split(\"\/\");\n+        String[] nullableAtomicLayoutLine = lo.getCurrentLine().split(\"\\\\s+\");\n+        size_align = nullableAtomicLayoutLine[2].split(\"\/\");\n@@ -342,2 +349,2 @@\n-          cl.nullableLayoutSize = -1;\n-          cl.nullableLayoutAlignment = -1;\n+          cl.nullableAtomicLayoutSize = -1;\n+          cl.nullableAtomicLayoutAlignment = -1;\n@@ -345,2 +352,15 @@\n-          cl.nullableLayoutSize = Integer.parseInt(size_align[0]);\n-          cl.nullableLayoutAlignment = Integer.parseInt(size_align[1]);\n+          cl.nullableAtomicLayoutSize = Integer.parseInt(size_align[0]);\n+          cl.nullableAtomicLayoutAlignment = Integer.parseInt(size_align[1]);\n+        }\n+        lo.moveToNextLine();\n+        \/\/ Nullable non-atomic flat layout: x\/y\n+        Asserts.assertTrue(lo.getCurrentLine().startsWith(\"NULLABLE_NON_ATOMIC_FLAT layout\"));\n+        String[] nullableNonAtomicLayoutLine = lo.getCurrentLine().split(\"\\\\s+\");\n+        size_align = nullableNonAtomicLayoutLine[2].split(\"\/\");\n+        if (size_align[0].contentEquals(\"-\")) {\n+          Asserts.assertTrue(size_align[1].contentEquals(\"-\"), \"Size\/Alignment mismatch\");\n+          cl.nullableNonAtomicLayoutSize = -1;\n+          cl.nullableNonAtomicLayoutAlignment = -1;\n+        } else {\n+          cl.nullableNonAtomicLayoutSize = Integer.parseInt(size_align[0]);\n+          cl.nullableNonAtomicLayoutAlignment = Integer.parseInt(size_align[1]);\n@@ -350,1 +370,1 @@\n-        if (cl.nullableLayoutSize != -1) {\n+        if (cl.nullableAtomicLayoutSize != -1 || cl.nullableNonAtomicLayoutSize != -1) {\n@@ -361,1 +381,0 @@\n-\n@@ -375,1 +394,1 @@\n-    FieldBlock getFieldFromName(String fieldName, boolean isStatic) {\n+    public FieldBlock getFieldFromName(String fieldName, boolean isStatic) {\n@@ -422,1 +441,1 @@\n-  ClassLayout getClassLayoutFromName(String name) {\n+  public ClassLayout getClassLayoutFromName(String name) {\n@@ -666,1 +685,1 @@\n-            Asserts.assertTrue(layout.hasNullableLayout());\n+            Asserts.assertTrue(layout.hasNullableAtomicLayout() || layout.hasNullableNonAtomicLayout());\n@@ -686,1 +705,1 @@\n-  void check() {\n+  public void check() {\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/FieldLayoutAnalyzer.java","additions":48,"deletions":29,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @library \/test\/lib\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @enablePreview\n+ * @compile FieldLayoutAnalyzer.java StrictFinalTest.java\n+ * @run main\/othervm -XX:+UseNullableNonAtomicValueFlattening StrictFinalTest\n+ *\/\n+\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import jdk.internal.vm.annotation.LooselyConsistentValue;\n+import jdk.internal.vm.annotation.NullRestricted;\n+import jdk.internal.vm.annotation.Strict;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import runtime.valhalla.inlinetypes.field_layout.FieldLayoutAnalyzer;\n+\n+public class StrictFinalTest {\n+\n+    static class TestRunner {\n+        public static void main(String[] args) throws Exception {\n+            Class testClass = Class.forName(\"StrictFinalTest\");\n+            Asserts.assertNotNull(testClass);\n+            Method[] testMethods = testClass.getMethods();\n+            for (Method test : testMethods) {\n+                if (test.getName().startsWith(\"test_\")) {\n+                    Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+                    Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+                    System.out.println(\"Running \" + test.getName());\n+                    test.invoke(null);\n+                }\n+            }\n+        }\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Value0 {\n+        \/\/ bigger than 64 bits even without the null marker\n+        long i = 0;\n+        long j = 0;\n+    }\n+\n+    static value class Container0 {\n+        Value0 val0;\n+        Container0(Value0 v) {\n+          val0 = v;\n+        }\n+    }\n+\n+    static public void test_0() {\n+        var c = new Container0(null);\n+        Asserts.assertNull(c.val0);\n+        c = new Container0(new Value0());\n+        Asserts.assertNotNull(c.val0);\n+    }\n+\n+    static public void check_0(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container0\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f.layoutKind());\n+    }\n+\n+    static value class Value1 {\n+        \/\/ Just big enough to be bigger than 64 bits with the null marker\n+        int i = 0;\n+        int j = 0;\n+    }\n+\n+    static value class Container1 {\n+        Value1 val0;\n+        Container1(Value1 v) {\n+          val0 = v;\n+        }\n+    }\n+\n+    static public void test_1() {\n+        var c = new Container1(null);\n+        Asserts.assertNull(c.val0);\n+        c = new Container1(new Value1());\n+        Asserts.assertNotNull(c.val0);\n+    }\n+\n+    static public void check_1(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container1\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+        \/\/ Value classes' fields are always strict and final, must be flattened\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f.layoutKind());\n+    }\n+\n+    static class Container2 {\n+        Value1 val0;\n+    }\n+\n+\n+    static public void test_2() {\n+        Container2 c = new Container2();\n+        Asserts.assertNull(c.val0);\n+        c.val0 = new Value1();\n+        Asserts.assertNotNull(c.val0);\n+        c.val0 = null;\n+        Asserts.assertNull(c.val0);\n+    }\n+\n+    static public void check_2(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container2\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+        \/\/ Not strict nor final, must not be flattened\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    }\n+\n+    \/\/ Test temporarily disabled, to be be re-enabled when strict non-final fields are supported\n+    \/\/\n+    \/\/ static class Container3 {\n+    \/\/     @Strict\n+    \/\/     Value1 val0 = new Value1();\n+    \/\/ }\n+\n+\n+    \/\/ static public void test_3() {\n+    \/\/     Container3 c = new Container3();\n+    \/\/ }\n+\n+    \/\/ static public void check_3(FieldLayoutAnalyzer fla) {\n+    \/\/     FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container3\");\n+    \/\/     FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+    \/\/     \/\/ Not final, must not be flattened\n+    \/\/     Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    \/\/ }\n+\n+    static class Container4 {\n+        final Value1 val0;\n+        Container4(Value1 v) {\n+          val0 = v;\n+        }\n+    }\n+\n+\n+    static public void test_4() {\n+        var c = new Container4(null);\n+        Asserts.assertNull(c.val0);\n+        c = new Container4(new Value1());\n+        Asserts.assertNotNull(c.val0);\n+    }\n+\n+    static public void check_4(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container4\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+        \/\/ Not strict, must not be flattened\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    }\n+\n+    static class Container5 {\n+        @Strict\n+        final Value1 val0;\n+        Container5(Value1 v) {\n+          val0 = v;\n+        }\n+    }\n+\n+    static public void test_5() {\n+        var c = new Container5(new Value1());\n+        Asserts.assertNotNull(c.val0);\n+        c = new Container5(null);\n+        Asserts.assertNull(c.val0);\n+    }\n+\n+    static public void check_5(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container5\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+        \/\/ Strict and final, must be flattened\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f.layoutKind());\n+    }\n+\n+    static class Container6 {\n+        @Strict\n+        final Value1 val0 = null;\n+    }\n+\n+    static public void test_6() {\n+        Container6 c = new Container6();\n+        Asserts.assertNull(c.val0);\n+    }\n+\n+    static public void check_6(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container6\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+        \/\/ Strict and final, must be flattened\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NULLABLE_NON_ATOMIC_FLAT, f.layoutKind());\n+    }\n+\n+    @LooselyConsistentValue\n+    static value class Container7 {\n+        Value1 val0;\n+        Container7(Value1 v) {\n+          val0 = v;\n+        }\n+    }\n+\n+    static public void test_7() {\n+        var c = new Container7(new Value1());\n+        Asserts.assertNotNull(c.val0);\n+        c = new Container7(null);\n+        Asserts.assertNull(c.val0);\n+    }\n+\n+    static public void check_7(FieldLayoutAnalyzer fla) {\n+        FieldLayoutAnalyzer.ClassLayout cl = fla.getClassLayoutFromName(\"StrictFinalTest$Container7\");\n+        FieldLayoutAnalyzer.FieldBlock f = cl.getFieldFromName(\"val0\", false);\n+        \/\/ Container is not atomic, must not flattened\n+        Asserts.assertEquals(FieldLayoutAnalyzer.LayoutKind.NON_FLAT, f.layoutKind());\n+    }\n+\n+    static ProcessBuilder exec(String... args) throws Exception {\n+        List<String> argsList = new ArrayList<>();\n+        Collections.addAll(argsList, \"--enable-preview\");\n+        Collections.addAll(argsList, \"-Xint\");\n+        Collections.addAll(argsList, \"-XX:+UnlockDiagnosticVMOptions\");\n+        Collections.addAll(argsList, \"-XX:+PrintFieldLayout\");\n+        Collections.addAll(argsList, \"-Xshare:off\");\n+        Collections.addAll(argsList, \"-Xmx256m\");\n+        Collections.addAll(argsList, \"-XX:+UseNullableNonAtomicValueFlattening\");\n+        Collections.addAll(argsList, \"-cp\", System.getProperty(\"java.class.path\") + System.getProperty(\"path.separator\") + \".\");\n+        Collections.addAll(argsList, args);\n+        return ProcessTools.createTestJavaProcessBuilder(argsList);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Generate test classes\n+        StrictFinalTest sft = new StrictFinalTest();\n+\n+        \/\/ Execute the test runner in charge of loading all test classes\n+        ProcessBuilder pb = exec(\"StrictFinalTest$TestRunner\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+\n+        if (out.getExitValue() != 0) {\n+            System.out.print(out.getOutput());\n+        }\n+        Asserts.assertEquals(out.getExitValue(), 0, \"Something went wrong while running the tests\");\n+\n+        \/\/ To help during test development\n+        System.out.print(out.getOutput());\n+\n+        \/\/ Get and parse the test output\n+        FieldLayoutAnalyzer.LogOutput lo = new FieldLayoutAnalyzer.LogOutput(out.asLines());\n+        FieldLayoutAnalyzer fla =  FieldLayoutAnalyzer.createFieldLayoutAnalyzer(lo);\n+\n+        \/\/ Running tests verification method (check that tests produced the right configuration)\n+        Class testClass = StrictFinalTest.class;\n+        Method[] testMethods = testClass.getMethods();\n+        for (Method test : testMethods) {\n+            if (test.getName().startsWith(\"check_\")) {\n+                Asserts.assertTrue(Modifier.isStatic(test.getModifiers()));\n+                Asserts.assertTrue(test.getReturnType().equals(Void.TYPE));\n+                test.invoke(null, fla);\n+            }\n+        }\n+\n+        \/\/ Verify that all layouts are correct\n+        fla.check();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/StrictFinalTest.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/field_layout\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/TEST.properties","status":"copied"}]}