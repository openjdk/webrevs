{"files":[{"patch":"@@ -64,1 +64,1 @@\n-        \/\/ clone()\n+        \/\/ clone() - test the default implementation from j.l.Object\n@@ -66,0 +66,1 @@\n+        checkCloneable(new MyCloneableInt(78));\n@@ -111,1 +112,16 @@\n-        \/\/ Cloneable inline type checked by \"BadInlineTypes\" CFP tests\n+    }\n+\n+    static void checkCloneable(MyCloneableInt val) {\n+        boolean sawCnse = false;\n+        MyCloneableInt val2 = null;\n+        try {\n+            val2 = (MyCloneableInt)val.attemptClone();\n+        } catch (CloneNotSupportedException cnse) {\n+            sawCnse = true;\n+        }\n+        if (sawCnse) {\n+            throw new RuntimeException(\"clone() did fail\");\n+        }\n+        if (val != val2) {\n+            throw new RuntimeException(\"Cloned value is not identical to the original\");\n+        }\n@@ -235,0 +251,19 @@\n+    static value class MyCloneableInt implements Cloneable {\n+        int value;\n+        public MyCloneableInt(int v) { value = v; }\n+        public Object attemptClone() throws CloneNotSupportedException {\n+            try { \/\/ Check it is not possible to clone...\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+                MethodHandle mh = lookup.findVirtual(getClass(),\n+                                                     \"clone\",\n+                                                     MethodType.methodType(Object.class));\n+                return mh.invokeExact(this);\n+            } catch (Throwable t) {\n+                if (t instanceof CloneNotSupportedException) {\n+                    throw (CloneNotSupportedException) t;\n+                }\n+                throw new RuntimeException(t);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/valhalla\/inlinetypes\/ObjectMethods.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"}]}