{"files":[{"patch":"@@ -103,1 +103,1 @@\n-    --override-methods=summary --syntax-highlight\n+    --override-methods=summary\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    $1_$2_CDS_DUMP_FLAGS += -Xlog:cds+map*=trace:file=$$(JDK_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE).cdsmap:none:filesize=0\n+    $1_$2_CDS_DUMP_FLAGS += -Xlog:aot+map*=trace:file=$$(JDK_IMAGE_DIR)\/$$($1_$2_CDS_ARCHIVE).cdsmap:none:filesize=0\n","filename":"make\/Images.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,0 +311,4 @@\n+    private static final String REQUIRES_IDENTITY_ANNOTATION =\n+            \"Ljdk\/internal\/RequiresIdentity;\";\n+    private static final String REQUIRES_IDENTITY_ANNOTATION_INTERNAL =\n+            \"Ljdk\/internal\/RequiresIdentity+Annotation;\";\n@@ -318,1 +322,2 @@\n-                    RESTRICTED_ANNOTATION));\n+                    RESTRICTED_ANNOTATION,\n+                    REQUIRES_IDENTITY_ANNOTATION));\n@@ -1035,0 +1040,6 @@\n+        if (REQUIRES_IDENTITY_ANNOTATION.equals(annotationType)) {\n+            \/\/the non-public RequiresIdentity annotation will not be available in ct.sym,\n+            \/\/replace with purely synthetic javac-internal annotation:\n+            annotationType = REQUIRES_IDENTITY_ANNOTATION_INTERNAL;\n+        }\n+\n@@ -2216,0 +2227,1 @@\n+            case RuntimeVisibleTypeAnnotationsAttribute a -> {\/* do nothing for now *\/}\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-  sub(tmp1, tmp1, tmp2, ext::sxtw, 3);\n+  \/\/ For Cortex-A53 offset is 4 because 2 nops are generated.\n+  sub(tmp1, tmp1, tmp2, ext::sxtw, VM_Version::supports_a53mac() ? 4 : 3);\n@@ -139,0 +140,5 @@\n+    \/\/ maddw generates an extra nop for Cortex-A53 (see maddw definition in macroAssembler).\n+    \/\/ Generate 2nd nop to have 4 instructions per iteration.\n+    if (VM_Version::supports_a53mac()) {\n+      nop();\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2591,0 +2591,117 @@\n+  address generate_unsafecopy_common_error_exit() {\n+    address start_pc = __ pc();\n+      __ leave();\n+      __ mov(r0, 0);\n+      __ ret(lr);\n+    return start_pc;\n+  }\n+\n+  \/\/\n+  \/\/  Generate 'unsafe' set memory stub\n+  \/\/  Though just as safe as the other stubs, it takes an unscaled\n+  \/\/  size_t (# bytes) argument instead of an element count.\n+  \/\/\n+  \/\/  This fill operation is atomicity preserving: as long as the\n+  \/\/  address supplied is sufficiently aligned, all writes of up to 64\n+  \/\/  bits in size are single-copy atomic.\n+  \/\/\n+  \/\/  Input:\n+  \/\/    c_rarg0   - destination array address\n+  \/\/    c_rarg1   - byte count (size_t)\n+  \/\/    c_rarg2   - byte value\n+  \/\/\n+  address generate_unsafe_setmemory() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, StubGenStubId::unsafe_setmemory_id);\n+    address start = __ pc();\n+\n+    Register dest = c_rarg0, count = c_rarg1, value = c_rarg2;\n+    Label tail;\n+\n+    UnsafeMemoryAccessMark umam(this, true, false);\n+\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+    __ dup(v0, __ T16B, value);\n+\n+    if (AvoidUnalignedAccesses) {\n+      __ cmp(count, (u1)16);\n+      __ br(__ LO, tail);\n+\n+      __ mov(rscratch1, 16);\n+      __ andr(rscratch2, dest, 15);\n+      __ sub(rscratch1, rscratch1, rscratch2);  \/\/ Bytes needed to 16-align dest\n+      __ strq(v0, Address(dest));\n+      __ sub(count, count, rscratch1);\n+      __ add(dest, dest, rscratch1);\n+    }\n+\n+    __ subs(count, count, (u1)64);\n+    __ br(__ LO, tail);\n+    {\n+      Label again;\n+      __ bind(again);\n+      __ stpq(v0, v0, Address(dest));\n+      __ stpq(v0, v0, Address(dest, 32));\n+\n+      __ subs(count, count, 64);\n+      __ add(dest, dest, 64);\n+      __ br(__ HS, again);\n+    }\n+\n+    __ bind(tail);\n+    \/\/ The count of bytes is off by 64, but we don't need to correct\n+    \/\/ it because we're only going to use the least-significant few\n+    \/\/ count bits from here on.\n+    \/\/ __ add(count, count, 64);\n+\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(32), dont);\n+      __ stpq(v0, v0, __ post(dest, 32));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(16), dont);\n+      __ strq(v0, __ post(dest, 16));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(8), dont);\n+      __ strd(v0, __ post(dest, 8));\n+      __ bind(dont);\n+    }\n+\n+    Label finished;\n+    __ tst(count, 7);\n+    __ br(__ EQ, finished);\n+\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(4), dont);\n+      __ strs(v0, __ post(dest, 4));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(2), dont);\n+      __ bfi(value, value, 8, 8);\n+      __ strh(value, __ post(dest, 2));\n+      __ bind(dont);\n+    }\n+    {\n+      Label dont;\n+      __ tbz(count, exact_log2(1), dont);\n+      __ strb(value, Address(dest));\n+      __ bind(dont);\n+    }\n+\n+    __ bind(finished);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -2640,0 +2757,3 @@\n+    address ucm_common_error_exit       =  generate_unsafecopy_common_error_exit();\n+    UnsafeMemoryAccess::set_common_exit_stub_pc(ucm_common_error_exit);\n+\n@@ -8134,1 +8254,2 @@\n-    __ sub(rscratch1, rscratch1, rscratch2, ext::uxtw, 3);\n+    \/\/ For Cortex-A53 offset is 4 because 2 nops are generated.\n+    __ sub(rscratch1, rscratch1, rscratch2, ext::uxtw, VM_Version::supports_a53mac() ? 4 : 3);\n@@ -8142,0 +8263,5 @@\n+      \/\/ maddw generates an extra nop for Cortex-A53 (see maddw definition in macroAssembler).\n+      \/\/ Generate 2nd nop to have 4 instructions per iteration.\n+      if (VM_Version::supports_a53mac()) {\n+        __ nop();\n+      }\n@@ -11414,0 +11540,2 @@\n+    StubRoutines::_unsafe_setmemory = generate_unsafe_setmemory();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":129,"deletions":1,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -668,2 +668,7 @@\n-void InterpreterMacroAssembler::save_esp() {\n-  z_stg(Z_esp, Address(Z_fp, _z_ijava_state_neg(esp)));\n+void InterpreterMacroAssembler::save_esp(Register fp) {\n+  if (fp == noreg) {\n+    fp = Z_fp;\n+  }\n+  z_sgrk(Z_R0, Z_esp, fp);\n+  z_srag(Z_R0, Z_R0, Interpreter::logStackElementSize);\n+  z_stg(Z_R0, Address(fp, _z_ijava_state_neg(esp)));\n@@ -675,0 +680,2 @@\n+  z_slag(Z_esp, Z_esp, Interpreter::logStackElementSize);\n+  z_agr(Z_esp, Z_fp);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1358,10 +1358,1 @@\n-                                                      int constant,\n-                                                      bool decrement) {\n-  \/\/ Counter address\n-  Address data(mdp_in, constant);\n-\n-  increment_mdp_data_at(data, decrement);\n-}\n-\n-void InterpreterMacroAssembler::increment_mdp_data_at(Address data,\n-                                                      bool decrement) {\n+                                                      int constant) {\n@@ -1369,19 +1360,2 @@\n-  \/\/ %%% this does 64bit counters at best it is wasting space\n-  \/\/ at worst it is a rare bug when counters overflow\n-\n-  if (decrement) {\n-    \/\/ Decrement the register.  Set condition codes.\n-    addptr(data, -DataLayout::counter_increment);\n-    \/\/ If the decrement causes the counter to overflow, stay negative\n-    Label L;\n-    jcc(Assembler::negative, L);\n-    addptr(data, DataLayout::counter_increment);\n-    bind(L);\n-  } else {\n-    assert(DataLayout::counter_increment == 1,\n-           \"flow-free idiom only works with 1\");\n-    \/\/ Increment the register.  Set carry flag.\n-    addptr(data, DataLayout::counter_increment);\n-    \/\/ If the increment causes the counter to overflow, pull back by 1.\n-    sbbptr(data, 0);\n-  }\n+  Address data(mdp_in, constant);\n+  addptr(data, DataLayout::counter_increment);\n@@ -1392,6 +1366,5 @@\n-                                                      Register reg,\n-                                                      int constant,\n-                                                      bool decrement) {\n-  Address data(mdp_in, reg, Address::times_1, constant);\n-\n-  increment_mdp_data_at(data, decrement);\n+                                                      Register index,\n+                                                      int constant) {\n+  assert(ProfileInterpreter, \"must be profiling interpreter\");\n+  Address data(mdp_in, index, Address::times_1, constant);\n+  addptr(data, DataLayout::counter_increment);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -229,5 +229,2 @@\n-  void increment_mdp_data_at(Address data, bool decrement = false);\n-  void increment_mdp_data_at(Register mdp_in, int constant,\n-                             bool decrement = false);\n-  void increment_mdp_data_at(Register mdp_in, Register reg, int constant,\n-                             bool decrement = false);\n+  void increment_mdp_data_at(Register mdp_in, int constant);\n+  void increment_mdp_data_at(Register mdp_in, Register index, int constant);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4377,0 +4377,2 @@\n+  generate_kyber_stubs();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -493,1 +493,4 @@\n-  \/\/ Dilithium stubs and helper functions\n+  \/\/ Kyber stubs\n+  void generate_kyber_stubs();\n+\n+  \/\/ Dilithium stubs\n@@ -495,1 +498,1 @@\n-  \/\/ BASE64 stubs\n+  \/\/ BASE64 stubs\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1250,0 +1250,14 @@\n+  \/\/ Kyber Intrinsics\n+  \/\/ Currently we only have them for AVX512\n+#ifdef _LP64\n+  if (supports_evex() && supports_avx512bw()) {\n+      if (FLAG_IS_DEFAULT(UseKyberIntrinsics)) {\n+          UseKyberIntrinsics = true;\n+      }\n+  } else\n+#endif\n+  if (UseKyberIntrinsics) {\n+     warning(\"Intrinsics for ML-KEM are not available on this CPU.\");\n+     FLAG_SET_DEFAULT(UseKyberIntrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compilationLog.hpp\"\n@@ -655,0 +656,7 @@\n+  \/\/ record the bailout for hserr envlog\n+  if (CompilationLog::log() != nullptr) {\n+    CompilerThread* thread = CompilerThread::current();\n+    CompileTask* task = thread->task();\n+    CompilationLog::log()->log_failure(thread, task, msg, nullptr);\n+  }\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-    log_info(cds, heap)(\"archived obj root segment [%d] = %zu bytes, obj = \" PTR_FORMAT,\n+    log_info(aot, heap)(\"archived obj root segment [%d] = %zu bytes, obj = \" PTR_FORMAT,\n@@ -296,1 +296,1 @@\n-  log_info(cds)(\"sorting heap objects\");\n+  log_info(aot)(\"sorting heap objects\");\n@@ -306,1 +306,1 @@\n-  log_info(cds)(\"computed ranks\");\n+  log_info(aot)(\"computed ranks\");\n@@ -308,1 +308,1 @@\n-  log_info(cds)(\"sorting heap objects done\");\n+  log_info(aot)(\"sorting heap objects done\");\n@@ -333,1 +333,1 @@\n-  log_info(cds)(\"Size of heap region = %zu bytes, %d objects, %d roots, %d native ptrs\",\n+  log_info(aot)(\"Size of heap region = %zu bytes, %d objects, %d roots, %d native ptrs\",\n@@ -399,1 +399,1 @@\n-    log_info(cds, heap)(\"Inserting filler obj array of %d elements (%zu bytes total) @ buffer offset %zu\",\n+    log_info(aot, heap)(\"Inserting filler obj array of %d elements (%zu bytes total) @ buffer offset %zu\",\n@@ -477,1 +477,1 @@\n-      log_info(cds, heap)(\"Heap end = %p\", heap_end);\n+      log_info(aot, heap)(\"Heap end = %p\", heap_end);\n@@ -641,1 +641,1 @@\n-  log_info(cds)(\"%s = %7zu ... %7zu (%3zu%% ... %3zu%% = %3zu%%)\", which,\n+  log_info(aot)(\"%s = %7zu ... %7zu (%3zu%% ... %3zu%% = %3zu%%)\", which,\n@@ -768,1 +768,1 @@\n-  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers for heap region (%zu bits)\",\n+  log_info(aot, heap)(\"calculate_ptrmap: marked %d non-null native pointers for heap region (%zu bits)\",\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -114,0 +115,4 @@\n+    char jvm_path[JVM_MAXPATHLEN];\n+    os::jvm_path(jvm_path, sizeof(jvm_path));\n+    char *end = strrchr(jvm_path, *os::file_separator());\n+    if (end != nullptr) *end = '\\0';\n@@ -115,3 +120,1 @@\n-    const char* subdir = WINDOWS_ONLY(\"bin\") NOT_WINDOWS(\"lib\");\n-    tmp.print(\"%s%s%s%s%s%sclasses\", Arguments::get_java_home(), os::file_separator(), subdir,\n-              os::file_separator(), Abstract_VM_Version::vm_variant(), os::file_separator());\n+    tmp.print(\"%s%sclasses\", jvm_path, os::file_separator());\n@@ -244,1 +247,1 @@\n-            log_error(cds)(\"Not a valid archive (%s)\", SharedArchiveFile);\n+            aot_log_error(aot)(\"Not a valid %s (%s)\", type_of_archive_being_loaded(), SharedArchiveFile);\n@@ -288,1 +291,1 @@\n-    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n+    aot_log_info(aot)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n@@ -303,1 +306,1 @@\n-      log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+      aot_log_info(aot)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n@@ -373,1 +376,1 @@\n-        log_warning(cds)(\"AOT cache is disabled when the %s option is specified.\", option);\n+        aot_log_warning(aot)(\"AOT cache is disabled when the %s option is specified.\", option);\n@@ -375,1 +378,1 @@\n-        log_info(cds)(\"CDS is disabled when the %s option is specified.\", option);\n+        aot_log_info(aot)(\"CDS is disabled when the %s option is specified.\", option);\n@@ -435,1 +438,1 @@\n-    \/\/ AOTCache\/AOTConfiguration\/AOTMode not used.\n+    \/\/ AOTCache\/AOTConfiguration\/AOTMode not used -> using the \"classic CDS\" workflow.\n@@ -573,1 +576,1 @@\n-      log_info(cds)(\"reduced -Xcomp to -Xmixed for static dumping\");\n+      aot_log_info(aot)(\"reduced -Xcomp to -Xmixed for static dumping\");\n@@ -598,1 +601,1 @@\n-      log_warning(cds)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n+      aot_log_warning(aot)(\"-XX:+AutoCreateSharedArchive requires -XX:SharedArchiveFile\");\n@@ -602,1 +605,1 @@\n-      log_warning(cds)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n+      aot_log_warning(aot)(\"-XX:+AutoCreateSharedArchive does not work with ArchiveClassesAtExit\");\n@@ -618,1 +621,1 @@\n-      log_info(cds)(\"All non-system classes will be verified (-Xverify:remote) during CDS dump time.\");\n+      aot_log_info(aot)(\"All non-system classes will be verified (-Xverify:remote) during CDS dump time.\");\n@@ -639,1 +642,1 @@\n-      log_error(cds)(\"-XX:+RecordDynamicDumpInfo%s\", __THEMSG);\n+      aot_log_error(aot)(\"-XX:+RecordDynamicDumpInfo%s\", __THEMSG);\n@@ -643,1 +646,1 @@\n-      log_warning(cds)(\"-XX:ArchiveClassesAtExit\" __THEMSG);\n+      aot_log_warning(aot)(\"-XX:ArchiveClassesAtExit\" __THEMSG);\n@@ -790,1 +793,1 @@\n-  log_info(cds)(\"Archived java heap is not supported: %s\", reason);\n+  aot_log_info(aot)(\"Archived java heap is not supported: %s\", reason);\n@@ -844,1 +847,1 @@\n-      log_info(cds)(\"full module graph cannot be dumped: %s\", reason);\n+      aot_log_info(aot)(\"full module graph cannot be dumped: %s\", reason);\n@@ -854,1 +857,1 @@\n-      log_info(cds)(\"full module graph cannot be loaded: %s\", reason);\n+      aot_log_info(aot)(\"full module graph cannot be loaded: %s\", reason);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -71,1 +72,1 @@\n-  log_info(cds)(\"Parsing %s%s\", file,\n+  aot_log_info(aot)(\"Parsing %s%s\", file,\n@@ -166,1 +167,1 @@\n-    log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+    aot_log_warning(aot)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n@@ -170,1 +171,1 @@\n-    log_warning(cds)(\"Preload Warning: Cannot find %s\", _class_name);\n+    aot_log_warning(aot)(\"Preload Warning: Cannot find %s\", _class_name);\n@@ -175,1 +176,1 @@\n-  if (log_is_enabled(Trace, cds)) {\n+  if (aot_log_is_enabled(Trace, aot)) {\n@@ -177,1 +178,1 @@\n-    log_trace(cds)(\"Shared spaces preloaded: %s\", klass->external_name());\n+    log_trace(aot)(\"Shared spaces preloaded: %s\", klass->external_name());\n@@ -398,1 +399,1 @@\n-objArrayOop ClassListParser::get_specified_interfaces(TRAPS) {\n+GrowableArray<InstanceKlass *> ClassListParser::get_specified_interfaces() {\n@@ -400,8 +401,3 @@\n-  if (n == 0) {\n-    return nullptr;\n-  } else {\n-    objArrayOop array = oopFactory::new_objArray(vmClasses::Class_klass(), n, CHECK_NULL);\n-    for (int i = 0; i < n; i++) {\n-      array->obj_at_put(i, lookup_class_by_id(_interfaces->at(i))->java_mirror());\n-    }\n-    return array;\n+  GrowableArray<InstanceKlass *> specified_interfaces(n);\n+  for (int i = 0; i < n; i++) {\n+    specified_interfaces.append(lookup_class_by_id(_interfaces->at(i)));\n@@ -409,0 +405,1 @@\n+  return specified_interfaces;\n@@ -505,1 +502,1 @@\n-  LogTarget(Warning, cds, resolve) lt;\n+  LogTarget(Warning, aot, resolve) lt;\n@@ -512,0 +509,19 @@\n+\/\/ If an unregistered class U is specified to have a registered supertype S1\n+\/\/ named SN but an unregistered class S2 also named SN has already been loaded\n+\/\/ S2 will be incorrectly used as the supertype of U instead of S1 due to\n+\/\/ limitations in the loading mechanism of unregistered classes.\n+void ClassListParser::check_supertype_obstruction(int specified_supertype_id, const InstanceKlass* specified_supertype, TRAPS) {\n+  if (specified_supertype->is_shared_unregistered_class()) {\n+    return; \/\/ Only registered supertypes can be obstructed\n+  }\n+  const InstanceKlass* obstructor = SystemDictionaryShared::get_unregistered_class(specified_supertype->name());\n+  if (obstructor == nullptr) {\n+    return; \/\/ No unregistered types with the same name have been loaded, i.e. no obstruction\n+  }\n+  \/\/ 'specified_supertype' is S1, 'obstructor' is S2 from the explanation above\n+  ResourceMark rm;\n+  THROW_MSG(vmSymbols::java_lang_UnsupportedOperationException(),\n+            err_msg(\"%s (id %d) has super-type %s (id %d) obstructed by another class with the same name\",\n+                    _class_name, _id, specified_supertype->external_name(), specified_supertype_id));\n+}\n+\n@@ -530,1 +546,1 @@\n-    log_info(cds)(\"Prohibited package for non-bootstrap classes: %s.class from %s\",\n+    aot_log_info(aot)(\"Prohibited package for non-bootstrap classes: %s.class from %s\",\n@@ -536,6 +552,11 @@\n-  char * source_path = os::strdup_check_oom(ClassLoader::uri_to_path(_source));\n-  Handle super_class(THREAD, specified_super->java_mirror());\n-  objArrayOop r = get_specified_interfaces(CHECK_NULL);\n-  objArrayHandle interfaces(THREAD, r);\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path,\n-                                                     super_class, interfaces, CHECK_NULL);\n+  GrowableArray<InstanceKlass*> specified_interfaces = get_specified_interfaces();\n+  \/\/ Obstruction must be checked before the class loading attempt because it may\n+  \/\/ cause class loading errors (JVMS 5.3.5.3-5.3.5.4)\n+  check_supertype_obstruction(_super, specified_super, CHECK_NULL);\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    check_supertype_obstruction(_interfaces->at(i), specified_interfaces.at(i), CHECK_NULL);\n+  }\n+\n+  const char* source_path = ClassLoader::uri_to_path(_source);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+\n@@ -558,0 +579,9 @@\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    InstanceKlass* specified_interface = specified_interfaces.at(i);\n+    if (!k->local_interfaces()->contains(specified_interface)) {\n+      print_specified_interfaces();\n+      print_actual_interfaces(k);\n+      error(\"Specified interface %s (id %d) is not directly implemented\",\n+            specified_interface->external_name(), _interfaces->at(i));\n+      }\n+  }\n@@ -626,1 +656,1 @@\n-    log_warning(cds)(\"resolve_indy for class %s has encountered exception: %s %s\",\n+    aot_log_warning(aot)(\"resolve_indy for class %s has encountered exception: %s %s\",\n@@ -666,1 +696,1 @@\n-        log_debug(cds, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n+        log_debug(aot, lambda)(\"is_supported_invokedynamic check failed for cp_index %d\", pool_index);\n@@ -689,1 +719,1 @@\n-      log_warning(cds)(\"No invoke dynamic constant pool entry can be found for class %s. The classlist is probably out-of-date.\",\n+      aot_log_warning(aot)(\"No invoke dynamic constant pool entry can be found for class %s. The classlist is probably out-of-date.\",\n@@ -751,1 +781,1 @@\n-      log_info(cds, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->table_size());\n+      log_info(aot, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->table_size());\n@@ -855,1 +885,1 @@\n-    if (log_is_enabled(Warning, cds, resolve)) {\n+    if (log_is_enabled(Warning, aot, resolve)) {\n@@ -857,1 +887,1 @@\n-      log_warning(cds, resolve)(\"Cannot aot-resolve constants for %s because it is excluded\", ik->external_name());\n+      log_warning(aot, resolve)(\"Cannot aot-resolve constants for %s because it is excluded\", ik->external_name());\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":58,"deletions":28,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  log_debug(cds, vtables)(\"Copying %3d vtable entries for %s\", n, name);\n+  log_debug(aot, vtables)(\"Copying %3d vtable entries for %s\", n, name);\n@@ -175,1 +175,1 @@\n-  log_debug(cds, vtables)(\"Found   %3d vtable entries for %s\", vtable_len, name);\n+  log_debug(aot, vtables)(\"Found   %3d vtable entries for %s\", vtable_len, name);\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -408,1 +409,1 @@\n-      log_warning(cds)(\n+      aot_log_warning(aot)(\n@@ -414,1 +415,1 @@\n-        log_warning(cds)(\n+        aot_log_warning(aot)(\n@@ -469,1 +470,1 @@\n-      log_info(cds)(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n+      aot_log_info(aot)(\"Specified %s not found (%s)\", CDSConfig::type_of_archive_being_loaded(), _archive_name);\n@@ -486,1 +487,1 @@\n-      log_warning(cds)(\"Unable to read generic CDS file map header from %s\", file_type);\n+      aot_log_warning(aot)(\"Unable to read generic CDS file map header from %s\", file_type);\n@@ -493,1 +494,1 @@\n-      log_warning(cds)(\"The %s has a bad magic number: %#x\", file_type, gen_header._magic);\n+      aot_log_warning(aot)(\"The %s has a bad magic number: %#x\", file_type, gen_header._magic);\n@@ -498,1 +499,1 @@\n-      log_warning(cds)(\"Cannot handle %s version 0x%x. Must be at least 0x%x.\",\n+      aot_log_warning(aot)(\"Cannot handle %s version 0x%x. Must be at least 0x%x.\",\n@@ -504,1 +505,1 @@\n-      log_warning(cds)(\"The %s version 0x%x does not match the required version 0x%x.\",\n+      aot_log_warning(aot)(\"The %s version 0x%x does not match the required version 0x%x.\",\n@@ -510,1 +511,1 @@\n-      log_warning(cds)(\"Archive file header larger than archive file\");\n+      aot_log_warning(aot)(\"Archive file header larger than archive file\");\n@@ -520,1 +521,1 @@\n-      log_warning(cds)(\"Unable to read file map header from %s\", file_type);\n+      aot_log_warning(aot)(\"Unable to read file map header from %s\", file_type);\n@@ -565,3 +566,3 @@\n-        log_info(cds)(\"_crc expected: %d\", header->crc());\n-        log_info(cds)(\"       actual: %d\", actual_crc);\n-        log_warning(cds)(\"Header checksum verification failed.\");\n+        aot_log_info(aot)(\"_crc expected: %d\", header->crc());\n+        aot_log_info(aot)(\"       actual: %d\", actual_crc);\n+        aot_log_warning(aot)(\"Header checksum verification failed.\");\n@@ -580,1 +581,1 @@\n-      log_warning(cds)(\"base_archive_name offset\/size overflow: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+      aot_log_warning(aot)(\"base_archive_name offset\/size overflow: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n@@ -587,1 +588,1 @@\n-        log_warning(cds)(\"static shared archive must have zero _base_archive_name_offset\");\n+        aot_log_warning(aot)(\"static shared archive must have zero _base_archive_name_offset\");\n@@ -591,1 +592,1 @@\n-        log_warning(cds)(\"static shared archive must have zero _base_archive_name_size\");\n+        aot_log_warning(aot)(\"static shared archive must have zero _base_archive_name_size\");\n@@ -599,1 +600,1 @@\n-        log_warning(cds)(\"Invalid base_archive_name offset\/size: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n+        aot_log_warning(aot)(\"Invalid base_archive_name offset\/size: \" UINT32_FORMAT \"\/\" UINT32_FORMAT,\n@@ -605,1 +606,1 @@\n-          log_warning(cds)(\"Invalid base_archive_name offset\/size (out of range): \"\n+          aot_log_warning(aot)(\"Invalid base_archive_name offset\/size (out of range): \"\n@@ -612,1 +613,1 @@\n-          log_warning(cds)(\"Base archive name is damaged\");\n+          aot_log_warning(aot)(\"Base archive name is damaged\");\n@@ -616,1 +617,1 @@\n-          log_warning(cds)(\"Base archive %s does not exist\", name);\n+          aot_log_warning(aot)(\"Base archive %s does not exist\", name);\n@@ -651,1 +652,1 @@\n-     log_warning(cds)(\"AutoCreateSharedArchive is ignored because %s is a static archive\", archive_name);\n+     aot_log_warning(aot)(\"AutoCreateSharedArchive is ignored because %s is a static archive\", archive_name);\n@@ -679,1 +680,1 @@\n-    log_warning(cds)(\"Unable to read the file header.\");\n+    aot_log_warning(aot)(\"Unable to read the file header.\");\n@@ -691,1 +692,1 @@\n-        log_warning(cds)(\"Not a valid %s (%s)\", file_type, _full_path);\n+        aot_log_warning(aot)(\"Not a valid %s (%s)\", file_type, _full_path);\n@@ -693,1 +694,1 @@\n-        log_warning(cds)(\"Not a base shared archive: %s\", _full_path);\n+        aot_log_warning(aot)(\"Not a base shared archive: %s\", _full_path);\n@@ -699,1 +700,1 @@\n-      log_warning(cds)(\"Not a top shared archive: %s\", _full_path);\n+      aot_log_warning(aot)(\"Not a top shared archive: %s\", _full_path);\n@@ -709,1 +710,1 @@\n-    log_warning(cds)(\"Failed to read file header from the top archive file\\n\");\n+    aot_log_warning(aot)(\"Failed to read file header from the top archive file\\n\");\n@@ -714,3 +715,3 @@\n-    log_info(cds)(\"_version expected: 0x%x\", CURRENT_CDS_ARCHIVE_VERSION);\n-    log_info(cds)(\"           actual: 0x%x\", header()->version());\n-    log_warning(cds)(\"The %s has the wrong version.\", file_type);\n+    aot_log_info(aot)(\"_version expected: 0x%x\", CURRENT_CDS_ARCHIVE_VERSION);\n+    aot_log_info(aot)(\"           actual: 0x%x\", header()->version());\n+    aot_log_warning(aot)(\"The %s has the wrong version.\", file_type);\n@@ -725,4 +726,4 @@\n-      log_info(cds)(\"_header_size: \" UINT32_FORMAT, header_size);\n-      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, header()->base_archive_name_size());\n-      log_info(cds)(\"base_archive_name_offset: \" UINT32_FORMAT, header()->base_archive_name_offset());\n-      log_warning(cds)(\"The %s has an incorrect header size.\", file_type);\n+      aot_log_info(aot)(\"_header_size: \" UINT32_FORMAT, header_size);\n+      aot_log_info(aot)(\"base_archive_name_size: \" UINT32_FORMAT, header()->base_archive_name_size());\n+      aot_log_info(aot)(\"base_archive_name_offset: \" UINT32_FORMAT, header()->base_archive_name_offset());\n+      aot_log_warning(aot)(\"The %s has an incorrect header size.\", file_type);\n@@ -736,1 +737,1 @@\n-    log_warning(cds)(\"JVM version identifier is corrupted.\");\n+    aot_log_warning(aot)(\"JVM version identifier is corrupted.\");\n@@ -743,3 +744,3 @@\n-    log_info(cds)(\"_jvm_ident expected: %s\", expected_ident);\n-    log_info(cds)(\"             actual: %s\", actual_ident);\n-    log_warning(cds)(\"The %s was created by a different\"\n+    aot_log_info(aot)(\"_jvm_ident expected: %s\", expected_ident);\n+    aot_log_info(aot)(\"             actual: %s\", actual_ident);\n+    aot_log_warning(aot)(\"The %s was created by a different\"\n@@ -757,1 +758,1 @@\n-      log_warning(cds)(\"The %s has been truncated.\", file_type);\n+      aot_log_warning(aot)(\"The %s has been truncated.\", file_type);\n@@ -771,1 +772,1 @@\n-    log_error(cds)(\"Unable to seek to position %zu\", pos);\n+    aot_log_error(aot)(\"Unable to seek to position %zu\", pos);\n@@ -784,1 +785,1 @@\n-  log_info(cds)(\"trying to map %s%s\", info, _full_path);\n+  aot_log_info(aot)(\"trying to map %s%s\", info, _full_path);\n@@ -788,1 +789,1 @@\n-      log_info(cds)(\"Specified %s not found (%s)\", file_type, _full_path);\n+      aot_log_info(aot)(\"Specified %s not found (%s)\", file_type, _full_path);\n@@ -790,1 +791,1 @@\n-      log_warning(cds)(\"Failed to open %s (%s)\", file_type,\n+      aot_log_warning(aot)(\"Failed to open %s (%s)\", file_type,\n@@ -795,1 +796,1 @@\n-    log_info(cds)(\"Opened %s %s.\", file_type, _full_path);\n+    aot_log_info(aot)(\"Opened %s %s.\", file_type, _full_path);\n@@ -806,2 +807,1 @@\n-  LogMessage(cds) msg;\n-  if (msg.is_info()) {\n+  if (CDSConfig::new_aot_flags_used()) {\n@@ -809,1 +809,1 @@\n-      msg.info(\"Writing binary AOTConfiguration file: \");\n+      log_info(aot)(\"Writing binary AOTConfiguration file: %s\",  _full_path);\n@@ -811,1 +811,1 @@\n-      msg.info(\"Dumping shared data to file: \");\n+      log_info(aot)(\"Writing binary AOTConfiguration file: %s\",  _full_path);\n@@ -813,1 +813,2 @@\n-    msg.info(\"   %s\", _full_path);\n+  } else {\n+    aot_log_info(aot)(\"Dumping shared data to file: %s\", _full_path);\n@@ -825,1 +826,1 @@\n-    log_error(cds)(\"Unable to create %s %s: (%s).\", CDSConfig::type_of_archive_being_written(), _full_path,\n+    aot_log_error(aot)(\"Unable to create %s %s: (%s).\", CDSConfig::type_of_archive_being_written(), _full_path,\n@@ -891,1 +892,1 @@\n-    log_warning(cds)(\"Checksum verification failed.\");\n+    aot_log_warning(aot)(\"Checksum verification failed.\");\n@@ -913,1 +914,1 @@\n-  log_debug(cds, reloc)(\"mapped %s relocation %smap @ \" INTPTR_FORMAT \" (%zu bits)\",\n+  aot_log_debug(aot, reloc)(\"mapped %s relocation %smap @ \" INTPTR_FORMAT \" (%zu bits)\",\n@@ -981,1 +982,1 @@\n-    log_info(cds)(\"Shared file region (%s) %d: %8zu\"\n+    aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n@@ -986,1 +987,1 @@\n-     log_info(cds)(\"Shared file region (%s) %d: %8zu\"\n+     aot_log_info(aot)(\"Shared file region (%s) %d: %8zu\"\n@@ -1177,1 +1178,1 @@\n-    log_error(cds)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n+    aot_log_error(aot)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n@@ -1181,1 +1182,1 @@\n-    log_error(cds)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n+    aot_log_error(aot)(\"Unable to remap shared readonly space (errno=%d).\", errno);\n@@ -1212,1 +1213,1 @@\n-    log_info(cds)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\", is_static() ? \"static \" : \"dynamic\",\n+    aot_log_info(aot)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\", is_static() ? \"static \" : \"dynamic\",\n@@ -1229,1 +1230,1 @@\n-    log_info(cds)(\"Commit %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)%s\",\n+    aot_log_info(aot)(\"Commit %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)%s\",\n@@ -1233,1 +1234,1 @@\n-      log_error(cds)(\"Failed to commit %s region #%d (%s)\", is_static() ? \"static \" : \"dynamic\",\n+      aot_log_error(aot)(\"Failed to commit %s region #%d (%s)\", is_static() ? \"static \" : \"dynamic\",\n@@ -1282,1 +1283,1 @@\n-      log_info(cds)(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n+      aot_log_info(aot)(\"Failed to read %s shared space into reserved space at \" INTPTR_FORMAT,\n@@ -1296,1 +1297,1 @@\n-      log_info(cds)(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n+      aot_log_info(aot)(\"Unable to map %s shared space at \" INTPTR_FORMAT,\n@@ -1336,1 +1337,1 @@\n-    log_error(cds)(\"relocation bitmap CRC error\");\n+    aot_log_error(aot)(\"relocation bitmap CRC error\");\n@@ -1345,1 +1346,1 @@\n-  log_info(cds)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n+  aot_log_info(aot)(\"Mapped %s region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n@@ -1362,1 +1363,1 @@\n-      log_info(cds)(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n+      aot_log_info(aot)(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n@@ -1375,1 +1376,1 @@\n-    log_info(cds)(\"failed to map aot code region\");\n+    aot_log_info(aot)(\"failed to map aot code region\");\n@@ -1381,1 +1382,1 @@\n-    log_info(cds)(\"Mapped static  region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n+    aot_log_info(aot)(\"Mapped static  region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n@@ -1417,1 +1418,1 @@\n-  log_debug(cds, reloc)(\"runtime archive relocation start\");\n+  aot_log_debug(aot, reloc)(\"runtime archive relocation start\");\n@@ -1464,1 +1465,1 @@\n-    log_debug(cds, reloc)(\"runtime archive relocation done\");\n+    aot_log_debug(aot, reloc)(\"runtime archive relocation done\");\n@@ -1513,1 +1514,1 @@\n-  log_info(cds)(\"Requested heap region [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] = %8zu bytes\",\n+  aot_log_info(aot)(\"Requested heap region [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] = %8zu bytes\",\n@@ -1543,1 +1544,1 @@\n-      log_error(cds)(\"%s has aot-linked classes but the archived \"\n+      aot_log_error(aot)(\"%s has aot-linked classes but the archived \"\n@@ -1577,1 +1578,1 @@\n-  log_info(cds)(\"CDS archive was created with max heap size = %zuM, and the following configuration:\",\n+  aot_log_info(aot)(\"CDS archive was created with max heap size = %zuM, and the following configuration:\",\n@@ -1579,1 +1580,1 @@\n-  log_info(cds)(\"    narrow_klass_base at mapping start address, narrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_klass_base at mapping start address, narrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n@@ -1581,1 +1582,1 @@\n-  log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n@@ -1583,1 +1584,1 @@\n-  log_info(cds)(\"The current max heap size = %zuM, G1HeapRegion::GrainBytes = %zu\",\n+  aot_log_info(aot)(\"The current max heap size = %zuM, G1HeapRegion::GrainBytes = %zu\",\n@@ -1585,1 +1586,1 @@\n-  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", arrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_klass_base = \" PTR_FORMAT \", arrow_klass_pointer_bits = %d, narrow_klass_shift = %d\",\n@@ -1587,1 +1588,1 @@\n-  log_info(cds)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n+  aot_log_info(aot)(\"    narrow_oop_mode = %d, narrow_oop_base = \" PTR_FORMAT \", narrow_oop_shift = %d\",\n@@ -1589,1 +1590,1 @@\n-  log_info(cds)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+  aot_log_info(aot)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n@@ -1616,5 +1617,14 @@\n-    LogTarget(Info, cds) lt;\n-    if (lt.is_enabled()) {\n-      LogStream ls(lt);\n-      ls.print_raw(ss.base());\n-      header()->print(&ls);\n+    if (CDSConfig::new_aot_flags_used()) {\n+      LogTarget(Info, aot) lt;\n+      if (lt.is_enabled()) {\n+        LogStream ls(lt);\n+        ls.print_raw(ss.base());\n+        header()->print(&ls);\n+      }\n+    } else {\n+      LogTarget(Info, cds) lt;\n+      if (lt.is_enabled()) {\n+        LogStream ls(lt);\n+        ls.print_raw(ss.base());\n+        header()->print(&ls);\n+      }\n@@ -1707,1 +1717,1 @@\n-  log_info(cds)(\"Preferred address to map heap data (to avoid relocation) is \" INTPTR_FORMAT, p2i(requested_start));\n+  aot_log_info(aot)(\"Preferred address to map heap data (to avoid relocation) is \" INTPTR_FORMAT, p2i(requested_start));\n@@ -1728,1 +1738,1 @@\n-      log_error(cds)(\"Failed to read archived heap region into \" INTPTR_FORMAT, p2i(addr));\n+      aot_log_error(aot)(\"Failed to read archived heap region into \" INTPTR_FORMAT, p2i(addr));\n@@ -1739,1 +1749,1 @@\n-      log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+      aot_log_info(aot)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n@@ -1777,1 +1787,1 @@\n-  log_info(cds)(\"Heap data mapped at \" INTPTR_FORMAT \", size = %8zu bytes\",\n+  aot_log_info(aot)(\"Heap data mapped at \" INTPTR_FORMAT \", size = %8zu bytes\",\n@@ -1779,1 +1789,1 @@\n-  log_info(cds)(\"CDS heap data relocation delta = %zd bytes\", delta);\n+  aot_log_info(aot)(\"CDS heap data relocation delta = %zd bytes\", delta);\n@@ -1839,1 +1849,1 @@\n-      log_info(cds)(\"Unmapping region #%d at base \" INTPTR_FORMAT \" (%s)\", i, p2i(mapped_base),\n+      aot_log_info(aot)(\"Unmapping region #%d at base \" INTPTR_FORMAT \" (%s)\", i, p2i(mapped_base),\n@@ -1844,1 +1854,1 @@\n-        log_info(cds)(\"Region #%d (%s) is in a reserved space, it will be freed when the space is released\", i, shared_region_name[i]);\n+        aot_log_info(aot)(\"Region #%d (%s) is in a reserved space, it will be freed when the space is released\", i, shared_region_name[i]);\n@@ -1911,1 +1921,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\",\n@@ -1916,1 +1926,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\",\n@@ -1921,1 +1931,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when archived full module graph is not used.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when archived full module graph is not used.\",\n@@ -1928,1 +1938,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\",\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\",\n@@ -1935,1 +1945,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used with JDWP agent\", archive_type);\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used with JDWP agent\", archive_type);\n@@ -1977,1 +1987,1 @@\n-    log_info(cds)(\"The %s's ObjectAlignmentInBytes of %d\"\n+    aot_log_info(aot)(\"The %s's ObjectAlignmentInBytes of %d\"\n@@ -1983,1 +1993,1 @@\n-    log_info(cds)(\"The %s's CompactStrings setting (%s)\"\n+    aot_log_info(aot)(\"The %s's CompactStrings setting (%s)\"\n@@ -1995,1 +2005,1 @@\n-      log_error(cds)(\"%s has aot-linked classes. It cannot be used when the \"\n+      aot_log_error(aot)(\"%s has aot-linked classes. It cannot be used when the \"\n@@ -1999,1 +2009,1 @@\n-    log_warning(cds)(\"Archived non-system classes are disabled because the \"\n+    aot_log_warning(aot)(\"Archived non-system classes are disabled because the \"\n@@ -2008,1 +2018,1 @@\n-    log_info(cds)(\"The %s's BytecodeVerificationLocal setting (%s)\"\n+    aot_log_info(aot)(\"The %s's BytecodeVerificationLocal setting (%s)\"\n@@ -2020,1 +2030,1 @@\n-    log_info(cds)(\"The %s was created with less restrictive \"\n+    aot_log_info(aot)(\"The %s was created with less restrictive \"\n@@ -2032,1 +2042,1 @@\n-    log_warning(cds)(\"The setting of the AllowArchivingWithJavaAgent is different \"\n+    aot_log_warning(aot)(\"The setting of the AllowArchivingWithJavaAgent is different \"\n@@ -2038,1 +2048,1 @@\n-    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+    aot_log_warning(aot)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n@@ -2042,1 +2052,1 @@\n-  log_info(cds)(\"The %s was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n+  aot_log_info(aot)(\"The %s was created with UseCompressedOops = %d, UseCompressedClassPointers = %d, UseCompactObjectHeaders = %d\",\n@@ -2045,1 +2055,1 @@\n-    log_warning(cds)(\"Unable to use %s.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n+    aot_log_warning(aot)(\"Unable to use %s.\\nThe saved state of UseCompressedOops and UseCompressedClassPointers is \"\n@@ -2069,1 +2079,1 @@\n-    log_warning(cds)(\"Unable to use %s.\\nThe %s's UseCompactObjectHeaders setting (%s)\"\n+    aot_log_warning(aot)(\"Unable to use %s.\\nThe %s's UseCompactObjectHeaders setting (%s)\"\n@@ -2078,1 +2088,1 @@\n-    log_info(cds)(\"optimized module handling: disabled because archive was created without optimized module handling\");\n+    aot_log_info(aot)(\"optimized module handling: disabled because archive was created without optimized module handling\");\n@@ -2166,1 +2176,1 @@\n-  log_debug(cds, jvmti)(\"classfile data for %s [%d: %s] = %d bytes\", class_name, path_index,\n+  log_debug(aot, jvmti)(\"classfile data for %s [%d: %s] = %d bytes\", class_name, path_index,\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":115,"deletions":105,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -177,1 +178,1 @@\n-      if (log_is_enabled(Debug, cds)) {\n+      if (log_is_enabled(Debug, aot)) {\n@@ -179,1 +180,1 @@\n-        log_debug(cds)(\"  calling %s\", method->name_and_sig_as_C_string());\n+        log_debug(aot)(\"  calling %s\", method->name_and_sig_as_C_string());\n@@ -191,1 +192,1 @@\n-  log_debug(cds)(\"Resetting platform loader\");\n+  log_debug(aot)(\"Resetting platform loader\");\n@@ -193,1 +194,1 @@\n-  log_debug(cds)(\"Resetting system loader\");\n+  log_debug(aot)(\"Resetting system loader\");\n@@ -203,1 +204,1 @@\n-  log_debug(cds)(\"Resetting boot loader\");\n+  log_debug(aot)(\"Resetting boot loader\");\n@@ -280,1 +281,1 @@\n-    if (log_is_enabled(Debug, cds, heap)) {\n+    if (log_is_enabled(Debug, aot, heap)) {\n@@ -282,1 +283,1 @@\n-      log_debug(cds, heap)(\"Clearing root %d: was \" PTR_FORMAT, index, p2i(old));\n+      log_debug(aot, heap)(\"Clearing root %d: was \" PTR_FORMAT, index, p2i(old));\n@@ -297,1 +298,1 @@\n-    log_debug(cds, heap)(\"Cannot archive, object (\" PTR_FORMAT \") is too large: %zu\",\n+    log_debug(aot, heap)(\"Cannot archive, object (\" PTR_FORMAT \") is too large: %zu\",\n@@ -345,1 +346,1 @@\n-    if (log_is_enabled(Debug, cds, heap)) {\n+    if (log_is_enabled(Debug, aot, heap)) {\n@@ -347,1 +348,1 @@\n-      LogTarget(Debug, cds, heap) log;\n+      LogTarget(Debug, aot, heap) log;\n@@ -572,1 +573,1 @@\n-  if (log_is_enabled(Debug, cds, init)) {\n+  if (log_is_enabled(Debug, aot, init)) {\n@@ -574,1 +575,1 @@\n-    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s%s\", nfields, ik->external_name(),\n+    log_debug(aot, init)(\"copied %3d field(s) in aot-initialized mirror %s%s%s\", nfields, ik->external_name(),\n@@ -657,1 +658,1 @@\n-      log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+      aot_log_info(aot)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n@@ -820,1 +821,1 @@\n-  if (log_is_enabled(Debug, cds, heap)) {\n+  if (log_is_enabled(Debug, aot, heap)) {\n@@ -823,1 +824,1 @@\n-      log_debug(cds, heap)(\"Adding klass %s\", orig_k->external_name());\n+      log_debug(aot, heap)(\"Adding klass %s\", orig_k->external_name());\n@@ -866,1 +867,1 @@\n-  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n+  log_error(aot, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n@@ -878,1 +879,1 @@\n-      log_info(cds, heap)(\"non-early: %s\", k->external_name());\n+      log_info(aot, heap)(\"non-early: %s\", k->external_name());\n@@ -906,1 +907,1 @@\n-    log_info(cds, heap)(\n+    log_info(aot, heap)(\n@@ -945,1 +946,1 @@\n-      if (log_is_enabled(Info, cds, heap)) {\n+      if (log_is_enabled(Info, aot, heap)) {\n@@ -951,1 +952,1 @@\n-        log_info(cds, heap)(\n+        log_info(aot, heap)(\n@@ -1020,1 +1021,1 @@\n-  if (log_is_enabled(Info, cds, heap)) {\n+  if (log_is_enabled(Info, aot, heap)) {\n@@ -1055,1 +1056,1 @@\n-    log_info(cds, heap)(\"Verify heap %s initializing static field(s) in %s\",\n+    log_info(aot, heap)(\"Verify heap %s initializing static field(s) in %s\",\n@@ -1069,1 +1070,1 @@\n-      log_info(cds, heap)(\"Trigger GC %s initializing static field(s) in %s\",\n+      log_info(aot, heap)(\"Trigger GC %s initializing static field(s) in %s\",\n@@ -1188,1 +1189,1 @@\n-    log_info(cds, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n+    log_info(aot, heap)(\"Skip initializing ArchivedModuleGraph subgraph: is_using_optimized_module_handling=%s num_module_paths=%d\",\n@@ -1231,1 +1232,1 @@\n-    if (log_is_enabled(Info, cds, heap)) {\n+    if (log_is_enabled(Info, aot, heap)) {\n@@ -1233,1 +1234,1 @@\n-      log_info(cds, heap)(\"subgraph %s is not recorded\",\n+      log_info(aot, heap)(\"subgraph %s is not recorded\",\n@@ -1239,1 +1240,1 @@\n-      if (log_is_enabled(Info, cds, heap)) {\n+      if (log_is_enabled(Info, aot, heap)) {\n@@ -1241,1 +1242,1 @@\n-        log_info(cds, heap)(\"subgraph %s cannot be used because full module graph is disabled\",\n+        log_info(aot, heap)(\"subgraph %s cannot be used because full module graph is disabled\",\n@@ -1248,1 +1249,1 @@\n-      if (log_is_enabled(Info, cds, heap)) {\n+      if (log_is_enabled(Info, aot, heap)) {\n@@ -1250,1 +1251,1 @@\n-        log_info(cds, heap)(\"subgraph %s cannot be used because JVMTI ClassFileLoadHook is enabled\",\n+        log_info(aot, heap)(\"subgraph %s cannot be used because JVMTI ClassFileLoadHook is enabled\",\n@@ -1256,1 +1257,1 @@\n-    if (log_is_enabled(Info, cds, heap)) {\n+    if (log_is_enabled(Info, aot, heap)) {\n@@ -1258,1 +1259,1 @@\n-      log_info(cds, heap)(\"%s subgraph %s \", do_init ? \"init\" : \"resolve\", k->external_name());\n+      log_info(aot, heap)(\"%s subgraph %s \", do_init ? \"init\" : \"resolve\", k->external_name());\n@@ -1330,1 +1331,1 @@\n-      log_debug(cds, heap)(\"  \" PTR_FORMAT \" init field @ %2d = \" PTR_FORMAT, p2i(k), field_offset, p2i(v));\n+      log_debug(aot, heap)(\"  \" PTR_FORMAT \" init field @ %2d = \" PTR_FORMAT, p2i(k), field_offset, p2i(v));\n@@ -1335,1 +1336,1 @@\n-    if (log_is_enabled(Info, cds, heap)) {\n+    if (log_is_enabled(Info, aot, heap)) {\n@@ -1337,1 +1338,1 @@\n-      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n+      log_info(aot, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n@@ -1409,1 +1410,1 @@\n-      if (!_record_klasses_only && log_is_enabled(Debug, cds, heap)) {\n+      if (!_record_klasses_only && log_is_enabled(Debug, aot, heap)) {\n@@ -1411,1 +1412,1 @@\n-        log_debug(cds, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n+        log_debug(aot, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n@@ -1414,2 +1415,2 @@\n-        if (log_is_enabled(Trace, cds, heap)) {\n-          LogTarget(Trace, cds, heap) log;\n+        if (log_is_enabled(Trace, aot, heap)) {\n+          LogTarget(Trace, aot, heap) log;\n@@ -1502,1 +1503,1 @@\n-    log_error(cds, heap)(\"Cannot archive object \" PTR_FORMAT \" of class %s\", p2i(orig_obj), orig_obj->klass()->external_name());\n+    log_error(aot, heap)(\"Cannot archive object \" PTR_FORMAT \" of class %s\", p2i(orig_obj), orig_obj->klass()->external_name());\n@@ -1507,1 +1508,1 @@\n-  if (log_is_enabled(Debug, cds, heap) && java_lang_Class::is_instance(orig_obj)) {\n+  if (log_is_enabled(Debug, aot, heap) && java_lang_Class::is_instance(orig_obj)) {\n@@ -1509,1 +1510,1 @@\n-    LogTarget(Debug, cds, heap) log;\n+    LogTarget(Debug, aot, heap) log;\n@@ -1548,1 +1549,1 @@\n-      log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n+      log_error(aot, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n@@ -1568,1 +1569,1 @@\n-      log_error(cds, heap)(\n+      log_error(aot, heap)(\n@@ -1653,1 +1654,1 @@\n-  log_debug(cds, heap)(\"Start archiving from: %s::%s (\" PTR_FORMAT \")\", klass_name, field_name, p2i(f));\n+  log_debug(aot, heap)(\"Start archiving from: %s::%s (\" PTR_FORMAT \")\", klass_name, field_name, p2i(f));\n@@ -1656,2 +1657,2 @@\n-    if (log_is_enabled(Trace, cds, heap)) {\n-      LogTarget(Trace, cds, heap) log;\n+    if (log_is_enabled(Trace, aot, heap)) {\n+      LogTarget(Trace, aot, heap) log;\n@@ -1664,1 +1665,1 @@\n-      log_error(cds, heap)(\"Archiving failed %s::%s (some reachable objects cannot be archived)\",\n+      log_error(aot, heap)(\"Archiving failed %s::%s (some reachable objects cannot be archived)\",\n@@ -1671,1 +1672,1 @@\n-      log_info(cds, heap)(\"Archived field %s::%s => \" PTR_FORMAT, klass_name, field_name, p2i(f));\n+      log_info(aot, heap)(\"Archived field %s::%s => \" PTR_FORMAT, klass_name, field_name, p2i(f));\n@@ -1790,1 +1791,1 @@\n-  log_info(cds, heap)(\"Start recording subgraph(s) for archived fields in %s\", class_name);\n+  log_info(aot, heap)(\"Start recording subgraph(s) for archived fields in %s\", class_name);\n@@ -1801,1 +1802,1 @@\n-  log_info(cds, heap)(\"Done recording subgraph(s) for archived fields in %s: \"\n+  log_info(aot, heap)(\"Done recording subgraph(s) for archived fields in %s: \"\n@@ -1853,1 +1854,1 @@\n-      log_warning(cds)(\"Loading ArchiveHeapTestClass %s ...\", test_class_name);\n+      log_warning(aot)(\"Loading ArchiveHeapTestClass %s ...\", test_class_name);\n@@ -1901,1 +1902,1 @@\n-      log_warning(cds)(\"Initializing ArchiveHeapTestClass %s ...\", test_class_name);\n+      log_warning(aot)(\"Initializing ArchiveHeapTestClass %s ...\", test_class_name);\n@@ -2057,1 +2058,1 @@\n-  log_info(cds, heap)(\"Archived subgraph records = %d\",\n+  log_info(aot, heap)(\"Archived subgraph records = %d\",\n@@ -2059,3 +2060,3 @@\n-  log_info(cds, heap)(\"  Walked %d objects\", _num_total_walked_objs);\n-  log_info(cds, heap)(\"  Archived %d objects\", _num_total_archived_objs);\n-  log_info(cds, heap)(\"  Recorded %d klasses\", _num_total_recorded_klasses);\n+  log_info(aot, heap)(\"  Walked %d objects\", _num_total_walked_objs);\n+  log_info(aot, heap)(\"  Archived %d objects\", _num_total_archived_objs);\n+  log_info(aot, heap)(\"  Recorded %d klasses\", _num_total_recorded_klasses);\n@@ -2068,1 +2069,1 @@\n-  log_info(cds, heap)(\"  Verified %d references\", _num_total_verifications);\n+  log_info(aot, heap)(\"  Verified %d references\", _num_total_verifications);\n@@ -2095,1 +2096,1 @@\n-    LogStream ls(Log(cds, heap)::error());\n+    LogStream ls(Log(aot, heap)::error());\n@@ -2168,1 +2169,1 @@\n-    log_info(cds, heap)(\"%8zu objects are <= %-6zu\"\n+    log_info(aot, heap)(\"%8zu objects are <= %-6zu\"\n@@ -2175,1 +2176,1 @@\n-  log_info(cds, heap)(\"%8zu huge  objects               (total %8zu bytes\"\n+  log_info(aot, heap)(\"%8zu huge  objects               (total %8zu bytes\"\n@@ -2179,1 +2180,1 @@\n-  log_info(cds, heap)(\"%8zu total objects               (total %8zu bytes\"\n+  log_info(aot, heap)(\"%8zu total objects               (total %8zu bytes\"\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":63,"deletions":62,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -191,1 +192,1 @@\n-      log_info(cds, hashtables)(\"Expanded _dumped_classes table to %d\", _dumped_classes.table_size());\n+      log_info(aot, hashtables)(\"Expanded _dumped_classes table to %d\", _dumped_classes.table_size());\n@@ -262,1 +263,1 @@\n-    log_info(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") aligned up to \" INTPTR_FORMAT,\n+    aot_log_info(aot)(\"SharedBaseAddress (\" INTPTR_FORMAT \") aligned up to \" INTPTR_FORMAT,\n@@ -280,1 +281,1 @@\n-  log_warning(cds)(\"SharedBaseAddress (\" INTPTR_FORMAT \") is %s. Reverted to \" INTPTR_FORMAT,\n+  aot_log_warning(aot)(\"SharedBaseAddress (\" INTPTR_FORMAT \") is %s. Reverted to \" INTPTR_FORMAT,\n@@ -295,1 +296,1 @@\n-  log_info(cds)(\"Core region alignment: %zu\", core_region_alignment());\n+  aot_log_info(aot)(\"Core region alignment: %zu\", core_region_alignment());\n@@ -319,1 +320,1 @@\n-    log_error(cds)(\"Unable to reserve memory for symbols: %zu bytes.\", symbol_rs_size);\n+    aot_log_error(aot)(\"Unable to reserve memory for symbols: %zu bytes.\", symbol_rs_size);\n@@ -355,1 +356,1 @@\n-      log_error(cds)(\"string length too large: %d\", utf8_length);\n+      aot_log_error(aot)(\"string length too large: %d\", utf8_length);\n@@ -372,1 +373,1 @@\n-        log_warning(cds, heap)(\"[line %d] extra interned string allocation failed; size too large: %d\",\n+        log_warning(aot, heap)(\"[line %d] extra interned string allocation failed; size too large: %d\",\n@@ -378,1 +379,1 @@\n-          log_warning(cds, heap)(\"[line %d] extra interned string ignored; size too large: %d\",\n+          log_warning(aot, heap)(\"[line %d] extra interned string ignored; size too large: %d\",\n@@ -412,1 +413,1 @@\n-  log_info(cds)(\"Archived %d method handle intrinsics (%d bytes)\", len, word_size * BytesPerWord);\n+  log_info(aot)(\"Archived %d method handle intrinsics (%d bytes)\", len, word_size * BytesPerWord);\n@@ -544,1 +545,1 @@\n-    log_info(cds)(\"Dumping symbol table ...\");\n+    log_info(aot)(\"Dumping symbol table ...\");\n@@ -661,1 +662,1 @@\n-  log_info(cds)(\"Make classes shareable\");\n+  log_info(aot)(\"Make classes shareable\");\n@@ -673,1 +674,1 @@\n-    log_info(cds)(\"Adjust lambda proxy class dictionary\");\n+    log_info(aot)(\"Adjust lambda proxy class dictionary\");\n@@ -799,1 +800,1 @@\n-      log_error(cds)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+      aot_log_error(aot)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n@@ -803,1 +804,1 @@\n-      log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+      aot_log_error(aot)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n@@ -805,1 +806,2 @@\n-      MetaspaceShared::writing_error(\"Unexpected exception, use -Xlog:cds,exceptions=trace for detail\");\n+      MetaspaceShared::writing_error(err_msg(\"Unexpected exception, use -Xlog:aot%s,exceptions=trace for detail\",\n+                                             CDSConfig::new_aot_flags_used() ? \"\" : \",cds\"));\n@@ -842,1 +844,1 @@\n-    log_debug(cds)(\"Setting MinHeapSize to 4G for CDS dumping, original size = %zuM\", MinHeapSize\/M);\n+    log_debug(aot)(\"Setting MinHeapSize to 4G for CDS dumping, original size = %zuM\", MinHeapSize\/M);\n@@ -846,1 +848,1 @@\n-    log_debug(cds)(\"Setting InitialHeapSize to 4G for CDS dumping, original size = %zuM\", InitialHeapSize\/M);\n+    log_debug(aot)(\"Setting InitialHeapSize to 4G for CDS dumping, original size = %zuM\", InitialHeapSize\/M);\n@@ -850,1 +852,1 @@\n-    log_debug(cds)(\"Setting MaxHeapSize to 4G for CDS dumping, original size = %zuM\", MaxHeapSize\/M);\n+    log_debug(aot)(\"Setting MaxHeapSize to 4G for CDS dumping, original size = %zuM\", MaxHeapSize\/M);\n@@ -873,1 +875,1 @@\n-  log_info(cds)(\"Loading classes to share ...\");\n+  aot_log_info(aot)(\"Loading classes to share ...\");\n@@ -894,1 +896,1 @@\n-  log_info(cds)(\"Loading classes to share: done.\");\n+  aot_log_info(aot)(\"Loading classes to share: done.\");\n@@ -912,1 +914,1 @@\n-      log_info(cds)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n+      log_info(aot)(\"Reading extra data from %s ...\", SharedArchiveConfigFile);\n@@ -914,1 +916,1 @@\n-      log_info(cds)(\"Reading extra data: done.\");\n+      log_info(aot)(\"Reading extra data: done.\");\n@@ -919,1 +921,1 @@\n-    log_info(cds)(\"Reading lambda form invokers from JDK default classlist ...\");\n+    log_info(aot)(\"Reading lambda form invokers from JDK default classlist ...\");\n@@ -943,1 +945,1 @@\n-      log_info(cds)(\"Loading extra classes from %s ...\", ExtraSharedClassListFile);\n+      log_info(aot)(\"Loading extra classes from %s ...\", ExtraSharedClassListFile);\n@@ -950,1 +952,1 @@\n-  log_info(cds)(\"Rewriting and linking classes ...\");\n+  log_info(aot)(\"Rewriting and linking classes ...\");\n@@ -957,1 +959,1 @@\n-  log_info(cds)(\"Rewriting and linking classes: done\");\n+  log_info(aot)(\"Rewriting and linking classes: done\");\n@@ -978,1 +980,1 @@\n-      log_debug(cds)(\"Resetting Class::reflectionFactory\");\n+      log_debug(aot)(\"Resetting Class::reflectionFactory\");\n@@ -993,1 +995,1 @@\n-    log_info(cds)(\"Not dumping heap, reset CDSConfig::_is_using_optimized_module_handling\");\n+    log_info(aot)(\"Not dumping heap, reset CDSConfig::_is_using_optimized_module_handling\");\n@@ -1029,1 +1031,1 @@\n-    log_warning(cds)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n+    aot_log_warning(aot)(\"This %s was created with AllowArchivingWithJavaAgent. It should be used \"\n@@ -1062,1 +1064,1 @@\n-      log_warning(cds)(\"Preload Warning: Verification failed for %s\",\n+      aot_log_warning(aot)(\"Preload Warning: Verification failed for %s\",\n@@ -1119,1 +1121,1 @@\n-  report_loading_error(message);\n+  report_loading_error(\"%s\", message);\n@@ -1131,2 +1133,5 @@\n-  \/\/ If the user doesn't specify any CDS options, we will try to load the default CDS archive, which\n-  \/\/ may fail due to incompatible VM options. Print at the info level to avoid excessive verbosity.\n+  \/\/ When using AOT cache, errors messages are always printed on the error channel.\n+  LogStream ls_aot(LogLevel::Error, LogTagSetMapping<LOG_TAGS(aot)>::tagset());\n+\n+  \/\/ If we are loading load the default CDS archive, it may fail due to incompatible VM options.\n+  \/\/ Print at the info level to avoid excessive verbosity.\n@@ -1135,4 +1140,7 @@\n-  Log(cds) log;\n-  LogStream ls_error(log.error());\n-  LogStream ls_info(log.info());\n-  LogStream& ls = (!CDSConfig::is_using_archive()) || CDSConfig::is_using_only_default_archive() ? ls_info : ls_error;\n+  LogLevelType level = (!CDSConfig::is_using_archive() || CDSConfig::is_using_only_default_archive()) ?\n+                        LogLevel::Info : LogLevel::Error;\n+  LogStream ls_cds(level, LogTagSetMapping<LOG_TAGS(cds)>::tagset());\n+\n+  LogStream& ls = CDSConfig::new_aot_flags_used() ? ls_aot : ls_cds;\n+  va_list ap;\n+  va_start(ap, format);\n@@ -1142,1 +1150,2 @@\n-    ls.print_cr(\"An error has occurred while processing the %s. Run with -Xlog:cds for details.\", CDSConfig::type_of_archive_being_loaded());\n+    ls.print_cr(\"An error has occurred while processing the %s. Run with -Xlog:%s for details.\",\n+                CDSConfig::type_of_archive_being_loaded(), CDSConfig::new_aot_flags_used() ? \"aot\" : \"aot,cds\");\n@@ -1145,0 +1154,1 @@\n+  ls.vprint_cr(format, ap);\n@@ -1146,6 +1156,1 @@\n-  if (format != nullptr) {\n-    va_list ap;\n-    va_start(ap, format);\n-    ls.vprint_cr(format, ap);\n-    va_end(ap);\n-  }\n+  va_end(ap);\n@@ -1164,1 +1169,1 @@\n-  log_error(cds)(\"An error has occurred while writing the shared archive file.\");\n+  aot_log_error(aot)(\"An error has occurred while writing the shared archive file.\");\n@@ -1166,1 +1171,1 @@\n-    log_error(cds)(\"%s\", message);\n+    aot_log_error(aot)(\"%s\", message);\n@@ -1178,1 +1183,1 @@\n-    log_info(cds)(\"Core region alignment: %zu\", static_mapinfo->core_region_alignment());\n+    aot_log_info(aot)(\"Core region alignment: %zu\", static_mapinfo->core_region_alignment());\n@@ -1181,1 +1186,1 @@\n-    log_info(cds)(\"ArchiveRelocationMode: %d\", ArchiveRelocationMode);\n+    aot_log_info(aot)(\"ArchiveRelocationMode: %d\", ArchiveRelocationMode);\n@@ -1188,1 +1193,1 @@\n-      log_info(cds)(\"Try to map archive(s) at an alternative address\");\n+      aot_log_info(aot)(\"Try to map archive(s) at an alternative address\");\n@@ -1209,1 +1214,1 @@\n-      log_warning(cds)(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+      aot_log_warning(aot)(\"-XX:ArchiveClassesAtExit is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n@@ -1278,1 +1283,1 @@\n-    log_info(cds)(\"Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.\");\n+    aot_log_info(aot)(\"Archive(s) were created with -XX:SharedBaseAddress=0. Always map at os-selected address.\");\n@@ -1286,1 +1291,1 @@\n-      log_info(cds)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n+      aot_log_info(aot)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n@@ -1291,1 +1296,1 @@\n-    log_info(cds)(\"ArchiveRelocationMode == 2: never map archive(s) at an alternative address\");\n+    aot_log_info(aot)(\"ArchiveRelocationMode == 2: never map archive(s) at an alternative address\");\n@@ -1312,1 +1317,1 @@\n-    log_debug(cds)(\"Failed to reserve spaces (use_requested_addr=%u)\", (unsigned)use_requested_addr);\n+    aot_log_debug(aot)(\"Failed to reserve spaces (use_requested_addr=%u)\", (unsigned)use_requested_addr);\n@@ -1342,1 +1347,1 @@\n-    log_info(cds)(\"Reserved archive_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes%s\",\n+    aot_log_info(aot)(\"Reserved archive_space_rs [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes%s\",\n@@ -1345,1 +1350,1 @@\n-    log_info(cds)(\"Reserved class_space_rs   [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes\",\n+    aot_log_info(aot)(\"Reserved class_space_rs   [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] (%zu) bytes\",\n@@ -1367,1 +1372,1 @@\n-        log_info(cds)(\"Windows mmap workaround: releasing archive space.\");\n+        aot_log_info(aot)(\"Windows mmap workaround: releasing archive space.\");\n@@ -1384,1 +1389,1 @@\n-            log_debug(cds)(\"Failed to re-reserve protection zone\");\n+            aot_log_debug(aot)(\"Failed to re-reserve protection zone\");\n@@ -1409,1 +1414,1 @@\n-      log_info(cds)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n+      aot_log_info(aot)(\"ArchiveRelocationMode == 1: always map archive(s) at an alternative address\");\n@@ -1478,2 +1483,2 @@\n-    log_info(cds)(\"initial optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"initial full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+    log_info(aot)(\"initial optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+    log_info(aot)(\"initial full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n@@ -1625,1 +1630,1 @@\n-    log_info(cds)(\"CDS initialization: Cannot use SharedBaseAddress \" PTR_FORMAT \" with precomputed shift %d.\",\n+    aot_log_info(aot)(\"CDS initialization: Cannot use SharedBaseAddress \" PTR_FORMAT \" with precomputed shift %d.\",\n@@ -1709,1 +1714,1 @@\n-    log_debug(cds)(\"Released shared space (archive + class) \" INTPTR_FORMAT, p2i(total_space_rs.base()));\n+    aot_log_debug(aot)(\"Released shared space (archive + class) \" INTPTR_FORMAT, p2i(total_space_rs.base()));\n@@ -1714,1 +1719,1 @@\n-      log_debug(cds)(\"Released shared space (archive) \" INTPTR_FORMAT, p2i(archive_space_rs.base()));\n+      aot_log_debug(aot)(\"Released shared space (archive) \" INTPTR_FORMAT, p2i(archive_space_rs.base()));\n@@ -1719,1 +1724,1 @@\n-      log_debug(cds)(\"Released shared space (classes) \" INTPTR_FORMAT, p2i(class_space_rs.base()));\n+      aot_log_debug(aot)(\"Released shared space (classes) \" INTPTR_FORMAT, p2i(class_space_rs.base()));\n@@ -1829,1 +1834,1 @@\n-  LogStreamHandle(Info, cds) lsh;\n+  LogStreamHandle(Info, aot) lsh;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":71,"deletions":66,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  static void unrecoverable_loading_error(const char* message = nullptr) ATTRIBUTE_PRINTF(1, 0);\n+  static void unrecoverable_loading_error(const char* message = \"unrecoverable error\");\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1179,0 +1179,9 @@\n+  \/\/ record the bailout for hserr envlog\n+  if (reason != nullptr) {\n+    if (CompilationLog::log() != nullptr) {\n+      CompilerThread* thread = CompilerThread::current();\n+      CompileTask* task = thread->task();\n+      CompilationLog::log()->log_failure(thread, task, reason, nullptr);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1535,2 +1535,1 @@\n-  char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(orig)+1);\n-  strcpy(orig_copy, orig);\n+  char* orig_copy = ResourceArea::strdup(thread, orig);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1221,1 +1221,1 @@\n-  log_debug(cds, mirror)(\"Archived mirror is: \" PTR_FORMAT, p2i(m));\n+  log_debug(aot, mirror)(\"Archived mirror is: \" PTR_FORMAT, p2i(m));\n@@ -1246,1 +1246,1 @@\n-  if (log_is_enabled(Trace, cds, heap, mirror)) {\n+  if (log_is_enabled(Trace, aot, heap, mirror)) {\n@@ -1248,1 +1248,1 @@\n-    log_trace(cds, heap, mirror)(\n+    log_trace(aot, heap, mirror)(\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -508,0 +508,1 @@\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  AOTStubCaching = false;\n@@ -137,0 +138,1 @@\n+    AOTStubCaching = false;\n@@ -140,0 +142,11 @@\n+  if (VerifyOops) {\n+    \/\/ Disable AOT stubs caching when VerifyOops flag is on.\n+    \/\/ Verify oops code generated a lot of C strings which overflow\n+    \/\/ AOT C string table (which has fixed size).\n+    \/\/ AOT C string table will be reworked later to handle such cases.\n+    \/\/\n+    \/\/ Note: AOT adapters are not affected - they don't have oop operations.\n+    log_info(aot, codecache, init)(\"AOT Stubs Caching is not supported with VerifyOops.\");\n+    FLAG_SET_ERGO(AOTStubCaching, false);\n+  }\n+\n@@ -1246,1 +1259,1 @@\n-#if defined(AARCH64)\n+#if defined(AARCH64) && !defined(ZERO)\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1053,1 +1053,1 @@\n-    log_info(cds, resolve)(\"Not resolved: class not linked: %s %s %s\",\n+    log_info(aot, resolve)(\"Not resolved: class not linked: %s %s %s\",\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"JVMCI is not enabled\")\n+    THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), JVMCI_NOT_ENABLED_ERROR_MESSAGE)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -499,0 +499,6 @@\n+  declare_preprocessor_constant(\"INCLUDE_SERIALGC\", INCLUDE_SERIALGC)     \\\n+  declare_preprocessor_constant(\"INCLUDE_PARALLELGC\", INCLUDE_PARALLELGC) \\\n+  declare_preprocessor_constant(\"INCLUDE_G1GC\", INCLUDE_G1GC)             \\\n+  declare_preprocessor_constant(\"INCLUDE_ZGC\", INCLUDE_ZGC)               \\\n+  declare_preprocessor_constant(\"INCLUDE_SHENANDOAHGC\", INCLUDE_SHENANDOAHGC) \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-  log_trace(cds)(\"Iter(ArrayKlass): %p (%s)\", this, external_name());\n+  log_trace(aot)(\"Iter(ArrayKlass): %p (%s)\", this, external_name());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  log_trace(cds)(\"Iter(ConstantPool): %p\", this);\n+  log_trace(aot)(\"Iter(ConstantPool): %p\", this);\n@@ -505,1 +505,1 @@\n-  log_info(cds, resolve)(\"Archiving CP entries for %s\", pool_holder()->name()->as_C_string());\n+  log_info(aot, resolve)(\"Archiving CP entries for %s\", pool_holder()->name()->as_C_string());\n@@ -564,1 +564,1 @@\n-  LogStreamHandle(Trace, cds, resolve) log;\n+  LogStreamHandle(Trace, aot, resolve) log;\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-      LogStreamHandle(Trace, cds, resolve) log;\n+      LogStreamHandle(Trace, aot, resolve) log;\n@@ -481,1 +481,1 @@\n-      LogStreamHandle(Trace, cds, resolve) log;\n+      LogStreamHandle(Trace, aot, resolve) log;\n@@ -521,1 +521,1 @@\n-      LogStreamHandle(Trace, cds, resolve) log;\n+      LogStreamHandle(Trace, aot, resolve) log;\n@@ -709,1 +709,1 @@\n-  log_trace(cds)(\"Iter(ConstantPoolCache): %p\", this);\n+  log_trace(aot)(\"Iter(ConstantPoolCache): %p\", this);\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -940,1 +940,1 @@\n-  if (log_is_enabled(Info, cds, init)) {\n+  if (log_is_enabled(Info, aot, init)) {\n@@ -942,1 +942,1 @@\n-    log_info(cds, init)(\"%s (aot-inited)\", external_name());\n+    log_info(aot, init)(\"%s (aot-inited)\", external_name());\n@@ -2868,1 +2868,1 @@\n-  if (log_is_enabled(Trace, cds)) {\n+  if (log_is_enabled(Trace, aot)) {\n@@ -2870,1 +2870,1 @@\n-    log_trace(cds)(\"Iter(InstanceKlass): %p (%s)\", this, external_name());\n+    log_trace(aot)(\"Iter(InstanceKlass): %p (%s)\", this, external_name());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -747,1 +747,1 @@\n-  if (log_is_enabled(Trace, cds)) {\n+  if (log_is_enabled(Trace, aot)) {\n@@ -749,1 +749,1 @@\n-    log_trace(cds)(\"Iter(Klass): %p (%s)\", this, external_name());\n+    log_trace(aot)(\"Iter(Klass): %p (%s)\", this, external_name());\n@@ -778,1 +778,1 @@\n-  if (log_is_enabled(Trace, cds, unshareable)) {\n+  if (log_is_enabled(Trace, aot, unshareable)) {\n@@ -780,1 +780,1 @@\n-    log_trace(cds, unshareable)(\"remove: %s\", external_name());\n+    log_trace(aot, unshareable)(\"remove: %s\", external_name());\n@@ -804,1 +804,1 @@\n-  if (log_is_enabled(Trace, cds, unshareable)) {\n+  if (log_is_enabled(Trace, aot, unshareable)) {\n@@ -806,1 +806,1 @@\n-    log_trace(cds, unshareable)(\"remove java_mirror: %s\", external_name());\n+    log_trace(aot, unshareable)(\"remove java_mirror: %s\", external_name());\n@@ -842,1 +842,1 @@\n-  if (log_is_enabled(Trace, cds, unshareable)) {\n+  if (log_is_enabled(Trace, aot, unshareable)) {\n@@ -845,1 +845,1 @@\n-    log_trace(cds, unshareable)(\"restore: %s with class loader: %s\", external_name(),\n+    log_trace(aot, unshareable)(\"restore: %s with class loader: %s\", external_name(),\n@@ -878,1 +878,1 @@\n-    log_debug(cds, mirror)(\"%s has raw archived mirror\", external_name());\n+    log_debug(aot, mirror)(\"%s has raw archived mirror\", external_name());\n@@ -889,1 +889,1 @@\n-    log_debug(cds, mirror)(\"No archived mirror data for %s\", external_name());\n+    log_debug(aot, mirror)(\"No archived mirror data for %s\", external_name());\n@@ -898,1 +898,1 @@\n-    log_trace(cds, mirror)(\"Recreate mirror for %s\", external_name());\n+    log_trace(aot, mirror)(\"Recreate mirror for %s\", external_name());\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-  log_trace(cds)(\"Iter(Method): %p\", this);\n+  log_trace(aot)(\"Iter(Method): %p\", this);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1795,1 +1795,1 @@\n-  log_trace(cds)(\"Iter(MethodData): %p\", this);\n+  log_trace(aot)(\"Iter(MethodData): %p\", this);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,2 +410,2 @@\n-  if (log_is_enabled(Trace, cds)) {\n-    LogStream trace_stream(Log(cds)::trace());\n+  if (log_is_enabled(Trace, aot)) {\n+    LogStream trace_stream(Log(aot)::trace());\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -370,0 +370,8 @@\n+  product(uint, SuperWordAutomaticAlignment, 1, DIAGNOSTIC,                 \\\n+          \"0 = Disabled (unless AlignVector is enabled)\"                    \\\n+          \"Else: align with a load or store of the largest vector width,\"   \\\n+          \"      and if there are loads and stores of the largest width:\"   \\\n+          \"1 = Prefer alignment with vector store (default)\"                \\\n+          \"2 = Prefer alignment with vector load.\")                         \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n@@ -389,0 +397,9 @@\n+  develop(intx, PrintPhaseLevel, 0,                                         \\\n+          \"Level of detail of the phase trace print. \"                      \\\n+          \"System-wide value, -1=printing is disabled, \"                    \\\n+          \"0=print nothing except PhasePrintLevel directives, \"             \\\n+          \"6=all details printed. \"                                         \\\n+          \"Level of detail of printouts can be set on a per-method level \"  \\\n+          \"as well by using CompileCommand=PrintPhaseLevel.\")                        \\\n+          range(-1, 6)                                                      \\\n+                                                                            \\\n@@ -844,0 +861,3 @@\n+                                                                            \\\n+  develop(bool, StressLoopPeeling, false,                                   \\\n+          \"Randomize loop peeling decision\")                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compilerDefinitions.hpp\"\n@@ -593,0 +594,4 @@\n+void Compile::print_phase(const char* phase_name) {\n+  tty->print_cr(\"%u.\\t%s\", ++_phase_counter, phase_name);\n+}\n+\n@@ -750,1 +755,2 @@\n-      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout) {\n+      StressIncrementalInlining || StressMacroExpansion || StressUnstableIfTraps || StressBailout ||\n+      StressLoopPeeling) {\n@@ -1096,0 +1102,1 @@\n+  _phase_counter = 0;\n@@ -5695,1 +5702,4 @@\n-  if (should_print_phase(cpt)) {\n+  if (should_print_phase(level)) {\n+    print_phase(name);\n+  }\n+  if (should_print_ideal_phase(cpt)) {\n@@ -5726,6 +5736,7 @@\n-bool Compile::should_print_phase(CompilerPhaseType cpt) {\n-  if (_directive->should_print_phase(cpt)) {\n-    return true;\n-  }\n-#endif\n-  return false;\n+bool Compile::should_print_phase(const int level) const {\n+  return PrintPhaseLevel > 0 && directive()->PhasePrintLevelOption >= level &&\n+         _method != nullptr; \/\/ Do not print phases for stubs.\n+}\n+\n+bool Compile::should_print_ideal_phase(CompilerPhaseType cpt) const {\n+  return _directive->should_print_ideal_phase(cpt);\n@@ -5735,1 +5746,0 @@\n-#ifndef PRODUCT\n@@ -5742,1 +5752,0 @@\n-#endif\n@@ -5745,1 +5754,2 @@\n-#ifndef PRODUCT\n+  PRODUCT_RETURN_(return false;);\n+\n@@ -5755,3 +5765,0 @@\n-#else\n-  return false;\n-#endif\n@@ -5760,1 +5767,0 @@\n-#ifndef PRODUCT\n@@ -5849,1 +5855,1 @@\n-#endif\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -353,0 +353,1 @@\n+  uint                  _phase_counter;         \/\/ Counter for the number of already printed phases\n@@ -664,1 +665,1 @@\n-  bool          method_has_option(CompileCommandEnum option) {\n+  bool          method_has_option(CompileCommandEnum option) const {\n@@ -671,0 +672,1 @@\n+  void          print_phase(const char* phase_name);\n@@ -688,2 +690,0 @@\n-  bool should_print_igv(int level);\n-  bool should_print_phase(CompilerPhaseType cpt);\n@@ -694,0 +694,3 @@\n+  bool should_print_igv(int level);\n+  bool should_print_phase(int level) const;\n+  bool should_print_ideal_phase(CompilerPhaseType cpt) const;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -459,0 +459,1 @@\n+  assert(early->dominates(LCA), \"precondition failed\");\n@@ -473,1 +474,1 @@\n-      assert(early->dominates(LCA), \"early is high enough\");\n+      assert(early->dominates(LCA), \"unsound LCA update\");\n@@ -546,1 +547,1 @@\n-\/\/ This function is used by insert_anti_dependences to find unrelated loads for stores in implicit null checks.\n+\/\/ This function is used by raise_above_anti_dependences to find unrelated loads for stores in implicit null checks.\n@@ -600,1 +601,1 @@\n-    \/\/ times as well. When PhaseCFG::insert_anti_dependences() goes over\n+    \/\/ times as well. When PhaseCFG::raise_above_anti_dependences() goes over\n@@ -665,5 +666,2 @@\n-\/\/--------------------------insert_anti_dependences---------------------------\n-\/\/ A load may need to witness memory that nearby stores can overwrite.\n-\/\/ For each nearby store, either insert an \"anti-dependence\" edge\n-\/\/ from the load to the store, or else move LCA upward to force the\n-\/\/ load to (eventually) be scheduled in a block above the store.\n+\/\/ Enforce a scheduling of the given 'load' that ensures anti-dependent stores\n+\/\/ do not overwrite the load's input memory state before the load executes.\n@@ -671,2 +669,5 @@\n-\/\/ Do not add edges to stores on distinct control-flow paths;\n-\/\/ only add edges to stores which might interfere.\n+\/\/ The given 'load' has a current scheduling range in the dominator tree that\n+\/\/ starts at the load's early block (computed in schedule_early) and ends at\n+\/\/ the given 'LCA' block for the load. However, there may still exist\n+\/\/ anti-dependent stores between the early block and the LCA that overwrite\n+\/\/ memory that the load must witness. For such stores, we must\n@@ -674,8 +675,52 @@\n-\/\/ Return the (updated) LCA.  There will not be any possibly interfering\n-\/\/ store between the load's \"early block\" and the updated LCA.\n-\/\/ Any stores in the updated LCA will have new precedence edges\n-\/\/ back to the load.  The caller is expected to schedule the load\n-\/\/ in the LCA, in which case the precedence edges will make LCM\n-\/\/ preserve anti-dependences.  The caller may also hoist the load\n-\/\/ above the LCA, if it is not the early block.\n-Block* PhaseCFG::insert_anti_dependences(Block* LCA, Node* load, bool verify) {\n+\/\/   1. raise the load's LCA to force the load to (eventually) be scheduled at\n+\/\/      latest in the store's block, and\n+\/\/   2. if the load may get scheduled in the store's block, additionally insert\n+\/\/      an anti-dependence edge (i.e., precedence edge) from the load to the\n+\/\/      store to ensure LCM schedules the load before the store within the\n+\/\/      block.\n+\/\/\n+\/\/ For a given store, we say that the store is on a _distinct_ control-flow\n+\/\/ path relative to the load if there are no paths from early to LCA that go\n+\/\/ through the store's block. Such stores are not anti-dependent, and there is\n+\/\/ no need to update the LCA nor to add anti-dependence edges.\n+\/\/\n+\/\/ Due to the presence of loops, we must also raise the LCA above\n+\/\/ anti-dependent memory Phis. We defer the details (see later comments in the\n+\/\/ method) and for now look at an example without loops.\n+\/\/\n+\/\/          CFG               DOMINATOR TREE\n+\/\/\n+\/\/       B1 (early,L)              B1\n+\/\/       |\\________                \/\\\\___\n+\/\/       |         \\              \/  \\   \\\n+\/\/       B2 (L,S)   \\            B2  B7  B6\n+\/\/      \/  \\         \\           \/\\\\___\n+\/\/     B3  B4 (S)    B7 (S)     \/  \\   \\\n+\/\/      \\  \/         \/         B3  B4  B5\n+\/\/       B5 (LCA,L) \/\n+\/\/        \\    ____\/\n+\/\/         \\  \/\n+\/\/          B6\n+\/\/\n+\/\/ Here, the load's scheduling range when calling raise_above_anti_dependences\n+\/\/ is between early and LCA in the dominator tree, i.e., in block B1, B2, or B5\n+\/\/ (indicated with \"L\"). However, there are a number of stores (indicated with\n+\/\/ \"S\") that overwrite the memory which the load must witness. First, consider\n+\/\/ the store in B4. We cannot legally schedule the load in B4, so an\n+\/\/ anti-dependence edge is redundant. However, we must raise the LCA above\n+\/\/ B4, which means that the updated LCA is B2. Now, consider the store in B2.\n+\/\/ The LCA is already B2, so we do not need to raise it any further.\n+\/\/ If we, eventually, decide to schedule the load in B2, it could happen that\n+\/\/ LCM decides to place the load after the anti-dependent store in B2.\n+\/\/ Therefore, we now need to add an anti-dependence edge between the load and\n+\/\/ the B2 store, ensuring that the load is scheduled before the store. Finally,\n+\/\/ the store in B7 is on a distinct control-flow path. Therefore, B7 requires\n+\/\/ no action.\n+\/\/\n+\/\/ The raise_above_anti_dependences method returns the updated LCA and ensures\n+\/\/ there are no anti-dependent stores in any block between the load's early\n+\/\/ block and the updated LCA. Any stores in the updated LCA will have new\n+\/\/ anti-dependence edges back to the load. The caller may schedule the load in\n+\/\/ the updated LCA, or it may hoist the load above the updated LCA, if the\n+\/\/ updated LCA is not the early block.\n+Block* PhaseCFG::raise_above_anti_dependences(Block* LCA, Node* load, const bool verify) {\n@@ -714,5 +759,5 @@\n-  \/\/ Note the earliest legal placement of 'load', as determined by\n-  \/\/ by the unique point in the dom tree where all memory effects\n-  \/\/ and other inputs are first available.  (Computed by schedule_early.)\n-  \/\/ For normal loads, 'early' is the shallowest place (dom graph wise)\n-  \/\/ to look for anti-deps between this load and any store.\n+  \/\/ Record the earliest legal placement of 'load', as determined by the unique\n+  \/\/ point in the dominator tree where all memory effects and other inputs are\n+  \/\/ first available (computed by schedule_early). For normal loads, 'early' is\n+  \/\/ the shallowest place (dominator-tree wise) to look for anti-dependences\n+  \/\/ between this load and any store.\n@@ -722,2 +767,2 @@\n-  \/\/ memory or address inputs. This block may be different than the\n-  \/\/ schedule_early block in that it could be at an even shallower depth in the\n+  \/\/ memory or address inputs. This block may be different from the\n+  \/\/ schedule_early block when it is at an even shallower depth in the\n@@ -732,0 +777,2 @@\n+  assert(early->dominates(LCA_orig), \"precondition failed\");\n+\n@@ -733,20 +780,16 @@\n-  DefUseMemStatesQueue worklist_def_use_mem_states(area); \/\/ prior memory state to store and possible-def to explore\n-  Node_List non_early_stores(area); \/\/ all relevant stores outside of early\n-  bool must_raise_LCA = false;\n-\n-  \/\/ 'load' uses some memory state; look for users of the same state.\n-  \/\/ Recurse through MergeMem nodes to the stores that use them.\n-\n-  \/\/ Each of these stores is a possible definition of memory\n-  \/\/ that 'load' needs to use.  We need to force 'load'\n-  \/\/ to occur before each such store.  When the store is in\n-  \/\/ the same block as 'load', we insert an anti-dependence\n-  \/\/ edge load->store.\n-\n-  \/\/ The relevant stores \"nearby\" the load consist of a tree rooted\n-  \/\/ at initial_mem, with internal nodes of type MergeMem.\n-  \/\/ Therefore, the branches visited by the worklist are of this form:\n-  \/\/    initial_mem -> (MergeMem ->)* Memory state modifying node\n-  \/\/ Memory state modifying nodes include Store and Phi nodes and any node for which needs_anti_dependence_check()\n-  \/\/ returns false.\n-  \/\/ The anti-dependence constraints apply only to the fringe of this tree.\n+  \/\/ Bookkeeping of possibly anti-dependent stores that we find outside the\n+  \/\/ early block and that may need anti-dependence edges. Note that stores in\n+  \/\/ non_early_stores are not necessarily dominated by early. The search starts\n+  \/\/ from initial_mem, which can reside in a block that dominates early, and\n+  \/\/ therefore, stores we find may be in blocks that are on completely distinct\n+  \/\/ control-flow paths compared to early. However, in the end, only stores in\n+  \/\/ blocks dominated by early matter. The reason for bookkeeping not only\n+  \/\/ relevant stores is efficiency: we lazily record all possible\n+  \/\/ anti-dependent stores and add anti-dependence edges only to the relevant\n+  \/\/ ones at the very end of this method when we know the final updated LCA.\n+  Node_List non_early_stores(area);\n+\n+  \/\/ Whether we must raise the LCA after the main worklist loop below.\n+  bool must_raise_LCA_above_marks = false;\n+\n+  \/\/ The input load uses some memory state (initial_mem).\n@@ -755,0 +798,20 @@\n+  \/\/ To find anti-dependences we must look for users of the same memory state.\n+  \/\/ To do this, we search the memory graph downwards from initial_mem. During\n+  \/\/ this search, we encounter different types of nodes that we handle\n+  \/\/ according to the following three categories:\n+  \/\/\n+  \/\/ - MergeMems\n+  \/\/ - Memory-state-modifying nodes (informally referred to as \"stores\" above\n+  \/\/   and below)\n+  \/\/ - Memory Phis\n+  \/\/\n+  \/\/ MergeMems do not modify the memory state. Anti-dependent stores or memory\n+  \/\/ Phis may, however, exist downstream of MergeMems. Therefore, we must\n+  \/\/ permit the search to continue through MergeMems. Stores may raise the LCA\n+  \/\/ and may potentially also require an anti-dependence edge. Memory Phis may\n+  \/\/ raise the LCA but never require anti-dependence edges. See the comments\n+  \/\/ throughout the worklist loop below for further details.\n+  \/\/\n+  \/\/ It may be useful to think of the anti-dependence search as traversing a\n+  \/\/ tree rooted at initial_mem, with internal nodes of type MergeMem and\n+  \/\/ memory Phis and stores as (potentially repeated) leaves.\n@@ -770,8 +833,26 @@\n-  worklist_def_use_mem_states.push(nullptr, initial_mem);\n-  while (worklist_def_use_mem_states.is_nonempty()) {\n-    \/\/ Examine a nearby store to see if it might interfere with our load.\n-    Node* def_mem_state = worklist_def_use_mem_states.top_def();\n-    Node* use_mem_state = worklist_def_use_mem_states.top_use();\n-    worklist_def_use_mem_states.pop();\n-\n-    uint op = use_mem_state->Opcode();\n+  \/\/ To administer the search, we use a worklist consisting of (def,use)-pairs\n+  \/\/ of memory states, corresponding to edges in the search tree (and edges\n+  \/\/ in the memory graph). We need to keep track of search tree edges in the\n+  \/\/ worklist rather than individual nodes due to memory Phis (see details\n+  \/\/ below).\n+  DefUseMemStatesQueue worklist(area);\n+  \/\/ We start the search at initial_mem and indicate the search root with the\n+  \/\/ edge (nullptr, initial_mem).\n+  worklist.push(nullptr, initial_mem);\n+\n+  \/\/ The worklist loop\n+  while (worklist.is_nonempty()) {\n+    \/\/ Pop the next edge from the worklist\n+    Node* def_mem_state = worklist.top_def();\n+    Node* use_mem_state = worklist.top_use();\n+    worklist.pop();\n+\n+    \/\/ We are either\n+    \/\/ - at the root of the search with the edge (nullptr, initial_mem),\n+    \/\/ - just past initial_mem with the edge (initial_mem, use_mem_state), or\n+    \/\/ - just past a MergeMem with the edge (MergeMem, use_mem_state).\n+    assert(def_mem_state == nullptr || def_mem_state == initial_mem ||\n+           def_mem_state->is_MergeMem(),\n+           \"unexpected memory state\");\n+\n+    const uint op = use_mem_state->Opcode();\n@@ -790,9 +871,7 @@\n-    \/\/ MergeMems do not directly have anti-deps.\n-    \/\/ Treat them as internal nodes in a forward tree of memory states,\n-    \/\/ the leaves of which are each a 'possible-def'.\n-    if (use_mem_state == initial_mem    \/\/ root (exclusive) of tree we are searching\n-        || op == Op_MergeMem    \/\/ internal node of tree we are searching\n-        ) {\n-      def_mem_state = use_mem_state;   \/\/ It's not a possibly interfering store.\n-      if (use_mem_state == initial_mem)\n-        initial_mem = nullptr;  \/\/ only process initial memory once\n+    \/\/ If we are either at the search root or have found a MergeMem, we step\n+    \/\/ past use_mem_state and populate the search worklist with edges\n+    \/\/ (use_mem_state, child) for use_mem_state's children.\n+    if (def_mem_state == nullptr \/\/ root (exclusive) of tree we are searching\n+        || op == Op_MergeMem     \/\/ internal node of tree we are searching\n+    ) {\n+      def_mem_state = use_mem_state;\n@@ -803,2 +882,3 @@\n-          \/\/ use_mem_state is also a kind of load (i.e. needs_anti_dependence_check), and it is not a memory state\n-          \/\/ modifying node (store, Phi or MergeMem). Hence, load can't be anti dependent on this node.\n+          \/\/ use_mem_state is also a kind of load (i.e.,\n+          \/\/ needs_anti_dependence_check), and it is not a store nor a memory\n+          \/\/ Phi. Hence, it is not anti-dependent on the load.\n@@ -807,1 +887,1 @@\n-        worklist_def_use_mem_states.push(def_mem_state, use_mem_state);\n+        worklist.push(def_mem_state, use_mem_state);\n@@ -809,0 +889,2 @@\n+      \/\/ Nothing more to do for the current (nullptr, initial_mem) or\n+      \/\/ (initial_mem\/MergeMem, MergeMem) edge, move on.\n@@ -812,0 +894,3 @@\n+    assert(!use_mem_state->is_MergeMem(),\n+           \"use_mem_state should be either a store or a memory Phi\");\n+\n@@ -814,3 +899,3 @@\n-    \/\/ Compute the alias index.  Loads and stores with different alias\n-    \/\/ indices do not need anti-dependence edges.  Wide MemBar's are\n-    \/\/ anti-dependent on everything (except immutable memories).\n+    \/\/ Compute the alias index. If the use_mem_state has an alias index\n+    \/\/ different from the load's, it is not anti-dependent. Wide MemBar's\n+    \/\/ are anti-dependent with everything (except immutable memories).\n@@ -823,1 +908,1 @@\n-      MachNode* mstore = use_mem_state->as_Mach();\n+      MachNode* muse = use_mem_state->as_Mach();\n@@ -829,3 +914,3 @@\n-        if (mstore->ideal_Opcode() == Op_CallStaticJava) {\n-          assert(mstore->is_MachSafePoint(), \"\");\n-          MachSafePointNode* ms = (MachSafePointNode*) mstore;\n+        if (muse->ideal_Opcode() == Op_CallStaticJava) {\n+          assert(muse->is_MachSafePoint(), \"\");\n+          MachSafePointNode* ms = (MachSafePointNode*)muse;\n@@ -836,1 +921,1 @@\n-            \/\/ (other than Raw) and so do not require anti-dependence edges.\n+            \/\/ (other than Raw) and so are not anti-dependent.\n@@ -843,1 +928,1 @@\n-        if (mstore->ideal_Opcode() == Op_SafePoint)\n+        if (muse->ideal_Opcode() == Op_SafePoint) {\n@@ -845,0 +930,1 @@\n+        }\n@@ -849,1 +935,1 @@\n-        \/\/ Inserting an anti-dep between such a safepoint and a use\n+        \/\/ Inserting an anti-dependence edge between such a safepoint and a use\n@@ -853,1 +939,1 @@\n-        if (mstore->ideal_Opcode() == Op_SafePoint && load->in(0) == mstore)\n+        if (muse->ideal_Opcode() == Op_SafePoint && load->in(0) == muse) {\n@@ -855,0 +941,1 @@\n+        }\n@@ -858,6 +945,17 @@\n-    \/\/ Identify a block that the current load must be above,\n-    \/\/ or else observe that 'store' is all the way up in the\n-    \/\/ earliest legal block for 'load'.  In the latter case,\n-    \/\/ immediately insert an anti-dependence edge.\n-    Block* store_block = get_block_for_node(use_mem_state);\n-    assert(store_block != nullptr, \"unused killing projections skipped above\");\n+    \/\/ Determine the block of the use_mem_state.\n+    Block* use_mem_state_block = get_block_for_node(use_mem_state);\n+    assert(use_mem_state_block != nullptr,\n+           \"unused killing projections skipped above\");\n+\n+    \/\/ For efficiency, we take a lazy approach to both raising the LCA and\n+    \/\/ adding anti-dependence edges. In this worklist loop, we only mark blocks\n+    \/\/ which we must raise the LCA above (set_raise_LCA_mark), and keep\n+    \/\/ track of nodes that potentially need anti-dependence edges\n+    \/\/ (non_early_stores). The only exceptions to this are if we\n+    \/\/ immediately see that we have to raise the LCA all the way to the early\n+    \/\/ block, and if we find stores in the early block (which always need\n+    \/\/ anti-dependence edges).\n+    \/\/\n+    \/\/ After the worklist loop, we perform an efficient combined LCA-raising\n+    \/\/ operation over all marks and only then add anti-dependence edges where\n+    \/\/ strictly necessary according to the new raised LCA.\n@@ -866,2 +964,5 @@\n-      \/\/ Loop-phis need to raise load before input. (Other phis are treated\n-      \/\/ as store below.)\n+      \/\/ We have reached a memory Phi node. On our search from initial_mem to\n+      \/\/ the Phi, we have found no anti-dependences (otherwise, we would have\n+      \/\/ already terminated the search along this branch). Consider the example\n+      \/\/ below, indicating a Phi node and its node inputs (we omit the control\n+      \/\/ input).\n@@ -869,3 +970,5 @@\n-      \/\/ 'load' uses memory which is one (or more) of the Phi's inputs.\n-      \/\/ It must be scheduled not before the Phi, but rather before\n-      \/\/ each of the relevant Phi inputs.\n+      \/\/    def_mem_state\n+      \/\/          |\n+      \/\/          | ? ?\n+      \/\/          \\ | \/\n+      \/\/           Phi\n@@ -873,3 +976,5 @@\n-      \/\/ Instead of finding the LCA of all inputs to a Phi that match 'mem',\n-      \/\/ we mark each corresponding predecessor block and do a combined\n-      \/\/ hoisting operation later (raise_LCA_above_marks).\n+      \/\/ We reached the Phi from def_mem_state and know that, on this\n+      \/\/ particular input, the memory that the load must witness is not\n+      \/\/ overwritten. However, for the Phi's other inputs (? in the\n+      \/\/ illustration), we have no information and must thus conservatively\n+      \/\/ assume that the load's memory is overwritten at and below the Phi.\n@@ -877,1 +982,21 @@\n-      \/\/ Do not assert(store_block != early, \"Phi merging memory after access\")\n+      \/\/ It is impossible to schedule the load before the Phi in\n+      \/\/ the same block as the Phi (use_mem_state_block), and anti-dependence\n+      \/\/ edges are, therefore, redundant. We must, however, find the\n+      \/\/ predecessor block of use_mem_state_block that corresponds to\n+      \/\/ def_mem_state, and raise the LCA above that block. Note that this block\n+      \/\/ is not necessarily def_mem_state's block! See the continuation of our\n+      \/\/ previous example below (now illustrating blocks instead of nodes)\n+      \/\/\n+      \/\/    def_mem_state's block\n+      \/\/          |\n+      \/\/          |\n+      \/\/      pred_block\n+      \/\/          |\n+      \/\/          |   ?   ?\n+      \/\/          |   |   |\n+      \/\/      use_mem_state_block\n+      \/\/\n+      \/\/ Here, we must raise the LCA above pred_block rather than\n+      \/\/ def_mem_state's block.\n+      \/\/\n+      \/\/ Do not assert(use_mem_state_block != early, \"Phi merging memory after access\")\n@@ -879,0 +1004,4 @@\n+      if (LCA == early) {\n+        \/\/ Don't bother if LCA is already raised all the way\n+        continue;\n+      }\n@@ -883,1 +1012,1 @@\n-          Block* pred_block = get_block_for_node(store_block->pred(j));\n+          Block* pred_block = get_block_for_node(use_mem_state_block->pred(j));\n@@ -885,3 +1014,1 @@\n-            \/\/ If any predecessor of the Phi matches the load's \"early block\",\n-            \/\/ we do not need a precedence edge between the Phi and 'load'\n-            \/\/ since the load will be forced into a block preceding the Phi.\n+            \/\/ Lazily set the LCA mark\n@@ -889,6 +1016,5 @@\n-            assert(!LCA_orig->dominates(pred_block) ||\n-                   early->dominates(pred_block), \"early is high enough\");\n-            must_raise_LCA = true;\n-          } else {\n-            \/\/ anti-dependent upon PHI pinned below 'early', no edge needed\n-            LCA = early;             \/\/ but can not schedule below 'early'\n+            must_raise_LCA_above_marks = true;\n+          } else \/* if (pred_block == early) *\/ {\n+            \/\/ We know already now that we must raise LCA all the way to early.\n+            LCA = early;\n+            \/\/ This turns off the process of gathering non_early_stores.\n@@ -899,12 +1025,8 @@\n-    } else if (store_block != early) {\n-      \/\/ 'store' is between the current LCA and earliest possible block.\n-      \/\/ Label its block, and decide later on how to raise the LCA\n-      \/\/ to include the effect on LCA of this store.\n-      \/\/ If this store's block gets chosen as the raised LCA, we\n-      \/\/ will find him on the non_early_stores list and stick him\n-      \/\/ with a precedence edge.\n-      \/\/ (But, don't bother if LCA is already raised all the way.)\n-      if (LCA != early && !unrelated_load_in_store_null_block(use_mem_state, load)) {\n-        store_block->set_raise_LCA_mark(load_index);\n-        must_raise_LCA = true;\n-        non_early_stores.push(use_mem_state);\n+    } else if (use_mem_state_block != early) {\n+      \/\/ We found an anti-dependent store outside the load's 'early' block. The\n+      \/\/ store may be between the current LCA and the earliest possible block\n+      \/\/ (but it could very well also be on a distinct control-flow path).\n+      \/\/ Lazily set the LCA mark and push to non_early_stores.\n+      if (LCA == early) {\n+        \/\/ Don't bother if LCA is already raised all the way\n+        continue;\n@@ -912,4 +1034,10 @@\n-    } else {\n-      \/\/ Found a possibly-interfering store in the load's 'early' block.\n-      \/\/ This means 'load' cannot sink at all in the dominator tree.\n-      \/\/ Add an anti-dep edge, and squeeze 'load' into the highest block.\n+      if (unrelated_load_in_store_null_block(use_mem_state, load)) {\n+        continue;\n+      }\n+      use_mem_state_block->set_raise_LCA_mark(load_index);\n+      must_raise_LCA_above_marks = true;\n+      non_early_stores.push(use_mem_state);\n+    } else \/* if (use_mem_state_block == early) *\/ {\n+      \/\/ We found an anti-dependent store in the load's 'early' block.\n+      \/\/ Therefore, we know already now that we must raise LCA all the way to\n+      \/\/ early and that we need to add an anti-dependence edge to the store.\n@@ -927,1 +1055,1 @@\n-  \/\/ (Worklist is now empty; all nearby stores have been visited.)\n+  \/\/ Worklist is now empty; we have visited all possible anti-dependences.\n@@ -931,2 +1059,4 @@\n-  \/\/ precedence edges.\n-  if (LCA == early)  return LCA;\n+  \/\/ anti-dependence edges.\n+  if (LCA == early) {\n+    return LCA;\n+  }\n@@ -934,11 +1064,6 @@\n-  \/\/ We get here only if there are no possibly-interfering stores\n-  \/\/ in the load's 'early' block.  Move LCA up above all predecessors\n-  \/\/ which contain stores we have noted.\n-  \/\/\n-  \/\/ The raised LCA block can be a home to such interfering stores,\n-  \/\/ but its predecessors must not contain any such stores.\n-  \/\/\n-  \/\/ The raised LCA will be a lower bound for placing the load,\n-  \/\/ preventing the load from sinking past any block containing\n-  \/\/ a store that may invalidate the memory state required by 'load'.\n-  if (must_raise_LCA)\n+  \/\/ We get here only if there are no anti-dependent stores in the load's\n+  \/\/ 'early' block and if no memory Phi has forced LCA to the early block. Now\n+  \/\/ we must raise the LCA above the blocks for all the anti-dependent stores\n+  \/\/ and above the predecessor blocks of anti-dependent memory Phis we reached\n+  \/\/ during the search.\n+  if (must_raise_LCA_above_marks) {\n@@ -946,1 +1071,8 @@\n-  if (LCA == early)  return LCA;\n+  }\n+\n+  \/\/ If LCA == early at this point, there were no stores that required\n+  \/\/ anti-dependence edges in the early block. Otherwise, we would have eagerly\n+  \/\/ raised the LCA to early already in the worklist loop.\n+  if (LCA == early) {\n+    return LCA;\n+  }\n@@ -948,3 +1080,16 @@\n-  \/\/ Insert anti-dependence edges from 'load' to each store\n-  \/\/ in the non-early LCA block.\n-  \/\/ Mine the non_early_stores list for such stores.\n+  \/\/ The raised LCA block can now be a home to anti-dependent stores for which\n+  \/\/ we still need to add anti-dependence edges, but no LCA predecessor block\n+  \/\/ contains any such stores (otherwise, we would have raised the LCA even\n+  \/\/ higher).\n+  \/\/\n+  \/\/ The raised LCA will be a lower bound for placing the load, preventing the\n+  \/\/ load from sinking past any block containing a store that may overwrite\n+  \/\/ memory that the load must witness.\n+  \/\/\n+  \/\/ Now we need to insert the necessary anti-dependence edges from 'load' to\n+  \/\/ each store in the non-early LCA block. We have recorded all such potential\n+  \/\/ stores in non_early_stores.\n+  \/\/\n+  \/\/ If LCA->raise_LCA_mark() != load_index, it means that we raised the LCA to\n+  \/\/ a block in which we did not find any anti-dependent stores. So, no need to\n+  \/\/ search for any such stores.\n@@ -956,1 +1101,2 @@\n-        \/\/ add anti_dependence from store to load in its own block\n+        \/\/ Add anti-dependence edge from the load to the store in the non-early\n+        \/\/ LCA.\n@@ -965,5 +1111,0 @@\n-        \/\/ Any other stores we found must be either inside the new LCA\n-        \/\/ or else outside the original LCA.  In the latter case, they\n-        \/\/ did not interfere with any use of 'load'.\n-        assert(LCA->dominates(store_block)\n-               || !LCA_orig->dominates(store_block), \"no stray stores\");\n@@ -974,0 +1115,2 @@\n+  assert(LCA->dominates(LCA_orig), \"unsound updated LCA\");\n+\n@@ -1538,1 +1681,1 @@\n-      LCA = insert_anti_dependences(LCA, self);\n+      LCA = raise_above_anti_dependences(LCA, self);\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":285,"deletions":142,"binary":false,"changes":427,"status":"modified"},{"patch":"@@ -520,1 +520,1 @@\n-        insert_anti_dependences(block, n);\n+        raise_above_anti_dependences(block, n);\n@@ -1393,1 +1393,1 @@\n-        insert_anti_dependences(sb, clone);\n+        raise_above_anti_dependences(sb, clone);\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8364,0 +8364,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,0 +139,4 @@\n+#ifndef PRODUCT\n+  uint _stress_peeling_attempts = 0;\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -503,0 +503,1 @@\n+  virtual uint size_of() const { return sizeof(MachConstantNode); }\n@@ -573,0 +574,2 @@\n+private:\n+  bool _do_polling;\n@@ -578,5 +581,1 @@\n-\n-private:\n-  bool _do_polling;\n-\n-public:\n+  virtual uint size_of() const { return sizeof(MachEpilogNode); }\n@@ -606,0 +605,1 @@\n+  virtual uint size_of() const { return sizeof(MachNopNode); }\n@@ -833,0 +833,1 @@\n+  virtual uint size_of() const { return sizeof(MachJumpNode); }\n@@ -931,0 +932,1 @@\n+  virtual uint size_of() const { return sizeof(MachSafePointNode); }\n@@ -1046,0 +1048,1 @@\n+  virtual uint size_of() const { return sizeof(MachCallDynamicJavaNode); }\n@@ -1079,0 +1082,1 @@\n+  virtual uint size_of() const { return sizeof(MachHaltNode); }\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1134,0 +1134,5 @@\n+  virtual uint size_of() const { return sizeof(ClearArrayNode); }\n+  virtual uint hash() const { return Node::hash() + _is_large; }\n+  virtual bool cmp(const Node& n) const {\n+    return Node::cmp(n) && _is_large == ((ClearArrayNode&)n).is_large();\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3130,1 +3130,1 @@\n-            if (u->in(j) == n) {\n+            if (u->in(j) == n && r->in(j) != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1517,0 +1517,1 @@\n+\n@@ -1589,0 +1590,1 @@\n+\n@@ -2080,1 +2082,1 @@\n-  if (!StressCompiledExceptionHandlers && doit) {\n+  if (DeoptimizeOnAllocationException && doit) {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-  static const TypeFunc* kyberNtt_Type() {\n+  static inline const TypeFunc* kyberNtt_Type() {\n@@ -610,1 +610,1 @@\n-  static const TypeFunc* kyberInverseNtt_Type() {\n+  static inline const TypeFunc* kyberInverseNtt_Type() {\n@@ -615,1 +615,1 @@\n-  static const TypeFunc* kyberNttMult_Type() {\n+  static inline const TypeFunc* kyberNttMult_Type() {\n@@ -620,1 +620,1 @@\n-  static const TypeFunc* kyberAddPoly_2_Type() {\n+  static inline const TypeFunc* kyberAddPoly_2_Type() {\n@@ -625,1 +625,1 @@\n-  static const TypeFunc* kyberAddPoly_3_Type() {\n+  static inline const TypeFunc* kyberAddPoly_3_Type() {\n@@ -630,1 +630,1 @@\n-  static const TypeFunc* kyber12To16_Type() {\n+  static inline const TypeFunc* kyber12To16_Type() {\n@@ -635,1 +635,1 @@\n-  static const TypeFunc* kyberBarrettReduce_Type() {\n+  static inline const TypeFunc* kyberBarrettReduce_Type() {\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2960,1 +2960,1 @@\n-    if (log_is_enabled(Info, cds)) {\n+    if (log_is_enabled(Info, aot)) {\n@@ -2963,1 +2963,1 @@\n-      log_info(cds)(\"JVM_StartThread() ignored: %s\", t->klass()->external_name());\n+      log_info(aot)(\"JVM_StartThread() ignored: %s\", t->klass()->external_name());\n@@ -3663,1 +3663,1 @@\n-    log_debug(cds)(\"JVM_GetRandomSeedForDumping() = \" JLONG_FORMAT, seed);\n+    log_debug(aot)(\"JVM_GetRandomSeedForDumping() = \" JLONG_FORMAT, seed);\n@@ -3726,1 +3726,1 @@\n-      log_debug(cds)(\"NeedsClassInitBarrierForCDS: %s\", k->external_name());\n+      log_debug(aot)(\"NeedsClassInitBarrierForCDS: %s\", k->external_name());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1250,0 +1250,3 @@\n+  \/\/ caller->constants->copy_bootstrap_arguments_at performs a runtime\n+  \/\/ range check, but let's assert earlier as well.\n+  assert(start < end && start >= 0, \"invariant\");\n@@ -1270,47 +1273,2 @@\n-  objArrayHandle buf(THREAD, (objArrayOop) JNIHandles::resolve(buf_jh));\n-  if (start < 0) {\n-    for (int pseudo_index = -4; pseudo_index < 0; pseudo_index++) {\n-      if (start == pseudo_index) {\n-        if (start >= end || 0 > pos || pos >= buf->length())  break;\n-        oop pseudo_arg = nullptr;\n-        switch (pseudo_index) {\n-        case -4:  \/\/ bootstrap method\n-          {\n-            int bsm_index = caller->constants()->bootstrap_method_ref_index_at(bss_index_in_pool);\n-            pseudo_arg = caller->constants()->resolve_possibly_cached_constant_at(bsm_index, CHECK);\n-            break;\n-          }\n-        case -3:  \/\/ name\n-          {\n-            Symbol* name = caller->constants()->name_ref_at(bss_index_in_pool, Bytecodes::_invokedynamic);\n-            Handle str = java_lang_String::create_from_symbol(name, CHECK);\n-            pseudo_arg = str();\n-            break;\n-          }\n-        case -2:  \/\/ type\n-          {\n-            Symbol* type = caller->constants()->signature_ref_at(bss_index_in_pool, Bytecodes::_invokedynamic);\n-            Handle th;\n-            if (type->char_at(0) == JVM_SIGNATURE_FUNC) {\n-              th = SystemDictionary::find_method_handle_type(type, caller, CHECK);\n-            } else {\n-              th = SystemDictionary::find_java_mirror_for_type(type, caller, SignatureStream::NCDFError, CHECK);\n-            }\n-            pseudo_arg = th();\n-            break;\n-          }\n-        case -1:  \/\/ argument count\n-          {\n-            int argc = caller->constants()->bootstrap_argument_count_at(bss_index_in_pool);\n-            jvalue argc_value; argc_value.i = (jint)argc;\n-            pseudo_arg = java_lang_boxing_object::create(T_INT, &argc_value, CHECK);\n-            break;\n-          }\n-        }\n-        \/\/ Store the pseudo-argument, and advance the pointers.\n-        buf->obj_at_put(pos++, pseudo_arg);\n-        ++start;\n-      }\n-    }\n-    \/\/ When we are done with this there may be regular arguments to process too.\n-  }\n+  objArrayHandle buf(THREAD, (objArrayOop)JNIHandles::resolve(buf_jh));\n+\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":5,"deletions":47,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotLogging.hpp\"\n@@ -89,0 +90,3 @@\n+#if INCLUDE_JVMCI\n+bool   Arguments::_jvmci_module_added           = false;\n+#endif\n@@ -335,2 +339,1 @@\n-    if (matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n-        matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||\n+    if (matches_property_suffix(property_suffix, PATCH, PATCH_LEN) ||\n@@ -347,0 +350,1 @@\n+          matches_property_suffix(property_suffix, ADDREADS, ADDREADS_LEN) ||\n@@ -1366,1 +1370,1 @@\n-    log_error(cds)(\"%s is incompatible with other specified options.\",\n+    aot_log_error(aot)(\"%s is incompatible with other specified options.\",\n@@ -1375,1 +1379,1 @@\n-      log_warning(cds)(\"Unable to use AOT cache: %s\", message);\n+      log_warning(aot)(\"Unable to use AOT cache: %s\", message);\n@@ -1377,1 +1381,1 @@\n-      log_info(cds)(\"Unable to use shared archive: %s\", message);\n+      aot_log_info(aot)(\"Unable to use shared archive: %s\", message);\n@@ -1566,1 +1570,1 @@\n-          log_info(cds)(\"UseCompressedOops and UseCompressedClassPointers have been disabled due to\"\n+          aot_log_info(aot)(\"UseCompressedOops and UseCompressedClassPointers have been disabled due to\"\n@@ -1801,3 +1805,3 @@\n-    PropertyList_unique_add(&_system_properties, \"jdk.internal.vm.ci.enabled\", \"true\",\n-        AddProperty, UnwriteableProperty, InternalProperty);\n-    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+    \/\/ Add the JVMCI module if not using libjvmci or EnableJVMCI\n+    \/\/ was explicitly set on the command line or in the jimage.\n+    if ((!UseJVMCINativeLibrary || FLAG_IS_CMDLINE(EnableJVMCI) || FLAG_IS_JIMAGE_RESOURCE(EnableJVMCI)) && ClassLoader::is_module_observable(\"jdk.internal.vm.ci\") && !_jvmci_module_added) {\n@@ -2311,0 +2315,13 @@\n+#if INCLUDE_JVMCI\n+      if (!_jvmci_module_added) {\n+        const char *jvmci_module = strstr(tail, \"jdk.internal.vm.ci\");\n+        if (jvmci_module != nullptr) {\n+          char before = *(jvmci_module - 1);\n+          char after  = *(jvmci_module + strlen(\"jdk.internal.vm.ci\"));\n+          if ((before == '=' || before == ',') && (after == '\\0' || after == ',')) {\n+            FLAG_SET_DEFAULT(EnableJVMCI, true);\n+            _jvmci_module_added = true;\n+          }\n+        }\n+      }\n+#endif\n@@ -3699,1 +3716,1 @@\n-      log_is_enabled(Info, cds)) {\n+      log_is_enabled(Info, cds) || log_is_enabled(Info, aot)) {\n@@ -3703,0 +3720,1 @@\n+    LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(aot));\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -201,0 +201,4 @@\n+#if INCLUDE_JVMCI\n+  \/\/ was jdk.internal.vm.ci module specified in the --add-modules option?\n+  static bool _jvmci_module_added;\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -330,0 +330,1 @@\n+                                                                            \\\n@@ -653,0 +654,4 @@\n+  product(bool, DeoptimizeOnAllocationException, false, DIAGNOSTIC,         \\\n+          \"Deoptimize on exception during allocation instead of using the \" \\\n+          \"compiled exception handlers\")                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3345,1 +3345,1 @@\n-    LogStreamHandle(Trace, cds) lsh;\n+    LogStreamHandle(Trace, aot) lsh;\n@@ -3359,1 +3359,1 @@\n-        log_trace(cds)(\"Added fp=%p (%s), entry=%p to the archived adater table\", buffered_fp, buffered_fp->as_basic_args_string(), buffered_entry);\n+        log_trace(aot)(\"Added fp=%p (%s), entry=%p to the archived adater table\", buffered_fp, buffered_fp->as_basic_args_string(), buffered_entry);\n@@ -3363,1 +3363,1 @@\n-        log_trace(cds)(\"Skipping adapter handler %p (fp=%s) as it is not archived\", entry, fp->as_basic_args_string());\n+        log_trace(aot)(\"Skipping adapter handler %p (fp=%s) as it is not archived\", entry, fp->as_basic_args_string());\n@@ -3411,1 +3411,1 @@\n-      log_warning(cds)(\"Failed to link AdapterHandlerEntry (fp=%s) to its code in the AOT code cache\", _fingerprint->as_basic_args_string());\n+      log_warning(aot)(\"Failed to link AdapterHandlerEntry (fp=%s) to its code in the AOT code cache\", _fingerprint->as_basic_args_string());\n@@ -3521,1 +3521,1 @@\n-  LogStreamHandle(Trace, cds) lsh;\n+  LogStreamHandle(Trace, aot) lsh;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -915,1 +915,1 @@\n-    if (log_is_enabled(Trace, cds, heap)) {\n+    if (log_is_enabled(Trace, aot, heap)) {\n@@ -918,1 +918,1 @@\n-        log_trace(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n+        log_trace(aot, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s) referenced by \" INTPTR_FORMAT \" (%s)\",\n@@ -922,1 +922,1 @@\n-        log_trace(cds, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\",\n+        log_trace(aot, heap)(\"skipped dormant archived object \" INTPTR_FORMAT \" (%s)\",\n@@ -3200,1 +3200,1 @@\n-    log_debug(cds, heap)(\"Error %s while dumping heap\", error());\n+    log_debug(aot, heap)(\"Error %s while dumping heap\", error());\n@@ -3232,2 +3232,1 @@\n-    char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);\n-    strcpy(str, error());\n+    char* str = ResourceArea::strdup(error());\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3734,1 +3734,1 @@\n-                int ascii = JLA.countPositives(buf, pos, Math.min(avail, (int)utflen));\n+                int ascii = JLA.uncheckedCountPositives(buf, pos, Math.min(avail, (int)utflen));\n@@ -3747,1 +3747,1 @@\n-                    JLA.inflateBytesToChars(buf, pos, cbuf, 0, ascii);\n+                    JLA.uncheckedInflateBytesToChars(buf, pos, cbuf, 0, ascii);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-            DecimalDigits.getCharsLatin1(i, size, buf);\n+            DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n@@ -449,1 +449,1 @@\n-            DecimalDigits.getCharsUTF16(i, size, buf);\n+            DecimalDigits.uncheckedGetCharsUTF16(i, size, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-            DecimalDigits.getCharsLatin1(i, size, buf);\n+            DecimalDigits.uncheckedGetCharsLatin1(i, size, buf);\n@@ -480,1 +480,1 @@\n-            DecimalDigits.getCharsUTF16(i, size, buf);\n+            DecimalDigits.uncheckedGetCharsUTF16(i, size, buf);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2137,1 +2137,1 @@\n-            public int countPositives(byte[] bytes, int offset, int length) {\n+            public int uncheckedCountPositives(byte[] bytes, int offset, int length) {\n@@ -2143,1 +2143,1 @@\n-            public String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n+            public String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException  {\n@@ -2146,1 +2146,1 @@\n-            public char getUTF16Char(byte[] bytes, int index) {\n+            public char uncheckedGetUTF16Char(byte[] bytes, int index) {\n@@ -2149,1 +2149,1 @@\n-            public void putCharUTF16(byte[] bytes, int index, int ch) {\n+            public void uncheckedPutCharUTF16(byte[] bytes, int index, int ch) {\n@@ -2152,1 +2152,1 @@\n-            public byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n+            public byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException {\n@@ -2164,1 +2164,1 @@\n-            public void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            public void uncheckedInflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n@@ -2168,1 +2168,1 @@\n-            public int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n+            public int uncheckedDecodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len) {\n@@ -2172,1 +2172,1 @@\n-            public int encodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -2208,1 +2208,1 @@\n-            public Object stringConcat1(String[] constants) {\n+            public Object uncheckedStringConcat1(String[] constants) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-public non-sealed class PhantomReference<T> extends Reference<T> {\n+public non-sealed class PhantomReference<@jdk.internal.RequiresIdentity T> extends Reference<T> {\n@@ -115,1 +115,1 @@\n-    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n+    public PhantomReference(@jdk.internal.RequiresIdentity T referent, ReferenceQueue<? super T> q) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-public abstract sealed class Reference<T>\n+public abstract sealed class Reference<@jdk.internal.RequiresIdentity T>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-public non-sealed class SoftReference<T> extends Reference<T> {\n+public non-sealed class SoftReference<@jdk.internal.RequiresIdentity T> extends Reference<T> {\n@@ -97,1 +97,1 @@\n-    public SoftReference(T referent) {\n+    public SoftReference(@jdk.internal.RequiresIdentity T referent) {\n@@ -112,1 +112,1 @@\n-    public SoftReference(T referent, ReferenceQueue<? super T> q) {\n+    public SoftReference(@jdk.internal.RequiresIdentity T referent, ReferenceQueue<? super T> q) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/SoftReference.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-public non-sealed class WeakReference<T> extends Reference<T> {\n+public non-sealed class WeakReference<@jdk.internal.RequiresIdentity T> extends Reference<T> {\n@@ -69,1 +69,1 @@\n-    public WeakReference(T referent) {\n+    public WeakReference(@jdk.internal.RequiresIdentity T referent) {\n@@ -83,1 +83,1 @@\n-    public WeakReference(T referent, ReferenceQueue<? super T> q) {\n+    public WeakReference(@jdk.internal.RequiresIdentity T referent, ReferenceQueue<? super T> q) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/WeakReference.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-public class WeakHashMap<K,V>\n+public class WeakHashMap<@jdk.internal.RequiresIdentity K,V>\n@@ -479,1 +479,1 @@\n-    public V put(K key, V value) {\n+    public V put(@jdk.internal.RequiresIdentity K key, V value) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -306,0 +306,2 @@\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -307,1 +309,1 @@\n-    int countPositives(byte[] ba, int off, int len);\n+    int uncheckedCountPositives(byte[] ba, int off, int len);\n@@ -315,5 +317,6 @@\n-     * Constructs a new {@code String} by decoding the specified subarray of\n-     * bytes using the specified {@linkplain java.nio.charset.Charset charset}.\n-     *\n-     * The caller of this method shall relinquish and transfer the ownership of\n-     * the byte array to the callee since the later will not make a copy.\n+     * Constructs a new {@code String} by decoding the specified byte array\n+     * using the specified {@linkplain java.nio.charset.Charset charset}.\n+     * <p>\n+     * <b>WARNING: The caller of this method shall relinquish and transfer the\n+     * ownership of the byte array to the callee<\/b>, since the latter will not\n+     * make a copy.\n@@ -326,1 +329,1 @@\n-    String newStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;\n+    String uncheckedNewStringNoRepl(byte[] bytes, Charset cs) throws CharacterCodingException;\n@@ -329,7 +332,9 @@\n-     * Encode the given string into a sequence of bytes using the specified Charset.\n-     *\n-     * This method avoids copying the String's internal representation if the input\n-     * is ASCII.\n-     *\n-     * This method throws CharacterCodingException instead of replacing when\n-     * malformed input or unmappable characters are encountered.\n+     * Encode the given string into a sequence of bytes using the specified\n+     * {@linkplain java.nio.charset.Charset charset}.\n+     * <p>\n+     * <b>WARNING: This method returns the {@code byte[]} backing the provided\n+     * {@code String}, if the input is ASCII. Hence, the returned byte array\n+     * must not be modified.<\/b>\n+     * <p>\n+     * This method throws {@code CharacterCodingException} instead of replacing\n+     * when malformed input or unmappable characters are encountered.\n@@ -342,1 +347,1 @@\n-    byte[] getBytesNoRepl(String s, Charset cs) throws CharacterCodingException;\n+    byte[] uncheckedGetBytesNoRepl(String s, Charset cs) throws CharacterCodingException;\n@@ -345,1 +350,1 @@\n-     * Returns a new string by decoding from the given utf8 bytes array.\n+     * Returns a new string by decoding from the given UTF-8 bytes array.\n@@ -355,2 +360,4 @@\n-     * Get the char at index in a byte[] in internal UTF-16 representation,\n-     * with no bounds checks.\n+     * Get the {@code char} at {@code index} in a {@code byte[]} in internal\n+     * UTF-16 representation.\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -362,1 +369,1 @@\n-    char getUTF16Char(byte[] bytes, int index);\n+    char uncheckedGetUTF16Char(byte[] bytes, int index);\n@@ -365,2 +372,4 @@\n-     * Put the char at index in a byte[] in internal UTF-16 representation,\n-     * with no bounds checks.\n+     * Put the {@code ch} at {@code index} in a {@code byte[]} in internal\n+     * UTF-16 representation.\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -371,1 +380,1 @@\n-    void putCharUTF16(byte[] bytes, int index, int ch);\n+    void uncheckedPutCharUTF16(byte[] bytes, int index, int ch);\n@@ -383,1 +392,4 @@\n-     * Inflated copy from byte[] to char[], as defined by StringLatin1.inflate\n+     * Inflated copy from {@code byte[]} to {@code char[]}, as defined by\n+     * {@code StringLatin1.inflate}.\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -385,1 +397,1 @@\n-    void inflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n+    void uncheckedInflateBytesToChars(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n@@ -390,0 +402,2 @@\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -393,1 +407,1 @@\n-    int decodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n+    int uncheckedDecodeASCII(byte[] src, int srcOff, char[] dst, int dstOff, int len);\n@@ -407,1 +421,1 @@\n-     * Encodes ASCII codepoints as possible from the source array into\n+     * Encodes as many ASCII codepoints as possible from the source array into\n@@ -409,1 +423,3 @@\n-     * compatible\n+     * compatible.\n+     * <p>\n+     * <b>WARNING: This method does not perform any bound checks.<\/b>\n@@ -413,1 +429,1 @@\n-    int encodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n@@ -446,1 +462,8 @@\n-    Object stringConcat1(String[] constants);\n+    \/**\n+     * Creates helper for string concatenation.\n+     * <p>\n+     * <b>WARNING: The caller of this method shall relinquish and transfer the\n+     * ownership of the string array to the callee<\/b>, since the latter will not\n+     * make a copy.\n+     *\/\n+    Object uncheckedStringConcat1(String[] constants);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":52,"deletions":29,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -81,2 +81,1 @@\n-        @JEP(number=478, title=\"Key Derivation Function API\", status=\"Preview\")\n-        KEY_DERIVATION,\n+        KEY_DERIVATION, \/\/remove when the boot JDK is JDK 25\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -158,1 +158,0 @@\n-        jdk.crypto.cryptoki, \/\/ participates in preview features\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -29,0 +30,1 @@\n+import java.util.Collections;\n@@ -30,0 +32,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -32,1 +36,1 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Set;\n@@ -122,1 +126,1 @@\n-    private static final Map<String, LintCategory> map = new ConcurrentHashMap<>(20);\n+    private static final Map<String, LintCategory> map = new LinkedHashMap<>(40);\n@@ -152,1 +156,1 @@\n-        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, \"all\")) {\n+        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_ALL)) {\n@@ -155,1 +159,1 @@\n-        } else if (options.isSet(Option.XLINT_CUSTOM, \"none\")) {\n+        } else if (options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_NONE)) {\n@@ -176,1 +180,1 @@\n-            values.add(LintCategory.SYNCHRONIZATION);\n+            values.add(LintCategory.IDENTITY);\n@@ -182,1 +186,1 @@\n-            if (options.isSet(Option.XLINT_CUSTOM, lc.option)) {\n+            if (options.isExplicitlyEnabled(Option.XLINT, lc)) {\n@@ -184,1 +188,1 @@\n-            } else if (options.isSet(Option.XLINT_CUSTOM, \"-\" + lc.option)) {\n+            } else if (options.isExplicitlyDisabled(Option.XLINT, lc)) {\n@@ -264,0 +268,5 @@\n+        \/**\n+         * Warn about uses of @ValueBased classes where an identity class is expected.\n+         *\/\n+        IDENTITY(\"identity\", true, \"synchronization\"),\n+\n@@ -371,5 +380,0 @@\n-        \/**\n-         * Warn about synchronization attempts on instances of @ValueBased classes.\n-         *\/\n-        SYNCHRONIZATION(\"synchronization\"),\n-\n@@ -418,1 +422,1 @@\n-        LintCategory(String option, boolean annotationSuppression) {\n+        LintCategory(String option, boolean annotationSuppression, String... aliases) {\n@@ -421,1 +425,5 @@\n-            map.put(option, this);\n+            ArrayList<String> optionList = new ArrayList<>(1 + aliases.length);\n+            optionList.add(option);\n+            Collections.addAll(optionList, aliases);\n+            this.optionList = Collections.unmodifiableList(optionList);\n+            this.optionList.forEach(ident -> map.put(ident, this));\n@@ -434,0 +442,7 @@\n+        \/**\n+         * Get all lint category option strings and aliases.\n+         *\/\n+        public static Set<String> options() {\n+            return Collections.unmodifiableSet(map.keySet());\n+        }\n+\n@@ -438,1 +453,1 @@\n-        \/** Get the string representing this category in @SuppressAnnotations and -Xlint options. *\/\n+        \/** Get the \"canonical\" string representing this category in @SuppressAnnotations and -Xlint options. *\/\n@@ -441,0 +456,3 @@\n+        \/** Get a list containing \"option\" followed by zero or more aliases. *\/\n+        public final List<String> optionList;\n+\n@@ -504,14 +522,0 @@\n-    \/**\n-     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n-     *\n-     * @param annotation @SuppressWarnings annotation, or null\n-     * @return set of lint categories, possibly empty but never null\n-     *\/\n-    private EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n-        initializeSymbolsIfNeeded();\n-        if (annotation == null)\n-            return LintCategory.newEmptySet();\n-        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n-        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -229,0 +229,2 @@\n+    public final Type requiresIdentityType;\n+    public final Type requiresIdentityInternalType;\n@@ -629,0 +631,2 @@\n+        requiresIdentityType = enterClass(\"jdk.internal.RequiresIdentity\");\n+        requiresIdentityInternalType = enterSyntheticAnnotation(\"jdk.internal.RequiresIdentity+Annotation\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -683,0 +683,4 @@\n+    public boolean isValueBased() {\n+        return tsym != null && (tsym.flags_field & VALUE_BASED) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-            if (tree.restype != null && !tree.restype.type.hasTag(VOID))\n+            if (tree.restype != null && !tree.restype.type.hasTag(VOID)) {\n@@ -1058,0 +1058,2 @@\n+            }\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -1350,0 +1352,1 @@\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -1975,1 +1978,1 @@\n-        if (identityType && isValueBased(tree.lock.type)) {\n+        if (identityType && tree.lock.type != null && tree.lock.type.isValueBased()) {\n@@ -1981,4 +1984,0 @@\n-        \/\/ where\n-        private boolean isValueBased(Type t) {\n-            return t != null && t.tsym != null && (t.tsym.flags() & VALUE_BASED) != 0;\n-        }\n@@ -2697,0 +2696,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -2939,0 +2939,2 @@\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n+\n@@ -3818,0 +3820,1 @@\n+            chk.checkRequiresIdentity(that, localEnv.info.lint);\n@@ -4121,0 +4124,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -4262,0 +4266,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -5497,2 +5502,7 @@\n-                                log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n-                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n+                                if(c.isInterface()) {\n+                                    log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                            Errors.InvalidPermitsClause(Fragments.DoesntImplementSealed(kindName(subType.tsym), subType)));\n+                                } else {\n+                                    log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                            Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n+                                }\n@@ -5621,0 +5631,2 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -49,0 +50,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -5828,0 +5830,176 @@\n+    void checkRequiresIdentity(JCTree tree, Lint lint) {\n+        switch (tree) {\n+            case JCClassDecl classDecl -> {\n+                Type st = types.supertype(classDecl.sym.type);\n+                if (st != null &&\n+                        \/\/ no need to recheck j.l.Object, shortcut,\n+                        st.tsym != syms.objectType.tsym &&\n+                        \/\/ this one could be null, no explicit extends\n+                        classDecl.extending != null) {\n+                    checkIfIdentityIsExpected(classDecl.extending.pos(), st, lint);\n+                }\n+                for (JCExpression intrface: classDecl.implementing) {\n+                    checkIfIdentityIsExpected(intrface.pos(), intrface.type, lint);\n+                }\n+                for (JCTypeParameter tp : classDecl.typarams) {\n+                    checkIfIdentityIsExpected(tp.pos(), tp.type, lint);\n+                }\n+            }\n+            case JCVariableDecl variableDecl -> {\n+                if (variableDecl.vartype != null &&\n+                        (variableDecl.sym.flags_field & RECORD) == 0 ||\n+                        (variableDecl.sym.flags_field & ~(Flags.PARAMETER | RECORD | GENERATED_MEMBER)) != 0) {\n+                    \/* we don't want to warn twice so if this variable is a compiler generated parameter of\n+                     * a canonical record constructor, we don't want to issue a warning as we will warn the\n+                     * corresponding compiler generated private record field anyways\n+                     *\/\n+                    checkIfIdentityIsExpected(variableDecl.vartype.pos(), variableDecl.vartype.type, lint);\n+                }\n+            }\n+            case JCTypeCast typeCast -> checkIfIdentityIsExpected(typeCast.clazz.pos(), typeCast.clazz.type, lint);\n+            case JCBindingPattern bindingPattern -> {\n+                if (bindingPattern.var.vartype != null) {\n+                    checkIfIdentityIsExpected(bindingPattern.var.vartype.pos(), bindingPattern.var.vartype.type, lint);\n+                }\n+            }\n+            case JCMethodDecl methodDecl -> {\n+                for (JCTypeParameter tp : methodDecl.typarams) {\n+                    checkIfIdentityIsExpected(tp.pos(), tp.type, lint);\n+                }\n+                if (methodDecl.restype != null && !methodDecl.restype.type.hasTag(VOID)) {\n+                    checkIfIdentityIsExpected(methodDecl.restype.pos(), methodDecl.restype.type, lint);\n+                }\n+            }\n+            case JCMemberReference mref -> {\n+                checkIfIdentityIsExpected(mref.expr.pos(), mref.target, lint);\n+                checkIfTypeParamsRequiresIdentity(mref.sym.getMetadata(), mref.typeargs, lint);\n+            }\n+            case JCPolyExpression poly\n+                when (poly instanceof JCNewClass || poly instanceof JCMethodInvocation) -> {\n+                if (poly instanceof JCNewClass newClass) {\n+                    checkIfIdentityIsExpected(newClass.clazz.pos(), newClass.clazz.type, lint);\n+                }\n+                List<JCExpression> argExps = poly instanceof JCNewClass ?\n+                        ((JCNewClass)poly).args :\n+                        ((JCMethodInvocation)poly).args;\n+                Symbol msym = TreeInfo.symbolFor(poly);\n+                if (msym != null) {\n+                    if (!argExps.isEmpty() && msym instanceof MethodSymbol ms && ms.params != null) {\n+                        VarSymbol lastParam = ms.params.head;\n+                        for (VarSymbol param: ms.params) {\n+                            if (param.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                            }\n+                            lastParam = param;\n+                            argExps = argExps.tail;\n+                        }\n+                        while (argExps != null && !argExps.isEmpty() && lastParam != null) {\n+                            if (lastParam.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                            }\n+                            argExps = argExps.tail;\n+                        }\n+                    }\n+                    checkIfTypeParamsRequiresIdentity(\n+                            msym.getMetadata(),\n+                            poly instanceof JCNewClass ?\n+                                ((JCNewClass)poly).typeargs :\n+                                ((JCMethodInvocation)poly).typeargs,\n+                            lint);\n+                }\n+            }\n+            default -> throw new AssertionError(\"unexpected tree \" + tree);\n+        }\n+    }\n+\n+    \/** Check if a type required an identity class\n+     *\/\n+    private boolean checkIfIdentityIsExpected(DiagnosticPosition pos, Type t, Lint lint) {\n+        if (t != null &&\n+                lint != null &&\n+                lint.isEnabled(LintCategory.IDENTITY)) {\n+            RequiresIdentityVisitor requiresIdentityVisitor = new RequiresIdentityVisitor();\n+            \/\/ we need to avoid recursion due to self referencing type vars or captures, this is why we need a set\n+            requiresIdentityVisitor.visit(t, new HashSet<>());\n+            if (requiresIdentityVisitor.requiresWarning) {\n+                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ where\n+    private class RequiresIdentityVisitor extends Types.SimpleVisitor<Void, Set<Type>> {\n+        boolean requiresWarning = false;\n+\n+        @Override\n+        public Void visitType(Type t, Set<Type> seen) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(WildcardType t, Set<Type> seen) {\n+            return visit(t.type, seen);\n+        }\n+\n+        @Override\n+        public Void visitTypeVar(TypeVar t, Set<Type> seen) {\n+            if (seen.add(t)) {\n+                visit(t.getUpperBound(), seen);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitCapturedType(CapturedType t, Set<Type> seen) {\n+            if (seen.add(t)) {\n+                visit(t.getUpperBound(), seen);\n+                visit(t.getLowerBound(), seen);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, Set<Type> seen) {\n+            return visit(t.elemtype, seen);\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, Set<Type> seen) {\n+            if (t != null && t.tsym != null) {\n+                SymbolMetadata sm = t.tsym.getMetadata();\n+                if (sm != null && !t.getTypeArguments().isEmpty()) {\n+                    if (sm.getTypeAttributes().stream()\n+                            .filter(ta -> ta.type.tsym == syms.requiresIdentityType.tsym &&\n+                                    t.getTypeArguments().get(ta.position.parameter_index) != null &&\n+                                    t.getTypeArguments().get(ta.position.parameter_index).isValueBased()).findAny().isPresent()) {\n+                        requiresWarning = true;\n+                        return null;\n+                    }\n+                }\n+            }\n+            visit(t.getEnclosingType(), seen);\n+            for (Type targ : t.getTypeArguments()) {\n+                visit(targ, seen);\n+            }\n+            return null;\n+        }\n+    } \/\/ RequiresIdentityVisitor\n+\n+    private void checkIfTypeParamsRequiresIdentity(SymbolMetadata sm,\n+                                                     List<JCExpression> typeParamTrees,\n+                                                     Lint lint) {\n+        if (typeParamTrees != null && !typeParamTrees.isEmpty()) {\n+            for (JCExpression targ : typeParamTrees) {\n+                checkIfIdentityIsExpected(targ.pos(), targ.type, lint);\n+            }\n+            if (sm != null)\n+                sm.getTypeAttributes().stream()\n+                        .filter(ta -> (ta.type.tsym == syms.requiresIdentityType.tsym) &&\n+                                typeParamTrees.get(ta.position.parameter_index).type != null &&\n+                                typeParamTrees.get(ta.position.parameter_index).type.isValueBased())\n+                        .forEach(ta -> lint.logIfEnabled(typeParamTrees.get(ta.position.parameter_index).pos(),\n+                                CompilerProperties.LintWarnings.AttemptToUseValueBasedWhereIdentityExpected));\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -4026,5 +4026,13 @@\n-        return env.info.ctorPrologue &&\n-            (v.flags() & STATIC) == 0 &&\n-            v.owner.kind == TYP &&\n-            types.isSubtype(env.enclClass.type, v.owner.type) &&\n-            (base == null || TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base));\n+        if (env.info.ctorPrologue &&\n+                (v.flags() & STATIC) == 0 &&\n+                v.isMemberOf(env.enclClass.sym, types)) {\n+\n+            \/\/ Allow \"Foo.this.x\" when \"Foo\" is (also) an outer class, as this refers to the outer instance\n+            if (base != null) {\n+                return TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.type, base);\n+            }\n+\n+            \/\/ It's an early reference to an instance field member of the current instance\n+            return true;\n+        }\n+        return false;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3974,1 +3974,5 @@\n-    subclass {0} must extend sealed class\n+    class {0} must extend sealed class\n+\n+# 0: kind name, 1: type\n+compiler.misc.doesnt.implement.sealed=\\\n+    {0} {1} must extend sealed interface\n@@ -4287,1 +4291,1 @@\n-# lint: synchronization\n+# lint: identity\n@@ -4291,0 +4295,4 @@\n+# lint: identity\n+compiler.warn.attempt.to.use.value.based.where.identity.expected=\\\n+    use of a value-based class with an operation that expects reliable identity\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -298,1 +298,7 @@\n-    Warn about synchronization attempts on instances of value-based classes.\n+    Warn about synchronization attempts on instances of value-based classes.\\n\\\n+\\                         This key is a deprecated alias for ''identity'', which has the same uses and\\n\\\n+\\                         effects. Users are encouraged to use the ''identity'' category for all future\\n\\\n+\\                         and existing uses of ''synchronization''.\n+\n+javac.opt.Xlint.desc.identity=\\\n+    Warn about uses of value-based classes where an identity class is expected.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+ * <tr><th scope=\"row\">{@code identity}             <td>use of a value-based class where an identity class is expected\n@@ -189,1 +190,5 @@\n- * <tr><th scope=\"row\">{@code synchronization}      <td>synchronization attempts on instances of value-based classes\n+ * <tr><th scope=\"row\">{@code synchronization}      <td>synchronization attempts on instances of value-based classes;\n+ *                                                      this key is a deprecated alias for {@code identity}, which has\n+ *                                                      the same uses and effects. Users are encouraged to use the\n+ *                                                      {@code identity} category for all future and existing uses of\n+ *                                                      {@code synchronization}\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-compiler\/runtime\/Test8168712.java 8211769,8211771 generic-ppc64,generic-ppc64le,linux-s390x\n+compiler\/runtime\/Test8168712.java#with-dtrace 8211769,8211771 generic-ppc64,generic-ppc64le,linux-s390x\n+compiler\/runtime\/Test8168712.java#without-dtrace 8211769,8211771 generic-ppc64,generic-ppc64le,linux-s390x\n@@ -91,1 +92,0 @@\n-gc\/TestAllocHumongousFragment.java#iu-aggressive 8298781 generic-all\n@@ -235,0 +235,3 @@\n+vmTestbase\/gc\/gctests\/FinalizeTest04\/FinalizeTest04.java 8284234 generic-all\n+vmTestbase\/gc\/gctests\/PhantomReference\/phantom001\/phantom001.java 8284234 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -445,1 +445,0 @@\n- -runtime\/cds\/appcds\/jigsaw\/modulepath\/AddExports.java \\\n@@ -566,2 +565,0 @@\n- -runtime\/cds\/appcds\/jigsaw\/modulepath\/AddExports.java \\\n- -runtime\/cds\/appcds\/jigsaw\/modulepath\/AddOpens.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-        String logArg = \"-Xlog:cds=debug,cds+reloc=debug,cds+heap\";\n+        String logArg = \"-Xlog:cds=debug,cds+reloc=debug,aot+heap\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ArchiveRelocationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-        final String loggingOption = \"-Xlog:cds=debug,cds+module=debug,cds+heap=info,module=trace\";\n+        final String loggingOption = \"-Xlog:aot=debug,aot+module=debug,aot+heap=info,cds=debug,module=trace\";\n@@ -67,1 +67,1 @@\n-            oa.shouldMatch(\"cds,module.*Restored from archive: entry.0x.*name jdk.httpserver\");\n+            oa.shouldMatch(\"aot,module.*Restored from archive: entry.0x.*name jdk.httpserver\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/module\/ModuleOption.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-#  Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,3 @@\n+# These sub groups of tier3 allow for running certain tests separately from the\n+# rest. When adding tests to tier3, in most cases they should be added to\n+# tier3_part1.\n@@ -87,0 +90,4 @@\n+    :tier3_part1 \\\n+    :tier3_jpackage\n+\n+tier3_part1 = \\\n@@ -94,1 +101,0 @@\n-    :jdk_jpackage \\\n@@ -97,0 +103,4 @@\n+# The jpackage tests on Windows require permissions that aren't always present\n+tier3_jpackage = \\\n+    :jdk_jpackage\n+\n@@ -636,0 +646,1 @@\n+    com\/sun\/net\/httpserver\/simpleserver\/DocRootDirPermissionsWinTest.java \\\n","filename":"test\/jdk\/TEST.groups","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.stream.Stream;\n@@ -178,8 +179,1 @@\n-                boolean found = false;\n-\n-                for (LintCategory lc : LintCategory.values()) {\n-                    if (option.equals(lc.option))\n-                        found = true;\n-                }\n-\n-                if (found)\n+                if (LintCategory.options().contains(option))\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -605,1 +605,1 @@\n-                \"error: can't find main(String[]) method in class: NoMain\");\n+                \"error: can't find main(String[]) or main() method in class: NoMain\");\n@@ -613,1 +613,1 @@\n-                \"error: can't find main(String[]) method in class: BadParams\");\n+                \"error: can't find main(String[]) or main() method in class: BadParams\");\n@@ -621,1 +621,1 @@\n-                \"error: can't find main(String[]) method in class: NotVoid\");\n+                \"error: can't find main(String[]) or main() method in class: NotVoid\");\n@@ -778,0 +778,76 @@\n+    @Test\n+    public void testAbstractClassInstanceMain(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public abstract class AbstractMain {\n+                              void main(String[] args) {}\n+                          }\n+                          \"\"\");\n+        testError(base.resolve(\"AbstractMain.java\"), \"\",\n+                \"error: abstract class: AbstractMain can not be instantiated\");\n+    }\n+\n+    @Test\n+    public void testWrongMainPrivate(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainPrivate {\n+                              private static void main(String[] args) {}\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainPrivate.java\"),\n+                    \"correct\\n\");\n+    }\n+\n+    @Test\n+    public void testWrongMainPrivateInstance(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainPrivate {\n+                              private void main(String[] args) {}\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainPrivate.java\"),\n+                    \"correct\\n\");\n+    }\n+\n+    @Test\n+    public void testWrongMainReturnType(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainReturnType {\n+                              public static int main(String[] args) {\n+                                  return -1;\n+                              }\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainReturnType.java\"),\n+                    \"correct\\n\");\n+    }\n+\n+    @Test\n+    public void testWrongMainReturnTypeInstance(Path base) throws IOException {\n+        tb.writeJavaFiles(base,\n+                          \"\"\"\n+                          public class WrongMainReturnType {\n+                              public int main(String[] args) {\n+                                  return -1;\n+                              }\n+                              void main() {\n+                                  System.out.println(\"correct\");\n+                              }\n+                          }\n+                          \"\"\");\n+        testSuccess(base.resolve(\"WrongMainReturnType.java\"),\n+                    \"correct\\n\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/launcher\/SourceLauncherTest.java","additions":79,"deletions":3,"binary":false,"changes":82,"status":"modified"}]}