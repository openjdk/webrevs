{"files":[{"patch":"@@ -47,1 +47,1 @@\n-\/\/  unused:22 hash:31 -->| unused_gap:4  age:4  self-fwd:1  lock:2 (normal object)\n+\/\/  unused:22 hash:31 -->| valhalla:4  age:4  self-fwd:1  lock:2 (normal object)\n@@ -51,1 +51,1 @@\n-\/\/  klass:22  hash:31 -->| unused_gap:4  age:4  self-fwd:1  lock:2 (normal object)\n+\/\/  klass:22  hash:31 -->| valhalla:4  age:4  self-fwd:1  lock:2 (normal object)\n@@ -75,0 +75,1 @@\n+\/\/  VALHALLA EXTENSIONS:\n@@ -76,0 +77,1 @@\n+\/\/  N.B.: 32 bit mode is not supported, this section assumes 64 bit systems.\n@@ -77,6 +79,1 @@\n-\/\/  Valhalla\n-\/\/\n-\/\/  <CMH: merge this doc into the text above>\n-\/\/\n-\/\/  Project Valhalla has mark word encoding requirements for the following oops:\n-\/\/\n+\/\/  Project Valhalla uses markWord bits to denote the following oops (listed least to most significant):\n@@ -84,3 +81,0 @@\n-\/\/    - \"larval state\": mutable state, but only during object init, observable\n-\/\/      by only by a single thread (generally do not mutate markWord)\n-\/\/\n@@ -88,1 +82,0 @@\n-\/\/\n@@ -90,0 +83,2 @@\n+\/\/  * inline type: \"larval state\": mutable state, but only during object init, observable\n+\/\/      by only by a single thread (generally do not mutate markWord)\n@@ -91,34 +86,1 @@\n-\/\/  EnableValhalla\n-\/\/\n-\/\/  Formerly known as \"biased lock bit\", \"unused_gap\" is free to use: using this\n-\/\/  bit to indicate inline type, combined with \"unlocked\" lock bits, means we\n-\/\/  will not interfere with lock encodings (displaced, inflating, and monitor),\n-\/\/  since inline types can't be locked.\n-\/\/\n-\/\/  Further state encoding\n-\/\/\n-\/\/  32 bit plaforms currently have no further room for encoding. No room for\n-\/\/  \"denormalized layout helper bits\", these fast mark word tests can only be made on\n-\/\/  64 bit platforms. 32-bit platforms need to load the klass->_layout_helper. This\n-\/\/  said, the larval state bit is still required for operation, stealing from the hash\n-\/\/  code is simplest mechanism.\n-\/\/\n-\/\/  Valhalla specific encodings\n-\/\/\n-\/\/  Revised Bit-format of an object header (most significant first, big endian layout below):\n-\/\/\n-\/\/  32 bits:\n-\/\/  --------\n-\/\/  hash:24 ------------>| larval:1 age:4 inline_type:1 lock:2\n-\/\/\n-\/\/  64 bits:\n-\/\/  --------\n-\/\/  unused:1 | <-- hash:31 -->| unused:22 larval:1 age:4 flat_array:1 null_free_array:1 inline_type:1 lock:2\n-\/\/  klass:22  hash:31 -->| larval:1 age:4 flat_array:1 null_free_array:1 inline_type:1 self-fwd:1 lock:2 (normal object)\n-\/\/\n-\/\/  The \"fast\" static type bits (flat_array, null_free_array, and inline_type)\n-\/\/  are placed lowest next to lock bits to more easily decode forwarding pointers.\n-\/\/  G1 for example, implicitly clears age bits (\"G1FullGCCompactionPoint::forward()\")\n-\/\/  using \"oopDesc->forwardee()\", so it necessary for \"markWord::decode_pointer()\"\n-\/\/  to return a non-nullptr for this case, but not confuse the static type bits for\n-\/\/  a pointer.\n+\/\/  Inline types cannot be locked, monitored or inflating.\n@@ -130,15 +92,0 @@\n-\/\/\n-\/\/\n-\/\/  Static types bits are recorded in the \"klass->prototype_header()\", displaced\n-\/\/  mark should simply use the prototype header as \"slow path\", rather chasing\n-\/\/  monitor or stack lock races.\n-\/\/\n-\/\/  Lock patterns (note inline types can't be locked\/monitor\/inflating)...\n-\/\/\n-\/\/  [ptr            | 000]  locked             ptr points to real header on stack\n-\/\/  [header         | ?01]  unlocked           regular object header\n-\/\/  [ptr            | 010]  monitor            inflated lock (header is wapped out)\n-\/\/  [ptr            | ?11]  marked             used to mark an object\n-\/\/  [0 ............ | 000]  inflating          inflation in progress\n-\/\/\n-\/\/\n@@ -186,0 +133,2 @@\n+  \/\/ instance state\n+  static const int age_bits                       = 4;\n@@ -190,2 +139,0 @@\n-  \/\/ instance state\n-  static const int age_bits                       = 4;\n@@ -197,2 +144,3 @@\n-  static const int self_fwd_shift                 = lock_bits ;\n-  static const int inline_type_shift              = self_fwd_shift + self_fwd_bits;\n+  static const int self_fwd_shift                 = lock_shift + lock_bits;\n+  static const int age_shift                      = self_fwd_shift + self_fwd_bits;\n+  static const int inline_type_shift              = age_shift + age_bits;\n@@ -201,2 +149,1 @@\n-  static const int age_shift                      = flat_array_shift + flat_array_bits;\n-  static const int larval_shift                   = age_shift + age_bits;\n+  static const int larval_shift                   = flat_array_shift + flat_array_bits;\n@@ -209,3 +156,2 @@\n-  static const uintptr_t inline_type_bit_in_place = 1 << inline_type_shift;\n-  static const uintptr_t inline_type_mask         = inline_type_bit_in_place + lock_mask;\n-  static const uintptr_t inline_type_mask_in_place = inline_type_mask << lock_shift;\n+  static const uintptr_t inline_type_bit_in_place = right_n_bits(inline_type_bits) << inline_type_shift;\n+  static const uintptr_t inline_type_mask_in_place = inline_type_bit_in_place + lock_mask;\n@@ -214,1 +160,1 @@\n-  static const uintptr_t null_free_array_bit_in_place  = (1 << null_free_array_shift);\n+  static const uintptr_t null_free_array_bit_in_place  = (right_n_bits(null_free_array_bits) << null_free_array_shift);\n@@ -217,1 +163,1 @@\n-  static const uintptr_t flat_array_bit_in_place  = (1 << flat_array_shift);\n+  static const uintptr_t flat_array_bit_in_place  = right_n_bits(flat_array_bits) << flat_array_shift;\n@@ -223,1 +169,1 @@\n-  static const uintptr_t larval_bit_in_place      = (1 << larval_shift);\n+  static const uintptr_t larval_bit_in_place      = right_n_bits(larval_bits) << larval_shift;\n@@ -252,5 +198,0 @@\n-  \/\/ Has static klass prototype, used for decode\/encode pointer\n-  static const uintptr_t static_prototype_mask    = LP64_ONLY(right_n_bits(inline_type_bits + flat_array_bits + null_free_array_bits)) NOT_LP64(right_n_bits(inline_type_bits));\n-  static const uintptr_t static_prototype_mask_in_place = static_prototype_mask << lock_bits;\n-  static const uintptr_t static_prototype_value_max = (1 << age_shift) - 1;\n-\n@@ -463,1 +404,0 @@\n-  \/\/ Recover address of oop from encoded form used in mark\n@@ -465,2 +405,1 @@\n-    return (EnableValhalla && _value < static_prototype_value_max) ? nullptr :\n-      (void*) (clear_lock_bits().value());\n+    return (void*) (clear_lock_bits().value());\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":20,"deletions":81,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -5313,1 +5313,1 @@\n-  \/\/ The \"is locked\" runtime check below also serves as inline type check and goes to the slow path.\n+  \/\/ The \"is locked\" runtime check also subsumes the inline type check (as inline types cannot be locked) and goes to the slow path.\n@@ -5367,2 +5367,3 @@\n-  \/\/ This also serves as guard against inline types\n-    Node *lock_mask      = _gvn.MakeConX(markWord::inline_type_mask_in_place);\n+    \/\/ We cannot use the inline type mask as this may check bits that are overriden\n+    \/\/ by an object monitor's pointer when inflating locking.\n+    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -160,1 +160,0 @@\n-  EXPECT_TRUE(mark.decode_pointer() == nullptr);\n@@ -183,1 +182,0 @@\n-  EXPECT_TRUE(mark.decode_pointer() == nullptr);\n@@ -196,1 +194,0 @@\n-  EXPECT_TRUE(mark.decode_pointer() == nullptr);\n@@ -217,1 +214,0 @@\n-  EXPECT_TRUE(mark.decode_pointer() == nullptr);\n@@ -236,1 +232,0 @@\n-  EXPECT_TRUE(mark.decode_pointer() == nullptr);\n@@ -261,1 +256,0 @@\n-  EXPECT_TRUE(mark.decode_pointer() == nullptr);\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}