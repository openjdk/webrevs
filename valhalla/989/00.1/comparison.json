{"files":[{"patch":"@@ -356,5 +356,0 @@\n-        \/**\n-         * Used for instances of {@link WithFieldTree}.\n-         *\/\n-        WITH_FIELD(WithFieldTree.class),\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -558,8 +558,0 @@\n-\n-    \/**\n-     * Visits a {@code WithFieldTree} node.\n-     * @param node the node being visited\n-     * @param p a parameter value\n-     * @return a result value\n-     *\/\n-    R visitWithField(WithFieldTree node, P p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -239,14 +239,0 @@\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation calls {@code defaultAction}.\n-     *\n-     * @param node {@inheritDoc}\n-     * @param p {@inheritDoc}\n-     * @return  the result of {@code defaultAction}\n-     *\/\n-    @Override\n-    public R visitWithField(WithFieldTree node, P p) {\n-        return defaultAction(node, p);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-        PRIMITIVE_CLASSES(JDK21, Fragments.FeaturePrimitiveClasses, DiagKind.PLURAL),\n@@ -308,3 +307,0 @@\n-            if (this == PRIMITIVE_CLASSES) {\n-                return Errors.PrimitiveClassesNotSupported(minLevel.name);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import com.sun.tools.javac.code.Type.ClassType.Flavor;\n@@ -66,0 +65,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -68,0 +68,1 @@\n+import com.sun.tools.javac.tree.JCTree;\n@@ -79,0 +80,1 @@\n+import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;\n@@ -114,4 +116,0 @@\n-    \/** Switch: allow primitive classes.\n-     *\/\n-    boolean allowPrimitiveClasses;\n-\n@@ -142,0 +140,4 @@\n+    \/** Switch: emit Q descriptors\n+     *\/\n+    private boolean emitQDesc;\n+\n@@ -296,1 +298,0 @@\n-        allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && options.isSet(\"enablePrimitiveClasses\");\n@@ -310,0 +311,2 @@\n+        emitQDesc = options.isSet(\"emitQDesc\") || options.isSet(\"enablePrimitiveClasses\");\n+\n@@ -520,1 +523,1 @@\n-                if ((char) signature[sigp] == 'Q' && !allowPrimitiveClasses) {\n+                if ((char) signature[sigp] == 'Q' && !emitQDesc) {\n@@ -582,1 +585,1 @@\n-        if (prefix != 'L' && (!allowPrimitiveClasses || prefix != 'Q'))\n+        if (prefix != 'L' && (!emitQDesc || prefix != 'Q'))\n@@ -587,1 +590,0 @@\n-        ClassType.Flavor flavor;\n@@ -600,1 +602,0 @@\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n@@ -604,2 +605,1 @@\n-                        \/\/ Todo: This spews out more objects than before, i.e no reuse with identical flavor\n-                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata(), flavor);\n+                        return new ClassType(et.getEnclosingType(), List.nil(), et.tsym, et.getMetadata());\n@@ -607,1 +607,1 @@\n-                    return new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    return new ClassType(outer, List.nil(), t, List.nil());\n@@ -618,2 +618,1 @@\n-                flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                outer = new ClassType(outer, sigToTypes('>'), t, List.nil(), flavor) {\n+                outer = new ClassType(outer, sigToTypes('>'), t, List.nil()) {\n@@ -683,2 +682,1 @@\n-                    flavor = prefix == 'L' ? Flavor.L_TypeOf_X : Flavor.Q_TypeOf_X;\n-                    outer = new ClassType(outer, List.nil(), t, List.nil(), flavor);\n+                    outer = new ClassType(outer, List.nil(), t, List.nil());\n@@ -876,1 +874,1 @@\n-                    if (sym.isInitOrVNew() && sym.type.getParameterTypes().size() == 0) {\n+                    if (sym.isInit() && sym.type.getParameterTypes().size() == 0) {\n@@ -1068,8 +1066,0 @@\n-                        \/\/ Map value class factory methods back to constructors for the benefit of earlier pipeline stages\n-                        if (sym.kind == MTH && sym.name == names.vnew && !sym.type.getReturnType().hasTag(TypeTag.VOID)) {\n-                            sym.type = new MethodType(sym.type.getParameterTypes(),\n-                                    syms.voidType,\n-                                    sym.type.getThrownTypes(),\n-                                    syms.methodClass);\n-                        }\n-\n@@ -1353,0 +1343,33 @@\n+            new AttributeReader(names.ImplicitCreation, V66, CLASS_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (((ClassSymbol)sym).hasImplicitConstructor()) { \/\/ there can only be one per class\n+                        throw badClassFile(\"attribute.must.be.unique\", names.ImplicitCreation);\n+                    }\n+                    if (sym.kind == TYP) {\n+                        nextChar();\n+                        ((ClassSymbol)sym).implicitConstructorFound();\n+                    }\n+                }\n+            },\n+            new AttributeReader(names.NullRestricted, V66, MEMBER_ATTRIBUTE) {\n+                @Override\n+                protected boolean accepts(AttributeKind kind) {\n+                    return super.accepts(kind) && allowValueClasses;\n+                }\n+                protected void read(Symbol sym, int attrLen) {\n+                    if (sym.kind != VAR) {\n+                        throw badClassFile(\"attribute.only.applicable.to.fields\", names.NullRestricted);\n+                    }\n+                    if (sym.type.isPrimitive() || sym.type.hasTag(TypeTag.ARRAY)) {\n+                        throw badClassFile(\"attribute.not.applicable.to.field.type\", names.NullRestricted, sym.type);\n+                    }\n+                    if (sym.type.isNonNullable()) {\n+                        throw badClassFile(\"attribute.must.be.unique\", names.NullRestricted);\n+                    }\n+                    sym.type = sym.type.asNullMarked(JCTree.JCNullableTypeExpression.NullMarker.NOT_NULL);\n+                }\n+            },\n@@ -1428,1 +1451,1 @@\n-        if (!names.isInitOrVNew(nt.name))\n+        if (!names.isInit(nt.name))\n@@ -2661,1 +2684,1 @@\n-        if (names.isInitOrVNew(name) && ((flags & STATIC) != 0)) {\n+        if (names.isInit(name) && ((flags & STATIC) != 0)) {\n@@ -2667,0 +2690,4 @@\n+            if (((ClassSymbol)currentOwner).hasImplicitConstructor() && type.getParameterTypes().size() == 0) {\n+                \/\/ this has to be the implicit constructor\n+                flags |= IMPLICIT;\n+            }\n@@ -2669,1 +2696,1 @@\n-        if (names.isInitOrVNew(name) && currentOwner.hasOuterInstance()) {\n+        if (names.isInit(name) && currentOwner.hasOuterInstance()) {\n@@ -2714,1 +2741,1 @@\n-            ((name == names.init || name == names.vnew) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n+            ((name == names.init) && !t.getReturnType().hasTag(TypeTag.VOID))) {\n@@ -2778,1 +2805,1 @@\n-        if (names.isInitOrVNew(sym.name) && currentOwner.hasOuterInstance()) {\n+        if (names.isInit(sym.name) && currentOwner.hasOuterInstance()) {\n@@ -2946,1 +2973,1 @@\n-            if (!allowPrimitiveClasses || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n+            if (!emitQDesc || (flags & (FINAL | PRIMITIVE_CLASS | IDENTITY_TYPE)) != (FINAL | PRIMITIVE_CLASS)) {\n@@ -3009,1 +3036,3 @@\n-        for (int i = 0; i < fieldCount; i++) enterMember(c, readField());\n+        for (int i = 0; i < fieldCount; i++) {\n+            enterMember(c, readField());\n+        }\n@@ -3178,0 +3207,2 @@\n+        \/\/ we need to do some checks now that the class has been loaded\n+        checkNonCyclicMembership(c);\n@@ -3214,6 +3245,0 @@\n-        if ((flags & ACC_PRIMITIVE) != 0) {\n-            flags &= ~ACC_PRIMITIVE;\n-            if (allowPrimitiveClasses) {\n-                flags |= PRIMITIVE_CLASS;\n-            }\n-        }\n@@ -3460,0 +3485,51 @@\n+\n+    \/\/ A value class cannot contain a non-nullable instance field of its own type either directly or indirectly.\n+    void checkNonCyclicMembership(ClassSymbol csym) {\n+        if (!allowValueClasses || !csym.type.hasImplicitConstructor()) {\n+            \/\/ nothing to see here\n+            return;\n+        }\n+        Assert.check((csym.flags_field & LOCKED) == 0);\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol field : csym.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(field);\n+            }\n+            csym.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            csym.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private void checkNonCyclicMembershipHelper(ClassSymbol c) {\n+        if ((c.flags_field & LOCKED) != 0) {\n+            JavaFileObject prevSource = log.useSource(currentClassFile);\n+            try {\n+                log.error(CompilerProperties.Errors.CyclicPrimitiveClassMembership(c));\n+                return;\n+            } finally {\n+                log.useSource(prevSource);\n+            }\n+        }\n+        try {\n+            ListBuffer<Symbol> fields = new ListBuffer<>();\n+            \/\/ invoking c::members can provoke symbol completion and thus the LOCKED flag can be set before expected\n+            for (Symbol fld : c.members().getSymbols(s -> s.kind == VAR && cyclePossible((VarSymbol) s), NON_RECURSIVE)) {\n+                fields.add(fld);\n+            }\n+            c.flags_field |= LOCKED;\n+            for (Symbol field : fields) {\n+                checkNonCyclicMembershipHelper((ClassSymbol) field.type.tsym);\n+            }\n+        } finally {\n+            c.flags_field &= ~LOCKED;\n+        }\n+    }\n+    \/\/ where\n+    private boolean cyclePossible(VarSymbol symbol) {\n+        return (symbol.flags() & STATIC) == 0 && symbol.type.isValueClass() && symbol.type.hasImplicitConstructor() && symbol.type.isNonNullable();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":115,"deletions":39,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -187,1 +187,0 @@\n-    private boolean allowPrimitiveClasses;\n@@ -201,2 +200,1 @@\n-                PoolWriter poolWriter,\n-                boolean allowPrimitiveClasses) {\n+                PoolWriter poolWriter) {\n@@ -224,1 +222,0 @@\n-        this.allowPrimitiveClasses = allowPrimitiveClasses;\n@@ -470,1 +467,1 @@\n-        if (member.isInitOrVNew())\n+        if (member.isInit())\n@@ -1032,5 +1029,0 @@\n-        case aconst_init: {\n-            Type t = (Type)data;\n-            state.push(t.tsym.erasure(types));\n-            break;\n-        }\n@@ -1063,3 +1055,0 @@\n-        case withfield:\n-            state.pop(((Symbol)data).erasure(types));\n-            break;\n@@ -1390,1 +1379,1 @@\n-            if (meth.isInitOrVNew() && thisType != syms.objectType) {\n+            if (meth.isInit() && thisType != syms.objectType) {\n@@ -1788,6 +1777,2 @@\n-                if (!allowPrimitiveClasses) {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)));\n-                } else {\n-                    Assert.check(types.isSubtype(types.erasure(old), types.erasure(t)) ||\n-                            (old.isPrimitiveClass() != t.isPrimitiveClass() && types.isConvertible(types.erasure(old), types.erasure(t))));\n-                }\n+                Assert.check(types.isSubtype(types.erasure(old),\n+                                       types.erasure(t)));\n@@ -2469,2 +2454,0 @@\n-            mnem[aconst_init] = \"aconst_init\";\n-            mnem[withfield] = \"withfield\";\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;\n@@ -49,0 +50,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNullableTypeExpression.NullMarker;\n@@ -197,1 +199,1 @@\n-        this.allowPrimitiveClasses = Feature.PRIMITIVE_CLASSES.allowedInSource(source) && fac.options.isSet(\"enablePrimitiveClasses\");\n+        this.allowNullRestrictedTypes = fac.options.isSet(\"enableNullRestrictedTypes\");\n@@ -222,1 +224,1 @@\n-        this.allowPrimitiveClasses = parser.allowPrimitiveClasses;\n+        this.allowNullRestrictedTypes = parser.allowNullRestrictedTypes;\n@@ -261,4 +263,0 @@\n-    \/** Switch: are primitive classes allowed in this source level?\n-     *\/\n-     boolean allowPrimitiveClasses;\n-\n@@ -273,0 +271,4 @@\n+    \/** Switch: are null-restricted types allowed?\n+     *\/\n+    boolean allowNullRestrictedTypes;\n+\n@@ -283,0 +285,1 @@\n+     *     mode |= NOQUES     : nullable types are not allowed\n@@ -290,0 +293,1 @@\n+    protected static final int NOQUES        = 1 << 6;\n@@ -308,1 +312,1 @@\n-        setMode((mode & NOLAMBDA) | EXPR);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | EXPR);\n@@ -312,1 +316,1 @@\n-        setMode((mode & NOLAMBDA) | TYPE);\n+        setMode((mode & (NOLAMBDA | NOQUES)) | TYPE);\n@@ -723,0 +727,4 @@\n+        if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+            setNullMarker(t);\n+            nextToken();\n+        }\n@@ -1160,1 +1168,12 @@\n-                    JCExpression type = unannotatedType(false);\n+                    JCExpression type = unannotatedType(false, NOQUES | TYPE);\n+                    if (allowNullRestrictedTypes && token.kind == QUES && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                        if (peekToken(IDENTIFIER, COMMA) || peekToken(IDENTIFIER, SEMI) ||\n+                                peekToken(IDENTIFIER, RPAREN) || peekToken(IDENTIFIER, INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        } else if (peekToken(COMMA) || peekToken(SEMI) ||\n+                                peekToken(RPAREN) || peekToken(QUES) || peekToken(INSTANCEOF_INFIX)) {\n+                            setNullMarker(type);\n+                            accept(QUES);\n+                        }\n+                    }\n@@ -1341,0 +1360,1 @@\n+        boolean emotionalMarkersOK = false;\n@@ -1490,0 +1510,6 @@\n+                if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (peekToken(LBRACKET) || peekToken(LT))) {\n+                    emotionalMarkersOK = true;\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                }\n@@ -1509,0 +1535,4 @@\n+                            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                                setNullMarker(t);\n+                                nextToken();\n+                            }\n@@ -1649,0 +1679,10 @@\n+            if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && (token.kind == QUES || token.kind == BANG || (token.kind == STAR))) {\n+                if (peekToken(LBRACKET) || peekToken(LT) || emotionalMarkersOK) {\n+                    selectTypeMode();\n+                    setNullMarker(t);\n+                    nextToken();\n+                } else {\n+                    \/\/ not a type\n+                    break;\n+                }\n+            }\n@@ -1765,1 +1805,6 @@\n-            if (token.kind == LBRACKET) {\n+            if (allowNullRestrictedTypes && isMode(TYPE) && typeArgs == null && EMOTIONAL_QUALIFIER.test(token.kind) &&\n+                    (t instanceof JCIdent || t instanceof JCFieldAccess || t instanceof JCArrayTypeTree)) {\n+                setNullMarker(t);\n+                selectTypeMode();\n+                nextToken();\n+            } else if (token.kind == LBRACKET) {\n@@ -1774,0 +1819,4 @@\n+                        if (allowNullRestrictedTypes && isMode(TYPE) && EMOTIONAL_QUALIFIER.test(token.kind)) {\n+                            setNullMarker(t);\n+                            nextToken();\n+                        }\n@@ -1858,0 +1907,13 @@\n+    void setNullMarker(JCExpression exp) {\n+        setNullMarker(exp, token);\n+    }\n+\n+    void setNullMarker(JCExpression exp, Token tk) {\n+        ((JCNullableTypeExpression)exp).setNullMarker(\n+                tk.kind == QUES ?\n+                        NullMarker.NULLABLE :\n+                        token.kind == BANG ?\n+                                NullMarker.NOT_NULL :\n+                                NullMarker.PARAMETRIC);\n+    }\n+\n@@ -1923,1 +1985,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n+    @SuppressWarnings({\"fallthrough\", \"unchecked\"})\n@@ -1991,0 +2053,15 @@\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, RPAREN, ARROW))) {\n+                        \/\/ Identifier, '!'\/'?', Identifier\/'_'\/'assert'\/'enum', ','\/')' -> explicit lambda\n+                        return ParensResult.EXPLICIT_LAMBDA;\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) {\n+                        \/\/ this must be a cast with emotional type\n+                        return ParensResult.CAST;\n+                    } else if (allowNullRestrictedTypes && (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LBRACKET)) ) {\n+                        \/\/ Identifier, '!'\/'?', '<'\/','\/'>' or\n+                        \/\/ Identifier, '!'\/'?', '[' -> it's a type, skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -2013,0 +2090,1 @@\n+                            (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2015,0 +2093,1 @@\n+                        \/\/ '[', ']', '!', ')' -> cast\n@@ -2017,0 +2096,6 @@\n+                    } else if (allowNullRestrictedTypes && peekToken(lookahead, RBRACKET, EMOTIONAL_QUALIFIER)) {\n+                        \/\/consume the ']' and the '!' and skip\n+                        type = true;\n+                        lookahead++;\n+                        lookahead++;\n+                        break;\n@@ -2035,0 +2120,1 @@\n+                                (allowNullRestrictedTypes && peekToken(lookahead, EMOTIONAL_QUALIFIER, RPAREN)) ||\n@@ -2094,0 +2180,4 @@\n+    protected Predicate<TokenKind> EMOTIONAL_QUALIFIER = t -> t == BANG;\n+    protected Predicate<TokenKind> GENERIC_TYPE_END = t -> t == GT || t == GTGT || t == GTGTGT;\n+    protected Predicate<TokenKind> INSTANCEOF_INFIX = t -> t == AMPAMP || t == BARBAR ||\n+                                                           t == EQEQ || t == BANGEQ;\n@@ -2433,0 +2523,6 @@\n+        } else if (allowNullRestrictedTypes && EMOTIONAL_QUALIFIER.test(token.kind) && peekToken(LBRACKET)) {\n+            Token nullMarker = token;\n+            nextToken();\n+            int pos = token.pos;\n+            nextToken();\n+            t = bracketsOptCont(t, pos, nextLevelAnnotations, nullMarker);\n@@ -2455,0 +2551,5 @@\n+        return bracketsOptCont(t, pos, annotations, null);\n+    }\n+\n+    private JCExpression bracketsOptCont(JCExpression t, int pos,\n+                                         List<JCAnnotation> annotations, Token nullMarker) {\n@@ -2458,0 +2559,3 @@\n+        if (nullMarker != null) {\n+            setNullMarker(t, nullMarker);\n+        }\n@@ -2615,1 +2719,1 @@\n-            long badModifiers = mods.flags & ~(Flags.PRIMITIVE_CLASS | Flags.VALUE_CLASS | Flags.FINAL);\n+            long badModifiers = mods.flags & ~(Flags.VALUE_CLASS | Flags.FINAL);\n@@ -2972,1 +3076,1 @@\n-        if ((isPrimitiveModifier() && allowPrimitiveClasses) || (isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n+        if ((isValueModifier() || isIdentityModifier()) && allowValueClasses) {\n@@ -3381,0 +3485,13 @@\n+                    } \/*else if (typeDepth == 0 && allowNullRestrictedTypes &&\n+                            ((peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COMMA) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, ARROW) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LAX_IDENTIFIER, COLON))) ) {\n+                        \/\/ this is a type test pattern\n+                        return PatternResult.PATTERN;\n+                    } *\/else if ( allowNullRestrictedTypes &&\n+                            (peekToken(lookahead, EMOTIONAL_QUALIFIER, GENERIC_TYPE_END) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, LT) ||\n+                            peekToken(lookahead, EMOTIONAL_QUALIFIER, COMMA)) ) {\n+                        \/\/ this is a type - skip the emotional anno and continue\n+                        lookahead++;\n+                        break;\n@@ -3395,0 +3512,2 @@\n+                case BANG:\n+                    if (allowNullRestrictedTypes && !peekToken(lookahead, LPAREN)) break;\n@@ -3569,4 +3688,0 @@\n-                if (isPrimitiveModifier()) {\n-                    flag = Flags.PRIMITIVE_CLASS;\n-                    break;\n-                }\n@@ -3581,0 +3696,4 @@\n+                if (allowNullRestrictedTypes && isImplicitModifier()) {\n+                    flag = Flags.IMPLICIT;\n+                    break;\n+                }\n@@ -3847,5 +3966,0 @@\n-        if (name == names.primitive) {\n-            if (allowPrimitiveClasses) {\n-                return Source.JDK18;\n-            }\n-        }\n@@ -3860,1 +3974,6 @@\n-            if (allowPrimitiveClasses) {\n+            if (shouldWarn) {\n+                log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK18));\n+            }\n+        }\n+        if (name == names.implicit) {\n+            if (allowNullRestrictedTypes && allowValueClasses) {\n@@ -4393,1 +4512,1 @@\n-                if (names.isInitOrVNew(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n+                if (names.isInit(methDef.name) && methDef.params.isEmpty() && (methDef.mods.flags & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {\n@@ -4934,26 +5053,0 @@\n-    protected boolean isPrimitiveModifier() {\n-        if (token.kind == IDENTIFIER && token.name() == names.primitive) {\n-            boolean isPrimitiveModifier = false;\n-            Token next = S.token(1);\n-            switch (next.kind) {\n-                case PRIVATE: case PROTECTED: case PUBLIC: case STATIC: case TRANSIENT:\n-                case FINAL: case ABSTRACT: case NATIVE: case VOLATILE: case SYNCHRONIZED:\n-                case STRICTFP: case MONKEYS_AT: case DEFAULT: case BYTE: case SHORT:\n-                case CHAR: case INT: case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:\n-                case CLASS: case INTERFACE: case ENUM:\n-                    isPrimitiveModifier = true;\n-                    break;\n-                case IDENTIFIER: \/\/ primitive record R || primitive primitive || primitive identity || primitive value || new primitive Comparable() {}\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n-                            || next.name() == names.value || (mode & EXPR) != 0)\n-                        isPrimitiveModifier = true;\n-                    break;\n-            }\n-            if (isPrimitiveModifier) {\n-                checkSourceLevel(Feature.PRIMITIVE_CLASSES);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n@@ -4972,1 +5065,1 @@\n-                case IDENTIFIER: \/\/ value record R || value value || value identity || value primitive || new value Comparable() {} ??\n+                case IDENTIFIER: \/\/ value record R || value value || value identity || new value Comparable() {} ??\n@@ -4974,1 +5067,1 @@\n-                            || next.name() == names.primitive || (mode & EXPR) != 0)\n+                            || (mode & EXPR) != 0)\n@@ -4999,1 +5092,1 @@\n-                    if (next.name() == names.record || next.name() == names.primitive || next.name() == names.identity\n+                    if (next.name() == names.record || next.name() == names.identity\n@@ -5012,0 +5105,19 @@\n+    protected boolean isImplicitModifier() {\n+        if (token.kind == IDENTIFIER && token.name() == names.implicit) {\n+            boolean isImplicitModifier = false;\n+            Token next = S.token(1);\n+            switch (next.kind) {\n+                case PRIVATE: case PROTECTED: case PUBLIC: case MONKEYS_AT:\n+                case STATIC: case FINAL: case ABSTRACT: case NATIVE:\n+                case SYNCHRONIZED: case STRICTFP: case DEFAULT: case IDENTIFIER:\n+                    isImplicitModifier = true;\n+                    break;\n+            }\n+            if (isImplicitModifier) {\n+                checkSourceLevel(Feature.VALUE_CLASSES);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -5073,1 +5185,1 @@\n-            if (!isRecord || !names.isInitOrVNew(name) || token.kind == LPAREN) {\n+            if (!isRecord || !names.isInit(name) || token.kind == LPAREN) {\n@@ -5529,4 +5641,1 @@\n-        if (feature == Feature.PRIMITIVE_CLASSES && !allowPrimitiveClasses) {\n-            \/\/ primitive classes are special\n-            log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));\n-        } else if (preview.isPreview(feature) && !preview.isEnabled()) {\n+        if (preview.isPreview(feature) && !preview.isEnabled()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":167,"deletions":58,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -3209,0 +3209,3 @@\n+compiler.misc.feature.bang.types=\\\n+    bang types\n+\n@@ -4060,6 +4063,1 @@\n-    cyclic primitive class membership involving {0}\n-\n-# 0: string (expected version)\n-compiler.err.primitive.classes.not.supported=\\\n-    primitive classes are not supported\\n\\\n-     (use -source {0} or higher to enable primitive classes and pass compiler option: -XDenablePrimitiveClasses)\n+    cyclic value class membership involving {0}\n@@ -4126,0 +4124,14 @@\n+# 0: symbol\n+compiler.err.value.class.with.implicit.cannot.be.inner=\\\n+    The value class {0} declares an implicit constructor. It cannot be an inner class.\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.declares.init.block=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    It cannot declare one or more non-empty instance initializer blocks\n+\n+# 0: symbol\n+compiler.err.value.class.with.implicit.instance.field.initializer=\\\n+    The value class {0} declares an implicit constructor.\\n\\\n+    And it defines an instance field with an initializer. This is disallowed.\n+\n@@ -4134,3 +4146,0 @@\n-compiler.err.projection.cant.be.instantiated=\\\n-    Illegal attempt to instantiate a projection type\n-\n@@ -4140,0 +4149,14 @@\n+compiler.err.implicit.const.cant.have.body=\\\n+    implicit constructors cannot have a body\n+\n+compiler.err.implicit.const.must.be.public=\\\n+    implicit constructors must be public\n+\n+compiler.err.implicit.const.must.be.declared.in.value.class=\\\n+    only value classes can declare implicit constructors\n+\n+# 0: symbol\n+compiler.err.cant.implement.interface=\\\n+    class {0} cannot implement LooselyConsistentValue interface. Concrete classes implementing this interface must:\\n\\\n+     be value classes and declare an implicit constructor.\n+\n@@ -4164,0 +4187,51 @@\n+\n+### null-restricted types\n+\n+compiler.err.non.nullable.cannot.be.assigned.null=\\\n+    non-nullable type cannot be assigned null\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    it must be a value class with an implicit constructor\n+\n+# 0: type\n+compiler.err.type.cant.be.null.restricted.2=\\\n+    type: {0}, cannot be a null restricted type\\n\\\n+    its element type must be a value class with an implicit constructor\n+\n+# 0: name\n+compiler.misc.attribute.must.be.unique=\\\n+    attribute {0} must be unique\n+\n+# 0: name\n+compiler.misc.attribute.only.applicable.to.fields=\\\n+    attribute {0} is only applicable to fields\n+\n+# 0: name, 1: type\n+compiler.misc.attribute.not.applicable.to.field.type=\\\n+    attribute {0} is not applicable to {1}\n+\n+compiler.warn.narrowing.nullness.conversion=\\\n+    narrowing nullness conversion\n+\n+compiler.warn.unchecked.nullness.conversion=\\\n+    unchecked nullness conversion\n+\n+compiler.warn.non.nullable.should.be.initialized=\\\n+    field of non-nullable type should be initialized\n+\n+compiler.warn.parametric.should.be.initialized=\\\n+    field of parametric type should be initialized\n+\n+compiler.warn.accessing.member.of.nullable=\\\n+    accessing member of nullable type\n+\n+compiler.warn.accessing.member.of.parametric=\\\n+    accessing member of parametric type\n+\n+compiler.warn.overrides.with.different.nullness.1=\\\n+    overriding method''s return type does not match nullness of overridden method\n+\n+compiler.warn.overrides.with.different.nullness.2=\\\n+    overriding method''s parameter(s) type(s) do not match nullness of overridden method\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":83,"deletions":9,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -158,5 +158,0 @@\n-    public void visitWithField(JCWithField tree) {\n-        scan(tree.field);\n-        scan(tree.value);\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}