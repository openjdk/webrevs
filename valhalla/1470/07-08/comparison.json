{"files":[{"patch":"@@ -1875,2 +1875,16 @@\n-Node* GraphKit::flat_array_element_address(Node*& array, Node* idx, ciInlineKlass* vk, bool is_null_free,\n-                                           bool is_not_null_free, bool is_atomic) {\n+Node* GraphKit::cast_to_flat_array(Node* array, ciInlineKlass* vk, bool is_null_free, bool is_not_null_free, bool is_atomic) {\n+  assert(vk->maybe_flat_in_array(), \"element of type %s cannot be flat in array\", vk->name()->as_utf8());\n+  if (!vk->has_nullable_atomic_layout()) {\n+    \/\/ Element does not have a nullable flat layout, cannot be nullable\n+    is_null_free = true;\n+  }\n+  if (!vk->has_atomic_layout() && !vk->has_non_atomic_layout()) {\n+    \/\/ Element does not have a null-free flat layout, cannot be null-free\n+    is_not_null_free = true;\n+  }\n+  if (is_null_free) {\n+    \/\/ TODO 8350865 Impossible type\n+    is_not_null_free = false;\n+  }\n+\n+  bool is_exact = is_null_free || is_not_null_free;\n@@ -1879,1 +1893,1 @@\n-  arytype = arytype->cast_to_exactness(true);\n+  arytype = arytype->cast_to_exactness(is_exact);\n@@ -1881,2 +1895,1 @@\n-  array = _gvn.transform(new CheckCastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n-  return array_element_address(array, idx, T_FLAT_ELEMENT, arytype->size(), control());\n+  return _gvn.transform(new CastPPNode(control(), array, arytype, ConstraintCastNode::StrongDependency));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -663,2 +663,1 @@\n-  Node* flat_array_element_address(Node*& array, Node* idx, ciInlineKlass* vk, bool is_null_free,\n-                                   bool is_not_null_free, bool is_atomic);\n+  Node* cast_to_flat_array(Node* array, ciInlineKlass* elem_vk, bool is_null_free, bool is_not_null_free, bool is_atomic);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-  assert(vk->maybe_flat_in_array(), \"\");\n+  assert(vk->maybe_flat_in_array(), \"element type %s cannot be flat in array\", vk->name()->as_utf8());\n@@ -718,11 +718,1 @@\n-  RegionNode* region;\n-  if (vk->nof_nonstatic_fields() == 0) {\n-    region = new RegionNode(3);\n-    region->init_req(1, kit->top());\n-    region->init_req(2, kit->top());\n-  } else {\n-    region = new RegionNode(4);\n-    region->init_req(1, kit->top());\n-    region->init_req(2, kit->top());\n-    region->init_req(3, kit->top());\n-  }\n+  RegionNode* region = new RegionNode(4);\n@@ -749,1 +739,1 @@\n-    assert(vk->has_nullable_atomic_layout(), \"\");\n+    assert(vk->has_nullable_atomic_layout(), \"element type %s does not have a nullable flat layout\", vk->name()->as_utf8());\n@@ -751,2 +741,2 @@\n-    Node* cast = base;\n-    Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ false, \/* not_null_free *\/ true, \/* atomic *\/ true);\n+    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n@@ -763,1 +753,1 @@\n-    region->set_req(1, kit->control());\n+    region->init_req(1, kit->control());\n@@ -768,0 +758,1 @@\n+  \/\/ Null-free\n@@ -775,1 +766,1 @@\n-      region->set_req(2, kit->control());\n+      region->init_req(2, kit->control());\n@@ -782,0 +773,1 @@\n+      \/\/ Atomic\n@@ -784,1 +776,1 @@\n-        assert(vk->has_atomic_layout(), \"\");\n+        assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n@@ -786,2 +778,2 @@\n-        Node* cast = base;\n-        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n+        Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n@@ -799,1 +791,1 @@\n-        region->set_req(2, kit->control());\n+        region->init_req(2, kit->control());\n@@ -804,0 +796,1 @@\n+      \/\/ Non-atomic\n@@ -806,1 +799,1 @@\n-        assert(vk->has_non_atomic_layout(), \"\");\n+        assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n@@ -808,2 +801,2 @@\n-        Node* cast = base;\n-        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n+        Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n@@ -821,1 +814,1 @@\n-        region->set_req(3, kit->control());\n+        region->init_req(3, kit->control());\n@@ -1285,1 +1278,1 @@\n-  assert(vk->maybe_flat_in_array(), \"\");\n+  assert(vk->maybe_flat_in_array(), \"element type %s cannot be flat in array\", vk->name()->as_utf8());\n@@ -1293,11 +1286,1 @@\n-  RegionNode* region;\n-  if (vk->nof_nonstatic_fields() == 0) {\n-    region = new RegionNode(3);\n-    region->init_req(1, kit->top());\n-    region->init_req(2, kit->top());\n-  } else {\n-    region = new RegionNode(4);\n-    region->init_req(1, kit->top());\n-    region->init_req(2, kit->top());\n-    region->init_req(3, kit->top());\n-  }\n+  RegionNode* region = new RegionNode(4);\n@@ -1324,1 +1307,1 @@\n-    assert(vk->has_nullable_atomic_layout(), \"\");\n+    assert(vk->has_nullable_atomic_layout(), \"element type %s does not have a nullable flat layout\", vk->name()->as_utf8());\n@@ -1326,2 +1309,2 @@\n-    Node* cast = base;\n-    Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ false, \/* not_null_free *\/ true, \/* atomic *\/ true);\n+    Node* cast = kit->cast_to_flat_array(base, vk, false, true, true);\n+    Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n@@ -1338,1 +1321,1 @@\n-    region->set_req(1, kit->control());\n+    region->init_req(1, kit->control());\n@@ -1352,1 +1335,1 @@\n-      region->set_req(2, kit->control());\n+      region->init_req(2, kit->control());\n@@ -1362,1 +1345,1 @@\n-        assert(vk->has_atomic_layout(), \"\");\n+        assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n@@ -1364,2 +1347,2 @@\n-        Node* cast = base;\n-        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n+        Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n@@ -1377,1 +1360,1 @@\n-        region->set_req(2, kit->control());\n+        region->init_req(2, kit->control());\n@@ -1385,3 +1368,1 @@\n-        assert(vk->has_non_atomic_layout(), \"\");\n-        \/\/ TODO 8350865 Is the conversion to\/from payload folded? We should wire this directly.\n-        \/\/ Also remove the PreserveReexecuteState in Parse::array_load when buffering is no longer possible.\n+        assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n@@ -1389,2 +1370,2 @@\n-        Node* cast = base;\n-        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n+        Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n@@ -1402,1 +1383,1 @@\n-        region->set_req(3, kit->control());\n+        region->init_req(3, kit->control());\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":33,"deletions":52,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -119,20 +119,2 @@\n-          bool is_null_free = array_type->is_null_free() || !vk->has_nullable_atomic_layout();\n-          bool is_not_null_free = array_type->is_not_null_free() || (!vk->has_atomic_layout() && !vk->has_non_atomic_layout());\n-          if (is_null_free) {\n-            \/\/ TODO 8350865 Impossible type\n-            is_not_null_free = false;\n-          }\n-          bool maybe_atomic = (!is_not_null_free && vk->has_atomic_layout()) || (!is_null_free && vk->has_nullable_atomic_layout());\n-\n-          ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* flat *\/ true, is_null_free, maybe_atomic);\n-          const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n-          arytype = arytype->cast_to_exactness(true);\n-          arytype = arytype->cast_to_not_null_free(is_not_null_free);\n-          Node* flat_array = gvn().transform(new CastPPNode(control(), array, arytype));\n-\n-          \/\/ Re-execute flat array load if buffering triggers deoptimization\n-          PreserveReexecuteState preexecs(this);\n-          jvms()->set_should_reexecute(true);\n-          inc_sp(3);\n-\n-          Node* vt = InlineTypeNode::make_from_flat_array(this, element_ptr->inline_klass(), flat_array, array_index);\n+          Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n+          Node* vt = InlineTypeNode::make_from_flat_array(this, vk, flat_array, array_index);\n@@ -288,13 +270,1 @@\n-            bool is_null_free = array_type->is_null_free() || !vk->has_nullable_atomic_layout();\n-            bool is_not_null_free = array_type->is_not_null_free() || (!vk->has_atomic_layout() && !vk->has_non_atomic_layout());\n-            if (is_null_free) {\n-              \/\/ TODO 8350865 Impossible type\n-              is_not_null_free = false;\n-            }\n-            bool maybe_atomic = (!is_not_null_free && vk->has_atomic_layout()) || (!is_null_free && vk->has_nullable_atomic_layout());\n-\n-            ciArrayKlass* array_klass = ciArrayKlass::make(vk, \/* flat *\/ true, is_null_free, maybe_atomic);\n-            const TypeAryPtr* arytype = TypeOopPtr::make_from_klass(array_klass)->isa_aryptr();\n-            arytype = arytype->cast_to_exactness(true);\n-            arytype = arytype->cast_to_not_null_free(is_not_null_free);\n-            Node* flat_array = gvn().transform(new CastPPNode(control(), array, arytype));\n+            Node* flat_array = cast_to_flat_array(array, vk, false, false, false);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"}]}