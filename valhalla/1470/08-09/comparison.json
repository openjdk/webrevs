{"files":[{"patch":"@@ -811,1 +811,1 @@\n-          vt->store_flat(&kit, buffer_oop, payload_ptr, kit.gvn().type(payload_ptr)->is_ptr(), false, true, true, IN_HEAP | MO_UNORDERED);\n+          vt->store_flat(&kit, buffer_oop, payload_ptr, false, true, true, IN_HEAP | MO_UNORDERED);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"opto\/idealKit.hpp\"\n@@ -412,8 +411,0 @@\n-const TypePtr* InlineTypeNode::field_adr_type(const TypePtr* holder_type, int offset) {\n-  if (holder_type->isa_aryptr()) {\n-    return holder_type->is_aryptr()->add_field_offset_and_offset(offset);\n-  } else {\n-    return holder_type->add_offset(offset);\n-  }\n-}\n-\n@@ -463,2 +454,1 @@\n-void InlineTypeNode::load(GraphKit* kit, Node* base, Node* ptr, const TypePtr* ptr_type,\n-                          bool immutable_memory, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n+void InlineTypeNode::load(GraphKit* kit, Node* base, Node* ptr, bool immutable_memory, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n@@ -482,2 +472,2 @@\n-      value = make_from_flat_impl(kit, fvk, base, field_ptr, field_adr_type(ptr_type, field_off),\n-                                  atomic, immutable_memory, field_null_free, trust_null_free_oop && field_null_free, decorators, visited);\n+      value = make_from_flat_impl(kit, fvk, base, field_ptr, atomic, immutable_memory,\n+                                  field_null_free, trust_null_free_oop && field_null_free, decorators, visited);\n@@ -487,1 +477,0 @@\n-      Node* adr = kit->basic_plus_adr(base, ptr, field_off);\n@@ -489,1 +478,1 @@\n-      assert(is_java_primitive(bt) || adr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n+      assert(is_java_primitive(bt) || field_ptr->bottom_type()->is_ptr_to_narrowoop() == UseCompressedOops, \"inconsistent\");\n@@ -494,1 +483,2 @@\n-      value = kit->access_load_at(base, adr, field_adr_type(ptr_type, field_off), val_type, bt, decorators);\n+      const TypePtr* field_ptr_type = (decorators & C2_MISMATCHED) == 0 ? kit->gvn().type(field_ptr)->is_ptr() : TypeRawPtr::BOTTOM;\n+      value = kit->access_load_at(base, field_ptr, field_ptr_type, val_type, bt, decorators);\n@@ -654,1 +644,1 @@\n-void InlineTypeNode::store_flat(GraphKit* kit, Node* base, Node* ptr, const TypePtr* ptr_type, bool atomic, bool immutable_memory, bool null_free, DecoratorSet decorators) const {\n+void InlineTypeNode::store_flat(GraphKit* kit, Node* base, Node* ptr, bool atomic, bool immutable_memory, bool null_free, DecoratorSet decorators) const {\n@@ -670,1 +660,2 @@\n-      kit->access_store_at(base, nm_ptr, field_adr_type(ptr_type, nm_offset), get_is_init(), TypeInt::BOOL, T_BOOLEAN, decorators);\n+      const TypePtr* nm_ptr_type = (decorators & C2_MISMATCHED) == 0 ? kit->gvn().type(nm_ptr)->is_ptr() : TypeRawPtr::BOTTOM;\n+      kit->access_store_at(base, nm_ptr, nm_ptr_type, get_is_init(), TypeInt::BOOL, T_BOOLEAN, decorators);\n@@ -672,1 +663,1 @@\n-    store(kit, base, ptr, ptr_type, immutable_memory, decorators);\n+    store(kit, base, ptr, immutable_memory, decorators);\n@@ -743,9 +734,1 @@\n-    if (vk->get_field_by_offset(vk->payload_offset(), false) == nullptr && vk->null_marker_offset_in_payload() != 0) {\n-      \/\/ TODO 8357612 Weird layout\n-      kit->insert_mem_bar(Op_MemBarCPUOrder);\n-      store_flat(kit, cast, ptr, TypeRawPtr::BOTTOM, true, false, false, decorators | C2_MISMATCHED);\n-      kit->insert_mem_bar(Op_MemBarCPUOrder);\n-    } else {\n-      const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n-      store_flat(kit, cast, ptr, ptr_type, true, false, false, decorators);\n-    }\n+    store_flat(kit, cast, ptr, true, false, false, decorators);\n@@ -763,3 +746,12 @@\n-    if (vk->nof_nonstatic_fields() == 0) {\n-      \/\/ Store into a null-free empty array is a nop. This short circuit must be done because we\n-      \/\/ cannot calculate the address type of the elements in this case.\n+    Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n+    IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n+\n+    \/\/ Atomic\n+    kit->set_control(kit->IfTrue(iff_atomic));\n+    if (!kit->stopped()) {\n+      assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n+      kit->set_all_memory(input_memory_state);\n+      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n+      store_flat(kit, cast, ptr, true, false, true, decorators);\n+\n@@ -769,44 +761,1 @@\n-    } else {\n-      Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n-      IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n-\n-      \/\/ Atomic\n-      kit->set_control(kit->IfTrue(iff_atomic));\n-      if (!kit->stopped()) {\n-        assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n-        kit->set_all_memory(input_memory_state);\n-        Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n-        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n-\n-        if (vk->get_field_by_offset(vk->payload_offset(), false) == nullptr) {\n-          \/\/ TODO 8357612 Weird layout\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-          store_flat(kit, cast, ptr, TypeRawPtr::BOTTOM, true, false, true, decorators | C2_MISMATCHED);\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-        } else {\n-          const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n-          store_flat(kit, cast, ptr, ptr_type, true, false, true, decorators);\n-        }\n-\n-        region->init_req(2, kit->control());\n-        mem->set_req(2, kit->reset_memory());\n-        io->set_req(2, kit->i_o());\n-      }\n-\n-      \/\/ Non-atomic\n-      kit->set_control(kit->IfFalse(iff_atomic));\n-      if (!kit->stopped()) {\n-        assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n-        kit->set_all_memory(input_memory_state);\n-        Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n-        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n-\n-        if (vk->get_field_by_offset(vk->payload_offset(), false) == nullptr) {\n-          \/\/ TODO 8357612 Weird layout\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-          store_flat(kit, cast, ptr, TypeRawPtr::BOTTOM, false, false, true, decorators | C2_MISMATCHED);\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-        } else {\n-          const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n-          store_flat(kit, cast, ptr, ptr_type, false, false, true, decorators);\n-        }\n+    }\n@@ -814,4 +763,12 @@\n-        region->init_req(3, kit->control());\n-        mem->set_req(3, kit->reset_memory());\n-        io->set_req(3, kit->i_o());\n-      }\n+    \/\/ Non-atomic\n+    kit->set_control(kit->IfFalse(iff_atomic));\n+    if (!kit->stopped()) {\n+      assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n+      kit->set_all_memory(input_memory_state);\n+      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n+      store_flat(kit, cast, ptr, false, false, true, decorators);\n+\n+      region->init_req(3, kit->control());\n+      mem->set_req(3, kit->reset_memory());\n+      io->set_req(3, kit->i_o());\n@@ -826,1 +783,1 @@\n-void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, const TypePtr* ptr_type, bool immutable_memory, DecoratorSet decorators) const {\n+void InlineTypeNode::store(GraphKit* kit, Node* base, Node* ptr, bool immutable_memory, DecoratorSet decorators) const {\n@@ -835,1 +792,0 @@\n-    const TypePtr* field_ptr_type = field_adr_type(ptr_type, field_off);\n@@ -842,1 +798,1 @@\n-      field_val->as_InlineType()->store_flat(kit, base, field_ptr, field_ptr_type, atomic, immutable_memory, field_null_free, decorators);\n+      field_val->as_InlineType()->store_flat(kit, base, field_ptr, atomic, immutable_memory, field_null_free, decorators);\n@@ -846,0 +802,1 @@\n+      const TypePtr* field_ptr_type = (decorators & C2_MISMATCHED) == 0 ? kit->gvn().type(field_ptr)->is_ptr() : TypeRawPtr::BOTTOM;\n@@ -904,1 +861,1 @@\n-    store(kit, alloc_oop, payload_alloc_oop, kit->gvn().type(payload_alloc_oop)->is_ptr(), true, IN_HEAP | MO_UNORDERED | C2_TIGHTLY_COUPLED_ALLOC);\n+    store(kit, alloc_oop, payload_alloc_oop, true, IN_HEAP | MO_UNORDERED | C2_TIGHTLY_COUPLED_ALLOC);\n@@ -1201,1 +1158,1 @@\n-    vt->load(kit, not_null_oop, payload_ptr, gvn.type(payload_ptr)->is_ptr(), true, true, IN_HEAP | MO_UNORDERED, visited);\n+    vt->load(kit, not_null_oop, payload_ptr, true, true, IN_HEAP | MO_UNORDERED, visited);\n@@ -1220,1 +1177,1 @@\n-    vt->load(kit, oop, payload_ptr, gvn.type(payload_ptr)->is_ptr(), true, true, IN_HEAP | MO_UNORDERED, visited);\n+    vt->load(kit, oop, payload_ptr, true, true, IN_HEAP | MO_UNORDERED, visited);\n@@ -1230,1 +1187,1 @@\n-InlineTypeNode* InlineTypeNode::make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr, const TypePtr* ptr_type,\n+InlineTypeNode* InlineTypeNode::make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr,\n@@ -1234,1 +1191,1 @@\n-  return make_from_flat_impl(kit, vk, base, ptr, ptr_type, atomic, immutable_memory, null_free, null_free, decorators, visited);\n+  return make_from_flat_impl(kit, vk, base, ptr, atomic, immutable_memory, null_free, null_free, decorators, visited);\n@@ -1238,2 +1195,2 @@\n-InlineTypeNode* InlineTypeNode::make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr, const TypePtr* ptr_type,\n-                                                    bool atomic, bool immutable_memory, bool null_free, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n+InlineTypeNode* InlineTypeNode::make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr, bool atomic, bool immutable_memory,\n+                                                    bool null_free, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited) {\n@@ -1257,1 +1214,2 @@\n-      Node* nm_value = kit->access_load_at(base, nm_ptr, field_adr_type(ptr_type, nm_offset), TypeInt::BOOL, T_BOOLEAN, decorators);\n+      const TypePtr* nm_ptr_type = (decorators & C2_MISMATCHED) == 0 ? gvn.type(nm_ptr)->is_ptr() : TypeRawPtr::BOTTOM;\n+      Node* nm_value = kit->access_load_at(base, nm_ptr, nm_ptr_type, TypeInt::BOOL, T_BOOLEAN, decorators);\n@@ -1261,1 +1219,1 @@\n-    vt->load(kit, base, ptr, ptr_type, immutable_memory, trust_null_free_oop, decorators, visited);\n+    vt->load(kit, base, ptr, immutable_memory, trust_null_free_oop, decorators, visited);\n@@ -1311,9 +1269,1 @@\n-    if (vk->get_field_by_offset(vk->payload_offset(), false) == nullptr && vk->null_marker_offset_in_payload() != 0) {\n-      \/\/ TODO 8357612 Weird layout\n-      kit->insert_mem_bar(Op_MemBarCPUOrder);\n-      vt_nullable = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, TypeRawPtr::BOTTOM, true, false, false, decorators | C2_MISMATCHED);\n-      kit->insert_mem_bar(Op_MemBarCPUOrder);\n-    } else {\n-      const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n-      vt_nullable = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, ptr_type, true, false, false, decorators);\n-    }\n+    vt_nullable = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, true, false, false, decorators);\n@@ -1331,4 +1281,12 @@\n-    if (vk->nof_nonstatic_fields() == 0) {\n-      \/\/ Load from a null-free empty array, just return the default instance. This short circuit\n-      \/\/ must be done because we cannot calculate the address type of the elements in this case.\n-      vt_null_free = make_all_zero(gvn, vk);\n+    Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n+    IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n+\n+    \/\/ Atomic\n+    kit->set_control(kit->IfTrue(iff_atomic));\n+    if (!kit->stopped()) {\n+      assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n+      kit->set_all_memory(input_memory_state);\n+      Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n+      Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n+      vt_null_free = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, true, false, true, decorators);\n+\n@@ -1338,44 +1296,1 @@\n-    } else {\n-      Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n-      IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n-\n-      \/\/ Atomic\n-      kit->set_control(kit->IfTrue(iff_atomic));\n-      if (!kit->stopped()) {\n-        assert(vk->has_atomic_layout(), \"element type %s does not have a null-free atomic flat layout\", vk->name()->as_utf8());\n-        kit->set_all_memory(input_memory_state);\n-        Node* cast = kit->cast_to_flat_array(base, vk, true, false, true);\n-        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n-\n-        if (vk->get_field_by_offset(vk->payload_offset(), false) == nullptr) {\n-          \/\/ TODO 8357612 Weird layout\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-          vt_null_free = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, TypeRawPtr::BOTTOM, true, false, true, decorators | C2_MISMATCHED);\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-        } else {\n-          const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n-          vt_null_free = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, ptr_type, true, false, true, decorators);\n-        }\n-\n-        region->init_req(2, kit->control());\n-        mem->set_req(2, kit->reset_memory());\n-        io->set_req(2, kit->i_o());\n-      }\n-\n-      \/\/ Non-Atomic\n-      kit->set_control(kit->IfFalse(iff_atomic));\n-      if (!kit->stopped()) {\n-        assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n-        kit->set_all_memory(input_memory_state);\n-        Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n-        Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n-\n-        if (vk->get_field_by_offset(vk->payload_offset(), false) == nullptr) {\n-          \/\/ TODO 8357612 Weird layout\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-          vt_non_atomic = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, TypeRawPtr::BOTTOM, false, false, true, decorators | C2_MISMATCHED);\n-          kit->insert_mem_bar(Op_MemBarCPUOrder);\n-        } else {\n-          const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n-          vt_non_atomic = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, ptr_type, false, false, true, decorators);\n-        }\n+    }\n@@ -1383,4 +1298,12 @@\n-        region->init_req(3, kit->control());\n-        mem->set_req(3, kit->reset_memory());\n-        io->set_req(3, kit->i_o());\n-      }\n+    \/\/ Non-Atomic\n+    kit->set_control(kit->IfFalse(iff_atomic));\n+    if (!kit->stopped()) {\n+      assert(vk->has_non_atomic_layout(), \"element type %s does not have a null-free non-atomic flat layout\", vk->name()->as_utf8());\n+      kit->set_all_memory(input_memory_state);\n+      Node* cast = kit->cast_to_flat_array(base, vk, true, false, false);\n+      Node* ptr = kit->array_element_address(cast, idx, T_FLAT_ELEMENT);\n+      vt_non_atomic = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, false, false, true, decorators);\n+\n+      region->init_req(3, kit->control());\n+      mem->set_req(3, kit->reset_memory());\n+      io->set_req(3, kit->i_o());\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":75,"deletions":152,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -62,2 +62,0 @@\n-  static const TypePtr* field_adr_type(const TypePtr* holder_type, int offset);\n-\n@@ -70,1 +68,1 @@\n-  void load(GraphKit* kit, Node* base, Node* ptr, const TypePtr* ptr_type, bool immutable_memory, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n+  void load(GraphKit* kit, Node* base, Node* ptr, bool immutable_memory, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n@@ -72,1 +70,1 @@\n-  void store(GraphKit* kit, Node* base, Node* ptr, const TypePtr* ptr_type, bool immutable_memory, DecoratorSet decorators) const;\n+  void store(GraphKit* kit, Node* base, Node* ptr, bool immutable_memory, DecoratorSet decorators) const;\n@@ -79,2 +77,2 @@\n-  static InlineTypeNode* make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr, const TypePtr* ptr_type,\n-                                             bool atomic, bool immutable_memory, bool null_free, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n+  static InlineTypeNode* make_from_flat_impl(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr, bool atomic, bool immutable_memory,\n+                                             bool null_free, bool trust_null_free_oop, DecoratorSet decorators, GrowableArray<ciType*>& visited);\n@@ -93,2 +91,2 @@\n-  static InlineTypeNode* make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr, const TypePtr* ptr_type,\n-                                        bool atomic, bool immutable_memory, bool null_free, DecoratorSet decorators = IN_HEAP | MO_UNORDERED);\n+  static InlineTypeNode* make_from_flat(GraphKit* kit, ciInlineKlass* vk, Node* base, Node* ptr,\n+                                        bool atomic, bool immutable_memory, bool null_free, DecoratorSet decorators);\n@@ -136,1 +134,1 @@\n-  void store_flat(GraphKit* kit, Node* base, Node* ptr, const TypePtr* ptr_type, bool atomic, bool immutable_memory, bool null_free, DecoratorSet decorators) const;\n+  void store_flat(GraphKit* kit, Node* base, Node* ptr, bool atomic, bool immutable_memory, bool null_free, DecoratorSet decorators) const;\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2698,1 +2698,1 @@\n-      val->as_InlineType()->store_flat(this, base, adr, adr_type, false, false, true, decorators);\n+      val->as_InlineType()->store_flat(this, base, adr, false, false, true, decorators);\n@@ -2734,1 +2734,1 @@\n-  value->as_InlineType()->store_flat(this, obj, payload_ptr, gvn().type(payload_ptr)->is_ptr(), false, true, true, IN_HEAP | MO_UNORDERED);\n+  value->as_InlineType()->store_flat(this, obj, payload_ptr, false, true, true, IN_HEAP | MO_UNORDERED);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/accessDecorators.hpp\"\n@@ -154,1 +155,0 @@\n-    const TypePtr* adr_type = gvn().type(adr)->is_ptr();\n@@ -157,1 +157,1 @@\n-    ld = InlineTypeNode::make_from_flat(this, field_klass->as_inline_klass(), obj, adr, adr_type, atomic, is_immutable, field->is_null_free());\n+    ld = InlineTypeNode::make_from_flat(this, field_klass->as_inline_klass(), obj, adr, atomic, is_immutable, field->is_null_free(), IN_HEAP | MO_UNORDERED);\n@@ -276,1 +276,0 @@\n-    const TypePtr* adr_type = gvn().type(adr)->is_ptr();\n@@ -279,1 +278,1 @@\n-    val->as_InlineType()->store_flat(this, obj, adr, adr_type, atomic, is_immutable, field->is_null_free(), IN_HEAP | MO_UNORDERED);\n+    val->as_InlineType()->store_flat(this, obj, adr, atomic, is_immutable, field->is_null_free(), IN_HEAP | MO_UNORDERED);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}