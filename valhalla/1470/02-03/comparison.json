{"files":[{"patch":"@@ -3533,1 +3533,7 @@\n-          bt = vk->get_field_by_offset(field_offset, false)->layout_type();\n+          ciField* field = vk->get_field_by_offset(field_offset, false);\n+          if (field != nullptr) {\n+            bt = field->layout_type();\n+          } else {\n+            assert(field_offset == vk->payload_offset() + vk->null_marker_offset_in_payload(), \"cannot find field of %s at offset %d\", vk->name()->as_utf8(), field_offset);\n+            bt = T_BOOLEAN;\n+          }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -718,4 +718,11 @@\n-  RegionNode* region = new RegionNode(4);\n-  region->init_req(1, kit->top());\n-  region->init_req(2, kit->top());\n-  region->init_req(3, kit->top());\n+  RegionNode* region;\n+  if (vk->nof_nonstatic_fields() == 0) {\n+    region = new RegionNode(3);\n+    region->init_req(1, kit->top());\n+    region->init_req(2, kit->top());\n+  } else {\n+    region = new RegionNode(4);\n+    region->init_req(1, kit->top());\n+    region->init_req(2, kit->top());\n+    region->init_req(3, kit->top());\n+  }\n@@ -728,1 +735,1 @@\n-  Node* mem = PhiNode::make(region, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n+  PhiNode* mem = PhiNode::make(region, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n@@ -746,1 +753,2 @@\n-    store_flat(kit, cast, ptr, gvn.type(ptr)->is_ptr(), true, false, false, decorators);\n+    const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n+    store_flat(kit, cast, ptr, ptr_type, true, false, false, decorators);\n@@ -757,11 +765,3 @@\n-    Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n-    IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n-\n-    kit->set_control(kit->IfTrue(iff_atomic));\n-    if (!kit->stopped()) {\n-      assert(vk->has_atomic_layout(), \"\");\n-      kit->set_all_memory(input_memory_state);\n-      Node* cast = base;\n-      Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n-      store_flat(kit, cast, ptr, gvn.type(ptr)->is_ptr(), true, false, true, decorators);\n-\n+    if (vk->nof_nonstatic_fields() == 0) {\n+      \/\/ Store into a null-free empty array is a nop. This short circuit must be done because we\n+      \/\/ cannot calculate the address type of the elements in this case.\n@@ -771,1 +771,17 @@\n-    }\n+    } else {\n+      Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n+      IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n+\n+      kit->set_control(kit->IfTrue(iff_atomic));\n+      if (!kit->stopped()) {\n+        assert(vk->has_atomic_layout(), \"\");\n+        kit->set_all_memory(input_memory_state);\n+        Node* cast = base;\n+        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n+        const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n+        store_flat(kit, cast, ptr, ptr_type, true, false, true, decorators);\n+\n+        region->set_req(2, kit->control());\n+        mem->set_req(2, kit->reset_memory());\n+        io->set_req(2, kit->i_o());\n+      }\n@@ -773,11 +789,13 @@\n-    kit->set_control(kit->IfFalse(iff_atomic));\n-    if (!kit->stopped()) {\n-      assert(vk->has_non_atomic_layout(), \"\");\n-      kit->set_all_memory(input_memory_state);\n-      Node* cast = base;\n-      Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n-      store_flat(kit, cast, ptr, gvn.type(ptr)->is_ptr(), false, false, true, decorators);\n-\n-      region->set_req(3, kit->control());\n-      mem->set_req(3, kit->reset_memory());\n-      io->set_req(3, kit->i_o());\n+      kit->set_control(kit->IfFalse(iff_atomic));\n+      if (!kit->stopped()) {\n+        assert(vk->has_non_atomic_layout(), \"\");\n+        kit->set_all_memory(input_memory_state);\n+        Node* cast = base;\n+        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n+        const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n+        store_flat(kit, cast, ptr, ptr_type, false, false, true, decorators);\n+\n+        region->set_req(3, kit->control());\n+        mem->set_req(3, kit->reset_memory());\n+        io->set_req(3, kit->i_o());\n+      }\n@@ -1252,4 +1270,11 @@\n-  RegionNode* region = new RegionNode(4);\n-  region->init_req(1, kit->top());\n-  region->init_req(2, kit->top());\n-  region->init_req(3, kit->top());\n+  RegionNode* region;\n+  if (vk->nof_nonstatic_fields() == 0) {\n+    region = new RegionNode(3);\n+    region->init_req(1, kit->top());\n+    region->init_req(2, kit->top());\n+  } else {\n+    region = new RegionNode(4);\n+    region->init_req(1, kit->top());\n+    region->init_req(2, kit->top());\n+    region->init_req(3, kit->top());\n+  }\n@@ -1262,1 +1287,1 @@\n-  Node* mem = PhiNode::make(region, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n+  PhiNode* mem = PhiNode::make(region, input_memory_state, Type::MEMORY, TypePtr::BOTTOM);\n@@ -1280,1 +1305,2 @@\n-    vt_nullable = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, gvn.type(ptr)->is_ptr(), true, false, false, decorators);\n+    const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n+    vt_nullable = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, ptr_type, true, false, false, decorators);\n@@ -1292,12 +1318,4 @@\n-    Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n-    IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n-\n-    \/\/ Atomic\n-    kit->set_control(kit->IfTrue(iff_atomic));\n-    if (!kit->stopped()) {\n-      assert(vk->has_atomic_layout(), \"\");\n-      kit->set_all_memory(input_memory_state);\n-      Node* cast = base;\n-      Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n-      vt_null_free = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, gvn.type(ptr)->is_ptr(), true, false, true, decorators);\n-\n+    if (vk->nof_nonstatic_fields() == 0) {\n+      \/\/ Load from a null-free empty array, just return the default instance. This short circuit\n+      \/\/ must be done because we cannot calculate the address type of the elements in this case.\n+      vt_null_free = make_all_zero(gvn, vk);\n@@ -1307,1 +1325,18 @@\n-    }\n+    } else {\n+      Node* bol_atomic = kit->null_free_atomic_array_test(base, vk);\n+      IfNode* iff_atomic = kit->create_and_map_if(kit->control(), bol_atomic, PROB_FAIR, COUNT_UNKNOWN);\n+\n+      \/\/ Atomic\n+      kit->set_control(kit->IfTrue(iff_atomic));\n+      if (!kit->stopped()) {\n+        assert(vk->has_atomic_layout(), \"\");\n+        kit->set_all_memory(input_memory_state);\n+        Node* cast = base;\n+        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ true);\n+        const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n+        vt_null_free = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, ptr_type, true, false, true, decorators);\n+\n+        region->set_req(2, kit->control());\n+        mem->set_req(2, kit->reset_memory());\n+        io->set_req(2, kit->i_o());\n+      }\n@@ -1309,14 +1344,16 @@\n-    \/\/ Non-Atomic\n-    kit->set_control(kit->IfFalse(iff_atomic));\n-    if (!kit->stopped()) {\n-      assert(vk->has_non_atomic_layout(), \"\");\n-      \/\/ TODO 8350865 Is the conversion to\/from payload folded? We should wire this directly.\n-      \/\/ Also remove the PreserveReexecuteState in Parse::array_load when buffering is no longer possible.\n-      kit->set_all_memory(input_memory_state);\n-      Node* cast = base;\n-      Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n-      vt_non_atomic = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, gvn.type(ptr)->is_ptr(), false, false, true, decorators);\n-\n-      region->set_req(3, kit->control());\n-      mem->set_req(3, kit->reset_memory());\n-      io->set_req(3, kit->i_o());\n+      \/\/ Non-Atomic\n+      kit->set_control(kit->IfFalse(iff_atomic));\n+      if (!kit->stopped()) {\n+        assert(vk->has_non_atomic_layout(), \"\");\n+        \/\/ TODO 8350865 Is the conversion to\/from payload folded? We should wire this directly.\n+        \/\/ Also remove the PreserveReexecuteState in Parse::array_load when buffering is no longer possible.\n+        kit->set_all_memory(input_memory_state);\n+        Node* cast = base;\n+        Node* ptr = kit->flat_array_element_address(cast, idx, vk, \/* null_free *\/ true, \/* not_null_free *\/ false, \/* atomic *\/ false);\n+        const TypeAryPtr* ptr_type = gvn.type(cast)->is_aryptr()->with_field_offset(0)->with_offset(TypePtr::OffsetBot);\n+        vt_non_atomic = InlineTypeNode::make_from_flat(kit, vk, cast, ptr, ptr_type, false, false, true, decorators);\n+\n+        region->set_req(3, kit->control());\n+        mem->set_req(3, kit->reset_memory());\n+        io->set_req(3, kit->i_o());\n+      }\n@@ -1346,3 +1383,9 @@\n-  vt = vt->merge_with(&gvn, vt_nullable == nullptr ? zero : vt_nullable, 1, false);\n-  vt = vt->merge_with(&gvn, vt_null_free == nullptr ? zero : vt_null_free, 2, false);\n-  vt = vt->merge_with(&gvn, vt_non_atomic == nullptr ? zero : vt_non_atomic, 3, false);\n+  if (vt_nullable != nullptr) {\n+    vt = vt->merge_with(&gvn, vt_nullable, 1, false);\n+  }\n+  if (vt_null_free != nullptr) {\n+    vt = vt->merge_with(&gvn, vt_null_free, 2, false);\n+  }\n+  if (vt_non_atomic != nullptr) {\n+    vt = vt->merge_with(&gvn, vt_non_atomic, 3, false);\n+  }\n","filename":"src\/hotspot\/share\/opto\/inlinetypenode.cpp","additions":108,"deletions":65,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -3862,0 +3863,1 @@\n+        BasicType field_bt;\n@@ -3863,3 +3865,7 @@\n-        assert(field != nullptr, \"missing field\");\n-        BasicType bt = field->layout_type();\n-        _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(bt);\n+        if (field != nullptr) {\n+          field_bt = field->layout_type();\n+        } else {\n+          assert(field_offset.get() == vk->null_marker_offset_in_payload(), \"no field of null marker of %s at offset %d\", vk->name()->as_utf8(), foffset);\n+          field_bt = T_BOOLEAN;\n+        }\n+        _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(field_bt);\n@@ -5791,0 +5797,2 @@\n+  } else if (is_not_flat()) {\n+    st->print(\":not_flat\");\n@@ -5794,0 +5802,2 @@\n+  } else if (is_not_null_free()) {\n+    st->print(\":nullable\");\n@@ -5896,1 +5906,1 @@\n-      if (field != nullptr) {\n+      if (field != nullptr || field_offset == vk->null_marker_offset_in_payload()) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1154,1 +1154,1 @@\n-    \/\/ TODO more aggressive flattening\n+    \/\/ TODO 8357580 more aggressive flattening\n@@ -1169,1 +1169,1 @@\n-    \/\/ TODO more aggressive flattening\n+    \/\/ TODO 8357580 more aggressive flattening\n","filename":"test\/hotspot\/jtreg\/compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}