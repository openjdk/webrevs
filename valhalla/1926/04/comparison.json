{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import static com.sun.tools.javac.code.Kinds.Kind.PCK;\n@@ -47,0 +48,1 @@\n+import static com.sun.tools.javac.code.Kinds.Kind.VAR;\n@@ -91,1 +93,3 @@\n-    public JCTree translateTopLevelClass(JCTree cdef, TreeMaker make) {\n+    Env<AttrContext> env;\n+\n+    public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n@@ -95,0 +99,1 @@\n+                this.env = env;\n@@ -99,0 +104,1 @@\n+                this.env = null;\n@@ -141,0 +147,40 @@\n+    @Override\n+    public void visitIdent(JCIdent tree) {\n+        super.visitIdent(tree);\n+        identSelectVisitHelper(tree);\n+    }\n+\n+    @Override\n+    public void visitSelect(JCFieldAccess tree) {\n+        super.visitSelect(tree);\n+        identSelectVisitHelper(tree);\n+    }\n+\n+    \/\/ where\n+        private void identSelectVisitHelper(JCTree tree) {\n+            Symbol sym = TreeInfo.symbolFor(tree);\n+            if (!noUseSiteNullChecks &&\n+                    sym.owner.kind == TYP &&\n+                    sym.kind == VAR &&\n+                    !isInThisSameCompUnit(sym) &&\n+                    types.isNonNullable(sym.type)) {\n+                \/* we are accessing a non-nullable field declared in another\n+                 * compilation unit\n+                 *\/\n+                result = attr.makeNullCheck((JCExpression) tree, true);\n+            }\n+        }\n+\n+        private boolean isInThisSameCompUnit(Symbol sym) {\n+            return env.toplevel.getTypeDecls().stream().anyMatch(tree -> TreeInfo.symbolFor(tree) == outermostType(sym));\n+        }\n+\n+        private Symbol outermostType(Symbol sym) {\n+            Symbol prev = null;\n+            while (sym.kind != PCK) {\n+                prev = sym;\n+                sym = sym.owner;\n+            }\n+            return prev;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/NullChecksWriter.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1711,1 +1711,1 @@\n-                NullChecksWriter.instance(context).translateTopLevelClass(def, localMake);\n+                NullChecksWriter.instance(context).translateTopLevelClass(env, def, localMake);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-    public void testClientSideChecks(Path base) throws Exception {\n+    public void testUseSideChecksForMethods(Path base) throws Exception {\n@@ -507,2 +507,2 @@\n-    public void testClientSideChecksSepCompilation(Path base) throws Exception {\n-        testSeparateCompilationHelper(base,\n+    public void testUseSideChecksForMethodsSepCompilation(Path base) throws Exception {\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n@@ -529,1 +529,1 @@\n-        testSeparateCompilationHelper(base,\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n@@ -550,1 +550,1 @@\n-        testSeparateCompilationHelper(base,\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n@@ -575,1 +575,1 @@\n-        testSeparateCompilationHelper(base,\n+        testUseSiteForMethodsSeparateCompilationHelper(base,\n@@ -602,1 +602,1 @@\n-    private void testSeparateCompilationHelper(\n+    private void testUseSiteForMethodsSeparateCompilationHelper(\n@@ -653,0 +653,95 @@\n+\n+    @Test\n+    public void testUseSideChecksForFieldsSepCompilation(Path base) throws Exception {\n+        testUseSiteForFieldsSeparateCompilationHelper(base,\n+                \"\"\"\n+                package pkg;\n+                public class A {\n+                    String! a;\n+                    public A() {\n+                        this.a = \"test\";\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                public class A {\n+                    String a;\n+                    public A() {\n+                        this.a = null;\n+                        super();\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                class Test {\n+                    public static void main(String... args) {\n+                        A a = new A();\n+                        System.out.println(a.a.toString());\n+                    }\n+                }\n+                \"\"\");\n+    }\n+\n+    private void testUseSiteForFieldsSeparateCompilationHelper(\n+            Path base,\n+            String code1,\n+            String code2,\n+            String testCode) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path ASrc = pkg.resolve(\"A\");\n+        Path test = pkg.resolve(\"Test\");\n+\n+        tb.writeJavaFiles(ASrc, code1);\n+        tb.writeJavaFiles(test, testCode);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        \/\/ this compilation will generate null checks in Test before accessing field A.a\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(PREVIEW_OPTIONS)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's producing the NPE\n+        System.err.println(\"running, this test should pass\");\n+        String output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Test\")\n+                .vmOptions(\"--enable-preview\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT);\n+        if (!output.startsWith(\"test\")) {\n+            throw new AssertionError(\"unexpected output: \" + output);\n+        }\n+\n+        \/\/ now lets change the code\n+        tb.writeJavaFiles(ASrc, code2);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .options(PREVIEW_OPTIONS)\n+                .files(findJavaFiles(ASrc))\n+                .run();\n+\n+        System.err.println(\"running, this test should fail\");\n+        output = new JavaTask(tb)\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Test\")\n+                .vmOptions(\"--enable-preview\")\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDERR);\n+\n+        \/\/ we need to check that the NPE is due to an invocation to j.l.r.Checks::nullCheck\n+        if (!output.contains(\"java.lang.NullPointerException\") &&\n+                !output.contains(\"java.base\/java.lang.runtime.Checks.nullCheck\")) {\n+            throw new AssertionError(\"unexpected output: \" + output);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/nullability\/RuntimeNullChecks.java","additions":102,"deletions":7,"binary":false,"changes":109,"status":"modified"}]}