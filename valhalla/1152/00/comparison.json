{"files":[{"patch":"@@ -4162,4 +4162,2 @@\n-                \/\/ valhalla is using this feature so commenting this code for now so that the\n-                \/\/ build doesn't depend on preview code\n-                \/\/ If super()\/this() isn't first, require \"statements before super()\" feature\n-                \/*if (!firstStatement) {\n+                \/\/ If super()\/this() isn't first, require flexible constructors feature\n+                if (!firstStatement)\n@@ -4167,1 +4165,0 @@\n-                }*\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+- compiler.note.preview.filename: SuperInitFails.java, DEFAULT\n+- compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitFails.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -224,2 +224,0 @@\n-compiler.misc.feature.super.init                            # temporary as we are using statements before super in value classes\n-compiler.warn.preview.feature.use                           # temporary as we are using statements before super in value classes\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+ \/\/ key: compiler.misc.feature.super.init\n+ \/\/ key: compiler.warn.preview.feature.use\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/FeatureStatementsBeforeSuper.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ReturnBeforeSuperclassInit.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,3 +105,28 @@\n-    @Test\n-    void testSuperClassConstraints() {\n-        assertFail(\"compiler.err.super.class.method.cannot.be.synchronized\",\n+    record TestData(String message, String snippet, String[] compilerOptions, boolean testLocalToo) {\n+        TestData(String snippet) {\n+            this(\"\", snippet, null, true);\n+        }\n+\n+        TestData(String snippet, boolean testLocalToo) {\n+            this(\"\", snippet, null, testLocalToo);\n+        }\n+\n+        TestData(String message, String snippet) {\n+            this(message, snippet, null, true);\n+        }\n+\n+        TestData(String snippet, String[] compilerOptions) {\n+            this(\"\", snippet, compilerOptions, true);\n+        }\n+\n+        TestData(String message, String snippet, String[] compilerOptions) {\n+            this(message, snippet, compilerOptions, true);\n+        }\n+\n+        TestData(String message, String snippet, boolean testLocalToo) {\n+            this(message, snippet, null, testLocalToo);\n+        }\n+    }\n+\n+    private void testHelper(List<TestData> testDataList) {\n+        String ttt =\n@@ -109,2 +134,12 @@\n-                abstract class I {\n-                    synchronized void foo() {}\n+                    class TTT {\n+                        void m() {\n+                            #LOCAL\n+                        }\n+                    }\n+                \"\"\";\n+        for (TestData td : testDataList) {\n+            String localSnippet = ttt.replace(\"#LOCAL\", td.snippet);\n+            String[] previousOptions = getCompileOptions();\n+            try {\n+                if (td.compilerOptions != null) {\n+                    setCompileOptions(td.compilerOptions);\n@@ -112,6 +147,15 @@\n-                value class V extends I {}\n-                \"\"\");\n-        assertFail(\"compiler.err.concrete.supertype.for.value.class\",\n-                \"\"\"\n-                class ConcreteSuperType {\n-                    static abstract value class V extends ConcreteSuperType {}  \/\/ Error: concrete super.\n+                if (td.message == \"\") {\n+                    assertOK(td.snippet);\n+                    if (td.testLocalToo) {\n+                        assertOK(localSnippet);\n+                    }\n+                } else if (td.message.startsWith(\"compiler.err\")) {\n+                    assertFail(td.message, td.snippet);\n+                    if (td.testLocalToo) {\n+                        assertFail(td.message, localSnippet);\n+                    }\n+                } else {\n+                    assertOKWithWarning(td.message, td.snippet);\n+                    if (td.testLocalToo) {\n+                        assertOKWithWarning(td.message, localSnippet);\n+                    }\n@@ -119,14 +163,46 @@\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                value record Point(int x, int y) {}\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                value class V extends Object {}\n-                \"\"\");\n-        assertFail(\"compiler.err.value.type.has.identity.super.type\",\n-                \"\"\"\n-                abstract class A {}\n-                value class V extends A {}\n-                \"\"\");\n+            } finally {\n+                setCompileOptions(previousOptions);\n+            }\n+        }\n+    }\n+\n+    private static final List<TestData> superClassConstraints = List.of(\n+            new TestData(\n+                    \"compiler.err.super.class.method.cannot.be.synchronized\",\n+                    \"\"\"\n+                    abstract class I {\n+                        synchronized void foo() {}\n+                    }\n+                    value class V extends I {}\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.concrete.supertype.for.value.class\",\n+                    \"\"\"\n+                    class ConcreteSuperType {\n+                        static abstract value class V extends ConcreteSuperType {}  \/\/ Error: concrete super.\n+                    }\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"\"\"\n+                    value record Point(int x, int y) {}\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"\"\"\n+                    value class V extends Object {}\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.value.type.has.identity.super.type\",\n+                    \"\"\"\n+                    abstract class A {}\n+                    value class V extends A {}\n+                    \"\"\"\n+            )\n+    );\n+\n+    @Test\n+    void testSuperClassConstraints() {\n+        testHelper(superClassConstraints);\n@@ -183,26 +259,18 @@\n-    @Test\n-    void testSemanticsViolations() {\n-        assertFail(\"compiler.err.cant.inherit.from.final\",\n-                \"\"\"\n-                value class Base {}\n-                class Subclass extends Base {}\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.assign.val.to.var\",\n-                \"\"\"\n-                value class Point {\n-                    int x = 10;\n-                    int y;\n-                    Point (int x, int y) {\n-                        this.x = x; \/\/ Error, final field 'x' is already assigned to.\n-                        this.y = y; \/\/ OK.\n-                    }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.assign.val.to.var\",\n-                \"\"\"\n-                abstract value class Point {\n-                    int x = 10;\n-                    int y;\n-                    Point (int x, int y) {\n-                        this.x = x; \/\/ Error, final field 'x' is already assigned to.\n-                        this.y = y; \/\/ OK.\n+    private static final List<TestData> semanticsViolations = List.of(\n+            new TestData(\n+                    \"compiler.err.cant.inherit.from.final\",\n+                    \"\"\"\n+                    value class Base {}\n+                    class Subclass extends Base {}\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.cant.assign.val.to.var\",\n+                    \"\"\"\n+                    value class Point {\n+                        int x = 10;\n+                        int y;\n+                        Point (int x, int y) {\n+                            this.x = x; \/\/ Error, final field 'x' is already assigned to.\n+                            this.y = y; \/\/ OK.\n+                        }\n@@ -210,10 +278,15 @@\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.assign.val.to.var\",\n-                \"\"\"\n-                value class Point {\n-                    int x;\n-                    int y;\n-                    Point (int x, int y) {\n-                        this.x = x;\n-                        this.y = y;\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.cant.assign.val.to.var\",\n+                    \"\"\"\n+                    value class Point {\n+                        int x;\n+                        int y;\n+                        Point (int x, int y) {\n+                            this.x = x;\n+                            this.y = y;\n+                        }\n+                        void foo(Point p) {\n+                            this.y = p.y; \/\/ Error, y is final and can't be written outside of ctor.\n+                        }\n@@ -221,3 +294,15 @@\n-\n-                    void foo(Point p) {\n-                        this.y = p.y; \/\/ Error, y is final and can't be written outside of ctor.\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.cant.assign.val.to.var\",\n+                    \"\"\"\n+                    abstract value class Point {\n+                        int x;\n+                        int y;\n+                        Point (int x, int y) {\n+                            this.x = x;\n+                            this.y = y;\n+                        }\n+                        void foo(Point p) {\n+                            this.y = p.y; \/\/ Error, y is final and can't be written outside of ctor.\n+                        }\n@@ -225,10 +310,12 @@\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.assign.val.to.var\",\n-                \"\"\"\n-                abstract value class Point {\n-                    int x;\n-                    int y;\n-                    Point (int x, int y) {\n-                        this.x = x;\n-                        this.y = y;\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.var.might.not.have.been.initialized\",\n+                    \"\"\"\n+                    value class Point {\n+                        int x;\n+                        int y;\n+                        Point (int x, int y) {\n+                            this.x = x;\n+                            \/\/ y hasn't been initialized\n+                        }\n@@ -236,3 +323,9 @@\n-\n-                    void foo(Point p) {\n-                        this.y = p.y; \/\/ Error, y is final and can't be written outside of ctor.\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.mod.not.allowed.here\",\n+                    \"\"\"\n+                    abstract value class V {\n+                        synchronized void foo() {\n+                         \/\/ Error, abstract value class may not declare a synchronized instance method.\n+                        }\n@@ -240,10 +333,6 @@\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.var.might.not.have.been.initialized\",\n-                \"\"\"\n-                value class Point {\n-                    int x;\n-                    int y;\n-                    Point (int x, int y) {\n-                        this.x = x;\n-                        \/\/ y hasn't been initialized\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"\"\"\n+                    abstract value class V {\n+                        static synchronized void foo() {} \/\/ OK static\n@@ -251,7 +340,7 @@\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n-                \"\"\"\n-                abstract value class V {\n-                    synchronized void foo() {\n-                     \/\/ Error, abstract value class may not declare a synchronized instance method.\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.mod.not.allowed.here\",\n+                    \"\"\"\n+                    value class V {\n+                        synchronized void foo() {}\n@@ -259,40 +348,6 @@\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                abstract value class V {\n-                    static synchronized void foo() {} \/\/ OK static\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n-                \"\"\"\n-                value class V {\n-                    synchronized void foo() {}\n-                }\n-                \"\"\");\n-        assertOK(\n-                \"\"\"\n-                value class V {\n-                    synchronized static void soo() {} \/\/ OK static\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.type.found.req\",\n-                \"\"\"\n-                value class V {\n-                    { synchronized(this) {} }\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.mod.not.allowed.here\",\n-                \"\"\"\n-                value record R() {\n-                    synchronized void foo() { } \/\/ Error;\n-                    synchronized static void soo() {} \/\/ OK.\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n-                \"\"\"\n-                value class V {\n-                    int x;\n-                    V() {\n-                        foo(this); \/\/ Error.\n-                        x = 10;\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"\"\"\n+                    value class V {\n+                        synchronized static void soo() {} \/\/ OK static\n@@ -300,10 +355,7 @@\n-                    void foo(V v) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.cant.ref.before.ctor.called\",\n-                \"\"\"\n-                value class V {\n-                    int x;\n-                    V() {\n-                        x = 10;\n-                        foo(this); \/\/ error\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.type.found.req\",\n+                    \"\"\"\n+                    value class V {\n+                        { synchronized(this) {} }\n@@ -311,11 +363,8 @@\n-                    void foo(V v) {}\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.type.found.req\",\n-                \"\"\"\n-                interface I {}\n-                interface VI extends I {}\n-                class C {}\n-                value class VC<T extends VC> {\n-                    void m(T t) {\n-                        synchronized(t) {} \/\/ error\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.mod.not.allowed.here\",\n+                    \"\"\"\n+                    value record R() {\n+                        synchronized void foo() { } \/\/ Error;\n+                        synchronized static void soo() {} \/\/ OK.\n@@ -323,10 +372,12 @@\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.type.found.req\",\n-                \"\"\"\n-                interface I {}\n-                interface VI extends I {}\n-                class C {}\n-                value class VC<T extends VC> {\n-                    void foo(Object o) {\n-                        synchronized ((VC & I)o) {} \/\/ error\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.cant.ref.before.ctor.called\",\n+                    \"\"\"\n+                    value class V {\n+                        int x;\n+                        V() {\n+                            foo(this); \/\/ Error.\n+                            x = 10;\n+                        }\n+                        void foo(V v) {}\n@@ -334,11 +385,12 @@\n-                }\n-                \"\"\");\n-        \/\/ OK if the value class is abstract\n-        assertOK(\n-                \"\"\"\n-                interface I {}\n-                abstract value class VI implements I {}\n-                class C {}\n-                value class VC<T extends VC> {\n-                    void bar(Object o) {\n-                        synchronized ((VI & I)o) {} \/\/ error\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.cant.ref.before.ctor.called\",\n+                    \"\"\"\n+                    value class V {\n+                        int x;\n+                        V() {\n+                            x = 10;\n+                            foo(this); \/\/ error\n+                        }\n+                        void foo(V v) {}\n@@ -346,8 +398,11 @@\n-                }\n-                \"\"\");\n-        assertFail(\"compiler.err.type.found.req\", \/\/ --enable-preview -source\"\n-                \"\"\"\n-                class V {\n-                    final Integer val = Integer.valueOf(42);\n-                    void test() {\n-                        synchronized (val) { \/\/ error\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.type.found.req\",\n+                    \"\"\"\n+                    interface I {}\n+                    interface VI extends I {}\n+                    class C {}\n+                    value class VC<T extends VC> {\n+                        void m(T t) {\n+                            synchronized(t) {} \/\/ error\n@@ -356,6 +411,0 @@\n-                }\n-                \"\"\");\n-        String[] previousOptions = getCompileOptions();\n-        try {\n-            setCompileOptions(new String[] {});\n-            assertOKWithWarning(\"compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\", \/\/ empty options\n@@ -363,5 +412,10 @@\n-                    class V {\n-                        final Integer val = Integer.valueOf(42);\n-                        void test() {\n-                            synchronized (val) { \/\/ warn\n-                            }\n+            ),\n+            new TestData(\n+                    \"compiler.err.type.found.req\",\n+                    \"\"\"\n+                    interface I {}\n+                    interface VI extends I {}\n+                    class C {}\n+                    value class VC<T extends VC> {\n+                        void foo(Object o) {\n+                            synchronized ((VC & I)o) {} \/\/ error\n@@ -370,4 +424,0 @@\n-                    \"\"\");\n-            setCompileOptions(new String[] {\"--source\",\n-                    Integer.toString(Runtime.version().feature())});\n-            assertOKWithWarning(\"compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\", \/\/ --source\n@@ -375,5 +425,10 @@\n-                    class V {\n-                        final Integer val = Integer.valueOf(42);\n-                        void test() {\n-                            synchronized (val) { \/\/ warn\n-                            }\n+            ),\n+            new TestData(\n+                    \/\/ OK if the value class is abstract\n+                    \"\"\"\n+                    interface I {}\n+                    abstract value class VI implements I {}\n+                    class C {}\n+                    value class VC<T extends VC> {\n+                        void bar(Object o) {\n+                            synchronized ((VI & I)o) {} \/\/ error\n@@ -382,4 +437,4 @@\n-                    \"\"\");\n-            setCompileOptions(new String[] {\"--enable-preview\", \"--source\",\n-                    Integer.toString(Runtime.version().feature())});\n-            assertFail(\"compiler.err.type.found.req\", \/\/ --enable-preview --source\n+                    \"\"\"\n+            ),\n+            new TestData(\n+                    \"compiler.err.type.found.req\", \/\/ --enable-preview -source\"\n@@ -390,1 +445,1 @@\n-                            synchronized (val) { \/\/ warn\n+                            synchronized (val) { \/\/ error\n@@ -394,7 +449,53 @@\n-                    \"\"\");\n-            \/* we should add tests for --release and --release --enable-preview once the stubs used for the latest\n-             * release have been updated, right now they are the same as those for 22\n-             *\/\n-        } finally {\n-            setCompileOptions(previousOptions);\n-        }\n+                    \"\"\"\n+            )\n+    );\n+\n+    @Test\n+    void testSemanticsViolations() {\n+        testHelper(semanticsViolations);\n+        testHelper(\n+                List.of(\n+                        new TestData(\n+                                \"compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\", \/\/ empty options\n+                                \"\"\"\n+                                class V {\n+                                    final Integer val = Integer.valueOf(42);\n+                                    void test() {\n+                                        synchronized (val) { \/\/ warn\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                new String[] {}\n+                        ),\n+                        new TestData(\n+                                \"compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\", \/\/ --source\n+                                \"\"\"\n+                                class V {\n+                                    final Integer val = Integer.valueOf(42);\n+                                    void test() {\n+                                        synchronized (val) { \/\/ warn\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                new String[] {\"--source\", Integer.toString(Runtime.version().feature())}\n+                        ),\n+                        new TestData(\n+                                \"compiler.err.type.found.req\", \/\/ --enable-preview --source\n+                                \"\"\"\n+                                class V {\n+                                    final Integer val = Integer.valueOf(42);\n+                                    void test() {\n+                                        synchronized (val) { \/\/ warn\n+                                        }\n+                                    }\n+                                }\n+                                \"\"\",\n+                                new String[] {\"--enable-preview\", \"--source\", Integer.toString(Runtime.version().feature())}\n+                        )\n+                        \/* we should add tests for --release and --release --enable-preview once the stubs used for the latest\n+                         * release have been updated, right now they are the same as those for 22\n+                         *\/\n+                )\n+        );\n@@ -403,0 +504,51 @@\n+    private static final List<TestData> sealedClassesData = List.of(\n+            new TestData(\n+                    \"\"\"\n+                    abstract sealed value class SC {}\n+                    value class VC extends SC {}\n+                    \"\"\",\n+                    false \/\/ local sealed classes are not allowed\n+            ),\n+            new TestData(\n+                    \"\"\"\n+                    abstract sealed interface SI {}\n+                    value class VC implements SI {}\n+                    \"\"\",\n+                    false \/\/ local sealed classes are not allowed\n+            ),\n+            new TestData(\n+                    \"\"\"\n+                    abstract sealed class SC {}\n+                    final class IC extends SC {}\n+                    non-sealed class IC2 extends SC {}\n+                    final class IC3 extends IC2 {}\n+                    \"\"\",\n+                    false\n+            ),\n+            new TestData(\n+                    \"\"\"\n+                    abstract sealed interface SI {}\n+                    final class IC implements SI {}\n+                    non-sealed class IC2 implements SI {}\n+                    final class IC3 extends IC2 {}\n+                    \"\"\",\n+                    false \/\/ local sealed classes are not allowed\n+            ),\n+            new TestData(\n+                    \"compiler.err.illegal.combination.of.modifiers\",\n+                    \"\"\"\n+                    abstract sealed value class SC {}\n+                    non-sealed value class VC extends SC {}\n+                    \"\"\",\n+                    false\n+            ),\n+            new TestData(\n+                    \"compiler.err.illegal.combination.of.modifiers\",\n+                    \"\"\"\n+                    sealed value class SI {}\n+                    non-sealed value class VC extends SI {}\n+                    \"\"\",\n+                    false\n+            )\n+    );\n+\n@@ -405,40 +557,1 @@\n-        assertOK(\n-                \"\"\"\n-                abstract sealed value class SC {}\n-                value class VC extends SC {}\n-                \"\"\"\n-        );\n-        assertOK(\n-                \"\"\"\n-                abstract sealed interface SI {}\n-                value class VC implements SI {}\n-                \"\"\"\n-        );\n-        assertOK(\n-                \"\"\"\n-                abstract sealed class SC {}\n-                final class IC extends SC {}\n-                non-sealed class IC2 extends SC {}\n-                final class IC3 extends IC2 {}\n-                \"\"\"\n-        );\n-        assertOK(\n-                \"\"\"\n-                abstract sealed interface SI {}\n-                final class IC implements SI {}\n-                non-sealed class IC2 implements SI {}\n-                final class IC3 extends IC2 {}\n-                \"\"\"\n-        );\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                abstract sealed value class SC {}\n-                non-sealed value class VC extends SC {}\n-                \"\"\"\n-        );\n-        assertFail(\"compiler.err.illegal.combination.of.modifiers\",\n-                \"\"\"\n-                sealed value class SI {}\n-                non-sealed value class VC extends SI {}\n-                \"\"\"\n-        );\n+        testHelper(sealedClassesData);\n@@ -970,1 +1083,4 @@\n-                    class ValueSerializable extends Super {\n+                    class Serializable1 extends Super {\n+                        private static final long serialVersionUID = 1;\n+                    }\n+                    class Serializable2 extends Serializable1 {\n","filename":"test\/langtools\/tools\/javac\/valhalla\/value-objects\/ValueObjectCompilationTests.java","additions":373,"deletions":257,"binary":false,"changes":630,"status":"modified"}]}