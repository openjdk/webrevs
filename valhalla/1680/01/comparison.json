{"files":[{"patch":"@@ -89,2 +89,3 @@\n-<li><a href=\"#inline-variables\" id=\"toc-inline-variables\">Inline\n-Variables<\/a><\/li>\n+<li><a href=\"#variable-templates-and-inline-variables\"\n+id=\"toc-variable-templates-and-inline-variables\">Variable Templates and\n+Inline Variables<\/a><\/li>\n@@ -940,6 +941,12 @@\n-<h3 id=\"inline-variables\">Inline Variables<\/h3>\n-<p>Variables with static storage duration may be declared\n-<code>inline<\/code> (<a href=\"https:\/\/wg21.link\/p0386r2\">p0386r2<\/a>).\n-This has similar effects as for declaring a function inline: it can be\n-defined, identically, in multiple translation units, must be defined in\n-every translation unit in which it is <a\n+<h3 id=\"variable-templates-and-inline-variables\">Variable Templates and\n+Inline Variables<\/h3>\n+<p>The use of variable templates (including static data member\n+templates) (<a href=\"https:\/\/wg21.link\/N3651\">N3651<\/a>) is permitted.\n+They provide parameterized variables and constants in a simple and\n+direct form, instead of requiring the use of various workarounds.<\/p>\n+<p>Variables with static storage duration and variable templates may be\n+declared <code>inline<\/code> (<a\n+href=\"https:\/\/wg21.link\/p0386r2\">p0386r2<\/a>), and this usage is\n+permitted. This has similar effects as for declaring a function inline:\n+it can be defined, identically, in multiple translation units, must be\n+defined in every translation unit in which it is <a\n@@ -958,2 +965,2 @@\n-<p>A <code>constexpr<\/code> static data member is implicitly\n-<code>inline<\/code>. As a consequence, an <a\n+<p>A <code>constexpr<\/code> static data member or static data member\n+template is implicitly <code>inline<\/code>. As a consequence, an <a\n@@ -961,7 +968,8 @@\n-title=\"One Definition Rule\">ODR use<\/a> of such a variable doesn't\n-require a definition in some .cpp file. (This is a change from\n-pre-C++17. Beginning with C++17, such a definition is considered a\n-duplicate definition, and is deprecated.)<\/p>\n-<p>Declaring a <code>thread_local<\/code> variable <code>inline<\/code> is\n-forbidden for HotSpot code. <a href=\"#thread_local\">The use of\n-<code>thread_local<\/code><\/a> is already heavily restricted.<\/p>\n+title=\"One Definition Rule\">ODR use<\/a> of such a member doesn't require\n+a definition in some .cpp file. (This is a change from pre-C++17.\n+Beginning with C++17, such a definition is considered a duplicate\n+definition, and is deprecated.)<\/p>\n+<p>Declaring a <code>thread_local<\/code> variable template or\n+<code>inline<\/code> variable is forbidden in HotSpot code. <a\n+href=\"#thread_local\">The use of <code>thread_local<\/code><\/a> is already\n+heavily restricted.<\/p>\n@@ -1854,5 +1862,0 @@\n-<li><p>Trailing return type syntax for functions (<a\n-href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm\">n2541<\/a>)<\/p><\/li>\n-<li><p>Variable templates (<a\n-href=\"https:\/\/isocpp.org\/files\/papers\/N3651.pdf\">n3651<\/a>, <a\n-href=\"http:\/\/wg21.link\/p0127r2\">p0127r2<\/a>)<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":25,"deletions":22,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -859,1 +859,1 @@\n-### Inline Variables\n+### Variable Templates and Inline Variables\n@@ -861,6 +861,11 @@\n-Variables with static storage duration may be declared `inline`\n-([p0386r2](https:\/\/wg21.link\/p0386r2)). This has similar effects as for\n-declaring a function inline: it can be defined, identically, in multiple\n-translation units, must be defined in every translation unit in which it is\n-[ODR used][ODR], and the behavior of the program is as if there is exactly one\n-variable.\n+The use of variable templates (including static data member templates)\n+([N3651](https:\/\/wg21.link\/N3651)) is permitted. They provide parameterized\n+variables and constants in a simple and direct form, instead of requiring the\n+use of various workarounds.\n+\n+Variables with static storage duration and variable templates may be declared\n+`inline` ([p0386r2](https:\/\/wg21.link\/p0386r2)), and this usage is\n+permitted. This has similar effects as for declaring a function inline: it can\n+be defined, identically, in multiple translation units, must be defined in\n+every translation unit in which it is [ODR used][ODR], and the behavior of the\n+program is as if there is exactly one variable.\n@@ -877,2 +882,3 @@\n-A `constexpr` static data member is implicitly `inline`. As a consequence, an\n-[ODR use][ODR] of such a variable doesn't require a definition in some .cpp\n+A `constexpr` static data member or static data member template\n+is implicitly `inline`. As a consequence, an\n+[ODR use][ODR] of such a member doesn't require a definition in some .cpp\n@@ -882,2 +888,3 @@\n-Declaring a `thread_local` variable `inline` is forbidden for HotSpot code.\n-[The use of `thread_local`](#thread_local) is already heavily restricted.\n+Declaring a `thread_local` variable template or `inline` variable is forbidden\n+in HotSpot code.  [The use of `thread_local`](#thread_local) is already\n+heavily restricted.\n@@ -1849,7 +1856,0 @@\n-* Trailing return type syntax for functions\n-([n2541](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2541.htm))\n-\n-* Variable templates\n-([n3651](https:\/\/isocpp.org\/files\/papers\/N3651.pdf),\n-[p0127r2](http:\/\/wg21.link\/p0127r2))\n-\n","filename":"doc\/hotspot-style.md","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -937,42 +937,0 @@\n-\n-  # Check whether the compiler supports the Arm C Language Extensions (ACLE)\n-  # for SVE. Set SVE_CFLAGS to -march=armv8-a+sve if it does.\n-  # ACLE and this flag are required to build the aarch64 SVE related functions in\n-  # libvectormath. Apple Silicon does not support SVE; use macOS as a proxy for\n-  # that check.\n-  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n-    if test \"x$TOOLCHAIN_TYPE\" = xgcc || test \"x$TOOLCHAIN_TYPE\" = xclang; then\n-      AC_LANG_PUSH(C)\n-      OLD_CFLAGS=\"$CFLAGS\"\n-      CFLAGS=\"$CFLAGS -march=armv8-a+sve\"\n-      AC_MSG_CHECKING([if Arm SVE ACLE is supported])\n-      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <arm_sve.h>],\n-          [\n-            svint32_t r = svdup_n_s32(1);\n-            return 0;\n-          ])],\n-          [\n-            AC_MSG_RESULT([yes])\n-            $2SVE_CFLAGS=\"-march=armv8-a+sve\"\n-            # Switching the initialization mode with gcc from 'pattern' to 'zero'\n-            # avoids the use of unsupported `__builtin_clear_padding` for variable\n-            # length aggregates\n-            if test \"x$DEBUG_LEVEL\" != xrelease && test \"x$TOOLCHAIN_TYPE\" = xgcc ; then\n-              INIT_ZERO_FLAG=\"-ftrivial-auto-var-init=zero\"\n-              FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [$INIT_ZERO_FLAG],\n-                IF_TRUE: [\n-                  $2SVE_CFLAGS=\"${$2SVE_CFLAGS} $INIT_ZERO_FLAG\"\n-                ]\n-              )\n-            fi\n-          ],\n-          [\n-            AC_MSG_RESULT([no])\n-            $2SVE_CFLAGS=\"\"\n-          ]\n-      )\n-      CFLAGS=\"$OLD_CFLAGS\"\n-      AC_LANG_POP(C)\n-    fi\n-  fi\n-  AC_SUBST($2SVE_CFLAGS)\n","filename":"make\/autoconf\/flags-cflags.m4","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -110,0 +110,56 @@\n+# Check whether the compiler supports the Arm C Language Extensions (ACLE)\n+# for SVE. Set SVE_CFLAGS to -march=armv8-a+sve if it does.\n+# ACLE and this flag are required to build the aarch64 SVE related functions\n+# in libvectormath.\n+AC_DEFUN([FLAGS_SETUP_SVE],\n+[\n+  AARCH64_SVE_AVAILABLE=false\n+  # Apple Silicon does not support SVE; use macOS as a proxy for that check.\n+  if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" && test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n+    if test \"x$TOOLCHAIN_TYPE\" = xgcc || test \"x$TOOLCHAIN_TYPE\" = xclang; then\n+      # check the compiler and binutils support sve or not\n+      AC_MSG_CHECKING([if Arm SVE ACLE is supported])\n+      AC_LANG_PUSH([C])\n+      saved_cflags=\"$CFLAGS\"\n+      CFLAGS=\"$CFLAGS -march=armv8-a+sve $CFLAGS_WARNINGS_ARE_ERRORS ARG_ARGUMENT\"\n+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n+        [\n+          #include <arm_sve.h>\n+          svfloat64_t a() {}\n+        ],\n+        [\n+          svint32_t r = svdup_n_s32(1)\n+        ])],\n+        [\n+          AARCH64_SVE_AVAILABLE=true\n+        ]\n+      )\n+      CFLAGS=\"$saved_cflags\"\n+      AC_LANG_POP([C])\n+      AC_MSG_RESULT([$AARCH64_SVE_AVAILABLE])\n+    fi\n+  fi\n+\n+  UTIL_ARG_ENABLE(NAME: aarch64-sve, DEFAULT: auto,\n+    RESULT: AARCH64_SVE_ENABLED,\n+    DESC: [Use SVE when compiling libsleef],\n+    AVAILABLE: $AARCH64_SVE_AVAILABLE)\n+  SVE_CFLAGS=\"\"\n+  if test \"x$AARCH64_SVE_ENABLED\" = xtrue; then\n+    SVE_CFLAGS=\"-march=armv8-a+sve\"\n+    # Switching the initialization mode with gcc from 'pattern' to 'zero'\n+    # avoids the use of unsupported `__builtin_clear_padding` for variable\n+    # length aggregates\n+    if test \"x$DEBUG_LEVEL\" != xrelease && test \"x$TOOLCHAIN_TYPE\" = xgcc ; then\n+      AC_MSG_CHECKING([Switching the initialization mode with gcc from pattern to zero])\n+      INIT_ZERO_FLAG=\"-ftrivial-auto-var-init=zero\"\n+      FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [$INIT_ZERO_FLAG],\n+        IF_TRUE: [\n+          SVE_CFLAGS=\"${SVE_CFLAGS} $INIT_ZERO_FLAG\"\n+        ]\n+      )\n+    fi\n+  fi\n+  AC_SUBST(SVE_CFLAGS)\n+])\n+\n","filename":"make\/autoconf\/flags-other.m4","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -377,0 +377,1 @@\n+  FLAGS_SETUP_SVE\n","filename":"make\/autoconf\/flags.m4","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/assembler.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-  Atomic::inc(&_patching_epoch);\n+  AtomicAccess::inc(&_patching_epoch);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    return Atomic::load_acquire(guard_addr());\n+    return AtomicAccess::load_acquire(guard_addr());\n@@ -122,1 +122,1 @@\n-      Atomic::release_store(guard_addr(), value);\n+      AtomicAccess::release_store(guard_addr(), value);\n@@ -127,1 +127,1 @@\n-    int old_value = Atomic::load(guard_addr());\n+    int old_value = AtomicAccess::load(guard_addr());\n@@ -132,1 +132,1 @@\n-      int v = Atomic::cmpxchg(guard_addr(), old_value, new_value, memory_order_release);\n+      int v = AtomicAccess::cmpxchg(guard_addr(), old_value, new_value, memory_order_release);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1700,1 +1700,1 @@\n-  void ghash_processBlocks_wide(address p, Register state, Register subkeyH,\n+  void ghash_processBlocks_wide(Label& p, Register state, Register subkeyH,\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-void MacroAssembler::ghash_processBlocks_wide(address field_polynomial, Register state,\n+void MacroAssembler::ghash_processBlocks_wide(Label& field_polynomial, Register state,\n@@ -534,1 +534,4 @@\n-  ldrq(p, field_polynomial);    \/\/ The field polynomial\n+  \/\/ load polynomial via label which must identify local data in the\n+  \/\/ same code stub\n+  adr(rscratch1, field_polynomial);\n+  ldrq(p, rscratch1);    \/\/ The field polynomial\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_aes.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -821,1 +821,1 @@\n-  void generate_copy_longs(StubId stub_id, DecoratorSet decorators, Label &start, Register s, Register d, Register count) {\n+  address generate_copy_longs(StubId stub_id, DecoratorSet decorators, Register s, Register d, Register count) {\n@@ -873,1 +873,1 @@\n-    __ bind(start);\n+    address start = __ pc();\n@@ -913,3 +913,3 @@\n-       use_stride = prefetch > 256;\n-       prefetch = -prefetch;\n-       if (use_stride) __ mov(stride, prefetch);\n+      use_stride = prefetch > 256;\n+      prefetch = -prefetch;\n+      if (use_stride) __ mov(stride, prefetch);\n@@ -1045,3 +1045,3 @@\n-         use_stride = prefetch > 256;\n-         prefetch = -prefetch;\n-         if (use_stride) __ mov(stride, prefetch);\n+        use_stride = prefetch > 256;\n+        prefetch = -prefetch;\n+        if (use_stride) __ mov(stride, prefetch);\n@@ -1056,9 +1056,9 @@\n-       \/\/ allowing for the offset of -8 the store instructions place\n-       \/\/ registers into the target 64 bit block at the following\n-       \/\/ offsets\n-       \/\/\n-       \/\/ t0 at offset 0\n-       \/\/ t1 at offset 8,  t2 at offset 16\n-       \/\/ t3 at offset 24, t4 at offset 32\n-       \/\/ t5 at offset 40, t6 at offset 48\n-       \/\/ t7 at offset 56\n+        \/\/ allowing for the offset of -8 the store instructions place\n+        \/\/ registers into the target 64 bit block at the following\n+        \/\/ offsets\n+        \/\/\n+        \/\/ t0 at offset 0\n+        \/\/ t1 at offset 8,  t2 at offset 16\n+        \/\/ t3 at offset 24, t4 at offset 32\n+        \/\/ t5 at offset 40, t6 at offset 48\n+        \/\/ t7 at offset 56\n@@ -1076,12 +1076,12 @@\n-       \/\/ d was not offset when we started so the registers are\n-       \/\/ written into the 64 bit block preceding d with the following\n-       \/\/ offsets\n-       \/\/\n-       \/\/ t1 at offset -8\n-       \/\/ t3 at offset -24, t0 at offset -16\n-       \/\/ t5 at offset -48, t2 at offset -32\n-       \/\/ t7 at offset -56, t4 at offset -48\n-       \/\/                   t6 at offset -64\n-       \/\/\n-       \/\/ note that this matches the offsets previously noted for the\n-       \/\/ loads\n+        \/\/ d was not offset when we started so the registers are\n+        \/\/ written into the 64 bit block preceding d with the following\n+        \/\/ offsets\n+        \/\/\n+        \/\/ t1 at offset -8\n+        \/\/ t3 at offset -24, t0 at offset -16\n+        \/\/ t5 at offset -48, t2 at offset -32\n+        \/\/ t7 at offset -56, t4 at offset -48\n+        \/\/                   t6 at offset -64\n+        \/\/\n+        \/\/ note that this matches the offsets previously noted for the\n+        \/\/ loads\n@@ -1128,4 +1128,4 @@\n-       \/\/ this is the same as above but copying only 4 longs hence\n-       \/\/ with only one intervening stp between the str instructions\n-       \/\/ but note that the offsets and registers still follow the\n-       \/\/ same pattern\n+        \/\/ this is the same as above but copying only 4 longs hence\n+        \/\/ with only one intervening stp between the str instructions\n+        \/\/ but note that the offsets and registers still follow the\n+        \/\/ same pattern\n@@ -1146,4 +1146,4 @@\n-       \/\/ this is the same as above but copying only 2 longs hence\n-       \/\/ there is no intervening stp between the str instructions\n-       \/\/ but note that the offset and register patterns are still\n-       \/\/ the same\n+        \/\/ this is the same as above but copying only 2 longs hence\n+        \/\/ there is no intervening stp between the str instructions\n+        \/\/ but note that the offset and register patterns are still\n+        \/\/ the same\n@@ -1160,2 +1160,2 @@\n-       \/\/ for forwards copy we need to re-adjust the offsets we\n-       \/\/ applied so that s and d are follow the last words written\n+        \/\/ for forwards copy we need to re-adjust the offsets we\n+        \/\/ applied so that s and d are follow the last words written\n@@ -1163,4 +1163,4 @@\n-       if (direction == copy_forwards) {\n-         __ add(s, s, 16);\n-         __ add(d, d, 8);\n-       }\n+        if (direction == copy_forwards) {\n+          __ add(s, s, 16);\n+          __ add(d, d, 8);\n+        }\n@@ -1171,1 +1171,3 @@\n-      }\n+    }\n+\n+    return start;\n@@ -1225,4 +1227,0 @@\n-  Label copy_f, copy_b;\n-  Label copy_obj_f, copy_obj_b;\n-  Label copy_obj_uninit_f, copy_obj_uninit_b;\n-\n@@ -1466,1 +1464,1 @@\n-        __ bl(copy_f);\n+        __ bl(StubRoutines::aarch64::copy_byte_f());\n@@ -1468,1 +1466,1 @@\n-        __ bl(copy_obj_uninit_f);\n+        __ bl(StubRoutines::aarch64::copy_oop_uninit_f());\n@@ -1470,1 +1468,1 @@\n-        __ bl(copy_obj_f);\n+        __ bl(StubRoutines::aarch64::copy_oop_f());\n@@ -1474,1 +1472,1 @@\n-        __ bl(copy_b);\n+        __ bl(StubRoutines::aarch64::copy_byte_b());\n@@ -1476,1 +1474,1 @@\n-        __ bl(copy_obj_uninit_b);\n+        __ bl(StubRoutines::aarch64::copy_oop_uninit_b());\n@@ -1478,1 +1476,1 @@\n-        __ bl(copy_obj_b);\n+        __ bl(StubRoutines::aarch64::copy_oop_b());\n@@ -1541,3 +1539,3 @@\n-  \/\/ Side Effects: entry is set to the (post push) entry point so it\n-  \/\/               can be used by the corresponding conjoint copy\n-  \/\/               method\n+  \/\/ Side Effects: nopush_entry is set to the (post push) entry point\n+  \/\/               so it can be used by the corresponding conjoint\n+  \/\/               copy method\n@@ -1545,1 +1543,1 @@\n-  address generate_disjoint_copy(StubId stub_id, address *entry) {\n+  address generate_disjoint_copy(StubId stub_id, address *nopush_entry) {\n@@ -1634,2 +1632,2 @@\n-    if (entry != nullptr) {\n-      *entry = __ pc();\n+    if (nopush_entry != nullptr) {\n+      *nopush_entry = __ pc();\n@@ -1698,2 +1696,2 @@\n-  \/\/   entry is set to the no-overlap entry point so it can be used by\n-  \/\/   some other conjoint copy method\n+  \/\/   nopush_entry is set to the no-overlap entry point so it can be\n+  \/\/   used by some other conjoint copy method\n@@ -1701,1 +1699,1 @@\n-  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *entry) {\n+  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *nopush_entry) {\n@@ -1788,2 +1786,2 @@\n-    if (entry != nullptr) {\n-      *entry = __ pc();\n+    if (nopush_entry != nullptr) {\n+      *nopush_entry = __ pc();\n@@ -1795,0 +1793,1 @@\n+    Label L_overlapping;\n@@ -1797,1 +1796,3 @@\n-    __ br(Assembler::HS, nooverlap_target);\n+    __ br(Assembler::LO, L_overlapping);\n+    __ b(RuntimeAddress(nooverlap_target));\n+    __ bind(L_overlapping);\n@@ -1869,1 +1870,1 @@\n-  address generate_checkcast_copy(StubId stub_id, address *entry) {\n+  address generate_checkcast_copy(StubId stub_id, address *nopush_entry) {\n@@ -1930,2 +1931,2 @@\n-    if (entry != nullptr) {\n-      *entry = __ pc();\n+    if (nopush_entry != nullptr) {\n+      *nopush_entry = __ pc();\n@@ -2749,7 +2750,15 @@\n-    address entry;\n-    address entry_jbyte_arraycopy;\n-    address entry_jshort_arraycopy;\n-    address entry_jint_arraycopy;\n-    address entry_oop_arraycopy;\n-    address entry_jlong_arraycopy;\n-    address entry_checkcast_arraycopy;\n+    \/\/ Some copy stubs publish a normal entry and then a 2nd 'fallback'\n+    \/\/ entry immediately following their stack push. This can be used\n+    \/\/ as a post-push branch target for compatible stubs when they\n+    \/\/ identify a special case that can be handled by the fallback\n+    \/\/ stub e.g a disjoint copy stub may be use as a special case\n+    \/\/ fallback for its compatible conjoint copy stub.\n+    \/\/\n+    \/\/ A no push entry is always returned in the following local and\n+    \/\/ then published by assigning to the appropriate entry field in\n+    \/\/ class StubRoutines. The entry value is then passed to the\n+    \/\/ generator for the compatible stub. That means the entry must be\n+    \/\/ listed when saving to\/restoring from the AOT cache, ensuring\n+    \/\/ that the inter-stub jumps are noted at AOT-cache save and\n+    \/\/ relocated at AOT cache load.\n+    address nopush_entry;\n@@ -2763,2 +2772,4 @@\n-    generate_copy_longs(StubId::stubgen_copy_byte_f_id, IN_HEAP | IS_ARRAY, copy_f, r0, r1, r15);\n-    generate_copy_longs(StubId::stubgen_copy_byte_b_id, IN_HEAP | IS_ARRAY, copy_b, r0, r1, r15);\n+    \/\/ generate and publish arch64-specific bulk copy routines first\n+    \/\/ so we can call them from other copy stubs\n+    StubRoutines::aarch64::_copy_byte_f = generate_copy_longs(StubId::stubgen_copy_byte_f_id, IN_HEAP | IS_ARRAY, r0, r1, r15);\n+    StubRoutines::aarch64::_copy_byte_b = generate_copy_longs(StubId::stubgen_copy_byte_b_id, IN_HEAP | IS_ARRAY, r0, r1, r15);\n@@ -2766,2 +2777,2 @@\n-    generate_copy_longs(StubId::stubgen_copy_oop_f_id, IN_HEAP | IS_ARRAY, copy_obj_f, r0, r1, r15);\n-    generate_copy_longs(StubId::stubgen_copy_oop_b_id, IN_HEAP | IS_ARRAY, copy_obj_b, r0, r1, r15);\n+    StubRoutines::aarch64::_copy_oop_f = generate_copy_longs(StubId::stubgen_copy_oop_f_id, IN_HEAP | IS_ARRAY, r0, r1, r15);\n+    StubRoutines::aarch64::_copy_oop_b = generate_copy_longs(StubId::stubgen_copy_oop_b_id, IN_HEAP | IS_ARRAY, r0, r1, r15);\n@@ -2769,2 +2780,2 @@\n-    generate_copy_longs(StubId::stubgen_copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_f, r0, r1, r15);\n-    generate_copy_longs(StubId::stubgen_copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, copy_obj_uninit_b, r0, r1, r15);\n+    StubRoutines::aarch64::_copy_oop_uninit_f = generate_copy_longs(StubId::stubgen_copy_oop_uninit_f_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, r0, r1, r15);\n+    StubRoutines::aarch64::_copy_oop_uninit_b = generate_copy_longs(StubId::stubgen_copy_oop_uninit_b_id, IN_HEAP | IS_ARRAY | IS_DEST_UNINITIALIZED, r0, r1, r15);\n@@ -2776,4 +2787,10 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jbyte_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_jbyte_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_jbyte_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_jbyte_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_arrayof_jbyte_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy_nopush, nullptr);\n@@ -2783,4 +2800,10 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_jshort_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is used by generic\/unsafe copy\n+    StubRoutines::_jshort_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy_nopush, nullptr);\n@@ -2790,2 +2813,4 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jint_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy_nopush, nullptr);\n@@ -2793,3 +2818,7 @@\n-    \/\/ entry_jint_arraycopy always points to the unaligned version\n-    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    \/\/ jint_arraycopy_nopush always points to the unaligned version\n+    StubRoutines::_jint_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_jint_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_jint_arraycopy_nopush = nopush_entry;\n@@ -2799,2 +2828,8 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, StubRoutines::_arrayof_jlong_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_jlong_arraycopy_nopush = nopush_entry;\n+    \/\/ disjoint normal\/nopush and conjoint normal entries are not\n+    \/\/ generated since the arrayof versions are the same\n@@ -2802,0 +2837,1 @@\n+    StubRoutines::_jlong_disjoint_arraycopy_nopush = StubRoutines::_arrayof_jlong_disjoint_arraycopy_nopush;\n@@ -2806,4 +2842,0 @@\n-      \/\/ With compressed oops we need unaligned versions; notice that\n-      \/\/ we overwrite entry_oop_arraycopy.\n-      bool aligned = !UseCompressedOops;\n-\n@@ -2811,1 +2843,3 @@\n-        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &entry);\n+        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &nopush_entry);\n+      \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+      StubRoutines::_arrayof_oop_disjoint_arraycopy_nopush = nopush_entry;\n@@ -2813,1 +2847,3 @@\n-        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy_nopush, &nopush_entry);\n+      \/\/ conjoint arrayof nopush entry is needed by generic\/unsafe copy\n+      StubRoutines::_oop_arraycopy_nopush = nopush_entry;\n@@ -2816,1 +2852,5 @@\n-        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+        = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &nopush_entry);\n+      \/\/ disjoint arrayof+uninit nopush entry is needed by conjoint copy\n+      StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit_nopush = nopush_entry;\n+      \/\/ note that we don't need a returned nopush entry because the\n+      \/\/ generic\/unsafe copy does not cater for uninit arrays.\n@@ -2818,1 +2858,1 @@\n-        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n+        = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit_nopush, nullptr);\n@@ -2821,0 +2861,1 @@\n+    \/\/ for oop copies reuse arrayof entries for non-arrayof cases\n@@ -2822,0 +2863,1 @@\n+    StubRoutines::_oop_disjoint_arraycopy_nopush = StubRoutines::_arrayof_oop_disjoint_arraycopy_nopush;\n@@ -2824,0 +2866,1 @@\n+    StubRoutines::_oop_disjoint_arraycopy_uninit_nopush = StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit_nopush;\n@@ -2826,1 +2869,5 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &nopush_entry);\n+    \/\/ checkcast nopush entry is needed by generic copy\n+    StubRoutines::_checkcast_arraycopy_nopush = nopush_entry;\n+    \/\/ note that we don't need a returned nopush entry because the\n+    \/\/ generic copy does not cater for uninit arrays.\n@@ -2829,4 +2876,5 @@\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n-                                                              entry_jshort_arraycopy,\n-                                                              entry_jint_arraycopy,\n-                                                              entry_jlong_arraycopy);\n+    \/\/ unsafe arraycopy may fallback on conjoint stubs\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(StubRoutines::_jbyte_arraycopy_nopush,\n+                                                              StubRoutines::_jshort_arraycopy_nopush,\n+                                                              StubRoutines::_jint_arraycopy_nopush,\n+                                                              StubRoutines::_jlong_arraycopy_nopush);\n@@ -2834,6 +2882,7 @@\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n-                                                               entry_jshort_arraycopy,\n-                                                               entry_jint_arraycopy,\n-                                                               entry_oop_arraycopy,\n-                                                               entry_jlong_arraycopy,\n-                                                               entry_checkcast_arraycopy);\n+    \/\/ generic arraycopy may fallback on conjoint stubs\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy(StubRoutines::_jbyte_arraycopy_nopush,\n+                                                               StubRoutines::_jshort_arraycopy_nopush,\n+                                                               StubRoutines::_jint_arraycopy_nopush,\n+                                                               StubRoutines::_oop_arraycopy_nopush,\n+                                                               StubRoutines::_jlong_arraycopy_nopush,\n+                                                               StubRoutines::_checkcast_arraycopy_nopush);\n@@ -3427,6 +3476,1 @@\n-    address ghash_polynomial = __ pc();\n-    __ emit_int64(0x87);  \/\/ The low-order bits of the field\n-                          \/\/ polynomial (i.e. p = z^7+z^2+z+1)\n-                          \/\/ repeated in the low and high parts of a\n-                          \/\/ 128-bit vector\n-    __ emit_int64(0x87);\n+    Label ghash_polynomial; \/\/ local data generated after code\n@@ -3434,1 +3478,1 @@\n-    __ align(CodeEntryAlignment);\n+   __ align(CodeEntryAlignment);\n@@ -3539,1 +3583,11 @@\n-     return start;\n+\n+    \/\/ bind label and generate polynomial data\n+    __ align(wordSize * 2);\n+    __ bind(ghash_polynomial);\n+    __ emit_int64(0x87);  \/\/ The low-order bits of the field\n+                          \/\/ polynomial (i.e. p = z^7+z^2+z+1)\n+                          \/\/ repeated in the low and high parts of a\n+                          \/\/ 128-bit vector\n+    __ emit_int64(0x87);\n+\n+    return start;\n@@ -4584,10 +4638,0 @@\n-    \/\/ The constant data is broken into two 128-bit segments to be loaded\n-    \/\/ onto FloatRegisters.  The first 128 bits are a counter add overlay\n-    \/\/ that adds +0\/+1\/+2\/+3 to the vector holding replicated state[12].\n-    \/\/ The second 128-bits is a table constant used for 8-bit left rotations.\n-    __ BIND(L_cc20_const);\n-    __ emit_int64(0x0000000100000000UL);\n-    __ emit_int64(0x0000000300000002UL);\n-    __ emit_int64(0x0605040702010003UL);\n-    __ emit_int64(0x0E0D0C0F0A09080BUL);\n-\n@@ -4741,0 +4785,11 @@\n+    \/\/ bind label and generate local constant data used by this stub\n+    \/\/ The constant data is broken into two 128-bit segments to be loaded\n+    \/\/ onto FloatRegisters.  The first 128 bits are a counter add overlay\n+    \/\/ that adds +0\/+1\/+2\/+3 to the vector holding replicated state[12].\n+    \/\/ The second 128-bits is a table constant used for 8-bit left rotations.\n+    __ BIND(L_cc20_const);\n+    __ emit_int64(0x0000000100000000UL);\n+    __ emit_int64(0x0000000300000002UL);\n+    __ emit_int64(0x0605040702010003UL);\n+    __ emit_int64(0x0E0D0C0F0A09080BUL);\n+\n@@ -6061,4 +6116,0 @@\n-    __ BIND(L_F00);\n-    __ emit_int64(0x0f000f000f000f00);\n-    __ emit_int64(0x0f000f000f000f00);\n-\n@@ -6258,0 +6309,5 @@\n+    \/\/ bind label and generate constant data used by this stub\n+    __ BIND(L_F00);\n+    __ emit_int64(0x0f000f000f000f00);\n+    __ emit_int64(0x0f000f000f000f00);\n+\n@@ -9667,8 +9723,1 @@\n-    __ align(wordSize * 2);\n-    address p = __ pc();\n-    __ emit_int64(0x87);  \/\/ The low-order bits of the field\n-                          \/\/ polynomial (i.e. p = z^7+z^2+z+1)\n-                          \/\/ repeated in the low and high parts of a\n-                          \/\/ 128-bit vector\n-    __ emit_int64(0x87);\n-\n+    Label polynomial; \/\/ local data generated at end of stub\n@@ -9686,1 +9735,2 @@\n-    __ ldrq(v24, p);    \/\/ The field polynomial\n+    __ adr(rscratch1, polynomial);\n+    __ ldrq(v24, rscratch1);    \/\/ The field polynomial\n@@ -9726,0 +9776,9 @@\n+    \/\/ bind label and generate local polynomial data\n+    __ align(wordSize * 2);\n+    __ bind(polynomial);\n+    __ emit_int64(0x87);  \/\/ The low-order bits of the field\n+                          \/\/ polynomial (i.e. p = z^7+z^2+z+1)\n+                          \/\/ repeated in the low and high parts of a\n+                          \/\/ 128-bit vector\n+    __ emit_int64(0x87);\n+\n@@ -9734,8 +9793,1 @@\n-    __ align(wordSize * 2);\n-    address p = __ pc();\n-    __ emit_int64(0x87);  \/\/ The low-order bits of the field\n-                          \/\/ polynomial (i.e. p = z^7+z^2+z+1)\n-                          \/\/ repeated in the low and high parts of a\n-                          \/\/ 128-bit vector\n-    __ emit_int64(0x87);\n-\n+    Label polynomial;           \/\/ local data generated after stub\n@@ -9763,1 +9815,1 @@\n-    __ ghash_processBlocks_wide(p, state, subkeyH, data, blocks, unroll);\n+    __ ghash_processBlocks_wide(polynomial, state, subkeyH, data, blocks, unroll);\n@@ -9776,0 +9828,9 @@\n+    \/\/ bind label and generate polynomial data\n+    __ align(wordSize * 2);\n+    __ bind(polynomial);\n+    __ emit_int64(0x87);  \/\/ The low-order bits of the field\n+                          \/\/ polynomial (i.e. p = z^7+z^2+z+1)\n+                          \/\/ repeated in the low and high parts of a\n+                          \/\/ 128-bit vector\n+    __ emit_int64(0x87);\n+\n@@ -9777,0 +9838,1 @@\n+\n@@ -10290,1 +10352,1 @@\n-  \/\/ ARMv8.1 LSE versions of the atomic stubs used by Atomic::PlatformXX.\n+  \/\/ ARMv8.1 LSE versions of the atomic stubs used by AtomicAccess::PlatformXX.\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":220,"deletions":158,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    return Atomic::load_acquire(guard_addr());\n+    return AtomicAccess::load_acquire(guard_addr());\n@@ -56,1 +56,1 @@\n-      Atomic::release_store(guard_addr(), value);\n+      AtomicAccess::release_store(guard_addr(), value);\n@@ -61,1 +61,1 @@\n-    int old_value = Atomic::load(guard_addr());\n+    int old_value = AtomicAccess::load(guard_addr());\n@@ -66,1 +66,1 @@\n-      int v = Atomic::cmpxchg(guard_addr(), old_value, new_value, memory_order_release);\n+      int v = AtomicAccess::cmpxchg(guard_addr(), old_value, new_value, memory_order_release);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetNMethod_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -424,1 +424,2 @@\n- \/\/ As per atomic.hpp the Atomic read-modify-write operations must be logically implemented as:\n+ \/\/ As per atomicAccess.hpp the atomic read-modify-write operations must be\n+ \/\/ logically implemented as:\n@@ -443,1 +444,1 @@\n-  \/\/ used by Atomic::add(volatile jint* dest, jint add_value)\n+  \/\/ used by AtomicAccess::add(volatile jint* dest, jint add_value)\n@@ -495,1 +496,1 @@\n-  \/\/ used by Atomic::add(volatile jint* dest, jint exchange_value)\n+  \/\/ used by AtomicAccess::add(volatile jint* dest, jint exchange_value)\n@@ -545,1 +546,1 @@\n-  \/\/ used by Atomic::cmpxchg(volatile jint *dest, jint compare_value, jint exchange_value)\n+  \/\/ used by AtomicAccess::cmpxchg(volatile jint *dest, jint compare_value, jint exchange_value)\n@@ -585,1 +586,1 @@\n-  \/\/ Support for jlong Atomic::cmpxchg(jlong exchange_value, volatile jlong *dest, jlong compare_value)\n+  \/\/ Support for jlong AtomicAccess::cmpxchg(jlong exchange_value, volatile jlong *dest, jlong compare_value)\n@@ -3013,0 +3014,4 @@\n+    \/\/ Note:   chaining of stubs does not rely on branching to an\n+    \/\/         auxiliary post-push entry because none of the stubs\n+    \/\/         push\/pop a frame.\n+\n@@ -3026,0 +3031,1 @@\n+    \/\/ disjoint copy entry is needed by conjoint copy\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/assembler.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    new_mov_instr.u64 = old_mov_instr.u64 = Atomic::load(instr);\n+    new_mov_instr.u64 = old_mov_instr.u64 = AtomicAccess::load(instr);\n@@ -84,1 +84,1 @@\n-      uint64_t v = Atomic::cmpxchg(instr, old_mov_instr.u64, new_mov_instr.u64, memory_order_relaxed);\n+      uint64_t v = AtomicAccess::cmpxchg(instr, old_mov_instr.u64, new_mov_instr.u64, memory_order_relaxed);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-  \/\/Atomic::release_store(jump_addr, *((juint*)code_buffer));\n+  \/\/AtomicAccess::release_store(jump_addr, *((juint*)code_buffer));\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3280,2 +3280,6 @@\n-    \/\/ Note: the disjoint stubs must be generated first, some of\n-    \/\/ the conjoint stubs use them.\n+    \/\/ Note: the disjoint stubs must be generated first, some of the\n+    \/\/       conjoint stubs use them.\n+\n+    \/\/ Note: chaining of stubs does not rely on branching to an\n+    \/\/       auxiliary post-push entry because none of the stubs\n+    \/\/       push\/pop a frame.\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -915,0 +915,26 @@\n+ public:\n+\n+  static uint32_t encode_jal(Register Rd, const int32_t offset) {\n+    guarantee(is_simm21(offset) && ((offset % 2) == 0), \"offset is invalid.\");\n+    uint32_t insn = 0;\n+    patch((address)&insn, 6, 0, 0b1101111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 19, 12, (uint32_t)((offset >> 12) & 0xff));\n+    patch((address)&insn, 20, (uint32_t)((offset >> 11) & 0x1));\n+    patch((address)&insn, 30, 21, (uint32_t)((offset >> 1) & 0x3ff));\n+    patch((address)&insn, 31, (uint32_t)((offset >> 20) & 0x1));\n+    return insn;\n+  }\n+\n+  static uint32_t encode_jalr(Register Rd, Register Rs, const int32_t offset) {\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    uint32_t insn = 0;\n+    patch((address)&insn, 6, 0, 0b1100111);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch((address)&insn, 14, 12, 0b000);\n+    patch_reg((address)&insn, 15, Rs);\n+    int32_t val = offset & 0xfff;\n+    patch((address)&insn, 31, 20, val);\n+    return insn;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/assembler.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  Atomic::inc(&_patching_epoch);\n+  AtomicAccess::inc(&_patching_epoch);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-    return Atomic::load_acquire(guard_addr());\n+    return AtomicAccess::load_acquire(guard_addr());\n@@ -114,1 +114,1 @@\n-      Atomic::release_store(guard_addr(), value);\n+      AtomicAccess::release_store(guard_addr(), value);\n@@ -119,1 +119,1 @@\n-    int old_value = Atomic::load(guard_addr());\n+    int old_value = AtomicAccess::load(guard_addr());\n@@ -124,1 +124,1 @@\n-      int v = Atomic::cmpxchg(guard_addr(), old_value, new_value, memory_order_release);\n+      int v = AtomicAccess::cmpxchg(guard_addr(), old_value, new_value, memory_order_release);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5874,1 +5874,1 @@\n-\/\/ you want to use it elsewhere, note that cnt must be >= CacheLineSize.\n+\/\/ you want to use it elsewhere, note that cnt must be >= zicboz_block_size.\n@@ -5876,0 +5876,1 @@\n+  int zicboz_block_size = VM_Version::zicboz_block_size.value();\n@@ -5880,1 +5881,1 @@\n-  andi(tmp1, tmp1, CacheLineSize - 1);\n+  andi(tmp1, tmp1, zicboz_block_size - 1);\n@@ -5890,1 +5891,1 @@\n-  for (int i = -CacheLineSize + wordSize; i < 0; i += wordSize) {\n+  for (int i = -zicboz_block_size + wordSize; i < 0; i += wordSize) {\n@@ -5895,1 +5896,1 @@\n-  mv(tmp1, CacheLineSize \/ wordSize);\n+  mv(tmp1, zicboz_block_size \/ wordSize);\n@@ -5899,1 +5900,1 @@\n-  addi(base, base, CacheLineSize);\n+  addi(base, base, zicboz_block_size);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -55,1 +57,1 @@\n-  address destination = MacroAssembler::target_addr_for_insn(addr);\n+  address stub_addr = MacroAssembler::target_addr_for_insn(addr);\n@@ -60,4 +62,4 @@\n-  assert(nm != nullptr, \"Sanity\");\n-  assert(nm->stub_contains(destination), \"Sanity\");\n-  assert(destination != nullptr, \"Sanity\");\n-  return stub_address_destination_at(destination);\n+  assert(nm->stub_contains(stub_addr), \"Sanity\");\n+  assert(stub_addr != nullptr, \"Sanity\");\n+\n+  return stub_address_destination_at(stub_addr);\n@@ -92,0 +94,24 @@\n+void NativeCall::optimize_call(address dest, bool mt_safe) {\n+  \/\/ Skip over auipc + ld\n+  address jmp_ins_pc = instruction_address() + 2 * NativeInstruction::instruction_size;\n+  \/\/ Rutime calls may be unaligned, but they are never changed after relocation.\n+  assert(!mt_safe || is_aligned(jmp_ins_pc, NativeInstruction::instruction_size), \"Must be naturally aligned: %p\", jmp_ins_pc);\n+  \/\/ If reachable use JAL\n+  if (Assembler::reachable_from_branch_at(jmp_ins_pc, dest)) {\n+    int64_t distance = dest - jmp_ins_pc;\n+    uint32_t new_jal = Assembler::encode_jal(ra, distance);\n+    AtomicAccess::store((uint32_t *)jmp_ins_pc, new_jal);\n+  } else if (!MacroAssembler::is_jalr_at(jmp_ins_pc)) { \/\/ The jalr is always identical: jalr ra, 0(t1)\n+    uint32_t new_jalr = Assembler::encode_jalr(ra, t1, 0);\n+    AtomicAccess::store((uint32_t *)jmp_ins_pc, new_jalr);\n+  } else {\n+    \/\/ No change to instruction stream\n+    return;\n+  }\n+  \/\/ We changed instruction stream\n+  if (mt_safe) {\n+    \/\/ IC invalidate provides a leading full fence, it thus happens after we changed the instruction stream.\n+    ICache::invalidate_range(jmp_ins_pc, NativeInstruction::instruction_size);\n+  }\n+}\n+\n@@ -99,4 +125,5 @@\n-  if (stub_addr != nullptr) {\n-    set_stub_address_destination_at(stub_addr, dest);\n-    return true;\n-  }\n+  assert(stub_addr != nullptr, \"No stub?\");\n+  set_stub_address_destination_at(stub_addr, dest); \/\/ release\n+  \/\/ optimize_call happens after we stored new address in addr stub.\n+  \/\/ patches jalr -> jal\/jal -> jalr depending on dest\n+  optimize_call(dest, true);\n@@ -104,1 +131,1 @@\n-  return false;\n+  return true;\n@@ -107,1 +134,2 @@\n-bool NativeCall::reloc_set_destination(address dest) {\n+\/\/ The argument passed in is the address to the stub containing the destination\n+bool NativeCall::reloc_set_destination(address stub_addr) {\n@@ -116,4 +144,6 @@\n-    assert(dest != nullptr, \"Sanity\");\n-    assert(dest == trampoline_stub_Relocation::get_trampoline_for(call_addr,\n-                                                          code->as_nmethod()), \"Sanity\");\n-    MacroAssembler::pd_patch_instruction_size(call_addr, dest);\n+    assert(stub_addr != nullptr, \"Sanity\");\n+    assert(stub_addr == trampoline_stub_Relocation::get_trampoline_for(call_addr, code->as_nmethod()), \"Sanity\");\n+    MacroAssembler::pd_patch_instruction_size(call_addr, stub_addr); \/\/ patches auipc + ld to stub_addr\n+\n+    address dest = stub_address_destination_at(stub_addr);\n+    optimize_call(dest, false); \/\/ patches jalr -> jal\/jal -> jalr depending on dest\n@@ -145,3 +175,3 @@\n-  address dest = MacroAssembler::target_addr_for_insn(call_addr);\n-  assert(code->contains(dest), \"Sanity\");\n-  return dest;\n+  address stub_addr = MacroAssembler::target_addr_for_insn(call_addr);\n+  assert(code->contains(stub_addr), \"Sanity\");\n+  return stub_addr;\n@@ -163,0 +193,9 @@\n+  if (MacroAssembler::is_auipc_at(addr) &&\n+      MacroAssembler::is_ld_at(addr + instr_size) &&\n+      MacroAssembler::is_jal_at(addr + 2 * instr_size) &&\n+      (MacroAssembler::extract_rd(addr)                    == x6) &&\n+      (MacroAssembler::extract_rd(addr + instr_size)       == x6) &&\n+      (MacroAssembler::extract_rs1(addr + instr_size)      == x6) &&\n+      (MacroAssembler::extract_rd(addr + 2 * instr_size)   == x1)) {\n+    return true;\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":57,"deletions":18,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -159,0 +159,4 @@\n+  \/\/ We either have a jalr or jal depending on distance to old destination.\n+  \/\/ This method emits a new jal if new destination is within jal reach.\n+  \/\/ Otherwise restores the jalr which can reach any destination.\n+  void optimize_call(address dest, bool mt_safe = true);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -686,2 +686,3 @@\n-      \/\/ Ensure count >= 2*CacheLineSize so that it still deserves a cbo.zero\n-      \/\/ after alignment.\n+      int zicboz_block_size = VM_Version::zicboz_block_size.value();\n+      \/\/ Ensure count >= 2 * zicboz_block_size so that it still deserves\n+      \/\/ a cbo.zero after alignment.\n@@ -689,1 +690,1 @@\n-      int low_limit = MAX2(2 * CacheLineSize, BlockZeroingLowLimit) \/ wordSize;\n+      int low_limit = MAX2(2 * zicboz_block_size, (int)BlockZeroingLowLimit) \/ wordSize;\n@@ -734,2 +735,1 @@\n-  void generate_copy_longs(StubId stub_id, Label &start,\n-                           Register s, Register d, Register count) {\n+  address generate_copy_longs(StubId stub_id, Register s, Register d, Register count) {\n@@ -765,1 +765,1 @@\n-    __ bind(start);\n+    address start = __ pc();\n@@ -881,1 +881,0 @@\n-  }\n@@ -883,1 +882,2 @@\n-  Label copy_f, copy_b;\n+    return start;\n+  }\n@@ -1101,2 +1101,2 @@\n-  \/\/   entry - is assigned to the stub's post push entry point unless\n-  \/\/           it is null\n+  \/\/   nopush_entry - is assigned to the stub's post push entry point\n+  \/\/                  unless it is null\n@@ -1113,3 +1113,3 @@\n-  \/\/ Side Effects: entry is set to the (post push) entry point so it\n-  \/\/               can be used by the corresponding conjoint copy\n-  \/\/               method\n+  \/\/ Side Effects: nopush_entry is set to the (post push) entry point\n+  \/\/               so it can be used by the corresponding conjoint\n+  \/\/               copy method\n@@ -1117,1 +1117,1 @@\n-  address generate_disjoint_copy(StubId stub_id, address* entry) {\n+  address generate_disjoint_copy(StubId stub_id, address* nopush_entry) {\n@@ -1206,2 +1206,2 @@\n-    if (entry != nullptr) {\n-      *entry = __ pc();\n+    if (nopush_entry != nullptr) {\n+     *nopush_entry = __ pc();\n@@ -1258,2 +1258,2 @@\n-  \/\/   entry - is assigned to the stub's post push entry point unless\n-  \/\/           it is null\n+  \/\/   nopush_entry - is assigned to the stub's post push entry point\n+  \/\/                 unless it is null\n@@ -1271,2 +1271,2 @@\n-  \/\/   entry is set to the no-overlap entry point so it can be used by\n-  \/\/   some other conjoint copy method\n+  \/\/   nopush_entry is set to the no-overlap entry point so it can be\n+  \/\/   used by some other conjoint copy method\n@@ -1274,1 +1274,1 @@\n-  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *entry) {\n+  address generate_conjoint_copy(StubId stub_id, address nooverlap_target, address *nopush_entry) {\n@@ -1361,2 +1361,2 @@\n-    if (entry != nullptr) {\n-      *entry = __ pc();\n+    if (nopush_entry != nullptr) {\n+      *nopush_entry = __ pc();\n@@ -1372,1 +1372,1 @@\n-    __ j(nooverlap_target);\n+    __ j(RuntimeAddress(nooverlap_target));\n@@ -1447,1 +1447,1 @@\n-  address generate_checkcast_copy(StubId stub_id, address* entry) {\n+  address generate_checkcast_copy(StubId stub_id, address* nopush_entry) {\n@@ -1498,2 +1498,2 @@\n-    if (entry != nullptr) {\n-      *entry = __ pc();\n+    if (nopush_entry != nullptr) {\n+      *nopush_entry = __ pc();\n@@ -2296,7 +2296,15 @@\n-    address entry                     = nullptr;\n-    address entry_jbyte_arraycopy     = nullptr;\n-    address entry_jshort_arraycopy    = nullptr;\n-    address entry_jint_arraycopy      = nullptr;\n-    address entry_oop_arraycopy       = nullptr;\n-    address entry_jlong_arraycopy     = nullptr;\n-    address entry_checkcast_arraycopy = nullptr;\n+    \/\/ Some copy stubs publish a normal entry and then a 2nd 'fallback'\n+    \/\/ entry immediately following their stack push. This can be used\n+    \/\/ as a post-push branch target for compatible stubs when they\n+    \/\/ identify a special case that can be handled by the fallback\n+    \/\/ stub e.g a disjoint copy stub may be use as a special case\n+    \/\/ fallback for its compatible conjoint copy stub.\n+    \/\/\n+    \/\/ A no push entry is always returned in the following local and\n+    \/\/ then published by assigning to the appropriate entry field in\n+    \/\/ class StubRoutines. The entry value is then passed to the\n+    \/\/ generator for the compatible stub. That means the entry must be\n+    \/\/ listed when saving to\/restoring from the AOT cache, ensuring\n+    \/\/ that the inter-stub jumps are noted at AOT-cache save and\n+    \/\/ relocated at AOT cache load.\n+    address nopush_entry = nullptr;\n@@ -2310,2 +2318,4 @@\n-    generate_copy_longs(StubId::stubgen_copy_byte_f_id, copy_f, c_rarg0, c_rarg1, t1);\n-    generate_copy_longs(StubId::stubgen_copy_byte_b_id, copy_b, c_rarg0, c_rarg1, t1);\n+    \/\/ generate and publish riscv-specific bulk copy routines first\n+    \/\/ so we can call them from other copy stubs\n+    StubRoutines::riscv::_copy_byte_f = generate_copy_longs(StubId::stubgen_copy_byte_f_id, c_rarg0, c_rarg1, t1);\n+    StubRoutines::riscv::_copy_byte_b = generate_copy_longs(StubId::stubgen_copy_byte_b_id, c_rarg0, c_rarg1, t1);\n@@ -2317,4 +2327,10 @@\n-    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, entry, &entry_jbyte_arraycopy);\n-    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jbyte_disjoint_arraycopy          = generate_disjoint_copy(StubId::stubgen_jbyte_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_jbyte_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_jbyte_arraycopy                   = generate_conjoint_copy(StubId::stubgen_jbyte_arraycopy_id, StubRoutines::_jbyte_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_jbyte_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy  = generate_disjoint_copy(StubId::stubgen_arrayof_jbyte_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jbyte_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_arrayof_jbyte_arraycopy           = generate_conjoint_copy(StubId::stubgen_arrayof_jbyte_arraycopy_id, StubRoutines::_arrayof_jbyte_disjoint_arraycopy_nopush, nullptr);\n@@ -2324,4 +2340,10 @@\n-    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, entry, &entry_jshort_arraycopy);\n-    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, entry, nullptr);\n+    StubRoutines::_jshort_disjoint_arraycopy         = generate_disjoint_copy(StubId::stubgen_jshort_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_jshort_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_jshort_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jshort_arraycopy_id, StubRoutines::_jshort_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is used by generic\/unsafe copy\n+    StubRoutines::_jshort_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jshort_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jshort_disjoint_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jshort_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jshort_arraycopy_id, StubRoutines::_arrayof_jshort_disjoint_arraycopy_nopush, nullptr);\n@@ -2331,2 +2353,4 @@\n-    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy   = generate_disjoint_copy(StubId::stubgen_arrayof_jint_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jint_disjoint_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jint_arraycopy            = generate_conjoint_copy(StubId::stubgen_arrayof_jint_arraycopy_id, StubRoutines::_arrayof_jint_disjoint_arraycopy_nopush, nullptr);\n@@ -2335,2 +2359,6 @@\n-    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n+    StubRoutines::_jint_disjoint_arraycopy           = generate_disjoint_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_jint_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_jint_arraycopy                  = generate_conjoint_copy(StubId::stubgen_jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_jint_arraycopy_nopush = nopush_entry;\n@@ -2340,2 +2368,8 @@\n-    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy = generate_disjoint_copy(StubId::stubgen_arrayof_jlong_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_jlong_disjoint_arraycopy_nopush = nopush_entry;\n+    StubRoutines::_arrayof_jlong_arraycopy          = generate_conjoint_copy(StubId::stubgen_arrayof_jlong_arraycopy_id, StubRoutines::_arrayof_jlong_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_jlong_arraycopy_nopush = nopush_entry;\n+    \/\/ disjoint normal\/nopush and conjoint normal entries are not\n+    \/\/ generated since the arrayof versions are the same\n@@ -2343,0 +2377,1 @@\n+    StubRoutines::_jlong_disjoint_arraycopy_nopush = StubRoutines::_arrayof_jlong_disjoint_arraycopy_nopush;\n@@ -2347,1 +2382,3 @@\n-      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &entry);\n+      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_id, &nopush_entry);\n+      \/\/ disjoint arrayof nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_nopush = nopush_entry;\n@@ -2349,1 +2386,3 @@\n-      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n+      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_id, StubRoutines::_arrayof_oop_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint arrayof nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_oop_arraycopy_nopush = nopush_entry;\n@@ -2352,1 +2391,6 @@\n-      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &entry);\n+      = generate_disjoint_copy(StubId::stubgen_arrayof_oop_disjoint_arraycopy_uninit_id, &nopush_entry);\n+    \/\/ disjoint arrayof+uninit nopush entry is needed by conjoint copy\n+    StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit_nopush = nopush_entry;\n+\n+    \/\/ note that we don't need a returned nopush entry because the\n+    \/\/ generic\/unsafe copy does not cater for uninit arrays.\n@@ -2354,1 +2398,1 @@\n-      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, entry, nullptr);\n+      = generate_conjoint_copy(StubId::stubgen_arrayof_oop_arraycopy_uninit_id, StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit_nopush, nullptr);\n@@ -2356,0 +2400,1 @@\n+    \/\/ for oop copies reuse arrayof entries for non-arrayof cases\n@@ -2357,0 +2402,1 @@\n+    StubRoutines::_oop_disjoint_arraycopy_nopush = StubRoutines::_arrayof_oop_disjoint_arraycopy_nopush;\n@@ -2359,0 +2405,1 @@\n+    StubRoutines::_oop_disjoint_arraycopy_uninit_nopush = StubRoutines::_arrayof_oop_disjoint_arraycopy_uninit_nopush;\n@@ -2361,1 +2408,5 @@\n-    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+    StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &nopush_entry);\n+    \/\/ checkcast nopush entry is needed by generic copy\n+    StubRoutines::_checkcast_arraycopy_nopush = nopush_entry;\n+    \/\/ note that we don't need a returned nopush entry because the\n+    \/\/ generic copy does not cater for uninit arrays.\n@@ -2365,4 +2416,5 @@\n-    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n-                                                              entry_jshort_arraycopy,\n-                                                              entry_jint_arraycopy,\n-                                                              entry_jlong_arraycopy);\n+    \/\/ unsafe arraycopy may fallback on conjoint stubs\n+    StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(StubRoutines::_jbyte_arraycopy_nopush,\n+                                                              StubRoutines::_jshort_arraycopy_nopush,\n+                                                              StubRoutines::_jint_arraycopy_nopush,\n+                                                              StubRoutines::_jlong_arraycopy_nopush);\n@@ -2370,6 +2422,7 @@\n-    StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n-                                                               entry_jshort_arraycopy,\n-                                                               entry_jint_arraycopy,\n-                                                               entry_oop_arraycopy,\n-                                                               entry_jlong_arraycopy,\n-                                                               entry_checkcast_arraycopy);\n+    \/\/ generic arraycopy may fallback on conjoint stubs\n+    StubRoutines::_generic_arraycopy   = generate_generic_copy(StubRoutines::_jbyte_arraycopy_nopush,\n+                                                               StubRoutines::_jshort_arraycopy_nopush,\n+                                                               StubRoutines::_jint_arraycopy_nopush,\n+                                                               StubRoutines::_oop_arraycopy_nopush,\n+                                                               StubRoutines::_jlong_arraycopy_nopush,\n+                                                               StubRoutines::_checkcast_arraycopy_nopush);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":118,"deletions":65,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -184,1 +184,2 @@\n-  if (UseZicboz) {\n+  if (UseZicboz && zicboz_block_size.enabled() && zicboz_block_size.value() > 0) {\n+    assert(is_power_of_2(zicboz_block_size.value()), \"Sanity\");\n@@ -189,1 +190,1 @@\n-      FLAG_SET_DEFAULT(BlockZeroingLowLimit, 2 * CacheLineSize);\n+      FLAG_SET_DEFAULT(BlockZeroingLowLimit, 4 * zicboz_block_size.value());\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -165,39 +165,40 @@\n-  #define RV_FEATURE_FLAGS(decl)                                                                    \\\n-  decl(ext_I           , \"i\"           ,    ('I' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_M           , \"m\"           ,    ('M' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_A           , \"a\"           ,    ('A' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_F           , \"f\"           ,    ('F' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_D           , \"d\"           ,    ('D' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_C           , \"c\"           ,    ('C' - 'A'), true , UPDATE_DEFAULT(UseRVC))             \\\n-  decl(ext_Q           , \"q\"           ,    ('Q' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_H           , \"h\"           ,    ('H' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_V           , \"v\"           ,    ('V' - 'A'), true , UPDATE_DEFAULT(UseRVV))             \\\n-  decl(ext_Zicbom      , \"Zicbom\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbom))          \\\n-  decl(ext_Zicboz      , \"Zicboz\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicboz))          \\\n-  decl(ext_Zicbop      , \"Zicbop\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbop))          \\\n-  decl(ext_Zba         , \"Zba\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZba))             \\\n-  decl(ext_Zbb         , \"Zbb\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbb))             \\\n-  decl(ext_Zbc         , \"Zbc\"         , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zbs         , \"Zbs\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbs))             \\\n-  decl(ext_Zbkb        , \"Zbkb\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbkb))            \\\n-  decl(ext_Zcb         , \"Zcb\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZcb))             \\\n-  decl(ext_Zfa         , \"Zfa\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfa))             \\\n-  decl(ext_Zfh         , \"Zfh\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfh))             \\\n-  decl(ext_Zfhmin      , \"Zfhmin\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfhmin))          \\\n-  decl(ext_Zicsr       , \"Zicsr\"       , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zicntr      , \"Zicntr\"      , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zifencei    , \"Zifencei\"    , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n-  decl(ext_Zic64b      , \"Zic64b\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZic64b))          \\\n-  decl(ext_Ztso        , \"Ztso\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZtso))            \\\n-  decl(ext_Zihintpause , \"Zihintpause\" , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZihintpause))     \\\n-  decl(ext_Zacas       , \"Zacas\"       , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZacas))           \\\n-  decl(ext_Zvbb        , \"Zvbb\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvbb, ext_V)) \\\n-  decl(ext_Zvbc        , \"Zvbc\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvbc, ext_V)) \\\n-  decl(ext_Zvfh        , \"Zvfh\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvfh, ext_V)) \\\n-  decl(ext_Zvkn        , \"Zvkn\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvkn, ext_V)) \\\n-  decl(ext_Zicond      , \"Zicond\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicond))          \\\n-  decl(mvendorid       , \"VendorId\"    , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(marchid         , \"ArchId\"      , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(mimpid          , \"ImpId\"       , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(unaligned_access, \"Unaligned\"   , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n-  decl(satp_mode       , \"SATP\"        , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n+  #define RV_FEATURE_FLAGS(decl)                                                                        \\\n+  decl(ext_I            , \"i\"              ,    ('I' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_M            , \"m\"              ,    ('M' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_A            , \"a\"              ,    ('A' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_F            , \"f\"              ,    ('F' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_D            , \"d\"              ,    ('D' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_C            , \"c\"              ,    ('C' - 'A'), true , UPDATE_DEFAULT(UseRVC))             \\\n+  decl(ext_Q            , \"q\"              ,    ('Q' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_H            , \"h\"              ,    ('H' - 'A'), true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_V            , \"v\"              ,    ('V' - 'A'), true , UPDATE_DEFAULT(UseRVV))             \\\n+  decl(ext_Zicbom       , \"Zicbom\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbom))          \\\n+  decl(ext_Zicboz       , \"Zicboz\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicboz))          \\\n+  decl(ext_Zicbop       , \"Zicbop\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicbop))          \\\n+  decl(ext_Zba          , \"Zba\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZba))             \\\n+  decl(ext_Zbb          , \"Zbb\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbb))             \\\n+  decl(ext_Zbc          , \"Zbc\"            , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zbs          , \"Zbs\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbs))             \\\n+  decl(ext_Zbkb         , \"Zbkb\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZbkb))            \\\n+  decl(ext_Zcb          , \"Zcb\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZcb))             \\\n+  decl(ext_Zfa          , \"Zfa\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfa))             \\\n+  decl(ext_Zfh          , \"Zfh\"            , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfh))             \\\n+  decl(ext_Zfhmin       , \"Zfhmin\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfhmin))          \\\n+  decl(ext_Zicsr        , \"Zicsr\"          , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zicntr       , \"Zicntr\"         , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zifencei     , \"Zifencei\"       , RV_NO_FLAG_BIT, true , NO_UPDATE_DEFAULT)                  \\\n+  decl(ext_Zic64b       , \"Zic64b\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZic64b))          \\\n+  decl(ext_Ztso         , \"Ztso\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZtso))            \\\n+  decl(ext_Zihintpause  , \"Zihintpause\"    , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZihintpause))     \\\n+  decl(ext_Zacas        , \"Zacas\"          , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZacas))           \\\n+  decl(ext_Zvbb         , \"Zvbb\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvbb, ext_V)) \\\n+  decl(ext_Zvbc         , \"Zvbc\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvbc, ext_V)) \\\n+  decl(ext_Zvfh         , \"Zvfh\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvfh, ext_V)) \\\n+  decl(ext_Zvkn         , \"Zvkn\"           , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT_DEP(UseZvkn, ext_V)) \\\n+  decl(ext_Zicond       , \"Zicond\"         , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZicond))          \\\n+  decl(mvendorid        , \"VendorId\"       , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n+  decl(marchid          , \"ArchId\"         , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n+  decl(mimpid           , \"ImpId\"          , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n+  decl(unaligned_access , \"Unaligned\"      , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n+  decl(satp_mode        , \"SATP\"           , RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n+  decl(zicboz_block_size, \"ZicbozBlockSize\", RV_NO_FLAG_BIT, false, NO_UPDATE_DEFAULT)                  \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":40,"deletions":39,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/assembler.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-      int old_value = Atomic::load(data_addr);\n+      int old_value = AtomicAccess::load(data_addr);\n@@ -72,1 +72,1 @@\n-        int v = Atomic::cmpxchg(data_addr, old_value, new_value, memory_order_release);\n+        int v = AtomicAccess::cmpxchg(data_addr, old_value, new_value, memory_order_release);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetNMethod_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1401,5 +1401,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x01);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x01, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -1435,5 +1431,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void)emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_arith(0x03, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x03, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -1660,0 +1652,5 @@\n+void Assembler::eandl(Register dst, Address src1, Register src2, bool no_flags) {\n+  InstructionMark im(this);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x21, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n+}\n+\n@@ -1666,5 +1663,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_arith(0x23, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x23, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -2522,1 +2515,1 @@\n-  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0xAF, no_flags, true \/* is_map1 *\/,  true \/* swap *\/);\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0xAF, no_flags, true \/* is_map1 *\/,  true \/* swap *\/, true \/* is_commutative *\/);\n@@ -4422,5 +4415,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_arith(0x0B, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_66, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_16bit, 0x0B, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -4470,5 +4459,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_arith(0x0B, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x0B, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -4486,5 +4471,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x09);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x09, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -4520,5 +4501,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x08);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_8bit, 0x08, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -7326,5 +7303,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_arith(0x33, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x33, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -7342,5 +7315,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_32bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x31);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_32bit, 0x31, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -7370,5 +7339,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_8bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x30);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_8bit, 0x30, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -12958,0 +12923,25 @@\n+void Assembler::emit_eevex_or_demote(Register dst, Address src1, Register src2, VexSimdPrefix pre, VexOpcode opc,\n+                                     int size, int opcode_byte, bool no_flags, bool is_map1, bool is_commutative) {\n+  if (is_commutative && is_demotable(no_flags, dst->encoding(), src2->encoding())) {\n+    \/\/ Opcode byte adjustment due to mismatch between NDD and equivalent demotable variant\n+    opcode_byte += 2;\n+    if (size == EVEX_64bit) {\n+      emit_prefix_and_int8(get_prefixq(src1, dst, is_map1), opcode_byte);\n+    } else {\n+      \/\/ For 32-bit, 16-bit and 8-bit\n+      if (size == EVEX_16bit) {\n+        emit_int8(0x66);\n+      }\n+      prefix(src1, dst, false, is_map1);\n+      emit_int8(opcode_byte);\n+    }\n+  } else {\n+    bool vex_w = (size == EVEX_64bit) ? true : false;\n+    InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+    attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n+    eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), pre, opc, &attributes, no_flags);\n+    emit_int8(opcode_byte);\n+  }\n+  emit_operand(src2, src1, 0);\n+}\n+\n@@ -13058,1 +13048,1 @@\n-                                     int size, int opcode_byte, bool no_flags, bool is_map1, bool swap) {\n+                                     int size, int opcode_byte, bool no_flags, bool is_map1, bool swap, bool is_commutative) {\n@@ -13061,1 +13051,3 @@\n-  if (is_demotable(no_flags, dst_enc, nds_enc)) {\n+  bool first_operand_demotable = is_demotable(no_flags, dst_enc, nds_enc);\n+  bool second_operand_demotable = is_commutative && is_demotable(no_flags, dst_enc, src_enc);\n+  if (first_operand_demotable || second_operand_demotable) {\n@@ -13065,1 +13057,1 @@\n-\n+    int src = first_operand_demotable ? src_enc : nds_enc;\n@@ -13067,1 +13059,1 @@\n-      encode = is_prefixq ? prefixq_and_encode(dst_enc, src_enc, is_map1) : prefix_and_encode(dst_enc, src_enc, is_map1);\n+      encode = is_prefixq ? prefixq_and_encode(dst_enc, src, is_map1) : prefix_and_encode(dst_enc, src, is_map1);\n@@ -13069,1 +13061,1 @@\n-      encode = is_prefixq ? prefixq_and_encode(src_enc, dst_enc, is_map1) : prefix_and_encode(src_enc, dst_enc, is_map1);\n+      encode = is_prefixq ? prefixq_and_encode(src, dst_enc, is_map1) : prefix_and_encode(src, dst_enc, is_map1);\n@@ -13117,0 +13109,20 @@\n+void Assembler::emit_eevex_prefix_or_demote_arith_ndd(Register dst, Register src1, Register src2, VexSimdPrefix pre, VexOpcode opc,\n+                                                      int size, int op1, int op2, bool no_flags, bool is_commutative) {\n+  bool demotable = is_demotable(no_flags, dst->encoding(), src1->encoding());\n+  if (!demotable && is_commutative) {\n+    if (is_demotable(no_flags, dst->encoding(), src2->encoding())) {\n+      \/\/ swap src1 and src2\n+      Register tmp = src1;\n+      src1 = src2;\n+      src2 = tmp;\n+    }\n+  }\n+  bool vex_w = (size == EVEX_64bit) ? true : false;\n+  bool use_prefixq = vex_w;\n+  InstructionAttr attributes(AVX_128bit, vex_w, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n+  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n+  (void)emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), pre, opc, &attributes, no_flags, use_prefixq);\n+  emit_arith(op1, op2, src1, src2);\n+}\n+\n@@ -13127,1 +13139,0 @@\n-    \/\/attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, size);\n@@ -13772,1 +13783,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13780,1 +13791,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13789,1 +13800,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13797,1 +13808,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13806,1 +13817,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13814,1 +13825,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13823,1 +13834,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13831,1 +13842,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13840,1 +13851,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13848,1 +13859,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13857,1 +13868,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -13865,1 +13876,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n@@ -14626,5 +14637,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x01);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x01, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -14659,5 +14666,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n-  emit_arith(0x03, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x03, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -14756,5 +14759,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n-  emit_arith(0x23, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x23, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -14771,5 +14770,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x21);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x21, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -15121,1 +15116,1 @@\n-  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0xAF, no_flags, true \/* is_map1 *\/,  true \/* swap *\/);\n+  emit_eevex_or_demote(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0xAF, no_flags, true \/* is_map1 *\/,  true \/* swap *\/, true \/* is_commutative *\/);\n@@ -15583,5 +15578,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x09);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x09, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n@@ -15627,5 +15618,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n-  emit_arith(0x0B, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x0B, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -15633,1 +15620,0 @@\n-\n@@ -16375,5 +16361,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  \/\/ NDD shares its encoding bits with NDS bits for regular EVEX instruction.\n-  \/\/ Therefore, DST is passed as the second argument to minimize changes in the leaf level routine.\n-  (void) emit_eevex_prefix_or_demote_ndd(src1->encoding(), dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags, true \/* use_prefixq *\/);\n-  emit_arith(0x33, 0xC0, src1, src2);\n+  emit_eevex_prefix_or_demote_arith_ndd(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x33, 0xC0, no_flags, true \/* is_commutative *\/);\n@@ -16433,5 +16415,1 @@\n-  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n-  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_NOSCALE, \/* input_size_in_bits *\/ EVEX_64bit);\n-  eevex_prefix_ndd(src1, dst->encoding(), src2->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, &attributes, no_flags);\n-  emit_int8(0x31);\n-  emit_operand(src2, src1, 0);\n+  emit_eevex_or_demote(dst, src1, src2, VEX_SIMD_NONE, VEX_OPCODE_0F_3C \/* MAP4 *\/, EVEX_64bit, 0x31, no_flags, false \/* is_map1 *\/, true \/* is_commutative *\/);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":89,"deletions":111,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -810,0 +810,3 @@\n+  void emit_eevex_prefix_or_demote_arith_ndd(Register dst, Register src1, Register src2, VexSimdPrefix pre, VexOpcode opc,\n+                                             int size, int op1, int op2, bool no_flags = false, bool is_commutative = false);\n+\n@@ -816,0 +819,3 @@\n+  void emit_eevex_or_demote(Register dst, Address src1, Register src2, VexSimdPrefix pre, VexOpcode opc,\n+                            int size, int opcode_byte, bool no_flags = false, bool is_map1 = false, bool is_commutative = false);\n+\n@@ -817,1 +823,1 @@\n-                            int size, int opcode_byte, bool no_flags, bool is_map1 = false, bool swap = false);\n+                            int size, int opcode_byte, bool no_flags, bool is_map1 = false, bool swap = false, bool is_commutative = false);\n@@ -1152,0 +1158,1 @@\n+  void eandl(Register dst, Address src1, Register src2, bool no_flags);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    jint old_value = Atomic::load(data_addr);\n+    jint old_value = AtomicAccess::load(data_addr);\n@@ -73,1 +73,1 @@\n-      jint v = Atomic::cmpxchg(data_addr, old_value, new_value, memory_order_release);\n+      jint v = AtomicAccess::cmpxchg(data_addr, old_value, new_value, memory_order_release);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,7 +79,43 @@\n-  address entry;\n-  address entry_jbyte_arraycopy;\n-  address entry_jshort_arraycopy;\n-  address entry_jint_arraycopy;\n-  address entry_oop_arraycopy;\n-  address entry_jlong_arraycopy;\n-  address entry_checkcast_arraycopy;\n+  \/\/ Some copy stubs publish a normal entry and then a 2nd 'fallback'\n+  \/\/ entry immediately following their stack push. This can be used\n+  \/\/ as a post-push branch target for compatible stubs when they\n+  \/\/ identify a special case that can be handled by the fallback\n+  \/\/ stub e.g a disjoint copy stub may be use as a special case\n+  \/\/ fallback for its compatible conjoint copy stub.\n+  \/\/\n+  \/\/ A no push entry is always returned in the following local and\n+  \/\/ then published by assigning to the appropriate entry field in\n+  \/\/ class StubRoutines. The entry value is then passed to the\n+  \/\/ generator for the compatible stub. That means the entry must be\n+  \/\/ listed when saving to\/restoring from the AOT cache, ensuring\n+  \/\/ that the inter-stub jumps are noted at AOT-cache save and\n+  \/\/ relocated at AOT cache load.\n+  address nopush_entry;\n+\n+  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(&nopush_entry);\n+  \/\/ disjoint nopush entry is needed by conjoint copy\n+  StubRoutines::_jbyte_disjoint_arraycopy_nopush  = nopush_entry;\n+  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(StubRoutines::_jbyte_disjoint_arraycopy_nopush, &nopush_entry);\n+  \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+  StubRoutines::_jbyte_arraycopy_nopush    = nopush_entry;\n+\n+  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(&nopush_entry);\n+  \/\/ disjoint nopush entry is needed by conjoint copy\n+  StubRoutines::_jshort_disjoint_arraycopy_nopush = nopush_entry;\n+  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(StubRoutines::_jshort_disjoint_arraycopy_nopush, &nopush_entry);\n+  \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+  StubRoutines::_jshort_arraycopy_nopush   = nopush_entry;\n+\n+  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &nopush_entry);\n+  \/\/ disjoint nopush entry is needed by conjoint copy\n+  StubRoutines::_jint_disjoint_arraycopy_nopush = nopush_entry;\n+  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubId::stubgen_jint_arraycopy_id, StubRoutines::_jint_disjoint_arraycopy_nopush, &nopush_entry);\n+  \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+  StubRoutines::_jint_arraycopy_nopush     = nopush_entry;\n+\n+  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_jlong_disjoint_arraycopy_id, &nopush_entry);\n+  \/\/ disjoint nopush entry is needed by conjoint copy\n+  StubRoutines::_jlong_disjoint_arraycopy_nopush  = nopush_entry;\n+  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_jlong_arraycopy_id, StubRoutines::_jlong_disjoint_arraycopy_nopush, &nopush_entry);\n+  \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+  StubRoutines::_jlong_arraycopy_nopush    = nopush_entry;\n@@ -87,11 +123,0 @@\n-  StubRoutines::_jbyte_disjoint_arraycopy  = generate_disjoint_byte_copy(&entry);\n-  StubRoutines::_jbyte_arraycopy           = generate_conjoint_byte_copy(entry, &entry_jbyte_arraycopy);\n-\n-  StubRoutines::_jshort_disjoint_arraycopy = generate_disjoint_short_copy(&entry);\n-  StubRoutines::_jshort_arraycopy          = generate_conjoint_short_copy(entry, &entry_jshort_arraycopy);\n-\n-  StubRoutines::_jint_disjoint_arraycopy   = generate_disjoint_int_oop_copy(StubId::stubgen_jint_disjoint_arraycopy_id, &entry);\n-  StubRoutines::_jint_arraycopy            = generate_conjoint_int_oop_copy(StubId::stubgen_jint_arraycopy_id, entry, &entry_jint_arraycopy);\n-\n-  StubRoutines::_jlong_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_jlong_disjoint_arraycopy_id, &entry);\n-  StubRoutines::_jlong_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_jlong_arraycopy_id, entry, &entry_jlong_arraycopy);\n@@ -99,4 +124,12 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &entry);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, entry, nullptr);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_oop_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_oop_arraycopy_nopush    = nopush_entry;\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_int_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_oop_disjoint_arraycopy_uninit_nopush  = nopush_entry;\n+    \/\/ note that we don't need a returned nopush entry because the\n+    \/\/ generic\/unsafe copy does not cater for uninit arrays.\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_int_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, StubRoutines::_oop_disjoint_arraycopy_uninit_nopush, nullptr);\n@@ -104,4 +137,12 @@\n-    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &entry);\n-    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_id, entry, &entry_oop_arraycopy);\n-    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &entry);\n-    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, entry, nullptr);\n+    StubRoutines::_oop_disjoint_arraycopy  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_oop_disjoint_arraycopy_nopush  = nopush_entry;\n+    StubRoutines::_oop_arraycopy           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_id, StubRoutines::_oop_disjoint_arraycopy_nopush, &nopush_entry);\n+    \/\/ conjoint nopush entry is needed by generic\/unsafe copy\n+    StubRoutines::_oop_arraycopy_nopush    = nopush_entry;\n+    StubRoutines::_oop_disjoint_arraycopy_uninit  = generate_disjoint_long_oop_copy(StubId::stubgen_oop_disjoint_arraycopy_uninit_id, &nopush_entry);\n+    \/\/ disjoint nopush entry is needed by conjoint copy\n+    StubRoutines::_oop_disjoint_arraycopy_uninit_nopush  = nopush_entry;\n+    \/\/ note that we don't need a returned nopush entry because the\n+    \/\/ generic\/unsafe copy does not cater for uninit arrays.\n+    StubRoutines::_oop_arraycopy_uninit           = generate_conjoint_long_oop_copy(StubId::stubgen_oop_arraycopy_uninit_id, StubRoutines::_oop_disjoint_arraycopy_uninit_nopush, nullptr);\n@@ -110,1 +151,5 @@\n-  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &entry_checkcast_arraycopy);\n+  StubRoutines::_checkcast_arraycopy        = generate_checkcast_copy(StubId::stubgen_checkcast_arraycopy_id, &nopush_entry);\n+  \/\/ checkcast nopush entry is needed by generic copy\n+  StubRoutines::_checkcast_arraycopy_nopush = nopush_entry;\n+  \/\/ note that we don't need a returned nopush entry because the\n+  \/\/ generic copy does not cater for uninit arrays.\n@@ -113,10 +158,10 @@\n-  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(entry_jbyte_arraycopy,\n-                                                            entry_jshort_arraycopy,\n-                                                            entry_jint_arraycopy,\n-                                                            entry_jlong_arraycopy);\n-  StubRoutines::_generic_arraycopy   = generate_generic_copy(entry_jbyte_arraycopy,\n-                                                             entry_jshort_arraycopy,\n-                                                             entry_jint_arraycopy,\n-                                                             entry_oop_arraycopy,\n-                                                             entry_jlong_arraycopy,\n-                                                             entry_checkcast_arraycopy);\n+  StubRoutines::_unsafe_arraycopy    = generate_unsafe_copy(StubRoutines::_jbyte_arraycopy_nopush,\n+                                                            StubRoutines::_jshort_arraycopy_nopush,\n+                                                            StubRoutines::_jint_arraycopy_nopush,\n+                                                            StubRoutines::_jlong_arraycopy_nopush);\n+  StubRoutines::_generic_arraycopy   = generate_generic_copy(StubRoutines::_jbyte_arraycopy_nopush,\n+                                                             StubRoutines::_jshort_arraycopy_nopush,\n+                                                             StubRoutines::_jint_arraycopy_nopush,\n+                                                             StubRoutines::_oop_arraycopy_nopush,\n+                                                             StubRoutines::_jlong_arraycopy_nopush,\n+                                                             StubRoutines::_checkcast_arraycopy_nopush);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":82,"deletions":37,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1019,10 +1019,0 @@\n-  \/\/ Currently APX support is only enabled for targets supporting AVX512VL feature.\n-  bool apx_supported = os_supports_apx_egprs() && supports_apx_f() && supports_avx512vl();\n-  if (UseAPX && !apx_supported) {\n-    warning(\"UseAPX is not supported on this CPU, setting it to false\");\n-    FLAG_SET_DEFAULT(UseAPX, false);\n-  }\n-\n-  if (!UseAPX) {\n-    _features.clear_feature(CPU_APX_F);\n-  }\n@@ -1052,0 +1042,1 @@\n+      _features.clear_feature(CPU_APX_F);\n@@ -1071,0 +1062,11 @@\n+    \/\/ Currently APX support is only enabled for targets supporting AVX512VL feature.\n+  bool apx_supported = os_supports_apx_egprs() && supports_apx_f() && supports_avx512vl();\n+  if (UseAPX && !apx_supported) {\n+    warning(\"UseAPX is not supported on this CPU, setting it to false\");\n+    FLAG_SET_DEFAULT(UseAPX, false);\n+  }\n+\n+  if (!UseAPX) {\n+    _features.clear_feature(CPU_APX_F);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"asm\/assembler.inline.hpp\"\n+#include \"asm\/assembler.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/assembler_zero.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -812,1 +812,1 @@\n-  const uint64_t obsv = Atomic::cmpxchg(&Bsd::_max_abstime, prev, now);\n+  const uint64_t obsv = AtomicAccess::cmpxchg(&Bsd::_max_abstime, prev, now);\n@@ -2136,1 +2136,1 @@\n-  int processor_id = Atomic::load(&processor_id_map[apic_id]);\n+  int processor_id = AtomicAccess::load(&processor_id_map[apic_id]);\n@@ -2140,1 +2140,1 @@\n-    processor_id = Atomic::cmpxchg(&processor_id_map[apic_id], processor_id_unassigned, processor_id_assigning);\n+    processor_id = AtomicAccess::cmpxchg(&processor_id_map[apic_id], processor_id_unassigned, processor_id_assigning);\n@@ -2142,2 +2142,2 @@\n-      processor_id = Atomic::fetch_then_add(&processor_id_next, 1) % os::processor_count();\n-      Atomic::store(&processor_id_map[apic_id], processor_id);\n+      processor_id = AtomicAccess::fetch_then_add(&processor_id_next, 1) % os::processor_count();\n+      AtomicAccess::store(&processor_id_map[apic_id], processor_id);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -373,0 +373,4 @@\n+\/\/ Returns the resident set size (RSS) of the process.\n+\/\/ Falls back to using VmRSS from \/proc\/self\/status if \/proc\/self\/smaps_rollup is unavailable.\n+\/\/ Note: On kernels with memory cgroups or shared memory, VmRSS may underreport RSS.\n+\/\/ Users requiring accurate RSS values should be aware of this limitation.\n@@ -375,3 +379,8 @@\n-  os::Linux::meminfo_t info;\n-  if (os::Linux::query_process_memory_info(&info)) {\n-    size = info.vmrss * K;\n+  os::Linux::accurate_meminfo_t accurate_info;\n+  if (os::Linux::query_accurate_process_memory_info(&accurate_info) && accurate_info.rss != -1) {\n+    size = accurate_info.rss * K;\n+  } else {\n+    os::Linux::meminfo_t info;\n+    if (os::Linux::query_process_memory_info(&info)) {\n+      size = info.vmrss * K;\n+    }\n@@ -2365,0 +2374,31 @@\n+\/\/ Accurate memory information need Linux 4.14 or newer\n+bool os::Linux::query_accurate_process_memory_info(os::Linux::accurate_meminfo_t* info) {\n+  FILE* f = os::fopen(\"\/proc\/self\/smaps_rollup\", \"r\");\n+  if (f == nullptr) {\n+    return false;\n+  }\n+\n+  const size_t num_values = sizeof(os::Linux::accurate_meminfo_t) \/ sizeof(size_t);\n+  size_t num_found = 0;\n+  char buf[256];\n+  info->rss = info->pss = info->pssdirty = info->pssanon =\n+      info->pssfile = info->pssshmem = info->swap = info->swappss = -1;\n+\n+  while (::fgets(buf, sizeof(buf), f) != nullptr && num_found < num_values) {\n+    if ( (info->rss == -1        && sscanf(buf, \"Rss: %zd kB\", &info->rss) == 1) ||\n+         (info->pss == -1        && sscanf(buf, \"Pss: %zd kB\", &info->pss) == 1) ||\n+         (info->pssdirty == -1   && sscanf(buf, \"Pss_Dirty: %zd kB\", &info->pssdirty) == 1) ||\n+         (info->pssanon == -1    && sscanf(buf, \"Pss_Anon: %zd kB\", &info->pssanon) == 1) ||\n+         (info->pssfile == -1    && sscanf(buf, \"Pss_File: %zd kB\", &info->pssfile) == 1) ||\n+         (info->pssshmem == -1   && sscanf(buf, \"Pss_Shmem: %zd kB\", &info->pssshmem) == 1) ||\n+         (info->swap == -1       && sscanf(buf, \"Swap: %zd kB\", &info->swap) == 1) ||\n+         (info->swappss == -1    && sscanf(buf, \"SwapPss: %zd kB\", &info->swappss) == 1)\n+         )\n+    {\n+      num_found ++;\n+    }\n+  }\n+  fclose(f);\n+  return true;\n+}\n+\n@@ -4784,2 +4824,2 @@\n-  if (Atomic::load(&warn_once) == 0 ||\n-      Atomic::xchg(&warn_once, 0) == 0) {\n+  if (AtomicAccess::load(&warn_once) == 0 ||\n+      AtomicAccess::xchg(&warn_once, 0) == 0) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":46,"deletions":6,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -184,0 +184,17 @@\n+  \/\/ Output structure for query_accurate_process_memory_info() (all values in KB)\n+  struct accurate_meminfo_t {\n+    ssize_t rss;        \/\/ current resident set size\n+    ssize_t pss;        \/\/ current proportional set size\n+    ssize_t pssdirty;   \/\/ proportional set size (dirty)\n+    ssize_t pssanon;    \/\/ proportional set size (anonymous mappings)\n+    ssize_t pssfile;    \/\/ proportional set size (file mappings)\n+    ssize_t pssshmem;   \/\/ proportional set size (shared mappings)\n+    ssize_t swap;       \/\/ swapped out\n+    ssize_t swappss;    \/\/ proportional set size (swapped out)\n+  };\n+\n+  \/\/ Attempts to query accurate memory information from \/proc\/self\/smaps_rollup and return it in the output structure.\n+  \/\/ May fail (returns false) or succeed (returns true) but not all output fields are available; unavailable\n+  \/\/ fields will contain -1.\n+  static bool query_accurate_process_memory_info(accurate_meminfo_t* info);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-FORBID_C_FUNCTION(char* strndup(const char*, size_t), \"don't use\");\n+FORBID_C_FUNCTION(char* strndup(const char*, size_t), noexcept, \"don't use\");\n@@ -45,2 +45,2 @@\n-FORBID_C_FUNCTION(int posix_memalign(void**, size_t, size_t), \"don't use\");\n-FORBID_C_FUNCTION(void* aligned_alloc(size_t, size_t), \"don't use\");\n+FORBID_C_FUNCTION(int posix_memalign(void**, size_t, size_t), noexcept, \"don't use\");\n+FORBID_C_FUNCTION(void* aligned_alloc(size_t, size_t), noexcept, \"don't use\");\n@@ -52,1 +52,1 @@\n-FORBID_C_FUNCTION(char* realpath(const char*, char*), \"use os::realpath\");\n+FORBID_C_FUNCTION(char* realpath(const char*, char*), noexcept, \"use os::realpath\");\n@@ -56,1 +56,1 @@\n-FORBID_C_FUNCTION(char* get_current_dir_name(), \"use os::get_current_directory\");\n+FORBID_C_FUNCTION(char* get_current_dir_name(), noexcept, \"use os::get_current_directory\");\n@@ -59,1 +59,1 @@\n-FORBID_C_FUNCTION(char* getwd(char*), \"use os::get_current_directory\");\n+FORBID_C_FUNCTION(char* getwd(char*), noexcept, \"use os::get_current_directory\");\n@@ -62,1 +62,1 @@\n-FORBID_C_FUNCTION(void* reallocf(void*, size_t), \"use os::realloc\");\n+FORBID_C_FUNCTION(void* reallocf(void*, size_t), \/* not noexcept *\/, \"use os::realloc\");\n","filename":"src\/hotspot\/os\/posix\/forbiddenFunctions_posix.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1694,1 +1694,1 @@\n-    if (Atomic::cmpxchg(&_event, v, v - 1) == v) break;\n+    if (AtomicAccess::cmpxchg(&_event, v, v - 1) == v) break;\n@@ -1741,1 +1741,1 @@\n-    if (Atomic::cmpxchg(&_event, v, v - 1) == v) break;\n+    if (AtomicAccess::cmpxchg(&_event, v, v - 1) == v) break;\n@@ -1797,1 +1797,1 @@\n-  if (Atomic::xchg(&_event, 1) >= 0) return;\n+  if (AtomicAccess::xchg(&_event, 1) >= 0) return;\n@@ -1850,1 +1850,1 @@\n-  \/\/ We depend on Atomic::xchg() having full barrier semantics\n+  \/\/ We depend on AtomicAccess::xchg() having full barrier semantics\n@@ -1852,1 +1852,1 @@\n-  if (Atomic::xchg(&_counter, 0) > 0) return;\n+  if (AtomicAccess::xchg(&_counter, 0) > 0) return;\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -359,1 +359,1 @@\n-    Atomic::inc(&pending_signals[sig]);\n+    AtomicAccess::inc(&pending_signals[sig]);\n@@ -372,1 +372,1 @@\n-      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n+      if (n > 0 && n == AtomicAccess::cmpxchg(&pending_signals[i], n, n - 1)) {\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -34,1 +34,1 @@\n-  SuspendResume::State result = Atomic::cmpxchg(&_state, from, to);\n+  SuspendResume::State result = AtomicAccess::cmpxchg(&_state, from, to);\n","filename":"src\/hotspot\/os\/posix\/suspendResume_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+\/\/ NOTE: The Windows C standard library doesn't declare functions \"noexcept\".\n+\n@@ -33,1 +35,1 @@\n-FORBID_IMPORTED_C_FUNCTION(char* _fullpath(char*, const char*, size_t), \"use os::realpath\");\n+FORBID_IMPORTED_C_FUNCTION(char* _fullpath(char*, const char*, size_t), \/* not noexcept *\/, \"use os::realpath\");\n@@ -36,1 +38,1 @@\n-FORBID_C_FUNCTION(int _snprintf(char*, size_t, const char*, ...), \"use os::snprintf\");\n+FORBID_C_FUNCTION(int _snprintf(char*, size_t, const char*, ...), \/* not noexcept *\/, \"use os::snprintf\");\n","filename":"src\/hotspot\/os\/windows\/forbiddenFunctions_windows.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -2465,1 +2465,1 @@\n-    Atomic::inc(&pending_signals[sig]);\n+    AtomicAccess::inc(&pending_signals[sig]);\n@@ -2478,1 +2478,1 @@\n-      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n+      if (n > 0 && n == AtomicAccess::cmpxchg(&pending_signals[i], n, n - 1)) {\n@@ -4300,1 +4300,1 @@\n-    } else if (Atomic::load_acquire(&process_exiting) == 0) {\n+    } else if (AtomicAccess::load_acquire(&process_exiting) == 0) {\n@@ -4304,1 +4304,1 @@\n-        Atomic::cmpxchg(&process_exiting, (DWORD)0, GetCurrentThreadId());\n+        AtomicAccess::cmpxchg(&process_exiting, (DWORD)0, GetCurrentThreadId());\n@@ -4308,1 +4308,1 @@\n-      if (what == EPT_THREAD && Atomic::load_acquire(&process_exiting) == 0) {\n+      if (what == EPT_THREAD && AtomicAccess::load_acquire(&process_exiting) == 0) {\n@@ -4421,1 +4421,1 @@\n-        Atomic::load_acquire(&process_exiting) != 0 &&\n+        AtomicAccess::load_acquire(&process_exiting) != 0 &&\n@@ -5587,1 +5587,1 @@\n-    if (Atomic::cmpxchg(&_Event, v, v-1) == v) break;\n+    if (AtomicAccess::cmpxchg(&_Event, v, v-1) == v) break;\n@@ -5650,1 +5650,1 @@\n-    if (Atomic::cmpxchg(&_Event, v, v-1) == v) break;\n+    if (AtomicAccess::cmpxchg(&_Event, v, v-1) == v) break;\n@@ -5697,1 +5697,1 @@\n-  if (Atomic::xchg(&_Event, 1) >= 0) return;\n+  if (AtomicAccess::xchg(&_Event, 1) >= 0) return;\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_AIX_PPC_ATOMICACCESS_AIX_PPC_HPP\n+#define OS_CPU_AIX_PPC_ATOMICACCESS_AIX_PPC_HPP\n+\n+#ifndef PPC64\n+#error \"Atomic currently only implemented for PPC64\"\n+#endif\n+\n+#include \"orderAccess_aix_ppc.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+\/\/\n+\/\/ machine barrier instructions:\n+\/\/\n+\/\/ - sync            two-way memory barrier, aka fence\n+\/\/ - lwsync          orders  Store|Store,\n+\/\/                            Load|Store,\n+\/\/                            Load|Load,\n+\/\/                   but not Store|Load\n+\/\/ - eieio           orders memory accesses for device memory (only)\n+\/\/ - isync           invalidates speculatively executed instructions\n+\/\/                   From the POWER ISA 2.06 documentation:\n+\/\/                    \"[...] an isync instruction prevents the execution of\n+\/\/                   instructions following the isync until instructions\n+\/\/                   preceding the isync have completed, [...]\"\n+\/\/                   From IBM's AIX assembler reference:\n+\/\/                    \"The isync [...] instructions causes the processor to\n+\/\/                   refetch any instructions that might have been fetched\n+\/\/                   prior to the isync instruction. The instruction isync\n+\/\/                   causes the processor to wait for all previous instructions\n+\/\/                   to complete. Then any instructions already fetched are\n+\/\/                   discarded and instruction processing continues in the\n+\/\/                   environment established by the previous instructions.\"\n+\/\/\n+\/\/ semantic barrier instructions:\n+\/\/ (as defined in orderAccess.hpp)\n+\/\/\n+\/\/ - release         orders Store|Store,       (maps to lwsync)\n+\/\/                           Load|Store\n+\/\/ - acquire         orders  Load|Store,       (maps to lwsync)\n+\/\/                           Load|Load\n+\/\/ - fence           orders Store|Store,       (maps to sync)\n+\/\/                           Load|Store,\n+\/\/                           Load|Load,\n+\/\/                          Store|Load\n+\/\/\n+\n+inline void pre_membar(atomic_memory_order order) {\n+  switch (order) {\n+    case memory_order_relaxed:\n+    case memory_order_acquire: break;\n+    case memory_order_release:\n+    case memory_order_acq_rel: __asm__ __volatile__ (\"lwsync\" : : : \"memory\"); break;\n+    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n+  }\n+}\n+\n+inline void post_membar(atomic_memory_order order) {\n+  switch (order) {\n+    case memory_order_relaxed:\n+    case memory_order_release: break;\n+    case memory_order_acquire:\n+    case memory_order_acq_rel: __asm__ __volatile__ (\"isync\"  : : : \"memory\"); break;\n+    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n+  }\n+}\n+\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D result;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \"1: lwarx   %0,  0, %2    \\n\"\n+    \"   add     %0, %0, %1    \\n\"\n+    \"   stwcx.  %0,  0, %2    \\n\"\n+    \"   bne-    1b            \\n\"\n+    : \/*%0*\/\"=&r\" (result)\n+    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n+    : \"cc\", \"memory\" );\n+\n+  post_membar(order);\n+\n+  return result;\n+}\n+\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+\n+  D result;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \"1: ldarx   %0,  0, %2    \\n\"\n+    \"   add     %0, %0, %1    \\n\"\n+    \"   stdcx.  %0,  0, %2    \\n\"\n+    \"   bne-    1b            \\n\"\n+    : \/*%0*\/\"=&r\" (result)\n+    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n+    : \"cc\", \"memory\" );\n+\n+  post_membar(order);\n+\n+  return result;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  \/\/ Note that xchg doesn't necessarily do an acquire\n+  \/\/ (see synchronizer.cpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  \/\/ Note that xchg doesn't necessarily do an acquire\n+  \/\/ (see synchronizer.cpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<1>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+\n+  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n+  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n+  \/\/ specified otherwise (see atomicAccess.hpp).\n+\n+  \/\/ Using 32 bit internally.\n+  volatile int *dest_base = (volatile int*)((uintptr_t)dest & ~3);\n+\n+#ifdef VM_LITTLE_ENDIAN\n+  const unsigned int shift_amount        = ((uintptr_t)dest & 3) * 8;\n+#else\n+  const unsigned int shift_amount        = ((~(uintptr_t)dest) & 3) * 8;\n+#endif\n+  const unsigned int masked_compare_val  = ((unsigned int)(unsigned char)compare_value),\n+                     masked_exchange_val = ((unsigned int)(unsigned char)exchange_value),\n+                     xor_value           = (masked_compare_val ^ masked_exchange_val) << shift_amount;\n+\n+  unsigned int old_value, value32;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* simple guard *\/\n+    \"   lbz     %[old_value], 0(%[dest])                  \\n\"\n+    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n+    \"   bne-    2f                                        \\n\"\n+    \/* atomic loop *\/\n+    \"1:                                                   \\n\"\n+    \"   lwarx   %[value32], 0, %[dest_base]               \\n\"\n+    \/* extract byte and compare *\/\n+    \"   srd     %[old_value], %[value32], %[shift_amount] \\n\"\n+    \"   clrldi  %[old_value], %[old_value], 56            \\n\"\n+    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n+    \"   bne-    2f                                        \\n\"\n+    \/* replace byte and try to store *\/\n+    \"   xor     %[value32], %[xor_value], %[value32]      \\n\"\n+    \"   stwcx.  %[value32], 0, %[dest_base]               \\n\"\n+    \"   bne-    1b                                        \\n\"\n+    \/* exit *\/\n+    \"2:                                                   \\n\"\n+    \/* out *\/\n+    : [old_value]           \"=&r\"   (old_value),\n+      [value32]             \"=&r\"   (value32),\n+                            \"=m\"    (*dest),\n+                            \"=m\"    (*dest_base)\n+    \/* in *\/\n+    : [dest]                \"b\"     (dest),\n+      [dest_base]           \"b\"     (dest_base),\n+      [shift_amount]        \"r\"     (shift_amount),\n+      [masked_compare_val]  \"r\"     (masked_compare_val),\n+      [xor_value]           \"r\"     (xor_value),\n+                            \"m\"     (*dest),\n+                            \"m\"     (*dest_base)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return PrimitiveConversions::cast<T>((unsigned char)old_value);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+\n+  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n+  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n+  \/\/ specified otherwise (see atomicAccess.hpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* simple guard *\/\n+    \"   lwz     %[old_value], 0(%[dest])                \\n\"\n+    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+\n+  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n+  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n+  \/\/ specified otherwise (see atomicAccess.hpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* simple guard *\/\n+    \"   ld      %[old_value], 0(%[dest])                \\n\"\n+    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedLoad<byte_size, X_ACQUIRE> {\n+  template <typename T>\n+  T operator()(const volatile T* p) const {\n+    T t = AtomicAccess::load(p);\n+    \/\/ Use twi-isync for load_acquire (faster than lwsync).\n+    __asm__ __volatile__ (\"twi 0,%0,0\\n isync\\n\" : : \"r\" (t) : \"memory\");\n+    return t;\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_AIX_PPC_ATOMICACCESS_AIX_PPC_HPP\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/atomicAccess_aix_ppc.hpp","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -1,417 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_AIX_PPC_ATOMIC_AIX_PPC_HPP\n-#define OS_CPU_AIX_PPC_ATOMIC_AIX_PPC_HPP\n-\n-#ifndef PPC64\n-#error \"Atomic currently only implemented for PPC64\"\n-#endif\n-\n-#include \"orderAccess_aix_ppc.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\n-\/\/\n-\/\/ machine barrier instructions:\n-\/\/\n-\/\/ - sync            two-way memory barrier, aka fence\n-\/\/ - lwsync          orders  Store|Store,\n-\/\/                            Load|Store,\n-\/\/                            Load|Load,\n-\/\/                   but not Store|Load\n-\/\/ - eieio           orders memory accesses for device memory (only)\n-\/\/ - isync           invalidates speculatively executed instructions\n-\/\/                   From the POWER ISA 2.06 documentation:\n-\/\/                    \"[...] an isync instruction prevents the execution of\n-\/\/                   instructions following the isync until instructions\n-\/\/                   preceding the isync have completed, [...]\"\n-\/\/                   From IBM's AIX assembler reference:\n-\/\/                    \"The isync [...] instructions causes the processor to\n-\/\/                   refetch any instructions that might have been fetched\n-\/\/                   prior to the isync instruction. The instruction isync\n-\/\/                   causes the processor to wait for all previous instructions\n-\/\/                   to complete. Then any instructions already fetched are\n-\/\/                   discarded and instruction processing continues in the\n-\/\/                   environment established by the previous instructions.\"\n-\/\/\n-\/\/ semantic barrier instructions:\n-\/\/ (as defined in orderAccess.hpp)\n-\/\/\n-\/\/ - release         orders Store|Store,       (maps to lwsync)\n-\/\/                           Load|Store\n-\/\/ - acquire         orders  Load|Store,       (maps to lwsync)\n-\/\/                           Load|Load\n-\/\/ - fence           orders Store|Store,       (maps to sync)\n-\/\/                           Load|Store,\n-\/\/                           Load|Load,\n-\/\/                          Store|Load\n-\/\/\n-\n-inline void pre_membar(atomic_memory_order order) {\n-  switch (order) {\n-    case memory_order_relaxed:\n-    case memory_order_acquire: break;\n-    case memory_order_release:\n-    case memory_order_acq_rel: __asm__ __volatile__ (\"lwsync\" : : : \"memory\"); break;\n-    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n-  }\n-}\n-\n-inline void post_membar(atomic_memory_order order) {\n-  switch (order) {\n-    case memory_order_relaxed:\n-    case memory_order_release: break;\n-    case memory_order_acquire:\n-    case memory_order_acq_rel: __asm__ __volatile__ (\"isync\"  : : : \"memory\"); break;\n-    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n-  }\n-}\n-\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n-                                               atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-\n-  D result;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \"1: lwarx   %0,  0, %2    \\n\"\n-    \"   add     %0, %0, %1    \\n\"\n-    \"   stwcx.  %0,  0, %2    \\n\"\n-    \"   bne-    1b            \\n\"\n-    : \/*%0*\/\"=&r\" (result)\n-    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n-    : \"cc\", \"memory\" );\n-\n-  post_membar(order);\n-\n-  return result;\n-}\n-\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n-                                               atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-\n-  D result;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \"1: ldarx   %0,  0, %2    \\n\"\n-    \"   add     %0, %0, %1    \\n\"\n-    \"   stdcx.  %0,  0, %2    \\n\"\n-    \"   bne-    1b            \\n\"\n-    : \/*%0*\/\"=&r\" (result)\n-    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n-    : \"cc\", \"memory\" );\n-\n-  post_membar(order);\n-\n-  return result;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  \/\/ Note that xchg doesn't necessarily do an acquire\n-  \/\/ (see synchronizer.cpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  \/\/ Note that xchg doesn't necessarily do an acquire\n-  \/\/ (see synchronizer.cpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(1 == sizeof(T));\n-\n-  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n-  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n-  \/\/ specified otherwise (see atomic.hpp).\n-\n-  \/\/ Using 32 bit internally.\n-  volatile int *dest_base = (volatile int*)((uintptr_t)dest & ~3);\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  const unsigned int shift_amount        = ((uintptr_t)dest & 3) * 8;\n-#else\n-  const unsigned int shift_amount        = ((~(uintptr_t)dest) & 3) * 8;\n-#endif\n-  const unsigned int masked_compare_val  = ((unsigned int)(unsigned char)compare_value),\n-                     masked_exchange_val = ((unsigned int)(unsigned char)exchange_value),\n-                     xor_value           = (masked_compare_val ^ masked_exchange_val) << shift_amount;\n-\n-  unsigned int old_value, value32;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* simple guard *\/\n-    \"   lbz     %[old_value], 0(%[dest])                  \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n-    \"   bne-    2f                                        \\n\"\n-    \/* atomic loop *\/\n-    \"1:                                                   \\n\"\n-    \"   lwarx   %[value32], 0, %[dest_base]               \\n\"\n-    \/* extract byte and compare *\/\n-    \"   srd     %[old_value], %[value32], %[shift_amount] \\n\"\n-    \"   clrldi  %[old_value], %[old_value], 56            \\n\"\n-    \"   cmpw    %[masked_compare_val], %[old_value]       \\n\"\n-    \"   bne-    2f                                        \\n\"\n-    \/* replace byte and try to store *\/\n-    \"   xor     %[value32], %[xor_value], %[value32]      \\n\"\n-    \"   stwcx.  %[value32], 0, %[dest_base]               \\n\"\n-    \"   bne-    1b                                        \\n\"\n-    \/* exit *\/\n-    \"2:                                                   \\n\"\n-    \/* out *\/\n-    : [old_value]           \"=&r\"   (old_value),\n-      [value32]             \"=&r\"   (value32),\n-                            \"=m\"    (*dest),\n-                            \"=m\"    (*dest_base)\n-    \/* in *\/\n-    : [dest]                \"b\"     (dest),\n-      [dest_base]           \"b\"     (dest_base),\n-      [shift_amount]        \"r\"     (shift_amount),\n-      [masked_compare_val]  \"r\"     (masked_compare_val),\n-      [xor_value]           \"r\"     (xor_value),\n-                            \"m\"     (*dest),\n-                            \"m\"     (*dest_base)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return PrimitiveConversions::cast<T>((unsigned char)old_value);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-\n-  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n-  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n-  \/\/ specified otherwise (see atomic.hpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* simple guard *\/\n-    \"   lwz     %[old_value], 0(%[dest])                \\n\"\n-    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [compare_value]   \"r\"     (compare_value),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-\n-  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n-  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n-  \/\/ specified otherwise (see atomic.hpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* simple guard *\/\n-    \"   ld      %[old_value], 0(%[dest])                \\n\"\n-    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [compare_value]   \"r\"     (compare_value),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE> {\n-  template <typename T>\n-  T operator()(const volatile T* p) const {\n-    T t = Atomic::load(p);\n-    \/\/ Use twi-isync for load_acquire (faster than lwsync).\n-    __asm__ __volatile__ (\"twi 0,%0,0\\n isync\\n\" : : \"r\" (t) : \"memory\");\n-    return t;\n-  }\n-};\n-\n-#endif \/\/ OS_CPU_AIX_PPC_ATOMIC_AIX_PPC_HPP\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/atomic_aix_ppc.hpp","additions":0,"deletions":417,"binary":false,"changes":417,"status":"deleted"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_ATOMICACCESS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_ATOMICACCESS_BSD_AARCH64_HPP\n+\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n+\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    if (order == memory_order_relaxed) {\n+      return __atomic_add_fetch(dest, add_value, __ATOMIC_RELAXED);\n+    } else {\n+      D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+      FULL_MEM_BARRIER;\n+      return res;\n+    }\n+  }\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<byte_size>::operator()(T volatile* dest,\n+                                                           T exchange_value,\n+                                                           atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<byte_size>::operator()(T volatile* dest,\n+                                                              T compare_value,\n+                                                              T exchange_value,\n+                                                              atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  if (order == memory_order_conservative) {\n+    T value = compare_value;\n+    FULL_MEM_BARRIER;\n+    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+    FULL_MEM_BARRIER;\n+    return value;\n+  } else {\n+    STATIC_ASSERT (\n+       \/\/ The modes that align with C++11 are intended to\n+       \/\/ follow the same semantics.\n+       memory_order_relaxed == __ATOMIC_RELAXED &&\n+       memory_order_acquire == __ATOMIC_ACQUIRE &&\n+       memory_order_release == __ATOMIC_RELEASE &&\n+       memory_order_acq_rel == __ATOMIC_ACQ_REL &&\n+       memory_order_seq_cst == __ATOMIC_SEQ_CST);\n+\n+    \/\/ Some sanity checking on the memory order. It makes no\n+    \/\/ sense to have a release operation for a store that never\n+    \/\/ happens.\n+    int failure_memory_order;\n+    switch (order) {\n+    case memory_order_release:\n+      failure_memory_order = memory_order_relaxed; break;\n+    case memory_order_acq_rel:\n+      failure_memory_order = memory_order_acquire; break;\n+    default:\n+      failure_memory_order = order;\n+    }\n+    assert(failure_memory_order <= order, \"must be\");\n+\n+    T value = compare_value;\n+    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                              order, failure_memory_order);\n+    return value;\n+  }\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n+{\n+  template <typename T>\n+  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }\n+};\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedStore<byte_size, RELEASE_X>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }\n+};\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }\n+};\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_ATOMICACCESS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/atomicAccess_bsd_aarch64.hpp","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -1,133 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n- * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP\n-#define OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP\n-\n-#include \"utilities\/debug.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n-\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    if (order == memory_order_relaxed) {\n-      return __atomic_add_fetch(dest, add_value, __ATOMIC_RELAXED);\n-    } else {\n-      D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n-      FULL_MEM_BARRIER;\n-      return res;\n-    }\n-  }\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-template<size_t byte_size>\n-template<typename T>\n-inline T Atomic::PlatformXchg<byte_size>::operator()(T volatile* dest,\n-                                                     T exchange_value,\n-                                                     atomic_memory_order order) const {\n-  STATIC_ASSERT(byte_size == sizeof(T));\n-  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELEASE);\n-  FULL_MEM_BARRIER;\n-  return res;\n-}\n-\n-template<size_t byte_size>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T volatile* dest,\n-                                                        T compare_value,\n-                                                        T exchange_value,\n-                                                        atomic_memory_order order) const {\n-  STATIC_ASSERT(byte_size == sizeof(T));\n-  if (order == memory_order_conservative) {\n-    T value = compare_value;\n-    FULL_MEM_BARRIER;\n-    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n-                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-    FULL_MEM_BARRIER;\n-    return value;\n-  } else {\n-    STATIC_ASSERT (\n-       \/\/ The modes that align with C++11 are intended to\n-       \/\/ follow the same semantics.\n-       memory_order_relaxed == __ATOMIC_RELAXED &&\n-       memory_order_acquire == __ATOMIC_ACQUIRE &&\n-       memory_order_release == __ATOMIC_RELEASE &&\n-       memory_order_acq_rel == __ATOMIC_ACQ_REL &&\n-       memory_order_seq_cst == __ATOMIC_SEQ_CST);\n-\n-    \/\/ Some sanity checking on the memory order. It makes no\n-    \/\/ sense to have a release operation for a store that never\n-    \/\/ happens.\n-    int failure_memory_order;\n-    switch (order) {\n-    case memory_order_release:\n-      failure_memory_order = memory_order_relaxed; break;\n-    case memory_order_acq_rel:\n-      failure_memory_order = memory_order_acquire; break;\n-    default:\n-      failure_memory_order = order;\n-    }\n-    assert(failure_memory_order <= order, \"must be\");\n-\n-    T value = compare_value;\n-    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n-                              order, failure_memory_order);\n-    return value;\n-  }\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n-{\n-  template <typename T>\n-  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }\n-};\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }\n-};\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }\n-};\n-\n-\n-#endif \/\/ OS_CPU_BSD_AARCH64_ATOMIC_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/atomic_bsd_aarch64.hpp","additions":0,"deletions":133,"binary":false,"changes":133,"status":"deleted"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_X86_ATOMICACCESS_BSD_X86_HPP\n+#define OS_CPU_BSD_X86_ATOMICACCESS_BSD_X86_HPP\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order \/* order *\/) const;\n+\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return fetch_then_add(dest, add_value, order) + add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::fetch_then_add(D volatile* dest, I add_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+  D old_value;\n+  __asm__ volatile (  \"lock xaddl %0,(%2)\"\n+                    : \"=r\" (old_value)\n+                    : \"0\" (add_value), \"r\" (dest)\n+                    : \"cc\", \"memory\");\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  __asm__ volatile (  \"xchgl (%2),%0\"\n+                    : \"=r\" (exchange_value)\n+                    : \"0\" (exchange_value), \"r\" (dest)\n+                    : \"memory\");\n+  return exchange_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<1>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+  __asm__ volatile (  \"lock cmpxchgb %1,(%3)\"\n+                    : \"=a\" (exchange_value)\n+                    : \"q\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n+                    : \"cc\", \"memory\");\n+  return exchange_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  __asm__ volatile (  \"lock cmpxchgl %1,(%3)\"\n+                    : \"=a\" (exchange_value)\n+                    : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n+                    : \"cc\", \"memory\");\n+  return exchange_value;\n+}\n+\n+#ifdef AMD64\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::fetch_then_add(D volatile* dest, I add_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  D old_value;\n+  __asm__ __volatile__ (  \"lock xaddq %0,(%2)\"\n+                        : \"=r\" (old_value)\n+                        : \"0\" (add_value), \"r\" (dest)\n+                        : \"cc\", \"memory\");\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  __asm__ __volatile__ (\"xchgq (%2),%0\"\n+                        : \"=r\" (exchange_value)\n+                        : \"0\" (exchange_value), \"r\" (dest)\n+                        : \"memory\");\n+  return exchange_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  __asm__ __volatile__ (  \"lock cmpxchgq %1,(%3)\"\n+                        : \"=a\" (exchange_value)\n+                        : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n+                        : \"cc\", \"memory\");\n+  return exchange_value;\n+}\n+\n+#else \/\/ !AMD64\n+\n+extern \"C\" {\n+  \/\/ defined in bsd_x86.s\n+  int64_t _Atomic_cmpxchg_long(int64_t, volatile int64_t*, int64_t);\n+  void _Atomic_move_long(const volatile int64_t* src, volatile int64_t* dst);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  return cmpxchg_using_helper<int64_t>(_Atomic_cmpxchg_long, dest, compare_value, exchange_value);\n+}\n+\n+\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n+template<>\n+struct AtomicAccess::PlatformXchg<8> : AtomicAccess::XchgUsingCmpxchg<8> {};\n+\n+\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n+template<>\n+struct AtomicAccess::PlatformAdd<8> : AtomicAccess::AddUsingCmpxchg<8> {};\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformLoad<8>::operator()(T const volatile* src) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  volatile int64_t dest;\n+  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(src), reinterpret_cast<volatile int64_t*>(&dest));\n+  return PrimitiveConversions::cast<T>(dest);\n+}\n+\n+template<>\n+template<typename T>\n+inline void AtomicAccess::PlatformStore<8>::operator()(T volatile* dest,\n+                                                       T store_value) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(&store_value), reinterpret_cast<volatile int64_t*>(dest));\n+}\n+\n+#endif \/\/ AMD64\n+\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<1, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgb (%2),%0\"\n+                      : \"=q\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<2, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgw (%2),%0\"\n+                      : \"=r\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<4, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgl (%2),%0\"\n+                      : \"=r\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+\n+#ifdef AMD64\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<8, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgq (%2), %0\"\n+                      : \"=r\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+#endif \/\/ AMD64\n+\n+#endif \/\/ OS_CPU_BSD_X86_ATOMICACCESS_BSD_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomicAccess_bsd_x86.hpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -1,233 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_BSD_X86_ATOMIC_BSD_X86_HPP\n-#define OS_CPU_BSD_X86_ATOMIC_BSD_X86_HPP\n-\n-\/\/ Implementation of class atomic\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order \/* order *\/) const;\n-\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return fetch_then_add(dest, add_value, order) + add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::fetch_then_add(D volatile* dest, I add_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-  D old_value;\n-  __asm__ volatile (  \"lock xaddl %0,(%2)\"\n-                    : \"=r\" (old_value)\n-                    : \"0\" (add_value), \"r\" (dest)\n-                    : \"cc\", \"memory\");\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  __asm__ volatile (  \"xchgl (%2),%0\"\n-                    : \"=r\" (exchange_value)\n-                    : \"0\" (exchange_value), \"r\" (dest)\n-                    : \"memory\");\n-  return exchange_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(1 == sizeof(T));\n-  __asm__ volatile (  \"lock cmpxchgb %1,(%3)\"\n-                    : \"=a\" (exchange_value)\n-                    : \"q\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n-                    : \"cc\", \"memory\");\n-  return exchange_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  __asm__ volatile (  \"lock cmpxchgl %1,(%3)\"\n-                    : \"=a\" (exchange_value)\n-                    : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n-                    : \"cc\", \"memory\");\n-  return exchange_value;\n-}\n-\n-#ifdef AMD64\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::fetch_then_add(D volatile* dest, I add_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-  D old_value;\n-  __asm__ __volatile__ (  \"lock xaddq %0,(%2)\"\n-                        : \"=r\" (old_value)\n-                        : \"0\" (add_value), \"r\" (dest)\n-                        : \"cc\", \"memory\");\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  __asm__ __volatile__ (\"xchgq (%2),%0\"\n-                        : \"=r\" (exchange_value)\n-                        : \"0\" (exchange_value), \"r\" (dest)\n-                        : \"memory\");\n-  return exchange_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  __asm__ __volatile__ (  \"lock cmpxchgq %1,(%3)\"\n-                        : \"=a\" (exchange_value)\n-                        : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n-                        : \"cc\", \"memory\");\n-  return exchange_value;\n-}\n-\n-#else \/\/ !AMD64\n-\n-extern \"C\" {\n-  \/\/ defined in bsd_x86.s\n-  int64_t _Atomic_cmpxchg_long(int64_t, volatile int64_t*, int64_t);\n-  void _Atomic_move_long(const volatile int64_t* src, volatile int64_t* dst);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  return cmpxchg_using_helper<int64_t>(_Atomic_cmpxchg_long, dest, compare_value, exchange_value);\n-}\n-\n-\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n-template<>\n-struct Atomic::PlatformXchg<8> : Atomic::XchgUsingCmpxchg<8> {};\n-\n-\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n-template<>\n-struct Atomic::PlatformAdd<8> : Atomic::AddUsingCmpxchg<8> {};\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  volatile int64_t dest;\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(src), reinterpret_cast<volatile int64_t*>(&dest));\n-  return PrimitiveConversions::cast<T>(dest);\n-}\n-\n-template<>\n-template<typename T>\n-inline void Atomic::PlatformStore<8>::operator()(T volatile* dest,\n-                                                 T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(&store_value), reinterpret_cast<volatile int64_t*>(dest));\n-}\n-\n-#endif \/\/ AMD64\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<1, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgb (%2),%0\"\n-                      : \"=q\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<2, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgw (%2),%0\"\n-                      : \"=r\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<4, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgl (%2),%0\"\n-                      : \"=r\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-\n-#ifdef AMD64\n-template<>\n-struct Atomic::PlatformOrderedStore<8, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgq (%2), %0\"\n-                      : \"=r\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-#endif \/\/ AMD64\n-\n-#endif \/\/ OS_CPU_BSD_X86_ATOMIC_BSD_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomic_bsd_x86.hpp","additions":0,"deletions":233,"binary":false,"changes":233,"status":"deleted"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright 2007, 2008, 2011, 2015, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_ZERO_ATOMICACCESS_BSD_ZERO_HPP\n+#define OS_CPU_BSD_ZERO_ATOMICACCESS_BSD_ZERO_HPP\n+\n+#include \"orderAccess_bsd_zero.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return result;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return result;\n+}\n+\n+\/\/ No direct support for cmpxchg of bytes; emulate using int.\n+template<>\n+struct AtomicAccess::PlatformCmpxchg<1> : AtomicAccess::CmpxchgByteUsingInt {};\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  T value = compare_value;\n+  FULL_MEM_BARRIER;\n+  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+\n+  T value = compare_value;\n+  FULL_MEM_BARRIER;\n+  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return value;\n+}\n+\n+\/\/ Atomically copy 64 bits of data\n+inline void atomic_copy64(const volatile void *src, volatile void *dst) {\n+  int64_t tmp;\n+  __atomic_load(reinterpret_cast<const volatile int64_t*>(src), &tmp, __ATOMIC_RELAXED);\n+  __atomic_store(reinterpret_cast<volatile int64_t*>(dst), &tmp, __ATOMIC_RELAXED);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformLoad<8>::operator()(T const volatile* src) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  T dest;\n+  __atomic_load(const_cast<T*>(src), &dest, __ATOMIC_RELAXED);\n+  return dest;\n+}\n+\n+template<>\n+template<typename T>\n+inline void AtomicAccess::PlatformStore<8>::operator()(T volatile* dest,\n+                                                       T store_value) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  __atomic_store(dest, &store_value, __ATOMIC_RELAXED);\n+}\n+\n+#endif \/\/ OS_CPU_BSD_ZERO_ATOMICACCESS_BSD_ZERO_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/atomicAccess_bsd_zero.hpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright 2007, 2008, 2011, 2015, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_BSD_ZERO_ATOMIC_BSD_ZERO_HPP\n-#define OS_CPU_BSD_ZERO_ATOMIC_BSD_ZERO_HPP\n-\n-#include \"orderAccess_bsd_zero.hpp\"\n-#include \"runtime\/os.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-\n-  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n-  FULL_MEM_BARRIER;\n-  return res;\n-}\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-\n-  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n-  FULL_MEM_BARRIER;\n-  return res;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  FULL_MEM_BARRIER;\n-  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return result;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  FULL_MEM_BARRIER;\n-  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return result;\n-}\n-\n-\/\/ No direct support for cmpxchg of bytes; emulate using int.\n-template<>\n-struct Atomic::PlatformCmpxchg<1> : Atomic::CmpxchgByteUsingInt {};\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  T value = compare_value;\n-  FULL_MEM_BARRIER;\n-  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n-                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-\n-  T value = compare_value;\n-  FULL_MEM_BARRIER;\n-  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n-                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return value;\n-}\n-\n-\/\/ Atomically copy 64 bits of data\n-inline void atomic_copy64(const volatile void *src, volatile void *dst) {\n-  int64_t tmp;\n-  __atomic_load(reinterpret_cast<const volatile int64_t*>(src), &tmp, __ATOMIC_RELAXED);\n-  __atomic_store(reinterpret_cast<volatile int64_t*>(dst), &tmp, __ATOMIC_RELAXED);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  T dest;\n-  __atomic_load(const_cast<T*>(src), &dest, __ATOMIC_RELAXED);\n-  return dest;\n-}\n-\n-template<>\n-template<typename T>\n-inline void Atomic::PlatformStore<8>::operator()(T volatile* dest,\n-                                                 T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  __atomic_store(dest, &store_value, __ATOMIC_RELAXED);\n-}\n-\n-#endif \/\/ OS_CPU_BSD_ZERO_ATOMIC_BSD_ZERO_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/atomic_bsd_zero.hpp","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"atomic_bsd_zero.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_AARCH64_ATOMICACCESS_LINUX_AARCH64_HPP\n+#define OS_CPU_LINUX_AARCH64_ATOMICACCESS_LINUX_AARCH64_HPP\n+\n+#include \"atomic_aarch64.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n+\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n+\n+\/\/ Call one of the stubs from C++. This uses the C calling convention,\n+\/\/ but this asm definition is used in order only to clobber the\n+\/\/ registers we use. If we called the stubs via an ABI call we'd have\n+\/\/ to save X0 - X18 and most of the vectors.\n+\/\/\n+\/\/ This really ought to be a template definition, but see GCC Bug\n+\/\/ 33661, template methods forget explicit local register asm\n+\/\/ vars. The problem is that register specifiers attached to local\n+\/\/ variables are ignored in any template function.\n+inline uint64_t bare_atomic_fastcall(address stub, volatile void *ptr, uint64_t arg1, uint64_t arg2 = 0) {\n+  register uint64_t reg0 __asm__(\"x0\") = (uint64_t)ptr;\n+  register uint64_t reg1 __asm__(\"x1\") = arg1;\n+  register uint64_t reg2 __asm__(\"x2\") = arg2;\n+  register uint64_t reg3 __asm__(\"x3\") = (uint64_t)stub;\n+  register uint64_t result __asm__(\"x0\");\n+  asm volatile(\/\/ \"stp x29, x30, [sp, #-16]!;\"\n+               \" blr %1;\"\n+               \/\/ \" ldp x29, x30, [sp], #16 \/\/ regs %0, %1, %2, %3, %4\"\n+               : \"=r\"(result), \"+r\"(reg3), \"+r\"(reg2)\n+               : \"r\"(reg1), \"0\"(reg0) : \"x8\", \"x9\", \"x30\", \"cc\", \"memory\");\n+  return result;\n+}\n+\n+template <typename F, typename D, typename T1>\n+inline D atomic_fastcall(F stub, volatile D *dest, T1 arg1) {\n+  return (D)bare_atomic_fastcall(CAST_FROM_FN_PTR(address, stub),\n+                                 dest, (uint64_t)arg1);\n+}\n+\n+template <typename F, typename D, typename T1, typename T2>\n+inline D atomic_fastcall(F stub, volatile D *dest, T1 arg1, T2 arg2) {\n+  return (D)bare_atomic_fastcall(CAST_FROM_FN_PTR(address, stub),\n+                                 dest, (uint64_t)arg1, (uint64_t)arg2);\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    D value = fetch_then_add(dest, add_value, order) + add_value;\n+    return value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::fetch_then_add(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+  aarch64_atomic_stub_t stub;\n+  switch (order) {\n+  case memory_order_relaxed:\n+    stub = aarch64_atomic_fetch_add_4_relaxed_impl; break;\n+  default:\n+    stub = aarch64_atomic_fetch_add_4_impl; break;\n+  }\n+  return atomic_fastcall(stub, dest, add_value);\n+}\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::fetch_then_add(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  aarch64_atomic_stub_t stub;\n+  switch (order) {\n+  case memory_order_relaxed:\n+    stub = aarch64_atomic_fetch_add_8_relaxed_impl; break;\n+  default:\n+    stub = aarch64_atomic_fetch_add_8_impl; break;\n+  }\n+  return atomic_fastcall(stub, dest, add_value);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  T old_value = atomic_fastcall(aarch64_atomic_xchg_4_impl, dest, exchange_value);\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest, T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  T old_value = atomic_fastcall(aarch64_atomic_xchg_8_impl, dest, exchange_value);\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<1>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+  aarch64_atomic_stub_t stub;\n+  switch (order) {\n+  case memory_order_relaxed:\n+    stub = aarch64_atomic_cmpxchg_1_relaxed_impl; break;\n+  default:\n+    stub = aarch64_atomic_cmpxchg_1_impl; break;\n+  }\n+\n+  return atomic_fastcall(stub, dest, compare_value, exchange_value);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  aarch64_atomic_stub_t stub;\n+  switch (order) {\n+  case memory_order_relaxed:\n+    stub = aarch64_atomic_cmpxchg_4_relaxed_impl; break;\n+  case memory_order_release:\n+    stub = aarch64_atomic_cmpxchg_4_release_impl; break;\n+  case memory_order_acq_rel:\n+  case memory_order_seq_cst:\n+    stub = aarch64_atomic_cmpxchg_4_seq_cst_impl; break;\n+  default:\n+    stub = aarch64_atomic_cmpxchg_4_impl; break;\n+  }\n+\n+  return atomic_fastcall(stub, dest, compare_value, exchange_value);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  aarch64_atomic_stub_t stub;\n+  switch (order) {\n+  case memory_order_relaxed:\n+    stub = aarch64_atomic_cmpxchg_8_relaxed_impl; break;\n+  case memory_order_release:\n+    stub = aarch64_atomic_cmpxchg_8_release_impl; break;\n+  case memory_order_acq_rel:\n+  case memory_order_seq_cst:\n+    stub = aarch64_atomic_cmpxchg_8_seq_cst_impl; break;\n+  default:\n+    stub = aarch64_atomic_cmpxchg_8_impl; break;\n+  }\n+\n+  return atomic_fastcall(stub, dest, compare_value, exchange_value);\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n+{\n+  template <typename T>\n+  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }\n+};\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedStore<byte_size, RELEASE_X>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }\n+};\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }\n+};\n+\n+#endif \/\/ OS_CPU_LINUX_AARCH64_ATOMICACCESS_LINUX_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomicAccess_linux_aarch64.hpp","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -1,220 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_AARCH64_ATOMIC_LINUX_AARCH64_HPP\n-#define OS_CPU_LINUX_AARCH64_ATOMIC_LINUX_AARCH64_HPP\n-\n-#include \"atomic_aarch64.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\n-\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n-\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n-\n-\/\/ Call one of the stubs from C++. This uses the C calling convention,\n-\/\/ but this asm definition is used in order only to clobber the\n-\/\/ registers we use. If we called the stubs via an ABI call we'd have\n-\/\/ to save X0 - X18 and most of the vectors.\n-\/\/\n-\/\/ This really ought to be a template definition, but see GCC Bug\n-\/\/ 33661, template methods forget explicit local register asm\n-\/\/ vars. The problem is that register specifiers attached to local\n-\/\/ variables are ignored in any template function.\n-inline uint64_t bare_atomic_fastcall(address stub, volatile void *ptr, uint64_t arg1, uint64_t arg2 = 0) {\n-  register uint64_t reg0 __asm__(\"x0\") = (uint64_t)ptr;\n-  register uint64_t reg1 __asm__(\"x1\") = arg1;\n-  register uint64_t reg2 __asm__(\"x2\") = arg2;\n-  register uint64_t reg3 __asm__(\"x3\") = (uint64_t)stub;\n-  register uint64_t result __asm__(\"x0\");\n-  asm volatile(\/\/ \"stp x29, x30, [sp, #-16]!;\"\n-               \" blr %1;\"\n-               \/\/ \" ldp x29, x30, [sp], #16 \/\/ regs %0, %1, %2, %3, %4\"\n-               : \"=r\"(result), \"+r\"(reg3), \"+r\"(reg2)\n-               : \"r\"(reg1), \"0\"(reg0) : \"x8\", \"x9\", \"x30\", \"cc\", \"memory\");\n-  return result;\n-}\n-\n-template <typename F, typename D, typename T1>\n-inline D atomic_fastcall(F stub, volatile D *dest, T1 arg1) {\n-  return (D)bare_atomic_fastcall(CAST_FROM_FN_PTR(address, stub),\n-                                 dest, (uint64_t)arg1);\n-}\n-\n-template <typename F, typename D, typename T1, typename T2>\n-inline D atomic_fastcall(F stub, volatile D *dest, T1 arg1, T2 arg2) {\n-  return (D)bare_atomic_fastcall(CAST_FROM_FN_PTR(address, stub),\n-                                 dest, (uint64_t)arg1, (uint64_t)arg2);\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    D value = fetch_then_add(dest, add_value, order) + add_value;\n-    return value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::fetch_then_add(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-  aarch64_atomic_stub_t stub;\n-  switch (order) {\n-  case memory_order_relaxed:\n-    stub = aarch64_atomic_fetch_add_4_relaxed_impl; break;\n-  default:\n-    stub = aarch64_atomic_fetch_add_4_impl; break;\n-  }\n-  return atomic_fastcall(stub, dest, add_value);\n-}\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::fetch_then_add(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-  aarch64_atomic_stub_t stub;\n-  switch (order) {\n-  case memory_order_relaxed:\n-    stub = aarch64_atomic_fetch_add_8_relaxed_impl; break;\n-  default:\n-    stub = aarch64_atomic_fetch_add_8_impl; break;\n-  }\n-  return atomic_fastcall(stub, dest, add_value);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  T old_value = atomic_fastcall(aarch64_atomic_xchg_4_impl, dest, exchange_value);\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest, T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  T old_value = atomic_fastcall(aarch64_atomic_xchg_8_impl, dest, exchange_value);\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(1 == sizeof(T));\n-  aarch64_atomic_stub_t stub;\n-  switch (order) {\n-  case memory_order_relaxed:\n-    stub = aarch64_atomic_cmpxchg_1_relaxed_impl; break;\n-  default:\n-    stub = aarch64_atomic_cmpxchg_1_impl; break;\n-  }\n-\n-  return atomic_fastcall(stub, dest, compare_value, exchange_value);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  aarch64_atomic_stub_t stub;\n-  switch (order) {\n-  case memory_order_relaxed:\n-    stub = aarch64_atomic_cmpxchg_4_relaxed_impl; break;\n-  case memory_order_release:\n-    stub = aarch64_atomic_cmpxchg_4_release_impl; break;\n-  case memory_order_acq_rel:\n-  case memory_order_seq_cst:\n-    stub = aarch64_atomic_cmpxchg_4_seq_cst_impl; break;\n-  default:\n-    stub = aarch64_atomic_cmpxchg_4_impl; break;\n-  }\n-\n-  return atomic_fastcall(stub, dest, compare_value, exchange_value);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  aarch64_atomic_stub_t stub;\n-  switch (order) {\n-  case memory_order_relaxed:\n-    stub = aarch64_atomic_cmpxchg_8_relaxed_impl; break;\n-  case memory_order_release:\n-    stub = aarch64_atomic_cmpxchg_8_release_impl; break;\n-  case memory_order_acq_rel:\n-  case memory_order_seq_cst:\n-    stub = aarch64_atomic_cmpxchg_8_seq_cst_impl; break;\n-  default:\n-    stub = aarch64_atomic_cmpxchg_8_impl; break;\n-  }\n-\n-  return atomic_fastcall(stub, dest, compare_value, exchange_value);\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n-{\n-  template <typename T>\n-  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }\n-};\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }\n-};\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }\n-};\n-\n-#endif \/\/ OS_CPU_LINUX_AARCH64_ATOMIC_LINUX_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.hpp","additions":0,"deletions":220,"binary":false,"changes":220,"status":"deleted"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_ARM_ATOMICACCESS_LINUX_ARM_HPP\n+#define OS_CPU_LINUX_ARM_ATOMICACCESS_LINUX_ARM_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+class ARMAtomicFuncs : AllStatic {\n+public:\n+  typedef int64_t (*cmpxchg_long_func_t)(int64_t, int64_t, volatile int64_t*);\n+  typedef int64_t (*load_long_func_t)(const volatile int64_t*);\n+  typedef void (*store_long_func_t)(int64_t, volatile int64_t*);\n+  typedef int32_t  (*atomic_add_func_t)(int32_t add_value, volatile int32_t *dest);\n+  typedef int32_t  (*atomic_xchg_func_t)(int32_t exchange_value, volatile int32_t *dest);\n+  typedef int32_t (*cmpxchg_func_t)(int32_t, int32_t, volatile int32_t*);\n+\n+  static cmpxchg_long_func_t  _cmpxchg_long_func;\n+  static load_long_func_t     _load_long_func;\n+  static store_long_func_t    _store_long_func;\n+  static atomic_add_func_t    _add_func;\n+  static atomic_xchg_func_t   _xchg_func;\n+  static cmpxchg_func_t       _cmpxchg_func;\n+\n+  static int64_t cmpxchg_long_bootstrap(int64_t, int64_t, volatile int64_t*);\n+\n+  static int64_t load_long_bootstrap(const volatile int64_t*);\n+\n+  static void store_long_bootstrap(int64_t, volatile int64_t*);\n+\n+  static int32_t  add_bootstrap(int32_t add_value, volatile int32_t *dest);\n+\n+  static int32_t  xchg_bootstrap(int32_t exchange_value, volatile int32_t *dest);\n+\n+  static int32_t  cmpxchg_bootstrap(int32_t compare_value,\n+                                    int32_t exchange_value,\n+                                    volatile int32_t *dest);\n+};\n+\n+\/*\n+ * Atomic long operations on 32-bit ARM\n+ * ARM v7 supports LDREXD\/STREXD synchronization instructions so no problem.\n+ * ARM < v7 does not have explicit 64 atomic load\/store capability.\n+ * However, gcc emits LDRD\/STRD instructions on v5te and LDM\/STM on v5t\n+ * when loading\/storing 64 bits.\n+ * For non-MP machines (which is all we support for ARM < v7)\n+ * under current Linux distros these instructions appear atomic.\n+ * See section A3.5.3 of ARM Architecture Reference Manual for ARM v7.\n+ * Also, for cmpxchg64, if ARM < v7 we check for cmpxchg64 support in the\n+ * Linux kernel using _kuser_helper_version. See entry-armv.S in the Linux\n+ * kernel source or kernel_user_helpers.txt in Linux Doc.\n+ *\/\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformLoad<8>::operator()(T const volatile* src) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  return PrimitiveConversions::cast<T>(\n+    (*ARMAtomicFuncs::_load_long_func)(reinterpret_cast<const volatile int64_t*>(src)));\n+}\n+\n+template<>\n+template<typename T>\n+inline void AtomicAccess::PlatformStore<8>::operator()(T volatile* dest,\n+                                                       T store_value) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  (*ARMAtomicFuncs::_store_long_func)(\n+    PrimitiveConversions::cast<int64_t>(store_value), reinterpret_cast<volatile int64_t*>(dest));\n+}\n+\n+\/\/ As per atomicAccess.hpp all read-modify-write operations have to provide two-way\n+\/\/ barriers semantics.\n+\/\/\n+\/\/ For ARMv7 we add explicit barriers in the stubs.\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+  return add_using_helper<int32_t>(ARMAtomicFuncs::_add_func, dest, add_value);\n+}\n+\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  return xchg_using_helper<int32_t>(ARMAtomicFuncs::_xchg_func, dest, exchange_value);\n+}\n+\n+\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n+template<>\n+struct AtomicAccess::PlatformXchg<8> : AtomicAccess::XchgUsingCmpxchg<8> {};\n+\n+\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n+template<>\n+struct AtomicAccess::PlatformAdd<8> : AtomicAccess::AddUsingCmpxchg<8> {};\n+\n+\/\/ The memory_order parameter is ignored - we always provide the strongest\/most-conservative ordering\n+\n+\/\/ No direct support for cmpxchg of bytes; emulate using int.\n+template<>\n+struct AtomicAccess::PlatformCmpxchg<1> : AtomicAccess::CmpxchgByteUsingInt {};\n+\n+\n+inline int32_t reorder_cmpxchg_func(int32_t exchange_value,\n+                                    int32_t volatile* dest,\n+                                    int32_t compare_value) {\n+  \/\/ Warning:  Arguments are swapped to avoid moving them for kernel call\n+  return (*ARMAtomicFuncs::_cmpxchg_func)(compare_value, exchange_value, dest);\n+}\n+\n+inline int64_t reorder_cmpxchg_long_func(int64_t exchange_value,\n+                                         int64_t volatile* dest,\n+                                         int64_t compare_value) {\n+  \/\/ Warning:  Arguments are swapped to avoid moving them for kernel call\n+  return (*ARMAtomicFuncs::_cmpxchg_long_func)(compare_value, exchange_value, dest);\n+}\n+\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  return cmpxchg_using_helper<int32_t>(reorder_cmpxchg_func, dest, compare_value, exchange_value);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  return cmpxchg_using_helper<int64_t>(reorder_cmpxchg_long_func, dest, compare_value, exchange_value);\n+}\n+\n+#endif \/\/ OS_CPU_LINUX_ARM_ATOMICACCESS_LINUX_ARM_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomicAccess_linux_arm.hpp","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP\n-#define OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\n-class ARMAtomicFuncs : AllStatic {\n-public:\n-  typedef int64_t (*cmpxchg_long_func_t)(int64_t, int64_t, volatile int64_t*);\n-  typedef int64_t (*load_long_func_t)(const volatile int64_t*);\n-  typedef void (*store_long_func_t)(int64_t, volatile int64_t*);\n-  typedef int32_t  (*atomic_add_func_t)(int32_t add_value, volatile int32_t *dest);\n-  typedef int32_t  (*atomic_xchg_func_t)(int32_t exchange_value, volatile int32_t *dest);\n-  typedef int32_t (*cmpxchg_func_t)(int32_t, int32_t, volatile int32_t*);\n-\n-  static cmpxchg_long_func_t  _cmpxchg_long_func;\n-  static load_long_func_t     _load_long_func;\n-  static store_long_func_t    _store_long_func;\n-  static atomic_add_func_t    _add_func;\n-  static atomic_xchg_func_t   _xchg_func;\n-  static cmpxchg_func_t       _cmpxchg_func;\n-\n-  static int64_t cmpxchg_long_bootstrap(int64_t, int64_t, volatile int64_t*);\n-\n-  static int64_t load_long_bootstrap(const volatile int64_t*);\n-\n-  static void store_long_bootstrap(int64_t, volatile int64_t*);\n-\n-  static int32_t  add_bootstrap(int32_t add_value, volatile int32_t *dest);\n-\n-  static int32_t  xchg_bootstrap(int32_t exchange_value, volatile int32_t *dest);\n-\n-  static int32_t  cmpxchg_bootstrap(int32_t compare_value,\n-                                    int32_t exchange_value,\n-                                    volatile int32_t *dest);\n-};\n-\n-\/*\n- * Atomic long operations on 32-bit ARM\n- * ARM v7 supports LDREXD\/STREXD synchronization instructions so no problem.\n- * ARM < v7 does not have explicit 64 atomic load\/store capability.\n- * However, gcc emits LDRD\/STRD instructions on v5te and LDM\/STM on v5t\n- * when loading\/storing 64 bits.\n- * For non-MP machines (which is all we support for ARM < v7)\n- * under current Linux distros these instructions appear atomic.\n- * See section A3.5.3 of ARM Architecture Reference Manual for ARM v7.\n- * Also, for cmpxchg64, if ARM < v7 we check for cmpxchg64 support in the\n- * Linux kernel using _kuser_helper_version. See entry-armv.S in the Linux\n- * kernel source or kernel_user_helpers.txt in Linux Doc.\n- *\/\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  return PrimitiveConversions::cast<T>(\n-    (*ARMAtomicFuncs::_load_long_func)(reinterpret_cast<const volatile int64_t*>(src)));\n-}\n-\n-template<>\n-template<typename T>\n-inline void Atomic::PlatformStore<8>::operator()(T volatile* dest,\n-                                                 T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  (*ARMAtomicFuncs::_store_long_func)(\n-    PrimitiveConversions::cast<int64_t>(store_value), reinterpret_cast<volatile int64_t*>(dest));\n-}\n-\n-\/\/ As per atomic.hpp all read-modify-write operations have to provide two-way\n-\/\/ barriers semantics.\n-\/\/\n-\/\/ For ARMv7 we add explicit barriers in the stubs.\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n-                                               atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-  return add_using_helper<int32_t>(ARMAtomicFuncs::_add_func, dest, add_value);\n-}\n-\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  return xchg_using_helper<int32_t>(ARMAtomicFuncs::_xchg_func, dest, exchange_value);\n-}\n-\n-\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n-template<>\n-struct Atomic::PlatformXchg<8> : Atomic::XchgUsingCmpxchg<8> {};\n-\n-\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n-template<>\n-struct Atomic::PlatformAdd<8> : Atomic::AddUsingCmpxchg<8> {};\n-\n-\/\/ The memory_order parameter is ignored - we always provide the strongest\/most-conservative ordering\n-\n-\/\/ No direct support for cmpxchg of bytes; emulate using int.\n-template<>\n-struct Atomic::PlatformCmpxchg<1> : Atomic::CmpxchgByteUsingInt {};\n-\n-\n-inline int32_t reorder_cmpxchg_func(int32_t exchange_value,\n-                                    int32_t volatile* dest,\n-                                    int32_t compare_value) {\n-  \/\/ Warning:  Arguments are swapped to avoid moving them for kernel call\n-  return (*ARMAtomicFuncs::_cmpxchg_func)(compare_value, exchange_value, dest);\n-}\n-\n-inline int64_t reorder_cmpxchg_long_func(int64_t exchange_value,\n-                                         int64_t volatile* dest,\n-                                         int64_t compare_value) {\n-  \/\/ Warning:  Arguments are swapped to avoid moving them for kernel call\n-  return (*ARMAtomicFuncs::_cmpxchg_long_func)(compare_value, exchange_value, dest);\n-}\n-\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  return cmpxchg_using_helper<int32_t>(reorder_cmpxchg_func, dest, compare_value, exchange_value);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  return cmpxchg_using_helper<int64_t>(reorder_cmpxchg_long_func, dest, compare_value, exchange_value);\n-}\n-\n-#endif \/\/ OS_CPU_LINUX_ARM_ATOMIC_LINUX_ARM_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"},{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_PPC_ATOMICACCESS_LINUX_PPC_HPP\n+#define OS_CPU_LINUX_PPC_ATOMICACCESS_LINUX_PPC_HPP\n+\n+#ifndef PPC64\n+#error \"Atomic currently only implemented for PPC64\"\n+#endif\n+\n+#include \"orderAccess_linux_ppc.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+\/\/\n+\/\/ machine barrier instructions:\n+\/\/\n+\/\/ - sync            two-way memory barrier, aka fence\n+\/\/ - lwsync          orders  Store|Store,\n+\/\/                            Load|Store,\n+\/\/                            Load|Load,\n+\/\/                   but not Store|Load\n+\/\/ - eieio           orders memory accesses for device memory (only)\n+\/\/ - isync           invalidates speculatively executed instructions\n+\/\/                   From the POWER ISA 2.06 documentation:\n+\/\/                    \"[...] an isync instruction prevents the execution of\n+\/\/                   instructions following the isync until instructions\n+\/\/                   preceding the isync have completed, [...]\"\n+\/\/                   From IBM's AIX assembler reference:\n+\/\/                    \"The isync [...] instructions causes the processor to\n+\/\/                   refetch any instructions that might have been fetched\n+\/\/                   prior to the isync instruction. The instruction isync\n+\/\/                   causes the processor to wait for all previous instructions\n+\/\/                   to complete. Then any instructions already fetched are\n+\/\/                   discarded and instruction processing continues in the\n+\/\/                   environment established by the previous instructions.\"\n+\/\/\n+\/\/ semantic barrier instructions:\n+\/\/ (as defined in orderAccess.hpp)\n+\/\/\n+\/\/ - release         orders Store|Store,       (maps to lwsync)\n+\/\/                           Load|Store\n+\/\/ - acquire         orders  Load|Store,       (maps to lwsync)\n+\/\/                           Load|Load\n+\/\/ - fence           orders Store|Store,       (maps to sync)\n+\/\/                           Load|Store,\n+\/\/                           Load|Load,\n+\/\/                          Store|Load\n+\/\/\n+\n+inline void pre_membar(atomic_memory_order order) {\n+  switch (order) {\n+    case memory_order_relaxed:\n+    case memory_order_acquire: break;\n+    case memory_order_release:\n+    case memory_order_acq_rel: __asm__ __volatile__ (\"lwsync\" : : : \"memory\"); break;\n+    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n+  }\n+}\n+\n+inline void post_membar(atomic_memory_order order) {\n+  switch (order) {\n+    case memory_order_relaxed:\n+    case memory_order_release: break;\n+    case memory_order_acquire:\n+    case memory_order_acq_rel: __asm__ __volatile__ (\"isync\"  : : : \"memory\"); break;\n+    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n+  }\n+}\n+\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D result;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \"1: lwarx   %0,  0, %2    \\n\"\n+    \"   add     %0, %0, %1    \\n\"\n+    \"   stwcx.  %0,  0, %2    \\n\"\n+    \"   bne-    1b            \\n\"\n+    : \/*%0*\/\"=&r\" (result)\n+    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n+    : \"cc\", \"memory\" );\n+\n+  post_membar(order);\n+\n+  return result;\n+}\n+\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+\n+  D result;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \"1: ldarx   %0,  0, %2    \\n\"\n+    \"   add     %0, %0, %1    \\n\"\n+    \"   stdcx.  %0,  0, %2    \\n\"\n+    \"   bne-    1b            \\n\"\n+    : \/*%0*\/\"=&r\" (result)\n+    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n+    : \"cc\", \"memory\" );\n+\n+  post_membar(order);\n+\n+  return result;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  \/\/ Note that xchg doesn't necessarily do an acquire\n+  \/\/ (see synchronizer.cpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  \/\/ Note that xchg doesn't necessarily do an acquire\n+  \/\/ (see synchronizer.cpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<1>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+\n+  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n+  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n+  \/\/ specified otherwise (see atomicAccess.hpp).\n+\n+  \/\/ Using 32 bit internally.\n+  unsigned int old_value, loaded_value;\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* atomic loop *\/\n+    \"1:                                                   \\n\"\n+    \"   lbarx   %[old_value], 0, %[dest]                  \\n\"\n+    \/* extract byte and compare *\/\n+    \"   cmpw    %[compare_value], %[old_value]            \\n\"\n+    \"   bne-    2f                                        \\n\"\n+    \/* replace byte and try to store *\/\n+    \"   stbcx.  %[exchange_value], 0, %[dest]             \\n\"\n+    \"   bne-    1b                                        \\n\"\n+    \/* exit *\/\n+    \"2:                                                   \\n\"\n+    \/* out *\/\n+    : [old_value]           \"=&r\"   (old_value),\n+      [loaded_value]        \"=&r\"   (loaded_value),\n+                            \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return PrimitiveConversions::cast<T>((unsigned char)old_value);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+\n+  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n+  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n+  \/\/ specified otherwise (see atomicAccess.hpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* simple guard *\/\n+    \"   lwz     %[old_value], 0(%[dest])                \\n\"\n+    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+\n+  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n+  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n+  \/\/ specified otherwise (see atomicAccess.hpp).\n+\n+  T old_value;\n+  const uint64_t zero = 0;\n+\n+  pre_membar(order);\n+\n+  __asm__ __volatile__ (\n+    \/* simple guard *\/\n+    \"   ld      %[old_value], 0(%[dest])                \\n\"\n+    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \/* atomic loop *\/\n+    \"1:                                                 \\n\"\n+    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n+    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n+    \"   bne-    2f                                      \\n\"\n+    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n+    \"   bne-    1b                                      \\n\"\n+    \/* exit *\/\n+    \"2:                                                 \\n\"\n+    \/* out *\/\n+    : [old_value]       \"=&r\"   (old_value),\n+                        \"=m\"    (*dest)\n+    \/* in *\/\n+    : [dest]            \"b\"     (dest),\n+      [zero]            \"r\"     (zero),\n+      [compare_value]   \"r\"     (compare_value),\n+      [exchange_value]  \"r\"     (exchange_value),\n+                        \"m\"     (*dest)\n+    \/* clobber *\/\n+    : \"cc\",\n+      \"memory\"\n+    );\n+\n+  post_membar(order);\n+\n+  return old_value;\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n+{\n+  template <typename T>\n+  T operator()(const volatile T* p) const {\n+    T t = AtomicAccess::load(p);\n+    \/\/ Use twi-isync for load_acquire (faster than lwsync).\n+    __asm__ __volatile__ (\"twi 0,%0,0\\n isync\\n\" : : \"r\" (t) : \"memory\");\n+    return t;\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_LINUX_PPC_ATOMICACCESS_LINUX_PPC_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/atomicAccess_linux_ppc.hpp","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -1,395 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_PPC_ATOMIC_LINUX_PPC_HPP\n-#define OS_CPU_LINUX_PPC_ATOMIC_LINUX_PPC_HPP\n-\n-#ifndef PPC64\n-#error \"Atomic currently only implemented for PPC64\"\n-#endif\n-\n-#include \"orderAccess_linux_ppc.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\n-\/\/\n-\/\/ machine barrier instructions:\n-\/\/\n-\/\/ - sync            two-way memory barrier, aka fence\n-\/\/ - lwsync          orders  Store|Store,\n-\/\/                            Load|Store,\n-\/\/                            Load|Load,\n-\/\/                   but not Store|Load\n-\/\/ - eieio           orders memory accesses for device memory (only)\n-\/\/ - isync           invalidates speculatively executed instructions\n-\/\/                   From the POWER ISA 2.06 documentation:\n-\/\/                    \"[...] an isync instruction prevents the execution of\n-\/\/                   instructions following the isync until instructions\n-\/\/                   preceding the isync have completed, [...]\"\n-\/\/                   From IBM's AIX assembler reference:\n-\/\/                    \"The isync [...] instructions causes the processor to\n-\/\/                   refetch any instructions that might have been fetched\n-\/\/                   prior to the isync instruction. The instruction isync\n-\/\/                   causes the processor to wait for all previous instructions\n-\/\/                   to complete. Then any instructions already fetched are\n-\/\/                   discarded and instruction processing continues in the\n-\/\/                   environment established by the previous instructions.\"\n-\/\/\n-\/\/ semantic barrier instructions:\n-\/\/ (as defined in orderAccess.hpp)\n-\/\/\n-\/\/ - release         orders Store|Store,       (maps to lwsync)\n-\/\/                           Load|Store\n-\/\/ - acquire         orders  Load|Store,       (maps to lwsync)\n-\/\/                           Load|Load\n-\/\/ - fence           orders Store|Store,       (maps to sync)\n-\/\/                           Load|Store,\n-\/\/                           Load|Load,\n-\/\/                          Store|Load\n-\/\/\n-\n-inline void pre_membar(atomic_memory_order order) {\n-  switch (order) {\n-    case memory_order_relaxed:\n-    case memory_order_acquire: break;\n-    case memory_order_release:\n-    case memory_order_acq_rel: __asm__ __volatile__ (\"lwsync\" : : : \"memory\"); break;\n-    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n-  }\n-}\n-\n-inline void post_membar(atomic_memory_order order) {\n-  switch (order) {\n-    case memory_order_relaxed:\n-    case memory_order_release: break;\n-    case memory_order_acquire:\n-    case memory_order_acq_rel: __asm__ __volatile__ (\"isync\"  : : : \"memory\"); break;\n-    default \/*conservative*\/ : __asm__ __volatile__ (\"sync\"   : : : \"memory\"); break;\n-  }\n-}\n-\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-\n-  D result;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \"1: lwarx   %0,  0, %2    \\n\"\n-    \"   add     %0, %0, %1    \\n\"\n-    \"   stwcx.  %0,  0, %2    \\n\"\n-    \"   bne-    1b            \\n\"\n-    : \/*%0*\/\"=&r\" (result)\n-    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n-    : \"cc\", \"memory\" );\n-\n-  post_membar(order);\n-\n-  return result;\n-}\n-\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-\n-  D result;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \"1: ldarx   %0,  0, %2    \\n\"\n-    \"   add     %0, %0, %1    \\n\"\n-    \"   stdcx.  %0,  0, %2    \\n\"\n-    \"   bne-    1b            \\n\"\n-    : \/*%0*\/\"=&r\" (result)\n-    : \/*%1*\/\"r\" (add_value), \/*%2*\/\"r\" (dest)\n-    : \"cc\", \"memory\" );\n-\n-  post_membar(order);\n-\n-  return result;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  \/\/ Note that xchg doesn't necessarily do an acquire\n-  \/\/ (see synchronizer.cpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  \/\/ Note that xchg doesn't necessarily do an acquire\n-  \/\/ (see synchronizer.cpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(1 == sizeof(T));\n-\n-  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n-  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n-  \/\/ specified otherwise (see atomic.hpp).\n-\n-  \/\/ Using 32 bit internally.\n-  unsigned int old_value, loaded_value;\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* atomic loop *\/\n-    \"1:                                                   \\n\"\n-    \"   lbarx   %[old_value], 0, %[dest]                  \\n\"\n-    \/* extract byte and compare *\/\n-    \"   cmpw    %[compare_value], %[old_value]            \\n\"\n-    \"   bne-    2f                                        \\n\"\n-    \/* replace byte and try to store *\/\n-    \"   stbcx.  %[exchange_value], 0, %[dest]             \\n\"\n-    \"   bne-    1b                                        \\n\"\n-    \/* exit *\/\n-    \"2:                                                   \\n\"\n-    \/* out *\/\n-    : [old_value]           \"=&r\"   (old_value),\n-      [loaded_value]        \"=&r\"   (loaded_value),\n-                            \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [compare_value]   \"r\"     (compare_value),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return PrimitiveConversions::cast<T>((unsigned char)old_value);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-\n-  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n-  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n-  \/\/ specified otherwise (see atomic.hpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* simple guard *\/\n-    \"   lwz     %[old_value], 0(%[dest])                \\n\"\n-    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   lwarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   cmpw    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \"   stwcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [compare_value]   \"r\"     (compare_value),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-\n-  \/\/ Note that cmpxchg guarantees a two-way memory barrier across\n-  \/\/ the cmpxchg, so it's really a 'fence_cmpxchg_fence' if not\n-  \/\/ specified otherwise (see atomic.hpp).\n-\n-  T old_value;\n-  const uint64_t zero = 0;\n-\n-  pre_membar(order);\n-\n-  __asm__ __volatile__ (\n-    \/* simple guard *\/\n-    \"   ld      %[old_value], 0(%[dest])                \\n\"\n-    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \/* atomic loop *\/\n-    \"1:                                                 \\n\"\n-    \"   ldarx   %[old_value], %[dest], %[zero]          \\n\"\n-    \"   cmpd    %[compare_value], %[old_value]          \\n\"\n-    \"   bne-    2f                                      \\n\"\n-    \"   stdcx.  %[exchange_value], %[dest], %[zero]     \\n\"\n-    \"   bne-    1b                                      \\n\"\n-    \/* exit *\/\n-    \"2:                                                 \\n\"\n-    \/* out *\/\n-    : [old_value]       \"=&r\"   (old_value),\n-                        \"=m\"    (*dest)\n-    \/* in *\/\n-    : [dest]            \"b\"     (dest),\n-      [zero]            \"r\"     (zero),\n-      [compare_value]   \"r\"     (compare_value),\n-      [exchange_value]  \"r\"     (exchange_value),\n-                        \"m\"     (*dest)\n-    \/* clobber *\/\n-    : \"cc\",\n-      \"memory\"\n-    );\n-\n-  post_membar(order);\n-\n-  return old_value;\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n-{\n-  template <typename T>\n-  T operator()(const volatile T* p) const {\n-    T t = Atomic::load(p);\n-    \/\/ Use twi-isync for load_acquire (faster than lwsync).\n-    __asm__ __volatile__ (\"twi 0,%0,0\\n isync\\n\" : : \"r\" (t) : \"memory\");\n-    return t;\n-  }\n-};\n-\n-#endif \/\/ OS_CPU_LINUX_PPC_ATOMIC_LINUX_PPC_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/atomic_linux_ppc.hpp","additions":0,"deletions":395,"binary":false,"changes":395,"status":"deleted"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_RISCV_ATOMICACCESS_LINUX_RISCV_HPP\n+#define OS_CPU_LINUX_RISCV_ATOMICACCESS_LINUX_RISCV_HPP\n+\n+#include \"runtime\/vm_version.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n+\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n+\n+#if defined(__clang_major__)\n+#define FULL_COMPILER_ATOMIC_SUPPORT\n+#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ > 2))\n+#define FULL_COMPILER_ATOMIC_SUPPORT\n+#endif\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n+\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+    \/\/ If we add add and fetch for sub word and are using older compiler\n+    \/\/ it must be added here due to not using lib atomic.\n+    STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n+    if (order != memory_order_relaxed) {\n+      FULL_MEM_BARRIER;\n+    }\n+\n+    D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELAXED);\n+\n+    if (order != memory_order_relaxed) {\n+      FULL_MEM_BARRIER;\n+    }\n+    return res;\n+  }\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<1>::operator()(T volatile* dest __attribute__((unused)),\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  uint32_t volatile* aligned_dst = (uint32_t volatile*)(((uintptr_t)dest) & (~((uintptr_t)0x3)));\n+  int shift = 8 * (((uintptr_t)dest) - ((uintptr_t)aligned_dst)); \/\/ 0, 8, 16, 24\n+\n+  uint64_t mask = 0xfful << shift; \/\/ 0x00000000..FF..\n+  uint64_t remask = ~mask;         \/\/ 0xFFFFFFFF..00..\n+\n+  uint64_t w_cv = ((uint64_t)(unsigned char)compare_value) << shift;  \/\/ widen to 64-bit 0x00000000..CC..\n+  uint64_t w_ev = ((uint64_t)(unsigned char)exchange_value) << shift; \/\/ widen to 64-bit 0x00000000..EE..\n+\n+  uint64_t old_value;\n+  uint64_t rc_temp;\n+\n+  __asm__ __volatile__ (\n+    \"1:  lr.w      %0, %2      \\n\\t\"\n+    \"    and       %1, %0, %5  \\n\\t\" \/\/ ignore unrelated bytes and widen to 64-bit 0x00000000..XX..\n+    \"    bne       %1, %3, 2f  \\n\\t\" \/\/ compare 64-bit w_cv\n+    \"    and       %1, %0, %6  \\n\\t\" \/\/ remove old byte\n+    \"    or        %1, %1, %4  \\n\\t\" \/\/ add new byte\n+    \"    sc.w      %1, %1, %2  \\n\\t\" \/\/ store new word\n+    \"    bnez      %1, 1b      \\n\\t\"\n+    \"2:                        \\n\\t\"\n+    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*aligned_dst)\n+    : \/*%3*\/\"r\" (w_cv), \/*%4*\/\"r\" (w_ev), \/*%5*\/\"r\" (mask), \/*%6*\/\"r\" (remask)\n+    : \"memory\" );\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  return (T)((old_value & mask) >> shift);\n+}\n+#endif\n+\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+\/\/ The implementation of `__atomic_compare_exchange` lacks sign extensions\n+\/\/ in GCC 13.2 and lower when using with 32-bit unsigned integers on RV64,\n+\/\/ so we should implement it manually.\n+\/\/ GCC bug: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=114130.\n+\/\/ See also JDK-8326936.\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest __attribute__((unused)),\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+\n+  int32_t old_value;\n+  uint64_t rc_temp;\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  __asm__ __volatile__ (\n+    \"1:  lr.w      %0, %2      \\n\\t\"\n+    \"    bne       %0, %3, 2f  \\n\\t\"\n+    \"    sc.w      %1, %4, %2  \\n\\t\"\n+    \"    bnez      %1, 1b      \\n\\t\"\n+    \"2:                        \\n\\t\"\n+    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*dest)\n+    : \/*%3*\/\"r\" ((int64_t)(int32_t)compare_value), \/*%4*\/\"r\" (exchange_value)\n+    : \"memory\" );\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  return (T)old_value;\n+}\n+#endif\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<byte_size>::operator()(T volatile* dest,\n+                                                           T exchange_value,\n+                                                           atomic_memory_order order) const {\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+  \/\/ If we add xchg for sub word and are using older compiler\n+  \/\/ it must be added here due to not using lib atomic.\n+  STATIC_ASSERT(byte_size >= 4);\n+#endif\n+\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  return res;\n+}\n+\n+\/\/ __attribute__((unused)) on dest is to get rid of spurious GCC warnings.\n+template<size_t byte_size>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<byte_size>::operator()(T volatile* dest __attribute__((unused)),\n+                                                              T compare_value,\n+                                                              T exchange_value,\n+                                                              atomic_memory_order order) const {\n+\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+  STATIC_ASSERT(byte_size > 4);\n+#endif\n+\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  __atomic_compare_exchange(dest, &compare_value, &exchange_value, \/* weak *\/ false,\n+                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  return compare_value;\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n+{\n+  template <typename T>\n+  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }\n+};\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedStore<byte_size, RELEASE_X>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }\n+};\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }\n+};\n+\n+#undef FULL_COMPILER_ATOMIC_SUPPORT\n+\n+#endif \/\/ OS_CPU_LINUX_RISCV_ATOMICACCESS_LINUX_RISCV_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomicAccess_linux_riscv.hpp","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_RISCV_ATOMIC_LINUX_RISCV_HPP\n-#define OS_CPU_LINUX_RISCV_ATOMIC_LINUX_RISCV_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\n-\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n-\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n-\n-#if defined(__clang_major__)\n-#define FULL_COMPILER_ATOMIC_SUPPORT\n-#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ > 2))\n-#define FULL_COMPILER_ATOMIC_SUPPORT\n-#endif\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n-\n-#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n-    \/\/ If we add add and fetch for sub word and are using older compiler\n-    \/\/ it must be added here due to not using lib atomic.\n-    STATIC_ASSERT(byte_size >= 4);\n-#endif\n-\n-    if (order != memory_order_relaxed) {\n-      FULL_MEM_BARRIER;\n-    }\n-\n-    D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELAXED);\n-\n-    if (order != memory_order_relaxed) {\n-      FULL_MEM_BARRIER;\n-    }\n-    return res;\n-  }\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest __attribute__((unused)),\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(1 == sizeof(T));\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-\n-  uint32_t volatile* aligned_dst = (uint32_t volatile*)(((uintptr_t)dest) & (~((uintptr_t)0x3)));\n-  int shift = 8 * (((uintptr_t)dest) - ((uintptr_t)aligned_dst)); \/\/ 0, 8, 16, 24\n-\n-  uint64_t mask = 0xfful << shift; \/\/ 0x00000000..FF..\n-  uint64_t remask = ~mask;         \/\/ 0xFFFFFFFF..00..\n-\n-  uint64_t w_cv = ((uint64_t)(unsigned char)compare_value) << shift;  \/\/ widen to 64-bit 0x00000000..CC..\n-  uint64_t w_ev = ((uint64_t)(unsigned char)exchange_value) << shift; \/\/ widen to 64-bit 0x00000000..EE..\n-\n-  uint64_t old_value;\n-  uint64_t rc_temp;\n-\n-  __asm__ __volatile__ (\n-    \"1:  lr.w      %0, %2      \\n\\t\"\n-    \"    and       %1, %0, %5  \\n\\t\" \/\/ ignore unrelated bytes and widen to 64-bit 0x00000000..XX..\n-    \"    bne       %1, %3, 2f  \\n\\t\" \/\/ compare 64-bit w_cv\n-    \"    and       %1, %0, %6  \\n\\t\" \/\/ remove old byte\n-    \"    or        %1, %1, %4  \\n\\t\" \/\/ add new byte\n-    \"    sc.w      %1, %1, %2  \\n\\t\" \/\/ store new word\n-    \"    bnez      %1, 1b      \\n\\t\"\n-    \"2:                        \\n\\t\"\n-    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*aligned_dst)\n-    : \/*%3*\/\"r\" (w_cv), \/*%4*\/\"r\" (w_ev), \/*%5*\/\"r\" (mask), \/*%6*\/\"r\" (remask)\n-    : \"memory\" );\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-\n-  return (T)((old_value & mask) >> shift);\n-}\n-#endif\n-\n-#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n-\/\/ The implementation of `__atomic_compare_exchange` lacks sign extensions\n-\/\/ in GCC 13.2 and lower when using with 32-bit unsigned integers on RV64,\n-\/\/ so we should implement it manually.\n-\/\/ GCC bug: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=114130.\n-\/\/ See also JDK-8326936.\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest __attribute__((unused)),\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-\n-  int32_t old_value;\n-  uint64_t rc_temp;\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-\n-  __asm__ __volatile__ (\n-    \"1:  lr.w      %0, %2      \\n\\t\"\n-    \"    bne       %0, %3, 2f  \\n\\t\"\n-    \"    sc.w      %1, %4, %2  \\n\\t\"\n-    \"    bnez      %1, 1b      \\n\\t\"\n-    \"2:                        \\n\\t\"\n-    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*dest)\n-    : \/*%3*\/\"r\" ((int64_t)(int32_t)compare_value), \/*%4*\/\"r\" (exchange_value)\n-    : \"memory\" );\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-  return (T)old_value;\n-}\n-#endif\n-\n-template<size_t byte_size>\n-template<typename T>\n-inline T Atomic::PlatformXchg<byte_size>::operator()(T volatile* dest,\n-                                                     T exchange_value,\n-                                                     atomic_memory_order order) const {\n-#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n-  \/\/ If we add xchg for sub word and are using older compiler\n-  \/\/ it must be added here due to not using lib atomic.\n-  STATIC_ASSERT(byte_size >= 4);\n-#endif\n-\n-  STATIC_ASSERT(byte_size == sizeof(T));\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-\n-  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-  return res;\n-}\n-\n-\/\/ __attribute__((unused)) on dest is to get rid of spurious GCC warnings.\n-template<size_t byte_size>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T volatile* dest __attribute__((unused)),\n-                                                        T compare_value,\n-                                                        T exchange_value,\n-                                                        atomic_memory_order order) const {\n-\n-#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n-  STATIC_ASSERT(byte_size > 4);\n-#endif\n-\n-  STATIC_ASSERT(byte_size == sizeof(T));\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-\n-  __atomic_compare_exchange(dest, &compare_value, &exchange_value, \/* weak *\/ false,\n-                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-  return compare_value;\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n-{\n-  template <typename T>\n-  T operator()(const volatile T* p) const { T data; __atomic_load(const_cast<T*>(p), &data, __ATOMIC_ACQUIRE); return data; }\n-};\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const { __atomic_store(const_cast<T*>(p), &v, __ATOMIC_RELEASE); }\n-};\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedStore<byte_size, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const { release_store(p, v); OrderAccess::fence(); }\n-};\n-\n-#undef FULL_COMPILER_ATOMIC_SUPPORT\n-\n-#endif \/\/ OS_CPU_LINUX_RISCV_ATOMIC_LINUX_RISCV_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomic_linux_riscv.hpp","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"},{"patch":"@@ -92,0 +92,2 @@\n+#define RISCV_HWPROBE_KEY_ZICBOZ_BLOCK_SIZE 6\n+\n@@ -117,1 +119,2 @@\n-                                       {RISCV_HWPROBE_KEY_CPUPERF_0,     0}};\n+                                       {RISCV_HWPROBE_KEY_CPUPERF_0,     0},\n+                                       {RISCV_HWPROBE_KEY_ZICBOZ_BLOCK_SIZE, 0}};\n@@ -191,0 +194,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZICBOZ)) {\n+    VM_Version::ext_Zicboz.enable_feature();\n+  }\n@@ -247,0 +253,3 @@\n+  if (is_valid(RISCV_HWPROBE_KEY_ZICBOZ_BLOCK_SIZE)) {\n+    VM_Version::zicboz_block_size.enable_feature(query[RISCV_HWPROBE_KEY_ZICBOZ_BLOCK_SIZE].value);\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_S390_ATOMICACCESS_LINUX_S390_HPP\n+#define OS_CPU_LINUX_S390_ATOMICACCESS_LINUX_S390_HPP\n+\n+#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\/\/ Note that the compare-and-swap instructions on System z perform\n+\/\/ a serialization function before the storage operand is fetched\n+\/\/ and again after the operation is completed.\n+\/\/\n+\/\/ Used constraint modifiers:\n+\/\/ = write-only access: Value on entry to inline-assembler code irrelevant.\n+\/\/ + read\/write access: Value on entry is used; on exit value is changed.\n+\/\/   read-only  access: Value on entry is used and never changed.\n+\/\/ & early-clobber access: Might be modified before all read-only operands\n+\/\/                         have been used.\n+\/\/ a address register operand (not GR0).\n+\/\/ d general register operand (including GR0)\n+\/\/ Q memory operand w\/o index register.\n+\/\/ 0..9 operand reference (by operand position).\n+\/\/      Used for operands that fill multiple roles. One example would be a\n+\/\/      write-only operand receiving its initial value from a read-only operand.\n+\/\/      Refer to cmpxchg(..) operand #0 and variable cmp_val for a real-life example.\n+\/\/\n+\n+\/\/ On System z, all store operations are atomic if the address where the data is stored into\n+\/\/ is an integer multiple of the data length. Furthermore, all stores are ordered:\n+\/\/ a store which occurs conceptually before another store becomes visible to other CPUs\n+\/\/ before the other store becomes visible.\n+\n+\/\/------------\n+\/\/ AtomicAccess::add\n+\/\/------------\n+\/\/ These methods force the value in memory to be augmented by the passed increment.\n+\/\/ Both, memory value and increment, are treated as 32bit signed binary integers.\n+\/\/ No overflow exceptions are recognized, and the condition code does not hold\n+\/\/ information about the value in memory.\n+\/\/\n+\/\/ The value in memory is updated by using a compare-and-swap instruction. The\n+\/\/ instruction is retried as often as required.\n+\/\/\n+\/\/ The return value of the method is the value that was successfully stored. At the\n+\/\/ time the caller receives back control, the value in memory may have changed already.\n+\n+\/\/ New atomic operations only include specific-operand-serialization, not full\n+\/\/ memory barriers. We can use the Fast-BCR-Serialization Facility for them.\n+inline void z196_fast_sync() {\n+  __asm__ __volatile__ (\"bcr 14, 0\" : : : \"memory\");\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I inc,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D old, upd;\n+\n+  if (VM_Version::has_LoadAndALUAtomicV1()) {\n+    if (order == memory_order_conservative) { z196_fast_sync(); }\n+    __asm__ __volatile__ (\n+      \"   LGFR     0,%[inc]                \\n\\t\" \/\/ save increment\n+      \"   LA       3,%[mem]                \\n\\t\" \/\/ force data address into ARG2\n+\/\/    \"   LAA      %[upd],%[inc],%[mem]    \\n\\t\" \/\/ increment and get old value\n+\/\/    \"   LAA      2,0,0(3)                \\n\\t\" \/\/ actually coded instruction\n+      \"   .byte    0xeb                    \\n\\t\" \/\/ LAA main opcode\n+      \"   .byte    0x20                    \\n\\t\" \/\/ R1,R3\n+      \"   .byte    0x30                    \\n\\t\" \/\/ R2,disp1\n+      \"   .byte    0x00                    \\n\\t\" \/\/ disp2,disp3\n+      \"   .byte    0x00                    \\n\\t\" \/\/ disp4,disp5\n+      \"   .byte    0xf8                    \\n\\t\" \/\/ LAA minor opcode\n+      \"   AR       2,0                     \\n\\t\" \/\/ calc new value in register\n+      \"   LR       %[upd],2                \\n\\t\" \/\/ move to result register\n+      \/\/---<  outputs  >---\n+      : [upd]  \"=&d\" (upd)    \/\/ write-only, updated counter value\n+      , [mem]  \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n+      \/\/---<  inputs  >---\n+      : [inc]  \"a\"   (inc)    \/\/ read-only.\n+      \/\/---<  clobbered  >---\n+      : \"cc\", \"r0\", \"r2\", \"r3\", \"memory\"\n+    );\n+    if (order == memory_order_conservative) { z196_fast_sync(); }\n+  } else {\n+    __asm__ __volatile__ (\n+      \"   LLGF     %[old],%[mem]           \\n\\t\" \/\/ get old value\n+      \"0: LA       %[upd],0(%[inc],%[old]) \\n\\t\" \/\/ calc result\n+      \"   CS       %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg res with mem\n+      \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n+      \/\/---<  outputs  >---\n+      : [old] \"=&a\" (old)    \/\/ write-only, old counter value\n+      , [upd] \"=&d\" (upd)    \/\/ write-only, updated counter value\n+      , [mem] \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n+      \/\/---<  inputs  >---\n+      : [inc] \"a\"   (inc)    \/\/ read-only.\n+      \/\/---<  clobbered  >---\n+      : \"cc\", \"memory\"\n+    );\n+  }\n+\n+  return upd;\n+}\n+\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::add_then_fetch(D volatile* dest, I inc,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+\n+  D old, upd;\n+\n+  if (VM_Version::has_LoadAndALUAtomicV1()) {\n+    if (order == memory_order_conservative) { z196_fast_sync(); }\n+    __asm__ __volatile__ (\n+      \"   LGR      0,%[inc]                \\n\\t\" \/\/ save increment\n+      \"   LA       3,%[mem]                \\n\\t\" \/\/ force data address into ARG2\n+\/\/    \"   LAAG     %[upd],%[inc],%[mem]    \\n\\t\" \/\/ increment and get old value\n+\/\/    \"   LAAG     2,0,0(3)                \\n\\t\" \/\/ actually coded instruction\n+      \"   .byte    0xeb                    \\n\\t\" \/\/ LAA main opcode\n+      \"   .byte    0x20                    \\n\\t\" \/\/ R1,R3\n+      \"   .byte    0x30                    \\n\\t\" \/\/ R2,disp1\n+      \"   .byte    0x00                    \\n\\t\" \/\/ disp2,disp3\n+      \"   .byte    0x00                    \\n\\t\" \/\/ disp4,disp5\n+      \"   .byte    0xe8                    \\n\\t\" \/\/ LAA minor opcode\n+      \"   AGR      2,0                     \\n\\t\" \/\/ calc new value in register\n+      \"   LGR      %[upd],2                \\n\\t\" \/\/ move to result register\n+      \/\/---<  outputs  >---\n+      : [upd]  \"=&d\" (upd)    \/\/ write-only, updated counter value\n+      , [mem]  \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n+      \/\/---<  inputs  >---\n+      : [inc]  \"a\"   (inc)    \/\/ read-only.\n+      \/\/---<  clobbered  >---\n+      : \"cc\", \"r0\", \"r2\", \"r3\", \"memory\"\n+    );\n+    if (order == memory_order_conservative) { z196_fast_sync(); }\n+  } else {\n+    __asm__ __volatile__ (\n+      \"   LG       %[old],%[mem]           \\n\\t\" \/\/ get old value\n+      \"0: LA       %[upd],0(%[inc],%[old]) \\n\\t\" \/\/ calc result\n+      \"   CSG      %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg res with mem\n+      \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n+      \/\/---<  outputs  >---\n+      : [old] \"=&a\" (old)    \/\/ write-only, old counter value\n+      , [upd] \"=&d\" (upd)    \/\/ write-only, updated counter value\n+      , [mem] \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n+      \/\/---<  inputs  >---\n+      : [inc] \"a\"   (inc)    \/\/ read-only.\n+      \/\/---<  clobbered  >---\n+      : \"cc\", \"memory\"\n+    );\n+  }\n+\n+  return upd;\n+}\n+\n+\n+\/\/-------------\n+\/\/ AtomicAccess::xchg\n+\/\/-------------\n+\/\/ These methods force the value in memory to be replaced by the new value passed\n+\/\/ in as argument.\n+\/\/\n+\/\/ The value in memory is replaced by using a compare-and-swap instruction. The\n+\/\/ instruction is retried as often as required. This makes sure that the new\n+\/\/ value can be seen, at least for a very short period of time, by other CPUs.\n+\/\/\n+\/\/ If we would use a normal \"load(old value) store(new value)\" sequence,\n+\/\/ the new value could be lost unnoticed, due to a store(new value) from\n+\/\/ another thread.\n+\/\/\n+\/\/ The return value is the (unchanged) value from memory as it was when the\n+\/\/ replacement succeeded.\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order unused) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  T old;\n+\n+  __asm__ __volatile__ (\n+    \"   LLGF     %[old],%[mem]           \\n\\t\" \/\/ get old value\n+    \"0: CS       %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg upd with mem\n+    \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n+    \/\/---<  outputs  >---\n+    : [old] \"=&d\" (old)      \/\/ write-only, prev value irrelevant\n+    , [mem] \"+Q\"  (*dest)    \/\/ read\/write, memory to be updated atomically\n+    \/\/---<  inputs  >---\n+    : [upd] \"d\"   (exchange_value) \/\/ read-only, value to be written to memory\n+    \/\/---<  clobbered  >---\n+    : \"cc\", \"memory\"\n+  );\n+\n+  return old;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order unused) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  T old;\n+\n+  __asm__ __volatile__ (\n+    \"   LG       %[old],%[mem]           \\n\\t\" \/\/ get old value\n+    \"0: CSG      %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg upd with mem\n+    \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n+    \/\/---<  outputs  >---\n+    : [old] \"=&d\" (old)      \/\/ write-only, init from memory\n+    , [mem] \"+Q\"  (*dest)    \/\/ read\/write, memory to be updated atomically\n+    \/\/---<  inputs  >---\n+    : [upd] \"d\"   (exchange_value) \/\/ read-only, value to be written to memory\n+    \/\/---<  clobbered  >---\n+    : \"cc\", \"memory\"\n+  );\n+\n+  return old;\n+}\n+\n+\/\/----------------\n+\/\/ AtomicAccess::cmpxchg\n+\/\/----------------\n+\/\/ These methods compare the value in memory with a given compare value.\n+\/\/ If both values compare equal, the value in memory is replaced with\n+\/\/ the exchange value.\n+\/\/\n+\/\/ The value in memory is compared and replaced by using a compare-and-swap\n+\/\/ instruction. The instruction is NOT retried (one shot only).\n+\/\/\n+\/\/ The return value is the (unchanged) value from memory as it was when the\n+\/\/ compare-and-swap instruction completed. A successful exchange operation\n+\/\/ is indicated by (return value == compare_value). If unsuccessful, a new\n+\/\/ exchange value can be calculated based on the return value which is the\n+\/\/ latest contents of the memory location.\n+\/\/\n+\/\/ Inspecting the return value is the only way for the caller to determine\n+\/\/ if the compare-and-swap instruction was successful:\n+\/\/ - If return value and compare value compare equal, the compare-and-swap\n+\/\/   instruction was successful and the value in memory was replaced by the\n+\/\/   exchange value.\n+\/\/ - If return value and compare value compare unequal, the compare-and-swap\n+\/\/   instruction was not successful. The value in memory was left unchanged.\n+\/\/\n+\/\/ The s390 processors always fence before and after the csg instructions.\n+\/\/ Thus we ignore the memory ordering argument. The docu says: \"A serialization\n+\/\/ function is performed before the operand is fetched and again after the\n+\/\/ operation is completed.\"\n+\n+\/\/ No direct support for cmpxchg of bytes; emulate using int.\n+template<>\n+struct AtomicAccess::PlatformCmpxchg<1> : AtomicAccess::CmpxchgByteUsingInt {};\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T cmp_val,\n+                                                      T xchg_val,\n+                                                      atomic_memory_order unused) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  T old;\n+\n+  __asm__ __volatile__ (\n+    \"   CS       %[old],%[upd],%[mem]    \\n\\t\" \/\/ Try to xchg upd with mem.\n+    \/\/ outputs\n+    : [old] \"=&d\" (old)      \/\/ Write-only, prev value irrelevant.\n+    , [mem] \"+Q\"  (*dest)    \/\/ Read\/write, memory to be updated atomically.\n+    \/\/ inputs\n+    : [upd] \"d\"   (xchg_val)\n+    ,       \"0\"   (cmp_val)  \/\/ Read-only, initial value for [old] (operand #0).\n+    \/\/ clobbered\n+    : \"cc\", \"memory\"\n+  );\n+\n+  return old;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T cmp_val,\n+                                                      T xchg_val,\n+                                                      atomic_memory_order unused) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  T old;\n+\n+  __asm__ __volatile__ (\n+    \"   CSG      %[old],%[upd],%[mem]    \\n\\t\" \/\/ Try to xchg upd with mem.\n+    \/\/ outputs\n+    : [old] \"=&d\" (old)      \/\/ Write-only, prev value irrelevant.\n+    , [mem] \"+Q\"  (*dest)    \/\/ Read\/write, memory to be updated atomically.\n+    \/\/ inputs\n+    : [upd] \"d\"   (xchg_val)\n+    ,       \"0\"   (cmp_val)  \/\/ Read-only, initial value for [old] (operand #0).\n+    \/\/ clobbered\n+    : \"cc\", \"memory\"\n+  );\n+\n+  return old;\n+}\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n+{\n+  template <typename T>\n+  T operator()(const volatile T* p) const { T t = *p; OrderAccess::acquire(); return t; }\n+};\n+\n+#endif \/\/ OS_CPU_LINUX_S390_ATOMICACCESS_LINUX_S390_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/atomicAccess_linux_s390.hpp","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"},{"patch":"@@ -1,348 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_S390_ATOMIC_LINUX_S390_HPP\n-#define OS_CPU_LINUX_S390_ATOMIC_LINUX_S390_HPP\n-\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-\n-\/\/ Note that the compare-and-swap instructions on System z perform\n-\/\/ a serialization function before the storage operand is fetched\n-\/\/ and again after the operation is completed.\n-\/\/\n-\/\/ Used constraint modifiers:\n-\/\/ = write-only access: Value on entry to inline-assembler code irrelevant.\n-\/\/ + read\/write access: Value on entry is used; on exit value is changed.\n-\/\/   read-only  access: Value on entry is used and never changed.\n-\/\/ & early-clobber access: Might be modified before all read-only operands\n-\/\/                         have been used.\n-\/\/ a address register operand (not GR0).\n-\/\/ d general register operand (including GR0)\n-\/\/ Q memory operand w\/o index register.\n-\/\/ 0..9 operand reference (by operand position).\n-\/\/      Used for operands that fill multiple roles. One example would be a\n-\/\/      write-only operand receiving its initial value from a read-only operand.\n-\/\/      Refer to cmpxchg(..) operand #0 and variable cmp_val for a real-life example.\n-\/\/\n-\n-\/\/ On System z, all store operations are atomic if the address where the data is stored into\n-\/\/ is an integer multiple of the data length. Furthermore, all stores are ordered:\n-\/\/ a store which occurs conceptually before another store becomes visible to other CPUs\n-\/\/ before the other store becomes visible.\n-\n-\/\/------------\n-\/\/ Atomic::add\n-\/\/------------\n-\/\/ These methods force the value in memory to be augmented by the passed increment.\n-\/\/ Both, memory value and increment, are treated as 32bit signed binary integers.\n-\/\/ No overflow exceptions are recognized, and the condition code does not hold\n-\/\/ information about the value in memory.\n-\/\/\n-\/\/ The value in memory is updated by using a compare-and-swap instruction. The\n-\/\/ instruction is retried as often as required.\n-\/\/\n-\/\/ The return value of the method is the value that was successfully stored. At the\n-\/\/ time the caller receives back control, the value in memory may have changed already.\n-\n-\/\/ New atomic operations only include specific-operand-serialization, not full\n-\/\/ memory barriers. We can use the Fast-BCR-Serialization Facility for them.\n-inline void z196_fast_sync() {\n-  __asm__ __volatile__ (\"bcr 14, 0\" : : : \"memory\");\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::add_then_fetch(D volatile* dest, I inc,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-\n-  D old, upd;\n-\n-  if (VM_Version::has_LoadAndALUAtomicV1()) {\n-    if (order == memory_order_conservative) { z196_fast_sync(); }\n-    __asm__ __volatile__ (\n-      \"   LGFR     0,%[inc]                \\n\\t\" \/\/ save increment\n-      \"   LA       3,%[mem]                \\n\\t\" \/\/ force data address into ARG2\n-\/\/    \"   LAA      %[upd],%[inc],%[mem]    \\n\\t\" \/\/ increment and get old value\n-\/\/    \"   LAA      2,0,0(3)                \\n\\t\" \/\/ actually coded instruction\n-      \"   .byte    0xeb                    \\n\\t\" \/\/ LAA main opcode\n-      \"   .byte    0x20                    \\n\\t\" \/\/ R1,R3\n-      \"   .byte    0x30                    \\n\\t\" \/\/ R2,disp1\n-      \"   .byte    0x00                    \\n\\t\" \/\/ disp2,disp3\n-      \"   .byte    0x00                    \\n\\t\" \/\/ disp4,disp5\n-      \"   .byte    0xf8                    \\n\\t\" \/\/ LAA minor opcode\n-      \"   AR       2,0                     \\n\\t\" \/\/ calc new value in register\n-      \"   LR       %[upd],2                \\n\\t\" \/\/ move to result register\n-      \/\/---<  outputs  >---\n-      : [upd]  \"=&d\" (upd)    \/\/ write-only, updated counter value\n-      , [mem]  \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n-      \/\/---<  inputs  >---\n-      : [inc]  \"a\"   (inc)    \/\/ read-only.\n-      \/\/---<  clobbered  >---\n-      : \"cc\", \"r0\", \"r2\", \"r3\", \"memory\"\n-    );\n-    if (order == memory_order_conservative) { z196_fast_sync(); }\n-  } else {\n-    __asm__ __volatile__ (\n-      \"   LLGF     %[old],%[mem]           \\n\\t\" \/\/ get old value\n-      \"0: LA       %[upd],0(%[inc],%[old]) \\n\\t\" \/\/ calc result\n-      \"   CS       %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg res with mem\n-      \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n-      \/\/---<  outputs  >---\n-      : [old] \"=&a\" (old)    \/\/ write-only, old counter value\n-      , [upd] \"=&d\" (upd)    \/\/ write-only, updated counter value\n-      , [mem] \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n-      \/\/---<  inputs  >---\n-      : [inc] \"a\"   (inc)    \/\/ read-only.\n-      \/\/---<  clobbered  >---\n-      : \"cc\", \"memory\"\n-    );\n-  }\n-\n-  return upd;\n-}\n-\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::add_then_fetch(D volatile* dest, I inc,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-\n-  D old, upd;\n-\n-  if (VM_Version::has_LoadAndALUAtomicV1()) {\n-    if (order == memory_order_conservative) { z196_fast_sync(); }\n-    __asm__ __volatile__ (\n-      \"   LGR      0,%[inc]                \\n\\t\" \/\/ save increment\n-      \"   LA       3,%[mem]                \\n\\t\" \/\/ force data address into ARG2\n-\/\/    \"   LAAG     %[upd],%[inc],%[mem]    \\n\\t\" \/\/ increment and get old value\n-\/\/    \"   LAAG     2,0,0(3)                \\n\\t\" \/\/ actually coded instruction\n-      \"   .byte    0xeb                    \\n\\t\" \/\/ LAA main opcode\n-      \"   .byte    0x20                    \\n\\t\" \/\/ R1,R3\n-      \"   .byte    0x30                    \\n\\t\" \/\/ R2,disp1\n-      \"   .byte    0x00                    \\n\\t\" \/\/ disp2,disp3\n-      \"   .byte    0x00                    \\n\\t\" \/\/ disp4,disp5\n-      \"   .byte    0xe8                    \\n\\t\" \/\/ LAA minor opcode\n-      \"   AGR      2,0                     \\n\\t\" \/\/ calc new value in register\n-      \"   LGR      %[upd],2                \\n\\t\" \/\/ move to result register\n-      \/\/---<  outputs  >---\n-      : [upd]  \"=&d\" (upd)    \/\/ write-only, updated counter value\n-      , [mem]  \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n-      \/\/---<  inputs  >---\n-      : [inc]  \"a\"   (inc)    \/\/ read-only.\n-      \/\/---<  clobbered  >---\n-      : \"cc\", \"r0\", \"r2\", \"r3\", \"memory\"\n-    );\n-    if (order == memory_order_conservative) { z196_fast_sync(); }\n-  } else {\n-    __asm__ __volatile__ (\n-      \"   LG       %[old],%[mem]           \\n\\t\" \/\/ get old value\n-      \"0: LA       %[upd],0(%[inc],%[old]) \\n\\t\" \/\/ calc result\n-      \"   CSG      %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg res with mem\n-      \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n-      \/\/---<  outputs  >---\n-      : [old] \"=&a\" (old)    \/\/ write-only, old counter value\n-      , [upd] \"=&d\" (upd)    \/\/ write-only, updated counter value\n-      , [mem] \"+Q\"  (*dest)  \/\/ read\/write, memory to be updated atomically\n-      \/\/---<  inputs  >---\n-      : [inc] \"a\"   (inc)    \/\/ read-only.\n-      \/\/---<  clobbered  >---\n-      : \"cc\", \"memory\"\n-    );\n-  }\n-\n-  return upd;\n-}\n-\n-\n-\/\/-------------\n-\/\/ Atomic::xchg\n-\/\/-------------\n-\/\/ These methods force the value in memory to be replaced by the new value passed\n-\/\/ in as argument.\n-\/\/\n-\/\/ The value in memory is replaced by using a compare-and-swap instruction. The\n-\/\/ instruction is retried as often as required. This makes sure that the new\n-\/\/ value can be seen, at least for a very short period of time, by other CPUs.\n-\/\/\n-\/\/ If we would use a normal \"load(old value) store(new value)\" sequence,\n-\/\/ the new value could be lost unnoticed, due to a store(new value) from\n-\/\/ another thread.\n-\/\/\n-\/\/ The return value is the (unchanged) value from memory as it was when the\n-\/\/ replacement succeeded.\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order unused) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  T old;\n-\n-  __asm__ __volatile__ (\n-    \"   LLGF     %[old],%[mem]           \\n\\t\" \/\/ get old value\n-    \"0: CS       %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg upd with mem\n-    \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n-    \/\/---<  outputs  >---\n-    : [old] \"=&d\" (old)      \/\/ write-only, prev value irrelevant\n-    , [mem] \"+Q\"  (*dest)    \/\/ read\/write, memory to be updated atomically\n-    \/\/---<  inputs  >---\n-    : [upd] \"d\"   (exchange_value) \/\/ read-only, value to be written to memory\n-    \/\/---<  clobbered  >---\n-    : \"cc\", \"memory\"\n-  );\n-\n-  return old;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order unused) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  T old;\n-\n-  __asm__ __volatile__ (\n-    \"   LG       %[old],%[mem]           \\n\\t\" \/\/ get old value\n-    \"0: CSG      %[old],%[upd],%[mem]    \\n\\t\" \/\/ try to xchg upd with mem\n-    \"   JNE      0b                      \\n\\t\" \/\/ no success? -> retry\n-    \/\/---<  outputs  >---\n-    : [old] \"=&d\" (old)      \/\/ write-only, init from memory\n-    , [mem] \"+Q\"  (*dest)    \/\/ read\/write, memory to be updated atomically\n-    \/\/---<  inputs  >---\n-    : [upd] \"d\"   (exchange_value) \/\/ read-only, value to be written to memory\n-    \/\/---<  clobbered  >---\n-    : \"cc\", \"memory\"\n-  );\n-\n-  return old;\n-}\n-\n-\/\/----------------\n-\/\/ Atomic::cmpxchg\n-\/\/----------------\n-\/\/ These methods compare the value in memory with a given compare value.\n-\/\/ If both values compare equal, the value in memory is replaced with\n-\/\/ the exchange value.\n-\/\/\n-\/\/ The value in memory is compared and replaced by using a compare-and-swap\n-\/\/ instruction. The instruction is NOT retried (one shot only).\n-\/\/\n-\/\/ The return value is the (unchanged) value from memory as it was when the\n-\/\/ compare-and-swap instruction completed. A successful exchange operation\n-\/\/ is indicated by (return value == compare_value). If unsuccessful, a new\n-\/\/ exchange value can be calculated based on the return value which is the\n-\/\/ latest contents of the memory location.\n-\/\/\n-\/\/ Inspecting the return value is the only way for the caller to determine\n-\/\/ if the compare-and-swap instruction was successful:\n-\/\/ - If return value and compare value compare equal, the compare-and-swap\n-\/\/   instruction was successful and the value in memory was replaced by the\n-\/\/   exchange value.\n-\/\/ - If return value and compare value compare unequal, the compare-and-swap\n-\/\/   instruction was not successful. The value in memory was left unchanged.\n-\/\/\n-\/\/ The s390 processors always fence before and after the csg instructions.\n-\/\/ Thus we ignore the memory ordering argument. The docu says: \"A serialization\n-\/\/ function is performed before the operand is fetched and again after the\n-\/\/ operation is completed.\"\n-\n-\/\/ No direct support for cmpxchg of bytes; emulate using int.\n-template<>\n-struct Atomic::PlatformCmpxchg<1> : Atomic::CmpxchgByteUsingInt {};\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T cmp_val,\n-                                                T xchg_val,\n-                                                atomic_memory_order unused) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  T old;\n-\n-  __asm__ __volatile__ (\n-    \"   CS       %[old],%[upd],%[mem]    \\n\\t\" \/\/ Try to xchg upd with mem.\n-    \/\/ outputs\n-    : [old] \"=&d\" (old)      \/\/ Write-only, prev value irrelevant.\n-    , [mem] \"+Q\"  (*dest)    \/\/ Read\/write, memory to be updated atomically.\n-    \/\/ inputs\n-    : [upd] \"d\"   (xchg_val)\n-    ,       \"0\"   (cmp_val)  \/\/ Read-only, initial value for [old] (operand #0).\n-    \/\/ clobbered\n-    : \"cc\", \"memory\"\n-  );\n-\n-  return old;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T cmp_val,\n-                                                T xchg_val,\n-                                                atomic_memory_order unused) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  T old;\n-\n-  __asm__ __volatile__ (\n-    \"   CSG      %[old],%[upd],%[mem]    \\n\\t\" \/\/ Try to xchg upd with mem.\n-    \/\/ outputs\n-    : [old] \"=&d\" (old)      \/\/ Write-only, prev value irrelevant.\n-    , [mem] \"+Q\"  (*dest)    \/\/ Read\/write, memory to be updated atomically.\n-    \/\/ inputs\n-    : [upd] \"d\"   (xchg_val)\n-    ,       \"0\"   (cmp_val)  \/\/ Read-only, initial value for [old] (operand #0).\n-    \/\/ clobbered\n-    : \"cc\", \"memory\"\n-  );\n-\n-  return old;\n-}\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformOrderedLoad<byte_size, X_ACQUIRE>\n-{\n-  template <typename T>\n-  T operator()(const volatile T* p) const { T t = *p; OrderAccess::acquire(); return t; }\n-};\n-\n-#endif \/\/ OS_CPU_LINUX_S390_ATOMIC_LINUX_S390_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/atomic_linux_s390.hpp","additions":0,"deletions":348,"binary":false,"changes":348,"status":"deleted"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_X86_ATOMICACCESS_LINUX_X86_HPP\n+#define OS_CPU_LINUX_X86_ATOMICACCESS_LINUX_X86_HPP\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return fetch_then_add(dest, add_value, order) + add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::fetch_then_add(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+  D old_value;\n+  __asm__ volatile (  \"lock xaddl %0,(%2)\"\n+                    : \"=r\" (old_value)\n+                    : \"0\" (add_value), \"r\" (dest)\n+                    : \"cc\", \"memory\");\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  __asm__ volatile (  \"xchgl (%2),%0\"\n+                    : \"=r\" (exchange_value)\n+                    : \"0\" (exchange_value), \"r\" (dest)\n+                    : \"memory\");\n+  return exchange_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<1>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(1 == sizeof(T));\n+  __asm__ volatile (\"lock cmpxchgb %1,(%3)\"\n+                    : \"=a\" (exchange_value)\n+                    : \"q\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n+                    : \"cc\", \"memory\");\n+  return exchange_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  __asm__ volatile (\"lock cmpxchgl %1,(%3)\"\n+                    : \"=a\" (exchange_value)\n+                    : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n+                    : \"cc\", \"memory\");\n+  return exchange_value;\n+}\n+\n+#ifdef AMD64\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::fetch_then_add(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+  D old_value;\n+  __asm__ __volatile__ (\"lock xaddq %0,(%2)\"\n+                        : \"=r\" (old_value)\n+                        : \"0\" (add_value), \"r\" (dest)\n+                        : \"cc\", \"memory\");\n+  return old_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest, T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  __asm__ __volatile__ (\"xchgq (%2),%0\"\n+                        : \"=r\" (exchange_value)\n+                        : \"0\" (exchange_value), \"r\" (dest)\n+                        : \"memory\");\n+  return exchange_value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order \/* order *\/) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  __asm__ __volatile__ (\"lock cmpxchgq %1,(%3)\"\n+                        : \"=a\" (exchange_value)\n+                        : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n+                        : \"cc\", \"memory\");\n+  return exchange_value;\n+}\n+\n+#else \/\/ !AMD64\n+\n+extern \"C\" {\n+  \/\/ defined in linux_x86.s\n+  int64_t _Atomic_cmpxchg_long(int64_t, volatile int64_t*, int64_t);\n+  void _Atomic_move_long(const volatile int64_t* src, volatile int64_t* dst);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  return cmpxchg_using_helper<int64_t>(_Atomic_cmpxchg_long, dest, compare_value, exchange_value);\n+}\n+\n+\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n+template<>\n+struct AtomicAccess::PlatformXchg<8> : AtomicAccess::XchgUsingCmpxchg<8> {};\n+\n+\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n+template<>\n+struct AtomicAccess::PlatformAdd<8> : AtomicAccess::AddUsingCmpxchg<8> {};\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformLoad<8>::operator()(T const volatile* src) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  volatile int64_t dest;\n+  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(src), reinterpret_cast<volatile int64_t*>(&dest));\n+  return PrimitiveConversions::cast<T>(dest);\n+}\n+\n+template<>\n+template<typename T>\n+inline void AtomicAccess::PlatformStore<8>::operator()(T volatile* dest,\n+                                                       T store_value) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(&store_value), reinterpret_cast<volatile int64_t*>(dest));\n+}\n+\n+#endif \/\/ AMD64\n+\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<1, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgb (%2),%0\"\n+                      : \"=q\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<2, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgw (%2),%0\"\n+                      : \"=r\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<4, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgl (%2),%0\"\n+                      : \"=r\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+\n+#ifdef AMD64\n+template<>\n+struct AtomicAccess::PlatformOrderedStore<8, RELEASE_X_FENCE>\n+{\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    __asm__ volatile (  \"xchgq (%2), %0\"\n+                      : \"=r\" (v)\n+                      : \"0\" (v), \"r\" (p)\n+                      : \"memory\");\n+  }\n+};\n+#endif \/\/ AMD64\n+\n+#endif \/\/ OS_CPU_LINUX_X86_ATOMICACCESS_LINUX_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomicAccess_linux_x86.hpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -1,233 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_X86_ATOMIC_LINUX_X86_HPP\n-#define OS_CPU_LINUX_X86_ATOMIC_LINUX_X86_HPP\n-\n-\/\/ Implementation of class atomic\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return fetch_then_add(dest, add_value, order) + add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::fetch_then_add(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-  D old_value;\n-  __asm__ volatile (  \"lock xaddl %0,(%2)\"\n-                    : \"=r\" (old_value)\n-                    : \"0\" (add_value), \"r\" (dest)\n-                    : \"cc\", \"memory\");\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  __asm__ volatile (  \"xchgl (%2),%0\"\n-                    : \"=r\" (exchange_value)\n-                    : \"0\" (exchange_value), \"r\" (dest)\n-                    : \"memory\");\n-  return exchange_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<1>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(1 == sizeof(T));\n-  __asm__ volatile (\"lock cmpxchgb %1,(%3)\"\n-                    : \"=a\" (exchange_value)\n-                    : \"q\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n-                    : \"cc\", \"memory\");\n-  return exchange_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  __asm__ volatile (\"lock cmpxchgl %1,(%3)\"\n-                    : \"=a\" (exchange_value)\n-                    : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n-                    : \"cc\", \"memory\");\n-  return exchange_value;\n-}\n-\n-#ifdef AMD64\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::fetch_then_add(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-  D old_value;\n-  __asm__ __volatile__ (\"lock xaddq %0,(%2)\"\n-                        : \"=r\" (old_value)\n-                        : \"0\" (add_value), \"r\" (dest)\n-                        : \"cc\", \"memory\");\n-  return old_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest, T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  __asm__ __volatile__ (\"xchgq (%2),%0\"\n-                        : \"=r\" (exchange_value)\n-                        : \"0\" (exchange_value), \"r\" (dest)\n-                        : \"memory\");\n-  return exchange_value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order \/* order *\/) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  __asm__ __volatile__ (\"lock cmpxchgq %1,(%3)\"\n-                        : \"=a\" (exchange_value)\n-                        : \"r\" (exchange_value), \"a\" (compare_value), \"r\" (dest)\n-                        : \"cc\", \"memory\");\n-  return exchange_value;\n-}\n-\n-#else \/\/ !AMD64\n-\n-extern \"C\" {\n-  \/\/ defined in linux_x86.s\n-  int64_t _Atomic_cmpxchg_long(int64_t, volatile int64_t*, int64_t);\n-  void _Atomic_move_long(const volatile int64_t* src, volatile int64_t* dst);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  return cmpxchg_using_helper<int64_t>(_Atomic_cmpxchg_long, dest, compare_value, exchange_value);\n-}\n-\n-\/\/ No direct support for 8-byte xchg; emulate using cmpxchg.\n-template<>\n-struct Atomic::PlatformXchg<8> : Atomic::XchgUsingCmpxchg<8> {};\n-\n-\/\/ No direct support for 8-byte add; emulate using cmpxchg.\n-template<>\n-struct Atomic::PlatformAdd<8> : Atomic::AddUsingCmpxchg<8> {};\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  volatile int64_t dest;\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(src), reinterpret_cast<volatile int64_t*>(&dest));\n-  return PrimitiveConversions::cast<T>(dest);\n-}\n-\n-template<>\n-template<typename T>\n-inline void Atomic::PlatformStore<8>::operator()(T volatile* dest,\n-                                                 T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  _Atomic_move_long(reinterpret_cast<const volatile int64_t*>(&store_value), reinterpret_cast<volatile int64_t*>(dest));\n-}\n-\n-#endif \/\/ AMD64\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<1, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgb (%2),%0\"\n-                      : \"=q\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<2, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgw (%2),%0\"\n-                      : \"=r\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-\n-template<>\n-struct Atomic::PlatformOrderedStore<4, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgl (%2),%0\"\n-                      : \"=r\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-\n-#ifdef AMD64\n-template<>\n-struct Atomic::PlatformOrderedStore<8, RELEASE_X_FENCE>\n-{\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    __asm__ volatile (  \"xchgq (%2), %0\"\n-                      : \"=r\" (v)\n-                      : \"0\" (v), \"r\" (p)\n-                      : \"memory\");\n-  }\n-};\n-#endif \/\/ AMD64\n-\n-#endif \/\/ OS_CPU_LINUX_X86_ATOMIC_LINUX_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomic_linux_x86.hpp","additions":0,"deletions":233,"binary":false,"changes":233,"status":"deleted"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright 2007, 2008, 2011, 2015, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_ZERO_ATOMICACCESS_LINUX_ZERO_HPP\n+#define OS_CPU_LINUX_ZERO_ATOMICACCESS_LINUX_ZERO_HPP\n+\n+#include \"orderAccess_linux_zero.hpp\"\n+\n+\/\/ Implementation of class AtomicAccess\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(I));\n+  STATIC_ASSERT(4 == sizeof(D));\n+\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+template<>\n+template<typename D, typename I>\n+inline D AtomicAccess::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(I));\n+  STATIC_ASSERT(8 == sizeof(D));\n+\n+  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<4>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return result;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformXchg<8>::operator()(T volatile* dest,\n+                                                   T exchange_value,\n+                                                   atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return result;\n+}\n+\n+\/\/ No direct support for cmpxchg of bytes; emulate using int.\n+template<>\n+struct AtomicAccess::PlatformCmpxchg<1> : AtomicAccess::CmpxchgByteUsingInt {};\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<4>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+\n+  T value = compare_value;\n+  FULL_MEM_BARRIER;\n+  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return value;\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformCmpxchg<8>::operator()(T volatile* dest,\n+                                                      T compare_value,\n+                                                      T exchange_value,\n+                                                      atomic_memory_order order) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+\n+  FULL_MEM_BARRIER;\n+  T value = compare_value;\n+  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n+  return value;\n+}\n+\n+\/\/ Atomically copy 64 bits of data\n+inline void atomic_copy64(const volatile void *src, volatile void *dst) {\n+  int64_t tmp;\n+  __atomic_load(reinterpret_cast<const volatile int64_t*>(src), &tmp, __ATOMIC_RELAXED);\n+  __atomic_store(reinterpret_cast<volatile int64_t*>(dst), &tmp, __ATOMIC_RELAXED);\n+}\n+\n+template<>\n+template<typename T>\n+inline T AtomicAccess::PlatformLoad<8>::operator()(T const volatile* src) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  T dest;\n+  __atomic_load(const_cast<T*>(src), &dest, __ATOMIC_RELAXED);\n+  return dest;\n+}\n+\n+template<>\n+template<typename T>\n+inline void AtomicAccess::PlatformStore<8>::operator()(T volatile* dest,\n+                                                       T store_value) const {\n+  STATIC_ASSERT(8 == sizeof(T));\n+  __atomic_store(dest, &store_value, __ATOMIC_RELAXED);\n+}\n+\n+#endif \/\/ OS_CPU_LINUX_ZERO_ATOMICACCESS_LINUX_ZERO_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/atomicAccess_linux_zero.hpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright 2007, 2008, 2011, 2015, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_LINUX_ZERO_ATOMIC_LINUX_ZERO_HPP\n-#define OS_CPU_LINUX_ZERO_ATOMIC_LINUX_ZERO_HPP\n-\n-#include \"orderAccess_linux_zero.hpp\"\n-\n-\/\/ Implementation of class atomic\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<4>::add_then_fetch(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(I));\n-  STATIC_ASSERT(4 == sizeof(D));\n-\n-  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n-  FULL_MEM_BARRIER;\n-  return res;\n-}\n-\n-template<>\n-template<typename D, typename I>\n-inline D Atomic::PlatformAdd<8>::add_then_fetch(D volatile* dest, I add_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(I));\n-  STATIC_ASSERT(8 == sizeof(D));\n-\n-  D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n-  FULL_MEM_BARRIER;\n-  return res;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<4>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-  FULL_MEM_BARRIER;\n-  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return result;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformXchg<8>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  FULL_MEM_BARRIER;\n-  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return result;\n-}\n-\n-\/\/ No direct support for cmpxchg of bytes; emulate using int.\n-template<>\n-struct Atomic::PlatformCmpxchg<1> : Atomic::CmpxchgByteUsingInt {};\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-\n-  T value = compare_value;\n-  FULL_MEM_BARRIER;\n-  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n-                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<8>::operator()(T volatile* dest,\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-\n-  FULL_MEM_BARRIER;\n-  T value = compare_value;\n-  __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n-                            __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n-  FULL_MEM_BARRIER;\n-  return value;\n-}\n-\n-\/\/ Atomically copy 64 bits of data\n-inline void atomic_copy64(const volatile void *src, volatile void *dst) {\n-  int64_t tmp;\n-  __atomic_load(reinterpret_cast<const volatile int64_t*>(src), &tmp, __ATOMIC_RELAXED);\n-  __atomic_store(reinterpret_cast<volatile int64_t*>(dst), &tmp, __ATOMIC_RELAXED);\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformLoad<8>::operator()(T const volatile* src) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  T dest;\n-  __atomic_load(const_cast<T*>(src), &dest, __ATOMIC_RELAXED);\n-  return dest;\n-}\n-\n-template<>\n-template<typename T>\n-inline void Atomic::PlatformStore<8>::operator()(T volatile* dest,\n-                                                 T store_value) const {\n-  STATIC_ASSERT(8 == sizeof(T));\n-  __atomic_store(dest, &store_value, __ATOMIC_RELAXED);\n-}\n-\n-#endif \/\/ OS_CPU_LINUX_ZERO_ATOMIC_LINUX_ZERO_HPP\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/atomic_linux_zero.hpp","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"atomic_linux_zero.hpp\"\n@@ -39,0 +38,1 @@\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_ATOMICACCESS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_ATOMICACCESS_WINDOWS_AARCH64_HPP\n+\n+#include <intrin.h>\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\n+\/\/ As per atomicAccess.hpp all read-modify-write operations have to provide two-way\n+\/\/ barriers semantics. The memory_order parameter is ignored - we always provide\n+\/\/ the strongest\/most-conservative ordering\n+\/\/\n+\/\/ For AARCH64 we add explicit barriers in the stubs.\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+\/\/ The Interlocked* APIs only take long and will not accept __int32. That is\n+\/\/ acceptable on Windows, since long is a 32-bits integer type.\n+\n+#define DEFINE_INTRINSIC_ADD(IntrinsicName, IntrinsicType)                \\\n+  template<>                                                              \\\n+  template<typename D, typename I>                                        \\\n+  inline D AtomicAccess::PlatformAdd<sizeof(IntrinsicType)>::add_then_fetch(D volatile* dest, \\\n+                                                                            I add_value, \\\n+                                                                            atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(D));                    \\\n+    return PrimitiveConversions::cast<D>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_ADD(InterlockedAdd,   long)\n+DEFINE_INTRINSIC_ADD(InterlockedAdd64, __int64)\n+\n+#undef DEFINE_INTRINSIC_ADD\n+\n+#define DEFINE_INTRINSIC_XCHG(IntrinsicName, IntrinsicType)               \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T AtomicAccess::PlatformXchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n+                                                                         T exchange_value, \\\n+                                                                         atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange,   long)\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_XCHG\n+\n+\/\/ Note: the order of the parameters is different between\n+\/\/ AtomicAccess::PlatformCmpxchg<*>::operator() and the\n+\/\/ InterlockedCompareExchange* API.\n+\n+#define DEFINE_INTRINSIC_CMPXCHG(IntrinsicName, IntrinsicType)            \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T AtomicAccess::PlatformCmpxchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n+                                                                            T compare_value, \\\n+                                                                            T exchange_value, \\\n+                                                                            atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n+                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_CMPXCHG(_InterlockedCompareExchange8, char) \/\/ Use the intrinsic as InterlockedCompareExchange8 does not exist\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange,   long)\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_CMPXCHG\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_ATOMICACCESS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/atomicAccess_windows_aarch64.hpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n-#define OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n-\n-#include <intrin.h>\n-#include \"runtime\/os.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-\n-\n-\/\/ As per atomic.hpp all read-modify-write operations have to provide two-way\n-\/\/ barriers semantics. The memory_order parameter is ignored - we always provide\n-\/\/ the strongest\/most-conservative ordering\n-\/\/\n-\/\/ For AARCH64 we add explicit barriers in the stubs.\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-\/\/ The Interlocked* APIs only take long and will not accept __int32. That is\n-\/\/ acceptable on Windows, since long is a 32-bits integer type.\n-\n-#define DEFINE_INTRINSIC_ADD(IntrinsicName, IntrinsicType)                \\\n-  template<>                                                              \\\n-  template<typename D, typename I>                                        \\\n-  inline D Atomic::PlatformAdd<sizeof(IntrinsicType)>::add_then_fetch(D volatile* dest, \\\n-                                                                      I add_value, \\\n-                                                                      atomic_memory_order order) const { \\\n-    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(D));                    \\\n-    return PrimitiveConversions::cast<D>(                                 \\\n-      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n-                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n-  }\n-\n-DEFINE_INTRINSIC_ADD(InterlockedAdd,   long)\n-DEFINE_INTRINSIC_ADD(InterlockedAdd64, __int64)\n-\n-#undef DEFINE_INTRINSIC_ADD\n-\n-#define DEFINE_INTRINSIC_XCHG(IntrinsicName, IntrinsicType)               \\\n-  template<>                                                              \\\n-  template<typename T>                                                    \\\n-  inline T Atomic::PlatformXchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n-                                                                   T exchange_value, \\\n-                                                                   atomic_memory_order order) const { \\\n-    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n-    return PrimitiveConversions::cast<T>(                                 \\\n-      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n-  }\n-\n-DEFINE_INTRINSIC_XCHG(InterlockedExchange,   long)\n-DEFINE_INTRINSIC_XCHG(InterlockedExchange64, __int64)\n-\n-#undef DEFINE_INTRINSIC_XCHG\n-\n-\/\/ Note: the order of the parameters is different between\n-\/\/ Atomic::PlatformCmpxchg<*>::operator() and the\n-\/\/ InterlockedCompareExchange* API.\n-\n-#define DEFINE_INTRINSIC_CMPXCHG(IntrinsicName, IntrinsicType)            \\\n-  template<>                                                              \\\n-  template<typename T>                                                    \\\n-  inline T Atomic::PlatformCmpxchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n-                                                                      T compare_value, \\\n-                                                                      T exchange_value, \\\n-                                                                      atomic_memory_order order) const { \\\n-    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n-    return PrimitiveConversions::cast<T>(                                 \\\n-      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n-                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n-  }\n-\n-DEFINE_INTRINSIC_CMPXCHG(_InterlockedCompareExchange8, char) \/\/ Use the intrinsic as InterlockedCompareExchange8 does not exist\n-DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange,   long)\n-DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange64, __int64)\n-\n-#undef DEFINE_INTRINSIC_CMPXCHG\n-\n-#endif \/\/ OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/atomic_windows_aarch64.hpp","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -38,1 +38,1 @@\n-      Atomic::store(to++, Atomic::load(from++));\n+      AtomicAccess::store(to++, AtomicAccess::load(from++));\n@@ -45,1 +45,1 @@\n-      Atomic::store(to--, Atomic::load(from--));\n+      AtomicAccess::store(to--, AtomicAccess::load(from--));\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/copy_windows_aarch64.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_X86_ATOMICACCESS_WINDOWS_X86_HPP\n+#define OS_CPU_WINDOWS_X86_ATOMICACCESS_WINDOWS_X86_HPP\n+\n+#include <intrin.h>\n+#include \"runtime\/os.hpp\"\n+\n+\/\/ Note that in MSVC, volatile memory accesses are explicitly\n+\/\/ guaranteed to have acquire release semantics (w.r.t. compiler\n+\/\/ reordering) and therefore does not even need a compiler barrier\n+\/\/ for normal acquire release accesses. And all generalized\n+\/\/ bound calls like release_store go through AtomicAccess::load\n+\/\/ and AtomicAccess::store which do volatile memory accesses.\n+template<> inline void ScopedFence<X_ACQUIRE>::postfix()       { }\n+template<> inline void ScopedFence<RELEASE_X>::prefix()        { }\n+template<> inline void ScopedFence<RELEASE_X_FENCE>::prefix()  { }\n+template<> inline void ScopedFence<RELEASE_X_FENCE>::postfix() { OrderAccess::fence(); }\n+\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_then_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+\/\/ The Interlocked* APIs only take long and will not accept __int32. That is\n+\/\/ acceptable on Windows, since long is a 32-bits integer type.\n+\n+#define DEFINE_INTRINSIC_ADD(IntrinsicName, IntrinsicType)                \\\n+  template<>                                                              \\\n+  template<typename D, typename I>                                        \\\n+  inline D AtomicAccess::PlatformAdd<sizeof(IntrinsicType)>::add_then_fetch(D volatile* dest, \\\n+                                                                            I add_value, \\\n+                                                                            atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(D));                    \\\n+    return PrimitiveConversions::cast<D>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_ADD(InterlockedAdd,   long)\n+DEFINE_INTRINSIC_ADD(InterlockedAdd64, __int64)\n+\n+#undef DEFINE_INTRINSIC_ADD\n+\n+#define DEFINE_INTRINSIC_XCHG(IntrinsicName, IntrinsicType)               \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T AtomicAccess::PlatformXchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n+                                                                         T exchange_value, \\\n+                                                                         atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange,   long)\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_XCHG\n+\n+\/\/ Note: the order of the parameters is different between\n+\/\/ AtomicAccess::PlatformCmpxchg<*>::operator() and the\n+\/\/ InterlockedCompareExchange* API.\n+\n+#define DEFINE_INTRINSIC_CMPXCHG(IntrinsicName, IntrinsicType)            \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T AtomicAccess::PlatformCmpxchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n+                                                                            T compare_value, \\\n+                                                                            T exchange_value, \\\n+                                                                            atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n+                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_CMPXCHG(_InterlockedCompareExchange8, char) \/\/ Use the intrinsic as InterlockedCompareExchange8 does not exist\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange,   long)\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_CMPXCHG\n+\n+#endif \/\/ OS_CPU_WINDOWS_X86_ATOMICACCESS_WINDOWS_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/atomicAccess_windows_x86.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef OS_CPU_WINDOWS_X86_ATOMIC_WINDOWS_X86_HPP\n-#define OS_CPU_WINDOWS_X86_ATOMIC_WINDOWS_X86_HPP\n-\n-#include <intrin.h>\n-#include \"runtime\/os.hpp\"\n-\n-\/\/ Note that in MSVC, volatile memory accesses are explicitly\n-\/\/ guaranteed to have acquire release semantics (w.r.t. compiler\n-\/\/ reordering) and therefore does not even need a compiler barrier\n-\/\/ for normal acquire release accesses. And all generalized\n-\/\/ bound calls like release_store go through Atomic::load\n-\/\/ and Atomic::store which do volatile memory accesses.\n-template<> inline void ScopedFence<X_ACQUIRE>::postfix()       { }\n-template<> inline void ScopedFence<RELEASE_X>::prefix()        { }\n-template<> inline void ScopedFence<RELEASE_X_FENCE>::prefix()  { }\n-template<> inline void ScopedFence<RELEASE_X_FENCE>::postfix() { OrderAccess::fence(); }\n-\n-template<size_t byte_size>\n-struct Atomic::PlatformAdd {\n-  template<typename D, typename I>\n-  D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n-\n-  template<typename D, typename I>\n-  D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n-    return add_then_fetch(dest, add_value, order) - add_value;\n-  }\n-};\n-\n-\/\/ The Interlocked* APIs only take long and will not accept __int32. That is\n-\/\/ acceptable on Windows, since long is a 32-bits integer type.\n-\n-#define DEFINE_INTRINSIC_ADD(IntrinsicName, IntrinsicType)                \\\n-  template<>                                                              \\\n-  template<typename D, typename I>                                        \\\n-  inline D Atomic::PlatformAdd<sizeof(IntrinsicType)>::add_then_fetch(D volatile* dest, \\\n-                                                                      I add_value, \\\n-                                                                      atomic_memory_order order) const { \\\n-    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(D));                    \\\n-    return PrimitiveConversions::cast<D>(                                 \\\n-      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n-                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n-  }\n-\n-DEFINE_INTRINSIC_ADD(InterlockedAdd,   long)\n-DEFINE_INTRINSIC_ADD(InterlockedAdd64, __int64)\n-\n-#undef DEFINE_INTRINSIC_ADD\n-\n-#define DEFINE_INTRINSIC_XCHG(IntrinsicName, IntrinsicType)               \\\n-  template<>                                                              \\\n-  template<typename T>                                                    \\\n-  inline T Atomic::PlatformXchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n-                                                                   T exchange_value, \\\n-                                                                   atomic_memory_order order) const { \\\n-    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n-    return PrimitiveConversions::cast<T>(                                 \\\n-      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n-  }\n-\n-DEFINE_INTRINSIC_XCHG(InterlockedExchange,   long)\n-DEFINE_INTRINSIC_XCHG(InterlockedExchange64, __int64)\n-\n-#undef DEFINE_INTRINSIC_XCHG\n-\n-\/\/ Note: the order of the parameters is different between\n-\/\/ Atomic::PlatformCmpxchg<*>::operator() and the\n-\/\/ InterlockedCompareExchange* API.\n-\n-#define DEFINE_INTRINSIC_CMPXCHG(IntrinsicName, IntrinsicType)            \\\n-  template<>                                                              \\\n-  template<typename T>                                                    \\\n-  inline T Atomic::PlatformCmpxchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n-                                                                      T compare_value, \\\n-                                                                      T exchange_value, \\\n-                                                                      atomic_memory_order order) const { \\\n-    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n-    return PrimitiveConversions::cast<T>(                                 \\\n-      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n-                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n-  }\n-\n-DEFINE_INTRINSIC_CMPXCHG(_InterlockedCompareExchange8, char) \/\/ Use the intrinsic as InterlockedCompareExchange8 does not exist\n-DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange,   long)\n-DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange64, __int64)\n-\n-#undef DEFINE_INTRINSIC_CMPXCHG\n-\n-#endif \/\/ OS_CPU_WINDOWS_X86_ATOMIC_WINDOWS_X86_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/atomic_windows_x86.hpp","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -35,1 +35,1 @@\n-      Atomic::store(to++, Atomic::load(from++));\n+      AtomicAccess::store(to++, AtomicAccess::load(from++));\n@@ -42,1 +42,1 @@\n-      Atomic::store(to--, Atomic::load(from--));\n+      AtomicAccess::store(to--, AtomicAccess::load(from--));\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/copy_windows_x86.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  fprintf(fp_hpp, \"#define RM_SIZE %d\\n\", RegisterForm::RegMask_Size());\n+  fprintf(fp_hpp, \"#define RM_SIZE_IN_INTS %d\\n\", RegisterForm::RegMask_Size());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-    AOTLinkedClassTable* table = AOTLinkedClassTable::get(CDSConfig::is_dumping_static_archive());\n+    AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n@@ -215,10 +215,1 @@\n-    if (ik->in_aot_cache() && CDSConfig::is_dumping_dynamic_archive()) {\n-      if (CDSConfig::is_using_aot_linked_classes()) {\n-        \/\/ This class was recorded as AOT-linked for the base archive,\n-        \/\/ so there's no need to do so again for the dynamic archive.\n-      } else {\n-        list.append(ik);\n-      }\n-    } else {\n-      list.append(ArchiveBuilder::current()->get_buffered_addr(ik));\n-    }\n+    list.append(ArchiveBuilder::current()->get_buffered_addr(ik));\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n-void AOTLinkedClassBulkLoader::serialize(SerializeClosure* soc, bool is_static_archive) {\n-  AOTLinkedClassTable::get(is_static_archive)->serialize(soc);\n+void AOTLinkedClassBulkLoader::serialize(SerializeClosure* soc) {\n+  AOTLinkedClassTable::get()->serialize(soc);\n@@ -60,1 +60,1 @@\n-    return Atomic::load_acquire(&_all_completed);\n+    return AtomicAccess::load_acquire(&_all_completed);\n@@ -93,1 +93,1 @@\n-  Atomic::release_store(&_all_completed, true);\n+  AtomicAccess::release_store(&_all_completed, true);\n@@ -120,2 +120,2 @@\n-  load_table(AOTLinkedClassTable::for_static_archive(),  class_category, h_loader, CHECK);\n-  load_table(AOTLinkedClassTable::for_dynamic_archive(), class_category, h_loader, CHECK);\n+  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n+  load_table(table, class_category, h_loader, CHECK);\n@@ -125,3 +125,0 @@\n-  \/\/\n-  \/\/ Only the classes in the static archive can have archived mirrors.\n-  AOTLinkedClassTable* static_table = AOTLinkedClassTable::for_static_archive();\n@@ -134,1 +131,1 @@\n-    init_required_classes_for_loader(h_loader, static_table->boot2(), CHECK);\n+    init_required_classes_for_loader(h_loader, table->boot2(), CHECK);\n@@ -137,1 +134,1 @@\n-    init_required_classes_for_loader(h_loader, static_table->platform(), CHECK);\n+    init_required_classes_for_loader(h_loader, table->platform(), CHECK);\n@@ -140,1 +137,1 @@\n-    init_required_classes_for_loader(h_loader, static_table->app(), CHECK);\n+    init_required_classes_for_loader(h_loader, table->app(), CHECK);\n@@ -336,1 +333,1 @@\n-  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::for_static_archive()->boot(), CHECK);\n+  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot(), CHECK);\n@@ -431,2 +428,1 @@\n-    \/\/ Only static archive can have training data.\n-    AOTLinkedClassTable* table = AOTLinkedClassTable::for_static_archive();\n+    AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  static void serialize(SerializeClosure* soc, bool is_static_archive) NOT_CDS_RETURN;\n+  static void serialize(SerializeClosure* soc) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-AOTLinkedClassTable AOTLinkedClassTable::_for_static_archive;\n-AOTLinkedClassTable AOTLinkedClassTable::_for_dynamic_archive;\n+AOTLinkedClassTable AOTLinkedClassTable::_instance;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,4 +42,1 @@\n-  \/\/ The VM may load up to 2 CDS archives -- static and dynamic. Each\n-  \/\/ archive can have its own AOTLinkedClassTable.\n-  static AOTLinkedClassTable _for_static_archive;\n-  static AOTLinkedClassTable _for_dynamic_archive;\n+  static AOTLinkedClassTable _instance;\n@@ -57,5 +54,2 @@\n-  static AOTLinkedClassTable* for_static_archive()  { return &_for_static_archive; }\n-  static AOTLinkedClassTable* for_dynamic_archive() { return &_for_dynamic_archive; }\n-\n-  static AOTLinkedClassTable* get(bool is_static_archive) {\n-    return is_static_archive ? for_static_archive() : for_dynamic_archive();\n+  static AOTLinkedClassTable* get() {\n+    return &_instance;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.hpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-  AOTLinkedClassBulkLoader::serialize(soc, true);\n+  AOTLinkedClassBulkLoader::serialize(soc);\n@@ -790,1 +790,1 @@\n-      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      InstanceKlass* ik = java_lang_Class::as_InstanceKlass(mirror.resolve());\n@@ -817,1 +817,1 @@\n-      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(mirror.resolve()));\n+      InstanceKlass* ik = java_lang_Class::as_InstanceKlass(mirror.resolve());\n@@ -1306,1 +1306,1 @@\n-    vm_exit_during_initialization(\"Unable to use shared archive.\", nullptr);\n+    vm_exit_during_initialization(\"Unable to use shared archive. Unrecoverable archive loading error (run with -Xlog:aot,cds for details)\", message);\n@@ -1434,0 +1434,1 @@\n+    log_info(cds)(\"Opening of static archive %s failed\", static_archive);\n@@ -2010,1 +2011,1 @@\n-    ArchiveBuilder::serialize_dynamic_archivable_items(&rc);\n+    DynamicArchive::serialize(&rc);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -1024,7 +1023,0 @@\n-void ArchiveBuilder::serialize_dynamic_archivable_items(SerializeClosure* soc) {\n-  SymbolTable::serialize_shared_table_header(soc, false);\n-  SystemDictionaryShared::serialize_dictionary_headers(soc, false);\n-  DynamicArchive::serialize_array_klasses(soc);\n-  AOTLinkedClassBulkLoader::serialize(soc, false);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -385,1 +385,0 @@\n-  static void serialize_dynamic_archivable_items(SerializeClosure* soc);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-  assert(Atomic::load(&_state) != WORKING, \"Should not be working\");\n+  assert(AtomicAccess::load(&_state) != WORKING, \"Should not be working\");\n@@ -438,1 +438,1 @@\n-    int cur = Atomic::load(&_started_workers);\n+    int cur = AtomicAccess::load(&_started_workers);\n@@ -442,1 +442,1 @@\n-    if (Atomic::cmpxchg(&_started_workers, cur, cur + 1, memory_order_relaxed) == cur) {\n+    if (AtomicAccess::cmpxchg(&_started_workers, cur, cur + 1, memory_order_relaxed) == cur) {\n@@ -450,3 +450,3 @@\n-  assert(Atomic::load(&_state) == UNUSED, \"Should be unused yet\");\n-  assert(Atomic::load(&_task) == nullptr, \"Should not have running tasks\");\n-  Atomic::store(&_state, WORKING);\n+  assert(AtomicAccess::load(&_state) == UNUSED, \"Should be unused yet\");\n+  assert(AtomicAccess::load(&_task) == nullptr, \"Should not have running tasks\");\n+  AtomicAccess::store(&_state, WORKING);\n@@ -460,2 +460,2 @@\n-  assert(Atomic::load(&_state) == WORKING, \"Should be working\");\n-  Atomic::store(&_state, SHUTDOWN);\n+  assert(AtomicAccess::load(&_state) == WORKING, \"Should be working\");\n+  AtomicAccess::store(&_state, SHUTDOWN);\n@@ -478,2 +478,2 @@\n-  Atomic::store(&_finish_tokens, _num_workers + 1);\n-  Atomic::release_store(&_task, task);\n+  AtomicAccess::store(&_finish_tokens, _num_workers + 1);\n+  AtomicAccess::release_store(&_task, task);\n@@ -497,1 +497,1 @@\n-  while (Atomic::load(&_finish_tokens) != 0) {\n+  while (AtomicAccess::load(&_finish_tokens) != 0) {\n@@ -503,1 +503,1 @@\n-  assert(Atomic::load(&_finish_tokens) == 0, \"All tokens are consumed\");\n+  assert(AtomicAccess::load(&_finish_tokens) == 0, \"All tokens are consumed\");\n@@ -509,1 +509,1 @@\n-  ArchiveWorkerTask* task = Atomic::load_acquire(&_task);\n+  ArchiveWorkerTask* task = AtomicAccess::load_acquire(&_task);\n@@ -517,1 +517,1 @@\n-  if (Atomic::sub(&_finish_tokens, 1, memory_order_relaxed) == 1) {\n+  if (AtomicAccess::sub(&_finish_tokens, 1, memory_order_relaxed) == 1) {\n@@ -521,1 +521,1 @@\n-    int last = Atomic::sub(&_finish_tokens, 1, memory_order_relaxed);\n+    int last = AtomicAccess::sub(&_finish_tokens, 1, memory_order_relaxed);\n@@ -528,1 +528,1 @@\n-    int chunk = Atomic::load(&_chunk);\n+    int chunk = AtomicAccess::load(&_chunk);\n@@ -532,1 +532,1 @@\n-    if (Atomic::cmpxchg(&_chunk, chunk, chunk + 1, memory_order_relaxed) == chunk) {\n+    if (AtomicAccess::cmpxchg(&_chunk, chunk, chunk + 1, memory_order_relaxed) == chunk) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -780,0 +780,7 @@\n+  if (is_dumping_dynamic_archive() && AOTClassLinking) {\n+    if (FLAG_IS_CMDLINE(AOTClassLinking)) {\n+      log_warning(cds)(\"AOTClassLinking is not supported for dynamic CDS archive\");\n+    }\n+    FLAG_SET_ERGO(AOTClassLinking, false);\n+  }\n+\n@@ -886,1 +893,5 @@\n-  return t != nullptr && (t->is_VM_thread() || t == _dumper_thread);\n+  return t->is_VM_thread() || t == _dumper_thread;\n+}\n+\n+bool CDSConfig::current_thread_is_dumper() {\n+  return Thread::current() == _dumper_thread;\n@@ -1038,5 +1049,4 @@\n-  if (is_dumping_preimage_static_archive()) {\n-    return false;\n-  } else if (is_dumping_dynamic_archive()) {\n-    return is_using_full_module_graph() && AOTClassLinking;\n-  } else if (is_dumping_static_archive()) {\n+  if (is_dumping_classic_static_archive() || is_dumping_final_static_archive()) {\n+    \/\/ FMG is required to guarantee that all cached boot\/platform\/app classes\n+    \/\/ are visible in the production run, so they can be unconditionally\n+    \/\/ loaded during VM bootstrap.\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -232,0 +232,1 @@\n+  static bool current_thread_is_dumper() NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -90,1 +90,1 @@\n-  Atomic::store(&_parsing_thread, Thread::current());\n+  AtomicAccess::store(&_parsing_thread, Thread::current());\n@@ -107,1 +107,1 @@\n-  return Atomic::load(&_parsing_thread) == Thread::current();\n+  return AtomicAccess::load(&_parsing_thread) == Thread::current();\n@@ -111,1 +111,1 @@\n-  Atomic::store(&_parsing_thread, (Thread*)nullptr);\n+  AtomicAccess::store(&_parsing_thread, (Thread*)nullptr);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-      AOTClassLinker::write_to_archive();\n@@ -167,1 +166,1 @@\n-      ArchiveBuilder::serialize_dynamic_archivable_items(&wc);\n+      DynamicArchive::serialize(&wc);\n@@ -420,0 +419,6 @@\n+void DynamicArchive::serialize(SerializeClosure* soc) {\n+  SymbolTable::serialize_shared_table_header(soc, false);\n+  SystemDictionaryShared::serialize_dictionary_headers(soc, false);\n+  soc->do_ptr(&_dynamic_archive_array_klasses);\n+}\n+\n@@ -464,4 +469,0 @@\n-void DynamicArchive::serialize_array_klasses(SerializeClosure* soc) {\n-  soc->do_ptr(&_dynamic_archive_array_klasses);\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  static void serialize_array_klasses(SerializeClosure* soc);\n+  static void serialize(SerializeClosure* soc);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+static bool _stop_appending = false;\n@@ -74,0 +75,2 @@\n+  \/\/ This function can be called by concurrent Java threads, even after\n+  \/\/ LambdaFormInvokers::regenerate_holder_classes() has been called.\n@@ -75,0 +78,3 @@\n+  if (_stop_appending) {\n+    return;\n+  }\n@@ -115,6 +121,0 @@\n-  PrintLambdaFormMessage plm;\n-  if (_lambdaform_lines == nullptr || _lambdaform_lines->length() == 0) {\n-    log_info(aot)(\"Nothing to regenerate for holder classes\");\n-    return;\n-  }\n-\n@@ -130,3 +130,1 @@\n-  HandleMark hm(THREAD);\n-  int len = _lambdaform_lines->length();\n-  objArrayHandle list_lines;\n+  assert(CDSConfig::current_thread_is_dumper(), \"not supposed to be called from other threads\");\n@@ -134,0 +132,1 @@\n+    \/\/ Stop other threads from recording into _lambdaform_lines.\n@@ -135,7 +134,17 @@\n-    list_lines = oopFactory::new_objArray_handle(vmClasses::String_klass(), len, CHECK);\n-    for (int i = 0; i < len; i++) {\n-      Handle h_line = java_lang_String::create_from_str(_lambdaform_lines->at(i), CHECK);\n-      list_lines->obj_at_put(i, h_line());\n-    }\n-  } \/\/ Before calling into java, release vm lock.\n-  \/\/\n+    _stop_appending = true;\n+  }\n+\n+  PrintLambdaFormMessage plm;\n+  if (_lambdaform_lines == nullptr || _lambdaform_lines->length() == 0) {\n+    log_info(aot)(\"Nothing to regenerate for lambda form holder classes\");\n+    return;\n+  }\n+\n+  HandleMark hm(THREAD);\n+  int len = _lambdaform_lines->length();\n+  objArrayHandle list_lines = oopFactory::new_objArray_handle(vmClasses::String_klass(), len, CHECK);\n+  for (int i = 0; i < len; i++) {\n+    Handle h_line = java_lang_String::create_from_str(_lambdaform_lines->at(i), CHECK);\n+    list_lines->obj_at_put(i, h_line());\n+  }\n+\n@@ -235,0 +244,1 @@\n+  assert(SafepointSynchronize::is_at_safepoint(), \"no concurrent update to _lambdaform_lines\");\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  return InstanceKlass::cast(java_lang_Class::as_Klass(result.get_oop()));\n+  return java_lang_Class::as_InstanceKlass(result.get_oop());\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+friend class VMStructs;                \\\n","filename":"src\/hotspot\/share\/ci\/ciClassList.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3111,1 +3111,2 @@\n-    verify_legal_class_modifiers(flags, CHECK_0);\n+    Symbol* inner_name_symbol = inner_name_index == 0 ? nullptr : cp->symbol_at(inner_name_index);\n+    verify_legal_class_modifiers(flags, inner_name_symbol, inner_name_index == 0, CHECK_0);\n@@ -4454,1 +4455,2 @@\n-void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {\n+\/\/ Verify the class modifiers for the current class, or an inner class if inner_name is non-null.\n+void ClassFileParser::verify_legal_class_modifiers(jint flags, Symbol* inner_name, bool is_anonymous_inner_class, TRAPS) const {\n@@ -4490,6 +4492,25 @@\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_ClassFormatError(),\n-      \"Illegal class modifiers in class %s%s: 0x%X\",\n-      _class_name->as_C_string(), class_note, flags\n-    );\n+    \/\/ Names are all known to be < 64k so we know this formatted message is not excessively large.\n+    if (inner_name == nullptr && !is_anonymous_inner_class) {\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_ClassFormatError(),\n+        \"Illegal class modifiers in class %s: 0x%X\",\n+        _class_name->as_C_string(), flags\n+      );\n+    } else {\n+      if (is_anonymous_inner_class) {\n+        Exceptions::fthrow(\n+          THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_ClassFormatError(),\n+          \"Illegal class modifiers in anonymous inner class of class %s: 0x%X\",\n+          _class_name->as_C_string(), flags\n+        );\n+      } else {\n+        Exceptions::fthrow(\n+          THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_ClassFormatError(),\n+          \"Illegal class modifiers in inner class %s of class %s: 0x%X\",\n+          inner_name->as_C_string(), _class_name->as_C_string(), flags\n+        );\n+      }\n+    }\n@@ -5871,1 +5892,1 @@\n-  verify_legal_class_modifiers(flags, CHECK);\n+  verify_legal_class_modifiers(flags, nullptr, false, CHECK);\n@@ -6031,2 +6052,2 @@\n-    Atomic::cmpxchg(&counter, (size_t)0, Arguments::default_SharedBaseAddress()); \/\/ initialize it\n-    size_t new_id = Atomic::add(&counter, (size_t)1);\n+    AtomicAccess::cmpxchg(&counter, (size_t)0, Arguments::default_SharedBaseAddress()); \/\/ initialize it\n+    size_t new_id = AtomicAccess::add(&counter, (size_t)1);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -468,4 +468,3 @@\n-  void verify_legal_class_modifiers(jint flags, TRAPS) const;\n-  void verify_legal_field_modifiers(jint flags,\n-                                    AccessFlags class_access_flags,\n-                                    TRAPS) const;\n+  void verify_legal_class_modifiers(jint flags, Symbol* inner_name,\n+                                    bool is_anonymous_inner_class, TRAPS) const;\n+  void verify_legal_field_modifiers(jint flags, AccessFlags class_access_flags, TRAPS) const;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -753,1 +753,1 @@\n-      Atomic::release_store(&_first_append_entry_list, new_entry);\n+      AtomicAccess::release_store(&_first_append_entry_list, new_entry);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-    return Atomic::load_acquire(&_first_append_entry_list);\n+    return AtomicAccess::load_acquire(&_first_append_entry_list);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -33,1 +33,1 @@\n-inline ClassPathEntry* ClassPathEntry::next() const { return Atomic::load_acquire(&_next); }\n+inline ClassPathEntry* ClassPathEntry::next() const { return AtomicAccess::load_acquire(&_next); }\n@@ -37,1 +37,1 @@\n-  Atomic::release_store(&_next, next);\n+  AtomicAccess::release_store(&_next, next);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -196,1 +196,1 @@\n-    Atomic::release_store(&_head, next);\n+    AtomicAccess::release_store(&_head, next);\n@@ -200,1 +200,1 @@\n-  Atomic::release_store(&_head->_size, _head->_size + 1);\n+  AtomicAccess::release_store(&_head->_size, _head->_size + 1);\n@@ -206,1 +206,1 @@\n-  Chunk* chunk = Atomic::load_acquire(&_head);\n+  Chunk* chunk = AtomicAccess::load_acquire(&_head);\n@@ -208,1 +208,1 @@\n-    count += Atomic::load(&chunk->_size);\n+    count += AtomicAccess::load(&chunk->_size);\n@@ -221,1 +221,1 @@\n-  Chunk* head = Atomic::load_acquire(&_head);\n+  Chunk* head = AtomicAccess::load_acquire(&_head);\n@@ -224,1 +224,1 @@\n-    oops_do_chunk(f, head, Atomic::load_acquire(&head->_size));\n+    oops_do_chunk(f, head, AtomicAccess::load_acquire(&head->_size));\n@@ -262,1 +262,1 @@\n-  Chunk* chunk = Atomic::load_acquire(&_head);\n+  Chunk* chunk = AtomicAccess::load_acquire(&_head);\n@@ -264,1 +264,1 @@\n-    if (&(chunk->_data[0]) <= oop_handle && oop_handle < &(chunk->_data[Atomic::load(&chunk->_size)])) {\n+    if (&(chunk->_data[0]) <= oop_handle && oop_handle < &(chunk->_data[AtomicAccess::load(&chunk->_size)])) {\n@@ -275,1 +275,1 @@\n-    int old_claim = Atomic::load(&_claim);\n+    int old_claim = AtomicAccess::load(&_claim);\n@@ -280,1 +280,1 @@\n-    if (Atomic::cmpxchg(&_claim, old_claim, new_claim) == old_claim) {\n+    if (AtomicAccess::cmpxchg(&_claim, old_claim, new_claim) == old_claim) {\n@@ -294,1 +294,1 @@\n-    int old_claim = Atomic::load(&_claim);\n+    int old_claim = AtomicAccess::load(&_claim);\n@@ -299,1 +299,1 @@\n-    if (Atomic::cmpxchg(&_claim, old_claim, new_claim) == old_claim) {\n+    if (AtomicAccess::cmpxchg(&_claim, old_claim, new_claim) == old_claim) {\n@@ -387,1 +387,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+  for (Klass* k = AtomicAccess::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -395,1 +395,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+  for (Klass* k = AtomicAccess::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -403,1 +403,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+  for (Klass* k = AtomicAccess::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -412,1 +412,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+  for (Klass* k = AtomicAccess::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -440,1 +440,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+  for (Klass* k = AtomicAccess::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -450,1 +450,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+  for (Klass* k = AtomicAccess::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -512,1 +512,1 @@\n-    NOT_PRODUCT(Atomic::inc(&_dependency_count));\n+    NOT_PRODUCT(AtomicAccess::inc(&_dependency_count));\n@@ -537,1 +537,1 @@\n-    Atomic::release_store(&_klasses, k);\n+    AtomicAccess::release_store(&_klasses, k);\n@@ -651,1 +651,1 @@\n-  ModuleEntryTable* modules = Atomic::load_acquire(&_modules);\n+  ModuleEntryTable* modules = AtomicAccess::load_acquire(&_modules);\n@@ -661,1 +661,1 @@\n-        Atomic::release_store(&_modules, modules);\n+        AtomicAccess::release_store(&_modules, modules);\n@@ -835,1 +835,1 @@\n-  ClassLoaderMetaspace* metaspace = Atomic::load_acquire(&_metaspace);\n+  ClassLoaderMetaspace* metaspace = AtomicAccess::load_acquire(&_metaspace);\n@@ -849,1 +849,1 @@\n-      Atomic::release_store(&_metaspace, metaspace);\n+      AtomicAccess::release_store(&_metaspace, metaspace);\n@@ -1140,1 +1140,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n+  for (Klass* k = AtomicAccess::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  Atomic::store(&_next, next);\n+  AtomicAccess::store(&_next, next);\n@@ -42,1 +42,1 @@\n-  return Atomic::load(&_next);\n+  return AtomicAccess::load(&_next);\n@@ -47,1 +47,1 @@\n-  Atomic::store(&_next, _next->_next);\n+  AtomicAccess::store(&_next, _next->_next);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -64,1 +64,1 @@\n-  for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n+  for (ClassLoaderData* cld = AtomicAccess::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n@@ -70,1 +70,1 @@\n- for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n+ for (ClassLoaderData* cld = AtomicAccess::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n@@ -77,1 +77,1 @@\n- for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n+ for (ClassLoaderData* cld = AtomicAccess::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n@@ -158,1 +158,1 @@\n-  Atomic::release_store(&_head, cld);\n+  AtomicAccess::release_store(&_head, cld);\n@@ -195,1 +195,1 @@\n-  for (ClassLoaderData* cld = Atomic::load_acquire(&_head);  cld != nullptr; cld = cld->next()) {\n+  for (ClassLoaderData* cld = AtomicAccess::load_acquire(&_head);  cld != nullptr; cld = cld->next()) {\n@@ -202,1 +202,1 @@\n-  for (ClassLoaderData* cld = Atomic::load_acquire(&_head);  cld != nullptr; cld = cld->next()) {\n+  for (ClassLoaderData* cld = AtomicAccess::load_acquire(&_head);  cld != nullptr; cld = cld->next()) {\n@@ -431,1 +431,1 @@\n-        Atomic::store(&_head, data->next());\n+        AtomicAccess::store(&_head, data->next());\n@@ -536,1 +536,1 @@\n-    Klass* old_head = Atomic::cmpxchg(&_next_klass, head, next);\n+    Klass* old_head = AtomicAccess::cmpxchg(&_next_klass, head, next);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -47,1 +47,1 @@\n-  return Atomic::load(&_num_instance_classes);\n+  return AtomicAccess::load(&_num_instance_classes);\n@@ -51,1 +51,1 @@\n-  return Atomic::load(&_num_array_classes);\n+  return AtomicAccess::load(&_num_array_classes);\n@@ -55,1 +55,1 @@\n-  Atomic::add(&_num_instance_classes, count, memory_order_relaxed);\n+  AtomicAccess::add(&_num_instance_classes, count, memory_order_relaxed);\n@@ -59,1 +59,1 @@\n-  size_t old_count = Atomic::fetch_then_add(&_num_instance_classes, -count, memory_order_relaxed);\n+  size_t old_count = AtomicAccess::fetch_then_add(&_num_instance_classes, -count, memory_order_relaxed);\n@@ -64,1 +64,1 @@\n-  Atomic::add(&_num_array_classes, count, memory_order_relaxed);\n+  AtomicAccess::add(&_num_array_classes, count, memory_order_relaxed);\n@@ -68,1 +68,1 @@\n-  size_t old_count = Atomic::fetch_then_add(&_num_array_classes, -count, memory_order_relaxed);\n+  size_t old_count = AtomicAccess::fetch_then_add(&_num_array_classes, -count, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n+#include \"runtime\/reflection.hpp\"\n@@ -209,1 +209,1 @@\n-  uint8_t value = Atomic::load(addr);\n+  uint8_t value = AtomicAccess::load(addr);\n@@ -213,1 +213,1 @@\n-    value = Atomic::cmpxchg(addr, old_value, value);\n+    value = AtomicAccess::cmpxchg(addr, old_value, value);\n@@ -995,1 +995,1 @@\n-void java_lang_Class::initialize_mirror_fields(Klass* k,\n+void java_lang_Class::initialize_mirror_fields(InstanceKlass* ik,\n@@ -1010,1 +1010,1 @@\n-  InstanceKlass::cast(k)->do_local_static_fields(&initialize_static_field, mirror, CHECK);\n+  ik->do_local_static_fields(&initialize_static_field, mirror, CHECK);\n@@ -1126,2 +1126,1 @@\n-\n-    initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n+    initialize_mirror_fields(InstanceKlass::cast(k), mirror, protection_domain, classData, THREAD);\n@@ -2171,1 +2170,1 @@\n-  int res = Atomic::cmpxchg(addr, old_state, new_state);\n+  int res = AtomicAccess::cmpxchg(addr, old_state, new_state);\n@@ -2189,1 +2188,1 @@\n-  jboolean vthread_on_list = Atomic::load(addr);\n+  jboolean vthread_on_list = AtomicAccess::load(addr);\n@@ -2191,1 +2190,1 @@\n-    vthread_on_list = Atomic::cmpxchg(addr, (jboolean)JNI_FALSE, (jboolean)JNI_TRUE);\n+    vthread_on_list = AtomicAccess::cmpxchg(addr, (jboolean)JNI_FALSE, (jboolean)JNI_TRUE);\n@@ -2621,1 +2620,1 @@\n-  InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));\n+  InstanceKlass* holder = java_lang_Class::as_InstanceKlass(mirror());\n@@ -3000,1 +2999,1 @@\n-    InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));\n+    InstanceKlass* holder = java_lang_Class::as_InstanceKlass(bte._mirror());\n@@ -3086,1 +3085,1 @@\n-  InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));\n+  InstanceKlass* holder = java_lang_Class::as_InstanceKlass(bte._mirror());\n@@ -3472,1 +3471,1 @@\n-  Klass* klass = vmClasses::reflect_Method_klass();\n+  InstanceKlass* klass = vmClasses::reflect_Method_klass();\n@@ -3475,2 +3474,2 @@\n-  assert(InstanceKlass::cast(klass)->is_initialized(), \"must be initialized\");\n-  return InstanceKlass::cast(klass)->allocate_instance_handle(THREAD);\n+  assert(klass->is_initialized(), \"must be initialized\");\n+  return klass->allocate_instance_handle(THREAD);\n@@ -3773,4 +3772,1 @@\n-int reflect_ConstantPool::_oop_offset;\n-\n-#define CONSTANTPOOL_FIELDS_DO(macro) \\\n-  macro(_oop_offset, k, \"constantPoolOop\", object_signature, false)\n+int reflect_ConstantPool::_vmholder_offset;\n@@ -3780,2 +3776,2 @@\n-  \/\/ The field is called ConstantPool* in the sun.reflect.ConstantPool class.\n-  CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  \/\/ The field is injected and called Object vmholder in the jdk.internal.reflect.ConstantPool class.\n+  CONSTANTPOOL_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n@@ -3786,1 +3782,1 @@\n-  CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+  CONSTANTPOOL_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n@@ -3939,0 +3935,1 @@\n+  assert(_vmholder_offset != 0, \"Uninitialized vmholder\");\n@@ -3941,1 +3938,1 @@\n-  reflect->obj_field_put(_oop_offset, mirror);\n+  reflect->obj_field_put(_vmholder_offset, mirror);\n@@ -3945,4 +3942,3 @@\n-\n-  oop mirror = reflect->obj_field(_oop_offset);\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  assert(k->is_instance_klass(), \"Must be\");\n+  assert(_vmholder_offset != 0, \"Uninitialized vmholder\");\n+  oop mirror = reflect->obj_field(_vmholder_offset);\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(mirror);\n@@ -3955,1 +3951,1 @@\n-  return InstanceKlass::cast(k)->constants();\n+  return ik->constants();\n@@ -4799,1 +4795,1 @@\n-  return Atomic::load_acquire(loader->field_addr<ClassLoaderData*>(_loader_data_offset));\n+  return AtomicAccess::load_acquire(loader->field_addr<ClassLoaderData*>(_loader_data_offset));\n@@ -4811,1 +4807,1 @@\n-  Atomic::release_store(loader->field_addr<ClassLoaderData*>(_loader_data_offset), new_data);\n+  AtomicAccess::release_store(loader->field_addr<ClassLoaderData*>(_loader_data_offset), new_data);\n@@ -5565,1 +5561,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(klass());\n+  InstanceKlass* ik = klass();\n@@ -5591,1 +5587,0 @@\n-  FilteredFieldsMap::initialize();  \/\/ must be done after computing offsets.\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":28,"deletions":33,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -273,2 +273,1 @@\n-\n-  static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,\n+  static void initialize_mirror_fields(InstanceKlass* ik, Handle mirror, Handle protection_domain,\n@@ -298,1 +297,1 @@\n-  \/\/ Conversion\n+  \/\/ Conversion -- java_class must not be null. The return value is null only if java_class is a primitive type.\n@@ -300,0 +299,2 @@\n+  static InstanceKlass* as_InstanceKlass(oop java_class);\n+\n@@ -940,0 +941,3 @@\n+#define CONSTANTPOOL_INJECTED_FIELDS(macro)                             \\\n+  macro(reflect_ConstantPool, vmholder, object_signature, false)\n+\n@@ -944,2 +948,3 @@\n-  \/\/ offsets at run-time.\n-  static int _oop_offset;\n+  \/\/ offsets at run-time. This field is the oop offset for the\n+  \/\/ actual constant pool, previously called constantPoolOop.\n+  static int _vmholder_offset;\n@@ -957,1 +962,0 @@\n-  static int oop_offset() { CHECK_INIT(_oop_offset); }\n@@ -1904,1 +1908,1 @@\n-  const bool           may_be_java;\n+  const bool may_be_java;\n@@ -1907,2 +1911,2 @@\n-  Klass* klass() const      { return vmClasses::klass_at(klass_id); }\n-  Symbol* name() const      { return lookup_symbol(name_index); }\n+  InstanceKlass* klass() const { return vmClasses::klass_at(klass_id); }\n+  Symbol* name() const { return lookup_symbol(name_index); }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-  return (Atomic::load(flags_addr(java_string)) & flag_mask) != 0;\n+  return (AtomicAccess::load(flags_addr(java_string)) & flag_mask) != 0;\n@@ -294,0 +294,6 @@\n+inline InstanceKlass* java_lang_Class::as_InstanceKlass(oop java_class) {\n+  Klass* k = as_Klass(java_class);\n+  assert(k == nullptr || k->is_instance_klass(), \"type check\");\n+  return static_cast<InstanceKlass*>(k);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-  STACKCHUNK_INJECTED_FIELDS(macro)\n+  STACKCHUNK_INJECTED_FIELDS(macro)         \\\n+  CONSTANTPOOL_INJECTED_FIELDS(macro)\n","filename":"src\/hotspot\/share\/classfile\/javaClassesImpl.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -225,1 +225,1 @@\n-    return((Atomic::load(&_defined_by_cds_in_class_path) & ((int)1 << idx)) != 0);\n+    return((AtomicAccess::load(&_defined_by_cds_in_class_path) & ((int)1 << idx)) != 0);\n@@ -229,1 +229,1 @@\n-    Atomic::fetch_then_or(&_defined_by_cds_in_class_path, ((int)1 << idx));\n+    AtomicAccess::fetch_then_or(&_defined_by_cds_in_class_path, ((int)1 << idx));\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -328,1 +328,1 @@\n-  Atomic::inc(&_items_count);\n+  AtomicAccess::inc(&_items_count);\n@@ -332,1 +332,1 @@\n-  Atomic::dec(&_items_count);\n+  AtomicAccess::dec(&_items_count);\n@@ -348,1 +348,1 @@\n-  return Atomic::load_acquire(&_has_work);\n+  return AtomicAccess::load_acquire(&_has_work);\n@@ -352,1 +352,1 @@\n-  return Atomic::load_acquire(&_items_count);\n+  return AtomicAccess::load_acquire(&_items_count);\n@@ -359,1 +359,1 @@\n-    Atomic::store(&_has_work, true);\n+    AtomicAccess::store(&_has_work, true);\n@@ -513,1 +513,1 @@\n-  assert(!Atomic::load_acquire(&_disable_interning_during_cds_dump),\n+  assert(!AtomicAccess::load_acquire(&_disable_interning_during_cds_dump),\n@@ -669,1 +669,1 @@\n-    Atomic::release_store(&_has_work, false);\n+    AtomicAccess::release_store(&_has_work, false);\n@@ -679,1 +679,1 @@\n-  Atomic::release_store(&_has_work, false);\n+  AtomicAccess::release_store(&_has_work, false);\n@@ -969,1 +969,1 @@\n-  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, true));\n+  DEBUG_ONLY(AtomicAccess::release_store(&_disable_interning_during_cds_dump, true));\n@@ -1108,1 +1108,1 @@\n-  DEBUG_ONLY(Atomic::release_store(&_disable_interning_during_cds_dump, false));\n+  DEBUG_ONLY(AtomicAccess::release_store(&_disable_interning_during_cds_dump, false));\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -219,3 +219,3 @@\n-void SymbolTable::reset_has_items_to_clean() { Atomic::store(&_has_items_to_clean, false); }\n-void SymbolTable::mark_has_items_to_clean()  { Atomic::store(&_has_items_to_clean, true); }\n-bool SymbolTable::has_items_to_clean()       { return Atomic::load(&_has_items_to_clean); }\n+void SymbolTable::reset_has_items_to_clean() { AtomicAccess::store(&_has_items_to_clean, false); }\n+void SymbolTable::mark_has_items_to_clean()  { AtomicAccess::store(&_has_items_to_clean, true); }\n+bool SymbolTable::has_items_to_clean()       { return AtomicAccess::load(&_has_items_to_clean); }\n@@ -224,1 +224,1 @@\n-  Atomic::inc(&_items_count);\n+  AtomicAccess::inc(&_items_count);\n@@ -228,2 +228,2 @@\n-  Atomic::inc(&(_symbols_removed));\n-  Atomic::dec(&_items_count);\n+  AtomicAccess::inc(&(_symbols_removed));\n+  AtomicAccess::dec(&_items_count);\n@@ -240,1 +240,1 @@\n-bool SymbolTable::has_work() { return Atomic::load_acquire(&_has_work); }\n+bool SymbolTable::has_work() { return AtomicAccess::load_acquire(&_has_work); }\n@@ -789,1 +789,1 @@\n-  Atomic::add(&_symbols_counted, stdc._processed);\n+  AtomicAccess::add(&_symbols_counted, stdc._processed);\n@@ -817,1 +817,1 @@\n-    Atomic::release_store(&_has_work, false);\n+    AtomicAccess::release_store(&_has_work, false);\n@@ -827,1 +827,1 @@\n-  Atomic::release_store(&_has_work, false);\n+  AtomicAccess::release_store(&_has_work, false);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1178,1 +1178,1 @@\n-  assert(Atomic::add(&ik->_shared_class_load_count, 1) == 1, \"shared class loaded more than once\");\n+  assert(AtomicAccess::add(&ik->_shared_class_load_count, 1) == 1, \"shared class loaded more than once\");\n@@ -1398,1 +1398,1 @@\n-    \/\/ Primitive classes return null since forName() can not be\n+    \/\/ Primitive classes return null since forName() cannot be\n@@ -1401,1 +1401,1 @@\n-      InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n+      InstanceKlass* k = java_lang_Class::as_InstanceKlass(obj);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -870,5 +870,0 @@\n-    if (CDSConfig::is_dumping_dynamic_archive() && ik->in_aot_cache()) {\n-      \/\/ ik is already part of the static archive, so it will never be considered as excluded.\n-      return false;\n-    }\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -583,1 +583,1 @@\n-      Atomic::dec(&_number_of_nmethods_with_dependencies);\n+      AtomicAccess::dec(&_number_of_nmethods_with_dependencies);\n@@ -619,1 +619,1 @@\n-      Atomic::inc(&_number_of_nmethods_with_dependencies);\n+      AtomicAccess::inc(&_number_of_nmethods_with_dependencies);\n@@ -789,1 +789,1 @@\n-    if (Atomic::cmpxchg(&_unloading_threshold_gc_requested, false, true) == false) {\n+    if (AtomicAccess::cmpxchg(&_unloading_threshold_gc_requested, false, true) == false) {\n@@ -815,1 +815,1 @@\n-    if (Atomic::cmpxchg(&_unloading_threshold_gc_requested, false, true) == false) {\n+    if (AtomicAccess::cmpxchg(&_unloading_threshold_gc_requested, false, true) == false) {\n@@ -902,1 +902,1 @@\n-      ExceptionCache* purge_list_head = Atomic::load(&_exception_cache_purge_list);\n+      ExceptionCache* purge_list_head = AtomicAccess::load(&_exception_cache_purge_list);\n@@ -904,1 +904,1 @@\n-      if (Atomic::cmpxchg(&_exception_cache_purge_list, purge_list_head, entry) == purge_list_head) {\n+      if (AtomicAccess::cmpxchg(&_exception_cache_purge_list, purge_list_head, entry) == purge_list_head) {\n@@ -1155,1 +1155,1 @@\n-  return Atomic::load_acquire(&_number_of_nmethods_with_dependencies) != 0;\n+  return AtomicAccess::load_acquire(&_number_of_nmethods_with_dependencies) != 0;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -107,2 +107,2 @@\n-    Atomic::store(&_speculated_klass, (uintptr_t)0);\n-    Atomic::store(&_speculated_method, (Method*)nullptr);\n+    AtomicAccess::store(&_speculated_klass, (uintptr_t)0);\n+    AtomicAccess::store(&_speculated_method, (Method*)nullptr);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -110,1 +110,1 @@\n-  nmethodBucket* head = Atomic::load(_dependency_context_addr);\n+  nmethodBucket* head = AtomicAccess::load(_dependency_context_addr);\n@@ -124,1 +124,1 @@\n-    if (Atomic::cmpxchg(_dependency_context_addr, head, new_head) == head) {\n+    if (AtomicAccess::cmpxchg(_dependency_context_addr, head, new_head) == head) {\n@@ -127,1 +127,1 @@\n-    head = Atomic::load(_dependency_context_addr);\n+    head = AtomicAccess::load(_dependency_context_addr);\n@@ -145,1 +145,1 @@\n-      nmethodBucket* purge_list_head = Atomic::load(&_purge_list);\n+      nmethodBucket* purge_list_head = AtomicAccess::load(&_purge_list);\n@@ -147,1 +147,1 @@\n-      if (Atomic::cmpxchg(&_purge_list, purge_list_head, b) == purge_list_head) {\n+      if (AtomicAccess::cmpxchg(&_purge_list, purge_list_head, b) == purge_list_head) {\n@@ -199,1 +199,1 @@\n-  nmethodBucket* first = Atomic::load_acquire(_dependency_context_addr);\n+  nmethodBucket* first = AtomicAccess::load_acquire(_dependency_context_addr);\n@@ -214,1 +214,1 @@\n-  nmethodBucket* old_purge_list_head = Atomic::load(&_purge_list);\n+  nmethodBucket* old_purge_list_head = AtomicAccess::load(&_purge_list);\n@@ -217,1 +217,1 @@\n-    nmethodBucket* next_purge_list_head = Atomic::cmpxchg(&_purge_list, old_purge_list_head, first);\n+    nmethodBucket* next_purge_list_head = AtomicAccess::cmpxchg(&_purge_list, old_purge_list_head, first);\n@@ -267,2 +267,2 @@\n-  uint64_t cleaning_epoch = Atomic::load(&_cleaning_epoch);\n-  uint64_t last_cleanup = Atomic::load(_last_cleanup_addr);\n+  uint64_t cleaning_epoch = AtomicAccess::load(&_cleaning_epoch);\n+  uint64_t last_cleanup = AtomicAccess::load(_last_cleanup_addr);\n@@ -272,1 +272,1 @@\n-  return Atomic::cmpxchg(_last_cleanup_addr, last_cleanup, cleaning_epoch) == last_cleanup;\n+  return AtomicAccess::cmpxchg(_last_cleanup_addr, last_cleanup, cleaning_epoch) == last_cleanup;\n@@ -276,1 +276,1 @@\n-  return Atomic::load(&_cleaning_epoch) == 0;\n+  return AtomicAccess::load(&_cleaning_epoch) == 0;\n@@ -285,1 +285,1 @@\n-    nmethodBucket* head = Atomic::load_acquire(_dependency_context_addr);\n+    nmethodBucket* head = AtomicAccess::load_acquire(_dependency_context_addr);\n@@ -291,1 +291,1 @@\n-    if (Atomic::load(_dependency_context_addr) != head) {\n+    if (AtomicAccess::load(_dependency_context_addr) != head) {\n@@ -295,1 +295,1 @@\n-    if (Atomic::cmpxchg(_dependency_context_addr, head, head_next) == head) {\n+    if (AtomicAccess::cmpxchg(_dependency_context_addr, head, head_next) == head) {\n@@ -304,1 +304,1 @@\n-  Atomic::store(_dependency_context_addr, b);\n+  AtomicAccess::store(_dependency_context_addr, b);\n@@ -308,1 +308,1 @@\n-  return Atomic::load(_dependency_context_addr);\n+  return AtomicAccess::load(_dependency_context_addr);\n@@ -317,1 +317,1 @@\n-  Atomic::store(&_cleaning_epoch, epoch);\n+  AtomicAccess::store(&_cleaning_epoch, epoch);\n@@ -327,1 +327,1 @@\n-  Atomic::store(&_cleaning_epoch, epoch);\n+  AtomicAccess::store(&_cleaning_epoch, epoch);\n@@ -339,1 +339,1 @@\n-    nmethodBucket* next = Atomic::load(&_next);\n+    nmethodBucket* next = AtomicAccess::load(&_next);\n@@ -343,1 +343,1 @@\n-    nmethodBucket* next_next = Atomic::load(&next->_next);\n+    nmethodBucket* next_next = AtomicAccess::load(&next->_next);\n@@ -345,1 +345,1 @@\n-    if (Atomic::load(&_next) != next) {\n+    if (AtomicAccess::load(&_next) != next) {\n@@ -349,1 +349,1 @@\n-    if (Atomic::cmpxchg(&_next, next, next_next) == next) {\n+    if (AtomicAccess::cmpxchg(&_next, next, next_next) == next) {\n@@ -358,1 +358,1 @@\n-  return Atomic::load(&_next);\n+  return AtomicAccess::load(&_next);\n@@ -362,1 +362,1 @@\n-  Atomic::store(&_next, b);\n+  AtomicAccess::store(&_next, b);\n@@ -366,1 +366,1 @@\n-  return Atomic::load(&_purge_list_next);\n+  return AtomicAccess::load(&_purge_list_next);\n@@ -370,1 +370,1 @@\n-  Atomic::store(&_purge_list_next, b);\n+  AtomicAccess::store(&_purge_list_next, b);\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -379,1 +379,1 @@\n-  return Atomic::load(&_next);\n+  return AtomicAccess::load(&_next);\n@@ -383,1 +383,1 @@\n-  Atomic::store(&_next, ec);\n+  AtomicAccess::store(&_next, ec);\n@@ -495,1 +495,1 @@\n-    Atomic::store(&_deoptimization_status, deoptimize_done);\n+    AtomicAccess::store(&_deoptimization_status, deoptimize_done);\n@@ -500,1 +500,1 @@\n-  return Atomic::load_acquire(&_exception_cache);\n+  return AtomicAccess::load_acquire(&_exception_cache);\n@@ -520,1 +520,1 @@\n-        if (Atomic::cmpxchg(&_exception_cache, ec, next) == ec) {\n+        if (AtomicAccess::cmpxchg(&_exception_cache, ec, next) == ec) {\n@@ -530,1 +530,1 @@\n-    if (Atomic::cmpxchg(&_exception_cache, ec, new_entry) == ec) {\n+    if (AtomicAccess::cmpxchg(&_exception_cache, ec, new_entry) == ec) {\n@@ -563,1 +563,1 @@\n-        if (Atomic::cmpxchg(&_exception_cache, curr, next) != curr) {\n+        if (AtomicAccess::cmpxchg(&_exception_cache, curr, next) != curr) {\n@@ -933,1 +933,1 @@\n-          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n+          AtomicAccess::store(r->metadata_addr(), (Method*)nullptr);\n@@ -1945,1 +1945,1 @@\n-  Atomic::store(&_gc_epoch, CodeCache::gc_epoch());\n+  AtomicAccess::store(&_gc_epoch, CodeCache::gc_epoch());\n@@ -1951,1 +1951,1 @@\n-  return Atomic::load(&_gc_epoch) >= CodeCache::previous_completed_gc_marking_cycle();\n+  return AtomicAccess::load(&_gc_epoch) >= CodeCache::previous_completed_gc_marking_cycle();\n@@ -1978,1 +1978,1 @@\n-  Atomic::store(&_state, new_state);\n+  AtomicAccess::store(&_state, new_state);\n@@ -2029,1 +2029,1 @@\n-  if (Atomic::load(&_state) == not_entrant) {\n+  if (AtomicAccess::load(&_state) == not_entrant) {\n@@ -2041,1 +2041,1 @@\n-    if (Atomic::load(&_state) == not_entrant) {\n+    if (AtomicAccess::load(&_state) == not_entrant) {\n@@ -2412,1 +2412,1 @@\n-  uint8_t state = Atomic::load(&_is_unloading_state);\n+  uint8_t state = AtomicAccess::load(&_is_unloading_state);\n@@ -2435,1 +2435,1 @@\n-  uint8_t found_state = Atomic::cmpxchg(&_is_unloading_state, state, new_state, memory_order_relaxed);\n+  uint8_t found_state = AtomicAccess::cmpxchg(&_is_unloading_state, state, new_state, memory_order_relaxed);\n@@ -2448,1 +2448,1 @@\n-  Atomic::store(&_is_unloading_state, state);\n+  AtomicAccess::store(&_is_unloading_state, state);\n@@ -2533,1 +2533,1 @@\n-      (Atomic::replace_if_null(&_oops_do_mark_link, mark_link(this, claim_weak_request_tag)))) {\n+      (AtomicAccess::replace_if_null(&_oops_do_mark_link, mark_link(this, claim_weak_request_tag)))) {\n@@ -2547,1 +2547,1 @@\n-  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, mark_link(nullptr, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n+  oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_oops_do_mark_link, mark_link(nullptr, claim_weak_request_tag), mark_link(this, claim_strong_done_tag));\n@@ -2558,1 +2558,1 @@\n-  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, next, mark_link(this, claim_strong_request_tag));\n+  oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_oops_do_mark_link, next, mark_link(this, claim_strong_request_tag));\n@@ -2569,1 +2569,1 @@\n-  oops_do_mark_link* old_next = Atomic::cmpxchg(&_oops_do_mark_link, next, mark_link(extract_nmethod(next), claim_strong_done_tag));\n+  oops_do_mark_link* old_next = AtomicAccess::cmpxchg(&_oops_do_mark_link, next, mark_link(extract_nmethod(next), claim_strong_done_tag));\n@@ -2584,1 +2584,1 @@\n-  nmethod* old_head = Atomic::xchg(&_oops_do_mark_nmethods, this);\n+  nmethod* old_head = AtomicAccess::xchg(&_oops_do_mark_nmethods, this);\n@@ -2590,1 +2590,1 @@\n-  if (Atomic::cmpxchg(&_oops_do_mark_link, mark_link(this, claim_weak_request_tag), mark_link(old_head, claim_weak_done_tag)) == mark_link(this, claim_weak_request_tag)) {\n+  if (AtomicAccess::cmpxchg(&_oops_do_mark_link, mark_link(this, claim_weak_request_tag), mark_link(old_head, claim_weak_done_tag)) == mark_link(this, claim_weak_request_tag)) {\n@@ -2601,1 +2601,1 @@\n-  nmethod* old_head = Atomic::xchg(&_oops_do_mark_nmethods, this);\n+  nmethod* old_head = AtomicAccess::xchg(&_oops_do_mark_nmethods, this);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    return Atomic::load(&_deoptimization_status);\n+    return AtomicAccess::load(&_deoptimization_status);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -46,1 +46,1 @@\n-inline int ExceptionCache::count() { return Atomic::load_acquire(&_count); }\n+inline int ExceptionCache::count() { return AtomicAccess::load_acquire(&_count); }\n@@ -59,1 +59,1 @@\n-inline void ExceptionCache::increment_count() { Atomic::release_store(&_count, _count + 1); }\n+inline void ExceptionCache::increment_count() { AtomicAccess::release_store(&_count, _count + 1); }\n","filename":"src\/hotspot\/share\/code\/nmethod.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-      Atomic::store(&_table[i], (VtableStub*)nullptr);\n+      AtomicAccess::store(&_table[i], (VtableStub*)nullptr);\n@@ -274,1 +274,1 @@\n-  VtableStub* s = Atomic::load(&_table[hash]);\n+  VtableStub* s = AtomicAccess::load(&_table[hash]);\n@@ -285,1 +285,1 @@\n-  s->set_next(Atomic::load(&_table[h]));\n+  s->set_next(AtomicAccess::load(&_table[h]));\n@@ -287,1 +287,1 @@\n-  Atomic::release_store(&_table[h], s);\n+  AtomicAccess::release_store(&_table[h], s);\n@@ -299,1 +299,1 @@\n-  for (s = Atomic::load(&_table[hash]); s != nullptr && s->entry_point() != pc; s = s->next()) {}\n+  for (s = AtomicAccess::load(&_table[hash]); s != nullptr && s->entry_point() != pc; s = s->next()) {}\n@@ -312,1 +312,1 @@\n-    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n+    for (VtableStub* s = AtomicAccess::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n@@ -325,1 +325,1 @@\n-    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n+    for (VtableStub* s = AtomicAccess::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -905,1 +905,1 @@\n-        if (Atomic::cmpxchg(&_arenastat_oom_crash, (ArenaStatCounter*) nullptr, arena_stat) != nullptr) {\n+        if (AtomicAccess::cmpxchg(&_arenastat_oom_crash, (ArenaStatCounter*) nullptr, arena_stat) != nullptr) {\n@@ -995,1 +995,1 @@\n-  return Atomic::load(&_arenastat_oom_crash) != nullptr;\n+  return AtomicAccess::load(&_arenastat_oom_crash) != nullptr;\n@@ -1003,1 +1003,1 @@\n-  const ArenaStatCounter* const oom_stats = Atomic::load(&_arenastat_oom_crash);\n+  const ArenaStatCounter* const oom_stats = AtomicAccess::load(&_arenastat_oom_crash);\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -227,0 +227,4 @@\n+\n+  \/\/ First, disarm the timeout. This still relies on the underlying task.\n+  thread->timeout()->disarm();\n+\n@@ -232,1 +236,0 @@\n-  thread->timeout()->disarm();\n@@ -1590,1 +1593,1 @@\n-    return Atomic::add(CICountNative ? &_native_compilation_id : &_compilation_id, 1);\n+    return AtomicAccess::add(CICountNative ? &_native_compilation_id : &_compilation_id, 1);\n@@ -1592,1 +1595,1 @@\n-    id = Atomic::add(&_osr_compilation_id, 1);\n+    id = AtomicAccess::add(&_osr_compilation_id, 1);\n@@ -1597,1 +1600,1 @@\n-    id = Atomic::add(&_compilation_id, 1);\n+    id = AtomicAccess::add(&_compilation_id, 1);\n@@ -1609,1 +1612,1 @@\n-  return Atomic::add(&_compilation_id, 1);\n+  return AtomicAccess::add(&_compilation_id, 1);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -365,1 +365,1 @@\n-    jint old = Atomic::cmpxchg(&_should_compile_new_jobs, 1-new_state, new_state);\n+    jint old = AtomicAccess::cmpxchg(&_should_compile_new_jobs, 1-new_state, new_state);\n@@ -380,1 +380,1 @@\n-    Atomic::xchg(&_should_compile_new_jobs, jint(shutdown_compilation));\n+    AtomicAccess::xchg(&_should_compile_new_jobs, jint(shutdown_compilation));\n@@ -384,1 +384,1 @@\n-    return Atomic::load(&_should_compile_new_jobs) == shutdown_compilation;\n+    return AtomicAccess::load(&_should_compile_new_jobs) == shutdown_compilation;\n@@ -392,1 +392,1 @@\n-    jint old = Atomic::cmpxchg(&_print_compilation_warning, 0, 1);\n+    jint old = AtomicAccess::cmpxchg(&_print_compilation_warning, 0, 1);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -54,1 +54,1 @@\n-    CompileLog* head = Atomic::load_acquire(&_list_head);\n+    CompileLog* head = AtomicAccess::load_acquire(&_list_head);\n@@ -56,1 +56,1 @@\n-    if (Atomic::cmpxchg(&_list_head, head, this) == head) {\n+    if (AtomicAccess::cmpxchg(&_list_head, head, this) == head) {\n@@ -209,1 +209,1 @@\n-  CompileLog* log = Atomic::load_acquire(&_list_head);\n+  CompileLog* log = AtomicAccess::load_acquire(&_list_head);\n@@ -297,1 +297,1 @@\n-  Atomic::store(&_list_head, (CompileLog*)nullptr);\n+  AtomicAccess::store(&_list_head, (CompileLog*)nullptr);\n","filename":"src\/hotspot\/share\/compiler\/compileLog.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  Atomic::add(&_active_tasks, 1, memory_order_relaxed);\n+  AtomicAccess::add(&_active_tasks, 1, memory_order_relaxed);\n@@ -94,1 +94,1 @@\n-  if (Atomic::sub(&_active_tasks, 1, memory_order_relaxed) == 0) {\n+  if (AtomicAccess::sub(&_active_tasks, 1, memory_order_relaxed) == 0) {\n@@ -102,1 +102,1 @@\n-  while (Atomic::load(&_active_tasks) > 0) {\n+  while (AtomicAccess::load(&_active_tasks) > 0) {\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -157,1 +157,1 @@\n-    if ((used - last >= _step_counter_update) && Atomic::cmpxchg(&_last_counter_update, last, used) == last) {\n+    if ((used - last >= _step_counter_update) && AtomicAccess::cmpxchg(&_last_counter_update, last, used) == last) {\n@@ -165,1 +165,1 @@\n-    if ((used - last >= _step_heap_print) && Atomic::cmpxchg(&_last_heap_print, last, used) == last) {\n+    if ((used - last >= _step_heap_print) && AtomicAccess::cmpxchg(&_last_heap_print, last, used) == last) {\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -43,1 +43,1 @@\n-  task = Atomic::fetch_then_add(&_num_serial_tasks_done, 1);\n+  task = AtomicAccess::fetch_then_add(&_num_serial_tasks_done, 1);\n@@ -99,2 +99,2 @@\n-  assert(Atomic::load(&_num_serial_tasks_done) >= _serial_tasks.length(),\n-         \"Only %d tasks of %d claimed\", Atomic::load(&_num_serial_tasks_done), _serial_tasks.length());\n+  assert(AtomicAccess::load(&_num_serial_tasks_done) >= _serial_tasks.length(),\n+         \"Only %d tasks of %d claimed\", AtomicAccess::load(&_num_serial_tasks_done), _serial_tasks.length());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BatchedTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  Atomic::store(addr, offset);\n+  AtomicAccess::store(addr, offset);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -55,1 +55,1 @@\n-  return Atomic::load(addr);\n+  return AtomicAccess::load(addr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -218,1 +218,1 @@\n-  Atomic::inc(&_coarsen_from[tag], memory_order_relaxed);\n+  AtomicAccess::inc(&_coarsen_from[tag], memory_order_relaxed);\n@@ -220,1 +220,1 @@\n-    Atomic::inc(&_coarsen_collision[tag], memory_order_relaxed);\n+    AtomicAccess::inc(&_coarsen_collision[tag], memory_order_relaxed);\n@@ -317,1 +317,1 @@\n-      Atomic::store(&_inserted_card, true);\n+      AtomicAccess::store(&_inserted_card, true);\n@@ -346,1 +346,1 @@\n-    if (Atomic::load(&_inserted_card)) {\n+    if (AtomicAccess::load(&_inserted_card)) {\n@@ -348,1 +348,1 @@\n-      Atomic::store(&_inserted_card, false);\n+      AtomicAccess::store(&_inserted_card, false);\n@@ -465,1 +465,1 @@\n-    ContainerPtr container = Atomic::load_acquire(container_addr);\n+    ContainerPtr container = AtomicAccess::load_acquire(container_addr);\n@@ -508,1 +508,1 @@\n-      ContainerPtr cur_container = Atomic::load_acquire(container_addr);\n+      ContainerPtr cur_container = AtomicAccess::load_acquire(container_addr);\n@@ -514,1 +514,1 @@\n-      ContainerPtr old_value = Atomic::cmpxchg(container_addr, cur_container, G1CardSet::FullCardSet);\n+      ContainerPtr old_value = AtomicAccess::cmpxchg(container_addr, cur_container, G1CardSet::FullCardSet);\n@@ -550,1 +550,1 @@\n-    if (Atomic::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n+    if (AtomicAccess::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n@@ -574,1 +574,1 @@\n-    Atomic::inc(&howl->_num_entries, memory_order_relaxed);\n+    AtomicAccess::inc(&howl->_num_entries, memory_order_relaxed);\n@@ -643,1 +643,1 @@\n-  ContainerPtr old_value = Atomic::cmpxchg(container_addr, cur_container, new_container); \/\/ Memory order?\n+  ContainerPtr old_value = AtomicAccess::cmpxchg(container_addr, cur_container, new_container); \/\/ Memory order?\n@@ -690,1 +690,1 @@\n-    Atomic::add(&_num_occupied, _config->max_cards_in_region() - table_entry->_num_occupied, memory_order_relaxed);\n+    AtomicAccess::add(&_num_occupied, _config->max_cards_in_region() - table_entry->_num_occupied, memory_order_relaxed);\n@@ -716,1 +716,1 @@\n-    Atomic::add(&howling_array->_num_entries, diff, memory_order_relaxed);\n+    AtomicAccess::add(&howling_array->_num_entries, diff, memory_order_relaxed);\n@@ -721,1 +721,1 @@\n-    Atomic::add(&table_entry->_num_occupied, diff, memory_order_relaxed);\n+    AtomicAccess::add(&table_entry->_num_occupied, diff, memory_order_relaxed);\n@@ -723,1 +723,1 @@\n-    Atomic::add(&_num_occupied, diff, memory_order_relaxed);\n+    AtomicAccess::add(&_num_occupied, diff, memory_order_relaxed);\n@@ -830,2 +830,2 @@\n-    Atomic::inc(&table_entry->_num_occupied, memory_order_relaxed);\n-    Atomic::inc(&_num_occupied, memory_order_relaxed);\n+    AtomicAccess::inc(&table_entry->_num_occupied, memory_order_relaxed);\n+    AtomicAccess::inc(&_num_occupied, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -154,1 +154,1 @@\n-  uintptr_t refcount() const { return Atomic::load_acquire(&_ref_count); }\n+  uintptr_t refcount() const { return AtomicAccess::load_acquire(&_ref_count); }\n@@ -195,1 +195,1 @@\n-      Atomic::release_store(_num_entries_addr, _local_num_entries);\n+      AtomicAccess::release_store(_num_entries_addr, _local_num_entries);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    ContainerPtr old_value = Atomic::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n+    ContainerPtr old_value = AtomicAccess::cmpxchg(_value_addr, _value, new_value, memory_order_relaxed);\n@@ -129,1 +129,1 @@\n-    uintptr_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n+    uintptr_t ref_count = AtomicAccess::cmpxchg(&_ref_count, old_value, new_value);\n@@ -140,1 +140,1 @@\n-  return Atomic::sub(&_ref_count, 2u);\n+  return AtomicAccess::sub(&_ref_count, 2u);\n@@ -155,1 +155,1 @@\n-  EntryCountType num_entries = Atomic::load(_num_entries_addr) & EntryMask;\n+  EntryCountType num_entries = AtomicAccess::load(_num_entries_addr) & EntryMask;\n@@ -157,3 +157,3 @@\n-    EntryCountType old_value = Atomic::cmpxchg(_num_entries_addr,\n-                                               num_entries,\n-                                               (EntryCountType)(num_entries | LockBitMask));\n+    EntryCountType old_value = AtomicAccess::cmpxchg(_num_entries_addr,\n+                                                     num_entries,\n+                                                     (EntryCountType)(num_entries | LockBitMask));\n@@ -192,1 +192,1 @@\n-  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType num_entries = AtomicAccess::load_acquire(&_num_entries) & EntryMask;\n@@ -226,1 +226,1 @@\n-  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType num_entries = AtomicAccess::load_acquire(&_num_entries) & EntryMask;\n@@ -238,1 +238,1 @@\n-  EntryCountType num_entries = Atomic::load_acquire(&_num_entries) & EntryMask;\n+  EntryCountType num_entries = AtomicAccess::load_acquire(&_num_entries) & EntryMask;\n@@ -263,1 +263,1 @@\n-    Atomic::inc(&_num_bits_set, memory_order_relaxed);\n+    AtomicAccess::inc(&_num_bits_set, memory_order_relaxed);\n@@ -314,1 +314,1 @@\n-  ContainerPtr container = Atomic::load_acquire(array_entry);\n+  ContainerPtr container = AtomicAccess::load_acquire(array_entry);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -123,1 +123,1 @@\n-      Atomic::inc(&_num_entries);\n+      AtomicAccess::inc(&_num_entries);\n@@ -134,1 +134,1 @@\n-      Atomic::dec(&_num_entries);\n+      AtomicAccess::dec(&_num_entries);\n@@ -185,1 +185,1 @@\n-      size_t current_size = Atomic::sub(&_num_entries, num_deleted);\n+      size_t current_size = AtomicAccess::sub(&_num_entries, num_deleted);\n@@ -229,1 +229,1 @@\n-  size_t number_of_entries() const { return Atomic::load(&_num_entries); }\n+  size_t number_of_entries() const { return AtomicAccess::load(&_num_entries); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1203,1 +1203,1 @@\n-  _young_regions_cset_group(card_set_config(), &_card_set_freelist_pool, 1u \/* group_id *\/),\n+  _young_regions_cset_group(card_set_config(), &_card_set_freelist_pool, G1CSetCandidateGroup::YoungRegionId),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -56,1 +56,1 @@\n-  if (Atomic::load(&_cur_claim) >= _list.length()) {\n+  if (AtomicAccess::load(&_cur_claim) >= _list.length()) {\n@@ -59,1 +59,1 @@\n-  uint claim = Atomic::fetch_then_add(&_cur_claim, _claim_step);\n+  uint claim = AtomicAccess::fetch_then_add(&_cur_claim, _claim_step);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -388,0 +388,10 @@\n+void G1CollectionSet::add_optional_group(G1CSetCandidateGroup* group,\n+                                         uint& num_optional_regions,\n+                                         double& predicted_optional_time_ms,\n+                                         double predicted_time_ms) {\n+  _optional_groups.append(group);\n+  prepare_optional_group(group, num_optional_regions);\n+  num_optional_regions += group->length();\n+  predicted_optional_time_ms += predicted_time_ms;\n+}\n+\n@@ -407,0 +417,2 @@\n+  bool make_first_group_optional = G1ForceOptionalEvacuation;\n+\n@@ -424,0 +436,9 @@\n+    if (make_first_group_optional) {\n+        make_first_group_optional = false;\n+        add_optional_group(group,\n+                           num_optional_regions,\n+                           predicted_optional_time_ms,\n+                           predicted_time_ms);\n+        continue;\n+    }\n+\n@@ -459,4 +480,4 @@\n-        _optional_groups.append(group);\n-        prepare_optional_group(group, num_optional_regions);\n-        num_optional_regions += group->length();\n-        predicted_optional_time_ms += predicted_time_ms;\n+        add_optional_group(group,\n+                           num_optional_regions,\n+                           predicted_optional_time_ms,\n+                           predicted_time_ms);\n@@ -563,4 +584,4 @@\n-      _optional_groups.append(group);\n-      prepare_optional_group(group, num_optional_regions);\n-      num_optional_regions += group->length();\n-      predicted_optional_time_ms += predicted_time_ms;\n+      add_optional_group(group,\n+                         num_optional_regions,\n+                         predicted_optional_time_ms,\n+                         predicted_time_ms);\n@@ -644,2 +665,0 @@\n-  time_remaining_ms -= total_prediction_ms;\n-\n@@ -648,0 +667,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -223,0 +223,7 @@\n+\n+  \/\/ Adds the given group to the optional groups list (_optional_groups)\n+  \/\/ and updates all related bookkeeping.\n+  void add_optional_group(G1CSetCandidateGroup* group,\n+                          uint& num_optional_regions,\n+                          double& predicted_optional_time_ms,\n+                          double predicted_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-uint G1CSetCandidateGroup::_next_group_id = 2;\n+uint G1CSetCandidateGroup::_next_group_id = G1CSetCandidateGroup::InitialId;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,6 +76,12 @@\n-  \/\/ The _group_id is primarily used when printing out per-region liveness information,\n-  \/\/ making it easier to associate regions with their assigned G1CSetCandidateGroup, if any.\n-  \/\/ Note:\n-  \/\/ * _group_id 0 is reserved for special G1CSetCandidateGroups that hold only a single region,\n-  \/\/    such as G1CSetCandidateGroups for retained regions.\n-  \/\/ * _group_id 1 is reserved for the G1CSetCandidateGroup that contains all young regions.\n+public:\n+  \/\/ The _group_id uniquely identifies a candidate group when printing, making it\n+  \/\/ easier to associate regions with their assigned G1CSetCandidateGroup, if any.\n+  \/\/ Special values for the id:\n+  \/\/ * id 0 is reserved for regions that do not have a remembered set.\n+  \/\/ * id 1 is reserved for the G1CollectionSetCandidate that contains all young regions.\n+  \/\/ * other ids are handed out incrementally, starting from InitialId.\n+  static const uint NoRemSetId = 0;\n+  static const uint YoungRegionId = 1;\n+  static const uint InitialId = 2;\n+\n+private:\n@@ -84,0 +90,1 @@\n+\n@@ -98,2 +105,0 @@\n-  uint group_id() const { return _group_id; }\n-\n@@ -130,0 +135,2 @@\n+  uint group_id() const { return _group_id; }\n+\n@@ -131,1 +138,1 @@\n-    _next_group_id = 2;\n+    _next_group_id = InitialId;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -108,1 +108,1 @@\n-      uint result = Atomic::add(&_cur_claim_idx, _chunk_size);\n+      uint result = AtomicAccess::add(&_cur_claim_idx, _chunk_size);\n@@ -211,1 +211,1 @@\n-      Atomic::add(&_num_regions_added, num_regions);\n+      AtomicAccess::add(&_num_regions_added, num_regions);\n@@ -223,1 +223,1 @@\n-    uint num_candidates = Atomic::load(&_num_regions_added);\n+    uint num_candidates = AtomicAccess::load(&_num_regions_added);\n@@ -256,1 +256,1 @@\n-    Atomic::sub(&_num_regions_added, num_pruned, memory_order_relaxed);\n+    AtomicAccess::sub(&_num_regions_added, num_pruned, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -154,1 +154,1 @@\n-  size_t cur_idx = Atomic::fetch_then_add(&_size, 1u);\n+  size_t cur_idx = AtomicAccess::fetch_then_add(&_size, 1u);\n@@ -161,1 +161,1 @@\n-  if (Atomic::load_acquire(&_buckets[bucket]) == nullptr) {\n+  if (AtomicAccess::load_acquire(&_buckets[bucket]) == nullptr) {\n@@ -168,1 +168,1 @@\n-    if (Atomic::load_acquire(&_buckets[bucket]) == nullptr) {\n+    if (AtomicAccess::load_acquire(&_buckets[bucket]) == nullptr) {\n@@ -261,1 +261,1 @@\n-    if (Atomic::load_acquire(&_buckets[i]) != nullptr) {\n+    if (AtomicAccess::load_acquire(&_buckets[i]) != nullptr) {\n@@ -281,1 +281,1 @@\n-    Atomic::release_store(&_buckets[i], bucket_base);\n+    AtomicAccess::release_store(&_buckets[i], bucket_base);\n@@ -386,1 +386,1 @@\n-  size_t idx = Atomic::fetch_then_add(&_num_root_regions, 1u);\n+  size_t idx = AtomicAccess::fetch_then_add(&_num_root_regions, 1u);\n@@ -414,1 +414,1 @@\n-  size_t claimed_index = Atomic::fetch_then_add(&_claimed_root_regions, 1u);\n+  size_t claimed_index = AtomicAccess::fetch_then_add(&_claimed_root_regions, 1u);\n@@ -1112,1 +1112,1 @@\n-  return Atomic::load(&_completed_mark_cycles);\n+  return AtomicAccess::load(&_completed_mark_cycles);\n@@ -1121,1 +1121,1 @@\n-    Atomic::inc(&_completed_mark_cycles, memory_order_relaxed);\n+    AtomicAccess::inc(&_completed_mark_cycles, memory_order_relaxed);\n@@ -1323,1 +1323,1 @@\n-    Atomic::add(&_total_selected_for_rebuild, on_region_cl._num_selected_for_rebuild);\n+    AtomicAccess::add(&_total_selected_for_rebuild, on_region_cl._num_selected_for_rebuild);\n@@ -1906,1 +1906,1 @@\n-    HeapWord* res = Atomic::cmpxchg(&_finger, finger, end);\n+    HeapWord* res = AtomicAccess::cmpxchg(&_finger, finger, end);\n@@ -3055,5 +3055,3 @@\n-  uint cset_group_id     = 0;\n-\n-  if (r->rem_set()->has_cset_group()) {\n-    cset_group_id = r->rem_set()->cset_group_id();\n-  }\n+  uint cset_group_id     = r->rem_set()->has_cset_group()\n+                         ? r->rem_set()->cset_group_id()\n+                         : G1CSetCandidateGroup::NoRemSetId;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-  uint old_wanted = Atomic::load(&_threads_wanted);\n+  uint old_wanted = AtomicAccess::load(&_threads_wanted);\n@@ -363,1 +363,1 @@\n-  Atomic::store(&_threads_wanted, new_wanted);\n+  AtomicAccess::store(&_threads_wanted, new_wanted);\n@@ -377,1 +377,1 @@\n-      Atomic::store(&_threads_wanted, i);\n+      AtomicAccess::store(&_threads_wanted, i);\n@@ -387,1 +387,1 @@\n-    uint wanted = Atomic::load(&_threads_wanted);\n+    uint wanted = AtomicAccess::load(&_threads_wanted);\n@@ -389,1 +389,1 @@\n-      Atomic::store(&_threads_wanted, --wanted);\n+      AtomicAccess::store(&_threads_wanted, --wanted);\n@@ -401,1 +401,1 @@\n-  return worker_id < Atomic::load(&_threads_wanted);\n+  return worker_id < AtomicAccess::load(&_threads_wanted);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -120,1 +120,1 @@\n-  return Atomic::load(&_num_cards);\n+  return AtomicAccess::load(&_num_cards);\n@@ -127,1 +127,1 @@\n-  Atomic::add(&_num_cards, cbn->size());\n+  AtomicAccess::add(&_num_cards, cbn->size());\n@@ -163,1 +163,1 @@\n-  Atomic::sub(&_num_cards, result->size());\n+  AtomicAccess::sub(&_num_cards, result->size());\n@@ -175,1 +175,1 @@\n-  assert(actual == Atomic::load(&_num_cards),\n+  assert(actual == AtomicAccess::load(&_num_cards),\n@@ -177,1 +177,1 @@\n-         Atomic::load(&_num_cards), actual);\n+         AtomicAccess::load(&_num_cards), actual);\n@@ -188,1 +188,1 @@\n-  assert(Atomic::load(&_head) == nullptr, \"precondition\");\n+  assert(AtomicAccess::load(&_head) == nullptr, \"precondition\");\n@@ -201,1 +201,1 @@\n-  BufferNode* old_head = Atomic::xchg(&_head, node);\n+  BufferNode* old_head = AtomicAccess::xchg(&_head, node);\n@@ -211,1 +211,1 @@\n-  BufferNode* head = Atomic::load(&_head);\n+  BufferNode* head = AtomicAccess::load(&_head);\n@@ -213,1 +213,1 @@\n-  Atomic::store(&_head, (BufferNode*)nullptr);\n+  AtomicAccess::store(&_head, (BufferNode*)nullptr);\n@@ -222,1 +222,1 @@\n-  assert(Atomic::load(&_plist) == nullptr, \"invariant\");\n+  assert(AtomicAccess::load(&_plist) == nullptr, \"invariant\");\n@@ -228,1 +228,1 @@\n-  PausedList* plist = Atomic::load_acquire(&_plist);\n+  PausedList* plist = AtomicAccess::load_acquire(&_plist);\n@@ -232,1 +232,1 @@\n-    PausedList* old_plist = Atomic::cmpxchg(&_plist, (PausedList*)nullptr, plist);\n+    PausedList* old_plist = AtomicAccess::cmpxchg(&_plist, (PausedList*)nullptr, plist);\n@@ -250,1 +250,1 @@\n-    previous = Atomic::load_acquire(&_plist);\n+    previous = AtomicAccess::load_acquire(&_plist);\n@@ -254,1 +254,1 @@\n-        (Atomic::cmpxchg(&_plist, previous, (PausedList*)nullptr) != previous)) {\n+        (AtomicAccess::cmpxchg(&_plist, previous, (PausedList*)nullptr) != previous)) {\n@@ -271,1 +271,1 @@\n-  PausedList* plist = Atomic::load(&_plist);\n+  PausedList* plist = AtomicAccess::load(&_plist);\n@@ -273,1 +273,1 @@\n-    Atomic::store(&_plist, (PausedList*)nullptr);\n+    AtomicAccess::store(&_plist, (PausedList*)nullptr);\n@@ -289,1 +289,1 @@\n-  Atomic::add(&_num_cards, node->size());\n+  AtomicAccess::add(&_num_cards, node->size());\n@@ -328,1 +328,1 @@\n-    Atomic::add(&_num_cards, from._entry_count);\n+    AtomicAccess::add(&_num_cards, from._entry_count);\n@@ -337,2 +337,2 @@\n-  size_t num_cards = Atomic::load(&_num_cards);\n-  Atomic::store(&_num_cards, size_t(0));\n+  size_t num_cards = AtomicAccess::load(&_num_cards);\n+  AtomicAccess::store(&_num_cards, size_t(0));\n@@ -483,1 +483,1 @@\n-  if (Atomic::load(&_num_cards) <= Atomic::load(&_mutator_refinement_threshold)) {\n+  if (AtomicAccess::load(&_num_cards) <= AtomicAccess::load(&_mutator_refinement_threshold)) {\n@@ -517,1 +517,1 @@\n-  if (Atomic::load(&_num_cards) <= stop_at) return false;\n+  if (AtomicAccess::load(&_num_cards) <= stop_at) return false;\n@@ -594,1 +594,1 @@\n-  return Atomic::load(&_mutator_refinement_threshold);\n+  return AtomicAccess::load(&_mutator_refinement_threshold);\n@@ -598,1 +598,1 @@\n-  Atomic::store(&_mutator_refinement_threshold, value);\n+  AtomicAccess::store(&_mutator_refinement_threshold, value);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -46,1 +46,1 @@\n-  Atomic::store(&_num_regions_evac_failed, 0u);\n+  AtomicAccess::store(&_num_regions_evac_failed, 0u);\n@@ -72,1 +72,1 @@\n-                                                     Atomic::load(&_num_regions_evac_failed),\n+                                                     AtomicAccess::load(&_num_regions_evac_failed),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -35,1 +35,1 @@\n-  return Atomic::load(&_num_regions_evac_failed);\n+  return AtomicAccess::load(&_num_regions_evac_failed);\n@@ -60,1 +60,1 @@\n-    size_t offset = Atomic::fetch_then_add(&_num_regions_evac_failed, 1u);\n+    size_t offset = AtomicAccess::fetch_then_add(&_num_regions_evac_failed, 1u);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -33,1 +33,1 @@\n-  Atomic::add(&_direct_allocated, value, memory_order_relaxed);\n+  AtomicAccess::add(&_direct_allocated, value, memory_order_relaxed);\n@@ -37,1 +37,1 @@\n-  Atomic::add(&_num_plab_filled, value, memory_order_relaxed);\n+  AtomicAccess::add(&_num_plab_filled, value, memory_order_relaxed);\n@@ -41,1 +41,1 @@\n-  Atomic::add(&_num_direct_allocated, value, memory_order_relaxed);\n+  AtomicAccess::add(&_num_direct_allocated, value, memory_order_relaxed);\n@@ -45,2 +45,2 @@\n-  Atomic::add(&_region_end_waste, value, memory_order_relaxed);\n-  Atomic::inc(&_regions_filled, memory_order_relaxed);\n+  AtomicAccess::add(&_region_end_waste, value, memory_order_relaxed);\n+  AtomicAccess::inc(&_regions_filled, memory_order_relaxed);\n@@ -50,2 +50,2 @@\n-  Atomic::add(&_failure_used, used, memory_order_relaxed);\n-  Atomic::add(&_failure_waste, waste, memory_order_relaxed);\n+  AtomicAccess::add(&_failure_used, used, memory_order_relaxed);\n+  AtomicAccess::add(&_failure_waste, waste, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacStats.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -77,1 +77,1 @@\n-  uintx old_head = Atomic::load(&_head);\n+  uintx old_head = AtomicAccess::load(&_head);\n@@ -83,1 +83,1 @@\n-    new_head = Atomic::cmpxchg(&_head, old_head, new_head);\n+    new_head = AtomicAccess::cmpxchg(&_head, old_head, new_head);\n@@ -95,1 +95,1 @@\n-  uintx old_head = Atomic::load(&_head);\n+  uintx old_head = AtomicAccess::load(&_head);\n@@ -99,1 +99,1 @@\n-    new_head = Atomic::cmpxchg(&_head, old_head, new_head);\n+    new_head = AtomicAccess::cmpxchg(&_head, old_head, new_head);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FreeIdSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -66,1 +66,1 @@\n-  Atomic::store(&_compaction_tops[r->hrm_index()], value);\n+  AtomicAccess::store(&_compaction_tops[r->hrm_index()], value);\n@@ -70,1 +70,1 @@\n-  return Atomic::load(&_compaction_tops[r->hrm_index()]);\n+  return AtomicAccess::load(&_compaction_tops[r->hrm_index()]);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -291,1 +291,1 @@\n-  Atomic::add(&_garbage_bytes, garbage_bytes, memory_order_relaxed);\n+  AtomicAccess::add(&_garbage_bytes, garbage_bytes, memory_order_relaxed);\n@@ -444,1 +444,1 @@\n-  st->print(\"|%3zu\", Atomic::load(&_pinned_object_count));\n+  st->print(\"|%3zu\", AtomicAccess::load(&_pinned_object_count));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,1 @@\n-  size_t pinned_count() const { return Atomic::load(&_pinned_object_count); }\n+  size_t pinned_count() const { return AtomicAccess::load(&_pinned_object_count); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -197,1 +197,1 @@\n-      HeapWord* result = Atomic::cmpxchg(&_top, obj, new_top);\n+      HeapWord* result = AtomicAccess::cmpxchg(&_top, obj, new_top);\n@@ -261,1 +261,1 @@\n-  return Atomic::load_acquire(&_parsable_bottom);\n+  return AtomicAccess::load_acquire(&_parsable_bottom);\n@@ -265,1 +265,1 @@\n-  Atomic::release_store(&_parsable_bottom, bottom());\n+  AtomicAccess::release_store(&_parsable_bottom, bottom());\n@@ -514,1 +514,1 @@\n-  Atomic::add(&_pinned_object_count, value, memory_order_relaxed);\n+  AtomicAccess::add(&_pinned_object_count, value, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -729,1 +729,1 @@\n-  uint old_val = Atomic::cmpxchg(&_claims[region_index], Unclaimed, Claimed);\n+  uint old_val = AtomicAccess::cmpxchg(&_claims[region_index], Unclaimed, Claimed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -64,2 +64,2 @@\n-  Atomic::add(&_num_segments, num, memory_order_relaxed);\n-  Atomic::add(&_mem_size, mem_size, memory_order_relaxed);\n+  AtomicAccess::add(&_num_segments, num, memory_order_relaxed);\n+  AtomicAccess::add(&_mem_size, mem_size, memory_order_relaxed);\n@@ -70,1 +70,1 @@\n-                prefix, Atomic::load(&_num_segments), Atomic::load(&_mem_size));\n+                prefix, AtomicAccess::load(&_num_segments), AtomicAccess::load(&_mem_size));\n@@ -78,2 +78,2 @@\n-  num_segments = Atomic::load(&_num_segments);\n-  mem_size = Atomic::load(&_mem_size);\n+  num_segments = AtomicAccess::load(&_num_segments);\n+  mem_size = AtomicAccess::load(&_mem_size);\n@@ -82,2 +82,2 @@\n-    Atomic::sub(&_num_segments, num_segments, memory_order_relaxed);\n-    Atomic::sub(&_mem_size, mem_size, memory_order_relaxed);\n+    AtomicAccess::sub(&_num_segments, num_segments, memory_order_relaxed);\n+    AtomicAccess::sub(&_mem_size, mem_size, memory_order_relaxed);\n@@ -99,2 +99,2 @@\n-  Atomic::sub(&_num_segments, num_freed, memory_order_relaxed);\n-  Atomic::sub(&_mem_size, mem_size_freed, memory_order_relaxed);\n+  AtomicAccess::sub(&_num_segments, num_freed, memory_order_relaxed);\n+  AtomicAccess::sub(&_mem_size, mem_size_freed, memory_order_relaxed);\n@@ -118,1 +118,1 @@\n-  Segment* old = Atomic::cmpxchg(&_first, prev, next);\n+  Segment* old = AtomicAccess::cmpxchg(&_first, prev, next);\n@@ -129,3 +129,3 @@\n-    Atomic::inc(&_num_segments, memory_order_relaxed);\n-    Atomic::add(&_mem_size, next->mem_size(), memory_order_relaxed);\n-    Atomic::add(&_num_total_slots, next->num_slots(), memory_order_relaxed);\n+    AtomicAccess::inc(&_num_segments, memory_order_relaxed);\n+    AtomicAccess::add(&_mem_size, next->mem_size(), memory_order_relaxed);\n+    AtomicAccess::add(&_num_total_slots, next->num_slots(), memory_order_relaxed);\n@@ -158,1 +158,1 @@\n-  Segment* cur = Atomic::load_acquire(&_first);\n+  Segment* cur = AtomicAccess::load_acquire(&_first);\n@@ -196,1 +196,1 @@\n-  Segment* cur = Atomic::load_acquire(&_first);\n+  Segment* cur = AtomicAccess::load_acquire(&_first);\n@@ -204,1 +204,1 @@\n-      Atomic::inc(&_num_allocated_slots, memory_order_relaxed);\n+      AtomicAccess::inc(&_num_allocated_slots, memory_order_relaxed);\n@@ -216,1 +216,1 @@\n-  return Atomic::load(&_num_segments);\n+  return AtomicAccess::load(&_num_segments);\n@@ -241,1 +241,1 @@\n-  Segment* cur = Atomic::load_acquire(&_first);\n+  Segment* cur = AtomicAccess::load_acquire(&_first);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,1 @@\n-  const Segment* first_segment() const { return Atomic::load(&_first); }\n+  const Segment* first_segment() const { return AtomicAccess::load(&_first); }\n@@ -86,1 +86,1 @@\n-  uint num_total_slots() const { return Atomic::load(&_num_total_slots); }\n+  uint num_total_slots() const { return AtomicAccess::load(&_num_total_slots); }\n@@ -88,1 +88,1 @@\n-    uint allocated = Atomic::load(&_num_allocated_slots);\n+    uint allocated = AtomicAccess::load(&_num_allocated_slots);\n@@ -217,2 +217,2 @@\n-  size_t num_segments() const { return Atomic::load(&_num_segments); }\n-  size_t mem_size() const { return Atomic::load(&_mem_size); }\n+  size_t num_segments() const { return AtomicAccess::load(&_num_segments); }\n+  size_t mem_size() const { return AtomicAccess::load(&_mem_size); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -38,1 +38,1 @@\n-  uint result = Atomic::fetch_then_add(&_next_allocate, 1u, memory_order_relaxed);\n+  uint result = AtomicAccess::fetch_then_add(&_next_allocate, 1u, memory_order_relaxed);\n@@ -51,2 +51,2 @@\n-    Atomic::dec(&_num_segments, memory_order_relaxed);\n-    Atomic::sub(&_mem_size, result->mem_size(), memory_order_relaxed);\n+    AtomicAccess::dec(&_num_segments, memory_order_relaxed);\n+    AtomicAccess::sub(&_mem_size, result->mem_size(), memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1MonotonicArena.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -38,1 +38,1 @@\n-  if (Atomic::load(&_cleaning_claimed)) {\n+  if (AtomicAccess::load(&_cleaning_claimed)) {\n@@ -42,1 +42,1 @@\n-  return !Atomic::cmpxchg(&_cleaning_claimed, false, true);\n+  return !AtomicAccess::cmpxchg(&_cleaning_claimed, false, true);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParallelCleaning.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -207,2 +207,2 @@\n-  Atomic::store(&_young_list_desired_length, new_young_list_desired_length);\n-  Atomic::store(&_young_list_target_length, new_young_list_target_length);\n+  AtomicAccess::store(&_young_list_desired_length, new_young_list_desired_length);\n+  AtomicAccess::store(&_young_list_target_length, new_young_list_target_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -355,2 +355,2 @@\n-  uint young_list_desired_length() const { return Atomic::load(&_young_list_desired_length); }\n-  uint young_list_target_length() const { return Atomic::load(&_young_list_target_length); }\n+  uint young_list_desired_length() const { return AtomicAccess::load(&_young_list_desired_length); }\n+  uint young_list_target_length() const { return AtomicAccess::load(&_young_list_target_length); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -135,1 +135,1 @@\n-  Atomic::add(&_entry_count, node->size());\n+  AtomicAccess::add(&_entry_count, node->size());\n@@ -144,1 +144,1 @@\n-    Atomic::add(&_entry_count, buffers._entry_count);\n+    AtomicAccess::add(&_entry_count, buffers._entry_count);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -50,1 +50,1 @@\n-    Atomic::add(&_target[cur->_region_idx]._live_words, cur->_stats._live_words);\n+    AtomicAccess::add(&_target[cur->_region_idx]._live_words, cur->_stats._live_words);\n@@ -54,1 +54,1 @@\n-    Atomic::add(&_target[cur->_region_idx]._incoming_refs, cur->_stats._incoming_refs);\n+    AtomicAccess::add(&_target[cur->_region_idx]._incoming_refs, cur->_stats._incoming_refs);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -174,1 +174,1 @@\n-      bool marked_as_dirty = Atomic::cmpxchg(&_contains[region], false, true) == false;\n+      bool marked_as_dirty = AtomicAccess::cmpxchg(&_contains[region], false, true) == false;\n@@ -176,1 +176,1 @@\n-        uint allocated = Atomic::fetch_then_add(&_cur_idx, 1u);\n+        uint allocated = AtomicAccess::fetch_then_add(&_cur_idx, 1u);\n@@ -241,1 +241,1 @@\n-        uint next = Atomic::fetch_then_add(&_cur_dirty_regions, num_regions_per_worker);\n+        uint next = AtomicAccess::fetch_then_add(&_cur_dirty_regions, num_regions_per_worker);\n@@ -400,1 +400,1 @@\n-    return Atomic::fetch_then_add(&_card_table_scan_state[region], increment, memory_order_relaxed);\n+    return AtomicAccess::fetch_then_add(&_card_table_scan_state[region], increment, memory_order_relaxed);\n@@ -1337,1 +1337,1 @@\n-            !Atomic::cmpxchg(&_fast_reclaim_handled, false, true)) {\n+            !AtomicAccess::cmpxchg(&_fast_reclaim_handled, false, true)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-    Atomic::add(&_humongous_candidates, candidates);\n+    AtomicAccess::add(&_humongous_candidates, candidates);\n@@ -445,1 +445,1 @@\n-    Atomic::add(&_humongous_total, total);\n+    AtomicAccess::add(&_humongous_total, total);\n@@ -682,1 +682,1 @@\n-      if (!Atomic::cmpxchg(&_pinned_regions_recorded, false, true)) {\n+      if (!AtomicAccess::cmpxchg(&_pinned_regions_recorded, false, true)) {\n@@ -818,0 +818,5 @@\n+  double target_pause_time_ms = MaxGCPauseMillis;\n+\n+  if (G1ForceOptionalEvacuation) {\n+    target_pause_time_ms = DBL_MAX;\n+  }\n@@ -822,1 +827,1 @@\n-    double time_left_ms = MaxGCPauseMillis - time_used_ms;\n+    double time_left_ms = target_pause_time_ms - time_used_ms;\n@@ -824,1 +829,1 @@\n-    if (time_left_ms < 0 ||\n+    if (time_left_ms <= 0 ||\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -599,2 +599,2 @@\n-      BufferNode* next = Atomic::load(&_rdc_buffers[index]._head);\n-      BufferNode* tail = Atomic::load(&_rdc_buffers[index]._tail);\n+      BufferNode* next = AtomicAccess::load(&_rdc_buffers[index]._head);\n+      BufferNode* tail = AtomicAccess::load(&_rdc_buffers[index]._tail);\n@@ -604,1 +604,1 @@\n-        next = Atomic::cmpxchg(&_rdc_buffers[index]._head, node, (node != tail ) ? node->next() : nullptr);\n+        next = AtomicAccess::cmpxchg(&_rdc_buffers[index]._head, node, (node != tail ) ? node->next() : nullptr);\n@@ -872,1 +872,1 @@\n-    bool has_new_retained_regions = Atomic::load(&_num_retained_regions) != 0;\n+    bool has_new_retained_regions = AtomicAccess::load(&_num_retained_regions) != 0;\n@@ -907,1 +907,1 @@\n-    Atomic::add(&_num_retained_regions, cl.num_retained_regions(), memory_order_relaxed);\n+    AtomicAccess::add(&_num_retained_regions, cl.num_retained_regions(), memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -373,0 +373,6 @@\n+  develop(bool, G1ForceOptionalEvacuation, false,                           \\\n+          \"Force optional evacuation for all GCs where there are old gen \"  \\\n+          \"collection set candidates.\"                                      \\\n+          \"Also schedule all available optional groups for evacuation \"     \\\n+          \"regardless of timing.\")                                          \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -574,1 +574,1 @@\n-      if (Atomic::cmpxchg(top_addr(), cur_top, cur_chunk_top) == cur_top) {\n+      if (AtomicAccess::cmpxchg(top_addr(), cur_top, cur_chunk_top) == cur_top) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -133,1 +133,1 @@\n-  Atomic::release_store(end_addr(), mr.end());\n+  AtomicAccess::release_store(end_addr(), mr.end());\n@@ -165,1 +165,1 @@\n-    HeapWord* obj = Atomic::load_acquire(top_addr());\n+    HeapWord* obj = AtomicAccess::load_acquire(top_addr());\n@@ -168,1 +168,1 @@\n-      HeapWord* result = Atomic::cmpxchg(top_addr(), obj, new_top);\n+      HeapWord* result = AtomicAccess::cmpxchg(top_addr(), obj, new_top);\n@@ -187,1 +187,1 @@\n-  return Atomic::cmpxchg(top_addr(), expected_top, obj) == expected_top;\n+  return AtomicAccess::cmpxchg(top_addr(), expected_top, obj) == expected_top;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,0 +278,20 @@\n+HeapWord* ParallelScavengeHeap::mem_allocate_cas_noexpand(size_t size, bool is_tlab) {\n+  \/\/ Try young-gen first.\n+  HeapWord* result = young_gen()->allocate(size);\n+  if (result != nullptr) {\n+    return result;\n+  }\n+\n+  \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n+  if (!is_tlab) {\n+    if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n+      result = old_gen()->cas_allocate_noexpand(size);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -280,2 +300,1 @@\n-    \/\/ Try young-gen first.\n-    HeapWord* result = young_gen()->allocate(size);\n+    HeapWord* result = mem_allocate_cas_noexpand(size, is_tlab);\n@@ -286,21 +305,2 @@\n-    \/\/ Try allocating from the old gen for non-TLAB in certain scenarios.\n-    if (!is_tlab) {\n-      if (!should_alloc_in_eden(size) || _is_heap_almost_full) {\n-        result = old_gen()->cas_allocate_noexpand(size);\n-        if (result != nullptr) {\n-          return result;\n-        }\n-      }\n-    }\n-\n-    \/\/ We don't want to have multiple collections for a single filled generation.\n-    \/\/ To prevent this, each thread tracks the total_collections() value, and if\n-    \/\/ the count has changed, does not do a new collection.\n-    \/\/\n-    \/\/ The collection count must be read only while holding the heap lock. VM\n-    \/\/ operations also hold the heap lock during collections. There is a lock\n-    \/\/ contention case where thread A blocks waiting on the Heap_lock, while\n-    \/\/ thread B is holding it doing a collection. When thread A gets the lock,\n-    \/\/ the collection count has already changed. To prevent duplicate collections,\n-    \/\/ The policy MUST attempt allocations during the same period it reads the\n-    \/\/ total_collections() value!\n+    \/\/ Read total_collections() under the lock so that multiple\n+    \/\/ allocation-failures result in one GC.\n@@ -310,0 +310,8 @@\n+\n+      \/\/ Re-try after acquiring the lock, because a GC might have occurred\n+      \/\/ while waiting for this lock.\n+      result = mem_allocate_cas_noexpand(size, is_tlab);\n+      if (result != nullptr) {\n+        return result;\n+      }\n+\n@@ -472,5 +480,0 @@\n-bool ParallelScavengeHeap::must_clear_all_soft_refs() {\n-  return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||\n-         _gc_cause == GCCause::_wb_full_gc;\n-}\n-\n@@ -479,1 +482,1 @@\n-  bool clear_soft_refs = must_clear_all_soft_refs();\n+  bool clear_soft_refs = GCCause::should_clear_all_soft_refs(_gc_cause);\n@@ -515,1 +518,1 @@\n-    block_index = Atomic::fetch_then_add(&_claimed_index, 1u);\n+    block_index = AtomicAccess::fetch_then_add(&_claimed_index, 1u);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -99,2 +99,0 @@\n-  bool must_clear_all_soft_refs();\n-\n@@ -105,0 +103,1 @@\n+  HeapWord* mem_allocate_cas_noexpand(size_t size, bool is_tlab);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  const uint local_GCTimeRatio = Atomic::load(&GCTimeRatio);\n+  const uint local_GCTimeRatio = AtomicAccess::load(&GCTimeRatio);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n@@ -386,1 +385,1 @@\n-  Atomic::dec(&_preprocessing_active_workers);\n+  AtomicAccess::dec(&_preprocessing_active_workers);\n@@ -388,1 +387,1 @@\n-  while (Atomic::load_acquire(&_preprocessing_active_workers) > 0) {\n+  while (AtomicAccess::load_acquire(&_preprocessing_active_workers) > 0) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n@@ -42,2 +42,3 @@\n-    if (PSScavenge::should_scavenge(p)) {\n-      oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+    oop o = RawAccess<>::oop_load(p);\n+    if (PSScavenge::is_obj_in_young(o)) {\n+      assert(!PSScavenge::is_obj_in_to_space(o), \"Revisiting roots?\");\n@@ -46,6 +47,0 @@\n-      if (log_develop_is_enabled(Trace, gc, scavenge)) {\n-        ResourceMark rm; \/\/ required by internal_name()\n-        log_develop_trace(gc, scavenge)(\"{%s %s \" PTR_FORMAT \" -> \" PTR_FORMAT \" (%zu)}\",\n-                                        \"forwarding\",\n-                                        new_obj->klass()->internal_name(), p2i((void *)o), p2i((void *)new_obj), new_obj->size());\n-      }\n@@ -92,4 +87,1 @@\n-    ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();\n-    assert(!psh->is_in_reserved(p), \"GC barrier needed\");\n-    if (PSScavenge::should_scavenge(p)) {\n-      assert(PSScavenge::should_scavenge(p, true), \"revisiting object?\");\n+    assert(!ParallelScavengeHeap::heap()->is_in_reserved(p), \"GC barrier needed\");\n@@ -97,1 +89,3 @@\n-      oop o = RawAccess<IS_NOT_NULL>::oop_load(p);\n+    oop o = RawAccess<>::oop_load(p);\n+    if (PSScavenge::is_obj_in_young(o)) {\n+      assert(!PSScavenge::is_obj_in_to_space(o), \"Revisiting roots?\");\n@@ -101,1 +95,1 @@\n-      if (PSScavenge::is_obj_in_young(new_obj) && !_has_oops_into_young_gen) {\n+      if (!_has_oops_into_young_gen && PSScavenge::is_obj_in_young(new_obj)) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psClosure.inline.hpp","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1302,1 +1302,1 @@\n-    uint counter = Atomic::fetch_then_add(claim_counter, num_regions_per_stripe);\n+    uint counter = AtomicAccess::fetch_then_add(claim_counter, num_regions_per_stripe);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -446,1 +446,1 @@\n-  Atomic::add(&_dc_and_los, dc_mask);\n+  AtomicAccess::add(&_dc_and_los, dc_mask);\n@@ -469,1 +469,1 @@\n-  Atomic::add(&_dc_and_los, static_cast<region_sz_t>(words));\n+  AtomicAccess::add(&_dc_and_los, static_cast<region_sz_t>(words));\n@@ -475,1 +475,1 @@\n-  const region_sz_t old = Atomic::cmpxchg(&_dc_and_los, los, dc_claimed | los);\n+  const region_sz_t old = AtomicAccess::cmpxchg(&_dc_and_los, los, dc_claimed | los);\n@@ -480,1 +480,1 @@\n-  return Atomic::cmpxchg(&_shadow_state, UnusedRegion, NormalRegion) == UnusedRegion;\n+  return AtomicAccess::cmpxchg(&_shadow_state, UnusedRegion, NormalRegion) == UnusedRegion;\n@@ -485,1 +485,1 @@\n-  return Atomic::cmpxchg(&_shadow_state, UnusedRegion, ShadowRegion) == UnusedRegion;\n+  return AtomicAccess::cmpxchg(&_shadow_state, UnusedRegion, ShadowRegion) == UnusedRegion;\n@@ -489,1 +489,1 @@\n-  int old = Atomic::cmpxchg(&_shadow_state, ShadowRegion, FilledShadow);\n+  int old = AtomicAccess::cmpxchg(&_shadow_state, ShadowRegion, FilledShadow);\n@@ -494,1 +494,1 @@\n-  return Atomic::cmpxchg(&_shadow_state, FilledShadow, CopiedShadow) == FilledShadow;\n+  return AtomicAccess::cmpxchg(&_shadow_state, FilledShadow, CopiedShadow) == FilledShadow;\n@@ -498,1 +498,1 @@\n-  int old = Atomic::cmpxchg(&_shadow_state, ShadowRegion, NormalRegion);\n+  int old = AtomicAccess::cmpxchg(&_shadow_state, ShadowRegion, NormalRegion);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n@@ -90,9 +90,0 @@\n-\/\/ Helper functions to get around the circular dependency between\n-\/\/ psScavenge.inline.hpp and psPromotionManager.inline.hpp.\n-bool PSPromotionManager::should_scavenge(oop* p, bool check_to_space) {\n-  return PSScavenge::should_scavenge(p, check_to_space);\n-}\n-bool PSPromotionManager::should_scavenge(narrowOop* p, bool check_to_space) {\n-  return PSScavenge::should_scavenge(p, check_to_space);\n-}\n-\n@@ -216,1 +207,1 @@\n-void PSPromotionManager::drain_stacks_depth(bool totally_drain) {\n+void PSPromotionManager::drain_stacks(bool totally_drain) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -153,4 +153,0 @@\n-  void drain_stacks(bool totally_drain) {\n-    drain_stacks_depth(totally_drain);\n-  }\n- public:\n@@ -159,1 +155,1 @@\n-      drain_stacks_depth(false);\n+      drain_stacks(false);\n@@ -162,1 +158,1 @@\n-  void drain_stacks_depth(bool totally_drain);\n+  void drain_stacks(bool totally_drain);\n@@ -170,3 +166,0 @@\n-  static bool should_scavenge(oop* p, bool check_to_space = false);\n-  static bool should_scavenge(narrowOop* p, bool check_to_space = false);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n@@ -142,1 +142,2 @@\n-  assert(should_scavenge(&o), \"Sanity\");\n+  assert(PSScavenge::is_obj_in_young(o), \"precondition\");\n+  assert(!PSScavenge::is_obj_in_to_space(o), \"precondition\");\n@@ -238,3 +239,1 @@\n-  assert(should_scavenge(&o), \"Sanity\");\n-\n-  oop new_obj = nullptr;\n+  HeapWord* new_obj_addr = nullptr;\n@@ -263,1 +262,1 @@\n-      new_obj = cast_to_oop(allocate_in_young_gen(klass, new_obj_size, age));\n+      new_obj_addr = allocate_in_young_gen(klass, new_obj_size, age);\n@@ -268,3 +267,3 @@\n-  if (new_obj == nullptr) {\n-    new_obj = cast_to_oop(allocate_in_old_gen(klass, new_obj_size, age));\n-    if (new_obj == nullptr) {\n+  if (new_obj_addr == nullptr) {\n+    new_obj_addr = allocate_in_old_gen(klass, new_obj_size, age);\n+    if (new_obj_addr == nullptr) {\n@@ -276,1 +275,1 @@\n-  assert(new_obj != nullptr, \"allocation should have succeeded\");\n+  assert(new_obj_addr != nullptr, \"allocation should have succeeded\");\n@@ -279,1 +278,1 @@\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(o), cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(o), new_obj_addr, new_obj_size);\n@@ -286,1 +285,1 @@\n-  oop forwardee = o->forward_to_atomic(new_obj, test_mark, memory_order_relaxed);\n+  oop forwardee = o->forward_to_atomic(cast_to_oop(new_obj_addr), test_mark, memory_order_relaxed);\n@@ -289,0 +288,1 @@\n+    oop new_obj = cast_to_oop(new_obj_addr);\n@@ -325,1 +325,1 @@\n-      _old_lab.unallocate_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n+      _old_lab.unallocate_object(new_obj_addr, new_obj_size);\n@@ -327,1 +327,1 @@\n-      _young_lab.unallocate_object(cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n+      _young_lab.unallocate_object(new_obj_addr, new_obj_size);\n@@ -337,1 +337,0 @@\n-  assert(should_scavenge(p, true), \"revisiting object?\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"gc\/parallel\/psScavenge.inline.hpp\"\n+#include \"gc\/parallel\/psScavenge.hpp\"\n@@ -130,1 +130,1 @@\n-      pm->drain_stacks_depth(true);\n+      pm->drain_stacks(true);\n@@ -151,2 +151,0 @@\n-protected:\n-  MutableSpace* _to_space;\n@@ -157,3 +155,0 @@\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    _to_space = heap->young_gen()->to_space();\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -103,9 +103,0 @@\n-  template <class T> static inline bool should_scavenge(T* p);\n-\n-  \/\/ These call should_scavenge() above and, if it returns true, also check that\n-  \/\/ the object was not newly copied into to_space.  The version with the bool\n-  \/\/ argument is a convenience wrapper that fetches the to_space pointer from\n-  \/\/ the heap and calls the other version (if the arg is true).\n-  template <class T> static inline bool should_scavenge(T* p, MutableSpace* to_space);\n-  template <class T> static inline bool should_scavenge(T* p, bool check_to_space);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_PARALLEL_PSSCAVENGE_INLINE_HPP\n-#define SHARE_GC_PARALLEL_PSSCAVENGE_INLINE_HPP\n-\n-#include \"gc\/parallel\/psScavenge.hpp\"\n-\n-#include \"gc\/parallel\/parallelScavengeHeap.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-template <class T> inline bool PSScavenge::should_scavenge(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  return PSScavenge::is_obj_in_young(heap_oop);\n-}\n-\n-template <class T>\n-inline bool PSScavenge::should_scavenge(T* p, MutableSpace* to_space) {\n-  if (should_scavenge(p)) {\n-    oop obj = RawAccess<IS_NOT_NULL>::oop_load(p);\n-    \/\/ Skip objects copied to to_space since the scavenge started.\n-    HeapWord* const addr = cast_from_oop<HeapWord*>(obj);\n-    return addr < to_space->bottom() || addr >= to_space->end();\n-  }\n-  return false;\n-}\n-\n-template <class T>\n-inline bool PSScavenge::should_scavenge(T* p, bool check_to_space) {\n-  if (check_to_space) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    return should_scavenge(p, heap->young_gen()->to_space());\n-  }\n-  return should_scavenge(p);\n-}\n-\n-#endif \/\/ SHARE_GC_PARALLEL_PSSCAVENGE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.inline.hpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/spaceCounters.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,6 @@\n-    ClassLoaderData* _scanned_cld;\n+  public:\n+    \/\/ Records whether this CLD contains oops pointing into young-gen after scavenging.\n+    bool _has_oops_into_young_gen;\n+\n+    CLDOopClosure(DefNewGeneration* g) : OffHeapScanClosure(g),\n+      _has_oops_into_young_gen(false) {}\n@@ -99,2 +104,1 @@\n-    template <typename T>\n-    void do_oop_work(T* p) {\n+    void do_oop(oop* p) {\n@@ -104,3 +108,2 @@\n-        assert(_scanned_cld != nullptr, \"inv\");\n-        if (is_in_young_gen(new_obj) && !_scanned_cld->has_modified_oops()) {\n-          _scanned_cld->record_modified_oops();\n+        if (!_has_oops_into_young_gen && is_in_young_gen(new_obj)) {\n+          _has_oops_into_young_gen = true;\n@@ -111,10 +114,0 @@\n-  public:\n-    CLDOopClosure(DefNewGeneration* g) : OffHeapScanClosure(g),\n-      _scanned_cld(nullptr) {}\n-\n-    void set_scanned_cld(ClassLoaderData* cld) {\n-      assert(cld == nullptr || _scanned_cld == nullptr, \"Must be\");\n-      _scanned_cld = cld;\n-    }\n-\n-    void do_oop(oop* p)       { do_oop_work(p); }\n@@ -124,1 +117,1 @@\n-  CLDOopClosure _oop_closure;\n+  DefNewGeneration* _g;\n@@ -126,1 +119,1 @@\n-  CLDScanClosure(DefNewGeneration* g) : _oop_closure(g) {}\n+  CLDScanClosure(DefNewGeneration* g) : _g(g) {}\n@@ -131,1 +124,3 @@\n-    if (cld->has_modified_oops()) {\n+    if (!cld->has_modified_oops()) {\n+      return;\n+    }\n@@ -133,3 +128,1 @@\n-      \/\/ Tell the closure which CLD is being scanned so that it can be dirtied\n-      \/\/ if oops are left pointing into the young gen.\n-      _oop_closure.set_scanned_cld(cld);\n+    CLDOopClosure oop_closure{_g};\n@@ -137,2 +130,2 @@\n-      \/\/ Clean the cld since we're going to scavenge all the metadata.\n-      cld->oops_do(&_oop_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n+    \/\/ Clean the cld since we're going to scavenge all the metadata.\n+    cld->oops_do(&oop_closure, ClassLoaderData::_claim_none, \/*clear_modified_oops*\/true);\n@@ -140,1 +133,2 @@\n-      _oop_closure.set_scanned_cld(nullptr);\n+    if (oop_closure._has_oops_into_young_gen) {\n+      cld->record_modified_oops();\n@@ -609,1 +603,0 @@\n-    StrongRootsScope srs(0);\n@@ -613,3 +606,2 @@\n-    MarkingNMethodClosure nmethod_closure(&oop_closure,\n-                                          NMethodToOopClosure::FixRelocations,\n-                                          false \/* keepalive_nmethods *\/);\n+    NMethodToOopClosure nmethod_closure(&oop_closure,\n+                                        NMethodToOopClosure::FixRelocations);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -343,5 +343,0 @@\n-bool SerialHeap::must_clear_all_soft_refs() {\n-  return _gc_cause == GCCause::_metadata_GC_clear_soft_refs ||\n-         _gc_cause == GCCause::_wb_full_gc;\n-}\n-\n@@ -500,1 +495,1 @@\n-  bool clear_soft_refs = must_clear_all_soft_refs();\n+  bool clear_soft_refs = GCCause::should_clear_all_soft_refs(_gc_cause);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n@@ -107,4 +106,0 @@\n-  \/\/ Does the \"cause\" of GC indicate that\n-  \/\/ we absolutely __must__ clear soft refs?\n-  bool must_clear_all_soft_refs();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-      if (Atomic::add(&counter, 1u) % 10 == 0) {\n+      if (AtomicAccess::add(&counter, 1u) % 10 == 0) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,1 +279,0 @@\n-  _soft_ref_policy(),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n@@ -107,2 +106,0 @@\n-  SoftRefPolicy _soft_ref_policy;\n-\n@@ -399,3 +396,0 @@\n-  \/\/ Return the SoftRefPolicy for the heap;\n-  SoftRefPolicy* soft_ref_policy() { return &_soft_ref_policy; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -51,1 +51,1 @@\n-  Atomic::release_store(&_has_terminated, true);\n+  AtomicAccess::release_store(&_has_terminated, true);\n@@ -60,1 +60,1 @@\n-  Atomic::release_store_fence(&_should_terminate, true);\n+  AtomicAccess::release_store_fence(&_should_terminate, true);\n@@ -72,1 +72,1 @@\n-  return Atomic::load_acquire(&_should_terminate);\n+  return AtomicAccess::load_acquire(&_should_terminate);\n@@ -76,1 +76,1 @@\n-  return Atomic::load_acquire(&_has_terminated);\n+  return AtomicAccess::load_acquire(&_has_terminated);\n","filename":"src\/hotspot\/share\/gc\/shared\/concurrentGCThread.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  FreeNode* old_head = Atomic::xchg(&_head, node);\n+  FreeNode* old_head = AtomicAccess::xchg(&_head, node);\n@@ -51,1 +51,1 @@\n-  return Atomic::add(&_count, size_t(1));\n+  return AtomicAccess::add(&_count, size_t(1));\n@@ -55,2 +55,2 @@\n-  NodeList result{Atomic::load(&_head), _tail, Atomic::load(&_count)};\n-  Atomic::store(&_head, (FreeNode*)nullptr);\n+  NodeList result{AtomicAccess::load(&_head), _tail, AtomicAccess::load(&_count)};\n+  AtomicAccess::store(&_head, (FreeNode*)nullptr);\n@@ -58,1 +58,1 @@\n-  Atomic::store(&_count, size_t(0));\n+  AtomicAccess::store(&_count, size_t(0));\n@@ -63,1 +63,1 @@\n-  return  Atomic::load(&_count);\n+  return  AtomicAccess::load(&_count);\n@@ -88,1 +88,1 @@\n-  uint index = Atomic::load(&_active_pending_list);\n+  uint index = AtomicAccess::load(&_active_pending_list);\n@@ -96,1 +96,1 @@\n-  uint index = Atomic::load(&_active_pending_list);\n+  uint index = AtomicAccess::load(&_active_pending_list);\n@@ -103,1 +103,1 @@\n-  return Atomic::load(&_free_count);\n+  return AtomicAccess::load(&_free_count);\n@@ -107,1 +107,1 @@\n-  uint index = Atomic::load(&_active_pending_list);\n+  uint index = AtomicAccess::load(&_active_pending_list);\n@@ -127,1 +127,1 @@\n-    size_t count = Atomic::sub(&_free_count, 1u);\n+    size_t count = AtomicAccess::sub(&_free_count, 1u);\n@@ -152,1 +152,1 @@\n-    uint index = Atomic::load_acquire(&_active_pending_list);\n+    uint index = AtomicAccess::load_acquire(&_active_pending_list);\n@@ -167,2 +167,2 @@\n-  if (Atomic::load(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n-      Atomic::cmpxchg(&_transfer_lock, false, true)) {\n+  if (AtomicAccess::load(&_transfer_lock) || \/\/ Skip CAS if likely to fail.\n+      AtomicAccess::cmpxchg(&_transfer_lock, false, true)) {\n@@ -175,1 +175,1 @@\n-  uint index = Atomic::load(&_active_pending_list);\n+  uint index = AtomicAccess::load(&_active_pending_list);\n@@ -177,1 +177,1 @@\n-  Atomic::release_store(&_active_pending_list, new_active);\n+  AtomicAccess::release_store(&_active_pending_list, new_active);\n@@ -189,1 +189,1 @@\n-    Atomic::add(&_free_count, count);\n+    AtomicAccess::add(&_free_count, count);\n@@ -194,1 +194,1 @@\n-  Atomic::release_store(&_transfer_lock, false);\n+  AtomicAccess::release_store(&_transfer_lock, false);\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -69,1 +69,1 @@\n-    FreeNode* next() { return Atomic::load(&_next); }\n+    FreeNode* next() { return AtomicAccess::load(&_next); }\n@@ -73,1 +73,1 @@\n-    void set_next(FreeNode* next) { Atomic::store(&_next, next); }\n+    void set_next(FreeNode* next) { AtomicAccess::store(&_next, next); }\n","filename":"src\/hotspot\/share\/gc\/shared\/freeListAllocator.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -106,0 +106,7 @@\n+  \/\/ Does the \"cause\" of GC indicate that\n+  \/\/ we absolutely __must__ clear soft refs?\n+  inline static bool should_clear_all_soft_refs(GCCause::Cause cause) {\n+    return cause == GCCause::_metadata_GC_clear_soft_refs ||\n+           cause == GCCause::_wb_full_gc;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcCause.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -87,1 +87,1 @@\n-  assert(Atomic::load(&_is_gc_request_pending) == false, \"precondition\");\n+  assert(AtomicAccess::load(&_is_gc_request_pending) == false, \"precondition\");\n@@ -91,1 +91,1 @@\n-  Atomic::store(&_is_gc_request_pending, true);\n+  AtomicAccess::store(&_is_gc_request_pending, true);\n@@ -115,1 +115,1 @@\n-  assert(Atomic::load(&_verify_in_cr_count) == 0, \"inv\");\n+  assert(AtomicAccess::load(&_verify_in_cr_count) == 0, \"inv\");\n@@ -120,1 +120,1 @@\n-  assert(Atomic::load(&_is_gc_request_pending) == true, \"precondition\");\n+  assert(AtomicAccess::load(&_is_gc_request_pending) == true, \"precondition\");\n@@ -122,1 +122,1 @@\n-  Atomic::store(&_is_gc_request_pending, false);\n+  AtomicAccess::store(&_is_gc_request_pending, false);\n@@ -142,1 +142,1 @@\n-    if (!Atomic::load(&_is_gc_request_pending)) {\n+    if (!AtomicAccess::load(&_is_gc_request_pending)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    if (Atomic::load(&_is_gc_request_pending)) {\n+    if (AtomicAccess::load(&_is_gc_request_pending)) {\n@@ -47,1 +47,1 @@\n-    DEBUG_ONLY(Atomic::add(&_verify_in_cr_count, (uint64_t)1);)\n+    DEBUG_ONLY(AtomicAccess::add(&_verify_in_cr_count, (uint64_t)1);)\n@@ -58,1 +58,1 @@\n-    Atomic::add(&_verify_in_cr_count, (uint64_t)-1);\n+    AtomicAccess::add(&_verify_in_cr_count, (uint64_t)-1);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -151,1 +151,1 @@\n-  return Atomic::load_acquire(&_block_count);\n+  return AtomicAccess::load_acquire(&_block_count);\n@@ -155,1 +155,1 @@\n-  int new_value = Atomic::add(&_refcount, 1);\n+  int new_value = AtomicAccess::add(&_refcount, 1);\n@@ -160,1 +160,1 @@\n-  int new_value = Atomic::sub(&_refcount, 1);\n+  int new_value = AtomicAccess::sub(&_refcount, 1);\n@@ -172,1 +172,1 @@\n-    Atomic::release_store(&_block_count, index + 1);\n+    AtomicAccess::release_store(&_block_count, index + 1);\n@@ -275,2 +275,2 @@\n-  return (Atomic::load_acquire(&_release_refcount) == 0) &&\n-         (Atomic::load_acquire(&_deferred_updates_next) == nullptr);\n+  return (AtomicAccess::load_acquire(&_release_refcount) == 0) &&\n+         (AtomicAccess::load_acquire(&_deferred_updates_next) == nullptr);\n@@ -324,1 +324,1 @@\n-  uintx sum = Atomic::add(&_allocated_bitmask, add);\n+  uintx sum = AtomicAccess::add(&_allocated_bitmask, add);\n@@ -455,1 +455,1 @@\n-  Atomic::inc(&_allocation_count); \/\/ release updates outside lock.\n+  AtomicAccess::inc(&_allocation_count); \/\/ release updates outside lock.\n@@ -493,1 +493,1 @@\n-  Atomic::add(&_allocation_count, num_taken);\n+  AtomicAccess::add(&_allocation_count, num_taken);\n@@ -509,1 +509,1 @@\n-    Atomic::sub(&_allocation_count, num_taken - limit);\n+    AtomicAccess::sub(&_allocation_count, num_taken - limit);\n@@ -602,1 +602,1 @@\n-  Atomic::release_store(&_active_array, new_array);\n+  AtomicAccess::release_store(&_active_array, new_array);\n@@ -620,1 +620,1 @@\n-  ActiveArray* result = Atomic::load_acquire(&_active_array);\n+  ActiveArray* result = AtomicAccess::load_acquire(&_active_array);\n@@ -675,1 +675,1 @@\n-  Atomic::inc(&_release_refcount);\n+  AtomicAccess::inc(&_release_refcount);\n@@ -682,1 +682,1 @@\n-    uintx fetched = Atomic::cmpxchg(&_allocated_bitmask, old_allocated, new_value);\n+    uintx fetched = AtomicAccess::cmpxchg(&_allocated_bitmask, old_allocated, new_value);\n@@ -701,1 +701,1 @@\n-    if (Atomic::replace_if_null(&_deferred_updates_next, this)) {\n+    if (AtomicAccess::replace_if_null(&_deferred_updates_next, this)) {\n@@ -706,1 +706,1 @@\n-        Block* fetched = Atomic::cmpxchg(&owner->_deferred_updates, head, this);\n+        Block* fetched = AtomicAccess::cmpxchg(&owner->_deferred_updates, head, this);\n@@ -723,1 +723,1 @@\n-  Atomic::dec(&_release_refcount);\n+  AtomicAccess::dec(&_release_refcount);\n@@ -732,1 +732,1 @@\n-  Block* block = Atomic::load_acquire(&_deferred_updates);\n+  Block* block = AtomicAccess::load_acquire(&_deferred_updates);\n@@ -738,1 +738,1 @@\n-    Block* fetched = Atomic::cmpxchg(&_deferred_updates, block, tail);\n+    Block* fetched = AtomicAccess::cmpxchg(&_deferred_updates, block, tail);\n@@ -783,1 +783,1 @@\n-  Atomic::dec(&_allocation_count);\n+  AtomicAccess::dec(&_allocation_count);\n@@ -809,1 +809,1 @@\n-    Atomic::sub(&_allocation_count, count);\n+    AtomicAccess::sub(&_allocation_count, count);\n@@ -909,1 +909,1 @@\n-  if (Atomic::load_acquire(&needs_cleanup_requested) &&\n+  if (AtomicAccess::load_acquire(&needs_cleanup_requested) &&\n@@ -914,1 +914,1 @@\n-    Atomic::release_store(&needs_cleanup_requested, false);\n+    AtomicAccess::release_store(&needs_cleanup_requested, false);\n@@ -926,2 +926,2 @@\n-  Atomic::release_store(&_needs_cleanup, true);\n-  Atomic::release_store_fence(&needs_cleanup_requested, true);\n+  AtomicAccess::release_store(&_needs_cleanup, true);\n+  AtomicAccess::release_store_fence(&needs_cleanup_requested, true);\n@@ -933,2 +933,2 @@\n-  if (!Atomic::load_acquire(&_needs_cleanup) &&\n-      (Atomic::load_acquire(&_deferred_updates) == nullptr)) {\n+  if (!AtomicAccess::load_acquire(&_needs_cleanup) &&\n+      (AtomicAccess::load_acquire(&_deferred_updates) == nullptr)) {\n@@ -941,1 +941,1 @@\n-  Atomic::release_store_fence(&_needs_cleanup, false);\n+  AtomicAccess::release_store_fence(&_needs_cleanup, false);\n@@ -1087,1 +1087,1 @@\n-  size_t start = Atomic::load_acquire(&_next_block);\n+  size_t start = AtomicAccess::load_acquire(&_next_block);\n@@ -1100,1 +1100,1 @@\n-  \/\/ Atomic::add with possible overshoot.  This can perform better\n+  \/\/ AtomicAccess::add with possible overshoot.  This can perform better\n@@ -1104,1 +1104,1 @@\n-  size_t end = Atomic::add(&_next_block, step);\n+  size_t end = AtomicAccess::add(&_next_block, step);\n@@ -1131,1 +1131,1 @@\n-  return Atomic::load(&_num_dead);\n+  return AtomicAccess::load(&_num_dead);\n@@ -1135,1 +1135,1 @@\n-  Atomic::add(&_num_dead, num_dead);\n+  AtomicAccess::add(&_num_dead, num_dead);\n@@ -1139,1 +1139,1 @@\n-  _storage->report_num_dead(Atomic::load(&_num_dead));\n+  _storage->report_num_dead(AtomicAccess::load(&_num_dead));\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSetParState.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -71,1 +71,1 @@\n-  } while (Atomic::cmpxchg(&_claimed_nmethod, first, last.method()) != first);\n+  } while (AtomicAccess::cmpxchg(&_claimed_nmethod, first, last.method()) != first);\n@@ -107,1 +107,1 @@\n-  return !Atomic::cmpxchg(&_clean_klass_tree_claimed, false, true);\n+  return !AtomicAccess::cmpxchg(&_clean_klass_tree_claimed, false, true);\n","filename":"src\/hotspot\/share\/gc\/shared\/parallelCleaning.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -51,1 +51,1 @@\n-  size_t new_count = Atomic::add(&_refcount, count, memory_order_relaxed);\n+  size_t new_count = AtomicAccess::add(&_refcount, count, memory_order_relaxed);\n@@ -96,1 +96,1 @@\n-  size_t refcount = Atomic::sub(&state->_refcount, size_t(1), memory_order_release);\n+  size_t refcount = AtomicAccess::sub(&state->_refcount, size_t(1), memory_order_release);\n@@ -120,1 +120,1 @@\n-  uint idx = Atomic::fetch_then_add(&_registered_allocators, 1u, memory_order_relaxed);\n+  uint idx = AtomicAccess::fetch_then_add(&_registered_allocators, 1u, memory_order_relaxed);\n@@ -127,2 +127,2 @@\n-  uint old = Atomic::fetch_then_add(&_released_allocators, 1u, memory_order_relaxed);\n-  assert(old < Atomic::load(&_registered_allocators), \"too many releases\");\n+  uint old = AtomicAccess::fetch_then_add(&_released_allocators, 1u, memory_order_relaxed);\n+  assert(old < AtomicAccess::load(&_registered_allocators), \"too many releases\");\n@@ -133,2 +133,2 @@\n-  uint count = Atomic::load(&_registered_allocators);\n-  assert(count == Atomic::load(&_released_allocators),\n+  uint count = AtomicAccess::load(&_registered_allocators);\n+  assert(count == AtomicAccess::load(&_released_allocators),\n@@ -139,2 +139,2 @@\n-  Atomic::store(&_registered_allocators, 0u);\n-  DEBUG_ONLY(Atomic::store(&_released_allocators, 0u);)\n+  AtomicAccess::store(&_registered_allocators, 0u);\n+  DEBUG_ONLY(AtomicAccess::store(&_released_allocators, 0u);)\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -55,3 +55,3 @@\n-  size_t start = Atomic::fetch_then_add(index_addr,\n-                                        _chunk_size,\n-                                        memory_order_relaxed);\n+  size_t start = AtomicAccess::fetch_then_add(index_addr,\n+                                              _chunk_size,\n+                                              memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -35,1 +35,1 @@\n-  Atomic::add(&_allocated, v);\n+  AtomicAccess::add(&_allocated, v);\n@@ -39,1 +39,1 @@\n-  Atomic::add(&_unused, v);\n+  AtomicAccess::add(&_unused, v);\n@@ -43,1 +43,1 @@\n-  Atomic::add(&_wasted, v);\n+  AtomicAccess::add(&_wasted, v);\n@@ -47,1 +47,1 @@\n-  Atomic::add(&_undo_wasted, v);\n+  AtomicAccess::add(&_undo_wasted, v);\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -63,1 +63,1 @@\n-    Atomic::add(total_size_addr, stack_size);\n+    AtomicAccess::add(total_size_addr, stack_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -55,1 +55,1 @@\n-    char* cur_start = Atomic::load(&_cur_addr);\n+    char* cur_start = AtomicAccess::load(&_cur_addr);\n@@ -59,1 +59,1 @@\n-    } else if (cur_start == Atomic::cmpxchg(&_cur_addr, cur_start, cur_end)) {\n+    } else if (cur_start == AtomicAccess::cmpxchg(&_cur_addr, cur_start, cur_end)) {\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -217,1 +217,1 @@\n-  Atomic::add(&_ref_dropped[ref_type_2_index(ref_type)], count, memory_order_relaxed);\n+  AtomicAccess::add(&_ref_dropped[ref_type_2_index(ref_type)], count, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -90,1 +90,1 @@\n-  size_t value = Atomic::load(cfptr);\n+  size_t value = AtomicAccess::load(cfptr);\n@@ -96,1 +96,1 @@\n-    value = Atomic::cmpxchg(cfptr, old, value);\n+    value = AtomicAccess::cmpxchg(cfptr, old, value);\n@@ -103,1 +103,1 @@\n-  size_t value = Atomic::load(cfptr);\n+  size_t value = AtomicAccess::load(cfptr);\n@@ -109,1 +109,1 @@\n-    value = Atomic::cmpxchg(cfptr, old, value);\n+    value = AtomicAccess::cmpxchg(cfptr, old, value);\n@@ -335,1 +335,1 @@\n-  Atomic::store(&_count_and_process_flag, size_t(0));\n+  AtomicAccess::store(&_count_and_process_flag, size_t(0));\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_SOFTREFPOLICY_HPP\n-#define SHARE_GC_SHARED_SOFTREFPOLICY_HPP\n-\n-class SoftRefPolicy {\n- private:\n-  \/\/ Set to true when policy wants soft refs cleared.\n-  \/\/ Reset to false by gc after it clears all soft refs.\n-  bool _should_clear_all_soft_refs;\n-\n- public:\n-  SoftRefPolicy() :\n-    _should_clear_all_soft_refs(false) {}\n-\n-  bool should_clear_all_soft_refs() { return _should_clear_all_soft_refs; }\n-  void set_should_clear_all_soft_refs(bool v) { _should_clear_all_soft_refs = v; }\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_SOFTREFPOLICY_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/softRefPolicy.hpp","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -129,1 +129,1 @@\n-      HeapWord* result = Atomic::cmpxchg(top_addr(), obj, new_top);\n+      HeapWord* result = AtomicAccess::cmpxchg(top_addr(), obj, new_top);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -78,1 +78,1 @@\n-    OopStorage* storage = Atomic::load(&_storage_for_requests)->storage();\n+    OopStorage* storage = AtomicAccess::load(&_storage_for_requests)->storage();\n@@ -86,1 +86,1 @@\n-  _storage_for_processing = Atomic::xchg(&_storage_for_requests, _storage_for_processing);\n+  _storage_for_processing = AtomicAccess::xchg(&_storage_for_requests, _storage_for_processing);\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -37,1 +37,1 @@\n-  return Atomic::load_acquire(&_use_count) > 0;\n+  return AtomicAccess::load_acquire(&_use_count) > 0;\n@@ -43,2 +43,2 @@\n-  StorageUse* storage = Atomic::load(ptr);\n-  Atomic::inc(&storage->_use_count);\n+  StorageUse* storage = AtomicAccess::load(ptr);\n+  AtomicAccess::inc(&storage->_use_count);\n@@ -49,1 +49,1 @@\n-  size_t result = Atomic::sub(&_use_count, size_t(1));\n+  size_t result = AtomicAccess::sub(&_use_count, size_t(1));\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupStorageUse.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -246,1 +246,1 @@\n-  switch (Atomic::load(&_dead_state)) {\n+  switch (AtomicAccess::load(&_dead_state)) {\n@@ -248,1 +248,1 @@\n-    Atomic::store(&_dead_count, num_dead);\n+    AtomicAccess::store(&_dead_count, num_dead);\n@@ -254,2 +254,2 @@\n-    Atomic::store(&_dead_count, num_dead);\n-    Atomic::release_store(&_dead_state, DeadState::good);\n+    AtomicAccess::store(&_dead_count, num_dead);\n+    AtomicAccess::release_store(&_dead_state, DeadState::good);\n@@ -259,1 +259,1 @@\n-    Atomic::release_store(&_dead_state, DeadState::wait1);\n+    AtomicAccess::release_store(&_dead_state, DeadState::wait1);\n@@ -478,1 +478,1 @@\n-  return Atomic::load_acquire(&_dead_state) == DeadState::good;\n+  return AtomicAccess::load_acquire(&_dead_state) == DeadState::good;\n@@ -484,1 +484,1 @@\n-         ((_number_of_entries - Atomic::load(&_dead_count)) > _grow_threshold);\n+         ((_number_of_entries - AtomicAccess::load(&_dead_count)) > _grow_threshold);\n@@ -490,1 +490,1 @@\n-         Config::should_cleanup_table(_number_of_entries, Atomic::load(&_dead_count));\n+         Config::should_cleanup_table(_number_of_entries, AtomicAccess::load(&_dead_count));\n@@ -649,1 +649,1 @@\n-  size_t dead_count = Atomic::load(&_dead_count);\n+  size_t dead_count = AtomicAccess::load(&_dead_count);\n@@ -673,2 +673,2 @@\n-  Atomic::store(&_dead_count, size_t(0));\n-  Atomic::store(&_dead_state, DeadState::cleaning);\n+  AtomicAccess::store(&_dead_count, size_t(0));\n+  AtomicAccess::store(&_dead_state, DeadState::cleaning);\n@@ -708,1 +708,1 @@\n-  Atomic::store(&_dead_state, DeadState::wait2);\n+  AtomicAccess::store(&_dead_state, DeadState::wait2);\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupTable.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-    Atomic::store(&_suspend_all, true);\n+    AtomicAccess::store(&_suspend_all, true);\n@@ -130,1 +130,1 @@\n-  Atomic::store(&_suspend_all, false);\n+  AtomicAccess::store(&_suspend_all, false);\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -62,1 +62,1 @@\n-  static bool should_yield() { return Atomic::load(&_suspend_all); }\n+  static bool should_yield() { return AtomicAccess::load(&_suspend_all); }\n","filename":"src\/hotspot\/share\/gc\/shared\/suspendibleThreadSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -143,1 +143,1 @@\n-    return Atomic::load(&_bottom);\n+    return AtomicAccess::load(&_bottom);\n@@ -147,1 +147,1 @@\n-    return Atomic::load_acquire(&_bottom);\n+    return AtomicAccess::load_acquire(&_bottom);\n@@ -151,1 +151,1 @@\n-    Atomic::store(&_bottom, new_bottom);\n+    AtomicAccess::store(&_bottom, new_bottom);\n@@ -155,1 +155,1 @@\n-    Atomic::release_store(&_bottom, new_bottom);\n+    AtomicAccess::release_store(&_bottom, new_bottom);\n@@ -159,1 +159,1 @@\n-    return Age(Atomic::load(&_age._data));\n+    return Age(AtomicAccess::load(&_age._data));\n@@ -163,1 +163,1 @@\n-    Atomic::store(&_age._data, new_age._data);\n+    AtomicAccess::store(&_age._data, new_age._data);\n@@ -167,1 +167,1 @@\n-    return Age(Atomic::cmpxchg(&_age._data, old_age._data, new_age._data));\n+    return Age(AtomicAccess::cmpxchg(&_age._data, old_age._data, new_age._data));\n@@ -172,1 +172,1 @@\n-    return Atomic::load(&_age._fields._top);\n+    return AtomicAccess::load(&_age._fields._top);\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -463,1 +463,1 @@\n-  return Atomic::load(&_start);\n+  return AtomicAccess::load(&_start);\n@@ -467,1 +467,1 @@\n-  return Atomic::load(&_top);\n+  return AtomicAccess::load(&_top);\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -64,1 +64,1 @@\n-  const uint worker_id = Atomic::fetch_then_add(&_started, 1u);\n+  const uint worker_id = AtomicAccess::fetch_then_add(&_started, 1u);\n@@ -73,1 +73,1 @@\n-  const uint not_finished = Atomic::sub(&_not_finished, 1u);\n+  const uint not_finished = AtomicAccess::sub(&_not_finished, 1u);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -91,1 +91,1 @@\n-  if (Atomic::cmpxchg(&_verification_done, false, true)) {\n+  if (AtomicAccess::cmpxchg(&_verification_done, false, true)) {\n@@ -119,1 +119,1 @@\n-  return !_tasks[t] && !Atomic::cmpxchg(&_tasks[t], false, true);\n+  return !_tasks[t] && !AtomicAccess::cmpxchg(&_tasks[t], false, true);\n@@ -132,1 +132,1 @@\n-    t = Atomic::add(&_num_claimed, 1u) - 1;\n+    t = AtomicAccess::add(&_num_claimed, 1u) - 1;\n","filename":"src\/hotspot\/share\/gc\/shared\/workerUtils.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+  if (ShenandoahGenerationalAdaptiveTenuring) {\n@@ -155,1 +155,1 @@\n-  if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+  if (ShenandoahGenerationalAdaptiveTenuring) {\n@@ -200,1 +200,1 @@\n-  if (!ShenandoahGenerationalAdaptiveTenuring || ShenandoahGenerationalCensusAtEvac) {\n+  if (!ShenandoahGenerationalAdaptiveTenuring) {\n@@ -226,1 +226,1 @@\n-  if (!ShenandoahGenerationalAdaptiveTenuring || ShenandoahGenerationalCensusAtEvac) {\n+  if (!ShenandoahGenerationalAdaptiveTenuring) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  \/\/ Only used in the case of (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac)\n+  \/\/ Only used in the case of ShenandoahGenerationalAdaptiveTenuring\n@@ -207,3 +207,2 @@\n-  \/\/ This method should be called at the end of each marking (or optionally\n-  \/\/ evacuation) cycle to update the tenuring threshold to be used in\n-  \/\/ the next cycle.\n+  \/\/ This method should be called at the end of each marking cycle to update\n+  \/\/ the tenuring threshold to be used in the next cycle.\n@@ -234,1 +233,1 @@\n-  size_t get_total() { return _total; }\n+  size_t get_total() const { return _total; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -153,1 +153,1 @@\n-  size_t old = Atomic::load(&_current_index);\n+  size_t old = AtomicAccess::load(&_current_index);\n@@ -157,1 +157,1 @@\n-      size_t cur = Atomic::cmpxchg(&_current_index, old, index + 1, memory_order_relaxed);\n+      size_t cur = AtomicAccess::cmpxchg(&_current_index, old, index + 1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,0 +117,2 @@\n+  _generation->ref_processor()->set_soft_reference_policy(\n+      GCCause::should_clear_all_soft_refs(cause));\n@@ -735,1 +737,0 @@\n-  rp->set_soft_reference_policy(heap->soft_ref_policy()->should_clear_all_soft_refs());\n@@ -1190,0 +1191,1 @@\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_transfer_satb);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n@@ -121,1 +122,1 @@\n-      heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n+      heap->global_generation()->ref_processor()->set_soft_reference_policy(true);\n@@ -196,1 +197,1 @@\n-      heap->soft_ref_policy()->set_should_clear_all_soft_refs(false);\n+      heap->global_generation()->ref_processor()->set_soft_reference_policy(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  Atomic::inc(&_gc_id);\n+  AtomicAccess::inc(&_gc_id);\n@@ -38,1 +38,1 @@\n-  return Atomic::load(&_gc_id);\n+  return AtomicAccess::load(&_gc_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  Atomic::dec(&_bits);\n+  AtomicAccess::dec(&_bits);\n@@ -45,1 +45,1 @@\n-  Atomic::release_store_fence(&_bits, (jint)0);\n+  AtomicAccess::release_store_fence(&_bits, (jint)0);\n@@ -49,1 +49,1 @@\n-  jint threads_in_evac = Atomic::load_acquire(&_bits);\n+  jint threads_in_evac = AtomicAccess::load_acquire(&_bits);\n@@ -55,1 +55,1 @@\n-    jint other = Atomic::cmpxchg(&_bits, threads_in_evac, newval);\n+    jint other = AtomicAccess::cmpxchg(&_bits, threads_in_evac, newval);\n@@ -68,1 +68,1 @@\n-  jint threads_in_evac = Atomic::load_acquire(&_bits);\n+  jint threads_in_evac = AtomicAccess::load_acquire(&_bits);\n@@ -76,1 +76,1 @@\n-    jint other = Atomic::cmpxchg(&_bits, threads_in_evac, threads_in_evac + 1);\n+    jint other = AtomicAccess::cmpxchg(&_bits, threads_in_evac, threads_in_evac + 1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -35,1 +35,1 @@\n-  return Atomic::load_acquire(&_bits);\n+  return AtomicAccess::load_acquire(&_bits);\n@@ -39,1 +39,1 @@\n-  return Atomic::load_acquire(&_bits) & ~OOM_MARKER_MASK;\n+  return AtomicAccess::load_acquire(&_bits) & ~OOM_MARKER_MASK;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  : _use_age_table(ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring),\n+  : _use_age_table(!ShenandoahGenerationalAdaptiveTenuring),\n@@ -171,1 +171,1 @@\n-  if (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n+  if (!ShenandoahGenerationalAdaptiveTenuring) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  return Atomic::load(&_bytes_allocated_since_gc_start);\n+  return AtomicAccess::load(&_bytes_allocated_since_gc_start);\n@@ -155,1 +155,1 @@\n-  Atomic::store(&_bytes_allocated_since_gc_start, (size_t)0);\n+  AtomicAccess::store(&_bytes_allocated_since_gc_start, (size_t)0);\n@@ -159,1 +159,1 @@\n-  Atomic::add(&_bytes_allocated_since_gc_start, bytes, memory_order_relaxed);\n+  AtomicAccess::add(&_bytes_allocated_since_gc_start, bytes, memory_order_relaxed);\n@@ -681,1 +681,1 @@\n-  if (is_generational && ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+  if (is_generational && ShenandoahGenerationalAdaptiveTenuring) {\n@@ -857,1 +857,1 @@\n-  return Atomic::add(&_affiliated_region_count, (size_t) 1);\n+  return AtomicAccess::add(&_affiliated_region_count, (size_t) 1);\n@@ -865,1 +865,1 @@\n-  auto affiliated_region_count = Atomic::sub(&_affiliated_region_count, (size_t) 1);\n+  auto affiliated_region_count = AtomicAccess::sub(&_affiliated_region_count, (size_t) 1);\n@@ -873,1 +873,1 @@\n-  return Atomic::sub(&_affiliated_region_count, (size_t) 1);\n+  return AtomicAccess::sub(&_affiliated_region_count, (size_t) 1);\n@@ -878,1 +878,1 @@\n-  return Atomic::add(&_affiliated_region_count, delta);\n+  return AtomicAccess::add(&_affiliated_region_count, delta);\n@@ -883,1 +883,1 @@\n-  assert(Atomic::load(&_affiliated_region_count) >= delta, \"Affiliated region count cannot be negative\");\n+  assert(AtomicAccess::load(&_affiliated_region_count) >= delta, \"Affiliated region count cannot be negative\");\n@@ -885,1 +885,1 @@\n-  auto const affiliated_region_count = Atomic::sub(&_affiliated_region_count, delta);\n+  auto const affiliated_region_count = AtomicAccess::sub(&_affiliated_region_count, delta);\n@@ -894,2 +894,2 @@\n-  Atomic::store(&_affiliated_region_count, num_regions);\n-  Atomic::store(&_used, num_bytes);\n+  AtomicAccess::store(&_affiliated_region_count, num_regions);\n+  AtomicAccess::store(&_used, num_bytes);\n@@ -900,1 +900,1 @@\n-  Atomic::add(&_used, bytes);\n+  AtomicAccess::add(&_used, bytes);\n@@ -905,1 +905,1 @@\n-    Atomic::add(&_humongous_waste, bytes);\n+    AtomicAccess::add(&_humongous_waste, bytes);\n@@ -913,1 +913,1 @@\n-    Atomic::sub(&_humongous_waste, bytes);\n+    AtomicAccess::sub(&_humongous_waste, bytes);\n@@ -920,1 +920,1 @@\n-  Atomic::sub(&_used, bytes);\n+  AtomicAccess::sub(&_used, bytes);\n@@ -924,1 +924,1 @@\n-  return Atomic::load(&_affiliated_region_count);\n+  return AtomicAccess::load(&_affiliated_region_count);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  size_t used() const override { return Atomic::load(&_used); }\n+  size_t used() const override { return AtomicAccess::load(&_used); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n@@ -45,1 +46,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -219,2 +220,3 @@\n-  if (request.generation->is_global() && (ShenandoahCollectorPolicy::is_allocation_failure(request.cause) || ShenandoahCollectorPolicy::is_explicit_gc(request.cause) || ShenandoahAlwaysClearSoftRefs)) {\n-    _heap->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n+  if (GCCause::should_clear_all_soft_refs(request.cause) || (request.generation->is_global() &&\n+      (ShenandoahCollectorPolicy::is_allocation_failure(request.cause) || ShenandoahCollectorPolicy::is_explicit_gc(request.cause) || ShenandoahAlwaysClearSoftRefs))) {\n+    request.generation->ref_processor()->set_soft_reference_policy(true);\n@@ -292,1 +294,1 @@\n-  _heap->soft_ref_policy()->set_should_clear_all_soft_refs(false);\n+  request.generation->ref_processor()->set_soft_reference_policy(false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-      if (ShenandoahGenerationalCensusAtEvac || !ShenandoahGenerationalAdaptiveTenuring) {\n+      if (!ShenandoahGenerationalAdaptiveTenuring) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -701,1 +701,1 @@\n-  return Atomic::load(&_committed);\n+  return AtomicAccess::load(&_committed);\n@@ -792,1 +792,1 @@\n-  size_t v = Atomic::load(&_soft_max_size);\n+  size_t v = AtomicAccess::load(&_soft_max_size);\n@@ -803,1 +803,1 @@\n-  Atomic::store(&_soft_max_size, v);\n+  AtomicAccess::store(&_soft_max_size, v);\n@@ -855,1 +855,1 @@\n-  size_t new_soft_max = Atomic::load(&SoftMaxHeapSize);\n+  size_t new_soft_max = AtomicAccess::load(&SoftMaxHeapSize);\n@@ -1981,2 +1981,2 @@\n-    while (Atomic::load(&_index) < max) {\n-      size_t cur = Atomic::fetch_then_add(&_index, stride, memory_order_relaxed);\n+    while (AtomicAccess::load(&_index) < max) {\n+      size_t cur = AtomicAccess::fetch_then_add(&_index, stride, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -63,1 +63,1 @@\n-  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n+  size_t new_index = AtomicAccess::add(&_index, (size_t) 1, memory_order_relaxed);\n@@ -77,1 +77,1 @@\n-  Atomic::store(&_gc_no_progress_count, (size_t) 0);\n+  AtomicAccess::store(&_gc_no_progress_count, (size_t) 0);\n@@ -81,1 +81,1 @@\n-  Atomic::inc(&_gc_no_progress_count);\n+  AtomicAccess::inc(&_gc_no_progress_count);\n@@ -85,1 +85,1 @@\n-  return Atomic::load(&_gc_no_progress_count);\n+  return AtomicAccess::load(&_gc_no_progress_count);\n@@ -200,1 +200,1 @@\n-  Atomic::cmpxchg(addr, compare, update, memory_order_release);\n+  AtomicAccess::cmpxchg(addr, compare, update, memory_order_release);\n@@ -206,1 +206,1 @@\n-  Atomic::cmpxchg(addr, compare, u, memory_order_release);\n+  AtomicAccess::cmpxchg(addr, compare, u, memory_order_release);\n@@ -213,1 +213,1 @@\n-  Atomic::cmpxchg(addr, c, u, memory_order_release);\n+  AtomicAccess::cmpxchg(addr, c, u, memory_order_release);\n@@ -218,1 +218,1 @@\n-  return (oop) Atomic::cmpxchg(addr, compare, update, memory_order_release) == compare;\n+  return (oop) AtomicAccess::cmpxchg(addr, compare, update, memory_order_release) == compare;\n@@ -224,1 +224,1 @@\n-  return (narrowOop) Atomic::cmpxchg(addr, compare, u, memory_order_release) == compare;\n+  return (narrowOop) AtomicAccess::cmpxchg(addr, compare, u, memory_order_release) == compare;\n@@ -231,1 +231,1 @@\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, c, u, memory_order_release)) == compare;\n+  return CompressedOops::decode(AtomicAccess::cmpxchg(addr, c, u, memory_order_release)) == compare;\n@@ -240,1 +240,1 @@\n-  Atomic::cmpxchg(addr, compare, oop(), memory_order_relaxed);\n+  AtomicAccess::cmpxchg(addr, compare, oop(), memory_order_relaxed);\n@@ -246,1 +246,1 @@\n-  Atomic::cmpxchg(addr, cmp, narrowOop(), memory_order_relaxed);\n+  AtomicAccess::cmpxchg(addr, cmp, narrowOop(), memory_order_relaxed);\n@@ -251,1 +251,1 @@\n-  Atomic::cmpxchg(addr, compare, narrowOop(), memory_order_relaxed);\n+  AtomicAccess::cmpxchg(addr, compare, narrowOop(), memory_order_relaxed);\n@@ -426,1 +426,1 @@\n-  Atomic::store(_affiliations + r->index(), (uint8_t) new_affiliation);\n+  AtomicAccess::store(_affiliations + r->index(), (uint8_t) new_affiliation);\n@@ -430,1 +430,1 @@\n-  return (ShenandoahAffiliation) Atomic::load(_affiliations + index);\n+  return (ShenandoahAffiliation) AtomicAccess::load(_affiliations + index);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -837,1 +837,1 @@\n-  Atomic::store(&_state, to);\n+  AtomicAccess::store(&_state, to);\n@@ -841,1 +841,1 @@\n-  Atomic::add(&_critical_pins, (size_t)1);\n+  AtomicAccess::add(&_critical_pins, (size_t)1);\n@@ -846,1 +846,1 @@\n-  Atomic::sub(&_critical_pins, (size_t)1);\n+  AtomicAccess::sub(&_critical_pins, (size_t)1);\n@@ -850,1 +850,1 @@\n-  return Atomic::load(&_critical_pins);\n+  return AtomicAccess::load(&_critical_pins);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-  RegionState state()              const { return Atomic::load(&_state); }\n+  RegionState state()              const { return AtomicAccess::load(&_state); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -141,1 +141,1 @@\n-  size_t new_live_data = Atomic::add(&_live_data, s, memory_order_relaxed);\n+  size_t new_live_data = AtomicAccess::add(&_live_data, s, memory_order_relaxed);\n@@ -145,1 +145,1 @@\n-  Atomic::store(&_live_data, (size_t)0);\n+  AtomicAccess::store(&_live_data, (size_t)0);\n@@ -149,1 +149,1 @@\n-  return Atomic::load(&_live_data);\n+  return AtomicAccess::load(&_live_data);\n@@ -181,1 +181,1 @@\n-  HeapWord* watermark = Atomic::load_acquire(&_update_watermark);\n+  HeapWord* watermark = AtomicAccess::load_acquire(&_update_watermark);\n@@ -188,1 +188,1 @@\n-  Atomic::release_store(&_update_watermark, w);\n+  AtomicAccess::release_store(&_update_watermark, w);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -110,1 +110,1 @@\n-    if (current - last > ShenandoahRegionSamplingRate && Atomic::cmpxchg(&_last_sample_millis, last, current) == last) {\n+    if (current - last > ShenandoahRegionSamplingRate && AtomicAccess::cmpxchg(&_last_sample_millis, last, current) == last) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -49,2 +49,2 @@\n-  while (Atomic::load(&_state) == locked ||\n-         Atomic::cmpxchg(&_state, unlocked, locked) != unlocked) {\n+  while (AtomicAccess::load(&_state) == locked ||\n+         AtomicAccess::cmpxchg(&_state, unlocked, locked) != unlocked) {\n@@ -116,1 +116,1 @@\n-  Thread* const owner = Atomic::load(&_owner);\n+  Thread* const owner = AtomicAccess::load(&_owner);\n@@ -120,1 +120,1 @@\n-    Atomic::store(&_owner, thread);\n+    AtomicAccess::store(&_owner, thread);\n@@ -133,1 +133,1 @@\n-    Atomic::store(&_owner, (Thread*)nullptr);\n+    AtomicAccess::store(&_owner, (Thread*)nullptr);\n@@ -140,1 +140,1 @@\n-  Thread* const owner = Atomic::load(&_owner);\n+  Thread* const owner = AtomicAccess::load(&_owner);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    assert(Atomic::load(&_owner) != Thread::current(), \"reentrant locking attempt, would deadlock\");\n+    assert(AtomicAccess::load(&_owner) != Thread::current(), \"reentrant locking attempt, would deadlock\");\n@@ -54,1 +54,1 @@\n-        (Atomic::cmpxchg(&_state, unlocked, locked) != unlocked)) {\n+        (AtomicAccess::cmpxchg(&_state, unlocked, locked) != unlocked)) {\n@@ -61,3 +61,3 @@\n-    assert(Atomic::load(&_state) == locked, \"must be locked\");\n-    assert(Atomic::load(&_owner) == nullptr, \"must not be owned\");\n-    DEBUG_ONLY(Atomic::store(&_owner, Thread::current());)\n+    assert(AtomicAccess::load(&_state) == locked, \"must be locked\");\n+    assert(AtomicAccess::load(&_owner) == nullptr, \"must not be owned\");\n+    DEBUG_ONLY(AtomicAccess::store(&_owner, Thread::current());)\n@@ -67,2 +67,2 @@\n-    assert(Atomic::load(&_owner) == Thread::current(), \"sanity\");\n-    DEBUG_ONLY(Atomic::store(&_owner, (Thread*)nullptr);)\n+    assert(AtomicAccess::load(&_owner) == Thread::current(), \"sanity\");\n+    DEBUG_ONLY(AtomicAccess::store(&_owner, (Thread*)nullptr);)\n@@ -70,1 +70,1 @@\n-    Atomic::store(&_state, unlocked);\n+    AtomicAccess::store(&_state, unlocked);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    if (ShenandoahGenerationalAdaptiveTenuring && !ShenandoahGenerationalCensusAtEvac) {\n+    if (ShenandoahGenerationalAdaptiveTenuring) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -50,1 +50,1 @@\n-  bm_word_t old_val = Atomic::load(addr);\n+  bm_word_t old_val = AtomicAccess::load(addr);\n@@ -58,1 +58,1 @@\n-    const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order_relaxed);\n+    const bm_word_t cur_val = AtomicAccess::cmpxchg(addr, old_val, new_val, memory_order_relaxed);\n@@ -75,1 +75,1 @@\n-  bm_word_t old_val = Atomic::load(addr);\n+  bm_word_t old_val = AtomicAccess::load(addr);\n@@ -85,1 +85,1 @@\n-    const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order_relaxed);\n+    const bm_word_t cur_val = AtomicAccess::cmpxchg(addr, old_val, new_val, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-    size_t cur = Atomic::fetch_then_add(&_claimed, stride, memory_order_relaxed);\n+    size_t cur = AtomicAccess::fetch_then_add(&_claimed, stride, memory_order_relaxed);\n@@ -461,1 +461,1 @@\n-    size_t cur = Atomic::fetch_then_add(&_claimed, stride, memory_order_relaxed);\n+    size_t cur = AtomicAccess::fetch_then_add(&_claimed, stride, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -205,1 +205,1 @@\n-  Atomic::add(&_sum, val);\n+  AtomicAccess::add(&_sum, val);\n@@ -220,1 +220,1 @@\n-  Atomic::add(&_mags[mag], (size_t)1);\n+  AtomicAccess::add(&_mags[mag], (size_t)1);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    Atomic::add(&_trashed_oops, processor.trashed_oops());\n+    AtomicAccess::add(&_trashed_oops, processor.trashed_oops());\n@@ -152,1 +152,1 @@\n-    Atomic::add(&_trashed_oops, processor.trashed_oops());\n+    AtomicAccess::add(&_trashed_oops, processor.trashed_oops());\n@@ -186,1 +186,1 @@\n-        Atomic::store(&_is_preempted, true);\n+        AtomicAccess::store(&_is_preempted, true);\n@@ -194,1 +194,1 @@\n-    return !Atomic::load(&_is_preempted);\n+    return !AtomicAccess::load(&_is_preempted);\n@@ -243,1 +243,1 @@\n-  Atomic::store(&_promoted_expended, (size_t) 0);\n+  AtomicAccess::store(&_promoted_expended, (size_t) 0);\n@@ -249,1 +249,1 @@\n-  return Atomic::add(&_promoted_expended, increment);\n+  return AtomicAccess::add(&_promoted_expended, increment);\n@@ -253,1 +253,1 @@\n-  return Atomic::sub(&_promoted_expended, decrement);\n+  return AtomicAccess::sub(&_promoted_expended, decrement);\n@@ -257,1 +257,1 @@\n-  return Atomic::load(&_promoted_expended);\n+  return AtomicAccess::load(&_promoted_expended);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  f(final_update_refs_transfer_satb,                \"  Transfer Old From SATB\")        \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -124,1 +124,1 @@\n-  T raw_oop = Atomic::load(reference_referent_addr<T>(reference));\n+  T raw_oop = AtomicAccess::load(reference_referent_addr<T>(reference));\n@@ -224,0 +224,2 @@\n+AlwaysClearPolicy ShenandoahReferenceProcessor::_always_clear_policy;\n+\n@@ -225,1 +227,1 @@\n-  _soft_reference_policy(nullptr),\n+  _soft_reference_policy(&_always_clear_policy),\n@@ -248,1 +250,0 @@\n-  static AlwaysClearPolicy always_clear_policy;\n@@ -253,1 +254,1 @@\n-    _soft_reference_policy = &always_clear_policy;\n+    _soft_reference_policy = &_always_clear_policy;\n@@ -287,1 +288,1 @@\n-  assert(_soft_reference_policy != nullptr, \"Policy not initialized\");\n+  assert(_soft_reference_policy != nullptr, \"Should never be null\");\n@@ -508,1 +509,1 @@\n-    oop prev = Atomic::xchg(&_pending_list, head);\n+    oop prev = AtomicAccess::xchg(&_pending_list, head);\n@@ -523,1 +524,1 @@\n-  uint worker_id = Atomic::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n+  uint worker_id = AtomicAccess::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n@@ -530,1 +531,1 @@\n-    worker_id = Atomic::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n+    worker_id = AtomicAccess::add(&_iterate_discovered_list_id, 1U, memory_order_relaxed) - 1;\n@@ -563,1 +564,1 @@\n-  Atomic::release_store_fence(&_iterate_discovered_list_id, 0U);\n+  AtomicAccess::release_store_fence(&_iterate_discovered_list_id, 0U);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  static AlwaysClearPolicy _always_clear_policy;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  return Atomic::fetch_then_add(&_claimed, _stride, memory_order_relaxed);\n+  return AtomicAccess::fetch_then_add(&_claimed, _stride, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-  rp->set_soft_reference_policy(heap->soft_ref_policy()->should_clear_all_soft_refs());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSTWMark.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-  size_t new_index = Atomic::add(&_index, (size_t) 1, memory_order_relaxed);\n+  size_t new_index = AtomicAccess::add(&_index, (size_t) 1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -52,1 +52,1 @@\n-    Atomic::release_store_fence(&value, (ShenandoahSharedValue)SET);\n+    AtomicAccess::release_store_fence(&value, (ShenandoahSharedValue)SET);\n@@ -56,1 +56,1 @@\n-    Atomic::release_store_fence(&value, (ShenandoahSharedValue)UNSET);\n+    AtomicAccess::release_store_fence(&value, (ShenandoahSharedValue)UNSET);\n@@ -60,1 +60,1 @@\n-    return Atomic::load_acquire(&value) == SET;\n+    return AtomicAccess::load_acquire(&value) == SET;\n@@ -64,1 +64,1 @@\n-    return Atomic::load_acquire(&value) == UNSET;\n+    return AtomicAccess::load_acquire(&value) == UNSET;\n@@ -79,1 +79,1 @@\n-    ShenandoahSharedValue old = Atomic::cmpxchg(&value, (ShenandoahSharedValue)UNSET, (ShenandoahSharedValue)SET);\n+    ShenandoahSharedValue old = AtomicAccess::cmpxchg(&value, (ShenandoahSharedValue)UNSET, (ShenandoahSharedValue)SET);\n@@ -87,1 +87,1 @@\n-    ShenandoahSharedValue old = Atomic::cmpxchg(&value, (ShenandoahSharedValue)SET, (ShenandoahSharedValue)UNSET);\n+    ShenandoahSharedValue old = AtomicAccess::cmpxchg(&value, (ShenandoahSharedValue)SET, (ShenandoahSharedValue)UNSET);\n@@ -123,1 +123,1 @@\n-      ShenandoahSharedValue ov = Atomic::load_acquire(&value);\n+      ShenandoahSharedValue ov = AtomicAccess::load_acquire(&value);\n@@ -131,1 +131,1 @@\n-      if (Atomic::cmpxchg(&value, ov, nv) == ov) {\n+      if (AtomicAccess::cmpxchg(&value, ov, nv) == ov) {\n@@ -142,1 +142,1 @@\n-      ShenandoahSharedValue ov = Atomic::load_acquire(&value);\n+      ShenandoahSharedValue ov = AtomicAccess::load_acquire(&value);\n@@ -149,1 +149,1 @@\n-      if (Atomic::cmpxchg(&value, ov, nv) == ov) {\n+      if (AtomicAccess::cmpxchg(&value, ov, nv) == ov) {\n@@ -157,1 +157,1 @@\n-    Atomic::release_store_fence(&value, (ShenandoahSharedValue)0);\n+    AtomicAccess::release_store_fence(&value, (ShenandoahSharedValue)0);\n@@ -168,1 +168,1 @@\n-    uint uvalue = Atomic::load_acquire(&value);\n+    uint uvalue = AtomicAccess::load_acquire(&value);\n@@ -175,1 +175,1 @@\n-    return (Atomic::load_acquire(&value) & (ShenandoahSharedValue) mask) == 0;\n+    return (AtomicAccess::load_acquire(&value) & (ShenandoahSharedValue) mask) == 0;\n@@ -179,1 +179,1 @@\n-    return (Atomic::load_acquire(&value)) == 0;\n+    return (AtomicAccess::load_acquire(&value)) == 0;\n@@ -227,1 +227,1 @@\n-    Atomic::release_store_fence(&value, (EnumValueType)v);\n+    AtomicAccess::release_store_fence(&value, (EnumValueType)v);\n@@ -231,1 +231,1 @@\n-    return (T)Atomic::load_acquire(&value);\n+    return (T)AtomicAccess::load_acquire(&value);\n@@ -237,1 +237,1 @@\n-    return (T)Atomic::cmpxchg(&value, (EnumValueType)expected, (EnumValueType)new_value);\n+    return (T)AtomicAccess::cmpxchg(&value, (EnumValueType)expected, (EnumValueType)new_value);\n@@ -243,1 +243,1 @@\n-    return (T)Atomic::xchg(&value, (EnumValueType)new_value);\n+    return (T)AtomicAccess::xchg(&value, (EnumValueType)new_value);\n@@ -276,1 +276,1 @@\n-    Atomic::release_store_fence(&value, (ShenandoahSharedValue)tokens);\n+    AtomicAccess::release_store_fence(&value, (ShenandoahSharedValue)tokens);\n@@ -281,1 +281,1 @@\n-      ShenandoahSharedValue ov = Atomic::load_acquire(&value);\n+      ShenandoahSharedValue ov = AtomicAccess::load_acquire(&value);\n@@ -286,1 +286,1 @@\n-      if (Atomic::cmpxchg(&value, ov, nv) == ov) {\n+      if (AtomicAccess::cmpxchg(&value, ov, nv) == ov) {\n@@ -294,1 +294,1 @@\n-    Atomic::release_store_fence(&value, (ShenandoahSharedValue)0);\n+    AtomicAccess::release_store_fence(&value, (ShenandoahSharedValue)0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSharedVariables.hpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -343,1 +343,1 @@\n-  jint index = Atomic::add(&_claimed_index, 1, memory_order_relaxed);\n+  jint index = AtomicAccess::add(&_claimed_index, 1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -196,1 +196,1 @@\n-          Atomic::add(&_ld[obj_reg->index()], (uint) ShenandoahForwarding::size(obj), memory_order_relaxed);\n+          AtomicAccess::add(&_ld[obj_reg->index()], (uint) ShenandoahForwarding::size(obj), memory_order_relaxed);\n@@ -625,1 +625,1 @@\n-    Atomic::add(&_processed, processed, memory_order_relaxed);\n+    AtomicAccess::add(&_processed, processed, memory_order_relaxed);\n@@ -672,1 +672,1 @@\n-    return Atomic::load(&_processed);\n+    return AtomicAccess::load(&_processed);\n@@ -687,1 +687,1 @@\n-      size_t v = Atomic::fetch_then_add(&_claimed, 1u, memory_order_relaxed);\n+      size_t v = AtomicAccess::fetch_then_add(&_claimed, 1u, memory_order_relaxed);\n@@ -715,1 +715,1 @@\n-    Atomic::add(&_processed, processed, memory_order_relaxed);\n+    AtomicAccess::add(&_processed, processed, memory_order_relaxed);\n@@ -748,1 +748,1 @@\n-    Atomic::add(&_processed, processed, memory_order_relaxed);\n+    AtomicAccess::add(&_processed, processed, memory_order_relaxed);\n@@ -1026,1 +1026,1 @@\n-        juint start_live = Atomic::load(&ld[r->humongous_start_region()->index()]);\n+        juint start_live = AtomicAccess::load(&ld[r->humongous_start_region()->index()]);\n@@ -1031,1 +1031,1 @@\n-        verf_live = Atomic::load(&ld[r->index()]);\n+        verf_live = AtomicAccess::load(&ld[r->index()]);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -73,4 +73,0 @@\n-  product(bool, ShenandoahGenerationalCensusAtEvac, false, EXPERIMENTAL,    \\\n-          \"(Generational mode only) Object age census at evacuation, \"      \\\n-          \"rather than during marking.\")                                    \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -30,1 +30,1 @@\n-  Atomic::store(&_should_abort, true);\n+  AtomicAccess::store(&_should_abort, true);\n","filename":"src\/hotspot\/share\/gc\/z\/zAbort.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -32,1 +32,1 @@\n-  return Atomic::load(&_should_abort);\n+  return AtomicAccess::load(&_should_abort);\n","filename":"src\/hotspot\/share\/gc\/z\/zAbort.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -478,1 +478,1 @@\n-    (void)Atomic::load((int*)(uintptr_t)addr);\n+    (void)AtomicAccess::load((int*)(uintptr_t)addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -133,1 +133,1 @@\n-  const size_t claimed_index = Atomic::fetch_then_add(&_next, 1u, memory_order_relaxed);\n+  const size_t claimed_index = AtomicAccess::fetch_then_add(&_next, 1u, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -96,1 +96,1 @@\n-    const zpointer prev_ptr = Atomic::cmpxchg(p, ptr, heal_ptr, memory_order_relaxed);\n+    const zpointer prev_ptr = AtomicAccess::cmpxchg(p, ptr, heal_ptr, memory_order_relaxed);\n@@ -368,1 +368,1 @@\n-  const zpointer ptr = Atomic::load(p);\n+  const zpointer ptr = AtomicAccess::load(p);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    Atomic::store(dst, ZAddress::store_good(elem));\n+    AtomicAccess::store(dst, ZAddress::store_good(elem));\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -342,1 +342,1 @@\n-  Atomic::store(dst, ZAddress::store_good(obj));\n+  AtomicAccess::store(dst, ZAddress::store_good(obj));\n@@ -359,1 +359,1 @@\n-  Atomic::store(dst, ZAddress::store_good(obj));\n+  AtomicAccess::store(dst, ZAddress::store_good(obj));\n@@ -436,1 +436,1 @@\n-    Atomic::store(p, ZAddress::store_good(addr));\n+    AtomicAccess::store(p, ZAddress::store_good(addr));\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -73,1 +73,1 @@\n-    const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val);\n+    const bm_word_t cur_val = AtomicAccess::cmpxchg(addr, old_val, new_val);\n","filename":"src\/hotspot\/share\/gc\/z\/zBitMap.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/softRefPolicy.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -49,1 +49,1 @@\n-  const uintptr_t value = Atomic::load(value_addr);\n+  const uintptr_t value = AtomicAccess::load(value_addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zContinuation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -53,1 +53,1 @@\n-  return Atomic::cmpxchg(&_claimed, false, true) == false;\n+  return AtomicAccess::cmpxchg(&_claimed, false, true) == false;\n@@ -63,1 +63,1 @@\n-  Atomic::store(&_in_place_thread, Thread::current());\n+  AtomicAccess::store(&_in_place_thread, Thread::current());\n@@ -79,1 +79,1 @@\n-  Atomic::store(&_in_place_thread, (Thread*)nullptr);\n+  AtomicAccess::store(&_in_place_thread, (Thread*)nullptr);\n@@ -84,1 +84,1 @@\n-  return Atomic::load(&_in_place_thread) == Thread::current() && offset < _in_place_top_at_start;\n+  return AtomicAccess::load(&_in_place_thread) == Thread::current() && offset < _in_place_top_at_start;\n@@ -89,1 +89,1 @@\n-    const int32_t ref_count = Atomic::load_acquire(&_ref_count);\n+    const int32_t ref_count = AtomicAccess::load_acquire(&_ref_count);\n@@ -104,1 +104,1 @@\n-    if (Atomic::cmpxchg(&_ref_count, ref_count, ref_count + 1) == ref_count) {\n+    if (AtomicAccess::cmpxchg(&_ref_count, ref_count, ref_count + 1) == ref_count) {\n@@ -113,1 +113,1 @@\n-    const int32_t ref_count = Atomic::load(&_ref_count);\n+    const int32_t ref_count = AtomicAccess::load(&_ref_count);\n@@ -117,1 +117,1 @@\n-    if (Atomic::cmpxchg(&_ref_count, ref_count, -ref_count) != ref_count) {\n+    if (AtomicAccess::cmpxchg(&_ref_count, ref_count, -ref_count) != ref_count) {\n@@ -125,1 +125,1 @@\n-      while (Atomic::load_acquire(&_ref_count) != -1) {\n+      while (AtomicAccess::load_acquire(&_ref_count) != -1) {\n@@ -137,1 +137,1 @@\n-    const int32_t ref_count = Atomic::load(&_ref_count);\n+    const int32_t ref_count = AtomicAccess::load(&_ref_count);\n@@ -142,1 +142,1 @@\n-      if (Atomic::cmpxchg(&_ref_count, ref_count, ref_count - 1) != ref_count) {\n+      if (AtomicAccess::cmpxchg(&_ref_count, ref_count, ref_count - 1) != ref_count) {\n@@ -155,1 +155,1 @@\n-      if (Atomic::cmpxchg(&_ref_count, ref_count, ref_count + 1) != ref_count) {\n+      if (AtomicAccess::cmpxchg(&_ref_count, ref_count, ref_count + 1) != ref_count) {\n@@ -174,1 +174,1 @@\n-  if (Atomic::load_acquire(&_ref_count) != 0) {\n+  if (AtomicAccess::load_acquire(&_ref_count) != 0) {\n@@ -176,1 +176,1 @@\n-    while (Atomic::load_acquire(&_ref_count) != 0) {\n+    while (AtomicAccess::load_acquire(&_ref_count) != 0) {\n@@ -185,1 +185,1 @@\n-  assert(Atomic::load(&_ref_count) != 0, \"The page has been released\/detached\");\n+  assert(AtomicAccess::load(&_ref_count) != 0, \"The page has been released\/detached\");\n@@ -190,1 +190,1 @@\n-  Atomic::store(&_done, true);\n+  AtomicAccess::store(&_done, true);\n@@ -194,1 +194,1 @@\n-  return Atomic::load(&_done);\n+  return AtomicAccess::load(&_done);\n@@ -291,1 +291,1 @@\n-  const ZPublishState res = Atomic::cmpxchg(&_relocated_remembered_fields_state, ZPublishState::none, ZPublishState::published);\n+  const ZPublishState res = AtomicAccess::cmpxchg(&_relocated_remembered_fields_state, ZPublishState::none, ZPublishState::published);\n@@ -322,1 +322,1 @@\n-  const ZPublishState res = Atomic::cmpxchg(&_relocated_remembered_fields_state, ZPublishState::none, ZPublishState::reject);\n+  const ZPublishState res = AtomicAccess::cmpxchg(&_relocated_remembered_fields_state, ZPublishState::none, ZPublishState::reject);\n@@ -343,1 +343,1 @@\n-    const ZPublishState res2 = Atomic::cmpxchg(&_relocated_remembered_fields_state, ZPublishState::published, ZPublishState::reject);\n+    const ZPublishState res2 = AtomicAccess::cmpxchg(&_relocated_remembered_fields_state, ZPublishState::published, ZPublishState::reject);\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -199,1 +199,1 @@\n-  assert(Atomic::load(&_ref_count) != 0, \"The page has been released\/detached\");\n+  assert(AtomicAccess::load(&_ref_count) != 0, \"The page has been released\/detached\");\n@@ -210,1 +210,1 @@\n-  return Atomic::load_acquire(entries() + *cursor);\n+  return AtomicAccess::load_acquire(entries() + *cursor);\n@@ -276,1 +276,1 @@\n-    const ZForwardingEntry prev_entry = Atomic::cmpxchg(entries() + *cursor, old_entry, new_entry, memory_order_relaxed);\n+    const ZForwardingEntry prev_entry = AtomicAccess::cmpxchg(entries() + *cursor, old_entry, new_entry, memory_order_relaxed);\n@@ -310,1 +310,1 @@\n-  const ZPublishState res = Atomic::load(&_relocated_remembered_fields_state);\n+  const ZPublishState res = AtomicAccess::load(&_relocated_remembered_fields_state);\n@@ -330,1 +330,1 @@\n-  return Atomic::load(&_relocated_remembered_fields_state) == ZPublishState::reject;\n+  return AtomicAccess::load(&_relocated_remembered_fields_state) == ZPublishState::reject;\n@@ -338,1 +338,1 @@\n-  const ZPublishState res = Atomic::load_acquire(&_relocated_remembered_fields_state);\n+  const ZPublishState res = AtomicAccess::load_acquire(&_relocated_remembered_fields_state);\n@@ -366,1 +366,1 @@\n-    Atomic::store(&_relocated_remembered_fields_state, ZPublishState::reject);\n+    AtomicAccess::store(&_relocated_remembered_fields_state, ZPublishState::reject);\n@@ -373,1 +373,1 @@\n-    Atomic::store(&_relocated_remembered_fields_state, ZPublishState::accept);\n+    AtomicAccess::store(&_relocated_remembered_fields_state, ZPublishState::accept);\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -41,1 +41,1 @@\n-  char* const addr = Atomic::fetch_then_add(&_top, size);\n+  char* const addr = AtomicAccess::fetch_then_add(&_top, size);\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -290,1 +290,1 @@\n-  Atomic::add(&_freed, size, memory_order_relaxed);\n+  AtomicAccess::add(&_freed, size, memory_order_relaxed);\n@@ -298,1 +298,1 @@\n-  Atomic::add(&_promoted, size, memory_order_relaxed);\n+  AtomicAccess::add(&_promoted, size, memory_order_relaxed);\n@@ -306,1 +306,1 @@\n-  Atomic::add(&_compacted, size, memory_order_relaxed);\n+  AtomicAccess::add(&_compacted, size, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -60,1 +60,1 @@\n-  return Atomic::load(_map + index);\n+  return AtomicAccess::load(_map + index);\n@@ -72,1 +72,1 @@\n-  Atomic::store(_map + index, value);\n+  AtomicAccess::store(_map + index, value);\n@@ -82,1 +82,1 @@\n-    Atomic::store(_map + index, value);\n+    AtomicAccess::store(_map + index, value);\n@@ -89,1 +89,1 @@\n-  return Atomic::load_acquire(_map + index);\n+  return AtomicAccess::load_acquire(_map + index);\n@@ -95,1 +95,1 @@\n-  Atomic::release_store(_map + index, value);\n+  AtomicAccess::release_store(_map + index, value);\n","filename":"src\/hotspot\/share\/gc\/z\/zGranuleMap.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    const oop o = Atomic::load(p);\n+    const oop o = AtomicAccess::load(p);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -48,1 +48,1 @@\n-    return Atomic::fetch_then_add(&_claim_stripe, 1, memory_order_relaxed);\n+    return AtomicAccess::fetch_then_add(&_claim_stripe, 1, memory_order_relaxed);\n@@ -69,1 +69,1 @@\n-      for (int index; (index = Atomic::fetch_then_add(claim_addr(i), 1, memory_order_relaxed)) < stripe_max;) {\n+      for (int index; (index = AtomicAccess::fetch_then_add(claim_addr(i), 1, memory_order_relaxed)) < stripe_max;) {\n@@ -78,1 +78,1 @@\n-      for (int index; (index = Atomic::fetch_then_add(claim_addr(i), 1, memory_order_relaxed)) < stripe_max;) {\n+      for (int index; (index = AtomicAccess::fetch_then_add(claim_addr(i), 1, memory_order_relaxed)) < stripe_max;) {\n@@ -175,1 +175,1 @@\n-    return Atomic::fetch_then_add(&_claim_array[index], 1, memory_order_relaxed);\n+    return AtomicAccess::fetch_then_add(&_claim_array[index], 1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/z\/zIndexDistributor.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -59,1 +59,1 @@\n-    const int64_t count = Atomic::load_acquire(&_count);\n+    const int64_t count = AtomicAccess::load_acquire(&_count);\n@@ -64,1 +64,1 @@\n-      while (Atomic::load_acquire(&_count) < 0) {\n+      while (AtomicAccess::load_acquire(&_count) < 0) {\n@@ -73,1 +73,1 @@\n-    if (Atomic::cmpxchg(&_count, count, -(count + 1)) != count) {\n+    if (AtomicAccess::cmpxchg(&_count, count, -(count + 1)) != count) {\n@@ -83,1 +83,1 @@\n-      while (Atomic::load_acquire(&_count) != -1) {\n+      while (AtomicAccess::load_acquire(&_count) != -1) {\n@@ -94,1 +94,1 @@\n-  const int64_t count = Atomic::load_acquire(&_count);\n+  const int64_t count = AtomicAccess::load_acquire(&_count);\n@@ -99,1 +99,1 @@\n-  Atomic::release_store(&_count, (int64_t)0);\n+  AtomicAccess::release_store(&_count, (int64_t)0);\n@@ -105,1 +105,1 @@\n-    const int64_t count = Atomic::load_acquire(&_count);\n+    const int64_t count = AtomicAccess::load_acquire(&_count);\n@@ -115,1 +115,1 @@\n-      while (Atomic::load_acquire(&_count) < 0) {\n+      while (AtomicAccess::load_acquire(&_count) < 0) {\n@@ -124,1 +124,1 @@\n-    if (Atomic::cmpxchg(&_count, count, count + 1) != count) {\n+    if (AtomicAccess::cmpxchg(&_count, count, count + 1) != count) {\n@@ -145,1 +145,1 @@\n-    const int64_t count = Atomic::load_acquire(&_count);\n+    const int64_t count = AtomicAccess::load_acquire(&_count);\n@@ -150,1 +150,1 @@\n-      if (Atomic::cmpxchg(&_count, count, count - 1) != count) {\n+      if (AtomicAccess::cmpxchg(&_count, count, count - 1) != count) {\n@@ -155,1 +155,1 @@\n-      if (Atomic::cmpxchg(&_count, count, count + 1) != count) {\n+      if (AtomicAccess::cmpxchg(&_count, count, count + 1) != count) {\n","filename":"src\/hotspot\/share\/gc\/z\/zJNICritical.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -63,1 +63,1 @@\n-  for (uint32_t seqnum = Atomic::load_acquire(&_seqnum);\n+  for (uint32_t seqnum = AtomicAccess::load_acquire(&_seqnum);\n@@ -65,1 +65,1 @@\n-       seqnum = Atomic::load_acquire(&_seqnum)) {\n+       seqnum = AtomicAccess::load_acquire(&_seqnum)) {\n@@ -69,1 +69,1 @@\n-      if (Atomic::cmpxchg(&_seqnum, seqnum, seqnum_initializing) == seqnum) {\n+      if (AtomicAccess::cmpxchg(&_seqnum, seqnum, seqnum_initializing) == seqnum) {\n@@ -90,1 +90,1 @@\n-        Atomic::release_store(&_seqnum, generation->seqnum());\n+        AtomicAccess::release_store(&_seqnum, generation->seqnum());\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -43,1 +43,1 @@\n-  return Atomic::load_acquire(&_seqnum) == ZGeneration::generation(id)->seqnum();\n+  return AtomicAccess::load_acquire(&_seqnum) == ZGeneration::generation(id)->seqnum();\n@@ -119,2 +119,2 @@\n-  Atomic::add(&_live_objects, objects);\n-  Atomic::add(&_live_bytes, bytes);\n+  AtomicAccess::add(&_live_objects, objects);\n+  AtomicAccess::add(&_live_bytes, bytes);\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -53,1 +53,1 @@\n-  Thread* const owner = Atomic::load(&_owner);\n+  Thread* const owner = AtomicAccess::load(&_owner);\n@@ -57,1 +57,1 @@\n-    Atomic::store(&_owner, thread);\n+    AtomicAccess::store(&_owner, thread);\n@@ -70,1 +70,1 @@\n-    Atomic::store(&_owner, (Thread*)nullptr);\n+    AtomicAccess::store(&_owner, (Thread*)nullptr);\n@@ -77,1 +77,1 @@\n-  Thread* const owner = Atomic::load(&_owner);\n+  Thread* const owner = AtomicAccess::load(&_owner);\n","filename":"src\/hotspot\/share\/gc\/z\/zLock.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-  return Atomic::load(&_num_nodes);\n+  return AtomicAccess::load(&_num_nodes);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -598,1 +598,1 @@\n-  Atomic::inc(&_work_nterminateflush);\n+  AtomicAccess::inc(&_work_nterminateflush);\n@@ -614,1 +614,1 @@\n-  if (Atomic::load(&_work_nproactiveflush) == ZMarkProactiveFlushMax) {\n+  if (AtomicAccess::load(&_work_nproactiveflush) == ZMarkProactiveFlushMax) {\n@@ -619,1 +619,1 @@\n-  Atomic::inc(&_work_nproactiveflush);\n+  AtomicAccess::inc(&_work_nproactiveflush);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -75,1 +75,1 @@\n-  return Atomic::load(&_head) == nullptr;\n+  return AtomicAccess::load(&_head) == nullptr;\n@@ -80,1 +80,1 @@\n-  ZMarkStackListNode* head = Atomic::load(&_head);\n+  ZMarkStackListNode* head = AtomicAccess::load(&_head);\n@@ -90,1 +90,1 @@\n-    ZMarkStackListNode* prev = Atomic::cmpxchg(&_head, head, node, memory_order_release);\n+    ZMarkStackListNode* prev = AtomicAccess::cmpxchg(&_head, head, node, memory_order_release);\n@@ -96,1 +96,1 @@\n-      Atomic::inc(&_length, memory_order_relaxed);\n+      AtomicAccess::inc(&_length, memory_order_relaxed);\n@@ -108,1 +108,1 @@\n-  ZMarkStackListNode* head = Atomic::load(&_head);\n+  ZMarkStackListNode* head = AtomicAccess::load(&_head);\n@@ -118,1 +118,1 @@\n-    Atomic::store(hazard_ptr, head);\n+    AtomicAccess::store(hazard_ptr, head);\n@@ -130,1 +130,1 @@\n-    ZMarkStackListNode* const head_after_publish = Atomic::load_acquire(&_head);\n+    ZMarkStackListNode* const head_after_publish = AtomicAccess::load_acquire(&_head);\n@@ -144,1 +144,1 @@\n-    ZMarkStackListNode* const prev = Atomic::cmpxchg(&_head, head, next, memory_order_relaxed);\n+    ZMarkStackListNode* const prev = AtomicAccess::cmpxchg(&_head, head, next, memory_order_relaxed);\n@@ -152,1 +152,1 @@\n-      Atomic::release_store(hazard_ptr, (ZMarkStackListNode*)nullptr);\n+      AtomicAccess::release_store(hazard_ptr, (ZMarkStackListNode*)nullptr);\n@@ -155,1 +155,1 @@\n-      Atomic::dec(&_length, memory_order_relaxed);\n+      AtomicAccess::dec(&_length, memory_order_relaxed);\n@@ -170,1 +170,1 @@\n-  const ssize_t result = Atomic::load(&_length);\n+  const ssize_t result = AtomicAccess::load(&_length);\n@@ -224,1 +224,1 @@\n-  if (Atomic::cmpxchg(&_nstripes_mask, old_nstripes_mask, new_nstripes_mask) == old_nstripes_mask) {\n+  if (AtomicAccess::cmpxchg(&_nstripes_mask, old_nstripes_mask, new_nstripes_mask) == old_nstripes_mask) {\n@@ -233,1 +233,1 @@\n-  return Atomic::load(&_nstripes_mask) + 1;\n+  return AtomicAccess::load(&_nstripes_mask) + 1;\n@@ -261,1 +261,1 @@\n-  const size_t mask = Atomic::load(&_nstripes_mask);\n+  const size_t mask = AtomicAccess::load(&_nstripes_mask);\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  const size_t index = (addr >> ZMarkStripeShift) & Atomic::load(&_nstripes_mask);\n+  const size_t index = (addr >> ZMarkStripeShift) & AtomicAccess::load(&_nstripes_mask);\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -45,2 +45,2 @@\n-  Atomic::store(&_nworkers, nworkers);\n-  Atomic::store(&_nworking, nworkers);\n+  AtomicAccess::store(&_nworkers, nworkers);\n+  AtomicAccess::store(&_nworking, nworkers);\n@@ -54,1 +54,1 @@\n-  Atomic::store(&_nworking, _nworking - 1);\n+  AtomicAccess::store(&_nworking, _nworking - 1);\n@@ -72,1 +72,1 @@\n-  Atomic::store(&_nworking, _nworking - 1);\n+  AtomicAccess::store(&_nworking, _nworking - 1);\n@@ -87,1 +87,1 @@\n-    Atomic::store(&_nawakening, _nawakening - 1);\n+    AtomicAccess::store(&_nawakening, _nawakening - 1);\n@@ -95,1 +95,1 @@\n-  Atomic::store(&_nworking, _nworking + 1);\n+  AtomicAccess::store(&_nworking, _nworking + 1);\n@@ -101,3 +101,3 @@\n-  uint nworking = Atomic::load(&_nworking);\n-  uint nawakening = Atomic::load(&_nawakening);\n-  if (nworking + nawakening == Atomic::load(&_nworkers)) {\n+  uint nworking = AtomicAccess::load(&_nworking);\n+  uint nawakening = AtomicAccess::load(&_nawakening);\n+  if (nworking + nawakening == AtomicAccess::load(&_nworkers)) {\n@@ -116,1 +116,1 @@\n-    Atomic::store(&_nawakening, _nawakening + 1);\n+    AtomicAccess::store(&_nawakening, _nawakening + 1);\n@@ -122,2 +122,2 @@\n-  uint nworking = Atomic::load(&_nworking);\n-  uint nawakening = Atomic::load(&_nawakening);\n+  uint nworking = AtomicAccess::load(&_nworking);\n+  uint nawakening = AtomicAccess::load(&_nawakening);\n@@ -125,1 +125,1 @@\n-  return nworking + nawakening == Atomic::load(&_nworkers);\n+  return nworking + nawakening == AtomicAccess::load(&_nworkers);\n@@ -131,1 +131,1 @@\n-    Atomic::store(&_resurrected, value);\n+    AtomicAccess::store(&_resurrected, value);\n@@ -141,1 +141,1 @@\n-  return Atomic::load(&_resurrected);\n+  return AtomicAccess::load(&_resurrected);\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkTerminate.inline.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -73,1 +73,1 @@\n-    ZMarkStackListNode* const hazard = Atomic::load(&remote_state->_hazard_ptr);\n+    ZMarkStackListNode* const hazard = AtomicAccess::load(&remote_state->_hazard_ptr);\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkingSMR.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -149,1 +149,1 @@\n-      const oop o = Atomic::load(p); \/\/ C1 PatchingStub may replace it concurrently.\n+      const oop o = AtomicAccess::load(p); \/\/ C1 PatchingStub may replace it concurrently.\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,8 +197,0 @@\n-void ZNMethodTable::wait_until_iteration_done() {\n-  assert(CodeCache_lock->owned_by_self(), \"Lock must be held\");\n-\n-  while (_iteration.in_progress() || _iteration_secondary.in_progress()) {\n-    CodeCache_lock->wait_without_safepoint_check();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTable.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,0 @@\n-  static void wait_until_iteration_done();\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTable.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -60,1 +60,1 @@\n-    const size_t partition_start = MIN2(Atomic::fetch_then_add(&_claimed, partition_size), _size);\n+    const size_t partition_start = MIN2(AtomicAccess::fetch_then_add(&_claimed, partition_size), _size);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTableIteration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  bool in_progress() const;\n+\n@@ -41,2 +43,0 @@\n-  bool in_progress() const;\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTableIteration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -69,1 +69,1 @@\n-  ZPage* page = Atomic::load_acquire(shared_page);\n+  ZPage* page = AtomicAccess::load_acquire(shared_page);\n@@ -84,1 +84,1 @@\n-      ZPage* const prev_page = Atomic::cmpxchg(shared_page, page, new_page);\n+      ZPage* const prev_page = AtomicAccess::cmpxchg(shared_page, page, new_page);\n@@ -116,1 +116,1 @@\n-  ZPage* page = Atomic::load_acquire(shared_medium_page);\n+  ZPage* page = AtomicAccess::load_acquire(shared_medium_page);\n@@ -230,1 +230,1 @@\n-  const ZPage* const page = Atomic::load_acquire(shared_addr);\n+  const ZPage* const page = AtomicAccess::load_acquire(shared_addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-  Atomic::store(&_seqnum, generation()->seqnum());\n-  Atomic::store(&_seqnum_other, ZGeneration::generation(_generation_id == ZGenerationId::young ? ZGenerationId::old : ZGenerationId::young)->seqnum());\n+  AtomicAccess::store(&_seqnum, generation()->seqnum());\n+  AtomicAccess::store(&_seqnum_other, ZGeneration::generation(_generation_id == ZGenerationId::young ? ZGenerationId::old : ZGenerationId::young)->seqnum());\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -471,1 +471,1 @@\n-    const zoffset_end prev_top = Atomic::cmpxchg(&_top, addr, new_top);\n+    const zoffset_end prev_top = AtomicAccess::cmpxchg(&_top, addr, new_top);\n@@ -515,1 +515,1 @@\n-    const zoffset_end prev_top = Atomic::cmpxchg(&_top, old_top, new_top);\n+    const zoffset_end prev_top = AtomicAccess::cmpxchg(&_top, old_top, new_top);\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -653,1 +653,1 @@\n-    Atomic::add(&_capacity, increased);\n+    AtomicAccess::add(&_capacity, increased);\n@@ -663,1 +663,1 @@\n-  Atomic::sub(&_capacity, size);\n+  AtomicAccess::sub(&_capacity, size);\n@@ -668,1 +668,1 @@\n-    Atomic::store(&_current_max_capacity, _capacity);\n+    AtomicAccess::store(&_current_max_capacity, _capacity);\n@@ -938,1 +938,1 @@\n-      const uintptr_t claimed = Atomic::fetch_then_add(&_current, size);\n+      const uintptr_t claimed = AtomicAccess::fetch_then_add(&_current, size);\n@@ -1283,1 +1283,1 @@\n-  const size_t soft_max_heapsize = Atomic::load(&SoftMaxHeapSize);\n+  const size_t soft_max_heapsize = AtomicAccess::load(&SoftMaxHeapSize);\n@@ -1292,1 +1292,1 @@\n-    current_max_capacity += Atomic::load(&partition->_current_max_capacity);\n+    current_max_capacity += AtomicAccess::load(&partition->_current_max_capacity);\n@@ -1303,1 +1303,1 @@\n-    capacity += Atomic::load(&partition->_capacity);\n+    capacity += AtomicAccess::load(&partition->_capacity);\n@@ -1310,1 +1310,1 @@\n-  return Atomic::load(&_used);\n+  return AtomicAccess::load(&_used);\n@@ -1314,1 +1314,1 @@\n-  return Atomic::load(&_used_generations[(int)id]);\n+  return AtomicAccess::load(&_used_generations[(int)id]);\n@@ -1324,2 +1324,2 @@\n-    capacity += (ssize_t)Atomic::load(&partition->_capacity);\n-    claimed += (ssize_t)Atomic::load(&partition->_claimed);\n+    capacity += (ssize_t)AtomicAccess::load(&partition->_capacity);\n+    claimed += (ssize_t)AtomicAccess::load(&partition->_claimed);\n@@ -1379,1 +1379,1 @@\n-  Atomic::add(&_used_generations[(int)id], size, memory_order_relaxed);\n+  AtomicAccess::add(&_used_generations[(int)id], size, memory_order_relaxed);\n@@ -1384,1 +1384,1 @@\n-  Atomic::sub(&_used_generations[(int)id], size, memory_order_relaxed);\n+  AtomicAccess::sub(&_used_generations[(int)id], size, memory_order_relaxed);\n@@ -2232,1 +2232,1 @@\n-  const size_t used = Atomic::add(&_used, size);\n+  const size_t used = AtomicAccess::add(&_used, size);\n@@ -2244,1 +2244,1 @@\n-  const size_t used = Atomic::sub(&_used, size);\n+  const size_t used = AtomicAccess::sub(&_used, size);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -319,1 +319,1 @@\n-    const zaddress old_pending_list = Atomic::xchg(_pending_list.addr(), keep_head);\n+    const zaddress old_pending_list = AtomicAccess::xchg(_pending_list.addr(), keep_head);\n@@ -338,1 +338,1 @@\n-    const zaddress discovered_list = Atomic::xchg(start, zaddress::null);\n+    const zaddress discovered_list = AtomicAccess::xchg(start, zaddress::null);\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -67,1 +67,1 @@\n-  return Atomic::load(&_needs_attention) != 0;\n+  return AtomicAccess::load(&_needs_attention) != 0;\n@@ -71,1 +71,1 @@\n-  const int needs_attention = Atomic::add(&_needs_attention, 1);\n+  const int needs_attention = AtomicAccess::add(&_needs_attention, 1);\n@@ -76,1 +76,1 @@\n-  const int needs_attention = Atomic::sub(&_needs_attention, 1);\n+  const int needs_attention = AtomicAccess::sub(&_needs_attention, 1);\n@@ -86,1 +86,1 @@\n-  Atomic::store(&_is_active, false);\n+  AtomicAccess::store(&_is_active, false);\n@@ -91,1 +91,1 @@\n-  return Atomic::load(&_is_active);\n+  return AtomicAccess::load(&_is_active);\n@@ -466,1 +466,1 @@\n-      Atomic::inc(&_in_place_count);\n+      AtomicAccess::inc(&_in_place_count);\n@@ -542,1 +542,1 @@\n-        Atomic::inc(&_in_place_count);\n+        AtomicAccess::inc(&_in_place_count);\n@@ -744,1 +744,1 @@\n-    const zpointer ptr = Atomic::load(p);\n+    const zpointer ptr = AtomicAccess::load(p);\n@@ -1214,1 +1214,1 @@\n-      Atomic::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n+      AtomicAccess::add(&_numa_local_forwardings, numa_local_forwardings_worker, memory_order_relaxed);\n@@ -1226,1 +1226,1 @@\n-  const zpointer ptr = Atomic::load(p);\n+  const zpointer ptr = AtomicAccess::load(p);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-  BitMap::idx_t prev = Atomic::load(&_claimed);\n+  BitMap::idx_t prev = AtomicAccess::load(&_claimed);\n@@ -415,1 +415,1 @@\n-      Atomic::cmpxchg(&_claimed, prev, page_index, memory_order_relaxed);\n+      AtomicAccess::cmpxchg(&_claimed, prev, page_index, memory_order_relaxed);\n@@ -419,1 +419,1 @@\n-    const BitMap::idx_t res = Atomic::cmpxchg(&_claimed, prev, page_index + 1, memory_order_relaxed);\n+    const BitMap::idx_t res = AtomicAccess::cmpxchg(&_claimed, prev, page_index + 1, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/z\/zRemembered.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -40,1 +40,1 @@\n-  Atomic::store(&_blocked, false);\n+  AtomicAccess::store(&_blocked, false);\n","filename":"src\/hotspot\/share\/gc\/z\/zResurrection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -32,1 +32,1 @@\n-  return Atomic::load(&_blocked);\n+  return AtomicAccess::load(&_blocked);\n","filename":"src\/hotspot\/share\/gc\/z\/zResurrection.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -94,1 +94,1 @@\n-  if (!Atomic::load(&_completed)) {\n+  if (!AtomicAccess::load(&_completed)) {\n@@ -96,2 +96,2 @@\n-    if (!Atomic::load(&_completed)) {\n-      Atomic::store(&_completed, true);\n+    if (!AtomicAccess::load(&_completed)) {\n+      AtomicAccess::store(&_completed, true);\n@@ -123,1 +123,1 @@\n-  return Atomic::fetch_then_add(&_claimed, 1u);\n+  return AtomicAccess::fetch_then_add(&_claimed, 1u);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -448,3 +448,3 @@\n-      const uint64_t nsamples = Atomic::xchg(&cpu_data->_nsamples, (uint64_t)0);\n-      const uint64_t sum = Atomic::xchg(&cpu_data->_sum, (uint64_t)0);\n-      const uint64_t max = Atomic::xchg(&cpu_data->_max, (uint64_t)0);\n+      const uint64_t nsamples = AtomicAccess::xchg(&cpu_data->_nsamples, (uint64_t)0);\n+      const uint64_t sum = AtomicAccess::xchg(&cpu_data->_sum, (uint64_t)0);\n+      const uint64_t max = AtomicAccess::xchg(&cpu_data->_max, (uint64_t)0);\n@@ -483,1 +483,1 @@\n-    counter += Atomic::xchg(&cpu_data->_counter, (uint64_t)0);\n+    counter += AtomicAccess::xchg(&cpu_data->_counter, (uint64_t)0);\n@@ -505,1 +505,1 @@\n-    all._counter += Atomic::xchg(&cpu_data->_counter, (uint64_t)0);\n+    all._counter += AtomicAccess::xchg(&cpu_data->_counter, (uint64_t)0);\n@@ -895,2 +895,2 @@\n-  Atomic::add(&cpu_data->_nsamples, 1u);\n-  Atomic::add(&cpu_data->_sum, value);\n+  AtomicAccess::add(&cpu_data->_nsamples, 1u);\n+  AtomicAccess::add(&cpu_data->_sum, value);\n@@ -906,1 +906,1 @@\n-    const uint64_t prev_max = Atomic::cmpxchg(&cpu_data->_max, max, new_max);\n+    const uint64_t prev_max = AtomicAccess::cmpxchg(&cpu_data->_max, max, new_max);\n@@ -925,1 +925,1 @@\n-  const uint64_t value = Atomic::add(&cpu_data->_counter, increment);\n+  const uint64_t value = AtomicAccess::add(&cpu_data->_counter, increment);\n@@ -932,1 +932,1 @@\n-  Atomic::add(&cpu_data->_counter, increment);\n+  AtomicAccess::add(&cpu_data->_counter, increment);\n@@ -959,1 +959,1 @@\n-  const size_t allocated = Atomic::add(&_allocated_since_sample, allocation_bytes);\n+  const size_t allocated = AtomicAccess::add(&_allocated_since_sample, allocation_bytes);\n@@ -961,1 +961,1 @@\n-  if (allocated < Atomic::load(&_sampling_granule)) {\n+  if (allocated < AtomicAccess::load(&_sampling_granule)) {\n@@ -971,1 +971,1 @@\n-  const size_t allocated_sample = Atomic::load(&_allocated_since_sample);\n+  const size_t allocated_sample = AtomicAccess::load(&_allocated_since_sample);\n@@ -988,1 +988,1 @@\n-  Atomic::sub(&_allocated_since_sample, allocated_sample);\n+  AtomicAccess::sub(&_allocated_since_sample, allocated_sample);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -33,1 +33,1 @@\n-  Atomic::add(&_used, size, memory_order_relaxed);\n+  AtomicAccess::add(&_used, size, memory_order_relaxed);\n@@ -39,1 +39,1 @@\n-  Atomic::sub(&_used, size, memory_order_relaxed);\n+  AtomicAccess::sub(&_used, size, memory_order_relaxed);\n@@ -43,1 +43,1 @@\n-  const size_t used = Atomic::xchg(&_used, (size_t) 0);\n+  const size_t used = AtomicAccess::xchg(&_used, (size_t) 0);\n","filename":"src\/hotspot\/share\/gc\/z\/zTLABUsage.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  const zaddress_unsafe addr = Atomic::load(p);\n+  const zaddress_unsafe addr = AtomicAccess::load(p);\n","filename":"src\/hotspot\/share\/gc\/z\/zUncoloredRoot.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-    Atomic::add(&_partition->_claimed, flushed);\n+    AtomicAccess::add(&_partition->_claimed, flushed);\n@@ -419,1 +419,1 @@\n-    Atomic::sub(&_partition->_claimed, flushed);\n+    AtomicAccess::sub(&_partition->_claimed, flushed);\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    zaddress_unsafe addr = Atomic::load(ZUncoloredRoot::cast(p));\n+    zaddress_unsafe addr = AtomicAccess::load(ZUncoloredRoot::cast(p));\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-    _visited_ptr_pre_loaded = Atomic::load(_visited_p);\n+    _visited_ptr_pre_loaded = AtomicAccess::load(_visited_p);\n@@ -655,1 +655,1 @@\n-    const zpointer ptr = Atomic::load(p);\n+    const zpointer ptr = AtomicAccess::load(p);\n@@ -698,1 +698,1 @@\n-    if (Atomic::load(p) != ptr) {\n+    if (AtomicAccess::load(p) != ptr) {\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zWeakRootsProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -32,1 +32,1 @@\n-  return Atomic::load(&_requested_nworkers) != 0;\n+  return AtomicAccess::load(&_requested_nworkers) != 0;\n","filename":"src\/hotspot\/share\/gc\/z\/zWorkers.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -187,1 +187,1 @@\n-    BytecodePrinter printer(Atomic::load_acquire(&_method_currently_being_printed));\n+    BytecodePrinter printer(AtomicAccess::load_acquire(&_method_currently_being_printed));\n@@ -190,1 +190,1 @@\n-    Atomic::release_store(&_method_currently_being_printed, method());\n+    AtomicAccess::release_store(&_method_currently_being_printed, method());\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -428,1 +428,1 @@\n-  Atomic::inc(&Exceptions::_stack_overflow_errors);\n+  AtomicAccess::inc(&Exceptions::_stack_overflow_errors);\n@@ -442,1 +442,1 @@\n-  Atomic::inc(&Exceptions::_stack_overflow_errors);\n+  AtomicAccess::inc(&Exceptions::_stack_overflow_errors);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -451,1 +451,1 @@\n-  return Atomic::load_acquire(&(_array[i % size]));\n+  return AtomicAccess::load_acquire(&(_array[i % size]));\n@@ -455,1 +455,1 @@\n-  return Atomic::cmpxchg(&_array[i % size], old, entry) == old;\n+  return AtomicAccess::cmpxchg(&_array[i % size], old, entry) == old;\n@@ -565,1 +565,1 @@\n-    OopMapCacheEntry* head = Atomic::load(&_old_entries);\n+    OopMapCacheEntry* head = AtomicAccess::load(&_old_entries);\n@@ -567,1 +567,1 @@\n-    if (Atomic::cmpxchg(&_old_entries, head, entry) == head) {\n+    if (AtomicAccess::cmpxchg(&_old_entries, head, entry) == head) {\n@@ -581,1 +581,1 @@\n-  return Atomic::load(&_old_entries) != nullptr;\n+  return AtomicAccess::load(&_old_entries) != nullptr;\n@@ -595,1 +595,1 @@\n-  OopMapCacheEntry* entry = Atomic::xchg(&_old_entries, (OopMapCacheEntry*)nullptr);\n+  OopMapCacheEntry* entry = AtomicAccess::xchg(&_old_entries, (OopMapCacheEntry*)nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    ik = InstanceKlass::cast(java_lang_Class::as_Klass(ref_owner));\n+    ik = java_lang_Class::as_InstanceKlass(ref_owner);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -91,2 +91,2 @@\n-    Atomic::store(&_dead_samples, true);\n-    Atomic::store(&_last_sweep, (int64_t)JfrTicks::now().value());\n+    AtomicAccess::store(&_dead_samples, true);\n+    AtomicAccess::store(&_last_sweep, (int64_t)JfrTicks::now().value());\n@@ -116,2 +116,2 @@\n-  Atomic::store(&_dead_samples, false);\n-  Atomic::store(&_last_sweep, (int64_t)JfrTicks::now().value());\n+  AtomicAccess::store(&_dead_samples, false);\n+  AtomicAccess::store(&_last_sweep, (int64_t)JfrTicks::now().value());\n@@ -159,1 +159,1 @@\n-  while (Atomic::cmpxchg(&_lock, 0, 1) == 1) {}\n+  while (AtomicAccess::cmpxchg(&_lock, 0, 1) == 1) {}\n@@ -243,1 +243,1 @@\n-  if (Atomic::load(&_dead_samples)) {\n+  if (AtomicAccess::load(&_dead_samples)) {\n@@ -246,1 +246,1 @@\n-    Atomic::store(&_dead_samples, false);\n+    AtomicAccess::store(&_dead_samples, false);\n@@ -363,1 +363,1 @@\n-  return Atomic::load(&_last_sweep);\n+  return AtomicAccess::load(&_last_sweep);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/sampling\/objectSampler.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -87,1 +87,1 @@\n-    elementIndex = Atomic::load_acquire(&_head);\n+    elementIndex = AtomicAccess::load_acquire(&_head);\n@@ -91,1 +91,1 @@\n-  } while (Atomic::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n+  } while (AtomicAccess::cmpxchg(&_head, elementIndex, elementIndex + 1) != elementIndex);\n@@ -104,1 +104,1 @@\n-  return Atomic::load_acquire(&_head);\n+  return AtomicAccess::load_acquire(&_head);\n@@ -108,1 +108,1 @@\n-  Atomic::release_store(&_head, size);\n+  AtomicAccess::release_store(&_head, size);\n@@ -112,1 +112,1 @@\n-  return Atomic::load_acquire(&_capacity);\n+  return AtomicAccess::load_acquire(&_capacity);\n@@ -116,1 +116,1 @@\n-  if (capacity == Atomic::load(&_capacity)) {\n+  if (capacity == AtomicAccess::load(&_capacity)) {\n@@ -129,1 +129,1 @@\n-  Atomic::release_store(&_capacity, capacity);\n+  AtomicAccess::release_store(&_capacity, capacity);\n@@ -133,1 +133,1 @@\n-  return Atomic::load_acquire(&_head) == 0;\n+  return AtomicAccess::load_acquire(&_head) == 0;\n@@ -137,1 +137,1 @@\n-  return Atomic::load(&_lost_samples);\n+  return AtomicAccess::load(&_lost_samples);\n@@ -141,2 +141,2 @@\n-  Atomic::inc(&_lost_samples_sum);\n-  Atomic::inc(&_lost_samples);\n+  AtomicAccess::inc(&_lost_samples_sum);\n+  AtomicAccess::inc(&_lost_samples);\n@@ -146,1 +146,1 @@\n-  Atomic::inc(&_lost_samples_due_to_queue_full);\n+  AtomicAccess::inc(&_lost_samples_due_to_queue_full);\n@@ -150,1 +150,1 @@\n-  return Atomic::xchg(&_lost_samples, (u4)0);\n+  return AtomicAccess::xchg(&_lost_samples, (u4)0);\n@@ -154,1 +154,1 @@\n-  return Atomic::xchg(&_lost_samples_due_to_queue_full, (u4)0);\n+  return AtomicAccess::xchg(&_lost_samples_due_to_queue_full, (u4)0);\n@@ -162,1 +162,1 @@\n-  Atomic::release_store(&_head, (u4)0);\n+  AtomicAccess::release_store(&_head, (u4)0);\n@@ -170,1 +170,1 @@\n-  u4 capacity = Atomic::load(&_capacity);\n+  u4 capacity = AtomicAccess::load(&_capacity);\n@@ -249,1 +249,1 @@\n-  int64_t get_sampling_period() const { return Atomic::load(&_current_sampling_period_ns); };\n+  int64_t get_sampling_period() const { return AtomicAccess::load(&_current_sampling_period_ns); };\n@@ -283,1 +283,1 @@\n-    Atomic::release_store(&_out_of_stack_walking_enabled, runnable);\n+    AtomicAccess::release_store(&_out_of_stack_walking_enabled, runnable);\n@@ -287,1 +287,1 @@\n-    return Atomic::load(&_out_of_stack_walking_iterations);\n+    return AtomicAccess::load(&_out_of_stack_walking_iterations);\n@@ -305,1 +305,1 @@\n-  Atomic::release_store(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true);\n+  AtomicAccess::release_store(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true);\n@@ -310,1 +310,1 @@\n-      !Atomic::load_acquire(&_signal_handler_installed)) {\n+      !AtomicAccess::load_acquire(&_signal_handler_installed)) {\n@@ -320,1 +320,1 @@\n-    if (!Atomic::or_then_fetch(&_warned_about_timer_creation_failure, true)) {\n+    if (!AtomicAccess::or_then_fetch(&_warned_about_timer_creation_failure, true)) {\n@@ -353,2 +353,2 @@\n-  if (Atomic::cmpxchg(&_disenrolled, true, false)) {\n-    Atomic::store(&_warned_about_timer_creation_failure, false);\n+  if (AtomicAccess::cmpxchg(&_disenrolled, true, false)) {\n+    AtomicAccess::store(&_warned_about_timer_creation_failure, false);\n@@ -368,1 +368,1 @@\n-  if (!Atomic::cmpxchg(&_disenrolled, false, true)) {\n+  if (!AtomicAccess::cmpxchg(&_disenrolled, false, true)) {\n@@ -370,1 +370,1 @@\n-    if (Atomic::load_acquire(&_signal_handler_installed)) {\n+    if (AtomicAccess::load_acquire(&_signal_handler_installed)) {\n@@ -394,3 +394,3 @@\n-    DEBUG_ONLY(if (Atomic::load_acquire(&_out_of_stack_walking_enabled)) {)\n-      if (Atomic::cmpxchg(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true, false)) {\n-        DEBUG_ONLY(Atomic::inc(&_out_of_stack_walking_iterations);)\n+    DEBUG_ONLY(if (AtomicAccess::load_acquire(&_out_of_stack_walking_enabled)) {)\n+      if (AtomicAccess::cmpxchg(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true, false)) {\n+        DEBUG_ONLY(AtomicAccess::inc(&_out_of_stack_walking_iterations);)\n@@ -453,1 +453,1 @@\n-  Atomic::inc(&count);\n+  AtomicAccess::inc(&count);\n@@ -455,1 +455,1 @@\n-    Atomic::inc(&biased_count);\n+    AtomicAccess::inc(&biased_count);\n@@ -457,2 +457,2 @@\n-  if (Atomic::load(&count) % 1000 == 0) {\n-    log_debug(jfr)(\"CPU thread sampler sent %zu events, lost %d, biased %zu\\n\", Atomic::load(&count), Atomic::load(&_lost_samples_sum), Atomic::load(&biased_count));\n+  if (AtomicAccess::load(&count) % 1000 == 0) {\n+    log_debug(jfr)(\"CPU thread sampler sent %zu events, lost %d, biased %zu\\n\", AtomicAccess::load(&count), AtomicAccess::load(&_lost_samples_sum), AtomicAccess::load(&biased_count));\n@@ -706,2 +706,2 @@\n-  Atomic::or_then_fetch(&_active_signal_handlers, STOP_SIGNAL_BIT, memory_order_acq_rel);\n-  while (Atomic::load_acquire(&_active_signal_handlers) > STOP_SIGNAL_BIT) {\n+  AtomicAccess::or_then_fetch(&_active_signal_handlers, STOP_SIGNAL_BIT, memory_order_acq_rel);\n+  while (AtomicAccess::load_acquire(&_active_signal_handlers) > STOP_SIGNAL_BIT) {\n@@ -716,1 +716,1 @@\n-  u4 old_value = Atomic::fetch_then_add(&_active_signal_handlers, (u4)1, memory_order_acq_rel);\n+  u4 old_value = AtomicAccess::fetch_then_add(&_active_signal_handlers, (u4)1, memory_order_acq_rel);\n@@ -719,1 +719,1 @@\n-    Atomic::dec(&_active_signal_handlers, memory_order_acq_rel);\n+    AtomicAccess::dec(&_active_signal_handlers, memory_order_acq_rel);\n@@ -726,1 +726,1 @@\n-  Atomic::dec(&_active_signal_handlers, memory_order_acq_rel);\n+  AtomicAccess::dec(&_active_signal_handlers, memory_order_acq_rel);\n@@ -730,1 +730,1 @@\n-  Atomic::release_store(&_active_signal_handlers, (u4)0);\n+  AtomicAccess::release_store(&_active_signal_handlers, (u4)0);\n@@ -757,1 +757,1 @@\n-  Atomic::release_store(&_signal_handler_installed, true);\n+  AtomicAccess::release_store(&_signal_handler_installed, true);\n@@ -795,1 +795,1 @@\n-    Atomic::store(&_current_sampling_period_ns, period);\n+    AtomicAccess::store(&_current_sampling_period_ns, period);\n@@ -802,1 +802,1 @@\n-  if (_throttle.enabled() && Atomic::load_acquire(&_disenrolled) == false) {\n+  if (_throttle.enabled() && AtomicAccess::load_acquire(&_disenrolled) == false) {\n@@ -805,1 +805,1 @@\n-    Atomic::store(&_current_sampling_period_ns, _throttle.compute_sampling_period());\n+    AtomicAccess::store(&_current_sampling_period_ns, _throttle.compute_sampling_period());\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -86,2 +86,2 @@\n-  int64_t java_period() const { return Atomic::load(&_java_period_millis); };\n-  int64_t native_period() const { return Atomic::load(&_native_period_millis); };\n+  int64_t java_period() const { return AtomicAccess::load(&_java_period_millis); };\n+  int64_t native_period() const { return AtomicAccess::load(&_native_period_millis); };\n@@ -379,1 +379,1 @@\n-  Atomic::store(&_java_period_millis, period_millis);\n+  AtomicAccess::store(&_java_period_millis, period_millis);\n@@ -384,1 +384,1 @@\n-  Atomic::store(&_native_period_millis, period_millis);\n+  AtomicAccess::store(&_native_period_millis, period_millis);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -46,1 +46,1 @@\n-  } while (Atomic::cmpxchg(dest, compare_value, exchange_value) != compare_value);\n+  } while (AtomicAccess::cmpxchg(dest, compare_value, exchange_value) != compare_value);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -109,1 +109,1 @@\n-    if (current == new_value || Atomic::cmpxchg(dest, current, new_value) == current) {\n+    if (current == new_value || AtomicAccess::cmpxchg(dest, current, new_value) == current) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdBits.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -57,1 +57,1 @@\n-  Atomic::release_store(&_method_tracer_state, true);\n+  AtomicAccess::release_store(&_method_tracer_state, true);\n@@ -62,1 +62,1 @@\n-  Atomic::release_store(&_method_tracer_state, false);\n+  AtomicAccess::release_store(&_method_tracer_state, false);\n@@ -66,1 +66,1 @@\n-  return Atomic::load_acquire(&_method_tracer_state);\n+  return AtomicAccess::load_acquire(&_method_tracer_state);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -526,1 +526,1 @@\n-  return Atomic::cmpxchg(&jfr_shutdown_lock, 0, 1) == 0;\n+  return AtomicAccess::cmpxchg(&jfr_shutdown_lock, 0, 1) == 0;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -88,1 +88,1 @@\n-    const int current_msgs = Atomic::load(&_messages);\n+    const int current_msgs = AtomicAccess::load(&_messages);\n@@ -91,1 +91,1 @@\n-    const int result = Atomic::cmpxchg(&_messages, current_msgs, exchange_value);\n+    const int result = AtomicAccess::cmpxchg(&_messages, current_msgs, exchange_value);\n@@ -119,1 +119,1 @@\n-  const uintptr_t serial_id = Atomic::load(&_msg_read_serial) + 1;\n+  const uintptr_t serial_id = AtomicAccess::load(&_msg_read_serial) + 1;\n@@ -134,1 +134,1 @@\n-  return serial_id <= Atomic::load(&_msg_handled_serial);\n+  return serial_id <= AtomicAccess::load(&_msg_handled_serial);\n@@ -139,1 +139,1 @@\n-  return Atomic::load(&_messages) == 0;\n+  return AtomicAccess::load(&_messages) == 0;\n@@ -144,1 +144,1 @@\n-  const int messages = Atomic::xchg(&_messages, 0);\n+  const int messages = AtomicAccess::xchg(&_messages, 0);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrPostBox.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -70,1 +70,1 @@\n-    if (Atomic::cmpxchg(&_lock, 0, 1) == 0) {\n+    if (AtomicAccess::cmpxchg(&_lock, 0, 1) == 0) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  return Atomic::load_acquire(&_top);\n+  return AtomicAccess::load_acquire(&_top);\n@@ -76,1 +76,1 @@\n-  Atomic::release_store(&_top, new_top);\n+  AtomicAccess::release_store(&_top, new_top);\n@@ -83,1 +83,1 @@\n-    if (Atomic::cmpxchg(&_top, current_top, TOP_CRITICAL_SECTION) == current_top) {\n+    if (AtomicAccess::cmpxchg(&_top, current_top, TOP_CRITICAL_SECTION) == current_top) {\n@@ -108,1 +108,1 @@\n-  } while (current_id != nullptr || Atomic::cmpxchg(&_identity, current_id, id) != current_id);\n+  } while (current_id != nullptr || AtomicAccess::cmpxchg(&_identity, current_id, id) != current_id);\n@@ -114,1 +114,1 @@\n-  return current_id == nullptr && Atomic::cmpxchg(&_identity, current_id, id) == current_id;\n+  return current_id == nullptr && AtomicAccess::cmpxchg(&_identity, current_id, id) == current_id;\n@@ -126,1 +126,1 @@\n-  Atomic::release_store(&_identity, (const void*)nullptr);\n+  AtomicAccess::release_store(&_identity, (const void*)nullptr);\n@@ -181,1 +181,1 @@\n-  return Atomic::load_acquire(dest);\n+  return AtomicAccess::load_acquire(dest);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -115,1 +115,1 @@\n-    Atomic::release_store(&_pos, new_pos);\n+    AtomicAccess::release_store(&_pos, new_pos);\n@@ -138,1 +138,1 @@\n-    return end() - Atomic::load_acquire(&_pos);\n+    return end() - AtomicAccess::load_acquire(&_pos);\n@@ -144,1 +144,1 @@\n-    return Atomic::load_acquire(&_pos) == start();\n+    return AtomicAccess::load_acquire(&_pos) == start();\n@@ -148,1 +148,1 @@\n-    return Atomic::load_acquire(&_identity);\n+    return AtomicAccess::load_acquire(&_identity);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -270,1 +270,1 @@\n-    Atomic::inc(&_free_list_cache_count);\n+    AtomicAccess::inc(&_free_list_cache_count);\n@@ -283,1 +283,1 @@\n-    Atomic::dec(&_free_list_cache_count);\n+    AtomicAccess::dec(&_free_list_cache_count);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrMemorySpace.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -51,1 +51,1 @@\n-  const size_t result = Atomic::add(&_full_count, (size_t)1);\n+  const size_t result = AtomicAccess::add(&_full_count, (size_t)1);\n@@ -62,1 +62,1 @@\n-  } while (Atomic::cmpxchg(&_full_count, current, exchange) != current);\n+  } while (AtomicAccess::cmpxchg(&_full_count, current, exchange) != current);\n@@ -67,1 +67,1 @@\n-  Atomic::store(&_full_count, (size_t)0);\n+  AtomicAccess::store(&_full_count, (size_t)0);\n@@ -79,1 +79,1 @@\n-  return Atomic::load(&_global_lease_count);\n+  return AtomicAccess::load(&_global_lease_count);\n@@ -83,1 +83,1 @@\n-  return Atomic::add(&_global_lease_count, (size_t)1);\n+  return AtomicAccess::add(&_global_lease_count, (size_t)1);\n@@ -92,1 +92,1 @@\n-  } while (Atomic::cmpxchg(&_global_lease_count, current, exchange) != current);\n+  } while (AtomicAccess::cmpxchg(&_global_lease_count, current, exchange) != current);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorageControl.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -52,1 +52,1 @@\n-  return Atomic::load_acquire(t->pos_address()) - top;\n+  return AtomicAccess::load_acquire(t->pos_address()) - top;\n@@ -155,1 +155,1 @@\n-  const size_t unflushed_size = Atomic::load_acquire(t->pos_address()) - current_top;\n+  const size_t unflushed_size = AtomicAccess::load_acquire(t->pos_address()) - current_top;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorageUtils.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -92,1 +92,1 @@\n-  return Atomic::load_acquire(&_active_window);\n+  return AtomicAccess::load_acquire(&_active_window);\n@@ -100,1 +100,1 @@\n-  const int64_t end_ticks = Atomic::load(&_end_ticks);\n+  const int64_t end_ticks = AtomicAccess::load(&_end_ticks);\n@@ -111,1 +111,1 @@\n-  const size_t ordinal = Atomic::add(&_measured_population_size, static_cast<size_t>(1));\n+  const size_t ordinal = AtomicAccess::add(&_measured_population_size, static_cast<size_t>(1));\n@@ -142,1 +142,1 @@\n-  Atomic::release_store(&_active_window, next);\n+  AtomicAccess::release_store(&_active_window, next);\n@@ -200,1 +200,1 @@\n-    Atomic::store(&_end_ticks, static_cast<int64_t>(0));\n+    AtomicAccess::store(&_end_ticks, static_cast<int64_t>(0));\n@@ -203,1 +203,1 @@\n-  Atomic::store(&_measured_population_size, static_cast<size_t>(0));\n+  AtomicAccess::store(&_measured_population_size, static_cast<size_t>(0));\n@@ -205,1 +205,1 @@\n-  Atomic::store(&_end_ticks, end_ticks);\n+  AtomicAccess::store(&_end_ticks, end_ticks);\n@@ -282,1 +282,1 @@\n-  return Atomic::load(&_measured_population_size);\n+  return AtomicAccess::load(&_measured_population_size);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAdaptiveSampler.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -154,1 +154,1 @@\n-    compare_value = Atomic::load(&num_edges);\n+    compare_value = AtomicAccess::load(&num_edges);\n@@ -158,1 +158,1 @@\n-  } while (compare_value != Atomic::cmpxchg(&num_edges, compare_value, compare_value + 1));\n+  } while (compare_value != AtomicAccess::cmpxchg(&num_edges, compare_value, compare_value + 1));\n@@ -307,1 +307,1 @@\n-  return Atomic::load(&_pending_head);\n+  return AtomicAccess::load(&_pending_head);\n@@ -320,1 +320,1 @@\n-  Atomic::store(&_pending_head, head);\n+  AtomicAccess::store(&_pending_head, head);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -325,1 +325,1 @@\n-  return Atomic::load(&_vthread_excluded);\n+  return AtomicAccess::load(&_vthread_excluded);\n@@ -340,1 +340,1 @@\n-  Atomic::store(&tl->_vthread_epoch, static_cast<u2>(0));\n+  AtomicAccess::store(&tl->_vthread_epoch, static_cast<u2>(0));\n@@ -360,1 +360,1 @@\n-  return Atomic::load_acquire(&_vthread) ? is_vthread_excluded(): _jvm_thread_excluded;\n+  return AtomicAccess::load_acquire(&_vthread) ? is_vthread_excluded(): _jvm_thread_excluded;\n@@ -404,1 +404,1 @@\n-  Atomic::store(&jt->jfr_thread_local()->_vthread_epoch, epoch);\n+  AtomicAccess::store(&jt->jfr_thread_local()->_vthread_epoch, epoch);\n@@ -430,1 +430,1 @@\n-  return Atomic::load(&t->jfr_thread_local()->_vthread_id);\n+  return AtomicAccess::load(&t->jfr_thread_local()->_vthread_id);\n@@ -448,1 +448,1 @@\n-  return Atomic::load(&jt->jfr_thread_local()->_vthread_epoch);\n+  return AtomicAccess::load(&jt->jfr_thread_local()->_vthread_epoch);\n@@ -453,2 +453,2 @@\n-  if (Atomic::load(&_generation) != current_generation) {\n-    Atomic::store(&_generation, current_generation);\n+  if (AtomicAccess::load(&_generation) != current_generation) {\n+    AtomicAccess::store(&_generation, current_generation);\n@@ -507,1 +507,1 @@\n-      Atomic::store(&tl->_vthread_id, tid);\n+      AtomicAccess::store(&tl->_vthread_id, tid);\n@@ -528,1 +528,1 @@\n-  return Atomic::load_acquire(&jt->jfr_thread_local()->_vthread) && jt->last_continuation() != nullptr;\n+  return AtomicAccess::load_acquire(&jt->jfr_thread_local()->_vthread) && jt->last_continuation() != nullptr;\n@@ -561,1 +561,1 @@\n-    Atomic::release_store(&tl->_vthread, false);\n+    AtomicAccess::release_store(&tl->_vthread, false);\n@@ -565,1 +565,1 @@\n-  Atomic::store(&tl->_vthread_id, AccessThreadTraceId::id(thread));\n+  AtomicAccess::store(&tl->_vthread_id, AccessThreadTraceId::id(thread));\n@@ -568,1 +568,1 @@\n-  Atomic::store(&tl->_vthread_excluded, excluded);\n+  AtomicAccess::store(&tl->_vthread_excluded, excluded);\n@@ -570,1 +570,1 @@\n-    Atomic::store(&tl->_vthread_epoch, static_cast<u2>(epoch_raw & epoch_mask));\n+    AtomicAccess::store(&tl->_vthread_epoch, static_cast<u2>(epoch_raw & epoch_mask));\n@@ -572,1 +572,1 @@\n-  Atomic::release_store(&tl->_vthread, true);\n+  AtomicAccess::release_store(&tl->_vthread, true);\n@@ -610,1 +610,1 @@\n-  return Atomic::load_acquire(&_cpu_time_jfr_locked) == ENQUEUE;\n+  return AtomicAccess::load_acquire(&_cpu_time_jfr_locked) == ENQUEUE;\n@@ -614,1 +614,1 @@\n-  return Atomic::load_acquire(&_cpu_time_jfr_locked) == DEQUEUE;\n+  return AtomicAccess::load_acquire(&_cpu_time_jfr_locked) == DEQUEUE;\n@@ -618,1 +618,1 @@\n-  return Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, ENQUEUE) == UNLOCKED;\n+  return AtomicAccess::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, ENQUEUE) == UNLOCKED;\n@@ -624,1 +624,1 @@\n-    CPUTimeLockState got = Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE);\n+    CPUTimeLockState got = AtomicAccess::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE);\n@@ -637,1 +637,1 @@\n-  while (Atomic::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED) {\n+  while (AtomicAccess::cmpxchg(&_cpu_time_jfr_locked, UNLOCKED, DEQUEUE) != UNLOCKED) {\n@@ -643,1 +643,1 @@\n-  Atomic::release_store(&_cpu_time_jfr_locked, UNLOCKED);\n+  AtomicAccess::release_store(&_cpu_time_jfr_locked, UNLOCKED);\n@@ -647,1 +647,1 @@\n-  Atomic::release_store(&_has_cpu_time_jfr_requests, has_requests);\n+  AtomicAccess::release_store(&_has_cpu_time_jfr_requests, has_requests);\n@@ -651,1 +651,1 @@\n-  return Atomic::load_acquire(&_has_cpu_time_jfr_requests);\n+  return AtomicAccess::load_acquire(&_has_cpu_time_jfr_requests);\n@@ -663,1 +663,1 @@\n-  Atomic::release_store(&_do_async_processing_of_cpu_time_jfr_requests, wants);\n+  AtomicAccess::release_store(&_do_async_processing_of_cpu_time_jfr_requests, wants);\n@@ -667,1 +667,1 @@\n-  return Atomic::load_acquire(&_do_async_processing_of_cpu_time_jfr_requests);\n+  return AtomicAccess::load_acquire(&_do_async_processing_of_cpu_time_jfr_requests);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -172,1 +172,1 @@\n-    return Atomic::load_acquire(&_sample_state);\n+    return AtomicAccess::load_acquire(&_sample_state);\n@@ -176,1 +176,1 @@\n-    Atomic::release_store(&_sample_state, state);\n+    AtomicAccess::release_store(&_sample_state, state);\n@@ -212,1 +212,1 @@\n-    return Atomic::load_acquire(&_enqueued_requests);\n+    return AtomicAccess::load_acquire(&_enqueued_requests);\n@@ -219,1 +219,1 @@\n-      Atomic::release_store(&_enqueued_requests, true);\n+      AtomicAccess::release_store(&_enqueued_requests, true);\n@@ -229,1 +229,1 @@\n-    Atomic::release_store(&_enqueued_requests, false);\n+    AtomicAccess::release_store(&_enqueued_requests, false);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  return Atomic::load_acquire(&_current);\n+  return AtomicAccess::load_acquire(&_current);\n@@ -86,1 +86,1 @@\n-  add_previous_filter(Atomic::xchg(&_current, new_filter));\n+  add_previous_filter(AtomicAccess::xchg(&_current, new_filter));\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilterManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -42,1 +42,1 @@\n-  } while (Atomic::cmpxchg(dest, compare_value, exchange_value) != compare_value);\n+  } while (AtomicAccess::cmpxchg(dest, compare_value, exchange_value) != compare_value);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrAllocation.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -70,1 +70,1 @@\n-    Node* next = Atomic::load_acquire(&current->_next);\n+    Node* next = AtomicAccess::load_acquire(&current->_next);\n@@ -161,1 +161,1 @@\n-  if (Atomic::load_acquire(&last->_next) == predecessor) {\n+  if (AtomicAccess::load_acquire(&last->_next) == predecessor) {\n@@ -228,1 +228,1 @@\n-  if (last != nullptr && Atomic::load_acquire(&last->_next) == successor) {\n+  if (last != nullptr && AtomicAccess::load_acquire(&last->_next) == successor) {\n@@ -252,1 +252,1 @@\n-  const Node* next = Atomic::load_acquire(&current->_next);\n+  const Node* next = AtomicAccess::load_acquire(&current->_next);\n@@ -277,1 +277,1 @@\n-  NodePtr next = Atomic::load_acquire(&current->_next);\n+  NodePtr next = AtomicAccess::load_acquire(&current->_next);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrConcurrentLinkedListHost.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  return Atomic::load_acquire(&_head._next) == &_tail;\n+  return AtomicAccess::load_acquire(&_head._next) == &_tail;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrConcurrentQueue.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -62,1 +62,1 @@\n-    return (TableEntry*)Atomic::load_acquire(&_entry);\n+    return (TableEntry*)AtomicAccess::load_acquire(&_entry);\n@@ -64,1 +64,1 @@\n-  void set_entry(TableEntry* entry) { Atomic::release_store(&_entry, entry);}\n+  void set_entry(TableEntry* entry) { AtomicAccess::release_store(&_entry, entry);}\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrHashtable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -42,1 +42,1 @@\n-  return (NodeType*)Atomic::load_acquire(&_head);\n+  return (NodeType*)AtomicAccess::load_acquire(&_head);\n@@ -62,1 +62,1 @@\n-  } while (Atomic::cmpxchg(&_head, next, node) != next);\n+  } while (AtomicAccess::cmpxchg(&_head, next, node) != next);\n@@ -73,1 +73,1 @@\n-  } while (Atomic::cmpxchg(&_head, node, next) != node);\n+  } while (AtomicAccess::cmpxchg(&_head, node, next) != node);\n@@ -94,1 +94,1 @@\n-    prev = Atomic::cmpxchg(&_head, node, next);\n+    prev = AtomicAccess::cmpxchg(&_head, node, next);\n@@ -126,1 +126,1 @@\n-  } while (Atomic::cmpxchg(&_head, node, (NodeType*)nullptr) != node);\n+  } while (AtomicAccess::cmpxchg(&_head, node, (NodeType*)nullptr) != node);\n@@ -139,1 +139,1 @@\n-  Atomic::store(&_head, first);\n+  AtomicAccess::store(&_head, first);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLinkedList.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -38,1 +38,1 @@\n-  return Atomic::cmpxchg(address, current, exchange) == current;\n+  return AtomicAccess::cmpxchg(address, current, exchange) == current;\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrNode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -115,1 +115,1 @@\n-    Atomic::inc(&_refs, memory_order_relaxed);\n+    AtomicAccess::inc(&_refs, memory_order_relaxed);\n@@ -119,1 +119,1 @@\n-    if (0 == Atomic::sub(&_refs, 1, memory_order_release)) {\n+    if (0 == AtomicAccess::sub(&_refs, 1, memory_order_release)) {\n@@ -127,1 +127,1 @@\n-    return Atomic::load(&_refs);\n+    return AtomicAccess::load(&_refs);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrRefCountPointer.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -37,1 +37,1 @@\n-    Atomic::release_store(&_signaled, true);\n+    AtomicAccess::release_store(&_signaled, true);\n@@ -41,1 +41,1 @@\n-    Atomic::release_store(&_signaled, false);\n+    AtomicAccess::release_store(&_signaled, false);\n@@ -45,1 +45,1 @@\n-    return Atomic::load_acquire(&_signaled);\n+    return AtomicAccess::load_acquire(&_signaled);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSignal.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -39,1 +39,1 @@\n-  JfrTryLock(volatile int* lock) : _lock(lock), _acquired(Atomic::cmpxchg(lock, 0, 1) == 0) {}\n+  JfrTryLock(volatile int* lock) : _lock(lock), _acquired(AtomicAccess::cmpxchg(lock, 0, 1) == 0) {}\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrTryLock.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -53,1 +53,1 @@\n-  return Atomic::load(&_tip._value);\n+  return AtomicAccess::load(&_tip._value);\n@@ -62,1 +62,1 @@\n-  } while (Atomic::cmpxchg(&_tip._value, cmp, xchg) != cmp);\n+  } while (AtomicAccess::cmpxchg(&_tip._value, cmp, xchg) != cmp);\n@@ -70,1 +70,1 @@\n-    if (node->_live || Atomic::cmpxchg(&node->_live, false, true)) {\n+    if (node->_live || AtomicAccess::cmpxchg(&node->_live, false, true)) {\n@@ -83,1 +83,1 @@\n-  } while (Atomic::cmpxchg(&_head, next, node) != next);\n+  } while (AtomicAccess::cmpxchg(&_head, next, node) != next);\n@@ -99,1 +99,1 @@\n-  Atomic::release_store_fence(&_version, version);\n+  AtomicAccess::release_store_fence(&_version, version);\n@@ -133,1 +133,1 @@\n-    const Type checkedout = Atomic::load_acquire(&node->_version);\n+    const Type checkedout = AtomicAccess::load_acquire(&node->_version);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrVersionSystem.inline.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -364,1 +364,1 @@\n-  if (_first_error_tid == invalid_id && Atomic::cmpxchg(&_first_error_tid, invalid_id, current_thread_id) == invalid_id) {\n+  if (_first_error_tid == invalid_id && AtomicAccess::cmpxchg(&_first_error_tid, invalid_id, current_thread_id) == invalid_id) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,3 +221,3 @@\n-  Atomic::inc(&_count);\n-  Atomic::add(&_codeBlobs_size, cb->size());\n-  Atomic::add(&_codeBlobs_code_size, cb->code_size());\n+  AtomicAccess::inc(&_count);\n+  AtomicAccess::add(&_codeBlobs_size, cb->size());\n+  AtomicAccess::add(&_codeBlobs_code_size, cb->code_size());\n@@ -227,2 +227,2 @@\n-  Atomic::inc(&_methods_compiled);\n-  Atomic::inc(&_global_compilation_ticks);\n+  AtomicAccess::inc(&_methods_compiled);\n+  AtomicAccess::inc(&_global_compilation_ticks);\n@@ -234,1 +234,1 @@\n-    Atomic::inc(&_err_upcalls);\n+    AtomicAccess::inc(&_err_upcalls);\n@@ -263,1 +263,1 @@\n-    Atomic::inc(&_ok_upcalls);\n+    AtomicAccess::inc(&_ok_upcalls);\n@@ -268,1 +268,1 @@\n-  Atomic::inc(&_global_compilation_ticks);\n+  AtomicAccess::inc(&_global_compilation_ticks);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -190,1 +190,1 @@\n-  InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(type_mirror));\n+  InstanceKlass* klass = java_lang_Class::as_InstanceKlass(type_mirror);\n@@ -1625,1 +1625,1 @@\n-  if (!report_error && Atomic::cmpxchg(&report_error, 0, 1) == 0) {\n+  if (!report_error && AtomicAccess::cmpxchg(&report_error, 0, 1) == 0) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -157,1 +157,1 @@\n-          jlong old_value = Atomic::cmpxchg((jlong*)handle, (jlong) value, (jlong) (ptr_tag));\n+          jlong old_value = AtomicAccess::cmpxchg((jlong*)handle, (jlong) value, (jlong) (ptr_tag));\n","filename":"src\/hotspot\/share\/jvmci\/metadataHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -327,1 +327,1 @@\n-    Atomic::release_store_fence(&AsyncLogWriter::_instance, self);\n+    AtomicAccess::release_store_fence(&AsyncLogWriter::_instance, self);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -36,1 +36,1 @@\n-  const char* host_name = Atomic::load_acquire(&_host_name);\n+  const char* host_name = AtomicAccess::load_acquire(&_host_name);\n@@ -41,1 +41,1 @@\n-      const char* old_value = Atomic::cmpxchg(&_host_name, (const char*)nullptr, host_name);\n+      const char* old_value = AtomicAccess::cmpxchg(&_host_name, (const char*)nullptr, host_name);\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -32,1 +32,1 @@\n-  jint result = Atomic::add(&_active_readers, 1);\n+  jint result = AtomicAccess::add(&_active_readers, 1);\n@@ -38,1 +38,1 @@\n-  jint result = Atomic::add(&_active_readers, -1);\n+  jint result = AtomicAccess::add(&_active_readers, -1);\n@@ -45,1 +45,1 @@\n-  while (Atomic::load(&_active_readers) != 0) {\n+  while (AtomicAccess::load(&_active_readers) != 0) {\n@@ -136,1 +136,1 @@\n-    LogOutputNode* lnode = Atomic::load(&_level_start[l]);\n+    LogOutputNode* lnode = AtomicAccess::load(&_level_start[l]);\n@@ -138,1 +138,1 @@\n-      Atomic::store(&_level_start[l], node);\n+      AtomicAccess::store(&_level_start[l], node);\n@@ -143,3 +143,3 @@\n-  for (LogOutputNode* cur = Atomic::load(&_level_start[LogLevel::Last]); cur != nullptr; cur = Atomic::load(&cur->_next)) {\n-    if (cur != node && Atomic::load(&cur->_next) == node->_next) {\n-      Atomic::store(&cur->_next, node);\n+  for (LogOutputNode* cur = AtomicAccess::load(&_level_start[LogLevel::Last]); cur != nullptr; cur = AtomicAccess::load(&cur->_next)) {\n+    if (cur != node && AtomicAccess::load(&cur->_next) == node->_next) {\n+      AtomicAccess::store(&cur->_next, node);\n","filename":"src\/hotspot\/share\/logging\/logOutputList.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -130,1 +130,1 @@\n-      _current = Atomic::load_acquire(&_current->_next);\n+      _current = AtomicAccess::load_acquire(&_current->_next);\n@@ -146,1 +146,1 @@\n-    return Iterator(this, Atomic::load_acquire(&_level_start[level]));\n+    return Iterator(this, AtomicAccess::load_acquire(&_level_start[level]));\n","filename":"src\/hotspot\/share\/logging\/logOutputList.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  \/\/ the implied memory order of Atomic::add().\n+  \/\/ the implied memory order of AtomicAccess::add().\n","filename":"src\/hotspot\/share\/logging\/logTagSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -44,2 +44,2 @@\n-  julong value = Atomic::load(dest);\n-  Atomic::store(dest, value + add_value);\n+  julong value = AtomicAccess::load(dest);\n+  AtomicAccess::store(dest, value + add_value);\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -216,1 +216,1 @@\n-  int         report_full()                      { return Atomic::add(&_full_count, 1); }\n+  int         report_full()                      { return AtomicAccess::add(&_full_count, 1); }\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -670,1 +670,1 @@\n-  if (!Atomic::load(&_success)) {\n+  if (!AtomicAccess::load(&_success)) {\n@@ -678,1 +678,1 @@\n-    Atomic::store(&_success, false);\n+    AtomicAccess::store(&_success, false);\n@@ -689,1 +689,1 @@\n-    Atomic::add(&_missed_count, missed_count);\n+    AtomicAccess::add(&_missed_count, missed_count);\n@@ -691,1 +691,1 @@\n-    Atomic::store(&_success, false);\n+    AtomicAccess::store(&_success, false);\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -262,1 +262,0 @@\n-  bool fix_relocations() const { return _fix_relocations; }\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -322,1 +322,1 @@\n-  size_t value = Atomic::load_acquire(&_capacity_until_GC);\n+  size_t value = AtomicAccess::load_acquire(&_capacity_until_GC);\n@@ -356,1 +356,1 @@\n-  size_t prev_value = Atomic::cmpxchg(&_capacity_until_GC, old_capacity_until_GC, new_value);\n+  size_t prev_value = AtomicAccess::cmpxchg(&_capacity_until_GC, old_capacity_until_GC, new_value);\n@@ -374,1 +374,1 @@\n-  return Atomic::sub(&_capacity_until_GC, v);\n+  return AtomicAccess::sub(&_capacity_until_GC, v);\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -96,1 +96,1 @@\n-  T get() const               { return Atomic::load(&_c); }\n+  T get() const               { return AtomicAccess::load(&_c); }\n@@ -99,1 +99,1 @@\n-    Atomic::inc(&_c, memory_order_relaxed);\n+    AtomicAccess::inc(&_c, memory_order_relaxed);\n@@ -103,1 +103,1 @@\n-    Atomic::dec(&_c, memory_order_relaxed);\n+    AtomicAccess::dec(&_c, memory_order_relaxed);\n@@ -107,1 +107,1 @@\n-    Atomic::add(&_c, v, memory_order_relaxed);\n+    AtomicAccess::add(&_c, v, memory_order_relaxed);\n@@ -111,1 +111,1 @@\n-    Atomic::sub(&_c, v, memory_order_relaxed);\n+    AtomicAccess::sub(&_c, v, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/counters.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -111,1 +111,1 @@\n-#define INCREMENTOR_ATOMIC(name)    static void inc_##name() { Atomic::inc(&_##name); }\n+#define INCREMENTOR_ATOMIC(name)    static void inc_##name() { AtomicAccess::inc(&_##name); }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/internalStats.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -101,1 +101,1 @@\n-  Atomic::release_store(&_first_node, vsn);\n+  AtomicAccess::release_store(&_first_node, vsn);\n@@ -192,1 +192,1 @@\n-  const VirtualSpaceNode* vsn = Atomic::load_acquire(&_first_node);\n+  const VirtualSpaceNode* vsn = AtomicAccess::load_acquire(&_first_node);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceList.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  Atomic::store(&_has_critical_allocation, true);\n+  AtomicAccess::store(&_has_critical_allocation, true);\n@@ -182,1 +182,1 @@\n-  if (Atomic::load(&_has_critical_allocation)) {\n+  if (AtomicAccess::load(&_has_critical_allocation)) {\n@@ -208,1 +208,1 @@\n-    Atomic::store(&_has_critical_allocation, false);\n+    AtomicAccess::store(&_has_critical_allocation, false);\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -52,2 +52,2 @@\n-    if (!Atomic::load(&reported)) {\n-      if (!Atomic::cmpxchg(&reported, false, true)) {\n+    if (!AtomicAccess::load(&reported)) {\n+      if (!AtomicAccess::cmpxchg(&reported, false, true)) {\n","filename":"src\/hotspot\/share\/memory\/resourceArea.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -745,1 +745,1 @@\n-    next = (int)Atomic::add(&_preallocated_out_of_memory_error_avail_count, -1);\n+    next = (int)AtomicAccess::add(&_preallocated_out_of_memory_error_avail_count, -1);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -126,1 +126,1 @@\n-    if (Atomic::replace_if_null(&_table[index], entry)) {\n+    if (AtomicAccess::replace_if_null(&_table[index], entry)) {\n@@ -253,1 +253,1 @@\n-  return Atomic::replace_if_null(&_next, entry);\n+  return AtomicAccess::replace_if_null(&_next, entry);\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -53,1 +53,1 @@\n-    size_t old_sz = Atomic::cmpxchg(&_peak_size, peak_sz, size, memory_order_relaxed);\n+    size_t old_sz = AtomicAccess::cmpxchg(&_peak_size, peak_sz, size, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -64,1 +64,1 @@\n-    size_t cnt = Atomic::add(&_count, size_t(1), memory_order_relaxed);\n+    size_t cnt = AtomicAccess::add(&_count, size_t(1), memory_order_relaxed);\n@@ -66,1 +66,1 @@\n-      size_t sum = Atomic::add(&_size, sz, memory_order_relaxed);\n+      size_t sum = AtomicAccess::add(&_size, sz, memory_order_relaxed);\n@@ -74,1 +74,1 @@\n-    Atomic::dec(&_count, memory_order_relaxed);\n+    AtomicAccess::dec(&_count, memory_order_relaxed);\n@@ -76,1 +76,1 @@\n-      Atomic::sub(&_size, sz, memory_order_relaxed);\n+      AtomicAccess::sub(&_size, sz, memory_order_relaxed);\n@@ -83,1 +83,1 @@\n-      size_t sum = Atomic::add(&_size, size_t(sz), memory_order_relaxed);\n+      size_t sum = AtomicAccess::add(&_size, size_t(sz), memory_order_relaxed);\n@@ -88,2 +88,2 @@\n-  inline size_t count() const { return Atomic::load(&_count); }\n-  inline size_t size()  const { return Atomic::load(&_size);  }\n+  inline size_t count() const { return AtomicAccess::load(&_count); }\n+  inline size_t size()  const { return AtomicAccess::load(&_size);  }\n@@ -92,1 +92,1 @@\n-    return Atomic::load(&_peak_count);\n+    return AtomicAccess::load(&_peak_count);\n@@ -96,1 +96,1 @@\n-    return Atomic::load(&_peak_size);\n+    return AtomicAccess::load(&_peak_size);\n","filename":"src\/hotspot\/share\/nmt\/mallocTracker.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -141,1 +141,0 @@\n-  VirtualMemorySummary::snapshot(&_virtual_memory_snapshot);\n@@ -144,0 +143,1 @@\n+    VirtualMemorySummary::snapshot(&_virtual_memory_snapshot);\n@@ -163,1 +163,1 @@\n-  if (!VirtualMemoryTracker::Instance::walk_virtual_memory(&virtual_memory_walker)) {\n+  if (!MemTracker::walk_virtual_memory(&virtual_memory_walker)) {\n","filename":"src\/hotspot\/share\/nmt\/memBaseline.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-    return VirtualMemoryTracker::Instance::walk_virtual_memory(this);\n+    return MemTracker::walk_virtual_memory(this);\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -119,1 +119,1 @@\n-  if (enabled() && Atomic::cmpxchg(&g_final_report_did_run, false, true) == false) {\n+  if (enabled() && AtomicAccess::cmpxchg(&g_final_report_did_run, false, true) == false) {\n","filename":"src\/hotspot\/share\/nmt\/memTracker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,0 +176,7 @@\n+  static inline bool walk_virtual_memory(VirtualMemoryWalker* walker) {\n+    assert_post_init();\n+    if (!enabled()) return false;\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    return VirtualMemoryTracker::Instance::walk_virtual_memory(walker);\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/nmt\/nmtPreInit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -50,0 +51,1 @@\n+  MemTracker::NmtVirtualMemoryLocker locker;\n@@ -51,0 +53,1 @@\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtUsage.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    size_t old_sz = Atomic::cmpxchg(&_peak_size, peak_sz, size, memory_order_relaxed);\n+    size_t old_sz = AtomicAccess::cmpxchg(&_peak_size, peak_sz, size, memory_order_relaxed);\n@@ -211,1 +211,1 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n+  bool ret = true;\n@@ -214,0 +214,1 @@\n+      ret = false;\n@@ -218,1 +219,1 @@\n-  return true;\n+  return ret;\n@@ -353,1 +354,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -85,1 +85,1 @@\n-    return Atomic::load(&_peak_size);\n+    return AtomicAccess::load(&_peak_size);\n@@ -348,1 +348,1 @@\n-   virtual bool do_allocation_site(const ReservedMemoryRegion* rgn) { return false; }\n+  virtual bool do_allocation_site(const ReservedMemoryRegion* rgn) { return false; }\n@@ -412,1 +412,1 @@\n-#endif \/\/ SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n\\ No newline at end of file\n+#endif \/\/ SHARE_NMT_VIRTUALMEMORYTRACKER_HPP\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -144,1 +144,1 @@\n-  return Atomic::load_acquire(reinterpret_cast<const volatile T*>(addr));\n+  return AtomicAccess::load_acquire(reinterpret_cast<const volatile T*>(addr));\n@@ -152,1 +152,1 @@\n-  return Atomic::load_acquire(reinterpret_cast<const volatile T*>(addr));\n+  return AtomicAccess::load_acquire(reinterpret_cast<const volatile T*>(addr));\n@@ -160,1 +160,1 @@\n-  return Atomic::load(reinterpret_cast<const volatile T*>(addr));\n+  return AtomicAccess::load(reinterpret_cast<const volatile T*>(addr));\n@@ -168,1 +168,1 @@\n-  Atomic::release_store_fence(reinterpret_cast<volatile T*>(addr), value);\n+  AtomicAccess::release_store_fence(reinterpret_cast<volatile T*>(addr), value);\n@@ -176,1 +176,1 @@\n-  Atomic::release_store(reinterpret_cast<volatile T*>(addr), value);\n+  AtomicAccess::release_store(reinterpret_cast<volatile T*>(addr), value);\n@@ -184,1 +184,1 @@\n-  Atomic::store(reinterpret_cast<volatile T*>(addr), value);\n+  AtomicAccess::store(reinterpret_cast<volatile T*>(addr), value);\n@@ -192,4 +192,4 @@\n-  return Atomic::cmpxchg(reinterpret_cast<volatile T*>(addr),\n-                         compare_value,\n-                         new_value,\n-                         memory_order_relaxed);\n+  return AtomicAccess::cmpxchg(reinterpret_cast<volatile T*>(addr),\n+                               compare_value,\n+                               new_value,\n+                               memory_order_relaxed);\n@@ -203,4 +203,4 @@\n-  return Atomic::cmpxchg(reinterpret_cast<volatile T*>(addr),\n-                         compare_value,\n-                         new_value,\n-                         memory_order_conservative);\n+  return AtomicAccess::cmpxchg(reinterpret_cast<volatile T*>(addr),\n+                               compare_value,\n+                               new_value,\n+                               memory_order_conservative);\n@@ -214,2 +214,2 @@\n-  return Atomic::xchg(reinterpret_cast<volatile T*>(addr),\n-                      new_value);\n+  return AtomicAccess::xchg(reinterpret_cast<volatile T*>(addr),\n+                            new_value);\n","filename":"src\/hotspot\/share\/oops\/accessBackend.inline.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -136,2 +136,2 @@\n-  T at_acquire(const int i)            { return Atomic::load_acquire(adr_at(i)); }\n-  void release_at_put(int i, T x)      { Atomic::release_store(adr_at(i), x); }\n+  T at_acquire(const int i)            { return AtomicAccess::load_acquire(adr_at(i)); }\n+  void release_at_put(int i, T x)      { AtomicAccess::release_store(adr_at(i), x); }\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -33,1 +33,1 @@\n-  return Atomic::load_acquire(&_higher_dimension);\n+  return AtomicAccess::load_acquire(&_higher_dimension);\n@@ -37,1 +37,1 @@\n-  Atomic::release_store(&_higher_dimension, k);\n+  AtomicAccess::release_store(&_higher_dimension, k);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -282,1 +282,1 @@\n-  Atomic::release_store(adr, k);\n+  AtomicAccess::release_store(adr, k);\n@@ -726,1 +726,1 @@\n-  Atomic::release_store(adr, k);\n+  AtomicAccess::release_store(adr, k);\n@@ -728,3 +728,3 @@\n-  jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(cp_index),\n-                                  (jbyte)JVM_CONSTANT_UnresolvedClass,\n-                                  (jbyte)JVM_CONSTANT_Class);\n+  jbyte old_tag = AtomicAccess::cmpxchg((jbyte*)this_cp->tag_addr_at(cp_index),\n+                                        (jbyte)JVM_CONSTANT_UnresolvedClass,\n+                                        (jbyte)JVM_CONSTANT_Class);\n@@ -735,1 +735,1 @@\n-    Atomic::store(adr, (Klass*)nullptr);\n+    AtomicAccess::store(adr, (Klass*)nullptr);\n@@ -1067,3 +1067,3 @@\n-    jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp->tag_addr_at(cp_index),\n-                                    (jbyte)tag.value(),\n-                                    (jbyte)error_tag);\n+    jbyte old_tag = AtomicAccess::cmpxchg((jbyte*)this_cp->tag_addr_at(cp_index),\n+                                          (jbyte)tag.value(),\n+                                          (jbyte)error_tag);\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -44,1 +44,1 @@\n-  return Atomic::load_acquire(adr);\n+  return AtomicAccess::load_acquire(adr);\n","filename":"src\/hotspot\/share\/oops\/constantPool.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -195,1 +195,1 @@\n-  Atomic::fetch_then_or(&flags, mask);\n+  AtomicAccess::fetch_then_or(&flags, mask);\n@@ -199,1 +199,1 @@\n-  Atomic::fetch_then_and(&flags, (u1)(~mask));\n+  AtomicAccess::fetch_then_and(&flags, (u1)(~mask));\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1651,1 +1651,1 @@\n-    InstanceKlass* ikls = Atomic::load_acquire(ik);\n+    InstanceKlass* ikls = AtomicAccess::load_acquire(ik);\n@@ -1667,1 +1667,1 @@\n-    Atomic::release_store(addr, ik);\n+    AtomicAccess::release_store(addr, ik);\n@@ -1988,1 +1988,1 @@\n-  OopMapCache* oop_map_cache = Atomic::load_acquire(&_oop_map_cache);\n+  OopMapCache* oop_map_cache = AtomicAccess::load_acquire(&_oop_map_cache);\n@@ -1992,1 +1992,1 @@\n-    OopMapCache* other = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n+    OopMapCache* other = AtomicAccess::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n@@ -2627,1 +2627,1 @@\n-  Atomic::release_store(&jmeths[idnum + 1], new_id);\n+  AtomicAccess::release_store(&jmeths[idnum + 1], new_id);\n@@ -2642,1 +2642,1 @@\n-  return Atomic::load_acquire(&_methods_jmethod_ids);\n+  return AtomicAccess::load_acquire(&_methods_jmethod_ids);\n@@ -2646,1 +2646,1 @@\n-  Atomic::release_store(&_methods_jmethod_ids, jmeths);\n+  AtomicAccess::release_store(&_methods_jmethod_ids, jmeths);\n@@ -2685,1 +2685,1 @@\n-  jmethodID id = Atomic::load_acquire(&jmeths[idnum + 1]);\n+  jmethodID id = AtomicAccess::load_acquire(&jmeths[idnum + 1]);\n@@ -2734,1 +2734,1 @@\n-    jmethodID id = Atomic::load_acquire(&jmeths[idnum + 1]);\n+    jmethodID id = AtomicAccess::load_acquire(&jmeths[idnum + 1]);\n@@ -2738,1 +2738,1 @@\n-      Atomic::release_store(&jmeths[idnum + 1], id);\n+      AtomicAccess::release_store(&jmeths[idnum + 1], id);\n@@ -2791,1 +2791,1 @@\n-      InstanceKlass* impl = Atomic::load_acquire(iklass);\n+      InstanceKlass* impl = AtomicAccess::load_acquire(iklass);\n@@ -2794,1 +2794,1 @@\n-        if (Atomic::cmpxchg(iklass, impl, (InstanceKlass*)nullptr) == impl) {\n+        if (AtomicAccess::cmpxchg(iklass, impl, (InstanceKlass*)nullptr) == impl) {\n@@ -4560,1 +4560,1 @@\n-  Atomic::release_store(&_init_state, state);\n+  AtomicAccess::release_store(&_init_state, state);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-  JavaThread* init_thread()  { return Atomic::load(&_init_thread); }\n+  JavaThread* init_thread()  { return AtomicAccess::load(&_init_thread); }\n@@ -616,1 +616,1 @@\n-  ClassState  init_state() const           { return Atomic::load_acquire(&_init_state); }\n+  ClassState  init_state() const           { return AtomicAccess::load_acquire(&_init_state); }\n@@ -1195,1 +1195,1 @@\n-    Atomic::store(&_init_thread, thread);\n+    AtomicAccess::store(&_init_thread, thread);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -82,1 +82,1 @@\n-  return Atomic::load_acquire(&_array_klasses);\n+  return AtomicAccess::load_acquire(&_array_klasses);\n@@ -86,1 +86,1 @@\n-  Atomic::release_store(&_array_klasses, k);\n+  AtomicAccess::release_store(&_array_klasses, k);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -143,2 +143,2 @@\n-  void atomic_set_bits(u1 bits)   { Atomic::fetch_then_or(&_status, bits); }\n-  void atomic_clear_bits(u1 bits) { Atomic::fetch_then_and(&_status, (u1)(~bits)); }\n+  void atomic_set_bits(u1 bits)   { AtomicAccess::fetch_then_or(&_status, bits); }\n+  void atomic_clear_bits(u1 bits) { AtomicAccess::fetch_then_and(&_status, (u1)(~bits)); }\n","filename":"src\/hotspot\/share\/oops\/instanceKlassFlags.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -603,1 +603,1 @@\n-  for (Klass* chain = Atomic::load_acquire(&_subklass);\n+  for (Klass* chain = AtomicAccess::load_acquire(&_subklass);\n@@ -607,1 +607,1 @@\n-       chain = Atomic::load(&chain->_next_sibling))\n+       chain = AtomicAccess::load(&chain->_next_sibling))\n@@ -624,1 +624,1 @@\n-  for (Klass* chain = Atomic::load(&_next_sibling);\n+  for (Klass* chain = AtomicAccess::load(&_next_sibling);\n@@ -626,1 +626,1 @@\n-       chain = Atomic::load(&chain->_next_sibling)) {\n+       chain = AtomicAccess::load(&chain->_next_sibling)) {\n@@ -643,1 +643,1 @@\n-  Atomic::release_store(&_subklass, s);\n+  AtomicAccess::release_store(&_subklass, s);\n@@ -651,1 +651,1 @@\n-  Atomic::store(&_next_sibling, s);\n+  AtomicAccess::store(&_next_sibling, s);\n@@ -670,1 +670,1 @@\n-    Klass* prev_first_subklass = Atomic::load_acquire(&_super->_subklass);\n+    Klass* prev_first_subklass = AtomicAccess::load_acquire(&_super->_subklass);\n@@ -679,1 +679,1 @@\n-    if (Atomic::cmpxchg(&super->_subklass, prev_first_subklass, this) == prev_first_subklass) {\n+    if (AtomicAccess::cmpxchg(&super->_subklass, prev_first_subklass, this) == prev_first_subklass) {\n@@ -689,1 +689,1 @@\n-    Klass* subklass = Atomic::load_acquire(&_subklass);\n+    Klass* subklass = AtomicAccess::load_acquire(&_subklass);\n@@ -694,1 +694,1 @@\n-    Atomic::cmpxchg(&_subklass, subklass, subklass->next_sibling());\n+    AtomicAccess::cmpxchg(&_subklass, subklass, subklass->next_sibling());\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -648,1 +648,1 @@\n-    Atomic::replace_if_null(&method->_method_data, mtd->final_profile());\n+    AtomicAccess::replace_if_null(&method->_method_data, mtd->final_profile());\n@@ -675,1 +675,1 @@\n-  if (!Atomic::replace_if_null(&method->_method_data, method_data)) {\n+  if (!AtomicAccess::replace_if_null(&method->_method_data, method_data)) {\n@@ -726,1 +726,1 @@\n-  return Atomic::replace_if_null(&_method_counters, counters);\n+  return AtomicAccess::replace_if_null(&_method_counters, counters);\n@@ -1416,1 +1416,1 @@\n-  nmethod *code = Atomic::load_acquire(&_code);\n+  nmethod *code = AtomicAccess::load_acquire(&_code);\n@@ -1458,1 +1458,1 @@\n-    Atomic::release_store(&mh->_from_interpreted_entry , mh->get_i2c_entry());\n+    AtomicAccess::release_store(&mh->_from_interpreted_entry , mh->get_i2c_entry());\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -37,1 +37,1 @@\n-  return Atomic::load_acquire(&_from_compiled_entry);\n+  return AtomicAccess::load_acquire(&_from_compiled_entry);\n@@ -41,1 +41,1 @@\n-  return Atomic::load_acquire(&_from_compiled_inline_ro_entry);\n+  return AtomicAccess::load_acquire(&_from_compiled_inline_ro_entry);\n@@ -45,1 +45,1 @@\n-  return Atomic::load_acquire(&_from_compiled_inline_entry);\n+  return AtomicAccess::load_acquire(&_from_compiled_inline_entry);\n@@ -49,1 +49,1 @@\n-  return Atomic::load_acquire(&_from_interpreted_entry);\n+  return AtomicAccess::load_acquire(&_from_interpreted_entry);\n@@ -54,1 +54,1 @@\n-  return Atomic::load_acquire(&_code);\n+  return AtomicAccess::load_acquire(&_code);\n","filename":"src\/hotspot\/share\/oops\/method.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-      return Atomic::cmpxchg(reinterpret_cast<MethodTrainingData**>(&_method_training_data), cur, td) == cur;\n+      return AtomicAccess::cmpxchg(reinterpret_cast<MethodTrainingData**>(&_method_training_data), cur, td) == cur;\n","filename":"src\/hotspot\/share\/oops\/methodCounters.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -960,1 +960,1 @@\n-      FailedSpeculation* old_fs = Atomic::cmpxchg(cursor, (FailedSpeculation*) nullptr, fs);\n+      FailedSpeculation* old_fs = AtomicAccess::cmpxchg(cursor, (FailedSpeculation*) nullptr, fs);\n@@ -1581,1 +1581,1 @@\n-    \/\/ No need for \"Atomic::load_acquire\" ops,\n+    \/\/ No need for \"AtomicAccess::load_acquire\" ops,\n@@ -1708,1 +1708,1 @@\n-    \/\/ No need for \"Atomic::load_acquire\" ops,\n+    \/\/ No need for \"AtomicAccess::load_acquire\" ops,\n@@ -1929,1 +1929,1 @@\n-  Mutex* lock = Atomic::load_acquire(&_extra_data_lock);\n+  Mutex* lock = AtomicAccess::load_acquire(&_extra_data_lock);\n@@ -1933,1 +1933,1 @@\n-    Mutex* old = Atomic::cmpxchg(&_extra_data_lock, (Mutex*)nullptr, lock);\n+    Mutex* old = AtomicAccess::cmpxchg(&_extra_data_lock, (Mutex*)nullptr, lock);\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -187,1 +187,1 @@\n-    return Atomic::load_acquire(&_header._struct._flags);\n+    return AtomicAccess::load_acquire(&_header._struct._flags);\n@@ -220,1 +220,1 @@\n-    } while (compare_value != Atomic::cmpxchg(&_header._struct._flags, compare_value, static_cast<u1>(compare_value | bit)));\n+    } while (compare_value != AtomicAccess::cmpxchg(&_header._struct._flags, compare_value, static_cast<u1>(compare_value | bit)));\n@@ -235,1 +235,1 @@\n-    } while (compare_value != Atomic::cmpxchg(&_header._struct._flags, compare_value, exchange_value));\n+    } while (compare_value != AtomicAccess::cmpxchg(&_header._struct._flags, compare_value, exchange_value));\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -34,1 +34,1 @@\n-  Atomic::release_store(&_cells[index], value);\n+  AtomicAccess::release_store(&_cells[index], value);\n","filename":"src\/hotspot\/share\/oops\/methodData.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -94,2 +94,2 @@\n-  void atomic_set_bits(u4 bits)   { Atomic::fetch_then_or(&_status, bits); }\n-  void atomic_clear_bits(u4 bits) { Atomic::fetch_then_and(&_status, ~bits); }\n+  void atomic_set_bits(u4 bits)   { AtomicAccess::fetch_then_or(&_status, bits); }\n+  void atomic_clear_bits(u4 bits) { AtomicAccess::fetch_then_and(&_status, ~bits); }\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -42,1 +42,1 @@\n-  return Atomic::load_acquire(&_next_refined_array_klass);\n+  return AtomicAccess::load_acquire(&_next_refined_array_klass);\n@@ -46,1 +46,1 @@\n-  Atomic::release_store(&_next_refined_array_klass, k);\n+  AtomicAccess::release_store(&_next_refined_array_klass, k);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-address oopDesc::address_field_acquire(int offset) const              { return Atomic::load_acquire(field_addr<address>(offset)); }\n+address oopDesc::address_field_acquire(int offset) const              { return AtomicAccess::load_acquire(field_addr<address>(offset)); }\n@@ -173,1 +173,1 @@\n-void oopDesc::release_address_field_put(int offset, address value)    { Atomic::release_store(field_addr<address>(offset), value); }\n+void oopDesc::release_address_field_put(int offset, address value)    { AtomicAccess::release_store(field_addr<address>(offset), value); }\n@@ -178,2 +178,2 @@\n-Metadata* oopDesc::metadata_field_acquire(int offset) const           { return Atomic::load_acquire(field_addr<Metadata*>(offset)); }\n-void oopDesc::release_metadata_field_put(int offset, Metadata* value) { Atomic::release_store(field_addr<Metadata*>(offset), value); }\n+Metadata* oopDesc::metadata_field_acquire(int offset) const           { return AtomicAccess::load_acquire(field_addr<Metadata*>(offset)); }\n+void oopDesc::release_metadata_field_put(int offset, Metadata* value) { AtomicAccess::release_store(field_addr<Metadata*>(offset), value); }\n@@ -181,2 +181,2 @@\n-jbyte oopDesc::byte_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jbyte>(offset)); }\n-void oopDesc::release_byte_field_put(int offset, jbyte value)         { Atomic::release_store(field_addr<jbyte>(offset), value); }\n+jbyte oopDesc::byte_field_acquire(int offset) const                   { return AtomicAccess::load_acquire(field_addr<jbyte>(offset)); }\n+void oopDesc::release_byte_field_put(int offset, jbyte value)         { AtomicAccess::release_store(field_addr<jbyte>(offset), value); }\n@@ -184,2 +184,2 @@\n-jchar oopDesc::char_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jchar>(offset)); }\n-void oopDesc::release_char_field_put(int offset, jchar value)         { Atomic::release_store(field_addr<jchar>(offset), value); }\n+jchar oopDesc::char_field_acquire(int offset) const                   { return AtomicAccess::load_acquire(field_addr<jchar>(offset)); }\n+void oopDesc::release_char_field_put(int offset, jchar value)         { AtomicAccess::release_store(field_addr<jchar>(offset), value); }\n@@ -187,2 +187,2 @@\n-jboolean oopDesc::bool_field_acquire(int offset) const                { return Atomic::load_acquire(field_addr<jboolean>(offset)); }\n-void oopDesc::release_bool_field_put(int offset, jboolean value)      { Atomic::release_store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n+jboolean oopDesc::bool_field_acquire(int offset) const                { return AtomicAccess::load_acquire(field_addr<jboolean>(offset)); }\n+void oopDesc::release_bool_field_put(int offset, jboolean value)      { AtomicAccess::release_store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n@@ -190,2 +190,2 @@\n-jint oopDesc::int_field_acquire(int offset) const                     { return Atomic::load_acquire(field_addr<jint>(offset)); }\n-void oopDesc::release_int_field_put(int offset, jint value)           { Atomic::release_store(field_addr<jint>(offset), value); }\n+jint oopDesc::int_field_acquire(int offset) const                     { return AtomicAccess::load_acquire(field_addr<jint>(offset)); }\n+void oopDesc::release_int_field_put(int offset, jint value)           { AtomicAccess::release_store(field_addr<jint>(offset), value); }\n@@ -193,2 +193,2 @@\n-jshort oopDesc::short_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jshort>(offset)); }\n-void oopDesc::release_short_field_put(int offset, jshort value)       { Atomic::release_store(field_addr<jshort>(offset), value); }\n+jshort oopDesc::short_field_acquire(int offset) const                 { return AtomicAccess::load_acquire(field_addr<jshort>(offset)); }\n+void oopDesc::release_short_field_put(int offset, jshort value)       { AtomicAccess::release_store(field_addr<jshort>(offset), value); }\n@@ -196,2 +196,2 @@\n-jlong oopDesc::long_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jlong>(offset)); }\n-void oopDesc::release_long_field_put(int offset, jlong value)         { Atomic::release_store(field_addr<jlong>(offset), value); }\n+jlong oopDesc::long_field_acquire(int offset) const                   { return AtomicAccess::load_acquire(field_addr<jlong>(offset)); }\n+void oopDesc::release_long_field_put(int offset, jlong value)         { AtomicAccess::release_store(field_addr<jlong>(offset), value); }\n@@ -199,2 +199,2 @@\n-jfloat oopDesc::float_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jfloat>(offset)); }\n-void oopDesc::release_float_field_put(int offset, jfloat value)       { Atomic::release_store(field_addr<jfloat>(offset), value); }\n+jfloat oopDesc::float_field_acquire(int offset) const                 { return AtomicAccess::load_acquire(field_addr<jfloat>(offset)); }\n+void oopDesc::release_float_field_put(int offset, jfloat value)       { AtomicAccess::release_store(field_addr<jfloat>(offset), value); }\n@@ -202,2 +202,2 @@\n-jdouble oopDesc::double_field_acquire(int offset) const               { return Atomic::load_acquire(field_addr<jdouble>(offset)); }\n-void oopDesc::release_double_field_put(int offset, jdouble value)     { Atomic::release_store(field_addr<jdouble>(offset), value); }\n+jdouble oopDesc::double_field_acquire(int offset) const               { return AtomicAccess::load_acquire(field_addr<jdouble>(offset)); }\n+void oopDesc::release_double_field_put(int offset, jdouble value)     { AtomicAccess::release_store(field_addr<jdouble>(offset), value); }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -54,1 +54,1 @@\n-  return Atomic::load(&_mark);\n+  return AtomicAccess::load(&_mark);\n@@ -58,1 +58,1 @@\n-  return Atomic::load_acquire(&_mark);\n+  return AtomicAccess::load_acquire(&_mark);\n@@ -62,1 +62,1 @@\n-  Atomic::store(&_mark, m);\n+  AtomicAccess::store(&_mark, m);\n@@ -70,1 +70,1 @@\n-  Atomic::release_store((markWord*)(((char*)mem) + mark_offset_in_bytes()), m);\n+  AtomicAccess::release_store((markWord*)(((char*)mem) + mark_offset_in_bytes()), m);\n@@ -74,1 +74,1 @@\n-  Atomic::release_store(&_mark, m);\n+  AtomicAccess::release_store(&_mark, m);\n@@ -78,1 +78,1 @@\n-  return Atomic::cmpxchg(&_mark, old_mark, new_mark);\n+  return AtomicAccess::cmpxchg(&_mark, old_mark, new_mark);\n@@ -82,1 +82,1 @@\n-  return Atomic::cmpxchg(&_mark, old_mark, new_mark, order);\n+  return AtomicAccess::cmpxchg(&_mark, old_mark, new_mark, order);\n@@ -135,1 +135,1 @@\n-      narrowKlass narrow_klass = Atomic::load_acquire(&_metadata._compressed_klass);\n+      narrowKlass narrow_klass = AtomicAccess::load_acquire(&_metadata._compressed_klass);\n@@ -139,1 +139,1 @@\n-      return Atomic::load_acquire(&_metadata._klass);\n+      return AtomicAccess::load_acquire(&_metadata._klass);\n@@ -180,1 +180,1 @@\n-    Atomic::release_store((narrowKlass*)raw_mem,\n+    AtomicAccess::release_store((narrowKlass*)raw_mem,\n@@ -183,1 +183,1 @@\n-    Atomic::release_store((Klass**)raw_mem, k);\n+    AtomicAccess::release_store((Klass**)raw_mem, k);\n@@ -302,2 +302,2 @@\n-inline jint oopDesc::int_field_relaxed(int offset) const            { return Atomic::load(field_addr<jint>(offset)); }\n-inline void oopDesc::int_field_put_relaxed(int offset, jint value)  { Atomic::store(field_addr<jint>(offset), value); }\n+inline jint oopDesc::int_field_relaxed(int offset) const            { return AtomicAccess::load(field_addr<jint>(offset)); }\n+inline void oopDesc::int_field_put_relaxed(int offset, jint value)  { AtomicAccess::store(field_addr<jint>(offset), value); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -137,2 +137,2 @@\n-  u1 get_code()                 const { return Atomic::load_acquire(&_get_code);      }\n-  u1 put_code()                 const { return Atomic::load_acquire(&_put_code);      }\n+  u1 get_code()                 const { return AtomicAccess::load_acquire(&_get_code);      }\n+  u1 put_code()                 const { return AtomicAccess::load_acquire(&_put_code);      }\n@@ -181,1 +181,1 @@\n-    Atomic::release_store(code, new_code);\n+    AtomicAccess::release_store(code, new_code);\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  Method* method()               const { return Atomic::load_acquire(&_method); }\n+  Method* method()               const { return AtomicAccess::load_acquire(&_method); }\n@@ -104,1 +104,1 @@\n-    Atomic::store(&_number_of_parameters, (u2)value);\n+    AtomicAccess::store(&_number_of_parameters, (u2)value);\n@@ -116,1 +116,1 @@\n-    Atomic::release_store(&_method, m);\n+    AtomicAccess::release_store(&_method, m);\n","filename":"src\/hotspot\/share\/oops\/resolvedIndyEntry.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -148,1 +148,1 @@\n-  Method* method() const { return Atomic::load_acquire(&_method); }\n+  Method* method() const { return AtomicAccess::load_acquire(&_method); }\n@@ -167,2 +167,2 @@\n-  u1 bytecode1() const { return Atomic::load_acquire(&_bytecode1); }\n-  u1 bytecode2() const { return Atomic::load_acquire(&_bytecode2); }\n+  u1 bytecode1() const { return AtomicAccess::load_acquire(&_bytecode1); }\n+  u1 bytecode2() const { return AtomicAccess::load_acquire(&_bytecode2); }\n@@ -203,1 +203,1 @@\n-    Atomic::release_store(code, new_code);\n+    AtomicAccess::release_store(code, new_code);\n@@ -215,1 +215,1 @@\n-    Atomic::release_store(&_method, m);\n+    AtomicAccess::release_store(&_method, m);\n","filename":"src\/hotspot\/share\/oops\/resolvedMethodEntry.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -338,1 +338,1 @@\n-      found = Atomic::cmpxchg(&_hash_and_refcount, old_value, old_value + 1);\n+      found = AtomicAccess::cmpxchg(&_hash_and_refcount, old_value, old_value + 1);\n@@ -357,1 +357,1 @@\n-    NOT_PRODUCT(Atomic::inc(&_total_count);)\n+    NOT_PRODUCT(AtomicAccess::inc(&_total_count);)\n@@ -377,1 +377,1 @@\n-      found = Atomic::cmpxchg(&_hash_and_refcount, old_value, old_value - 1);\n+      found = AtomicAccess::cmpxchg(&_hash_and_refcount, old_value, old_value - 1);\n@@ -399,1 +399,1 @@\n-      found = Atomic::cmpxchg(&_hash_and_refcount, old_value, pack_hash_and_refcount(hash, PERM_REFCOUNT));\n+      found = AtomicAccess::cmpxchg(&_hash_and_refcount, old_value, pack_hash_and_refcount(hash, PERM_REFCOUNT));\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -36,2 +36,2 @@\n-  uint i = Atomic::add(&_index, 1u) % QueueSize;\n-  Symbol* old = Atomic::xchg(&_queue[i], sym);\n+  uint i = AtomicAccess::add(&_index, 1u) % QueueSize;\n+  Symbol* old = AtomicAccess::xchg(&_queue[i], sym);\n@@ -43,1 +43,1 @@\n-    Symbol* sym = Atomic::xchg(&_queue[i], (Symbol*) nullptr);\n+    Symbol* sym = AtomicAccess::xchg(&_queue[i], (Symbol*) nullptr);\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-  uint init_deps_left1 = Atomic::sub(&_init_deps_left, 1);\n+  uint init_deps_left1 = AtomicAccess::sub(&_init_deps_left, 1);\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-    return Atomic::load_acquire(&_init_deps_left);\n+    return AtomicAccess::load_acquire(&_init_deps_left);\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,1 +159,1 @@\n-  return Atomic::load_acquire(byte_at_addr(which));\n+  return AtomicAccess::load_acquire(byte_at_addr(which));\n@@ -162,1 +162,1 @@\n-  Atomic::release_store(byte_at_addr(which), contents);\n+  AtomicAccess::release_store(byte_at_addr(which), contents);\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1580,2 +1580,2 @@\n-    \/\/ capture allstackedness flag before mask is hacked\n-    const int is_allstack = lrg->mask().is_AllStack();\n+    \/\/ capture infinitestackedness flag before mask is hacked\n+    const int is_infinite_stack = lrg->mask().is_infinite_stack();\n@@ -1632,1 +1632,1 @@\n-    \/\/assert(is_allstack == lrg->mask().is_AllStack(), \"nbrs must not change AllStackedness\");\n+    \/\/assert(is_infinite_stack == lrg->mask().is_infinite_stack(), \"nbrs must not change InfiniteStackedness\");\n@@ -1643,1 +1643,1 @@\n-    \/\/ If we fail to color and the AllStack flag is set, trigger\n+    \/\/ If we fail to color and the infinite flag is set, trigger\n@@ -1645,1 +1645,1 @@\n-    if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) && is_allstack) {\n+    if (!OptoReg::is_valid(OptoReg::add(reg, -chunk)) && is_infinite_stack) {\n@@ -1654,1 +1654,1 @@\n-    else if( OptoReg::is_valid(reg)) {\n+    else if (OptoReg::is_valid(reg)) {\n@@ -1711,1 +1711,1 @@\n-      assert( !orig_mask.is_AllStack(), \"All Stack does not spill\" );\n+      assert( !orig_mask.is_infinite_stack(), \"infinite stack does not spill\" );\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  static const uint AllStack_size = 0xFFFFF; \/\/ This mask size is used to tell that the mask of this LRG supports stack positions\n+  static const uint INFINITE_STACK_SIZE = 0xFFFFF; \/\/ This mask size is used to tell that the mask of this LRG supports stack positions\n@@ -86,1 +86,1 @@\n-    assert(!_mask.is_AllStack() || (_mask.is_AllStack() && lo_degree()), \"_eff_degree can't be bigger than AllStack_size - _num_regs if the mask supports stack registers\");\n+    assert(!_mask.is_infinite_stack() || (_mask.is_infinite_stack() && lo_degree()), \"_eff_degree can't be bigger than INFINITE_STACK_SIZE - _num_regs if the mask supports stack registers\");\n@@ -93,1 +93,1 @@\n-    assert(!_mask.is_AllStack() || (_mask.is_AllStack() && lo_degree()), \"_eff_degree can't be bigger than AllStack_size - _num_regs if the mask supports stack registers\");\n+    assert(!_mask.is_infinite_stack() || (_mask.is_infinite_stack() && lo_degree()), \"_eff_degree can't be bigger than INFINITE_STACK_SIZE - _num_regs if the mask supports stack registers\");\n@@ -108,1 +108,1 @@\n-  int compute_mask_size() const { return _mask.is_AllStack() ? AllStack_size : _mask.Size(); }\n+  int compute_mask_size() const { return _mask.is_infinite_stack() ? INFINITE_STACK_SIZE : _mask.Size(); }\n@@ -110,1 +110,1 @@\n-    assert((size == (int)AllStack_size) || (size == (int)_mask.Size()), \"\");\n+    assert((size == (int)INFINITE_STACK_SIZE) || (size == (int)_mask.Size()), \"\");\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-          if( !lrgs(lidx).mask().is_AllStack() ) {\n+          if( !lrgs(lidx).mask().is_infinite_stack() ) {\n@@ -701,1 +701,1 @@\n-  if (UseFPUForSpilling && rm.is_AllStack() ) {\n+  if (UseFPUForSpilling && rm.is_infinite_stack()) {\n@@ -710,1 +710,3 @@\n-  if( rm.is_AllStack() ) rm_size += 1000000;\n+  if (rm.is_infinite_stack()) {\n+    rm_size += 1000000;\n+  }\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1201,1 +1201,2 @@\n-const Type* ModINode::Value(PhaseGVN* phase) const {\n+static const Type* mod_value(const PhaseGVN* phase, const Node* in1, const Node* in2, const BasicType bt) {\n+  assert(bt == T_INT || bt == T_LONG, \"unexpected basic type\");\n@@ -1203,4 +1204,4 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in1);\n+  const Type* t2 = phase->type(in2);\n+  if (t1 == Type::TOP) { return Type::TOP; }\n+  if (t2 == Type::TOP) { return Type::TOP; }\n@@ -1210,1 +1211,2 @@\n-  if( t1 == TypeInt::ZERO ) return TypeInt::ZERO;\n+  if (t1 == TypeInteger::zero(bt)) { return t1; }\n+\n@@ -1212,2 +1214,2 @@\n-  if (in(1) == in(2)) {\n-    return TypeInt::ZERO;\n+  if (in1 == in2) {\n+    return TypeInteger::zero(bt);\n@@ -1216,14 +1218,0 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  const TypeInt *i1 = t1->is_int();\n-  const TypeInt *i2 = t2->is_int();\n-  if( !i1->is_con() || !i2->is_con() ) {\n-    if( i1->_lo >= 0 && i2->_lo >= 0 )\n-      return TypeInt::POS;\n-    \/\/ If both numbers are not constants, we know little.\n-    return TypeInt::INT;\n-  }\n@@ -1231,1 +1219,3 @@\n-  if( !i2->get_con() ) return TypeInt::POS;\n+  if (t2 == TypeInteger::zero(bt)) {\n+    return Type::TOP;\n+  }\n@@ -1233,4 +1223,45 @@\n-  \/\/ We must be modulo'ing 2 float constants.\n-  \/\/ Check for min_jint % '-1', result is defined to be '0'.\n-  if( i1->get_con() == min_jint && i2->get_con() == -1 )\n-    return TypeInt::ZERO;\n+  const TypeInteger* i1 = t1->is_integer(bt);\n+  const TypeInteger* i2 = t2->is_integer(bt);\n+  if (i1->is_con() && i2->is_con()) {\n+    \/\/ We must be modulo'ing 2 int constants.\n+    \/\/ Special case: min_jlong % '-1' is UB, and e.g., x86 triggers a division error.\n+    \/\/ Any value % -1 is 0, so we can return 0 and avoid that scenario.\n+    if (i2->get_con_as_long(bt) == -1) {\n+      return TypeInteger::zero(bt);\n+    }\n+    return TypeInteger::make(i1->get_con_as_long(bt) % i2->get_con_as_long(bt), bt);\n+  }\n+  \/\/ We checked that t2 is not the zero constant. Hence, at least i2->_lo or i2->_hi must be non-zero,\n+  \/\/ and hence its absoute value is bigger than zero. Hence, the magnitude of the divisor (i.e. the\n+  \/\/ largest absolute value for any value in i2) must be in the range [1, 2^31] or [1, 2^63], depending\n+  \/\/ on the BasicType.\n+  julong divisor_magnitude = MAX2(g_uabs(i2->lo_as_long()), g_uabs(i2->hi_as_long()));\n+  \/\/ JVMS lrem bytecode: \"the magnitude of the result is always less than the magnitude of the divisor\"\n+  \/\/ \"less than\" means we can subtract 1 to get an inclusive upper bound in [0, 2^31-1] or [0, 2^63-1], respectively\n+  jlong hi = static_cast<jlong>(divisor_magnitude - 1);\n+  jlong lo = -hi;\n+  \/\/ JVMS lrem bytecode: \"the result of the remainder operation can be negative only if the dividend\n+  \/\/ is negative and can be positive only if the dividend is positive\"\n+  \/\/ Note that with a dividend with bounds e.g. lo == -4 and hi == -1 can still result in values\n+  \/\/ below lo; i.e., -3 % 3 == 0.\n+  \/\/ That means we cannot restrict the bound that is closer to zero beyond knowing its sign (or zero).\n+  if (i1->hi_as_long() <= 0) {\n+    \/\/ all dividends are not positive, so the result is not positive\n+    hi = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as a lower limit\n+    lo = MAX2(lo, i1->lo_as_long());\n+  } else if (i1->lo_as_long() >= 0) {\n+    \/\/ all dividends are not negative, so the result is not negative\n+    lo = 0;\n+    \/\/ if the dividend is known to be closer to zero, use that as an upper limit\n+    hi = MIN2(hi, i1->hi_as_long());\n+  } else {\n+    \/\/ Mixed signs, so we don't know the sign of the result, but the result is\n+    \/\/ either the dividend itself or a value closer to zero than the dividend,\n+    \/\/ and it is closer to zero than the divisor.\n+    \/\/ As we know i1->_lo < 0 and i1->_hi > 0, we can use these bounds directly.\n+    lo = MAX2(lo, i1->lo_as_long());\n+    hi = MIN2(hi, i1->hi_as_long());\n+  }\n+  return TypeInteger::make(lo, hi, MAX2(i1->_widen, i2->_widen), bt);\n+}\n@@ -1238,1 +1269,2 @@\n-  return TypeInt::make( i1->get_con() % i2->get_con() );\n+const Type* ModINode::Value(PhaseGVN* phase) const {\n+  return mod_value(phase, in(1), in(2), T_INT);\n@@ -1467,37 +1499,1 @@\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n-\n-  \/\/ We always generate the dynamic check for 0.\n-  \/\/ 0 MOD X is 0\n-  if( t1 == TypeLong::ZERO ) return TypeLong::ZERO;\n-  \/\/ X MOD X is 0\n-  if (in(1) == in(2)) {\n-    return TypeLong::ZERO;\n-  }\n-\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  const TypeLong *i1 = t1->is_long();\n-  const TypeLong *i2 = t2->is_long();\n-  if( !i1->is_con() || !i2->is_con() ) {\n-    if( i1->_lo >= CONST64(0) && i2->_lo >= CONST64(0) )\n-      return TypeLong::POS;\n-    \/\/ If both numbers are not constants, we know little.\n-    return TypeLong::LONG;\n-  }\n-  \/\/ Mod by zero?  Throw exception at runtime!\n-  if( !i2->get_con() ) return TypeLong::POS;\n-\n-  \/\/ We must be modulo'ing 2 float constants.\n-  \/\/ Check for min_jint % '-1', result is defined to be '0'.\n-  if( i1->get_con() == min_jlong && i2->get_con() == -1 )\n-    return TypeLong::ZERO;\n-\n-  return TypeLong::make( i1->get_con() % i2->get_con() );\n+  return mod_value(phase, in(1), in(2), T_LONG);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":61,"deletions":65,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -3197,0 +3197,8 @@\n+        } else if (use->is_LocalVar()) {\n+          Node* phi = use->ideal_node();\n+          if (phi->Opcode() == Op_Phi && reducible_merges.member(phi) && !can_reduce_phi(phi->as_Phi())) {\n+            set_not_scalar_replaceable(jobj NOT_PRODUCT(COMMA \"is merged in a non-reducible phi\"));\n+            reducible_merges.yank(phi);\n+            found_nsr_alloc = true;\n+            break;\n+          }\n@@ -5187,1 +5195,1 @@\n-  tty->print_cr(\"No escape = %d, Arg escape = %d, Global escape = %d\", Atomic::load(&_no_escape_counter), Atomic::load(&_arg_escape_counter), Atomic::load(&_global_escape_counter));\n+  tty->print_cr(\"No escape = %d, Arg escape = %d, Global escape = %d\", AtomicAccess::load(&_no_escape_counter), AtomicAccess::load(&_arg_escape_counter), AtomicAccess::load(&_global_escape_counter));\n@@ -5198,1 +5206,1 @@\n-        Atomic::inc(&ConnectionGraph::_no_escape_counter);\n+        AtomicAccess::inc(&ConnectionGraph::_no_escape_counter);\n@@ -5200,1 +5208,1 @@\n-        Atomic::inc(&ConnectionGraph::_arg_escape_counter);\n+        AtomicAccess::inc(&ConnectionGraph::_arg_escape_counter);\n@@ -5202,1 +5210,1 @@\n-        Atomic::inc(&ConnectionGraph::_global_escape_counter);\n+        AtomicAccess::inc(&ConnectionGraph::_global_escape_counter);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -451,0 +451,5 @@\n+    if (n->adr_type() != nullptr) {\n+      stringStream adr_type_stream;\n+      n->adr_type()->dump_on(&adr_type_stream);\n+      print_prop(\"adr_type\", adr_type_stream.freeze());\n+    }\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-        interfering_lrg.set_mask_size(interfering_lrg.mask().is_AllStack() ? LRG::AllStack_size : old_size - 1);\n+        interfering_lrg.set_mask_size(interfering_lrg.mask().is_infinite_stack() ? LRG::INFINITE_STACK_SIZE : old_size - 1);\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        if (!lrg.mask().is_AllStack()) {\n+        if (!lrg.mask().is_infinite_stack()) {\n@@ -201,1 +201,1 @@\n-          if (!lrg.mask().is_AllStack()) {\n+          if (!lrg.mask().is_infinite_stack()) {\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4034,2 +4034,2 @@\n- *   Atomic::store(&tl->_contextual_tid, java_lang_Thread::tid(thread));\n- *   Atomic::store(&tl->_contextual_thread_excluded, is_excluded);\n+ *   AtomicAccess::store(&tl->_contextual_tid, java_lang_Thread::tid(thread));\n+ *   AtomicAccess::store(&tl->_contextual_thread_excluded, is_excluded);\n@@ -4038,1 +4038,1 @@\n- *     Atomic::store(&tl->_vthread_epoch, vthread_epoch);\n+ *     AtomicAccess::store(&tl->_vthread_epoch, vthread_epoch);\n@@ -4040,1 +4040,1 @@\n- *   Atomic::release_store(&tl->_vthread, true);\n+ *   AtomicAccess::release_store(&tl->_vthread, true);\n@@ -4043,1 +4043,1 @@\n- * Atomic::release_store(&tl->_vthread, false);\n+ * AtomicAccess::release_store(&tl->_vthread, false);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -833,1 +833,1 @@\n-    Atomic::inc(&_long_loop_candidates);\n+    AtomicAccess::inc(&_long_loop_candidates);\n@@ -1151,1 +1151,1 @@\n-    Atomic::inc(&_long_loop_nests);\n+    AtomicAccess::inc(&_long_loop_nests);\n@@ -2588,1 +2588,1 @@\n-    Atomic::inc(&_long_loop_counted_loops);\n+    AtomicAccess::inc(&_long_loop_counted_loops);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1870,0 +1870,2 @@\n+  bool would_sink_below_pre_loop_exit(IdealLoopTree* n_loop, Node* ctrl);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1885,9 +1885,11 @@\n-        if (n->depends_only_on_test()) {\n-          Node* pinned_clone = n->pin_array_access_node();\n-          if (pinned_clone != nullptr) {\n-            \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n-            \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n-            \/\/ unpinned load would risk floating above its range check.\n-            register_new_node(pinned_clone, n_ctrl);\n-            maybe_pinned_n = pinned_clone;\n-            _igvn.replace_node(n, pinned_clone);\n+        if (!would_sink_below_pre_loop_exit(loop_ctrl, outside_ctrl)) {\n+          if (n->depends_only_on_test()) {\n+            Node* pinned_clone = n->pin_array_access_node();\n+            if (pinned_clone != nullptr) {\n+              \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n+              \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n+              \/\/ unpinned load would risk floating above its range check.\n+              register_new_node(pinned_clone, n_ctrl);\n+              maybe_pinned_n = pinned_clone;\n+              _igvn.replace_node(n, pinned_clone);\n+            }\n@@ -1895,0 +1897,1 @@\n+          _igvn.replace_input_of(maybe_pinned_n, 0, outside_ctrl);\n@@ -1896,1 +1899,0 @@\n-        _igvn.replace_input_of(maybe_pinned_n, 0, outside_ctrl);\n@@ -2104,0 +2106,15 @@\n+\/\/ Sinking a node from a pre loop to its main loop pins the node between the pre and main loops. If that node is input\n+\/\/ to a check that's eliminated by range check elimination, it becomes input to an expression that feeds into the exit\n+\/\/ test of the pre loop above the point in the graph where it's pinned. This results in a broken graph. One way to avoid\n+\/\/ it would be to not eliminate the check in the main loop. Instead, we prevent sinking of the node here so better code\n+\/\/ is generated for the main loop.\n+bool PhaseIdealLoop::would_sink_below_pre_loop_exit(IdealLoopTree* n_loop, Node* ctrl) {\n+  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n+    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n+    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -2115,8 +2132,2 @@\n-  \/\/ Sinking a node from a pre loop to its main loop pins the node between the pre and main loops. If that node is input\n-  \/\/ to a check that's eliminated by range check elimination, it becomes input to an expression that feeds into the exit\n-  \/\/ test of the pre loop above the point in the graph where it's pinned.\n-  if (n_loop->_head->is_CountedLoop() && n_loop->_head->as_CountedLoop()->is_pre_loop()) {\n-    CountedLoopNode* pre_loop = n_loop->_head->as_CountedLoop();\n-    if (is_dominator(pre_loop->loopexit(), ctrl)) {\n-      return false;\n-    }\n+  if (would_sink_below_pre_loop_exit(n_loop, ctrl)) {\n+    return false;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    Atomic::inc(&PhaseMacroExpand::_GC_barriers_removed_counter);\n+    AtomicAccess::inc(&PhaseMacroExpand::_GC_barriers_removed_counter);\n@@ -3037,1 +3037,1 @@\n-          Atomic::inc(&PhaseMacroExpand::_objs_scalar_replaced_counter);\n+          AtomicAccess::inc(&PhaseMacroExpand::_objs_scalar_replaced_counter);\n@@ -3054,1 +3054,1 @@\n-            Atomic::inc(&PhaseMacroExpand::_monitor_objects_removed_counter);\n+            AtomicAccess::inc(&PhaseMacroExpand::_monitor_objects_removed_counter);\n@@ -3106,1 +3106,1 @@\n-    Atomic::add(&PhaseMacroExpand::_memory_barriers_removed_counter, membar_before - membar_after);\n+    AtomicAccess::add(&PhaseMacroExpand::_memory_barriers_removed_counter, membar_before - membar_after);\n@@ -3341,4 +3341,4 @@\n-  tty->print(\"Objects scalar replaced = %d, \", Atomic::load(&_objs_scalar_replaced_counter));\n-  tty->print(\"Monitor objects removed = %d, \", Atomic::load(&_monitor_objects_removed_counter));\n-  tty->print(\"GC barriers removed = %d, \", Atomic::load(&_GC_barriers_removed_counter));\n-  tty->print_cr(\"Memory barriers removed = %d\", Atomic::load(&_memory_barriers_removed_counter));\n+  tty->print(\"Objects scalar replaced = %d, \", AtomicAccess::load(&_objs_scalar_replaced_counter));\n+  tty->print(\"Monitor objects removed = %d, \", AtomicAccess::load(&_monitor_objects_removed_counter));\n+  tty->print(\"GC barriers removed = %d, \", AtomicAccess::load(&_GC_barriers_removed_counter));\n+  tty->print_cr(\"Memory barriers removed = %d\", AtomicAccess::load(&_memory_barriers_removed_counter));\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -593,1 +593,1 @@\n-  C->FIRST_STACK_mask().set_AllStack();\n+  C->FIRST_STACK_mask().set_infinite_stack();\n@@ -599,1 +599,1 @@\n-  assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+  assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -656,1 +656,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -671,1 +671,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -686,1 +686,1 @@\n-     assert(aligned_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(aligned_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -706,1 +706,1 @@\n-      assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+      assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -720,1 +720,1 @@\n-     assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+     assert(scalable_stack_mask.is_infinite_stack(), \"should be infinite stack\");\n@@ -1033,1 +1033,1 @@\n-  STACK_ONLY_mask.set_AllStack();\n+  STACK_ONLY_mask.set_infinite_stack();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1226,0 +1226,3 @@\n+  } else if (n->Opcode() == Op_XorV || n->Opcode() == Op_XorVMask) {\n+    \/\/ Condition for XorVMask(VectorMaskCmp(x,y,cond), MaskAll(true)) ==> VectorMaskCmp(x,y,ncond)\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2698,1 +2698,5 @@\n-  if (use->Opcode() == Op_AddX) {\n+\n+  \/\/ From CastX2PNode::Ideal\n+  \/\/ CastX2P(AddX(x, y))\n+  \/\/ CastX2P(SubX(x, y))\n+  if (use->Opcode() == Op_AddX || use->Opcode() == Op_SubX) {\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,2 +176,2 @@\n-  bool can_use = ( RegMask::can_represent(def_reg) ? (use_mask.Member(def_reg) != 0)\n-                                                   : (use_mask.is_AllStack() != 0));\n+  bool can_use = (RegMask::can_represent(def_reg) ? (use_mask.Member(def_reg) != 0)\n+                                                  : (use_mask.is_infinite_stack() != 0));\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-      assert(!lrgs(bidx).mask().is_AllStack(),\"AllStack should color\");\n+      assert(!lrgs(bidx).mask().is_infinite_stack(), \"Infinite stack mask should color\");\n@@ -1040,1 +1040,1 @@\n-            if( !umask.is_AllStack() &&\n+            if (!umask.is_infinite_stack() &&\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -125,1 +125,1 @@\n-    _RM_UP[i] = bits;\n+    _rm_word[i] = bits;\n@@ -138,1 +138,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -154,1 +154,3 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite_stack()) {\n+    return false;\n+  }\n@@ -157,1 +159,1 @@\n-    uintptr_t v = _RM_UP[i];\n+    uintptr_t v = _rm_word[i];\n@@ -166,1 +168,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -180,1 +182,3 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite_stack()) {\n+    return false;\n+  }\n@@ -184,3 +188,3 @@\n-    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n-      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n-      if (bit_index != _WordBitMask) {   \/\/ Bit pair stays in same word?\n+    if (_rm_word[i] != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(_rm_word[i]);\n+      if (bit_index != WORD_BIT_MASK) {   \/\/ Bit pair stays in same word?\n@@ -188,1 +192,1 @@\n-        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n+        if ((bit | (bit << 1U)) != _rm_word[i]) {\n@@ -192,1 +196,1 @@\n-        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n+        assert(is_power_of_2(_rm_word[i]), \"invariant\");\n@@ -194,1 +198,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1) {\n+        if (i > _hwm || _rm_word[i] != 1) {\n@@ -201,1 +205,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -247,1 +251,1 @@\n-    if (_RM_UP[i]) {                \/\/ Found some bits\n+    if (_rm_word[i]) {                \/\/ Found some bits\n@@ -249,1 +253,1 @@\n-      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_RM_UP[i]) + (size - 1));\n+      return OptoReg::Name((i << LogBitsPerWord) + find_lowest_bit(_rm_word[i]) + (size - 1));\n@@ -263,1 +267,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -278,1 +282,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_word[i] = sets;\n@@ -291,1 +295,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -307,1 +311,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_word[i] = sets;\n@@ -320,1 +324,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_word[i];\n@@ -343,1 +347,3 @@\n-  if (is_AllStack()) return false;\n+  if (is_infinite_stack()) {\n+    return false;\n+  }\n@@ -347,2 +353,2 @@\n-    if (_RM_UP[i] != 0) {       \/\/ Found some bits\n-      unsigned bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (_rm_word[i] != 0) {       \/\/ Found some bits\n+      unsigned bit_index = find_lowest_bit(_rm_word[i]);\n@@ -353,1 +359,1 @@\n-        if (set != _RM_UP[i]) {\n+        if (set != _rm_word[i]) {\n@@ -358,1 +364,1 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i]) {\n+        if ((all & ~(bit - 1)) != _rm_word[i]) {\n@@ -364,1 +370,1 @@\n-        if (i > _hwm || _RM_UP[i] != set) {\n+        if (i > _hwm || _rm_word[i] != set) {\n@@ -371,1 +377,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_word[i] != 0) {\n@@ -386,1 +392,1 @@\n-  if (is_AllStack())\n+  if (is_infinite_stack()) {\n@@ -388,0 +394,1 @@\n+  }\n@@ -400,1 +407,1 @@\n-    sum += population_count(_RM_UP[i]);\n+    sum += population_count(_rm_word[i]);\n@@ -448,1 +455,3 @@\n-    if (is_AllStack()) st->print(\"...\");\n+    if (is_infinite_stack()) {\n+      st->print(\"...\");\n+    }\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":40,"deletions":31,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-\/\/ The ADLC defines 2 macros, RM_SIZE and FORALL_BODY.\n-\/\/ RM_SIZE is the size of a register mask in 32-bit words.\n+\/\/ The ADLC defines 2 macros, RM_SIZE_IN_INTS and FORALL_BODY.\n+\/\/ RM_SIZE_IN_INTS is the size of a register mask in 32-bit words.\n@@ -62,2 +62,2 @@\n-  \/\/ The RM_SIZE is aligned to 64-bit - assert that this holds\n-  LP64_ONLY(STATIC_ASSERT(is_aligned(RM_SIZE, 2)));\n+  \/\/ RM_SIZE_IN_INTS is aligned to 64-bit - assert that this holds\n+  LP64_ONLY(STATIC_ASSERT(is_aligned(RM_SIZE_IN_INTS, 2)));\n@@ -65,4 +65,4 @@\n-  static const unsigned int _WordBitMask = BitsPerWord - 1U;\n-  static const unsigned int _LogWordBits = LogBitsPerWord;\n-  static const unsigned int _RM_SIZE     = LP64_ONLY(RM_SIZE >> 1) NOT_LP64(RM_SIZE);\n-  static const unsigned int _RM_MAX      = _RM_SIZE - 1U;\n+  static const unsigned int WORD_BIT_MASK = BitsPerWord - 1U;\n+  static const unsigned int RM_SIZE_IN_WORDS =\n+      LP64_ONLY(RM_SIZE_IN_INTS >> 1) NOT_LP64(RM_SIZE_IN_INTS);\n+  static const unsigned int RM_WORD_MAX_INDEX = RM_SIZE_IN_WORDS - 1U;\n@@ -76,2 +76,2 @@\n-    int       _RM_I[RM_SIZE];\n-    uintptr_t _RM_UP[_RM_SIZE];\n+    int _rm_int[RM_SIZE_IN_INTS];\n+    uintptr_t _rm_word[RM_SIZE_IN_WORDS];\n@@ -88,1 +88,1 @@\n-  enum { CHUNK_SIZE = _RM_SIZE * BitsPerWord };\n+  enum { CHUNK_SIZE = RM_SIZE_IN_WORDS * BitsPerWord };\n@@ -120,1 +120,1 @@\n-#   define BODY(I) _RM_I[I] = a##I;\n+#   define BODY(I) _rm_int[I] = a##I;\n@@ -123,1 +123,1 @@\n-#   define BODY(I) _RM_I[I ^ 1] = a##I;\n+#   define BODY(I) _rm_int[I ^ 1] = a##I;\n@@ -128,3 +128,7 @@\n-    _hwm = _RM_MAX;\n-    while (_hwm > 0      && _RM_UP[_hwm] == 0) _hwm--;\n-    while ((_lwm < _hwm) && _RM_UP[_lwm] == 0) _lwm++;\n+    _hwm = RM_WORD_MAX_INDEX;\n+    while (_hwm > 0 && _rm_word[_hwm] == 0) {\n+      _hwm--;\n+    }\n+    while ((_lwm < _hwm) && _rm_word[_lwm] == 0) {\n+      _lwm++;\n+    }\n@@ -138,2 +142,2 @@\n-    for (unsigned i = 0; i < _RM_SIZE; i++) {\n-      _RM_UP[i] = rm->_RM_UP[i];\n+    for (unsigned i = 0; i < RM_SIZE_IN_WORDS; i++) {\n+      _rm_word[i] = rm->_rm_word[i];\n@@ -145,1 +149,1 @@\n-  RegMask() : _RM_UP(), _lwm(_RM_MAX), _hwm(0) {\n+  RegMask() : _rm_word(), _lwm(RM_WORD_MAX_INDEX), _hwm(0) {\n@@ -159,1 +163,1 @@\n-    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) << (r & _WordBitMask));\n+    return _rm_word[r >> LogBitsPerWord] & (uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -165,2 +169,2 @@\n-  bool is_AllStack() const {\n-    return (_RM_UP[_RM_MAX] & (uintptr_t(1) << _WordBitMask)) != 0;\n+  bool is_infinite_stack() const {\n+    return (_rm_word[RM_WORD_MAX_INDEX] & (uintptr_t(1) << WORD_BIT_MASK)) != 0;\n@@ -169,2 +173,2 @@\n-  void set_AllStack() {\n-    _RM_UP[_RM_MAX] |= (uintptr_t(1) << _WordBitMask);\n+  void set_infinite_stack() {\n+    _rm_word[RM_WORD_MAX_INDEX] |= (uintptr_t(1) << WORD_BIT_MASK);\n@@ -178,1 +182,1 @@\n-      tmp |= _RM_UP[i];\n+      tmp |= _rm_word[i];\n@@ -187,1 +191,1 @@\n-      uintptr_t bits = _RM_UP[i];\n+      uintptr_t bits = _rm_word[i];\n@@ -189,1 +193,1 @@\n-        return OptoReg::Name((i << _LogWordBits) + find_lowest_bit(bits));\n+        return OptoReg::Name((i << LogBitsPerWord) + find_lowest_bit(bits));\n@@ -201,1 +205,1 @@\n-      uintptr_t bits = _RM_UP[--i];\n+      uintptr_t bits = _rm_word[--i];\n@@ -203,1 +207,1 @@\n-        return OptoReg::Name((i << _LogWordBits) + find_highest_bit(bits));\n+        return OptoReg::Name((i << LogBitsPerWord) + find_highest_bit(bits));\n@@ -216,2 +220,2 @@\n-    assert(_hwm < _RM_SIZE, \"_hwm out of range: %d\", _hwm);\n-    assert(_lwm < _RM_SIZE, \"_lwm out of range: %d\", _lwm);\n+    assert(_hwm < RM_SIZE_IN_WORDS, \"_hwm out of range: %d\", _hwm);\n+    assert(_lwm < RM_SIZE_IN_WORDS, \"_lwm out of range: %d\", _lwm);\n@@ -219,1 +223,1 @@\n-      assert(_RM_UP[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+      assert(_rm_word[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n@@ -221,2 +225,2 @@\n-    for (unsigned i = _hwm + 1; i < _RM_SIZE; i++) {\n-      assert(_RM_UP[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    for (unsigned i = _hwm + 1; i < RM_SIZE_IN_WORDS; i++) {\n+      assert(_rm_word[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n@@ -270,1 +274,1 @@\n-      result |= _RM_UP[i] & rm._RM_UP[i];\n+      result |= _rm_word[i] & rm._rm_word[i];\n@@ -281,1 +285,1 @@\n-    _lwm = _RM_MAX;\n+    _lwm = RM_WORD_MAX_INDEX;\n@@ -283,1 +287,1 @@\n-    memset(_RM_UP, 0, sizeof(uintptr_t) * _RM_SIZE);\n+    memset(_rm_word, 0, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n@@ -290,2 +294,2 @@\n-    _hwm = _RM_MAX;\n-    memset(_RM_UP, 0xFF, sizeof(uintptr_t) * _RM_SIZE);\n+    _hwm = RM_WORD_MAX_INDEX;\n+    memset(_rm_word, 0xFF, sizeof(uintptr_t) * RM_SIZE_IN_WORDS);\n@@ -302,1 +306,1 @@\n-    unsigned index = r >> _LogWordBits;\n+    unsigned index = r >> LogBitsPerWord;\n@@ -305,1 +309,1 @@\n-    _RM_UP[index] |= (uintptr_t(1) << (r & _WordBitMask));\n+    _rm_word[index] |= (uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -313,1 +317,1 @@\n-    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & _WordBitMask));\n+    _rm_word[r >> LogBitsPerWord] &= ~(uintptr_t(1) << (r & WORD_BIT_MASK));\n@@ -323,1 +327,1 @@\n-      _RM_UP[i] |= rm._RM_UP[i];\n+      _rm_word[i] |= rm._rm_word[i];\n@@ -334,1 +338,1 @@\n-      _RM_UP[i] &= rm._RM_UP[i];\n+      _rm_word[i] &= rm._rm_word[i];\n@@ -348,1 +352,1 @@\n-      _RM_UP[i] &= ~rm._RM_UP[i];\n+      _rm_word[i] &= ~rm._rm_word[i];\n@@ -418,1 +422,1 @@\n-      _current_bits = _rm._RM_UP[_next_index++];\n+      _current_bits = _rm._rm_word[_next_index++];\n@@ -426,1 +430,1 @@\n-        _reg = OptoReg::Name(((_next_index - 1) << RegMask::_LogWordBits) + next_bit);\n+        _reg = OptoReg::Name(((_next_index - 1) << LogBitsPerWord) + next_bit);\n@@ -438,1 +442,1 @@\n-#undef RM_SIZE\n+#undef RM_SIZE_IN_INTS\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":53,"deletions":49,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -2262,1 +2262,1 @@\n-  } while (Atomic::cmpxchg(&_named_counters, head, c) != head);\n+  } while (AtomicAccess::cmpxchg(&_named_counters, head, c) != head);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -412,1 +412,1 @@\n-  Atomic::add(&_stropts_total, encountered);\n+  AtomicAccess::add(&_stropts_total, encountered);\n@@ -685,1 +685,1 @@\n-              Atomic::inc(&_stropts_merged);\n+              AtomicAccess::inc(&_stropts_merged);\n@@ -2044,1 +2044,1 @@\n-  Atomic::inc(&_stropts_replaced);\n+  AtomicAccess::inc(&_stropts_replaced);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -353,1 +353,3 @@\n-  mask negate( ) const { return mask(_test^4); }\n+  mask negate( ) const { return negate_mask(_test); }\n+  \/\/ Return the negative mask for the given mask, for both signed and unsigned comparison.\n+  static mask negate_mask(mask btm) { return mask(btm ^ 4); }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2271,0 +2271,93 @@\n+\/\/ Returns whether (XorV (VectorMaskCmp) -1) can be optimized by negating the\n+\/\/ comparison operation.\n+bool VectorMaskCmpNode::predicate_can_be_negated() {\n+  switch (_predicate) {\n+    case BoolTest::eq:\n+    case BoolTest::ne:\n+      \/\/ eq and ne also apply to floating-point special values like NaN and infinities.\n+      return true;\n+    case BoolTest::le:\n+    case BoolTest::ge:\n+    case BoolTest::lt:\n+    case BoolTest::gt:\n+    case BoolTest::ule:\n+    case BoolTest::uge:\n+    case BoolTest::ult:\n+    case BoolTest::ugt: {\n+      BasicType bt = vect_type()->element_basic_type();\n+      \/\/ For float and double, we don't know if either comparison operand is a\n+      \/\/ NaN, NaN {le|ge|lt|gt} anything is false, resulting in inconsistent\n+      \/\/ results before and after negation.\n+      return is_integral_type(bt);\n+    }\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/\/ This function transforms the following patterns:\n+\/\/\n+\/\/ For integer types:\n+\/\/ (XorV (VectorMaskCmp src1 src2 cond) (Replicate -1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ (XorVMask (VectorMaskCmp src1 src2 cond) (MaskAll m1))\n+\/\/    => (VectorMaskCmp src1 src2 ncond)\n+\/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ cond can be eq, ne, le, ge, lt, gt, ule, uge, ult and ugt.\n+\/\/ ncond is the negative comparison of cond.\n+\/\/\n+\/\/ For float and double types:\n+\/\/ (XorV (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (Replicate -1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ (XorVMask (VectorMaskCast (VectorMaskCmp src1 src2 cond)) (MaskAll m1))\n+\/\/    => (VectorMaskCast (VectorMaskCmp src1 src2 ncond))\n+\/\/ cond can be eq or ne.\n+Node* XorVNode::Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape) {\n+  Node* in1 = in(1);\n+  Node* in2 = in(2);\n+  \/\/ Transformations for predicated vectors are not supported for now.\n+  if (is_predicated_vector() ||\n+      in1->is_predicated_vector() ||\n+      in2->is_predicated_vector()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ XorV\/XorVMask is commutative, swap VectorMaskCmp\/VectorMaskCast to in1.\n+  if (VectorNode::is_all_ones_vector(in1)) {\n+    swap(in1, in2);\n+  }\n+\n+  bool with_vector_mask_cast = false;\n+  \/\/ Required conditions:\n+  \/\/   1. VectorMaskCast and VectorMaskCmp should only have a single use,\n+  \/\/      otherwise the optimization may be unprofitable.\n+  \/\/   2. The predicate of VectorMaskCmp should be negatable.\n+  \/\/   3. The second input should be an all true vector mask.\n+  if (in1->Opcode() == Op_VectorMaskCast) {\n+    if (in1->outcnt() != 1) {\n+      return nullptr;\n+    }\n+    with_vector_mask_cast = true;\n+    in1 = in1->in(1);\n+  }\n+  if (in1->Opcode() != Op_VectorMaskCmp ||\n+      in1->outcnt() != 1 ||\n+      !in1->as_VectorMaskCmp()->predicate_can_be_negated() ||\n+      !VectorNode::is_all_ones_vector(in2)) {\n+    return nullptr;\n+  }\n+\n+  BoolTest::mask neg_cond = BoolTest::negate_mask((in1->as_VectorMaskCmp())->get_predicate());\n+  ConINode* predicate_node = phase->intcon(neg_cond);\n+  const TypeVect* vt = in1->as_Vector()->vect_type();\n+  Node* res = new VectorMaskCmpNode(neg_cond, in1->in(1), in1->in(2), predicate_node, vt);\n+  if (with_vector_mask_cast) {\n+    \/\/ We optimized out a VectorMaskCast, regenerate one to ensure type correctness.\n+    res = new VectorMaskCastNode(phase->transform(res), vect_type());\n+  }\n+  return res;\n+}\n+\n@@ -2284,0 +2377,5 @@\n+\n+  Node* res = Ideal_XorV_VectorMaskCmp(phase, can_reshape);\n+  if (res != nullptr) {\n+    return res;\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -1016,0 +1016,1 @@\n+  Node* Ideal_XorV_VectorMaskCmp(PhaseGVN* phase, bool can_reshape);\n@@ -1679,0 +1680,1 @@\n+  bool predicate_can_be_negated();\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -532,1 +532,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n+  InstanceKlass* k = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(clazz));\n@@ -3020,1 +3020,1 @@\n-  if (Atomic::cmpxchg(&directBufferSupportInitializeStarted, 0, 1) == 0) {\n+  if (AtomicAccess::cmpxchg(&directBufferSupportInitializeStarted, 0, 1) == 0) {\n@@ -3490,1 +3490,1 @@\n-    Atomic::store(a++, *b++);\n+    AtomicAccess::store(a++, *b++);\n@@ -3606,1 +3606,1 @@\n-  \/\/ We're about to use Atomic::xchg for synchronization.  Some Zero\n+  \/\/ We're about to use AtomicAccess::xchg for synchronization.  Some Zero\n@@ -3613,1 +3613,1 @@\n-    jint b = Atomic::xchg(&a, (jint) 0xdeadbeef);\n+    jint b = AtomicAccess::xchg(&a, (jint) 0xdeadbeef);\n@@ -3615,3 +3615,3 @@\n-    void *d = Atomic::xchg(&c, &b);\n-    assert(a == (jint) 0xdeadbeef && b == (jint) 0xcafebabe, \"Atomic::xchg() works\");\n-    assert(c == &b && d == &a, \"Atomic::xchg() works\");\n+    void *d = AtomicAccess::xchg(&c, &b);\n+    assert(a == (jint) 0xdeadbeef && b == (jint) 0xcafebabe, \"AtomicAccess::xchg() works\");\n+    assert(c == &b && d == &a, \"AtomicAccess::xchg() works\");\n@@ -3628,1 +3628,1 @@\n-  \/\/ We use Atomic::xchg rather than Atomic::add\/dec since on some platforms\n+  \/\/ We use AtomicAccess::xchg rather than AtomicAccess::add\/dec since on some platforms\n@@ -3630,2 +3630,2 @@\n-  \/\/ on a multiprocessor Atomic::xchg does not have this problem.\n-  if (Atomic::xchg(&vm_created, IN_PROGRESS) != NOT_CREATED) {\n+  \/\/ on a multiprocessor AtomicAccess::xchg does not have this problem.\n+  if (AtomicAccess::xchg(&vm_created, IN_PROGRESS) != NOT_CREATED) {\n@@ -3640,1 +3640,1 @@\n-  if (Atomic::xchg(&safe_to_recreate_vm, 0) == 0) {\n+  if (AtomicAccess::xchg(&safe_to_recreate_vm, 0) == 0) {\n@@ -3664,1 +3664,1 @@\n-    Atomic::release_store(&vm_created, COMPLETE);\n+    AtomicAccess::release_store(&vm_created, COMPLETE);\n@@ -3730,1 +3730,1 @@\n-    Atomic::release_store(&vm_created, NOT_CREATED);\n+    AtomicAccess::release_store(&vm_created, NOT_CREATED);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1019,8 +1019,3 @@\n-    oop from_mirror = JNIHandles::resolve_non_null(from);\n-    Klass* from_class = java_lang_Class::as_Klass(from_mirror);\n-    const char * from_name = from_class->external_name();\n-\n-    oop mirror = JNIHandles::resolve_non_null(result);\n-    Klass* to_class = java_lang_Class::as_Klass(mirror);\n-    const char * to = to_class->external_name();\n-    log_debug(class, resolve)(\"%s %s (verification)\", from_name, to);\n+    const char* from_name = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(from))->external_name();\n+    const char* to_name = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result))->external_name();\n+    log_debug(class, resolve)(\"%s %s (verification)\", from_name, to_name);\n@@ -1097,2 +1092,2 @@\n-  Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));\n-  \/\/ Lookup class must be a non-null instance\n+  InstanceKlass* lookup_k = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(lookup));\n+  \/\/ Lookup class must not be a primitive class (whose mirror has a null Klass*)\n@@ -1100,0 +1095,1 @@\n+    \/\/ The error message is wrong. We come here only if lookup is a primitive class\n@@ -1102,1 +1098,0 @@\n-  assert(lookup_k->is_instance_klass(), \"Lookup class must be an instance klass\");\n@@ -1113,1 +1108,1 @@\n-    host_class = InstanceKlass::cast(lookup_k)->nest_host(CHECK_NULL);\n+    host_class = lookup_k->nest_host(CHECK_NULL);\n@@ -1444,1 +1439,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n+  InstanceKlass* k = java_lang_Class::as_InstanceKlass(ofMirror);\n@@ -1583,1 +1578,0 @@\n-  Klass* k    = java_lang_Class::as_Klass(mirror);\n@@ -1587,1 +1581,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(mirror);\n@@ -1623,1 +1617,1 @@\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(mirror);\n@@ -1625,1 +1619,1 @@\n-  Method* m = InstanceKlass::cast(k)->method_with_idnum(slot);\n+  Method* m = ik->method_with_idnum(slot);\n@@ -1749,1 +1743,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n+  InstanceKlass* k = java_lang_Class::as_InstanceKlass(ofMirror);\n@@ -1806,3 +1800,1 @@\n-  Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));\n-  assert(c->is_instance_klass(), \"must be\");\n-  InstanceKlass* ik = InstanceKlass::cast(c);\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(ofClass));\n@@ -1850,1 +1842,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n+  InstanceKlass* k = java_lang_Class::as_InstanceKlass(ofMirror);\n@@ -1930,7 +1922,3 @@\n-  Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));\n-  assert(c->is_instance_klass(), \"must be\");\n-  InstanceKlass* ck = InstanceKlass::cast(c);\n-  Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));\n-  assert(m->is_instance_klass(), \"must be\");\n-  InstanceKlass* mk = InstanceKlass::cast(m);\n-  return ck->has_nestmate_access_to(mk, THREAD);\n+  InstanceKlass* c = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(current));\n+  InstanceKlass* m = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(member));\n+  return c->has_nestmate_access_to(m, THREAD);\n@@ -1943,4 +1931,2 @@\n-  Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));\n-  assert(c->is_instance_klass(), \"must be\");\n-  InstanceKlass* ck = InstanceKlass::cast(c);\n-  InstanceKlass* host = ck->nest_host(THREAD);\n+  InstanceKlass* c = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(current));\n+  InstanceKlass* host = c->nest_host(THREAD);\n@@ -1956,4 +1942,2 @@\n-  Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));\n-  assert(c->is_instance_klass(), \"must be\");\n-  InstanceKlass* ck = InstanceKlass::cast(c);\n-  InstanceKlass* host = ck->nest_host(THREAD);\n+  InstanceKlass* c = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(current));\n+  InstanceKlass* host = c->nest_host(THREAD);\n@@ -1962,1 +1946,1 @@\n-                              ck->external_name(), host->external_name());\n+                              c->external_name(), host->external_name());\n@@ -2025,1 +2009,1 @@\n-      assert(host == ck || ck->is_hidden(), \"must be singleton nest or dynamic nestmate\");\n+      assert(host == c || c->is_hidden(), \"must be singleton nest or dynamic nestmate\");\n@@ -2036,3 +2020,2 @@\n-  Klass* c = java_lang_Class::as_Klass(mirror);\n-  assert(c->is_instance_klass(), \"must be\");\n-  InstanceKlass* ik = InstanceKlass::cast(c);\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(mirror);\n+\n@@ -3565,2 +3548,1 @@\n-  Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));\n-  InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);\n+  InstanceKlass* caller_ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(caller));\n@@ -3573,2 +3555,1 @@\n-  Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));\n-  InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);\n+  InstanceKlass* lambda_ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(lambdaProxyClass));\n@@ -3614,2 +3595,1 @@\n-  Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));\n-  InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);\n+  InstanceKlass* caller_ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(caller));\n@@ -4012,5 +3992,1 @@\n-  assert(!java_lang_Class::as_Klass(mirror)->is_array_klass(), \"unexpected array class\");\n-\n-  Klass* c = java_lang_Class::as_Klass(mirror);\n-  assert(c->is_instance_klass(), \"must be\");\n-  InstanceKlass* ik = InstanceKlass::cast(c);\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(mirror);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":30,"deletions":54,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -86,1 +86,1 @@\n-  return Atomic::load_acquire(&_next);\n+  return AtomicAccess::load_acquire(&_next);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -105,1 +105,1 @@\n-    JvmtiAgent* next = Atomic::load(tail_ptr);\n+    JvmtiAgent* next = AtomicAccess::load(tail_ptr);\n@@ -108,1 +108,1 @@\n-      if (Atomic::cmpxchg(tail_ptr, (JvmtiAgent*)nullptr, agent) != nullptr) {\n+      if (AtomicAccess::cmpxchg(tail_ptr, (JvmtiAgent*)nullptr, agent) != nullptr) {\n@@ -138,1 +138,1 @@\n-  return Atomic::load_acquire(&_head);\n+  return AtomicAccess::load_acquire(&_head);\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -71,1 +72,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -2840,1 +2840,1 @@\n-  FilteredJavaFieldStream flds(ik);\n+  JavaFieldStream flds(ik);\n@@ -2842,1 +2842,1 @@\n-  int result_count = flds.field_count();\n+  int result_count = ik->java_fields_count();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -331,1 +331,1 @@\n-    return Atomic::load_acquire(&_tag_map);\n+    return AtomicAccess::load_acquire(&_tag_map);\n@@ -335,1 +335,1 @@\n-    Atomic::release_store(&_tag_map, tag_map);\n+    AtomicAccess::release_store(&_tag_map, tag_map);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -303,1 +303,1 @@\n-    if (!Atomic::replace_if_null(&_jvmti_breakpoints, breakpoints)) {\n+    if (!AtomicAccess::replace_if_null(&_jvmti_breakpoints, breakpoints)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -125,1 +125,1 @@\n-    if (Atomic::replace_if_null(&_owner, self)) {\n+    if (AtomicAccess::replace_if_null(&_owner, self)) {\n@@ -140,1 +140,1 @@\n-    if (_owner == nullptr && Atomic::replace_if_null(&_owner, self)) {\n+    if (_owner == nullptr && AtomicAccess::replace_if_null(&_owner, self)) {\n@@ -157,1 +157,1 @@\n-  Atomic::release_store(&_owner, (Thread*)nullptr);\n+  AtomicAccess::release_store(&_owner, (Thread*)nullptr);\n@@ -327,1 +327,1 @@\n-  \/\/ TODO Atomic::load on _owner field\n+  \/\/ TODO AtomicAccess::load on _owner field\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -4589,1 +4589,1 @@\n-    u8 result = Atomic::cmpxchg(&_id_counter, id, next_id);\n+    u8 result = AtomicAccess::cmpxchg(&_id_counter, id, next_id);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/fieldStreams.inline.hpp\"\n@@ -61,1 +62,0 @@\n-#include \"runtime\/reflectionUtils.hpp\"\n@@ -675,2 +675,2 @@\n-    FilteredJavaFieldStream fld(interfaces->at(i));\n-    count += fld.field_count();\n+    count += interfaces->at(i)->java_fields_count();\n+\n@@ -698,2 +698,1 @@\n-    FilteredJavaFieldStream super_fld(super_klass);\n-    index += super_fld.field_count();\n+    index += super_klass->java_fields_count();\n@@ -702,1 +701,1 @@\n-  for (FilteredJavaFieldStream fld(ik); !fld.done(); fld.next(), index++) {\n+  for (JavaFieldStream fld(ik); !fld.done(); fld.next(), index++) {\n@@ -725,2 +724,1 @@\n-    FilteredJavaFieldStream fld(klass);\n-    total_field_number += fld.field_count();\n+    total_field_number += klass->java_fields_count();\n@@ -730,2 +728,2 @@\n-    FilteredJavaFieldStream fld(klass);\n-    int start_index = total_field_number - fld.field_count();\n+    JavaFieldStream fld(klass);\n+    int start_index = total_field_number - klass->java_fields_count();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  _debuggable           = true;\n@@ -310,1 +309,1 @@\n-      Atomic::store(&_sync_protocol_enabled_permanently, true);\n+      AtomicAccess::store(&_sync_protocol_enabled_permanently, true);\n@@ -350,1 +349,1 @@\n-  Atomic::inc(&_VTMS_transition_disable_for_one_count);\n+  AtomicAccess::inc(&_VTMS_transition_disable_for_one_count);\n@@ -380,1 +379,1 @@\n-    Atomic::inc(&_VTMS_transition_disable_for_all_count);\n+    AtomicAccess::inc(&_VTMS_transition_disable_for_all_count);\n@@ -418,1 +417,1 @@\n-  Atomic::dec(&_VTMS_transition_disable_for_one_count);\n+  AtomicAccess::dec(&_VTMS_transition_disable_for_one_count);\n@@ -438,1 +437,1 @@\n-    Atomic::dec(&_VTMS_transition_disable_for_all_count);\n+    AtomicAccess::dec(&_VTMS_transition_disable_for_all_count);\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -104,4 +104,4 @@\n-  static void inc_sync_protocol_enabled_count()      { Atomic::inc(&_sync_protocol_enabled_count); }\n-  static void dec_sync_protocol_enabled_count()      { Atomic::dec(&_sync_protocol_enabled_count); }\n-  static int  sync_protocol_enabled_count()          { return Atomic::load(&_sync_protocol_enabled_count); }\n-  static bool sync_protocol_enabled_permanently()    { return Atomic::load(&_sync_protocol_enabled_permanently); }\n+  static void inc_sync_protocol_enabled_count()      { AtomicAccess::inc(&_sync_protocol_enabled_count); }\n+  static void dec_sync_protocol_enabled_count()      { AtomicAccess::dec(&_sync_protocol_enabled_count); }\n+  static int  sync_protocol_enabled_count()          { return AtomicAccess::load(&_sync_protocol_enabled_count); }\n+  static bool sync_protocol_enabled_permanently()    { return AtomicAccess::load(&_sync_protocol_enabled_permanently); }\n@@ -447,9 +447,0 @@\n-  \/\/ Todo: get rid of this!\n- private:\n-  bool _debuggable;\n- public:\n-  \/\/ Should the thread be enumerated by jvmtiInternal::GetAllThreads?\n-  bool is_debuggable()                 { return _debuggable; }\n-  \/\/ If a thread cannot be suspended (has no valid last_java_frame) then it gets marked !debuggable\n-  void set_debuggable(bool debuggable) { _debuggable = debuggable; }\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -914,1 +914,1 @@\n-      InstanceKlass* defc = InstanceKlass::cast(java_lang_Class::as_Klass(clazz));\n+      InstanceKlass* defc = java_lang_Class::as_InstanceKlass(clazz);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -218,1 +218,1 @@\n-  Atomic::inc(&_items_count);\n+  AtomicAccess::inc(&_items_count);\n@@ -222,1 +222,1 @@\n-  Atomic::dec(&_items_count);\n+  AtomicAccess::dec(&_items_count);\n@@ -261,1 +261,1 @@\n-  Atomic::store(&_has_work, true);\n+  AtomicAccess::store(&_has_work, true);\n@@ -266,1 +266,1 @@\n-  return Atomic::load_acquire(&_has_work);\n+  return AtomicAccess::load_acquire(&_has_work);\n@@ -278,1 +278,1 @@\n-  Atomic::release_store(&_has_work, false);\n+  AtomicAccess::release_store(&_has_work, false);\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -757,1 +757,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));\n+  InstanceKlass* k = java_lang_Class::as_InstanceKlass(JNIHandles::resolve_non_null(clazz));\n@@ -1067,1 +1067,1 @@\n-  return Atomic::cmpxchg(addr, e, x);\n+  return AtomicAccess::cmpxchg(addr, e, x);\n@@ -1073,1 +1073,1 @@\n-  return Atomic::cmpxchg(addr, e, x);\n+  return AtomicAccess::cmpxchg(addr, e, x);\n@@ -1088,1 +1088,1 @@\n-  return Atomic::cmpxchg(addr, e, x) == e;\n+  return AtomicAccess::cmpxchg(addr, e, x) == e;\n@@ -1094,1 +1094,1 @@\n-  return Atomic::cmpxchg(addr, e, x) == e;\n+  return AtomicAccess::cmpxchg(addr, e, x) == e;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -595,0 +595,19 @@\n+    case VECTOR_OP_TAN:   \/\/ fall-through\n+    case VECTOR_OP_TANH:  \/\/ fall-through\n+    case VECTOR_OP_SIN:   \/\/ fall-through\n+    case VECTOR_OP_SINH:  \/\/ fall-through\n+    case VECTOR_OP_COS:   \/\/ fall-through\n+    case VECTOR_OP_COSH:  \/\/ fall-through\n+    case VECTOR_OP_ASIN:  \/\/ fall-through\n+    case VECTOR_OP_ACOS:  \/\/ fall-through\n+    case VECTOR_OP_ATAN:  \/\/ fall-through\n+    case VECTOR_OP_ATAN2: \/\/ fall-through\n+    case VECTOR_OP_CBRT:  \/\/ fall-through\n+    case VECTOR_OP_LOG:   \/\/ fall-through\n+    case VECTOR_OP_LOG10: \/\/ fall-through\n+    case VECTOR_OP_LOG1P: \/\/ fall-through\n+    case VECTOR_OP_POW:   \/\/ fall-through\n+    case VECTOR_OP_EXP:   \/\/ fall-through\n+    case VECTOR_OP_EXPM1: \/\/ fall-through\n+    case VECTOR_OP_HYPOT: return 0; \/\/ not supported; should be handled in Java code\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -104,0 +104,19 @@\n+    VECTOR_OP_TAN   = 101,\n+    VECTOR_OP_TANH  = 102,\n+    VECTOR_OP_SIN   = 103,\n+    VECTOR_OP_SINH  = 104,\n+    VECTOR_OP_COS   = 105,\n+    VECTOR_OP_COSH  = 106,\n+    VECTOR_OP_ASIN  = 107,\n+    VECTOR_OP_ACOS  = 108,\n+    VECTOR_OP_ATAN  = 109,\n+    VECTOR_OP_ATAN2 = 110,\n+    VECTOR_OP_CBRT  = 111,\n+    VECTOR_OP_LOG   = 112,\n+    VECTOR_OP_LOG10 = 113,\n+    VECTOR_OP_LOG1P = 114,\n+    VECTOR_OP_POW   = 115,\n+    VECTOR_OP_EXP   = 116,\n+    VECTOR_OP_EXPM1 = 117,\n+    VECTOR_OP_HYPOT = 118,\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1163,1 +1163,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -1508,1 +1508,0 @@\n-  Universe::heap()->soft_ref_policy()->set_should_clear_all_soft_refs(true);\n@@ -1943,1 +1942,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -1948,1 +1947,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -2057,1 +2056,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -2066,1 +2065,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -2075,1 +2074,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -2084,1 +2083,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -2093,1 +2092,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -2102,1 +2101,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(klass));\n@@ -2414,1 +2413,1 @@\n-      Atomic::inc(&_num_threads_completed);\n+      AtomicAccess::inc(&_num_threads_completed);\n@@ -2481,1 +2480,1 @@\n-    while (Atomic::cmpxchg(&_emulated_lock, 0, 1) != 0) {}\n+    while (AtomicAccess::cmpxchg(&_emulated_lock, 0, 1) != 0) {}\n@@ -2488,1 +2487,1 @@\n-  Atomic::store(&_emulated_lock, 0);\n+  AtomicAccess::store(&_emulated_lock, 0);\n@@ -2496,4 +2495,2 @@\n-  \/\/Get the class of our object\n-  Klass* arg_klass = object->klass();\n-  \/\/Turn it into an instance-klass\n-  InstanceKlass* ik = InstanceKlass::cast(arg_klass);\n+  \/\/Only non-array oops have fields. Don't call this function on arrays!\n+  InstanceKlass* ik = InstanceKlass::cast(object->klass());\n@@ -3181,1 +3178,1 @@\n-      InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(wbclass)));\n+      InstanceKlass* ik = java_lang_Class::as_InstanceKlass(JNIHandles::resolve(wbclass));\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,1235 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_ATOMIC_HPP\n-#define SHARE_RUNTIME_ATOMIC_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/enableIf.hpp\"\n-#include \"metaprogramming\/primitiveConversions.hpp\"\n-#include \"runtime\/orderAccess.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/bytes.hpp\"\n-#include \"utilities\/checkedCast.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#include <type_traits>\n-\n-enum atomic_memory_order {\n-  \/\/ The modes that align with C++11 are intended to\n-  \/\/ follow the same semantics.\n-  memory_order_relaxed = 0,\n-  memory_order_acquire = 2,\n-  memory_order_release = 3,\n-  memory_order_acq_rel = 4,\n-  memory_order_seq_cst = 5,\n-  \/\/ Strong two-way memory barrier.\n-  memory_order_conservative = 8\n-};\n-\n-enum ScopedFenceType {\n-    X_ACQUIRE\n-  , RELEASE_X\n-  , RELEASE_X_FENCE\n-};\n-\n-class Atomic : AllStatic {\n-public:\n-  \/\/ Atomic operations on int64 types are required to be available on\n-  \/\/ all platforms. At a minimum a 64-bit cmpxchg must be available\n-  \/\/ from which other atomic operations can be constructed if needed.\n-  \/\/ The legacy `Abstract_VMVersion::supports_cx8()` function used to\n-  \/\/ indicate if this support existed, allowing for alternative lock-\n-  \/\/ based mechanism to be used. But today this function is required\n-  \/\/ to return true and in the future will be removed entirely.\n-\n-  \/\/ The memory operations that are mentioned with each of the atomic\n-  \/\/ function families come from src\/share\/vm\/runtime\/orderAccess.hpp,\n-  \/\/ e.g., <fence> is described in that file and is implemented by the\n-  \/\/ OrderAccess::fence() function. See that file for the gory details\n-  \/\/ on the Memory Access Ordering Model.\n-\n-  \/\/ All of the atomic operations that imply a read-modify-write action\n-  \/\/ guarantee a two-way memory barrier across that operation. Historically\n-  \/\/ these semantics reflect the strength of atomic operations that are\n-  \/\/ provided on SPARC\/X86. We assume that strength is necessary unless\n-  \/\/ we can prove that a weaker form is sufficiently safe.\n-\n-  \/\/ Atomically store to a location\n-  \/\/ The type T must be either a pointer type convertible to or equal\n-  \/\/ to D, an integral\/enum type equal to D, or a type equal to D that\n-  \/\/ is primitive convertible using PrimitiveConversions.\n-  template<typename D, typename T>\n-  inline static void store(volatile D* dest, T store_value);\n-\n-  template <typename D, typename T>\n-  inline static void release_store(volatile D* dest, T store_value);\n-\n-  template <typename D, typename T>\n-  inline static void release_store_fence(volatile D* dest, T store_value);\n-\n-  \/\/ Atomically load from a location\n-  \/\/ The type T must be either a pointer type, an integral\/enum type,\n-  \/\/ or a type that is primitive convertible using PrimitiveConversions.\n-  template<typename T>\n-  inline static T load(const volatile T* dest);\n-\n-  template <typename T>\n-  inline static T load_acquire(const volatile T* dest);\n-\n-  \/\/ Atomically add to a location. *add*() provide:\n-  \/\/ <fence> add-value-to-dest <membar StoreLoad|StoreStore>\n-\n-  \/\/ Returns updated value.\n-  template<typename D, typename I>\n-  inline static D add(D volatile* dest, I add_value,\n-                      atomic_memory_order order = memory_order_conservative);\n-\n-  \/\/ Returns previous value.\n-  template<typename D, typename I>\n-  inline static D fetch_then_add(D volatile* dest, I add_value,\n-                                 atomic_memory_order order = memory_order_conservative);\n-\n-  template<typename D, typename I>\n-  inline static D sub(D volatile* dest, I sub_value,\n-                      atomic_memory_order order = memory_order_conservative);\n-\n-  \/\/ Atomically increment location. inc() provide:\n-  \/\/ <fence> increment-dest <membar StoreLoad|StoreStore>\n-  \/\/ The type D may be either a pointer type, or an integral\n-  \/\/ type. If it is a pointer type, then the increment is\n-  \/\/ scaled to the size of the type pointed to by the pointer.\n-  template<typename D>\n-  inline static void inc(D volatile* dest,\n-                         atomic_memory_order order = memory_order_conservative);\n-\n-  \/\/ Atomically decrement a location. dec() provide:\n-  \/\/ <fence> decrement-dest <membar StoreLoad|StoreStore>\n-  \/\/ The type D may be either a pointer type, or an integral\n-  \/\/ type. If it is a pointer type, then the decrement is\n-  \/\/ scaled to the size of the type pointed to by the pointer.\n-  template<typename D>\n-  inline static void dec(D volatile* dest,\n-                         atomic_memory_order order = memory_order_conservative);\n-\n-  \/\/ Performs atomic exchange of *dest with exchange_value. Returns old\n-  \/\/ prior value of *dest. xchg*() provide:\n-  \/\/ <fence> exchange-value-with-dest <membar StoreLoad|StoreStore>\n-  \/\/ The type T must be either a pointer type convertible to or equal\n-  \/\/ to D, an integral\/enum type equal to D, or a type equal to D that\n-  \/\/ is primitive convertible using PrimitiveConversions.\n-  template<typename D, typename T>\n-  inline static D xchg(volatile D* dest, T exchange_value,\n-                       atomic_memory_order order = memory_order_conservative);\n-\n-  \/\/ Performs atomic compare of *dest and compare_value, and exchanges\n-  \/\/ *dest with exchange_value if the comparison succeeded. Returns prior\n-  \/\/ value of *dest. cmpxchg*() provide:\n-  \/\/ <fence> compare-and-exchange <membar StoreLoad|StoreStore>\n-\n-  template<typename D, typename U, typename T>\n-  inline static D cmpxchg(D volatile* dest,\n-                          U compare_value,\n-                          T exchange_value,\n-                          atomic_memory_order order = memory_order_conservative);\n-\n-  \/\/ Performs atomic compare of *dest and nullptr, and replaces *dest\n-  \/\/ with exchange_value if the comparison succeeded.  Returns true if\n-  \/\/ the comparison succeeded and the exchange occurred.  This is\n-  \/\/ often used as part of lazy initialization, as a lock-free\n-  \/\/ alternative to the Double-Checked Locking Pattern.\n-  template<typename D, typename T>\n-  inline static bool replace_if_null(D* volatile* dest, T* value,\n-                                     atomic_memory_order order = memory_order_conservative);\n-\n-  \/\/ Bitwise logical operations (and, or, xor)\n-  \/\/\n-  \/\/ All operations apply the corresponding operation to the value in dest and\n-  \/\/ bits, storing the result in dest. They return either the old value\n-  \/\/ (fetch_then_BITOP) or the newly updated value (BITOP_then_fetch).\n-  \/\/\n-  \/\/ Requirements:\n-  \/\/ - T is an integral type\n-  \/\/ - sizeof(T) == 1 || sizeof(T) == sizeof(int) || sizeof(T) == sizeof(void*)\n-\n-  \/\/ Performs atomic bitwise-and of *dest and bits, storing the result in\n-  \/\/ *dest.  Returns the prior value of *dest.  That is, atomically performs\n-  \/\/ this sequence of operations:\n-  \/\/ { tmp = *dest; *dest &= bits; return tmp; }\n-  template<typename T>\n-  static T fetch_then_and(volatile T* dest, T bits,\n-                          atomic_memory_order order = memory_order_conservative) {\n-    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n-    return PlatformBitops<sizeof(T)>().fetch_then_and(dest, bits, order);\n-  }\n-\n-  \/\/ Performs atomic bitwise-or of *dest and bits, storing the result in\n-  \/\/ *dest.  Returns the prior value of *dest.  That is, atomically performs\n-  \/\/ this sequence of operations:\n-  \/\/ { tmp = *dest; *dest |= bits; return tmp; }\n-  template<typename T>\n-  static T fetch_then_or(volatile T* dest, T bits,\n-                         atomic_memory_order order = memory_order_conservative) {\n-    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n-    return PlatformBitops<sizeof(T)>().fetch_then_or(dest, bits, order);\n-  }\n-\n-  \/\/ Performs atomic bitwise-xor of *dest and bits, storing the result in\n-  \/\/ *dest.  Returns the prior value of *dest.  That is, atomically performs\n-  \/\/ this sequence of operations:\n-  \/\/ { tmp = *dest; *dest ^= bits; return tmp; }\n-  template<typename T>\n-  static T fetch_then_xor(volatile T* dest, T bits,\n-                          atomic_memory_order order = memory_order_conservative) {\n-    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n-    return PlatformBitops<sizeof(T)>().fetch_then_xor(dest, bits, order);\n-  }\n-\n-  \/\/ Performs atomic bitwise-and of *dest and bits, storing the result in\n-  \/\/ *dest.  Returns the new value of *dest.  That is, atomically performs\n-  \/\/ this operation:\n-  \/\/ { return *dest &= bits; }\n-  template<typename T>\n-  static T and_then_fetch(volatile T* dest, T bits,\n-                          atomic_memory_order order = memory_order_conservative) {\n-    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n-    return PlatformBitops<sizeof(T)>().and_then_fetch(dest, bits, order);\n-  }\n-\n-  \/\/ Performs atomic bitwise-or of *dest and bits, storing the result in\n-  \/\/ *dest.  Returns the new value of *dest.  That is, atomically performs\n-  \/\/ this operation:\n-  \/\/ { return *dest |= bits; }\n-  template<typename T>\n-  static T or_then_fetch(volatile T* dest, T bits,\n-                         atomic_memory_order order = memory_order_conservative) {\n-    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n-    return PlatformBitops<sizeof(T)>().or_then_fetch(dest, bits, order);\n-  }\n-\n-  \/\/ Performs atomic bitwise-xor of *dest and bits, storing the result in\n-  \/\/ *dest.  Returns the new value of *dest.  That is, atomically performs\n-  \/\/ this operation:\n-  \/\/ { return *dest ^= bits; }\n-  template<typename T>\n-  static T xor_then_fetch(volatile T* dest, T bits,\n-                          atomic_memory_order order = memory_order_conservative) {\n-    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n-    return PlatformBitops<sizeof(T)>().xor_then_fetch(dest, bits, order);\n-  }\n-\n-private:\n-  \/\/ Test whether From is implicitly convertible to To.\n-  \/\/ From and To must be pointer types.\n-  \/\/ Note: Provides the limited subset of C++11 std::is_convertible\n-  \/\/ that is needed here.\n-  template<typename From, typename To> struct IsPointerConvertible;\n-\n-protected:\n-  \/\/ Dispatch handler for store.  Provides type-based validity\n-  \/\/ checking and limited conversions around calls to the platform-\n-  \/\/ specific implementation layer provided by PlatformOp.\n-  template<typename D, typename T, typename PlatformOp, typename Enable = void>\n-  struct StoreImpl;\n-\n-  \/\/ Platform-specific implementation of store.  Support for sizes\n-  \/\/ of 1, 2, 4, and (if different) pointer size bytes are required.\n-  \/\/ The class is a function object that must be default constructable,\n-  \/\/ with these requirements:\n-  \/\/\n-  \/\/ either:\n-  \/\/ - dest is of type D*, an integral, enum or pointer type.\n-  \/\/ - new_value are of type T, an integral, enum or pointer type D or\n-  \/\/   pointer type convertible to D.\n-  \/\/ or:\n-  \/\/ - T and D are the same and are primitive convertible using PrimitiveConversions\n-  \/\/ and either way:\n-  \/\/ - platform_store is an object of type PlatformStore<sizeof(T)>.\n-  \/\/\n-  \/\/ Then\n-  \/\/   platform_store(new_value, dest)\n-  \/\/ must be a valid expression.\n-  \/\/\n-  \/\/ The default implementation is a volatile store. If a platform\n-  \/\/ requires more for e.g. 64 bit stores, a specialization is required\n-  template<size_t byte_size> struct PlatformStore;\n-\n-  \/\/ Dispatch handler for load.  Provides type-based validity\n-  \/\/ checking and limited conversions around calls to the platform-\n-  \/\/ specific implementation layer provided by PlatformOp.\n-  template<typename T, typename PlatformOp, typename Enable = void>\n-  struct LoadImpl;\n-\n-  \/\/ Platform-specific implementation of load. Support for sizes of\n-  \/\/ 1, 2, 4 bytes and (if different) pointer size bytes are required.\n-  \/\/ The class is a function object that must be default\n-  \/\/ constructable, with these requirements:\n-  \/\/\n-  \/\/ - dest is of type T*, an integral, enum or pointer type, or\n-  \/\/   T is convertible to a primitive type using PrimitiveConversions\n-  \/\/ - platform_load is an object of type PlatformLoad<sizeof(T)>.\n-  \/\/\n-  \/\/ Then\n-  \/\/   platform_load(src)\n-  \/\/ must be a valid expression, returning a result convertible to T.\n-  \/\/\n-  \/\/ The default implementation is a volatile load. If a platform\n-  \/\/ requires more for e.g. 64 bit loads, a specialization is required\n-  template<size_t byte_size> struct PlatformLoad;\n-\n-  \/\/ Give platforms a variation point to specialize.\n-  template<size_t byte_size, ScopedFenceType type> struct PlatformOrderedStore;\n-  template<size_t byte_size, ScopedFenceType type> struct PlatformOrderedLoad;\n-\n-private:\n-  \/\/ Dispatch handler for add.  Provides type-based validity checking\n-  \/\/ and limited conversions around calls to the platform-specific\n-  \/\/ implementation layer provided by PlatformAdd.\n-  template<typename D, typename I, typename Enable = void>\n-  struct AddImpl;\n-\n-  \/\/ Platform-specific implementation of add.  Support for sizes of 4\n-  \/\/ bytes and (if different) pointer size bytes are required.  The\n-  \/\/ class must be default constructable, with these requirements:\n-  \/\/\n-  \/\/ - dest is of type D*, where D is an integral or pointer type.\n-  \/\/ - add_value is of type I, an integral type.\n-  \/\/ - sizeof(I) == sizeof(D).\n-  \/\/ - if D is an integral type, I == D.\n-  \/\/ - if D is a pointer type P*, sizeof(P) == 1.\n-  \/\/ - order is of type atomic_memory_order.\n-  \/\/ - platform_add is an object of type PlatformAdd<sizeof(D)>.\n-  \/\/\n-  \/\/ Then both\n-  \/\/   platform_add.add_then_fetch(dest, add_value, order)\n-  \/\/   platform_add.fetch_then_add(dest, add_value, order)\n-  \/\/ must be valid expressions returning a result convertible to D.\n-  \/\/\n-  \/\/ add_then_fetch atomically adds add_value to the value of dest,\n-  \/\/ returning the new value.\n-  \/\/\n-  \/\/ fetch_then_add atomically adds add_value to the value of dest,\n-  \/\/ returning the old value.\n-  \/\/\n-  \/\/ When the destination type D of the Atomic operation is a pointer type P*,\n-  \/\/ the addition must scale the add_value by sizeof(P) to add that many bytes\n-  \/\/ to the destination value.  Rather than requiring each platform deal with\n-  \/\/ this, the shared part of the implementation performs some adjustments\n-  \/\/ before and after calling the platform operation.  It ensures the pointee\n-  \/\/ type of the destination value passed to the platform operation has size\n-  \/\/ 1, casting if needed.  It also scales add_value by sizeof(P).  The result\n-  \/\/ of the platform operation is cast back to P*.  This means the platform\n-  \/\/ operation does not need to account for the scaling.  It also makes it\n-  \/\/ easy for the platform to implement one of add_then_fetch or fetch_then_add\n-  \/\/ in terms of the other (which is a common approach).\n-  \/\/\n-  \/\/ No definition is provided; all platforms must explicitly define\n-  \/\/ this class and any needed specializations.\n-  template<size_t byte_size> struct PlatformAdd;\n-\n-  \/\/ Support for platforms that implement some variants of add using a\n-  \/\/ (typically out of line) non-template helper function.  The\n-  \/\/ generic arguments passed to PlatformAdd need to be translated to\n-  \/\/ the appropriate type for the helper function, the helper function\n-  \/\/ invoked on the translated arguments, and the result translated\n-  \/\/ back.  Type is the parameter \/ return type of the helper\n-  \/\/ function.  No scaling of add_value is performed when D is a pointer\n-  \/\/ type, so this function can be used to implement the support function\n-  \/\/ required by AddAndFetch.\n-  template<typename Type, typename Fn, typename D, typename I>\n-  static D add_using_helper(Fn fn, D volatile* dest, I add_value);\n-\n-  \/\/ Dispatch handler for cmpxchg.  Provides type-based validity\n-  \/\/ checking and limited conversions around calls to the\n-  \/\/ platform-specific implementation layer provided by\n-  \/\/ PlatformCmpxchg.\n-  template<typename D, typename U, typename T, typename Enable = void>\n-  struct CmpxchgImpl;\n-\n-  \/\/ Platform-specific implementation of cmpxchg.  Support for sizes\n-  \/\/ of 1, 4, and 8 are required.  The class is a function object that\n-  \/\/ must be default constructable, with these requirements:\n-  \/\/\n-  \/\/ - dest is of type T*.\n-  \/\/ - exchange_value and compare_value are of type T.\n-  \/\/ - order is of type atomic_memory_order.\n-  \/\/ - platform_cmpxchg is an object of type PlatformCmpxchg<sizeof(T)>.\n-  \/\/\n-  \/\/ Then\n-  \/\/   platform_cmpxchg(dest, compare_value, exchange_value, order)\n-  \/\/ must be a valid expression, returning a result convertible to T.\n-  \/\/\n-  \/\/ A default definition is provided, which declares a function template\n-  \/\/   T operator()(T volatile*, T, T, atomic_memory_order) const\n-  \/\/\n-  \/\/ For each required size, a platform must either provide an\n-  \/\/ appropriate definition of that function, or must entirely\n-  \/\/ specialize the class template for that size.\n-  template<size_t byte_size> struct PlatformCmpxchg;\n-\n-  \/\/ Support for platforms that implement some variants of cmpxchg\n-  \/\/ using a (typically out of line) non-template helper function.\n-  \/\/ The generic arguments passed to PlatformCmpxchg need to be\n-  \/\/ translated to the appropriate type for the helper function, the\n-  \/\/ helper invoked on the translated arguments, and the result\n-  \/\/ translated back.  Type is the parameter \/ return type of the\n-  \/\/ helper function.\n-  template<typename Type, typename Fn, typename T>\n-  static T cmpxchg_using_helper(Fn fn,\n-                                T volatile* dest,\n-                                T compare_value,\n-                                T exchange_value);\n-\n-  \/\/ Support platforms that do not provide Read-Modify-Write atomic\n-  \/\/ accesses for 1-byte and 8-byte widths. To use, derive PlatformCmpxchg<1>,\n-  \/\/ PlatformAdd<S>, PlatformXchg<S> from these classes.\n-public: \/\/ Temporary, can't be private: C++03 11.4\/2. Fixed by C++11.\n-  struct CmpxchgByteUsingInt;\n-  template<size_t byte_size>\n-  struct XchgUsingCmpxchg;\n-  template<size_t byte_size>\n-  class AddUsingCmpxchg;\n-private:\n-\n-  \/\/ Dispatch handler for xchg.  Provides type-based validity\n-  \/\/ checking and limited conversions around calls to the\n-  \/\/ platform-specific implementation layer provided by\n-  \/\/ PlatformXchg.\n-  template<typename D, typename T, typename Enable = void>\n-  struct XchgImpl;\n-\n-  \/\/ Platform-specific implementation of xchg.  Support for sizes\n-  \/\/ of 4, and sizeof(intptr_t) are required.  The class is a function\n-  \/\/ object that must be default constructable, with these requirements:\n-  \/\/\n-  \/\/ - dest is of type T*.\n-  \/\/ - exchange_value is of type T.\n-  \/\/ - platform_xchg is an object of type PlatformXchg<sizeof(T)>.\n-  \/\/\n-  \/\/ Then\n-  \/\/   platform_xchg(dest, exchange_value)\n-  \/\/ must be a valid expression, returning a result convertible to T.\n-  \/\/\n-  \/\/ A default definition is provided, which declares a function template\n-  \/\/   T operator()(T volatile*, T, atomic_memory_order) const\n-  \/\/\n-  \/\/ For each required size, a platform must either provide an\n-  \/\/ appropriate definition of that function, or must entirely\n-  \/\/ specialize the class template for that size.\n-  template<size_t byte_size> struct PlatformXchg;\n-\n-  \/\/ Support for platforms that implement some variants of xchg\n-  \/\/ using a (typically out of line) non-template helper function.\n-  \/\/ The generic arguments passed to PlatformXchg need to be\n-  \/\/ translated to the appropriate type for the helper function, the\n-  \/\/ helper invoked on the translated arguments, and the result\n-  \/\/ translated back.  Type is the parameter \/ return type of the\n-  \/\/ helper function.\n-  template<typename Type, typename Fn, typename T>\n-  static T xchg_using_helper(Fn fn,\n-                             T volatile* dest,\n-                             T exchange_value);\n-\n-  \/\/ Platform-specific implementation of the bitops (and, or, xor).  Support\n-  \/\/ for sizes of 4 bytes and (if different) pointer size bytes are required.\n-  \/\/ The class is a function object that must be default constructable, with\n-  \/\/ these requirements:\n-  \/\/\n-  \/\/ - T is an integral type.\n-  \/\/ - dest is of type T*.\n-  \/\/ - bits is of type T.\n-  \/\/ - order is of type atomic_memory_order.\n-  \/\/ - platform_bitops is an object of type PlatformBitops<sizeof(T)>.\n-  \/\/\n-  \/\/ Then\n-  \/\/  platform_bitops.fetch_then_and(dest, bits, order)\n-  \/\/  platform_bitops.fetch_then_or(dest, bits, order)\n-  \/\/  platform_bitops.fetch_then_xor(dest, bits, order)\n-  \/\/  platform_bitops.and_then_fetch(dest, bits, order)\n-  \/\/  platform_bitops.or_then_fetch(dest, bits, order)\n-  \/\/  platform_bitops.xor_then_fetch(dest, bits, order)\n-  \/\/ must all be valid expressions, returning a result convertible to T.\n-  \/\/\n-  \/\/ A default definition is provided, which implements all of the operations\n-  \/\/ using cmpxchg.\n-  \/\/\n-  \/\/ For each required size, a platform must either use the default or\n-  \/\/ entirely specialize the class for that size by providing all of the\n-  \/\/ required operations.\n-  \/\/\n-  \/\/ The second (bool) template parameter allows platforms to provide a\n-  \/\/ partial specialization with a parameterized size, and is otherwise\n-  \/\/ unused.  The default value for that bool parameter means specializations\n-  \/\/ don't need to mention it.\n-  template<size_t size, bool = true> class PlatformBitops;\n-\n-  \/\/ Helper base classes that may be used to implement PlatformBitops.\n-  class PrefetchBitopsUsingCmpxchg;\n-  class PostfetchBitopsUsingCmpxchg;\n-  class PostfetchBitopsUsingPrefetch;\n-};\n-\n-template<typename From, typename To>\n-struct Atomic::IsPointerConvertible<From*, To*> : AllStatic {\n-  \/\/ Determine whether From* is implicitly convertible to To*, using\n-  \/\/ the \"sizeof trick\".\n-  typedef char yes;\n-  typedef char (&no)[2];\n-\n-  static yes test(To*);\n-  static no test(...);\n-  static From* test_value;\n-\n-  static const bool value = (sizeof(yes) == sizeof(test(test_value)));\n-};\n-\n-\/\/ Handle load for pointer and integral types.\n-template<typename T, typename PlatformOp>\n-struct Atomic::LoadImpl<\n-  T,\n-  PlatformOp,\n-  typename EnableIf<std::is_integral<T>::value || std::is_pointer<T>::value>::type>\n-{\n-  T operator()(T const volatile* dest) const {\n-    \/\/ Forward to the platform handler for the size of T.\n-    return PlatformOp()(dest);\n-  }\n-};\n-\n-\/\/ Handle load for types that have a translator.\n-\/\/\n-\/\/ All the involved types must be identical.\n-\/\/\n-\/\/ This translates the original call into a call on the decayed\n-\/\/ arguments, and returns the recovered result of that translated\n-\/\/ call.\n-template<typename T, typename PlatformOp>\n-struct Atomic::LoadImpl<\n-  T,\n-  PlatformOp,\n-  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n-{\n-  T operator()(T const volatile* dest) const {\n-    typedef PrimitiveConversions::Translate<T> Translator;\n-    typedef typename Translator::Decayed Decayed;\n-    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n-    Decayed result = PlatformOp()(reinterpret_cast<Decayed const volatile*>(dest));\n-    return Translator::recover(result);\n-  }\n-};\n-\n-\/\/ Default implementation of atomic load if a specific platform\n-\/\/ does not provide a specialization for a certain size class.\n-\/\/ For increased safety, the default implementation only allows\n-\/\/ load types that are pointer sized or smaller. If a platform still\n-\/\/ supports wide atomics, then it has to use specialization\n-\/\/ of Atomic::PlatformLoad for that wider size class.\n-template<size_t byte_size>\n-struct Atomic::PlatformLoad {\n-  template<typename T>\n-  T operator()(T const volatile* dest) const {\n-    STATIC_ASSERT(sizeof(T) <= sizeof(void*)); \/\/ wide atomics need specialization\n-    return *dest;\n-  }\n-};\n-\n-\/\/ Handle store for integral types.\n-\/\/\n-\/\/ All the involved types must be identical.\n-template<typename T, typename PlatformOp>\n-struct Atomic::StoreImpl<\n-  T, T,\n-  PlatformOp,\n-  typename EnableIf<std::is_integral<T>::value>::type>\n-{\n-  void operator()(T volatile* dest, T new_value) const {\n-    \/\/ Forward to the platform handler for the size of T.\n-    PlatformOp()(dest, new_value);\n-  }\n-};\n-\n-\/\/ Handle store for pointer types.\n-\/\/\n-\/\/ The new_value must be implicitly convertible to the\n-\/\/ destination's type; it must be type-correct to store the\n-\/\/ new_value in the destination.\n-template<typename D, typename T, typename PlatformOp>\n-struct Atomic::StoreImpl<\n-  D*, T*,\n-  PlatformOp,\n-  typename EnableIf<Atomic::IsPointerConvertible<T*, D*>::value>::type>\n-{\n-  void operator()(D* volatile* dest, T* new_value) const {\n-    \/\/ Allow derived to base conversion, and adding cv-qualifiers.\n-    D* value = new_value;\n-    PlatformOp()(dest, value);\n-  }\n-};\n-\n-\/\/ Handle store for types that have a translator.\n-\/\/\n-\/\/ All the involved types must be identical.\n-\/\/\n-\/\/ This translates the original call into a call on the decayed\n-\/\/ arguments.\n-template<typename T, typename PlatformOp>\n-struct Atomic::StoreImpl<\n-  T, T,\n-  PlatformOp,\n-  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n-{\n-  void operator()(T volatile* dest, T new_value) const {\n-    typedef PrimitiveConversions::Translate<T> Translator;\n-    typedef typename Translator::Decayed Decayed;\n-    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n-    PlatformOp()(reinterpret_cast<Decayed volatile*>(dest),\n-                 Translator::decay(new_value));\n-  }\n-};\n-\n-\/\/ Default implementation of atomic store if a specific platform\n-\/\/ does not provide a specialization for a certain size class.\n-\/\/ For increased safety, the default implementation only allows\n-\/\/ storing types that are pointer sized or smaller. If a platform still\n-\/\/ supports wide atomics, then it has to use specialization\n-\/\/ of Atomic::PlatformStore for that wider size class.\n-template<size_t byte_size>\n-struct Atomic::PlatformStore {\n-  template<typename T>\n-  void operator()(T volatile* dest,\n-                  T new_value) const {\n-    STATIC_ASSERT(sizeof(T) <= sizeof(void*)); \/\/ wide atomics need specialization\n-    (void)const_cast<T&>(*dest = new_value);\n-  }\n-};\n-\n-template<typename D>\n-inline void Atomic::inc(D volatile* dest, atomic_memory_order order) {\n-  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n-  using I = std::conditional_t<std::is_pointer<D>::value, ptrdiff_t, D>;\n-  Atomic::add(dest, I(1), order);\n-}\n-\n-template<typename D>\n-inline void Atomic::dec(D volatile* dest, atomic_memory_order order) {\n-  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n-  using I = std::conditional_t<std::is_pointer<D>::value, ptrdiff_t, D>;\n-  \/\/ Assumes two's complement integer representation.\n-  #pragma warning(suppress: 4146)\n-  Atomic::add(dest, I(-1), order);\n-}\n-\n-template<typename D, typename I>\n-inline D Atomic::sub(D volatile* dest, I sub_value, atomic_memory_order order) {\n-  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n-  STATIC_ASSERT(std::is_integral<I>::value);\n-  \/\/ If D is a pointer type, use [u]intptr_t as the addend type,\n-  \/\/ matching signedness of I.  Otherwise, use D as the addend type.\n-  using PI = std::conditional_t<std::is_signed<I>::value, intptr_t, uintptr_t>;\n-  using AddendType = std::conditional_t<std::is_pointer<D>::value, PI, D>;\n-  \/\/ Only allow conversions that can't change the value.\n-  STATIC_ASSERT(std::is_signed<I>::value == std::is_signed<AddendType>::value);\n-  STATIC_ASSERT(sizeof(I) <= sizeof(AddendType));\n-  AddendType addend = sub_value;\n-  \/\/ Assumes two's complement integer representation.\n-  #pragma warning(suppress: 4146) \/\/ In case AddendType is not signed.\n-  return Atomic::add(dest, -addend, order);\n-}\n-\n-\/\/ Define the class before including platform file, which may specialize\n-\/\/ the operator definition.  No generic definition of specializations\n-\/\/ of the operator template are provided, nor are there any generic\n-\/\/ specializations of the class.  The platform file is responsible for\n-\/\/ providing those.\n-template<size_t byte_size>\n-struct Atomic::PlatformCmpxchg {\n-  template<typename T>\n-  T operator()(T volatile* dest,\n-               T compare_value,\n-               T exchange_value,\n-               atomic_memory_order order) const;\n-};\n-\n-\/\/ Define the class before including platform file, which may use this\n-\/\/ as a base class, requiring it be complete.  The definition is later\n-\/\/ in this file, near the other definitions related to cmpxchg.\n-struct Atomic::CmpxchgByteUsingInt {\n-  static uint8_t get_byte_in_int(uint32_t n, uint32_t idx);\n-  static uint32_t set_byte_in_int(uint32_t n, uint8_t b, uint32_t idx);\n-  template<typename T>\n-  T operator()(T volatile* dest,\n-               T compare_value,\n-               T exchange_value,\n-               atomic_memory_order order) const;\n-};\n-\n-\/\/ Define the class before including platform file, which may use this\n-\/\/ as a base class, requiring it be complete.  The definition is later\n-\/\/ in this file, near the other definitions related to xchg.\n-template<size_t byte_size>\n-struct Atomic::XchgUsingCmpxchg {\n-  template<typename T>\n-  T operator()(T volatile* dest,\n-               T exchange_value,\n-               atomic_memory_order order) const;\n-};\n-\n-\/\/ Define the class before including platform file, which may use this\n-\/\/ as a base class, requiring it be complete.\n-template<size_t byte_size>\n-class Atomic::AddUsingCmpxchg {\n-public:\n-  template<typename D, typename I>\n-  static inline D add_then_fetch(D volatile* dest,\n-                                 I add_value,\n-                                 atomic_memory_order order) {\n-    D addend = add_value;\n-    return fetch_then_add(dest, add_value, order) + add_value;\n-  }\n-\n-  template<typename D, typename I>\n-  static inline D fetch_then_add(D volatile* dest,\n-                          I add_value,\n-                          atomic_memory_order order) {\n-    STATIC_ASSERT(byte_size == sizeof(I));\n-    STATIC_ASSERT(byte_size == sizeof(D));\n-\n-    D old_value;\n-    D new_value;\n-    do {\n-      old_value = Atomic::load(dest);\n-      new_value = old_value + add_value;\n-    } while (old_value != Atomic::cmpxchg(dest, old_value, new_value, order));\n-    return old_value;\n-  }\n-};\n-\n-\/\/ Define the class before including platform file, which may specialize\n-\/\/ the operator definition.  No generic definition of specializations\n-\/\/ of the operator template are provided, nor are there any generic\n-\/\/ specializations of the class.  The platform file is responsible for\n-\/\/ providing those.\n-template<size_t byte_size>\n-struct Atomic::PlatformXchg {\n-  template<typename T>\n-  T operator()(T volatile* dest,\n-               T exchange_value,\n-               atomic_memory_order order) const;\n-};\n-\n-\/\/ Implement fetch_then_bitop operations using a CAS loop.\n-class Atomic::PrefetchBitopsUsingCmpxchg {\n-  template<typename T, typename Op>\n-  T bitop(T volatile* dest, atomic_memory_order order, Op operation) const {\n-    T old_value;\n-    T new_value;\n-    T fetched_value = Atomic::load(dest);\n-    do {\n-      old_value = fetched_value;\n-      new_value = operation(old_value);\n-      fetched_value = Atomic::cmpxchg(dest, old_value, new_value, order);\n-    } while (old_value != fetched_value);\n-    return fetched_value;\n-  }\n-\n-public:\n-  template<typename T>\n-  T fetch_then_and(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bitop(dest, order, [&](T value) -> T { return value & bits; });\n-  }\n-\n-  template<typename T>\n-  T fetch_then_or(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bitop(dest, order, [&](T value) -> T { return value | bits; });\n-  }\n-\n-  template<typename T>\n-  T fetch_then_xor(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bitop(dest, order, [&](T value) -> T { return value ^ bits; });\n-  }\n-};\n-\n-\/\/ Implement bitop_then_fetch operations using a CAS loop.\n-class Atomic::PostfetchBitopsUsingCmpxchg {\n-  template<typename T, typename Op>\n-  T bitop(T volatile* dest, atomic_memory_order order, Op operation) const {\n-    T old_value;\n-    T new_value;\n-    T fetched_value = Atomic::load(dest);\n-    do {\n-      old_value = fetched_value;\n-      new_value = operation(old_value);\n-      fetched_value = Atomic::cmpxchg(dest, old_value, new_value, order);\n-    } while (old_value != fetched_value);\n-    return new_value;\n-  }\n-\n-public:\n-  template<typename T>\n-  T and_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bitop(dest, order, [&](T value) -> T { return value & bits; });\n-  }\n-\n-  template<typename T>\n-  T or_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bitop(dest, order, [&](T value) -> T { return value | bits; });\n-  }\n-\n-  template<typename T>\n-  T xor_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bitop(dest, order, [&](T value) -> T { return value ^ bits; });\n-  }\n-};\n-\n-\/\/ Implement bitop_then_fetch operations by calling fetch_then_bitop and\n-\/\/ applying the operation to the result and the bits argument.\n-class Atomic::PostfetchBitopsUsingPrefetch {\n-public:\n-  template<typename T>\n-  T and_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bits & Atomic::fetch_then_and(dest, bits, order);\n-  }\n-\n-  template<typename T>\n-  T or_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bits | Atomic::fetch_then_or(dest, bits, order);\n-  }\n-\n-  template<typename T>\n-  T xor_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n-    return bits ^ Atomic::fetch_then_xor(dest, bits, order);\n-  }\n-};\n-\n-\/\/ The default definition uses cmpxchg.  Platforms can override by defining a\n-\/\/ partial specialization providing size, either as a template parameter or as\n-\/\/ a specific value.\n-template<size_t size, bool>\n-class Atomic::PlatformBitops\n-  : public PrefetchBitopsUsingCmpxchg,\n-    public PostfetchBitopsUsingCmpxchg\n-{};\n-\n-template <ScopedFenceType T>\n-class ScopedFenceGeneral: public StackObj {\n- public:\n-  void prefix() {}\n-  void postfix() {}\n-};\n-\n-\/\/ The following methods can be specialized using simple template specialization\n-\/\/ in the platform specific files for optimization purposes. Otherwise the\n-\/\/ generalized variant is used.\n-\n-template<> inline void ScopedFenceGeneral<X_ACQUIRE>::postfix()       { OrderAccess::acquire(); }\n-template<> inline void ScopedFenceGeneral<RELEASE_X>::prefix()        { OrderAccess::release(); }\n-template<> inline void ScopedFenceGeneral<RELEASE_X_FENCE>::prefix()  { OrderAccess::release(); }\n-template<> inline void ScopedFenceGeneral<RELEASE_X_FENCE>::postfix() { OrderAccess::fence();   }\n-\n-template <ScopedFenceType T>\n-class ScopedFence : public ScopedFenceGeneral<T> {\n-  void *const _field;\n- public:\n-  ScopedFence(void *const field) : _field(field) { prefix(); }\n-  ~ScopedFence() { postfix(); }\n-  void prefix() { ScopedFenceGeneral<T>::prefix(); }\n-  void postfix() { ScopedFenceGeneral<T>::postfix(); }\n-};\n-\n-\/\/ platform specific in-line definitions - must come before shared definitions\n-\n-#include OS_CPU_HEADER(atomic)\n-\n-\/\/ shared in-line definitions\n-\n-\/\/ size_t casts...\n-#if (SIZE_MAX != UINTPTR_MAX)\n-#error size_t is not WORD_SIZE, interesting platform, but missing implementation here\n-#endif\n-\n-template<typename T>\n-inline T Atomic::load(const volatile T* dest) {\n-  return LoadImpl<T, PlatformLoad<sizeof(T)> >()(dest);\n-}\n-\n-template<size_t byte_size, ScopedFenceType type>\n-struct Atomic::PlatformOrderedLoad {\n-  template <typename T>\n-  T operator()(const volatile T* p) const {\n-    ScopedFence<type> f((void*)p);\n-    return Atomic::load(p);\n-  }\n-};\n-\n-template <typename T>\n-inline T Atomic::load_acquire(const volatile T* p) {\n-  return LoadImpl<T, PlatformOrderedLoad<sizeof(T), X_ACQUIRE> >()(p);\n-}\n-\n-template<typename D, typename T>\n-inline void Atomic::store(volatile D* dest, T store_value) {\n-  StoreImpl<D, T, PlatformStore<sizeof(D)> >()(dest, store_value);\n-}\n-\n-template<size_t byte_size, ScopedFenceType type>\n-struct Atomic::PlatformOrderedStore {\n-  template <typename T>\n-  void operator()(volatile T* p, T v) const {\n-    ScopedFence<type> f((void*)p);\n-    Atomic::store(p, v);\n-  }\n-};\n-\n-template <typename D, typename T>\n-inline void Atomic::release_store(volatile D* p, T v) {\n-  StoreImpl<D, T, PlatformOrderedStore<sizeof(D), RELEASE_X> >()(p, v);\n-}\n-\n-template <typename D, typename T>\n-inline void Atomic::release_store_fence(volatile D* p, T v) {\n-  StoreImpl<D, T, PlatformOrderedStore<sizeof(D), RELEASE_X_FENCE> >()(p, v);\n-}\n-\n-template<typename D, typename I>\n-inline D Atomic::add(D volatile* dest, I add_value,\n-                     atomic_memory_order order) {\n-  return AddImpl<D, I>::add_then_fetch(dest, add_value, order);\n-}\n-\n-template<typename D, typename I>\n-inline D Atomic::fetch_then_add(D volatile* dest, I add_value,\n-                                atomic_memory_order order) {\n-  return AddImpl<D, I>::fetch_then_add(dest, add_value, order);\n-}\n-\n-template<typename D, typename I>\n-struct Atomic::AddImpl<\n-  D, I,\n-  typename EnableIf<std::is_integral<I>::value &&\n-                    std::is_integral<D>::value &&\n-                    (sizeof(I) <= sizeof(D)) &&\n-                    (std::is_signed<I>::value == std::is_signed<D>::value)>::type>\n-{\n-  static D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) {\n-    D addend = add_value;\n-    return PlatformAdd<sizeof(D)>().add_then_fetch(dest, addend, order);\n-  }\n-  static D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) {\n-    D addend = add_value;\n-    return PlatformAdd<sizeof(D)>().fetch_then_add(dest, addend, order);\n-  }\n-};\n-\n-template<typename P, typename I>\n-struct Atomic::AddImpl<\n-  P*, I,\n-  typename EnableIf<std::is_integral<I>::value && (sizeof(I) <= sizeof(P*))>::type>\n-{\n-  STATIC_ASSERT(sizeof(intptr_t) == sizeof(P*));\n-  STATIC_ASSERT(sizeof(uintptr_t) == sizeof(P*));\n-\n-  \/\/ Type of the scaled addend.  An integral type of the same size as a\n-  \/\/ pointer, and the same signedness as I.\n-  using SI = std::conditional_t<std::is_signed<I>::value, intptr_t, uintptr_t>;\n-\n-  \/\/ Type of the unscaled destination.  A pointer type with pointee size == 1.\n-  using UP = const char*;\n-\n-  \/\/ Scale add_value by the size of the pointee.\n-  static SI scale_addend(SI add_value) {\n-    return add_value * SI(sizeof(P));\n-  }\n-\n-  \/\/ Casting between P* and UP* here intentionally uses C-style casts,\n-  \/\/ because reinterpret_cast can't cast away cv qualifiers.  Using copy_cv\n-  \/\/ would be an alternative if it existed.\n-\n-  \/\/ Unscale dest to a char* pointee for consistency with scaled addend.\n-  static UP volatile* unscale_dest(P* volatile* dest) {\n-    return (UP volatile*) dest;\n-  }\n-\n-  \/\/ Convert the unscaled char* result to a P*.\n-  static P* scale_result(UP result) {\n-    return (P*) result;\n-  }\n-\n-  static P* add_then_fetch(P* volatile* dest, I addend, atomic_memory_order order) {\n-    return scale_result(PlatformAdd<sizeof(P*)>().add_then_fetch(unscale_dest(dest),\n-                                                                scale_addend(addend),\n-                                                                order));\n-  }\n-\n-  static P* fetch_then_add(P* volatile* dest, I addend, atomic_memory_order order) {\n-    return scale_result(PlatformAdd<sizeof(P*)>().fetch_then_add(unscale_dest(dest),\n-                                                                scale_addend(addend),\n-                                                                order));\n-  }\n-};\n-\n-template<typename Type, typename Fn, typename D, typename I>\n-inline D Atomic::add_using_helper(Fn fn, D volatile* dest, I add_value) {\n-  return PrimitiveConversions::cast<D>(\n-    fn(PrimitiveConversions::cast<Type>(add_value),\n-       reinterpret_cast<Type volatile*>(dest)));\n-}\n-\n-template<typename D, typename U, typename T>\n-inline D Atomic::cmpxchg(D volatile* dest,\n-                         U compare_value,\n-                         T exchange_value,\n-                         atomic_memory_order order) {\n-  return CmpxchgImpl<D, U, T>()(dest, compare_value, exchange_value, order);\n-}\n-\n-template<typename D, typename T>\n-inline bool Atomic::replace_if_null(D* volatile* dest, T* value,\n-                                    atomic_memory_order order) {\n-  \/\/ Presently using a trivial implementation in terms of cmpxchg.\n-  \/\/ Consider adding platform support, to permit the use of compiler\n-  \/\/ intrinsics like gcc's __sync_bool_compare_and_swap.\n-  D* expected_null = nullptr;\n-  return expected_null == cmpxchg(dest, expected_null, value, order);\n-}\n-\n-\/\/ Handle cmpxchg for integral types.\n-\/\/\n-\/\/ All the involved types must be identical.\n-template<typename T>\n-struct Atomic::CmpxchgImpl<\n-  T, T, T,\n-  typename EnableIf<std::is_integral<T>::value>::type>\n-{\n-  T operator()(T volatile* dest, T compare_value, T exchange_value,\n-               atomic_memory_order order) const {\n-    \/\/ Forward to the platform handler for the size of T.\n-    return PlatformCmpxchg<sizeof(T)>()(dest,\n-                                        compare_value,\n-                                        exchange_value,\n-                                        order);\n-  }\n-};\n-\n-\/\/ Handle cmpxchg for pointer types.\n-\/\/\n-\/\/ The destination's type and the compare_value type must be the same,\n-\/\/ ignoring cv-qualifiers; we don't care about the cv-qualifiers of\n-\/\/ the compare_value.\n-\/\/\n-\/\/ The exchange_value must be implicitly convertible to the\n-\/\/ destination's type; it must be type-correct to store the\n-\/\/ exchange_value in the destination.\n-template<typename D, typename U, typename T>\n-struct Atomic::CmpxchgImpl<\n-  D*, U*, T*,\n-  typename EnableIf<Atomic::IsPointerConvertible<T*, D*>::value &&\n-                    std::is_same<std::remove_cv_t<D>,\n-                                 std::remove_cv_t<U>>::value>::type>\n-{\n-  D* operator()(D* volatile* dest, U* compare_value, T* exchange_value,\n-               atomic_memory_order order) const {\n-    \/\/ Allow derived to base conversion, and adding cv-qualifiers.\n-    D* new_value = exchange_value;\n-    \/\/ Don't care what the CV qualifiers for compare_value are,\n-    \/\/ but we need to match D* when calling platform support.\n-    D* old_value = const_cast<D*>(compare_value);\n-    return PlatformCmpxchg<sizeof(D*)>()(dest, old_value, new_value, order);\n-  }\n-};\n-\n-\/\/ Handle cmpxchg for types that have a translator.\n-\/\/\n-\/\/ All the involved types must be identical.\n-\/\/\n-\/\/ This translates the original call into a call on the decayed\n-\/\/ arguments, and returns the recovered result of that translated\n-\/\/ call.\n-template<typename T>\n-struct Atomic::CmpxchgImpl<\n-  T, T, T,\n-  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n-{\n-  T operator()(T volatile* dest, T compare_value, T exchange_value,\n-               atomic_memory_order order) const {\n-    typedef PrimitiveConversions::Translate<T> Translator;\n-    typedef typename Translator::Decayed Decayed;\n-    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n-    return Translator::recover(\n-      cmpxchg(reinterpret_cast<Decayed volatile*>(dest),\n-              Translator::decay(compare_value),\n-              Translator::decay(exchange_value),\n-              order));\n-  }\n-};\n-\n-template<typename Type, typename Fn, typename T>\n-inline T Atomic::cmpxchg_using_helper(Fn fn,\n-                                      T volatile* dest,\n-                                      T compare_value,\n-                                      T exchange_value) {\n-  STATIC_ASSERT(sizeof(Type) == sizeof(T));\n-  return PrimitiveConversions::cast<T>(\n-    fn(PrimitiveConversions::cast<Type>(exchange_value),\n-       reinterpret_cast<Type volatile*>(dest),\n-       PrimitiveConversions::cast<Type>(compare_value)));\n-}\n-\n-inline uint32_t Atomic::CmpxchgByteUsingInt::set_byte_in_int(uint32_t n,\n-                                                             uint8_t b,\n-                                                             uint32_t idx) {\n-  uint32_t bitsIdx = BitsPerByte * idx;\n-  return (n & ~(static_cast<uint32_t>(0xff) << bitsIdx))\n-          | (static_cast<uint32_t>(b) << bitsIdx);\n-}\n-\n-inline uint8_t Atomic::CmpxchgByteUsingInt::get_byte_in_int(uint32_t n,\n-                                                            uint32_t idx) {\n-  uint32_t bitsIdx = BitsPerByte * idx;\n-  return (uint8_t)(n >> bitsIdx);\n-}\n-\n-template<typename T>\n-inline T Atomic::CmpxchgByteUsingInt::operator()(T volatile* dest,\n-                                                 T compare_value,\n-                                                 T exchange_value,\n-                                                 atomic_memory_order order) const {\n-  STATIC_ASSERT(sizeof(T) == sizeof(uint8_t));\n-  uint8_t canon_exchange_value = exchange_value;\n-  uint8_t canon_compare_value = compare_value;\n-  volatile uint32_t* aligned_dest\n-    = reinterpret_cast<volatile uint32_t*>(align_down(dest, sizeof(uint32_t)));\n-  uint32_t offset = checked_cast<uint32_t>(pointer_delta(dest, aligned_dest, 1));\n-\n-  uint32_t idx = (Endian::NATIVE == Endian::BIG)\n-                   ? (sizeof(uint32_t) - 1 - offset)\n-                   : offset;\n-\n-  \/\/ current value may not be what we are looking for, so force it\n-  \/\/ to that value so the initial cmpxchg will fail if it is different\n-  uint32_t cur = set_byte_in_int(Atomic::load(aligned_dest), canon_compare_value, idx);\n-\n-  \/\/ always execute a real cmpxchg so that we get the required memory\n-  \/\/ barriers even on initial failure\n-  do {\n-    \/\/ value to swap in matches current value\n-    \/\/ except for the one byte we want to update\n-    uint32_t new_value = set_byte_in_int(cur, canon_exchange_value, idx);\n-\n-    uint32_t res = cmpxchg(aligned_dest, cur, new_value, order);\n-    if (res == cur) break;      \/\/ success\n-\n-    \/\/ at least one byte in the int changed value, so update\n-    \/\/ our view of the current int\n-    cur = res;\n-    \/\/ if our byte is still as cur we loop and try again\n-  } while (get_byte_in_int(cur, idx) == canon_compare_value);\n-\n-  return PrimitiveConversions::cast<T>(get_byte_in_int(cur, idx));\n-}\n-\n-\/\/ Handle xchg for integral types.\n-\/\/\n-\/\/ All the involved types must be identical.\n-template<typename T>\n-struct Atomic::XchgImpl<\n-  T, T,\n-  typename EnableIf<std::is_integral<T>::value>::type>\n-{\n-  T operator()(T volatile* dest, T exchange_value, atomic_memory_order order) const {\n-    \/\/ Forward to the platform handler for the size of T.\n-    return PlatformXchg<sizeof(T)>()(dest, exchange_value, order);\n-  }\n-};\n-\n-\/\/ Handle xchg for pointer types.\n-\/\/\n-\/\/ The exchange_value must be implicitly convertible to the\n-\/\/ destination's type; it must be type-correct to store the\n-\/\/ exchange_value in the destination.\n-template<typename D, typename T>\n-struct Atomic::XchgImpl<\n-  D*, T*,\n-  typename EnableIf<Atomic::IsPointerConvertible<T*, D*>::value>::type>\n-{\n-  D* operator()(D* volatile* dest, T* exchange_value, atomic_memory_order order) const {\n-    \/\/ Allow derived to base conversion, and adding cv-qualifiers.\n-    D* new_value = exchange_value;\n-    return PlatformXchg<sizeof(D*)>()(dest, new_value, order);\n-  }\n-};\n-\n-\/\/ Handle xchg for types that have a translator.\n-\/\/\n-\/\/ All the involved types must be identical.\n-\/\/\n-\/\/ This translates the original call into a call on the decayed\n-\/\/ arguments, and returns the recovered result of that translated\n-\/\/ call.\n-template<typename T>\n-struct Atomic::XchgImpl<\n-  T, T,\n-  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n-{\n-  T operator()(T volatile* dest, T exchange_value, atomic_memory_order order) const {\n-    typedef PrimitiveConversions::Translate<T> Translator;\n-    typedef typename Translator::Decayed Decayed;\n-    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n-    return Translator::recover(\n-      xchg(reinterpret_cast<Decayed volatile*>(dest),\n-           Translator::decay(exchange_value),\n-           order));\n-  }\n-};\n-\n-template<typename Type, typename Fn, typename T>\n-inline T Atomic::xchg_using_helper(Fn fn,\n-                                   T volatile* dest,\n-                                   T exchange_value) {\n-  STATIC_ASSERT(sizeof(Type) == sizeof(T));\n-  \/\/ Notice the swapped order of arguments. Change when\/if stubs are rewritten.\n-  return PrimitiveConversions::cast<T>(\n-    fn(PrimitiveConversions::cast<Type>(exchange_value),\n-       reinterpret_cast<Type volatile*>(dest)));\n-}\n-\n-template<typename D, typename T>\n-inline D Atomic::xchg(volatile D* dest, T exchange_value, atomic_memory_order order) {\n-  return XchgImpl<D, T>()(dest, exchange_value, order);\n-}\n-\n-template<size_t byte_size>\n-template<typename T>\n-inline T Atomic::XchgUsingCmpxchg<byte_size>::operator()(T volatile* dest,\n-                                             T exchange_value,\n-                                             atomic_memory_order order) const {\n-  STATIC_ASSERT(byte_size == sizeof(T));\n-\n-  T old_value;\n-  do {\n-    old_value = Atomic::load(dest);\n-  } while (old_value != Atomic::cmpxchg(dest, old_value, exchange_value, order));\n-  return old_value;\n-}\n-\n-#endif \/\/ SHARE_RUNTIME_ATOMIC_HPP\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":0,"deletions":1235,"binary":false,"changes":1235,"status":"deleted"},{"patch":"@@ -0,0 +1,1235 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_ATOMICACCESS_HPP\n+#define SHARE_RUNTIME_ATOMICACCESS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/bytes.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <type_traits>\n+\n+enum atomic_memory_order {\n+  \/\/ The modes that align with C++11 are intended to\n+  \/\/ follow the same semantics.\n+  memory_order_relaxed = 0,\n+  memory_order_acquire = 2,\n+  memory_order_release = 3,\n+  memory_order_acq_rel = 4,\n+  memory_order_seq_cst = 5,\n+  \/\/ Strong two-way memory barrier.\n+  memory_order_conservative = 8\n+};\n+\n+enum ScopedFenceType {\n+    X_ACQUIRE\n+  , RELEASE_X\n+  , RELEASE_X_FENCE\n+};\n+\n+class AtomicAccess : AllStatic {\n+public:\n+  \/\/ Atomic operations on int64 types are required to be available on\n+  \/\/ all platforms. At a minimum a 64-bit cmpxchg must be available\n+  \/\/ from which other atomic operations can be constructed if needed.\n+  \/\/ The legacy `Abstract_VMVersion::supports_cx8()` function used to\n+  \/\/ indicate if this support existed, allowing for alternative lock-\n+  \/\/ based mechanism to be used. But today this function is required\n+  \/\/ to return true and in the future will be removed entirely.\n+\n+  \/\/ The memory operations that are mentioned with each of the atomic\n+  \/\/ function families come from src\/share\/vm\/runtime\/orderAccess.hpp,\n+  \/\/ e.g., <fence> is described in that file and is implemented by the\n+  \/\/ OrderAccess::fence() function. See that file for the gory details\n+  \/\/ on the Memory Access Ordering Model.\n+\n+  \/\/ All of the atomic operations that imply a read-modify-write action\n+  \/\/ guarantee a two-way memory barrier across that operation. Historically\n+  \/\/ these semantics reflect the strength of atomic operations that are\n+  \/\/ provided on SPARC\/X86. We assume that strength is necessary unless\n+  \/\/ we can prove that a weaker form is sufficiently safe.\n+\n+  \/\/ Atomically store to a location\n+  \/\/ The type T must be either a pointer type convertible to or equal\n+  \/\/ to D, an integral\/enum type equal to D, or a type equal to D that\n+  \/\/ is primitive convertible using PrimitiveConversions.\n+  template<typename D, typename T>\n+  inline static void store(volatile D* dest, T store_value);\n+\n+  template <typename D, typename T>\n+  inline static void release_store(volatile D* dest, T store_value);\n+\n+  template <typename D, typename T>\n+  inline static void release_store_fence(volatile D* dest, T store_value);\n+\n+  \/\/ Atomically load from a location\n+  \/\/ The type T must be either a pointer type, an integral\/enum type,\n+  \/\/ or a type that is primitive convertible using PrimitiveConversions.\n+  template<typename T>\n+  inline static T load(const volatile T* dest);\n+\n+  template <typename T>\n+  inline static T load_acquire(const volatile T* dest);\n+\n+  \/\/ Atomically add to a location. *add*() provide:\n+  \/\/ <fence> add-value-to-dest <membar StoreLoad|StoreStore>\n+\n+  \/\/ Returns updated value.\n+  template<typename D, typename I>\n+  inline static D add(D volatile* dest, I add_value,\n+                      atomic_memory_order order = memory_order_conservative);\n+\n+  \/\/ Returns previous value.\n+  template<typename D, typename I>\n+  inline static D fetch_then_add(D volatile* dest, I add_value,\n+                                 atomic_memory_order order = memory_order_conservative);\n+\n+  template<typename D, typename I>\n+  inline static D sub(D volatile* dest, I sub_value,\n+                      atomic_memory_order order = memory_order_conservative);\n+\n+  \/\/ Atomically increment location. inc() provide:\n+  \/\/ <fence> increment-dest <membar StoreLoad|StoreStore>\n+  \/\/ The type D may be either a pointer type, or an integral\n+  \/\/ type. If it is a pointer type, then the increment is\n+  \/\/ scaled to the size of the type pointed to by the pointer.\n+  template<typename D>\n+  inline static void inc(D volatile* dest,\n+                         atomic_memory_order order = memory_order_conservative);\n+\n+  \/\/ Atomically decrement a location. dec() provide:\n+  \/\/ <fence> decrement-dest <membar StoreLoad|StoreStore>\n+  \/\/ The type D may be either a pointer type, or an integral\n+  \/\/ type. If it is a pointer type, then the decrement is\n+  \/\/ scaled to the size of the type pointed to by the pointer.\n+  template<typename D>\n+  inline static void dec(D volatile* dest,\n+                         atomic_memory_order order = memory_order_conservative);\n+\n+  \/\/ Performs atomic exchange of *dest with exchange_value. Returns old\n+  \/\/ prior value of *dest. xchg*() provide:\n+  \/\/ <fence> exchange-value-with-dest <membar StoreLoad|StoreStore>\n+  \/\/ The type T must be either a pointer type convertible to or equal\n+  \/\/ to D, an integral\/enum type equal to D, or a type equal to D that\n+  \/\/ is primitive convertible using PrimitiveConversions.\n+  template<typename D, typename T>\n+  inline static D xchg(volatile D* dest, T exchange_value,\n+                       atomic_memory_order order = memory_order_conservative);\n+\n+  \/\/ Performs atomic compare of *dest and compare_value, and exchanges\n+  \/\/ *dest with exchange_value if the comparison succeeded. Returns prior\n+  \/\/ value of *dest. cmpxchg*() provide:\n+  \/\/ <fence> compare-and-exchange <membar StoreLoad|StoreStore>\n+\n+  template<typename D, typename U, typename T>\n+  inline static D cmpxchg(D volatile* dest,\n+                          U compare_value,\n+                          T exchange_value,\n+                          atomic_memory_order order = memory_order_conservative);\n+\n+  \/\/ Performs atomic compare of *dest and nullptr, and replaces *dest\n+  \/\/ with exchange_value if the comparison succeeded.  Returns true if\n+  \/\/ the comparison succeeded and the exchange occurred.  This is\n+  \/\/ often used as part of lazy initialization, as a lock-free\n+  \/\/ alternative to the Double-Checked Locking Pattern.\n+  template<typename D, typename T>\n+  inline static bool replace_if_null(D* volatile* dest, T* value,\n+                                     atomic_memory_order order = memory_order_conservative);\n+\n+  \/\/ Bitwise logical operations (and, or, xor)\n+  \/\/\n+  \/\/ All operations apply the corresponding operation to the value in dest and\n+  \/\/ bits, storing the result in dest. They return either the old value\n+  \/\/ (fetch_then_BITOP) or the newly updated value (BITOP_then_fetch).\n+  \/\/\n+  \/\/ Requirements:\n+  \/\/ - T is an integral type\n+  \/\/ - sizeof(T) == 1 || sizeof(T) == sizeof(int) || sizeof(T) == sizeof(void*)\n+\n+  \/\/ Performs atomic bitwise-and of *dest and bits, storing the result in\n+  \/\/ *dest.  Returns the prior value of *dest.  That is, atomically performs\n+  \/\/ this sequence of operations:\n+  \/\/ { tmp = *dest; *dest &= bits; return tmp; }\n+  template<typename T>\n+  static T fetch_then_and(volatile T* dest, T bits,\n+                          atomic_memory_order order = memory_order_conservative) {\n+    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n+    return PlatformBitops<sizeof(T)>().fetch_then_and(dest, bits, order);\n+  }\n+\n+  \/\/ Performs atomic bitwise-or of *dest and bits, storing the result in\n+  \/\/ *dest.  Returns the prior value of *dest.  That is, atomically performs\n+  \/\/ this sequence of operations:\n+  \/\/ { tmp = *dest; *dest |= bits; return tmp; }\n+  template<typename T>\n+  static T fetch_then_or(volatile T* dest, T bits,\n+                         atomic_memory_order order = memory_order_conservative) {\n+    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n+    return PlatformBitops<sizeof(T)>().fetch_then_or(dest, bits, order);\n+  }\n+\n+  \/\/ Performs atomic bitwise-xor of *dest and bits, storing the result in\n+  \/\/ *dest.  Returns the prior value of *dest.  That is, atomically performs\n+  \/\/ this sequence of operations:\n+  \/\/ { tmp = *dest; *dest ^= bits; return tmp; }\n+  template<typename T>\n+  static T fetch_then_xor(volatile T* dest, T bits,\n+                          atomic_memory_order order = memory_order_conservative) {\n+    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n+    return PlatformBitops<sizeof(T)>().fetch_then_xor(dest, bits, order);\n+  }\n+\n+  \/\/ Performs atomic bitwise-and of *dest and bits, storing the result in\n+  \/\/ *dest.  Returns the new value of *dest.  That is, atomically performs\n+  \/\/ this operation:\n+  \/\/ { return *dest &= bits; }\n+  template<typename T>\n+  static T and_then_fetch(volatile T* dest, T bits,\n+                          atomic_memory_order order = memory_order_conservative) {\n+    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n+    return PlatformBitops<sizeof(T)>().and_then_fetch(dest, bits, order);\n+  }\n+\n+  \/\/ Performs atomic bitwise-or of *dest and bits, storing the result in\n+  \/\/ *dest.  Returns the new value of *dest.  That is, atomically performs\n+  \/\/ this operation:\n+  \/\/ { return *dest |= bits; }\n+  template<typename T>\n+  static T or_then_fetch(volatile T* dest, T bits,\n+                         atomic_memory_order order = memory_order_conservative) {\n+    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n+    return PlatformBitops<sizeof(T)>().or_then_fetch(dest, bits, order);\n+  }\n+\n+  \/\/ Performs atomic bitwise-xor of *dest and bits, storing the result in\n+  \/\/ *dest.  Returns the new value of *dest.  That is, atomically performs\n+  \/\/ this operation:\n+  \/\/ { return *dest ^= bits; }\n+  template<typename T>\n+  static T xor_then_fetch(volatile T* dest, T bits,\n+                          atomic_memory_order order = memory_order_conservative) {\n+    static_assert(std::is_integral<T>::value, \"bitop with non-integral type\");\n+    return PlatformBitops<sizeof(T)>().xor_then_fetch(dest, bits, order);\n+  }\n+\n+private:\n+  \/\/ Test whether From is implicitly convertible to To.\n+  \/\/ From and To must be pointer types.\n+  \/\/ Note: Provides the limited subset of C++11 std::is_convertible\n+  \/\/ that is needed here.\n+  template<typename From, typename To> struct IsPointerConvertible;\n+\n+protected:\n+  \/\/ Dispatch handler for store.  Provides type-based validity\n+  \/\/ checking and limited conversions around calls to the platform-\n+  \/\/ specific implementation layer provided by PlatformOp.\n+  template<typename D, typename T, typename PlatformOp, typename Enable = void>\n+  struct StoreImpl;\n+\n+  \/\/ Platform-specific implementation of store.  Support for sizes\n+  \/\/ of 1, 2, 4, and (if different) pointer size bytes are required.\n+  \/\/ The class is a function object that must be default constructable,\n+  \/\/ with these requirements:\n+  \/\/\n+  \/\/ either:\n+  \/\/ - dest is of type D*, an integral, enum or pointer type.\n+  \/\/ - new_value are of type T, an integral, enum or pointer type D or\n+  \/\/   pointer type convertible to D.\n+  \/\/ or:\n+  \/\/ - T and D are the same and are primitive convertible using PrimitiveConversions\n+  \/\/ and either way:\n+  \/\/ - platform_store is an object of type PlatformStore<sizeof(T)>.\n+  \/\/\n+  \/\/ Then\n+  \/\/   platform_store(new_value, dest)\n+  \/\/ must be a valid expression.\n+  \/\/\n+  \/\/ The default implementation is a volatile store. If a platform\n+  \/\/ requires more for e.g. 64 bit stores, a specialization is required\n+  template<size_t byte_size> struct PlatformStore;\n+\n+  \/\/ Dispatch handler for load.  Provides type-based validity\n+  \/\/ checking and limited conversions around calls to the platform-\n+  \/\/ specific implementation layer provided by PlatformOp.\n+  template<typename T, typename PlatformOp, typename Enable = void>\n+  struct LoadImpl;\n+\n+  \/\/ Platform-specific implementation of load. Support for sizes of\n+  \/\/ 1, 2, 4 bytes and (if different) pointer size bytes are required.\n+  \/\/ The class is a function object that must be default\n+  \/\/ constructable, with these requirements:\n+  \/\/\n+  \/\/ - dest is of type T*, an integral, enum or pointer type, or\n+  \/\/   T is convertible to a primitive type using PrimitiveConversions\n+  \/\/ - platform_load is an object of type PlatformLoad<sizeof(T)>.\n+  \/\/\n+  \/\/ Then\n+  \/\/   platform_load(src)\n+  \/\/ must be a valid expression, returning a result convertible to T.\n+  \/\/\n+  \/\/ The default implementation is a volatile load. If a platform\n+  \/\/ requires more for e.g. 64 bit loads, a specialization is required\n+  template<size_t byte_size> struct PlatformLoad;\n+\n+  \/\/ Give platforms a variation point to specialize.\n+  template<size_t byte_size, ScopedFenceType type> struct PlatformOrderedStore;\n+  template<size_t byte_size, ScopedFenceType type> struct PlatformOrderedLoad;\n+\n+private:\n+  \/\/ Dispatch handler for add.  Provides type-based validity checking\n+  \/\/ and limited conversions around calls to the platform-specific\n+  \/\/ implementation layer provided by PlatformAdd.\n+  template<typename D, typename I, typename Enable = void>\n+  struct AddImpl;\n+\n+  \/\/ Platform-specific implementation of add.  Support for sizes of 4\n+  \/\/ bytes and (if different) pointer size bytes are required.  The\n+  \/\/ class must be default constructable, with these requirements:\n+  \/\/\n+  \/\/ - dest is of type D*, where D is an integral or pointer type.\n+  \/\/ - add_value is of type I, an integral type.\n+  \/\/ - sizeof(I) == sizeof(D).\n+  \/\/ - if D is an integral type, I == D.\n+  \/\/ - if D is a pointer type P*, sizeof(P) == 1.\n+  \/\/ - order is of type atomic_memory_order.\n+  \/\/ - platform_add is an object of type PlatformAdd<sizeof(D)>.\n+  \/\/\n+  \/\/ Then both\n+  \/\/   platform_add.add_then_fetch(dest, add_value, order)\n+  \/\/   platform_add.fetch_then_add(dest, add_value, order)\n+  \/\/ must be valid expressions returning a result convertible to D.\n+  \/\/\n+  \/\/ add_then_fetch atomically adds add_value to the value of dest,\n+  \/\/ returning the new value.\n+  \/\/\n+  \/\/ fetch_then_add atomically adds add_value to the value of dest,\n+  \/\/ returning the old value.\n+  \/\/\n+  \/\/ When the destination type D of the Atomic operation is a pointer type P*,\n+  \/\/ the addition must scale the add_value by sizeof(P) to add that many bytes\n+  \/\/ to the destination value.  Rather than requiring each platform deal with\n+  \/\/ this, the shared part of the implementation performs some adjustments\n+  \/\/ before and after calling the platform operation.  It ensures the pointee\n+  \/\/ type of the destination value passed to the platform operation has size\n+  \/\/ 1, casting if needed.  It also scales add_value by sizeof(P).  The result\n+  \/\/ of the platform operation is cast back to P*.  This means the platform\n+  \/\/ operation does not need to account for the scaling.  It also makes it\n+  \/\/ easy for the platform to implement one of add_then_fetch or fetch_then_add\n+  \/\/ in terms of the other (which is a common approach).\n+  \/\/\n+  \/\/ No definition is provided; all platforms must explicitly define\n+  \/\/ this class and any needed specializations.\n+  template<size_t byte_size> struct PlatformAdd;\n+\n+  \/\/ Support for platforms that implement some variants of add using a\n+  \/\/ (typically out of line) non-template helper function.  The\n+  \/\/ generic arguments passed to PlatformAdd need to be translated to\n+  \/\/ the appropriate type for the helper function, the helper function\n+  \/\/ invoked on the translated arguments, and the result translated\n+  \/\/ back.  Type is the parameter \/ return type of the helper\n+  \/\/ function.  No scaling of add_value is performed when D is a pointer\n+  \/\/ type, so this function can be used to implement the support function\n+  \/\/ required by AddAndFetch.\n+  template<typename Type, typename Fn, typename D, typename I>\n+  static D add_using_helper(Fn fn, D volatile* dest, I add_value);\n+\n+  \/\/ Dispatch handler for cmpxchg.  Provides type-based validity\n+  \/\/ checking and limited conversions around calls to the\n+  \/\/ platform-specific implementation layer provided by\n+  \/\/ PlatformCmpxchg.\n+  template<typename D, typename U, typename T, typename Enable = void>\n+  struct CmpxchgImpl;\n+\n+  \/\/ Platform-specific implementation of cmpxchg.  Support for sizes\n+  \/\/ of 1, 4, and 8 are required.  The class is a function object that\n+  \/\/ must be default constructable, with these requirements:\n+  \/\/\n+  \/\/ - dest is of type T*.\n+  \/\/ - exchange_value and compare_value are of type T.\n+  \/\/ - order is of type atomic_memory_order.\n+  \/\/ - platform_cmpxchg is an object of type PlatformCmpxchg<sizeof(T)>.\n+  \/\/\n+  \/\/ Then\n+  \/\/   platform_cmpxchg(dest, compare_value, exchange_value, order)\n+  \/\/ must be a valid expression, returning a result convertible to T.\n+  \/\/\n+  \/\/ A default definition is provided, which declares a function template\n+  \/\/   T operator()(T volatile*, T, T, atomic_memory_order) const\n+  \/\/\n+  \/\/ For each required size, a platform must either provide an\n+  \/\/ appropriate definition of that function, or must entirely\n+  \/\/ specialize the class template for that size.\n+  template<size_t byte_size> struct PlatformCmpxchg;\n+\n+  \/\/ Support for platforms that implement some variants of cmpxchg\n+  \/\/ using a (typically out of line) non-template helper function.\n+  \/\/ The generic arguments passed to PlatformCmpxchg need to be\n+  \/\/ translated to the appropriate type for the helper function, the\n+  \/\/ helper invoked on the translated arguments, and the result\n+  \/\/ translated back.  Type is the parameter \/ return type of the\n+  \/\/ helper function.\n+  template<typename Type, typename Fn, typename T>\n+  static T cmpxchg_using_helper(Fn fn,\n+                                T volatile* dest,\n+                                T compare_value,\n+                                T exchange_value);\n+\n+  \/\/ Support platforms that do not provide Read-Modify-Write atomic\n+  \/\/ accesses for 1-byte and 8-byte widths. To use, derive PlatformCmpxchg<1>,\n+  \/\/ PlatformAdd<S>, PlatformXchg<S> from these classes.\n+public: \/\/ Temporary, can't be private: C++03 11.4\/2. Fixed by C++11.\n+  struct CmpxchgByteUsingInt;\n+  template<size_t byte_size>\n+  struct XchgUsingCmpxchg;\n+  template<size_t byte_size>\n+  class AddUsingCmpxchg;\n+private:\n+\n+  \/\/ Dispatch handler for xchg.  Provides type-based validity\n+  \/\/ checking and limited conversions around calls to the\n+  \/\/ platform-specific implementation layer provided by\n+  \/\/ PlatformXchg.\n+  template<typename D, typename T, typename Enable = void>\n+  struct XchgImpl;\n+\n+  \/\/ Platform-specific implementation of xchg.  Support for sizes\n+  \/\/ of 4, and sizeof(intptr_t) are required.  The class is a function\n+  \/\/ object that must be default constructable, with these requirements:\n+  \/\/\n+  \/\/ - dest is of type T*.\n+  \/\/ - exchange_value is of type T.\n+  \/\/ - platform_xchg is an object of type PlatformXchg<sizeof(T)>.\n+  \/\/\n+  \/\/ Then\n+  \/\/   platform_xchg(dest, exchange_value)\n+  \/\/ must be a valid expression, returning a result convertible to T.\n+  \/\/\n+  \/\/ A default definition is provided, which declares a function template\n+  \/\/   T operator()(T volatile*, T, atomic_memory_order) const\n+  \/\/\n+  \/\/ For each required size, a platform must either provide an\n+  \/\/ appropriate definition of that function, or must entirely\n+  \/\/ specialize the class template for that size.\n+  template<size_t byte_size> struct PlatformXchg;\n+\n+  \/\/ Support for platforms that implement some variants of xchg\n+  \/\/ using a (typically out of line) non-template helper function.\n+  \/\/ The generic arguments passed to PlatformXchg need to be\n+  \/\/ translated to the appropriate type for the helper function, the\n+  \/\/ helper invoked on the translated arguments, and the result\n+  \/\/ translated back.  Type is the parameter \/ return type of the\n+  \/\/ helper function.\n+  template<typename Type, typename Fn, typename T>\n+  static T xchg_using_helper(Fn fn,\n+                             T volatile* dest,\n+                             T exchange_value);\n+\n+  \/\/ Platform-specific implementation of the bitops (and, or, xor).  Support\n+  \/\/ for sizes of 4 bytes and (if different) pointer size bytes are required.\n+  \/\/ The class is a function object that must be default constructable, with\n+  \/\/ these requirements:\n+  \/\/\n+  \/\/ - T is an integral type.\n+  \/\/ - dest is of type T*.\n+  \/\/ - bits is of type T.\n+  \/\/ - order is of type atomic_memory_order.\n+  \/\/ - platform_bitops is an object of type PlatformBitops<sizeof(T)>.\n+  \/\/\n+  \/\/ Then\n+  \/\/  platform_bitops.fetch_then_and(dest, bits, order)\n+  \/\/  platform_bitops.fetch_then_or(dest, bits, order)\n+  \/\/  platform_bitops.fetch_then_xor(dest, bits, order)\n+  \/\/  platform_bitops.and_then_fetch(dest, bits, order)\n+  \/\/  platform_bitops.or_then_fetch(dest, bits, order)\n+  \/\/  platform_bitops.xor_then_fetch(dest, bits, order)\n+  \/\/ must all be valid expressions, returning a result convertible to T.\n+  \/\/\n+  \/\/ A default definition is provided, which implements all of the operations\n+  \/\/ using cmpxchg.\n+  \/\/\n+  \/\/ For each required size, a platform must either use the default or\n+  \/\/ entirely specialize the class for that size by providing all of the\n+  \/\/ required operations.\n+  \/\/\n+  \/\/ The second (bool) template parameter allows platforms to provide a\n+  \/\/ partial specialization with a parameterized size, and is otherwise\n+  \/\/ unused.  The default value for that bool parameter means specializations\n+  \/\/ don't need to mention it.\n+  template<size_t size, bool = true> class PlatformBitops;\n+\n+  \/\/ Helper base classes that may be used to implement PlatformBitops.\n+  class PrefetchBitopsUsingCmpxchg;\n+  class PostfetchBitopsUsingCmpxchg;\n+  class PostfetchBitopsUsingPrefetch;\n+};\n+\n+template<typename From, typename To>\n+struct AtomicAccess::IsPointerConvertible<From*, To*> : AllStatic {\n+  \/\/ Determine whether From* is implicitly convertible to To*, using\n+  \/\/ the \"sizeof trick\".\n+  typedef char yes;\n+  typedef char (&no)[2];\n+\n+  static yes test(To*);\n+  static no test(...);\n+  static From* test_value;\n+\n+  static const bool value = (sizeof(yes) == sizeof(test(test_value)));\n+};\n+\n+\/\/ Handle load for pointer and integral types.\n+template<typename T, typename PlatformOp>\n+struct AtomicAccess::LoadImpl<\n+  T,\n+  PlatformOp,\n+  typename EnableIf<std::is_integral<T>::value || std::is_pointer<T>::value>::type>\n+{\n+  T operator()(T const volatile* dest) const {\n+    \/\/ Forward to the platform handler for the size of T.\n+    return PlatformOp()(dest);\n+  }\n+};\n+\n+\/\/ Handle load for types that have a translator.\n+\/\/\n+\/\/ All the involved types must be identical.\n+\/\/\n+\/\/ This translates the original call into a call on the decayed\n+\/\/ arguments, and returns the recovered result of that translated\n+\/\/ call.\n+template<typename T, typename PlatformOp>\n+struct AtomicAccess::LoadImpl<\n+  T,\n+  PlatformOp,\n+  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n+{\n+  T operator()(T const volatile* dest) const {\n+    typedef PrimitiveConversions::Translate<T> Translator;\n+    typedef typename Translator::Decayed Decayed;\n+    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n+    Decayed result = PlatformOp()(reinterpret_cast<Decayed const volatile*>(dest));\n+    return Translator::recover(result);\n+  }\n+};\n+\n+\/\/ Default implementation of atomic load if a specific platform\n+\/\/ does not provide a specialization for a certain size class.\n+\/\/ For increased safety, the default implementation only allows\n+\/\/ load types that are pointer sized or smaller. If a platform still\n+\/\/ supports wide atomics, then it has to use specialization\n+\/\/ of AtomicAccess::PlatformLoad for that wider size class.\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformLoad {\n+  template<typename T>\n+  T operator()(T const volatile* dest) const {\n+    STATIC_ASSERT(sizeof(T) <= sizeof(void*)); \/\/ wide atomics need specialization\n+    return *dest;\n+  }\n+};\n+\n+\/\/ Handle store for integral types.\n+\/\/\n+\/\/ All the involved types must be identical.\n+template<typename T, typename PlatformOp>\n+struct AtomicAccess::StoreImpl<\n+  T, T,\n+  PlatformOp,\n+  typename EnableIf<std::is_integral<T>::value>::type>\n+{\n+  void operator()(T volatile* dest, T new_value) const {\n+    \/\/ Forward to the platform handler for the size of T.\n+    PlatformOp()(dest, new_value);\n+  }\n+};\n+\n+\/\/ Handle store for pointer types.\n+\/\/\n+\/\/ The new_value must be implicitly convertible to the\n+\/\/ destination's type; it must be type-correct to store the\n+\/\/ new_value in the destination.\n+template<typename D, typename T, typename PlatformOp>\n+struct AtomicAccess::StoreImpl<\n+  D*, T*,\n+  PlatformOp,\n+  typename EnableIf<AtomicAccess::IsPointerConvertible<T*, D*>::value>::type>\n+{\n+  void operator()(D* volatile* dest, T* new_value) const {\n+    \/\/ Allow derived to base conversion, and adding cv-qualifiers.\n+    D* value = new_value;\n+    PlatformOp()(dest, value);\n+  }\n+};\n+\n+\/\/ Handle store for types that have a translator.\n+\/\/\n+\/\/ All the involved types must be identical.\n+\/\/\n+\/\/ This translates the original call into a call on the decayed\n+\/\/ arguments.\n+template<typename T, typename PlatformOp>\n+struct AtomicAccess::StoreImpl<\n+  T, T,\n+  PlatformOp,\n+  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n+{\n+  void operator()(T volatile* dest, T new_value) const {\n+    typedef PrimitiveConversions::Translate<T> Translator;\n+    typedef typename Translator::Decayed Decayed;\n+    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n+    PlatformOp()(reinterpret_cast<Decayed volatile*>(dest),\n+                 Translator::decay(new_value));\n+  }\n+};\n+\n+\/\/ Default implementation of atomic store if a specific platform\n+\/\/ does not provide a specialization for a certain size class.\n+\/\/ For increased safety, the default implementation only allows\n+\/\/ storing types that are pointer sized or smaller. If a platform still\n+\/\/ supports wide atomics, then it has to use specialization\n+\/\/ of AtomicAccess::PlatformStore for that wider size class.\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformStore {\n+  template<typename T>\n+  void operator()(T volatile* dest,\n+                  T new_value) const {\n+    STATIC_ASSERT(sizeof(T) <= sizeof(void*)); \/\/ wide atomics need specialization\n+    (void)const_cast<T&>(*dest = new_value);\n+  }\n+};\n+\n+template<typename D>\n+inline void AtomicAccess::inc(D volatile* dest, atomic_memory_order order) {\n+  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n+  using I = std::conditional_t<std::is_pointer<D>::value, ptrdiff_t, D>;\n+  AtomicAccess::add(dest, I(1), order);\n+}\n+\n+template<typename D>\n+inline void AtomicAccess::dec(D volatile* dest, atomic_memory_order order) {\n+  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n+  using I = std::conditional_t<std::is_pointer<D>::value, ptrdiff_t, D>;\n+  \/\/ Assumes two's complement integer representation.\n+  #pragma warning(suppress: 4146)\n+  AtomicAccess::add(dest, I(-1), order);\n+}\n+\n+template<typename D, typename I>\n+inline D AtomicAccess::sub(D volatile* dest, I sub_value, atomic_memory_order order) {\n+  STATIC_ASSERT(std::is_pointer<D>::value || std::is_integral<D>::value);\n+  STATIC_ASSERT(std::is_integral<I>::value);\n+  \/\/ If D is a pointer type, use [u]intptr_t as the addend type,\n+  \/\/ matching signedness of I.  Otherwise, use D as the addend type.\n+  using PI = std::conditional_t<std::is_signed<I>::value, intptr_t, uintptr_t>;\n+  using AddendType = std::conditional_t<std::is_pointer<D>::value, PI, D>;\n+  \/\/ Only allow conversions that can't change the value.\n+  STATIC_ASSERT(std::is_signed<I>::value == std::is_signed<AddendType>::value);\n+  STATIC_ASSERT(sizeof(I) <= sizeof(AddendType));\n+  AddendType addend = sub_value;\n+  \/\/ Assumes two's complement integer representation.\n+  #pragma warning(suppress: 4146) \/\/ In case AddendType is not signed.\n+  return AtomicAccess::add(dest, -addend, order);\n+}\n+\n+\/\/ Define the class before including platform file, which may specialize\n+\/\/ the operator definition.  No generic definition of specializations\n+\/\/ of the operator template are provided, nor are there any generic\n+\/\/ specializations of the class.  The platform file is responsible for\n+\/\/ providing those.\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformCmpxchg {\n+  template<typename T>\n+  T operator()(T volatile* dest,\n+               T compare_value,\n+               T exchange_value,\n+               atomic_memory_order order) const;\n+};\n+\n+\/\/ Define the class before including platform file, which may use this\n+\/\/ as a base class, requiring it be complete.  The definition is later\n+\/\/ in this file, near the other definitions related to cmpxchg.\n+struct AtomicAccess::CmpxchgByteUsingInt {\n+  static uint8_t get_byte_in_int(uint32_t n, uint32_t idx);\n+  static uint32_t set_byte_in_int(uint32_t n, uint8_t b, uint32_t idx);\n+  template<typename T>\n+  T operator()(T volatile* dest,\n+               T compare_value,\n+               T exchange_value,\n+               atomic_memory_order order) const;\n+};\n+\n+\/\/ Define the class before including platform file, which may use this\n+\/\/ as a base class, requiring it be complete.  The definition is later\n+\/\/ in this file, near the other definitions related to xchg.\n+template<size_t byte_size>\n+struct AtomicAccess::XchgUsingCmpxchg {\n+  template<typename T>\n+  T operator()(T volatile* dest,\n+               T exchange_value,\n+               atomic_memory_order order) const;\n+};\n+\n+\/\/ Define the class before including platform file, which may use this\n+\/\/ as a base class, requiring it be complete.\n+template<size_t byte_size>\n+class AtomicAccess::AddUsingCmpxchg {\n+public:\n+  template<typename D, typename I>\n+  static inline D add_then_fetch(D volatile* dest,\n+                                 I add_value,\n+                                 atomic_memory_order order) {\n+    D addend = add_value;\n+    return fetch_then_add(dest, add_value, order) + add_value;\n+  }\n+\n+  template<typename D, typename I>\n+  static inline D fetch_then_add(D volatile* dest,\n+                          I add_value,\n+                          atomic_memory_order order) {\n+    STATIC_ASSERT(byte_size == sizeof(I));\n+    STATIC_ASSERT(byte_size == sizeof(D));\n+\n+    D old_value;\n+    D new_value;\n+    do {\n+      old_value = AtomicAccess::load(dest);\n+      new_value = old_value + add_value;\n+    } while (old_value != AtomicAccess::cmpxchg(dest, old_value, new_value, order));\n+    return old_value;\n+  }\n+};\n+\n+\/\/ Define the class before including platform file, which may specialize\n+\/\/ the operator definition.  No generic definition of specializations\n+\/\/ of the operator template are provided, nor are there any generic\n+\/\/ specializations of the class.  The platform file is responsible for\n+\/\/ providing those.\n+template<size_t byte_size>\n+struct AtomicAccess::PlatformXchg {\n+  template<typename T>\n+  T operator()(T volatile* dest,\n+               T exchange_value,\n+               atomic_memory_order order) const;\n+};\n+\n+\/\/ Implement fetch_then_bitop operations using a CAS loop.\n+class AtomicAccess::PrefetchBitopsUsingCmpxchg {\n+  template<typename T, typename Op>\n+  T bitop(T volatile* dest, atomic_memory_order order, Op operation) const {\n+    T old_value;\n+    T new_value;\n+    T fetched_value = AtomicAccess::load(dest);\n+    do {\n+      old_value = fetched_value;\n+      new_value = operation(old_value);\n+      fetched_value = AtomicAccess::cmpxchg(dest, old_value, new_value, order);\n+    } while (old_value != fetched_value);\n+    return fetched_value;\n+  }\n+\n+public:\n+  template<typename T>\n+  T fetch_then_and(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bitop(dest, order, [&](T value) -> T { return value & bits; });\n+  }\n+\n+  template<typename T>\n+  T fetch_then_or(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bitop(dest, order, [&](T value) -> T { return value | bits; });\n+  }\n+\n+  template<typename T>\n+  T fetch_then_xor(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bitop(dest, order, [&](T value) -> T { return value ^ bits; });\n+  }\n+};\n+\n+\/\/ Implement bitop_then_fetch operations using a CAS loop.\n+class AtomicAccess::PostfetchBitopsUsingCmpxchg {\n+  template<typename T, typename Op>\n+  T bitop(T volatile* dest, atomic_memory_order order, Op operation) const {\n+    T old_value;\n+    T new_value;\n+    T fetched_value = AtomicAccess::load(dest);\n+    do {\n+      old_value = fetched_value;\n+      new_value = operation(old_value);\n+      fetched_value = AtomicAccess::cmpxchg(dest, old_value, new_value, order);\n+    } while (old_value != fetched_value);\n+    return new_value;\n+  }\n+\n+public:\n+  template<typename T>\n+  T and_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bitop(dest, order, [&](T value) -> T { return value & bits; });\n+  }\n+\n+  template<typename T>\n+  T or_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bitop(dest, order, [&](T value) -> T { return value | bits; });\n+  }\n+\n+  template<typename T>\n+  T xor_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bitop(dest, order, [&](T value) -> T { return value ^ bits; });\n+  }\n+};\n+\n+\/\/ Implement bitop_then_fetch operations by calling fetch_then_bitop and\n+\/\/ applying the operation to the result and the bits argument.\n+class AtomicAccess::PostfetchBitopsUsingPrefetch {\n+public:\n+  template<typename T>\n+  T and_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bits & AtomicAccess::fetch_then_and(dest, bits, order);\n+  }\n+\n+  template<typename T>\n+  T or_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bits | AtomicAccess::fetch_then_or(dest, bits, order);\n+  }\n+\n+  template<typename T>\n+  T xor_then_fetch(T volatile* dest, T bits, atomic_memory_order order) const {\n+    return bits ^ AtomicAccess::fetch_then_xor(dest, bits, order);\n+  }\n+};\n+\n+\/\/ The default definition uses cmpxchg.  Platforms can override by defining a\n+\/\/ partial specialization providing size, either as a template parameter or as\n+\/\/ a specific value.\n+template<size_t size, bool>\n+class AtomicAccess::PlatformBitops\n+  : public PrefetchBitopsUsingCmpxchg,\n+    public PostfetchBitopsUsingCmpxchg\n+{};\n+\n+template <ScopedFenceType T>\n+class ScopedFenceGeneral: public StackObj {\n+ public:\n+  void prefix() {}\n+  void postfix() {}\n+};\n+\n+\/\/ The following methods can be specialized using simple template specialization\n+\/\/ in the platform specific files for optimization purposes. Otherwise the\n+\/\/ generalized variant is used.\n+\n+template<> inline void ScopedFenceGeneral<X_ACQUIRE>::postfix()       { OrderAccess::acquire(); }\n+template<> inline void ScopedFenceGeneral<RELEASE_X>::prefix()        { OrderAccess::release(); }\n+template<> inline void ScopedFenceGeneral<RELEASE_X_FENCE>::prefix()  { OrderAccess::release(); }\n+template<> inline void ScopedFenceGeneral<RELEASE_X_FENCE>::postfix() { OrderAccess::fence();   }\n+\n+template <ScopedFenceType T>\n+class ScopedFence : public ScopedFenceGeneral<T> {\n+  void *const _field;\n+ public:\n+  ScopedFence(void *const field) : _field(field) { prefix(); }\n+  ~ScopedFence() { postfix(); }\n+  void prefix() { ScopedFenceGeneral<T>::prefix(); }\n+  void postfix() { ScopedFenceGeneral<T>::postfix(); }\n+};\n+\n+\/\/ platform specific in-line definitions - must come before shared definitions\n+\n+#include OS_CPU_HEADER(atomicAccess)\n+\n+\/\/ shared in-line definitions\n+\n+\/\/ size_t casts...\n+#if (SIZE_MAX != UINTPTR_MAX)\n+#error size_t is not WORD_SIZE, interesting platform, but missing implementation here\n+#endif\n+\n+template<typename T>\n+inline T AtomicAccess::load(const volatile T* dest) {\n+  return LoadImpl<T, PlatformLoad<sizeof(T)> >()(dest);\n+}\n+\n+template<size_t byte_size, ScopedFenceType type>\n+struct AtomicAccess::PlatformOrderedLoad {\n+  template <typename T>\n+  T operator()(const volatile T* p) const {\n+    ScopedFence<type> f((void*)p);\n+    return AtomicAccess::load(p);\n+  }\n+};\n+\n+template <typename T>\n+inline T AtomicAccess::load_acquire(const volatile T* p) {\n+  return LoadImpl<T, PlatformOrderedLoad<sizeof(T), X_ACQUIRE> >()(p);\n+}\n+\n+template<typename D, typename T>\n+inline void AtomicAccess::store(volatile D* dest, T store_value) {\n+  StoreImpl<D, T, PlatformStore<sizeof(D)> >()(dest, store_value);\n+}\n+\n+template<size_t byte_size, ScopedFenceType type>\n+struct AtomicAccess::PlatformOrderedStore {\n+  template <typename T>\n+  void operator()(volatile T* p, T v) const {\n+    ScopedFence<type> f((void*)p);\n+    AtomicAccess::store(p, v);\n+  }\n+};\n+\n+template <typename D, typename T>\n+inline void AtomicAccess::release_store(volatile D* p, T v) {\n+  StoreImpl<D, T, PlatformOrderedStore<sizeof(D), RELEASE_X> >()(p, v);\n+}\n+\n+template <typename D, typename T>\n+inline void AtomicAccess::release_store_fence(volatile D* p, T v) {\n+  StoreImpl<D, T, PlatformOrderedStore<sizeof(D), RELEASE_X_FENCE> >()(p, v);\n+}\n+\n+template<typename D, typename I>\n+inline D AtomicAccess::add(D volatile* dest, I add_value,\n+                           atomic_memory_order order) {\n+  return AddImpl<D, I>::add_then_fetch(dest, add_value, order);\n+}\n+\n+template<typename D, typename I>\n+inline D AtomicAccess::fetch_then_add(D volatile* dest, I add_value,\n+                                      atomic_memory_order order) {\n+  return AddImpl<D, I>::fetch_then_add(dest, add_value, order);\n+}\n+\n+template<typename D, typename I>\n+struct AtomicAccess::AddImpl<\n+  D, I,\n+  typename EnableIf<std::is_integral<I>::value &&\n+                    std::is_integral<D>::value &&\n+                    (sizeof(I) <= sizeof(D)) &&\n+                    (std::is_signed<I>::value == std::is_signed<D>::value)>::type>\n+{\n+  static D add_then_fetch(D volatile* dest, I add_value, atomic_memory_order order) {\n+    D addend = add_value;\n+    return PlatformAdd<sizeof(D)>().add_then_fetch(dest, addend, order);\n+  }\n+  static D fetch_then_add(D volatile* dest, I add_value, atomic_memory_order order) {\n+    D addend = add_value;\n+    return PlatformAdd<sizeof(D)>().fetch_then_add(dest, addend, order);\n+  }\n+};\n+\n+template<typename P, typename I>\n+struct AtomicAccess::AddImpl<\n+  P*, I,\n+  typename EnableIf<std::is_integral<I>::value && (sizeof(I) <= sizeof(P*))>::type>\n+{\n+  STATIC_ASSERT(sizeof(intptr_t) == sizeof(P*));\n+  STATIC_ASSERT(sizeof(uintptr_t) == sizeof(P*));\n+\n+  \/\/ Type of the scaled addend.  An integral type of the same size as a\n+  \/\/ pointer, and the same signedness as I.\n+  using SI = std::conditional_t<std::is_signed<I>::value, intptr_t, uintptr_t>;\n+\n+  \/\/ Type of the unscaled destination.  A pointer type with pointee size == 1.\n+  using UP = const char*;\n+\n+  \/\/ Scale add_value by the size of the pointee.\n+  static SI scale_addend(SI add_value) {\n+    return add_value * SI(sizeof(P));\n+  }\n+\n+  \/\/ Casting between P* and UP* here intentionally uses C-style casts,\n+  \/\/ because reinterpret_cast can't cast away cv qualifiers.  Using copy_cv\n+  \/\/ would be an alternative if it existed.\n+\n+  \/\/ Unscale dest to a char* pointee for consistency with scaled addend.\n+  static UP volatile* unscale_dest(P* volatile* dest) {\n+    return (UP volatile*) dest;\n+  }\n+\n+  \/\/ Convert the unscaled char* result to a P*.\n+  static P* scale_result(UP result) {\n+    return (P*) result;\n+  }\n+\n+  static P* add_then_fetch(P* volatile* dest, I addend, atomic_memory_order order) {\n+    return scale_result(PlatformAdd<sizeof(P*)>().add_then_fetch(unscale_dest(dest),\n+                                                                scale_addend(addend),\n+                                                                order));\n+  }\n+\n+  static P* fetch_then_add(P* volatile* dest, I addend, atomic_memory_order order) {\n+    return scale_result(PlatformAdd<sizeof(P*)>().fetch_then_add(unscale_dest(dest),\n+                                                                scale_addend(addend),\n+                                                                order));\n+  }\n+};\n+\n+template<typename Type, typename Fn, typename D, typename I>\n+inline D AtomicAccess::add_using_helper(Fn fn, D volatile* dest, I add_value) {\n+  return PrimitiveConversions::cast<D>(\n+    fn(PrimitiveConversions::cast<Type>(add_value),\n+       reinterpret_cast<Type volatile*>(dest)));\n+}\n+\n+template<typename D, typename U, typename T>\n+inline D AtomicAccess::cmpxchg(D volatile* dest,\n+                               U compare_value,\n+                               T exchange_value,\n+                               atomic_memory_order order) {\n+  return CmpxchgImpl<D, U, T>()(dest, compare_value, exchange_value, order);\n+}\n+\n+template<typename D, typename T>\n+inline bool AtomicAccess::replace_if_null(D* volatile* dest, T* value,\n+                                          atomic_memory_order order) {\n+  \/\/ Presently using a trivial implementation in terms of cmpxchg.\n+  \/\/ Consider adding platform support, to permit the use of compiler\n+  \/\/ intrinsics like gcc's __sync_bool_compare_and_swap.\n+  D* expected_null = nullptr;\n+  return expected_null == cmpxchg(dest, expected_null, value, order);\n+}\n+\n+\/\/ Handle cmpxchg for integral types.\n+\/\/\n+\/\/ All the involved types must be identical.\n+template<typename T>\n+struct AtomicAccess::CmpxchgImpl<\n+  T, T, T,\n+  typename EnableIf<std::is_integral<T>::value>::type>\n+{\n+  T operator()(T volatile* dest, T compare_value, T exchange_value,\n+               atomic_memory_order order) const {\n+    \/\/ Forward to the platform handler for the size of T.\n+    return PlatformCmpxchg<sizeof(T)>()(dest,\n+                                        compare_value,\n+                                        exchange_value,\n+                                        order);\n+  }\n+};\n+\n+\/\/ Handle cmpxchg for pointer types.\n+\/\/\n+\/\/ The destination's type and the compare_value type must be the same,\n+\/\/ ignoring cv-qualifiers; we don't care about the cv-qualifiers of\n+\/\/ the compare_value.\n+\/\/\n+\/\/ The exchange_value must be implicitly convertible to the\n+\/\/ destination's type; it must be type-correct to store the\n+\/\/ exchange_value in the destination.\n+template<typename D, typename U, typename T>\n+struct AtomicAccess::CmpxchgImpl<\n+  D*, U*, T*,\n+  typename EnableIf<AtomicAccess::IsPointerConvertible<T*, D*>::value &&\n+                    std::is_same<std::remove_cv_t<D>,\n+                                 std::remove_cv_t<U>>::value>::type>\n+{\n+  D* operator()(D* volatile* dest, U* compare_value, T* exchange_value,\n+               atomic_memory_order order) const {\n+    \/\/ Allow derived to base conversion, and adding cv-qualifiers.\n+    D* new_value = exchange_value;\n+    \/\/ Don't care what the CV qualifiers for compare_value are,\n+    \/\/ but we need to match D* when calling platform support.\n+    D* old_value = const_cast<D*>(compare_value);\n+    return PlatformCmpxchg<sizeof(D*)>()(dest, old_value, new_value, order);\n+  }\n+};\n+\n+\/\/ Handle cmpxchg for types that have a translator.\n+\/\/\n+\/\/ All the involved types must be identical.\n+\/\/\n+\/\/ This translates the original call into a call on the decayed\n+\/\/ arguments, and returns the recovered result of that translated\n+\/\/ call.\n+template<typename T>\n+struct AtomicAccess::CmpxchgImpl<\n+  T, T, T,\n+  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n+{\n+  T operator()(T volatile* dest, T compare_value, T exchange_value,\n+               atomic_memory_order order) const {\n+    typedef PrimitiveConversions::Translate<T> Translator;\n+    typedef typename Translator::Decayed Decayed;\n+    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n+    return Translator::recover(\n+      cmpxchg(reinterpret_cast<Decayed volatile*>(dest),\n+              Translator::decay(compare_value),\n+              Translator::decay(exchange_value),\n+              order));\n+  }\n+};\n+\n+template<typename Type, typename Fn, typename T>\n+inline T AtomicAccess::cmpxchg_using_helper(Fn fn,\n+                                            T volatile* dest,\n+                                            T compare_value,\n+                                            T exchange_value) {\n+  STATIC_ASSERT(sizeof(Type) == sizeof(T));\n+  return PrimitiveConversions::cast<T>(\n+    fn(PrimitiveConversions::cast<Type>(exchange_value),\n+       reinterpret_cast<Type volatile*>(dest),\n+       PrimitiveConversions::cast<Type>(compare_value)));\n+}\n+\n+inline uint32_t AtomicAccess::CmpxchgByteUsingInt::set_byte_in_int(uint32_t n,\n+                                                                   uint8_t b,\n+                                                                   uint32_t idx) {\n+  uint32_t bitsIdx = BitsPerByte * idx;\n+  return (n & ~(static_cast<uint32_t>(0xff) << bitsIdx))\n+          | (static_cast<uint32_t>(b) << bitsIdx);\n+}\n+\n+inline uint8_t AtomicAccess::CmpxchgByteUsingInt::get_byte_in_int(uint32_t n,\n+                                                                  uint32_t idx) {\n+  uint32_t bitsIdx = BitsPerByte * idx;\n+  return (uint8_t)(n >> bitsIdx);\n+}\n+\n+template<typename T>\n+inline T AtomicAccess::CmpxchgByteUsingInt::operator()(T volatile* dest,\n+                                                       T compare_value,\n+                                                       T exchange_value,\n+                                                       atomic_memory_order order) const {\n+  STATIC_ASSERT(sizeof(T) == sizeof(uint8_t));\n+  uint8_t canon_exchange_value = exchange_value;\n+  uint8_t canon_compare_value = compare_value;\n+  volatile uint32_t* aligned_dest\n+    = reinterpret_cast<volatile uint32_t*>(align_down(dest, sizeof(uint32_t)));\n+  uint32_t offset = checked_cast<uint32_t>(pointer_delta(dest, aligned_dest, 1));\n+\n+  uint32_t idx = (Endian::NATIVE == Endian::BIG)\n+                   ? (sizeof(uint32_t) - 1 - offset)\n+                   : offset;\n+\n+  \/\/ current value may not be what we are looking for, so force it\n+  \/\/ to that value so the initial cmpxchg will fail if it is different\n+  uint32_t cur = set_byte_in_int(AtomicAccess::load(aligned_dest), canon_compare_value, idx);\n+\n+  \/\/ always execute a real cmpxchg so that we get the required memory\n+  \/\/ barriers even on initial failure\n+  do {\n+    \/\/ value to swap in matches current value\n+    \/\/ except for the one byte we want to update\n+    uint32_t new_value = set_byte_in_int(cur, canon_exchange_value, idx);\n+\n+    uint32_t res = cmpxchg(aligned_dest, cur, new_value, order);\n+    if (res == cur) break;      \/\/ success\n+\n+    \/\/ at least one byte in the int changed value, so update\n+    \/\/ our view of the current int\n+    cur = res;\n+    \/\/ if our byte is still as cur we loop and try again\n+  } while (get_byte_in_int(cur, idx) == canon_compare_value);\n+\n+  return PrimitiveConversions::cast<T>(get_byte_in_int(cur, idx));\n+}\n+\n+\/\/ Handle xchg for integral types.\n+\/\/\n+\/\/ All the involved types must be identical.\n+template<typename T>\n+struct AtomicAccess::XchgImpl<\n+  T, T,\n+  typename EnableIf<std::is_integral<T>::value>::type>\n+{\n+  T operator()(T volatile* dest, T exchange_value, atomic_memory_order order) const {\n+    \/\/ Forward to the platform handler for the size of T.\n+    return PlatformXchg<sizeof(T)>()(dest, exchange_value, order);\n+  }\n+};\n+\n+\/\/ Handle xchg for pointer types.\n+\/\/\n+\/\/ The exchange_value must be implicitly convertible to the\n+\/\/ destination's type; it must be type-correct to store the\n+\/\/ exchange_value in the destination.\n+template<typename D, typename T>\n+struct AtomicAccess::XchgImpl<\n+  D*, T*,\n+  typename EnableIf<AtomicAccess::IsPointerConvertible<T*, D*>::value>::type>\n+{\n+  D* operator()(D* volatile* dest, T* exchange_value, atomic_memory_order order) const {\n+    \/\/ Allow derived to base conversion, and adding cv-qualifiers.\n+    D* new_value = exchange_value;\n+    return PlatformXchg<sizeof(D*)>()(dest, new_value, order);\n+  }\n+};\n+\n+\/\/ Handle xchg for types that have a translator.\n+\/\/\n+\/\/ All the involved types must be identical.\n+\/\/\n+\/\/ This translates the original call into a call on the decayed\n+\/\/ arguments, and returns the recovered result of that translated\n+\/\/ call.\n+template<typename T>\n+struct AtomicAccess::XchgImpl<\n+  T, T,\n+  typename EnableIf<PrimitiveConversions::Translate<T>::value>::type>\n+{\n+  T operator()(T volatile* dest, T exchange_value, atomic_memory_order order) const {\n+    typedef PrimitiveConversions::Translate<T> Translator;\n+    typedef typename Translator::Decayed Decayed;\n+    STATIC_ASSERT(sizeof(T) == sizeof(Decayed));\n+    return Translator::recover(\n+      xchg(reinterpret_cast<Decayed volatile*>(dest),\n+           Translator::decay(exchange_value),\n+           order));\n+  }\n+};\n+\n+template<typename Type, typename Fn, typename T>\n+inline T AtomicAccess::xchg_using_helper(Fn fn,\n+                                         T volatile* dest,\n+                                         T exchange_value) {\n+  STATIC_ASSERT(sizeof(Type) == sizeof(T));\n+  \/\/ Notice the swapped order of arguments. Change when\/if stubs are rewritten.\n+  return PrimitiveConversions::cast<T>(\n+    fn(PrimitiveConversions::cast<Type>(exchange_value),\n+       reinterpret_cast<Type volatile*>(dest)));\n+}\n+\n+template<typename D, typename T>\n+inline D AtomicAccess::xchg(volatile D* dest, T exchange_value, atomic_memory_order order) {\n+  return XchgImpl<D, T>()(dest, exchange_value, order);\n+}\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T AtomicAccess::XchgUsingCmpxchg<byte_size>::operator()(T volatile* dest,\n+                                                               T exchange_value,\n+                                                               atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+\n+  T old_value;\n+  do {\n+    old_value = AtomicAccess::load(dest);\n+  } while (old_value != AtomicAccess::cmpxchg(dest, old_value, exchange_value, order));\n+  return old_value;\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_ATOMICACCESS_HPP\n","filename":"src\/hotspot\/share\/runtime\/atomicAccess.hpp","additions":1235,"deletions":0,"binary":false,"changes":1235,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -42,2 +42,2 @@\n-  uintptr_t get_metadata() const { return Atomic::load(&_metadata); }\n-  void set_metadata(uintptr_t value) { Atomic::store(&_metadata, value); }\n+  uintptr_t get_metadata() const { return AtomicAccess::load(&_metadata); }\n+  void set_metadata(uintptr_t value) { AtomicAccess::store(&_metadata, value); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -157,1 +157,1 @@\n-  return Atomic::load(chunk->field_addr<uint8_t>(_flags_offset));\n+  return AtomicAccess::load(chunk->field_addr<uint8_t>(_flags_offset));\n@@ -161,1 +161,1 @@\n-  Atomic::store(chunk->field_addr<uint8_t>(_flags_offset), value);\n+  AtomicAccess::store(chunk->field_addr<uint8_t>(_flags_offset), value);\n@@ -165,1 +165,1 @@\n-  return Atomic::load_acquire(chunk->field_addr<uint8_t>(_flags_offset));\n+  return AtomicAccess::load_acquire(chunk->field_addr<uint8_t>(_flags_offset));\n@@ -169,1 +169,1 @@\n-  Atomic::release_store(chunk->field_addr<uint8_t>(_flags_offset), value);\n+  AtomicAccess::release_store(chunk->field_addr<uint8_t>(_flags_offset), value);\n@@ -173,1 +173,1 @@\n-  return Atomic::cmpxchg(chunk->field_addr<uint8_t>(_flags_offset), expected_value, new_value) == expected_value;\n+  return AtomicAccess::cmpxchg(chunk->field_addr<uint8_t>(_flags_offset), expected_value, new_value) == expected_value;\n@@ -190,1 +190,1 @@\n-  return Atomic::load(chunk->field_addr<uint8_t>(_lockStackSize_offset));\n+  return AtomicAccess::load(chunk->field_addr<uint8_t>(_lockStackSize_offset));\n@@ -194,1 +194,1 @@\n-  Atomic::store(chunk->field_addr<uint8_t>(_lockStackSize_offset), value);\n+  AtomicAccess::store(chunk->field_addr<uint8_t>(_lockStackSize_offset), value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -73,1 +73,1 @@\n-  Atomic::add(&(instance->_gc_total_cpu_time_diff), diff);\n+  AtomicAccess::add(&(instance->_gc_total_cpu_time_diff), diff);\n@@ -80,1 +80,1 @@\n-  jlong fetched_value = Atomic::xchg(&(instance->_gc_total_cpu_time_diff), new_value);\n+  jlong fetched_value = AtomicAccess::xchg(&(instance->_gc_total_cpu_time_diff), new_value);\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  \/\/ It is incremented using Atomic::add() to prevent race conditions, and\n+  \/\/ It is incremented using AtomicAccess::add() to prevent race conditions, and\n","filename":"src\/hotspot\/share\/runtime\/cpuTimeCounters.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -141,1 +141,1 @@\n-  Atomic::store(&nm->_deoptimization_status, status);\n+  AtomicAccess::store(&nm->_deoptimization_status, status);\n@@ -1169,1 +1169,1 @@\n-      if (!Atomic::replace_if_null(&_singleton, s)) {\n+      if (!AtomicAccess::replace_if_null(&_singleton, s)) {\n@@ -1232,1 +1232,1 @@\n-      if (!Atomic::replace_if_null(&_singleton, s)) {\n+      if (!AtomicAccess::replace_if_null(&_singleton, s)) {\n@@ -2094,1 +2094,1 @@\n-  if (1 == critical_section || Atomic::cmpxchg(&critical_section, 0, 1) == 1) {\n+  if (1 == critical_section || AtomicAccess::cmpxchg(&critical_section, 0, 1) == 1) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -77,1 +77,1 @@\n-    int32_t val = Atomic::load(&_pending_threads);\n+    int32_t val = AtomicAccess::load(&_pending_threads);\n@@ -81,2 +81,2 @@\n-  void add_target_count(int count) { Atomic::add(&_pending_threads, count); }\n-  int32_t pending_threads()        { return Atomic::load(&_pending_threads); }\n+  void add_target_count(int count) { AtomicAccess::add(&_pending_threads, count); }\n+  int32_t pending_threads()        { return AtomicAccess::load(&_pending_threads); }\n@@ -351,1 +351,1 @@\n-  Atomic::dec(&_pending_threads);\n+  AtomicAccess::dec(&_pending_threads);\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  void set_active_handshaker(Thread* thread) { Atomic::store(&_active_handshaker, thread); }\n+  void set_active_handshaker(Thread* thread) { AtomicAccess::store(&_active_handshaker, thread); }\n@@ -150,1 +150,1 @@\n-  Thread* active_handshaker() const { return Atomic::load(&_active_handshaker); }\n+  Thread* active_handshaker() const { return AtomicAccess::load(&_active_handshaker); }\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -241,1 +241,1 @@\n-  return Atomic::load_acquire(&_init_completed);\n+  return AtomicAccess::load_acquire(&_init_completed);\n@@ -254,1 +254,1 @@\n-  Atomic::release_store(&_init_completed, true);\n+  AtomicAccess::release_store(&_init_completed, true);\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -1068,1 +1068,1 @@\n-  return Atomic::load(&_exception_oop);\n+  return AtomicAccess::load(&_exception_oop);\n@@ -1072,1 +1072,1 @@\n-  Atomic::store(&_exception_oop, o);\n+  AtomicAccess::store(&_exception_oop, o);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    \/\/ Use Atomic::load() to prevent data race between concurrent modification and\n+    \/\/ Use AtomicAccess::load() to prevent data race between concurrent modification and\n@@ -189,1 +189,1 @@\n-    return Atomic::load(&_current_pending_monitor);\n+    return AtomicAccess::load(&_current_pending_monitor);\n@@ -192,1 +192,1 @@\n-    Atomic::store(&_current_pending_monitor, monitor);\n+    AtomicAccess::store(&_current_pending_monitor, monitor);\n@@ -202,1 +202,1 @@\n-    return Atomic::load(&_current_waiting_monitor);\n+    return AtomicAccess::load(&_current_waiting_monitor);\n@@ -205,1 +205,1 @@\n-    Atomic::store(&_current_waiting_monitor, monitor);\n+    AtomicAccess::store(&_current_waiting_monitor, monitor);\n@@ -719,1 +719,1 @@\n-    return Atomic::load(&_carrier_thread_suspended);\n+    return AtomicAccess::load(&_carrier_thread_suspended);\n@@ -731,2 +731,2 @@\n-  bool VTMS_transition_mark() const              { return Atomic::load(&_VTMS_transition_mark); }\n-  void set_VTMS_transition_mark(bool val)        { Atomic::store(&_VTMS_transition_mark, val); }\n+  bool VTMS_transition_mark() const              { return AtomicAccess::load(&_VTMS_transition_mark); }\n+  void set_VTMS_transition_mark(bool val)        { AtomicAccess::store(&_VTMS_transition_mark, val); }\n@@ -951,1 +951,1 @@\n-  bool in_critical_atomic() { return Atomic::load(&_jni_active_critical) > 0; }\n+  bool in_critical_atomic() { return AtomicAccess::load(&_jni_active_critical) > 0; }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -50,1 +50,1 @@\n-  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags | f)) != flags);\n+  while (AtomicAccess::cmpxchg(&_suspend_flags, flags, (flags | f)) != flags);\n@@ -57,1 +57,1 @@\n-  while (Atomic::cmpxchg(&_suspend_flags, flags, (flags & ~f)) != flags);\n+  while (AtomicAccess::cmpxchg(&_suspend_flags, flags, (flags & ~f)) != flags);\n@@ -69,1 +69,1 @@\n-  return Atomic::cmpxchg(&_carrier_thread_suspended, false, true) == false;\n+  return AtomicAccess::cmpxchg(&_carrier_thread_suspended, false, true) == false;\n@@ -72,1 +72,1 @@\n-  return Atomic::cmpxchg(&_carrier_thread_suspended, true, false) == true;\n+  return AtomicAccess::cmpxchg(&_carrier_thread_suspended, true, false) == true;\n@@ -140,1 +140,1 @@\n-  return Atomic::load_acquire(&_thread_state);\n+  return AtomicAccess::load_acquire(&_thread_state);\n@@ -142,1 +142,1 @@\n-  return Atomic::load(&_thread_state);\n+  return AtomicAccess::load(&_thread_state);\n@@ -152,1 +152,1 @@\n-  Atomic::release_store(&_thread_state, s);\n+  AtomicAccess::release_store(&_thread_state, s);\n@@ -154,1 +154,1 @@\n-  Atomic::store(&_thread_state, s);\n+  AtomicAccess::store(&_thread_state, s);\n@@ -201,1 +201,1 @@\n-  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n+  TerminatedTypes l_terminated = AtomicAccess::load_acquire(&_terminated);\n@@ -208,1 +208,1 @@\n-  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n+  TerminatedTypes l_terminated = AtomicAccess::load_acquire(&_terminated);\n@@ -214,1 +214,1 @@\n-  TerminatedTypes l_terminated = Atomic::load_acquire(&_terminated);\n+  TerminatedTypes l_terminated = AtomicAccess::load_acquire(&_terminated);\n@@ -219,1 +219,1 @@\n-  Atomic::release_store(&_terminated, t);\n+  AtomicAccess::release_store(&_terminated, t);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-    Atomic::inc(&_blocks_allocated);\n+    AtomicAccess::inc(&_blocks_allocated);\n@@ -415,1 +415,1 @@\n-      Atomic::dec(&_blocks_allocated);\n+      AtomicAccess::dec(&_blocks_allocated);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -118,1 +118,1 @@\n-    Atomic::inc(&_items_count, memory_order_relaxed);\n+    AtomicAccess::inc(&_items_count, memory_order_relaxed);\n@@ -122,1 +122,1 @@\n-    Atomic::dec(&_items_count, memory_order_relaxed);\n+    AtomicAccess::dec(&_items_count, memory_order_relaxed);\n@@ -126,1 +126,1 @@\n-    size_t count = Atomic::load(&_items_count);\n+    size_t count = AtomicAccess::load(&_items_count);\n@@ -198,2 +198,2 @@\n-    if (!_table->is_max_size_reached() && !Atomic::load(&_resize)) {\n-      Atomic::store(&_resize, true);\n+    if (!_table->is_max_size_reached() && !AtomicAccess::load(&_resize)) {\n+      AtomicAccess::store(&_resize, true);\n@@ -219,1 +219,1 @@\n-    return should_grow() || should_shrink() || Atomic::load(&_resize);\n+    return should_grow() || should_shrink() || AtomicAccess::load(&_resize);\n@@ -268,1 +268,1 @@\n-      if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n+      if (!_table->is_max_size_reached() && AtomicAccess::load(&_resize)) {\n@@ -275,1 +275,1 @@\n-    Atomic::store(&_resize, false);\n+    AtomicAccess::store(&_resize, false);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -107,1 +107,1 @@\n-  void raw_set_owner(Thread* new_owner) { Atomic::store(&_owner, new_owner); }\n+  void raw_set_owner(Thread* new_owner) { AtomicAccess::store(&_owner, new_owner); }\n@@ -205,1 +205,1 @@\n-  Thread* owner() const         { return Atomic::load(&_owner); }\n+  Thread* owner() const         { return AtomicAccess::load(&_owner); }\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -57,1 +57,1 @@\n-  _current(Atomic::load_acquire(&_the_list._head))\n+  _current(AtomicAccess::load_acquire(&_the_list._head))\n@@ -66,1 +66,1 @@\n-  _current = Atomic::load_acquire(&_current->_next);\n+  _current = AtomicAccess::load_acquire(&_current->_next);\n@@ -79,2 +79,2 @@\n-  Atomic::release_store(&_next, _the_list._head);\n-  Atomic::release_store(&_the_list._head, this);\n+  AtomicAccess::release_store(&_next, _the_list._head);\n+  AtomicAccess::release_store(&_the_list._head, this);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -698,1 +698,1 @@\n-    ObjectWaiter* head = Atomic::load(&_entry_list);\n+    ObjectWaiter* head = AtomicAccess::load(&_entry_list);\n@@ -700,1 +700,1 @@\n-    if (Atomic::cmpxchg(&_entry_list, head, node) == head) {\n+    if (AtomicAccess::cmpxchg(&_entry_list, head, node) == head) {\n@@ -717,1 +717,1 @@\n-    ObjectWaiter* head = Atomic::load(&_entry_list);\n+    ObjectWaiter* head = AtomicAccess::load(&_entry_list);\n@@ -719,1 +719,1 @@\n-    if (Atomic::cmpxchg(&_entry_list, head, node) == head) {\n+    if (AtomicAccess::cmpxchg(&_entry_list, head, node) == head) {\n@@ -808,1 +808,1 @@\n-    if (Atomic::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n+    if (AtomicAccess::cmpxchg(&_contentions, 0, INT_MIN) != 0) {\n@@ -825,1 +825,1 @@\n-  ObjectWaiter* w = Atomic::load(&_entry_list);\n+  ObjectWaiter* w = AtomicAccess::load(&_entry_list);\n@@ -1272,1 +1272,1 @@\n-  ObjectWaiter* w = Atomic::load_acquire(&_entry_list);\n+  ObjectWaiter* w = AtomicAccess::load_acquire(&_entry_list);\n@@ -1341,1 +1341,1 @@\n-    ObjectWaiter* w = Atomic::load(&_entry_list);\n+    ObjectWaiter* w = AtomicAccess::load(&_entry_list);\n@@ -1344,1 +1344,1 @@\n-      if (Atomic::cmpxchg(&_entry_list, w, (ObjectWaiter*)nullptr) == w) {\n+      if (AtomicAccess::cmpxchg(&_entry_list, w, (ObjectWaiter*)nullptr) == w) {\n@@ -1381,1 +1381,1 @@\n-    ObjectWaiter* w = Atomic::load(&_entry_list);\n+    ObjectWaiter* w = AtomicAccess::load(&_entry_list);\n@@ -1387,1 +1387,1 @@\n-      if (Atomic::cmpxchg(&_entry_list, w, next) == w) {\n+      if (AtomicAccess::cmpxchg(&_entry_list, w, next) == w) {\n@@ -1514,1 +1514,1 @@\n-      ObjectWaiter* w = Atomic::load(&_entry_list);\n+      ObjectWaiter* w = AtomicAccess::load(&_entry_list);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-  \/\/ old_value, using Atomic::cmpxchg(). Otherwise, does not change the\n+  \/\/ old_value, using AtomicAccess::cmpxchg(). Otherwise, does not change the\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -63,1 +63,1 @@\n-  return Atomic::load(&_metadata);\n+  return AtomicAccess::load(&_metadata);\n@@ -67,1 +67,1 @@\n-  Atomic::store(&_metadata, value);\n+  AtomicAccess::store(&_metadata, value);\n@@ -112,1 +112,1 @@\n-  return Atomic::load(&_owner);\n+  return AtomicAccess::load(&_owner);\n@@ -127,1 +127,1 @@\n-  return Atomic::load(&_contentions);\n+  return AtomicAccess::load(&_contentions);\n@@ -132,1 +132,1 @@\n-  Atomic::add(&_contentions, value);\n+  AtomicAccess::add(&_contentions, value);\n@@ -150,1 +150,1 @@\n-  int64_t prev = Atomic::load(&_owner);\n+  int64_t prev = AtomicAccess::load(&_owner);\n@@ -154,1 +154,1 @@\n-  Atomic::release_store(&_owner, NO_OWNER);\n+  AtomicAccess::release_store(&_owner, NO_OWNER);\n@@ -164,1 +164,1 @@\n-  int64_t prev = Atomic::load(&_owner);\n+  int64_t prev = AtomicAccess::load(&_owner);\n@@ -169,1 +169,1 @@\n-  Atomic::store(&_owner, new_value);\n+  AtomicAccess::store(&_owner, new_value);\n@@ -185,1 +185,1 @@\n-  int64_t prev = Atomic::cmpxchg(&_owner, old_value, new_value);\n+  int64_t prev = AtomicAccess::cmpxchg(&_owner, old_value, new_value);\n@@ -200,1 +200,1 @@\n-  return Atomic::load(&_succ) != NO_OWNER;\n+  return AtomicAccess::load(&_succ) != NO_OWNER;\n@@ -204,1 +204,1 @@\n-  return owner_id_from(thread) == Atomic::load(&_succ);\n+  return owner_id_from(thread) == AtomicAccess::load(&_succ);\n@@ -208,1 +208,1 @@\n-  Atomic::store(&_succ, owner_id_from(thread));\n+  AtomicAccess::store(&_succ, owner_id_from(thread));\n@@ -212,1 +212,1 @@\n-  Atomic::store(&_succ, java_lang_Thread::thread_id(vthread));\n+  AtomicAccess::store(&_succ, java_lang_Thread::thread_id(vthread));\n@@ -216,1 +216,1 @@\n-  Atomic::store(&_succ, NO_OWNER);\n+  AtomicAccess::store(&_succ, NO_OWNER);\n@@ -220,1 +220,1 @@\n-  return Atomic::load(&_succ);\n+  return AtomicAccess::load(&_succ);\n@@ -229,1 +229,1 @@\n-  return Atomic::load(&_next_om);\n+  return AtomicAccess::load(&_next_om);\n@@ -234,1 +234,1 @@\n-  Atomic::store(&_next_om, new_value);\n+  AtomicAccess::store(&_next_om, new_value);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -830,1 +830,1 @@\n-    if (Atomic::cmpxchg(&_rand_seed, seed, rand, memory_order_relaxed) == seed) {\n+    if (AtomicAccess::cmpxchg(&_rand_seed, seed, rand, memory_order_relaxed) == seed) {\n@@ -1579,1 +1579,1 @@\n-  Atomic::release_store(&_image_release_file_content, tmp);\n+  AtomicAccess::release_store(&_image_release_file_content, tmp);\n@@ -1584,1 +1584,1 @@\n-  char* ifrc = Atomic::load_acquire(&_image_release_file_content);\n+  char* ifrc = AtomicAccess::load_acquire(&_image_release_file_content);\n@@ -2349,1 +2349,1 @@\n-        Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+        AtomicAccess::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1108,1 +1108,1 @@\n-\/\/ so arguably we should provide Atomic::SpinPause() instead\n+\/\/ so arguably we should provide AtomicAccess::SpinPause() instead\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-  Atomic::store(&_has_PerfData, false);\n+  AtomicAccess::store(&_has_PerfData, false);\n@@ -279,1 +279,1 @@\n-    Atomic::release_store(&_has_PerfData, true);\n+    AtomicAccess::release_store(&_has_PerfData, true);\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -700,1 +700,1 @@\n-    static bool has_PerfData() { return Atomic::load_acquire(&_has_PerfData); }\n+    static bool has_PerfData() { return AtomicAccess::load_acquire(&_has_PerfData); }\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -157,1 +157,1 @@\n-  Atomic::release_store(&_initialized, 1);\n+  AtomicAccess::release_store(&_initialized, 1);\n@@ -270,1 +270,1 @@\n-  return Atomic::load_acquire(&_initialized) != 0;\n+  return AtomicAccess::load_acquire(&_initialized) != 0;\n","filename":"src\/hotspot\/share\/runtime\/perfMemory.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1152,1 +1152,1 @@\n-  InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  InstanceKlass* klass = java_lang_Class::as_InstanceKlass(mirror);\n@@ -1169,1 +1169,1 @@\n-  InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  InstanceKlass* klass = java_lang_Class::as_InstanceKlass(mirror);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"classfile\/javaClasses.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"oops\/instanceKlass.inline.hpp\"\n-#include \"runtime\/reflectionUtils.hpp\"\n-\n-\n-GrowableArray<FilteredField*> *FilteredFieldsMap::_filtered_fields =\n-  new (mtServiceability) GrowableArray<FilteredField*>(3, mtServiceability);\n-\n-\n-void FilteredFieldsMap::initialize() {\n-  int offset = reflect_ConstantPool::oop_offset();\n-  _filtered_fields->append(new FilteredField(vmClasses::reflect_ConstantPool_klass(), offset));\n-}\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.cpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_REFLECTIONUTILS_HPP\n-#define SHARE_RUNTIME_REFLECTIONUTILS_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-#include \"oops\/fieldStreams.inline.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"runtime\/reflection.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-class FilteredField : public CHeapObj<mtInternal>  {\n- private:\n-  Klass* _klass;\n-  int    _field_offset;\n-\n- public:\n-  FilteredField(Klass* klass, int field_offset) {\n-    _klass = klass;\n-    _field_offset = field_offset;\n-  }\n-  Klass* klass() { return _klass; }\n-  int  field_offset() { return _field_offset; }\n-};\n-\n-class FilteredFieldsMap : AllStatic {\n- private:\n-  static GrowableArray<FilteredField *> *_filtered_fields;\n- public:\n-  static void initialize();\n-  static bool is_filtered_field(Klass* klass, int field_offset) {\n-    for (int i=0; i < _filtered_fields->length(); i++) {\n-      if (klass == _filtered_fields->at(i)->klass() &&\n-        field_offset == _filtered_fields->at(i)->field_offset()) {\n-        return true;\n-      }\n-    }\n-    return false;\n-  }\n-  static int  filtered_fields_count(Klass* klass, bool local_only) {\n-    int nflds = 0;\n-    for (int i=0; i < _filtered_fields->length(); i++) {\n-      if (local_only && klass == _filtered_fields->at(i)->klass()) {\n-        nflds++;\n-      } else if (klass->is_subtype_of(_filtered_fields->at(i)->klass())) {\n-        nflds++;\n-      }\n-    }\n-    return nflds;\n-  }\n-};\n-\n-\/\/ Iterate over Java fields filtering fields like reflection does.\n-class FilteredJavaFieldStream : public JavaFieldStream {\n-private:\n-  InstanceKlass* _klass;\n-  int  _filtered_fields_count;\n-  bool has_filtered_field() const { return (_filtered_fields_count > 0); }\n-  void skip_filtered_fields() {\n-    if (has_filtered_field()) {\n-      while (!done() && FilteredFieldsMap::is_filtered_field((Klass*)_klass, offset())) {\n-        JavaFieldStream::next();\n-      }\n-    }\n-  }\n-\n-public:\n-  FilteredJavaFieldStream(InstanceKlass* klass)\n-    : JavaFieldStream(klass),\n-      _klass(klass),\n-      _filtered_fields_count(FilteredFieldsMap::filtered_fields_count(klass, true))\n-  {\n-    \/\/ skip filtered fields at the beginning\n-    skip_filtered_fields();\n-  }\n-  int field_count() const {\n-    return _klass->java_fields_count() - _filtered_fields_count;\n-  }\n-  void next() {\n-    JavaFieldStream::next();\n-    skip_filtered_fields();\n-  }\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_REFLECTIONUTILS_HPP\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -310,1 +310,1 @@\n-  Atomic::release_store(&_safepoint_counter, _safepoint_counter + 1);\n+  AtomicAccess::release_store(&_safepoint_counter, _safepoint_counter + 1);\n@@ -445,1 +445,1 @@\n-    Atomic::release_store(&_safepoint_counter, _safepoint_counter + 1);\n+    AtomicAccess::release_store(&_safepoint_counter, _safepoint_counter + 1);\n@@ -613,1 +613,1 @@\n-    Atomic::inc(&_nof_threads_hit_polling_page);\n+    AtomicAccess::inc(&_nof_threads_hit_polling_page);\n@@ -689,1 +689,1 @@\n-  return Atomic::load_acquire(&_safepoint_id);\n+  return AtomicAccess::load_acquire(&_safepoint_id);\n@@ -693,1 +693,1 @@\n-  Atomic::release_store(&_safepoint_id, SafepointSynchronize::InactiveSafepointCounter);\n+  AtomicAccess::release_store(&_safepoint_id, SafepointSynchronize::InactiveSafepointCounter);\n@@ -697,1 +697,1 @@\n-  Atomic::release_store(&_safepoint_id, safepoint_id);\n+  AtomicAccess::release_store(&_safepoint_id, safepoint_id);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -40,1 +40,1 @@\n-  Atomic::store(&_polling_page, poll_value);\n+  AtomicAccess::store(&_polling_page, poll_value);\n@@ -45,1 +45,1 @@\n-  Atomic::store(&_polling_word, poll_value);\n+  AtomicAccess::store(&_polling_word, poll_value);\n@@ -51,1 +51,1 @@\n-  return Atomic::load_acquire(&_polling_word);\n+  return AtomicAccess::load_acquire(&_polling_word);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -889,2 +889,2 @@\n-  Klass* k = vmClasses::StackOverflowError_klass();\n-  oop exception_oop = InstanceKlass::cast(k)->allocate_instance(CHECK);\n+  InstanceKlass* k = vmClasses::StackOverflowError_klass();\n+  oop exception_oop = k->allocate_instance(CHECK);\n@@ -904,1 +904,1 @@\n-  Atomic::inc(&Exceptions::_stack_overflow_errors);\n+  AtomicAccess::inc(&Exceptions::_stack_overflow_errors);\n@@ -1425,1 +1425,1 @@\n-  Atomic::inc(addr);\n+  AtomicAccess::inc(addr);\n@@ -1675,1 +1675,1 @@\n-  Atomic::inc(&_ic_miss_ctr);\n+  AtomicAccess::inc(&_ic_miss_ctr);\n@@ -1810,1 +1810,1 @@\n-  Atomic::inc(&_wrong_method_ctr);\n+  AtomicAccess::inc(&_wrong_method_ctr);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -189,1 +189,1 @@\n-  uint32_t state = Atomic::load(&_state);\n+  uint32_t state = AtomicAccess::load(&_state);\n@@ -234,2 +234,2 @@\n-    Atomic::release_store(&_watermark, _iterator->callee());\n-    Atomic::release_store(&_state, StackWatermarkState::create(epoch_id(), false \/* is_done *\/)); \/\/ release watermark w.r.t. epoch\n+    AtomicAccess::release_store(&_watermark, _iterator->callee());\n+    AtomicAccess::release_store(&_state, StackWatermarkState::create(epoch_id(), false \/* is_done *\/)); \/\/ release watermark w.r.t. epoch\n@@ -237,2 +237,2 @@\n-    Atomic::release_store(&_watermark, uintptr_t(0)); \/\/ Release stack data modifications w.r.t. watermark\n-    Atomic::release_store(&_state, StackWatermarkState::create(epoch_id(), true \/* is_done *\/)); \/\/ release watermark w.r.t. epoch\n+    AtomicAccess::release_store(&_watermark, uintptr_t(0)); \/\/ Release stack data modifications w.r.t. watermark\n+    AtomicAccess::release_store(&_state, StackWatermarkState::create(epoch_id(), true \/* is_done *\/)); \/\/ release watermark w.r.t. epoch\n@@ -266,1 +266,1 @@\n-  return Atomic::load_acquire(&_watermark);\n+  return AtomicAccess::load_acquire(&_watermark);\n@@ -287,1 +287,1 @@\n-  return processing_started(Atomic::load(&_state));\n+  return processing_started(AtomicAccess::load(&_state));\n@@ -291,1 +291,1 @@\n-  return processing_started(Atomic::load_acquire(&_state));\n+  return processing_started(AtomicAccess::load_acquire(&_state));\n@@ -295,1 +295,1 @@\n-  return processing_completed(Atomic::load(&_state));\n+  return processing_completed(AtomicAccess::load(&_state));\n@@ -299,1 +299,1 @@\n-  return processing_completed(Atomic::load_acquire(&_state));\n+  return processing_completed(AtomicAccess::load_acquire(&_state));\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/stackWatermarkSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -904,0 +904,2 @@\n+  do_entry(final, jbyte_arraycopy, jbyte_arraycopy_nopush,              \\\n+            jbyte_arraycopy_nopush)                                     \\\n@@ -907,0 +909,2 @@\n+  do_entry(final, jshort_arraycopy, jshort_arraycopy_nopush,            \\\n+            jshort_arraycopy_nopush)                                    \\\n@@ -910,0 +914,2 @@\n+  do_entry(final, jint_arraycopy, jint_arraycopy_nopush,                \\\n+            jint_arraycopy_nopush)                                      \\\n@@ -913,0 +919,2 @@\n+  do_entry(final, jlong_arraycopy, jlong_arraycopy_nopush,              \\\n+            jlong_arraycopy_nopush)                                     \\\n@@ -916,0 +924,2 @@\n+  do_entry(final, oop_arraycopy, oop_arraycopy_nopush,                  \\\n+            oop_arraycopy_nopush)                                       \\\n@@ -924,0 +934,3 @@\n+  do_entry(final, jbyte_disjoint_arraycopy,                             \\\n+           jbyte_disjoint_arraycopy_nopush,                             \\\n+           jbyte_disjoint_arraycopy_nopush)                             \\\n@@ -928,0 +941,3 @@\n+  do_entry(final, jshort_disjoint_arraycopy,                            \\\n+           jshort_disjoint_arraycopy_nopush,                            \\\n+           jshort_disjoint_arraycopy_nopush)                            \\\n@@ -932,0 +948,3 @@\n+  do_entry(final, jint_disjoint_arraycopy,                              \\\n+           jint_disjoint_arraycopy_nopush,                              \\\n+           jint_disjoint_arraycopy_nopush)                              \\\n@@ -936,0 +955,3 @@\n+  do_entry(final, jlong_disjoint_arraycopy,                             \\\n+           jlong_disjoint_arraycopy_nopush,                             \\\n+           jlong_disjoint_arraycopy_nopush)                             \\\n@@ -939,0 +961,3 @@\n+  do_entry(final, oop_disjoint_arraycopy,                               \\\n+           oop_disjoint_arraycopy_nopush,                               \\\n+           oop_disjoint_arraycopy_nopush)                               \\\n@@ -944,0 +969,3 @@\n+  do_entry(final, oop_disjoint_arraycopy_uninit,                        \\\n+           oop_disjoint_arraycopy_uninit_nopush,                        \\\n+           oop_disjoint_arraycopy_uninit_nopush)                        \\\n@@ -973,0 +1001,3 @@\n+  do_entry(final, arrayof_jbyte_disjoint_arraycopy,                     \\\n+           arrayof_jbyte_disjoint_arraycopy_nopush,                     \\\n+           arrayof_jbyte_disjoint_arraycopy_nopush)                     \\\n@@ -978,0 +1009,3 @@\n+  do_entry(final, arrayof_jshort_disjoint_arraycopy,                    \\\n+           arrayof_jshort_disjoint_arraycopy_nopush,                    \\\n+           arrayof_jshort_disjoint_arraycopy_nopush)                    \\\n@@ -983,0 +1017,3 @@\n+  do_entry(final, arrayof_jint_disjoint_arraycopy,                      \\\n+           arrayof_jint_disjoint_arraycopy_nopush,                      \\\n+           arrayof_jint_disjoint_arraycopy_nopush)                      \\\n@@ -988,0 +1025,3 @@\n+  do_entry(final, arrayof_jlong_disjoint_arraycopy,                     \\\n+           arrayof_jlong_disjoint_arraycopy_nopush,                     \\\n+           arrayof_jlong_disjoint_arraycopy_nopush)                     \\\n@@ -993,0 +1033,3 @@\n+  do_entry(final, arrayof_oop_disjoint_arraycopy,                       \\\n+           arrayof_oop_disjoint_arraycopy_nopush,                       \\\n+           arrayof_oop_disjoint_arraycopy_nopush)                       \\\n@@ -998,0 +1041,3 @@\n+  do_entry(final, arrayof_oop_disjoint_arraycopy_uninit,                \\\n+           arrayof_oop_disjoint_arraycopy_uninit_nopush,                \\\n+           arrayof_oop_disjoint_arraycopy_uninit_nopush)                \\\n@@ -1001,0 +1047,2 @@\n+  do_entry(final, checkcast_arraycopy, checkcast_arraycopy_nopush,      \\\n+            checkcast_arraycopy_nopush)                                 \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -81,1 +81,1 @@\n-  Atomic::store(&_suspended, is_suspend);\n+  AtomicAccess::store(&_suspended, is_suspend);\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    return Atomic::load(&_suspended);\n+    return AtomicAccess::load(&_suspended);\n","filename":"src\/hotspot\/share\/runtime\/suspendResumeManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -73,1 +73,1 @@\n-    head = Atomic::load(&_head);\n+    head = AtomicAccess::load(&_head);\n@@ -75,1 +75,1 @@\n-  } while (Atomic::cmpxchg(&_head, head, m) != head);\n+  } while (AtomicAccess::cmpxchg(&_head, head, m) != head);\n@@ -77,1 +77,1 @@\n-  size_t count = Atomic::add(&_count, 1u, memory_order_relaxed);\n+  size_t count = AtomicAccess::add(&_count, 1u, memory_order_relaxed);\n@@ -80,1 +80,1 @@\n-    old_max = Atomic::load(&_max);\n+    old_max = AtomicAccess::load(&_max);\n@@ -84,1 +84,1 @@\n-  } while (Atomic::cmpxchg(&_max, old_max, count, memory_order_relaxed) != old_max);\n+  } while (AtomicAccess::cmpxchg(&_max, old_max, count, memory_order_relaxed) != old_max);\n@@ -88,1 +88,1 @@\n-  return Atomic::load(&_count);\n+  return AtomicAccess::load(&_count);\n@@ -92,1 +92,1 @@\n-  return Atomic::load(&_max);\n+  return AtomicAccess::load(&_max);\n@@ -113,1 +113,1 @@\n-  ObjectMonitor* m = Atomic::load_acquire(&_head);\n+  ObjectMonitor* m = AtomicAccess::load_acquire(&_head);\n@@ -134,1 +134,1 @@\n-        if (prev == nullptr && Atomic::load(&_head) != m) {\n+        if (prev == nullptr && AtomicAccess::load(&_head) != m) {\n@@ -146,1 +146,1 @@\n-        ObjectMonitor* prev_head = Atomic::cmpxchg(&_head, m, next);\n+        ObjectMonitor* prev_head = AtomicAccess::cmpxchg(&_head, m, next);\n@@ -158,1 +158,1 @@\n-        assert(Atomic::load(&_head) != m, \"Sanity\");\n+        assert(AtomicAccess::load(&_head) != m, \"Sanity\");\n@@ -183,1 +183,1 @@\n-    ObjectMonitor* m = Atomic::load_acquire(&_head);\n+    ObjectMonitor* m = AtomicAccess::load_acquire(&_head);\n@@ -191,1 +191,1 @@\n-  Atomic::sub(&_count, unlinked_count);\n+  AtomicAccess::sub(&_count, unlinked_count);\n@@ -196,1 +196,1 @@\n-  return Iterator(Atomic::load_acquire(&_head));\n+  return Iterator(AtomicAccess::load_acquire(&_head));\n@@ -763,1 +763,1 @@\n-      uintptr_t v = Atomic::cmpxchg(monitor->metadata_addr(), mark.value(), temp.value());\n+      uintptr_t v = AtomicAccess::cmpxchg(monitor->metadata_addr(), mark.value(), temp.value());\n@@ -971,1 +971,1 @@\n-  Atomic::sub(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n+  AtomicAccess::sub(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n@@ -975,1 +975,1 @@\n-  Atomic::add(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n+  AtomicAccess::add(&_in_use_list_ceiling, AvgMonitorsPerThreadEstimate);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -293,1 +293,1 @@\n-  Atomic::store(&_ParkEvent, (ParkEvent*)nullptr);\n+  AtomicAccess::store(&_ParkEvent, (ParkEvent*)nullptr);\n@@ -418,1 +418,1 @@\n-    uintx res = Atomic::cmpxchg(&_threads_do_token, token, claim_token);\n+    uintx res = AtomicAccess::cmpxchg(&_threads_do_token, token, claim_token);\n@@ -578,1 +578,1 @@\n-  if (Atomic::cmpxchg(adr, 0, 1) == 0) {\n+  if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) {\n@@ -599,1 +599,1 @@\n-    if (Atomic::cmpxchg(adr, 0, 1) == 0) return;\n+    if (AtomicAccess::cmpxchg(adr, 0, 1) == 0) return;\n@@ -614,1 +614,1 @@\n-  Atomic::release_store(adr, 0);\n+  AtomicAccess::release_store(adr, 0);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -601,1 +601,1 @@\n-  bool has_terminated()                       { return Atomic::load(&_ParkEvent) == nullptr; };\n+  bool has_terminated()                       { return AtomicAccess::load(&_ParkEvent) == nullptr; };\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -39,1 +39,1 @@\n-  jlong allocated_bytes = Atomic::load_acquire(&_allocated_bytes);\n+  jlong allocated_bytes = AtomicAccess::load_acquire(&_allocated_bytes);\n@@ -62,1 +62,1 @@\n-  return (ThreadsList*)Atomic::cmpxchg(&_threads_hazard_ptr, compare_value, exchange_value);\n+  return (ThreadsList*)AtomicAccess::cmpxchg(&_threads_hazard_ptr, compare_value, exchange_value);\n@@ -66,1 +66,1 @@\n-  return (ThreadsList*)Atomic::load_acquire(&_threads_hazard_ptr);\n+  return (ThreadsList*)AtomicAccess::load_acquire(&_threads_hazard_ptr);\n@@ -70,1 +70,1 @@\n-  Atomic::release_store_fence(&_threads_hazard_ptr, new_list);\n+  AtomicAccess::release_store_fence(&_threads_hazard_ptr, new_list);\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -443,1 +443,1 @@\n-  return Atomic::load_acquire(&_sampling_interval);\n+  return AtomicAccess::load_acquire(&_sampling_interval);\n@@ -447,1 +447,1 @@\n-  Atomic::release_store(&_sampling_interval, sampling_interval);\n+  AtomicAccess::release_store(&_sampling_interval, sampling_interval);\n","filename":"src\/hotspot\/share\/runtime\/threadHeapSampler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -41,1 +41,1 @@\n-  return Atomic::load(&next_thread_id);\n+  return AtomicAccess::load(&next_thread_id);\n@@ -47,2 +47,2 @@\n-    next_tid = Atomic::load(&next_thread_id);\n-  } while (Atomic::cmpxchg(&next_thread_id, next_tid, next_tid + 1) != next_tid);\n+    next_tid = AtomicAccess::load(&next_thread_id);\n+  } while (AtomicAccess::cmpxchg(&next_thread_id, next_tid, next_tid + 1) != next_tid);\n","filename":"src\/hotspot\/share\/runtime\/threadIdentifier.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -71,1 +71,1 @@\n-\/\/ unsigned since this is a time value. Set via Atomic::cmpxchg() in a\n+\/\/ unsigned since this is a time value. Set via AtomicAccess::cmpxchg() in a\n@@ -119,1 +119,1 @@\n-\/\/ unsigned since this is a time value. Set via Atomic::cmpxchg() in a\n+\/\/ unsigned since this is a time value. Set via AtomicAccess::cmpxchg() in a\n@@ -143,1 +143,1 @@\n-  Atomic::add(&_deleted_thread_times, add_value);\n+  AtomicAccess::add(&_deleted_thread_times, add_value);\n@@ -147,1 +147,1 @@\n-  Atomic::inc(&_deleted_thread_cnt);\n+  AtomicAccess::inc(&_deleted_thread_cnt);\n@@ -165,1 +165,1 @@\n-    if (Atomic::cmpxchg(&_deleted_thread_time_max, cur_value, new_value) == cur_value) {\n+    if (AtomicAccess::cmpxchg(&_deleted_thread_time_max, cur_value, new_value) == cur_value) {\n@@ -179,1 +179,1 @@\n-  return (ThreadsList*)Atomic::xchg(&_java_thread_list, new_list);\n+  return (ThreadsList*)AtomicAccess::xchg(&_java_thread_list, new_list);\n@@ -693,1 +693,1 @@\n-  Atomic::dec(&_nested_handle_cnt);\n+  AtomicAccess::dec(&_nested_handle_cnt);\n@@ -736,1 +736,1 @@\n-  Atomic::inc(&_nested_handle_cnt);\n+  AtomicAccess::inc(&_nested_handle_cnt);\n@@ -898,1 +898,1 @@\n-  Atomic::dec(&_delete_notify);\n+  AtomicAccess::dec(&_delete_notify);\n@@ -904,1 +904,1 @@\n-  return (Atomic::load_acquire(&_delete_notify) != 0);\n+  return (AtomicAccess::load_acquire(&_delete_notify) != 0);\n@@ -1057,1 +1057,1 @@\n-  Atomic::inc(&_delete_notify);\n+  AtomicAccess::inc(&_delete_notify);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -117,1 +117,1 @@\n-  Atomic::add(&_tlh_times, add_value);\n+  AtomicAccess::add(&_tlh_times, add_value);\n@@ -121,1 +121,1 @@\n-  Atomic::inc(&_tlh_cnt);\n+  AtomicAccess::inc(&_tlh_cnt);\n@@ -131,1 +131,1 @@\n-    if (Atomic::cmpxchg(&_tlh_time_max, cur_value, new_value) == cur_value) {\n+    if (AtomicAccess::cmpxchg(&_tlh_time_max, cur_value, new_value) == cur_value) {\n@@ -139,1 +139,1 @@\n-  return (ThreadsList*)Atomic::load_acquire(&_java_thread_list);\n+  return (ThreadsList*)AtomicAccess::load_acquire(&_java_thread_list);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeHeapTrimmer_lock\")),\n+    _lock(new PaddedMonitor(Mutex::nosafepoint, \"NativeHeapTrimmer_lock\")),\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -671,0 +671,8 @@\n+  \/******************************************************************************************\/                                       \\\n+  \/* CI (NOTE: these CI fields are retained in VMStructs for the benefit of external tools, *\/                                       \\\n+  \/* to ease their migration to a future alternative.)                                      *\/                                       \\\n+  \/******************************************************************************************\/                                       \\\n+                                                                                                                                     \\\n+  nonstatic_field(CompilerThread,              _env,                                          ciEnv*)                                \\\n+  nonstatic_field(ciEnv,                       _task,                                         CompileTask*)                          \\\n+                                                                                                                                     \\\n@@ -1156,0 +1164,6 @@\n+  \/*********************\/                                                 \\\n+  \/* CI *\/                                                                \\\n+  \/*********************\/                                                 \\\n+                                                                          \\\n+  declare_toplevel_type(ciEnv)                                            \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -71,1 +71,1 @@\n-  return Atomic::load_acquire(&_armed) != 0;\n+  return AtomicAccess::load_acquire(&_armed) != 0;\n@@ -77,1 +77,1 @@\n-  Atomic::release_store_fence(&_armed, 1);\n+  AtomicAccess::release_store_fence(&_armed, 1);\n@@ -81,1 +81,1 @@\n-  Atomic::release_store_fence(&_armed, 0);\n+  AtomicAccess::release_store_fence(&_armed, 0);\n@@ -160,1 +160,1 @@\n-  Atomic::store(&_is_running, true);\n+  AtomicAccess::store(&_is_running, true);\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -91,1 +91,1 @@\n-  bool is_running() const { return Atomic::load(&_is_running); }\n+  bool is_running() const { return AtomicAccess::load(&_is_running); }\n","filename":"src\/hotspot\/share\/runtime\/vmThread.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -126,1 +126,1 @@\n-    Atomic::store(&_state, new_state);\n+    AtomicAccess::store(&_state, new_state);\n@@ -130,1 +130,1 @@\n-    return Atomic::load(&_state);\n+    return AtomicAccess::load(&_state);\n@@ -135,1 +135,1 @@\n-    return Atomic::cmpxchg(&_state, cmp_state, new_state);\n+    return AtomicAccess::cmpxchg(&_state, cmp_state, new_state);\n@@ -139,1 +139,1 @@\n-    return Atomic::load(&_state) == AL_INITIALIZED;\n+    return AtomicAccess::load(&_state) == AL_INITIALIZED;\n@@ -143,1 +143,1 @@\n-    Atomic::store(&_state, AL_INITIALIZED);\n+    AtomicAccess::store(&_state, AL_INITIALIZED);\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  return Atomic::load(&_has_error);\n+  return AtomicAccess::load(&_has_error);\n@@ -83,1 +83,1 @@\n-  Atomic::store(&_has_error, true);\n+  AtomicAccess::store(&_has_error, true);\n","filename":"src\/hotspot\/share\/services\/cpuTimeUsage.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -108,1 +108,1 @@\n-  return Atomic::load(&_objects_on_heap);\n+  return AtomicAccess::load(&_objects_on_heap);\n@@ -112,1 +112,1 @@\n-  return Atomic::load(&_total_finalizers_run);\n+  return AtomicAccess::load(&_total_finalizers_run);\n@@ -116,1 +116,1 @@\n-  Atomic::inc(&_objects_on_heap, memory_order_relaxed);\n+  AtomicAccess::inc(&_objects_on_heap, memory_order_relaxed);\n@@ -120,2 +120,2 @@\n-  Atomic::inc(&_total_finalizers_run, memory_order_relaxed);\n-  Atomic::dec(&_objects_on_heap, memory_order_relaxed);\n+  AtomicAccess::inc(&_total_finalizers_run, memory_order_relaxed);\n+  AtomicAccess::dec(&_objects_on_heap, memory_order_relaxed);\n@@ -196,1 +196,1 @@\n-  Atomic::store(&_has_work, value);\n+  AtomicAccess::store(&_has_work, value);\n@@ -200,1 +200,1 @@\n-  return Atomic::load(&_has_work);\n+  return AtomicAccess::load(&_has_work);\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2224,2 +2224,2 @@\n-    _thread_serial_num = Atomic::fetch_then_add(thread_counter, 1);\n-    _start_frame_serial_num = Atomic::fetch_then_add(frame_counter, frame_count());\n+    _thread_serial_num = AtomicAccess::fetch_then_add(thread_counter, 1);\n+    _start_frame_serial_num = AtomicAccess::fetch_then_add(frame_counter, frame_count());\n@@ -2766,1 +2766,1 @@\n-    return Atomic::fetch_then_add(&_dump_seq, 1);\n+    return AtomicAccess::fetch_then_add(&_dump_seq, 1);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/services\/lowMemoryDetector.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -63,1 +63,1 @@\n-  if (Atomic::load_acquire(&_memory_mgr_obj_initialized)) {\n+  if (AtomicAccess::load_acquire(&_memory_mgr_obj_initialized)) {\n@@ -82,1 +82,1 @@\n-  if (!Atomic::load_acquire(&_memory_mgr_obj_initialized)) {\n+  if (!AtomicAccess::load_acquire(&_memory_mgr_obj_initialized)) {\n@@ -139,1 +139,1 @@\n-    if (Atomic::load(&_memory_mgr_obj_initialized)) {\n+    if (AtomicAccess::load(&_memory_mgr_obj_initialized)) {\n@@ -150,1 +150,1 @@\n-      Atomic::release_store(&_memory_mgr_obj_initialized, true);\n+      AtomicAccess::release_store(&_memory_mgr_obj_initialized, true);\n","filename":"src\/hotspot\/share\/services\/memoryManager.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -70,1 +70,1 @@\n-  if (Atomic::load_acquire(&_memory_pool_obj_initialized)) {\n+  if (AtomicAccess::load_acquire(&_memory_pool_obj_initialized)) {\n@@ -93,1 +93,1 @@\n-  if (!Atomic::load_acquire(&_memory_pool_obj_initialized)) {\n+  if (!AtomicAccess::load_acquire(&_memory_pool_obj_initialized)) {\n@@ -134,1 +134,1 @@\n-    if (Atomic::load(&_memory_pool_obj_initialized)) {\n+    if (AtomicAccess::load(&_memory_pool_obj_initialized)) {\n@@ -145,1 +145,1 @@\n-      Atomic::release_store(&_memory_pool_obj_initialized, true);\n+      AtomicAccess::release_store(&_memory_pool_obj_initialized, true);\n","filename":"src\/hotspot\/share\/services\/memoryPool.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -123,1 +123,1 @@\n-  Atomic::inc(&_items_count);\n+  AtomicAccess::inc(&_items_count);\n@@ -128,1 +128,1 @@\n-  Atomic::dec(&_items_count);\n+  AtomicAccess::dec(&_items_count);\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -143,1 +143,1 @@\n-  Atomic::inc(&_atomic_threads_count);\n+  AtomicAccess::inc(&_atomic_threads_count);\n@@ -152,1 +152,1 @@\n-    Atomic::inc(&_atomic_daemon_threads_count);\n+    AtomicAccess::inc(&_atomic_daemon_threads_count);\n@@ -157,1 +157,1 @@\n-  Atomic::dec(&_atomic_threads_count);\n+  AtomicAccess::dec(&_atomic_threads_count);\n@@ -160,1 +160,1 @@\n-    Atomic::dec(&_atomic_daemon_threads_count);\n+    AtomicAccess::dec(&_atomic_daemon_threads_count);\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  static jlong exited_allocated_bytes()       { return Atomic::load(&_exited_allocated_bytes); }\n+  static jlong exited_allocated_bytes()       { return AtomicAccess::load(&_exited_allocated_bytes); }\n@@ -114,1 +114,1 @@\n-    Atomic::store(&_exited_allocated_bytes, _exited_allocated_bytes + size);\n+    AtomicAccess::store(&_exited_allocated_bytes, _exited_allocated_bytes + size);\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -246,1 +246,1 @@\n-    bm_word_t w = Atomic::load(pw);\n+    bm_word_t w = AtomicAccess::load(pw);\n@@ -250,1 +250,1 @@\n-      bm_word_t res = Atomic::cmpxchg(pw, w, nw);\n+      bm_word_t res = AtomicAccess::cmpxchg(pw, w, nw);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -47,1 +47,1 @@\n-    return Atomic::load(addr);\n+    return AtomicAccess::load(addr);\n@@ -53,1 +53,1 @@\n-    return Atomic::load_acquire(addr);\n+    return AtomicAccess::load_acquire(addr);\n@@ -77,1 +77,1 @@\n-    const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);\n+    const bm_word_t cur_val = AtomicAccess::cmpxchg(addr, old_val, new_val, memory_order);\n@@ -96,1 +96,1 @@\n-    const bm_word_t cur_val = Atomic::cmpxchg(addr, old_val, new_val, memory_order);\n+    const bm_word_t cur_val = AtomicAccess::cmpxchg(addr, old_val, new_val, memory_order);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-\/\/ FORBID_C_FUNCTION(Signature, Alternative)\n+\/\/ FORBID_C_FUNCTION(Signature, Noexcept, Alternative)\n@@ -91,0 +91,1 @@\n+\/\/ - Noexcept: either the token `noexcept` or nothing. See below.\n@@ -96,0 +97,12 @@\n+\/\/ The Noexcept argument is used to deal with differences among the standard\n+\/\/ libraries of various platforms.  For example, the C standard library on\n+\/\/ Linux declares many functions `noexcept`. Windows and BSD C standard\n+\/\/ libraries don't include exception specifications at all. This matters\n+\/\/ because some compilers reject (some) differences between declarations that\n+\/\/ differ in the exception specification. clang complains if the first\n+\/\/ declaration is not noexcept while some later declaration is, but not the\n+\/\/ reverse. gcc doesn't seem to care. (Maybe that's a gcc bug?) So if the\n+\/\/ forbidding declaration differs from the platform's library then we may get\n+\/\/ errors building with clang (but not gcc), depending on the difference and\n+\/\/ the include order.\n+\/\/\n@@ -105,2 +118,15 @@\n-#define FORBID_C_FUNCTION(Signature, Alternative) \\\n-  extern \"C\" { [[deprecated(Alternative)]] Signature; }\n+#define FORBID_C_FUNCTION(Signature, Noexcept, Alternative)     \\\n+  extern \"C\" {                                                  \\\n+    [[deprecated(Alternative)]]                                 \\\n+    Signature                                                   \\\n+    \/* 2-step pasting to avoid expansion of FFCN => nothing. *\/ \\\n+    PASTE_TOKENS(                                               \\\n+      FORBIDDEN_FUNCTION_,                                      \\\n+      PASTE_TOKENS(COND_NOEXCEPT_, Noexcept))                   \\\n+    ;                                                           \\\n+  }\n+\n+\/\/ Both Linux and AIX C libraries declare functions noexcept.\n+\/\/ Neither BSD nor Windows C libraries declare functions noexcept.\n+#define FORBIDDEN_FUNCTION_COND_NOEXCEPT_noexcept NOT_WINDOWS(NOT_BSD(noexcept))\n+#define FORBIDDEN_FUNCTION_COND_NOEXCEPT_\n@@ -120,2 +146,2 @@\n-#define FORBID_IMPORTED_C_FUNCTION(Signature, Alternative) \\\n-  FORBID_C_FUNCTION(FORBIDDEN_FUNCTION_IMPORT_SPEC Signature, Alternative)\n+#define FORBID_IMPORTED_C_FUNCTION(Signature, Noexcept, Alternative) \\\n+  FORBID_C_FUNCTION(FORBIDDEN_FUNCTION_IMPORT_SPEC Signature, Noexcept, Alternative)\n@@ -123,2 +149,2 @@\n-#define FORBID_NORETURN_C_FUNCTION(Signature, Alternative) \\\n-  FORBID_C_FUNCTION(FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE Signature, Alternative)\n+#define FORBID_NORETURN_C_FUNCTION(Signature, Noexcept, Alternative) \\\n+  FORBID_C_FUNCTION(FORBIDDEN_FUNCTION_NORETURN_ATTRIBUTE Signature, Noexcept, Alternative)\n@@ -126,2 +152,2 @@\n-#define FORBID_IMPORTED_NORETURN_C_FUNCTION(Signature, Alternative) \\\n-  FORBID_NORETURN_C_FUNCTION(FORBIDDEN_FUNCTION_IMPORT_SPEC Signature, Alternative)\n+#define FORBID_IMPORTED_NORETURN_C_FUNCTION(Signature, Noexcept, Alternative) \\\n+  FORBID_NORETURN_C_FUNCTION(FORBIDDEN_FUNCTION_IMPORT_SPEC Signature, Noexcept, Alternative)\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings.hpp","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -66,1 +66,1 @@\n-  return Atomic::load_acquire(&_next);\n+  return AtomicAccess::load_acquire(&_next);\n@@ -75,1 +75,1 @@\n-  return Atomic::load_acquire(&_first);\n+  return AtomicAccess::load_acquire(&_first);\n@@ -87,1 +87,1 @@\n-  Atomic::release_store(tmp, clear_set_state(node, *dst));\n+  AtomicAccess::release_store(tmp, clear_set_state(node, *dst));\n@@ -96,1 +96,1 @@\n-  return clear_state(Atomic::load_acquire(&_first));\n+  return clear_state(AtomicAccess::load_acquire(&_first));\n@@ -153,1 +153,1 @@\n-  if (Atomic::cmpxchg(&_first, expect, node) == expect) {\n+  if (AtomicAccess::cmpxchg(&_first, expect, node) == expect) {\n@@ -168,1 +168,1 @@\n-  if (Atomic::cmpxchg(&_first, tmp, set_state(tmp, STATE_LOCK_BIT)) == tmp) {\n+  if (AtomicAccess::cmpxchg(&_first, tmp, set_state(tmp, STATE_LOCK_BIT)) == tmp) {\n@@ -181,1 +181,1 @@\n-  Atomic::release_store(&_first, clear_state(first()));\n+  AtomicAccess::release_store(&_first, clear_state(first()));\n@@ -189,1 +189,1 @@\n-  Atomic::release_store(&_first, set_state(_first, STATE_REDIRECT_BIT));\n+  AtomicAccess::release_store(&_first, set_state(_first, STATE_REDIRECT_BIT));\n@@ -225,2 +225,2 @@\n-  if (Atomic::load_acquire(&_cht->_invisible_epoch) != nullptr) {\n-    Atomic::release_store_fence(&_cht->_invisible_epoch, (Thread*)nullptr);\n+  if (AtomicAccess::load_acquire(&_cht->_invisible_epoch) != nullptr) {\n+    AtomicAccess::release_store_fence(&_cht->_invisible_epoch, (Thread*)nullptr);\n@@ -297,1 +297,1 @@\n-  if (Atomic::load_acquire(&_invisible_epoch) == thread) {\n+  if (AtomicAccess::load_acquire(&_invisible_epoch) == thread) {\n@@ -303,1 +303,1 @@\n-  Atomic::release_store(&_invisible_epoch, thread);\n+  AtomicAccess::release_store(&_invisible_epoch, thread);\n@@ -382,1 +382,1 @@\n-  return Atomic::load_acquire(&_table);\n+  return AtomicAccess::load_acquire(&_table);\n@@ -390,1 +390,1 @@\n-  return Atomic::load_acquire(&_new_table);\n+  return AtomicAccess::load_acquire(&_new_table);\n@@ -400,1 +400,1 @@\n-  Atomic::release_store(&_table, _new_table);\n+  AtomicAccess::release_store(&_table, _new_table);\n@@ -800,1 +800,1 @@\n-  Atomic::release_store(&_table, table);\n+  AtomicAccess::release_store(&_table, table);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -65,2 +65,2 @@\n-      if (Atomic::load(&_next) < _limit) {\n-        size_t claimed = Atomic::fetch_then_add(&_next, _size);\n+      if (AtomicAccess::load(&_next) < _limit) {\n+        size_t claimed = AtomicAccess::fetch_then_add(&_next, _size);\n@@ -81,1 +81,1 @@\n-      return Atomic::load_acquire(&_next) >= _limit;\n+      return AtomicAccess::load_acquire(&_next) >= _limit;\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTableTasks.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -308,8 +308,8 @@\n-    case 8:  Atomic::store(&to[7], Atomic::load(&from[7]));\n-    case 7:  Atomic::store(&to[6], Atomic::load(&from[6]));\n-    case 6:  Atomic::store(&to[5], Atomic::load(&from[5]));\n-    case 5:  Atomic::store(&to[4], Atomic::load(&from[4]));\n-    case 4:  Atomic::store(&to[3], Atomic::load(&from[3]));\n-    case 3:  Atomic::store(&to[2], Atomic::load(&from[2]));\n-    case 2:  Atomic::store(&to[1], Atomic::load(&from[1]));\n-    case 1:  Atomic::store(&to[0], Atomic::load(&from[0]));\n+    case 8:  AtomicAccess::store(&to[7], AtomicAccess::load(&from[7]));\n+    case 7:  AtomicAccess::store(&to[6], AtomicAccess::load(&from[6]));\n+    case 6:  AtomicAccess::store(&to[5], AtomicAccess::load(&from[5]));\n+    case 5:  AtomicAccess::store(&to[4], AtomicAccess::load(&from[4]));\n+    case 4:  AtomicAccess::store(&to[3], AtomicAccess::load(&from[3]));\n+    case 3:  AtomicAccess::store(&to[2], AtomicAccess::load(&from[2]));\n+    case 2:  AtomicAccess::store(&to[1], AtomicAccess::load(&from[1]));\n+    case 1:  AtomicAccess::store(&to[0], AtomicAccess::load(&from[0]));\n@@ -319,1 +319,1 @@\n-        Atomic::store(to++, Atomic::load(from++));\n+        AtomicAccess::store(to++, AtomicAccess::load(from++));\n","filename":"src\/hotspot\/share\/utilities\/copy.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -269,1 +269,1 @@\n-  if (Atomic::cmpxchg(&out_of_memory_reported, 0, 1) == 0) {\n+  if (AtomicAccess::cmpxchg(&out_of_memory_reported, 0, 1) == 0) {\n@@ -788,1 +788,1 @@\n-    if (Atomic::cmpxchg(&g_asserting_thread, (intx)0, my_tid) == 0) {\n+    if (AtomicAccess::cmpxchg(&g_asserting_thread, (intx)0, my_tid) == 0) {\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -54,1 +54,1 @@\n-    old_head = Atomic::load(&Events::_logs);\n+    old_head = AtomicAccess::load(&Events::_logs);\n@@ -56,1 +56,1 @@\n-  } while (Atomic::cmpxchg(&Events::_logs, old_head, this) != old_head);\n+  } while (AtomicAccess::cmpxchg(&Events::_logs, old_head, this) != old_head);\n@@ -62,1 +62,1 @@\n-  EventLog* log = Atomic::load(&Events::_logs);\n+  EventLog* log = AtomicAccess::load(&Events::_logs);\n@@ -71,1 +71,1 @@\n-  EventLog* log = Atomic::load(&Events::_logs);\n+  EventLog* log = AtomicAccess::load(&Events::_logs);\n@@ -84,1 +84,1 @@\n-    EventLog* log = Atomic::load(&Events::_logs);\n+    EventLog* log = AtomicAccess::load(&Events::_logs);\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -180,1 +180,1 @@\n-    Atomic::inc(&_linkage_errors, memory_order_relaxed);\n+    AtomicAccess::inc(&_linkage_errors, memory_order_relaxed);\n@@ -256,1 +256,1 @@\n-    Atomic::inc(&Exceptions::_stack_overflow_errors, memory_order_relaxed);\n+    AtomicAccess::inc(&Exceptions::_stack_overflow_errors, memory_order_relaxed);\n@@ -498,1 +498,1 @@\n-     Atomic::inc(&_out_of_memory_error_metaspace_errors, memory_order_relaxed);\n+     AtomicAccess::inc(&_out_of_memory_error_metaspace_errors, memory_order_relaxed);\n@@ -500,1 +500,1 @@\n-     Atomic::inc(&_out_of_memory_error_class_metaspace_errors, memory_order_relaxed);\n+     AtomicAccess::inc(&_out_of_memory_error_class_metaspace_errors, memory_order_relaxed);\n@@ -503,1 +503,1 @@\n-     Atomic::inc(&_out_of_memory_error_java_heap_errors, memory_order_relaxed);\n+     AtomicAccess::inc(&_out_of_memory_error_java_heap_errors, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -47,1 +47,1 @@\n-    return Atomic::load_acquire(&_first);\n+    return AtomicAccess::load_acquire(&_first);\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    if (Atomic::cmpxchg(&_first, head, insnode) == head) {\n+    if (AtomicAccess::cmpxchg(&_first, head, insnode) == head) {\n@@ -94,1 +94,1 @@\n-      if (Atomic::cmpxchg(&_first, match, match->_next) == match) {\n+      if (AtomicAccess::cmpxchg(&_first, match, match->_next) == match) {\n","filename":"src\/hotspot\/share\/utilities\/filterQueue.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,9 +41,0 @@\n-\/\/ Workaround for noexcept functions in glibc when using clang.\n-\/\/ clang errors if declaration without exception specification preceeds\n-\/\/ noexcept declaration, but not the other way around.\n-#ifdef __clang__\n-#include <stdio.h>\n-#include <string.h>\n-#include <wchar.h>\n-#endif\n-\n@@ -61,2 +52,2 @@\n-FORBID_IMPORTED_NORETURN_C_FUNCTION(void exit(int), \"use os::exit\")\n-FORBID_IMPORTED_NORETURN_C_FUNCTION(void _Exit(int), \"use os::exit\")\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void exit(int), noexcept, \"use os::exit\")\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void _Exit(int), noexcept, \"use os::exit\")\n@@ -65,1 +56,1 @@\n-FORBID_IMPORTED_NORETURN_C_FUNCTION(void _exit(int), \"use os::exit\")\n+FORBID_IMPORTED_NORETURN_C_FUNCTION(void _exit(int), \/* not noexcept *\/, \"use os::exit\")\n@@ -67,2 +58,2 @@\n-FORBID_IMPORTED_C_FUNCTION(char* strerror(int), \"use os::strerror\");\n-FORBID_IMPORTED_C_FUNCTION(char* strtok(char*, const char*), \"use strtok_r\");\n+FORBID_IMPORTED_C_FUNCTION(char* strerror(int), noexcept, \"use os::strerror\");\n+FORBID_IMPORTED_C_FUNCTION(char* strtok(char*, const char*), noexcept, \"use strtok_r\");\n@@ -70,2 +61,5 @@\n-FORBID_C_FUNCTION(int sprintf(char*, const char*, ...), \"use os::snprintf\");\n-FORBID_C_FUNCTION(int snprintf(char*, size_t, const char*, ...), \"use os::snprintf\");\n+\/\/ AIX declarations for sprintf and snprintf are not noexcept, which is\n+\/\/ inconsistent with most other system header declarations, including being\n+\/\/ inconsistent with vsprintf and fsnprintf.\n+FORBID_C_FUNCTION(int sprintf(char*, const char*, ...), NOT_AIX(noexcept), \"use os::snprintf\");\n+FORBID_C_FUNCTION(int snprintf(char*, size_t, const char*, ...), NOT_AIX(noexcept), \"use os::snprintf\");\n@@ -75,2 +69,2 @@\n-FORBID_C_FUNCTION(int vsprintf(char*, const char*, va_list), \"use os::vsnprintf\");\n-FORBID_C_FUNCTION(int vsnprintf(char*, size_t, const char*, va_list), \"use os::vsnprintf\");\n+FORBID_C_FUNCTION(int vsprintf(char*, const char*, va_list), noexcept, \"use os::vsnprintf\");\n+FORBID_C_FUNCTION(int vsnprintf(char*, size_t, const char*, va_list), noexcept, \"use os::vsnprintf\");\n@@ -82,6 +76,6 @@\n-FORBID_IMPORTED_C_FUNCTION(void* malloc(size_t size), \"use os::malloc\");\n-FORBID_IMPORTED_C_FUNCTION(void free(void *ptr), \"use os::free\");\n-FORBID_IMPORTED_C_FUNCTION(void* calloc(size_t nmemb, size_t size), \"use os::malloc and zero out manually\");\n-FORBID_IMPORTED_C_FUNCTION(void* realloc(void *ptr, size_t size), \"use os::realloc\");\n-FORBID_IMPORTED_C_FUNCTION(char* strdup(const char *s), \"use os::strdup\");\n-FORBID_IMPORTED_C_FUNCTION(wchar_t* wcsdup(const wchar_t *s), \"don't use\");\n+FORBID_IMPORTED_C_FUNCTION(void* malloc(size_t size), noexcept, \"use os::malloc\");\n+FORBID_IMPORTED_C_FUNCTION(void free(void *ptr), noexcept, \"use os::free\");\n+FORBID_IMPORTED_C_FUNCTION(void* calloc(size_t nmemb, size_t size), noexcept, \"use os::malloc and zero out manually\");\n+FORBID_IMPORTED_C_FUNCTION(void* realloc(void *ptr, size_t size), noexcept, \"use os::realloc\");\n+FORBID_IMPORTED_C_FUNCTION(char* strdup(const char *s), noexcept, \"use os::strdup\");\n+FORBID_IMPORTED_C_FUNCTION(wchar_t* wcsdup(const wchar_t *s), noexcept, \"don't use\");\n","filename":"src\/hotspot\/share\/utilities\/forbiddenFunctions.hpp","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -44,1 +44,1 @@\n-      uintx cnt = Atomic::load_acquire(thread->get_rcu_counter());\n+      uintx cnt = AtomicAccess::load_acquire(thread->get_rcu_counter());\n@@ -61,2 +61,2 @@\n-  \/\/ Atomic::add must provide fence since we have storeload dependency.\n-  uintx gbl_cnt = Atomic::add(&_global_counter._counter, COUNTER_INCREMENT);\n+  \/\/ AtomicAccess::add must provide fence since we have storeload dependency.\n+  uintx gbl_cnt = AtomicAccess::add(&_global_counter._counter, COUNTER_INCREMENT);\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -36,1 +36,1 @@\n-  uintx old_cnt = Atomic::load(thread->get_rcu_counter());\n+  uintx old_cnt = AtomicAccess::load(thread->get_rcu_counter());\n@@ -41,1 +41,1 @@\n-    new_cnt = Atomic::load(&_global_counter._counter) | COUNTER_ACTIVE;\n+    new_cnt = AtomicAccess::load(&_global_counter._counter) | COUNTER_ACTIVE;\n@@ -43,1 +43,1 @@\n-  Atomic::release_store_fence(thread->get_rcu_counter(), new_cnt);\n+  AtomicAccess::release_store_fence(thread->get_rcu_counter(), new_cnt);\n@@ -52,2 +52,2 @@\n-  Atomic::release_store(thread->get_rcu_counter(),\n-                        static_cast<uintx>(context));\n+  AtomicAccess::release_store(thread->get_rcu_counter(),\n+                              static_cast<uintx>(context));\n","filename":"src\/hotspot\/share\/utilities\/globalCounter.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -68,1 +68,1 @@\n-      cur = Atomic::cmpxchg(&_top, cur, first);\n+      cur = AtomicAccess::cmpxchg(&_top, cur, first);\n@@ -92,1 +92,1 @@\n-      result = Atomic::cmpxchg(&_top, result, new_top);\n+      result = AtomicAccess::cmpxchg(&_top, result, new_top);\n@@ -104,1 +104,1 @@\n-    return Atomic::xchg(&_top, (T*)nullptr);\n+    return AtomicAccess::xchg(&_top, (T*)nullptr);\n@@ -148,1 +148,1 @@\n-  T* top() const { return Atomic::load(&_top); }\n+  T* top() const { return AtomicAccess::load(&_top); }\n@@ -163,1 +163,1 @@\n-    return Atomic::load(next_ptr(const_cast<T&>(value)));\n+    return AtomicAccess::load(next_ptr(const_cast<T&>(value)));\n@@ -171,1 +171,1 @@\n-    Atomic::store(next_ptr(value), new_next);\n+    AtomicAccess::store(next_ptr(value), new_next);\n","filename":"src\/hotspot\/share\/utilities\/lockFreeStack.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -34,1 +34,1 @@\n-  return Atomic::load(next_ptr(const_cast<T&>(node)));\n+  return AtomicAccess::load(next_ptr(const_cast<T&>(node)));\n@@ -39,1 +39,1 @@\n-  Atomic::store(next_ptr(node), new_next);\n+  AtomicAccess::store(next_ptr(node), new_next);\n@@ -63,1 +63,1 @@\n-  T* head = Atomic::load(&_head);\n+  T* head = AtomicAccess::load(&_head);\n@@ -74,1 +74,1 @@\n-  return Atomic::load(&_head) == nullptr;\n+  return AtomicAccess::load(&_head) == nullptr;\n@@ -108,1 +108,1 @@\n-  T* old_tail = Atomic::xchg(&_tail, &last);\n+  T* old_tail = AtomicAccess::xchg(&_tail, &last);\n@@ -113,1 +113,1 @@\n-    assert(Atomic::load(&_head) == nullptr, \"invariant\");\n+    assert(AtomicAccess::load(&_head) == nullptr, \"invariant\");\n@@ -115,1 +115,1 @@\n-  } else if (is_end(Atomic::cmpxchg(next_ptr(*old_tail), end_marker(), &first))) {\n+  } else if (is_end(AtomicAccess::cmpxchg(next_ptr(*old_tail), end_marker(), &first))) {\n@@ -131,1 +131,1 @@\n-    DEBUG_ONLY(T* old_head = Atomic::load(&_head);)\n+    DEBUG_ONLY(T* old_head = AtomicAccess::load(&_head);)\n@@ -137,1 +137,1 @@\n-  Atomic::store(&_head, &first);\n+  AtomicAccess::store(&_head, &first);\n@@ -144,1 +144,1 @@\n-  T* old_head = Atomic::load_acquire(&_head);\n+  T* old_head = AtomicAccess::load_acquire(&_head);\n@@ -150,1 +150,1 @@\n-  T* next_node = Atomic::load_acquire(next_ptr(*old_head));\n+  T* next_node = AtomicAccess::load_acquire(next_ptr(*old_head));\n@@ -163,1 +163,1 @@\n-    if (old_head != Atomic::cmpxchg(&_head, old_head, next_node)) {\n+    if (old_head != AtomicAccess::cmpxchg(&_head, old_head, next_node)) {\n@@ -191,1 +191,1 @@\n-  } else if (is_end(Atomic::cmpxchg(next_ptr(*old_head), next_node, (T*)nullptr))) {\n+  } else if (is_end(AtomicAccess::cmpxchg(next_ptr(*old_head), next_node, (T*)nullptr))) {\n@@ -206,1 +206,1 @@\n-    Atomic::cmpxchg(&_head, old_head, (T*)nullptr);\n+    AtomicAccess::cmpxchg(&_head, old_head, (T*)nullptr);\n@@ -212,1 +212,1 @@\n-    Atomic::cmpxchg(&_tail, old_head, (T*)nullptr);\n+    AtomicAccess::cmpxchg(&_tail, old_head, (T*)nullptr);\n@@ -240,1 +240,1 @@\n-  T* tail = Atomic::load(&_tail);\n+  T* tail = AtomicAccess::load(&_tail);\n@@ -242,3 +242,3 @@\n-  Pair<T*, T*> result(Atomic::load(&_head), tail);\n-  Atomic::store(&_head, (T*)nullptr);\n-  Atomic::store(&_tail, (T*)nullptr);\n+  Pair<T*, T*> result(AtomicAccess::load(&_head), tail);\n+  AtomicAccess::store(&_head, (T*)nullptr);\n+  AtomicAccess::store(&_tail, (T*)nullptr);\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -46,1 +46,1 @@\n-  assert(Atomic::add(&_writers, 1u) == 1u, \"multiple writers\");\n+  assert(AtomicAccess::add(&_writers, 1u) == 1u, \"multiple writers\");\n@@ -66,1 +66,1 @@\n-    value = Atomic::cmpxchg(&_enter, old, value);\n+    value = AtomicAccess::cmpxchg(&_enter, old, value);\n@@ -87,1 +87,1 @@\n-  while (old != Atomic::load_acquire(old_ptr)) {\n+  while (old != AtomicAccess::load_acquire(old_ptr)) {\n@@ -98,1 +98,1 @@\n-  DEBUG_ONLY(Atomic::dec(&_writers);)\n+  DEBUG_ONLY(AtomicAccess::dec(&_writers);)\n","filename":"src\/hotspot\/share\/utilities\/singleWriterSynchronizer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -90,1 +90,1 @@\n-  return Atomic::add(&_enter, 2u);\n+  return AtomicAccess::add(&_enter, 2u);\n@@ -94,1 +94,1 @@\n-  uint exit_value = Atomic::add(&_exit[enter_value & 1], 2u);\n+  uint exit_value = AtomicAccess::add(&_exit[enter_value & 1], 2u);\n","filename":"src\/hotspot\/share\/utilities\/singleWriterSynchronizer.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -45,1 +45,1 @@\n-    Atomic::inc(&_added_items);\n+    AtomicAccess::inc(&_added_items);\n@@ -53,1 +53,1 @@\n-    Atomic::inc(&_removed_items);\n+    AtomicAccess::inc(&_removed_items);\n","filename":"src\/hotspot\/share\/utilities\/tableStatistics.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -562,1 +562,1 @@\n-  Atomic::store(&_reporting_start_time, now);\n+  AtomicAccess::store(&_reporting_start_time, now);\n@@ -566,1 +566,1 @@\n-  return Atomic::load(&_reporting_start_time);\n+  return AtomicAccess::load(&_reporting_start_time);\n@@ -571,1 +571,1 @@\n-  Atomic::store(&_step_start_time, now);\n+  AtomicAccess::store(&_step_start_time, now);\n@@ -575,1 +575,1 @@\n-  return Atomic::load(&_step_start_time);\n+  return AtomicAccess::load(&_step_start_time);\n@@ -579,1 +579,1 @@\n-  return Atomic::store(&_step_start_time, (jlong)0);\n+  return AtomicAccess::store(&_step_start_time, (jlong)0);\n@@ -1146,0 +1146,1 @@\n+    size_t count = 0;\n@@ -1149,0 +1150,1 @@\n+      st->print_cr(\"VMErrorCallback %zu:\", ++count);\n@@ -1344,1 +1346,1 @@\n-  Atomic::replace_if_null(&_handshake_timed_out_thread, thread);\n+  AtomicAccess::replace_if_null(&_handshake_timed_out_thread, thread);\n@@ -1350,1 +1352,1 @@\n-  Atomic::replace_if_null(&_safepoint_timed_out_thread, thread);\n+  AtomicAccess::replace_if_null(&_safepoint_timed_out_thread, thread);\n@@ -1354,1 +1356,1 @@\n-  return Atomic::load(&_handshake_timed_out_thread);\n+  return AtomicAccess::load(&_handshake_timed_out_thread);\n@@ -1358,1 +1360,1 @@\n-  return Atomic::load(&_safepoint_timed_out_thread);\n+  return AtomicAccess::load(&_safepoint_timed_out_thread);\n@@ -1694,1 +1696,1 @@\n-      Atomic::cmpxchg(&_first_error_tid, (intptr_t)-1, mytid) == -1) {\n+      AtomicAccess::cmpxchg(&_first_error_tid, (intptr_t)-1, mytid) == -1) {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -82,1 +82,1 @@\n-  assert(Atomic::load(&_barrier_tag) == 0,\n+  assert(AtomicAccess::load(&_barrier_tag) == 0,\n@@ -84,2 +84,2 @@\n-         Atomic::load(&_barrier_tag));\n-  Atomic::release_store(&_barrier_tag, barrier_tag);\n+         AtomicAccess::load(&_barrier_tag));\n+  AtomicAccess::release_store(&_barrier_tag, barrier_tag);\n@@ -95,1 +95,1 @@\n-  int barrier_tag = Atomic::load_acquire(&_barrier_tag);\n+  int barrier_tag = AtomicAccess::load_acquire(&_barrier_tag);\n@@ -97,1 +97,1 @@\n-  Atomic::release_store(&_barrier_tag, 0);\n+  AtomicAccess::release_store(&_barrier_tag, 0);\n@@ -124,1 +124,1 @@\n-    state = Atomic::load_acquire(&_state);\n+    state = AtomicAccess::load_acquire(&_state);\n@@ -137,1 +137,1 @@\n-  int64_t prev_state = Atomic::cmpxchg(&_state, state, new_state);\n+  int64_t prev_state = AtomicAccess::cmpxchg(&_state, state, new_state);\n@@ -148,1 +148,1 @@\n-    int cur = Atomic::load_acquire(&_outstanding_wakeups);\n+    int cur = AtomicAccess::load_acquire(&_outstanding_wakeups);\n@@ -155,1 +155,1 @@\n-    int prev = Atomic::cmpxchg(&_outstanding_wakeups, cur, cur - 1);\n+    int prev = AtomicAccess::cmpxchg(&_outstanding_wakeups, cur, cur - 1);\n@@ -175,1 +175,1 @@\n-    int64_t state = Atomic::load_acquire(&_state);\n+    int64_t state = AtomicAccess::load_acquire(&_state);\n@@ -185,1 +185,1 @@\n-    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+    if (AtomicAccess::cmpxchg(&_state, state, new_state) == state) {\n@@ -194,1 +194,1 @@\n-    Atomic::release_store(&_outstanding_wakeups, waiters);\n+    AtomicAccess::release_store(&_outstanding_wakeups, waiters);\n@@ -200,1 +200,1 @@\n-  assert(Atomic::load(&_outstanding_wakeups) == 0, \"Post disarm: Should not have outstanding wakeups\");\n+  assert(AtomicAccess::load(&_outstanding_wakeups) == 0, \"Post disarm: Should not have outstanding wakeups\");\n@@ -206,1 +206,1 @@\n-    int64_t state = Atomic::load_acquire(&_state);\n+    int64_t state = AtomicAccess::load_acquire(&_state);\n@@ -222,1 +222,1 @@\n-    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+    if (AtomicAccess::cmpxchg(&_state, state, new_state) == state) {\n@@ -241,1 +241,1 @@\n-    int64_t state = Atomic::load_acquire(&_state);\n+    int64_t state = AtomicAccess::load_acquire(&_state);\n@@ -251,1 +251,1 @@\n-    if (Atomic::cmpxchg(&_state, state, new_state) == state) {\n+    if (AtomicAccess::cmpxchg(&_state, state, new_state) == state) {\n","filename":"src\/hotspot\/share\/utilities\/waitBarrier_generic.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  return Atomic::load_acquire(&_loaded);\n+  return AtomicAccess::load_acquire(&_loaded);\n@@ -114,1 +114,1 @@\n-  Atomic::release_store(&_loaded, true);\n+  AtomicAccess::release_store(&_loaded, true);\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+    JNU_CHECK_EXCEPTION(env);\n","filename":"src\/java.base\/aix\/native\/libjava\/ProcessHandleImpl_aix.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import static sun.nio.fs.MacOSXNativeDispatcher.*;\n-\n@@ -38,12 +36,0 @@\n-    private static final String PROPERTY_NORMALIZE_FILE_PATHS =\n-        \"jdk.nio.path.useNormalizationFormD\";\n-\n-    private static final boolean NORMALIZE_FILE_PATHS;\n-\n-    static {\n-        final String name = PROPERTY_NORMALIZE_FILE_PATHS;\n-        String value = System.getProperty(name);\n-        NORMALIZE_FILE_PATHS = (value != null)\n-            && (\"\".equals(value) || Boolean.parseBoolean(value));\n-    }\n-\n@@ -62,26 +48,0 @@\n-\n-    @Override\n-    String normalizeNativePath(String path) {\n-        if (NORMALIZE_FILE_PATHS) {\n-            for (int i = 0; i < path.length(); i++) {\n-                char c = path.charAt(i);\n-                if (c > 0x80)\n-                    return new String(normalizepath(path.toCharArray(),\n-                                  kCFStringNormalizationFormD));\n-            }\n-        }\n-        return path;\n-    }\n-\n-    @Override\n-    String normalizeJavaPath(String path) {\n-        if (NORMALIZE_FILE_PATHS) {\n-            for (int i = 0; i < path.length(); i++) {\n-                if (path.charAt(i) > 0x80)\n-                    return new String(normalizepath(path.toCharArray(),\n-                                      kCFStringNormalizationFormC));\n-            }\n-        }\n-        return path;\n-    }\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXFileSystem.java","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.fs;\n-\n-\/**\n- * MacOSX specific system calls.\n- *\/\n-\n-class MacOSXNativeDispatcher extends BsdNativeDispatcher {\n-    private MacOSXNativeDispatcher() { }\n-\n-    static final int kCFStringNormalizationFormC = 2;\n-    static final int kCFStringNormalizationFormD = 0;\n-    static native char[] normalizepath(char[] path, int form);\n-}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXNativeDispatcher.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,0 +266,1 @@\n+    JNU_CHECK_EXCEPTION(env);\n","filename":"src\/java.base\/macosx\/native\/libjava\/ProcessHandleImpl_macosx.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include <CoreFoundation\/CoreFoundation.h>\n-\n-JNIEXPORT jcharArray JNICALL\n-Java_sun_nio_fs_MacOSXNativeDispatcher_normalizepath(JNIEnv* env, jclass this,\n-                                                     jcharArray path,\n-                                                     jint form)\n-{\n-    jcharArray result = NULL;\n-    char *chars;\n-    CFMutableStringRef csref = CFStringCreateMutable(NULL, 0);\n-    if (csref == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"native heap\");\n-        return NULL;\n-    }\n-    chars = (char*)(*env)->GetPrimitiveArrayCritical(env, path, 0);\n-    if (chars != NULL) {\n-        char chars_buf[(PATH_MAX + 1) * 2];     \/\/ utf16 + zero padding\n-        jsize len = (*env)->GetArrayLength(env, path);\n-        CFStringAppendCharacters(csref, (const UniChar*)chars, len);\n-        (*env)->ReleasePrimitiveArrayCritical(env, path, chars, 0);\n-        CFStringNormalize(csref, form);\n-        len = CFStringGetLength(csref);\n-        if (len < PATH_MAX) {\n-            if (CFStringGetCString(csref, chars_buf, sizeof(chars_buf), kCFStringEncodingUTF16)) {\n-                result = (*env)->NewCharArray(env, len);\n-                if (result != NULL) {\n-                    (*env)->SetCharArrayRegion(env, result, 0, len, (jchar*)&chars_buf);\n-                }\n-            }\n-        } else {\n-            int ulen = (len + 1) * 2;\n-            chars = malloc(ulen);\n-            if (chars == NULL) {\n-                JNU_ThrowOutOfMemoryError(env, \"native heap\");\n-            } else {\n-                if (CFStringGetCString(csref, chars, ulen, kCFStringEncodingUTF16)) {\n-                    result = (*env)->NewCharArray(env, len);\n-                    if (result != NULL) {\n-                        (*env)->SetCharArrayRegion(env, result, 0, len, (jchar*)chars);\n-                    }\n-                }\n-                free(chars);\n-            }\n-        }\n-    }\n-    CFRelease(csref);\n-    return result;\n-}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/MacOSXNativeDispatcher.c","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,3 @@\n-            buf.position(offset + blockMultipleLength);\n+            \/\/ Advance the buffer position to account for processing on\n+            \/\/ the underlying array.\n+            buf.position(buf.position() + blockMultipleLength);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureSpi;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.SignatureException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.IllegalBlockSizeException;\n+\n+\/**\n+ * NONEwithRSA Signature implementation using the RSA\/ECB\/PKCS1Padding Cipher\n+ * implementation from SunJCE.\n+ *\/\n+public final class RSACipherAdaptor extends SignatureSpi {\n+\n+    private final RSACipher c;\n+    private ByteArrayOutputStream verifyBuf;\n+\n+    public RSACipherAdaptor() {\n+        c = new RSACipher();\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.DECRYPT_MODE, publicKey, null);\n+        if (verifyBuf == null) {\n+            verifyBuf = new ByteArrayOutputStream(128);\n+        } else {\n+            verifyBuf.reset();\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, null);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, random);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        engineUpdate(new byte[] {b}, 0, 1);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len)\n+            throws SignatureException {\n+        if (verifyBuf != null) {\n+            verifyBuf.write(b, off, len);\n+        } else {\n+            byte[] out = c.engineUpdate(b, off, len);\n+            if ((out != null) && (out.length != 0)) {\n+                throw new SignatureException\n+                       (\"Cipher unexpectedly returned data\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        try {\n+            return c.engineDoFinal(null, 0, 0);\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+           throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sigBytes) throws SignatureException {\n+        try {\n+            byte[] out = c.engineDoFinal(sigBytes, 0, sigBytes.length);\n+            byte[] data = verifyBuf.toByteArray();\n+            verifyBuf.reset();\n+            return MessageDigest.isEqual(out, data);\n+        } catch (BadPaddingException e) {\n+            \/\/ e.g. wrong public key used\n+            \/\/ return false rather than throwing exception\n+            return false;\n+        } catch (IllegalBlockSizeException e) {\n+            throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidParameterException(\"Parameters not supported\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipherAdaptor.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -139,0 +139,6 @@\n+        attrs.put(\"SupportedKeyClasses\",\n+                \"java.security.interfaces.RSAPublicKey\" +\n+                \"|java.security.interfaces.RSAPrivateKey\");\n+        ps(\"Signature\", \"NONEwithRSA\",\n+                \"com.sun.crypto.provider.RSACipherAdaptor\", null, attrs);\n+        \/\/ continue adding cipher specific attributes\n@@ -150,3 +156,0 @@\n-        attrs.put(\"SupportedKeyClasses\",\n-                \"java.security.interfaces.RSAPublicKey\" +\n-                \"|java.security.interfaces.RSAPrivateKey\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+import jdk.internal.util.ModifiedUtf;\n@@ -481,0 +482,1 @@\n+        validateClassNameLength(className);\n@@ -563,0 +565,1 @@\n+        validateClassNameLength(name);\n@@ -612,0 +615,3 @@\n+        if (!ModifiedUtf.isValidLengthInConstantPool(name)) {\n+            return null;\n+        }\n@@ -4230,0 +4236,10 @@\n+\n+    \/\/ Validates the length of the class name and throws an exception if it exceeds the maximum allowed length.\n+    private static void validateClassNameLength(String name) throws ClassNotFoundException {\n+        if (!ModifiedUtf.isValidLengthInConstantPool(name)) {\n+            throw new ClassNotFoundException(\n+                    \"Class name length exceeds limit of \"\n+                    + ModifiedUtf.CONSTANT_POOL_UTF8_MAX_BYTES\n+                    + \": \" + name.substring(0,256) + \"...\");\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1256,0 +1256,2 @@\n+     * In other words, {@linkplain ##repEquivalence representation\n+     * equivalence} is used to compare the {@code double} values.\n@@ -1469,0 +1471,6 @@\n+     * @apiNote\n+     * One idiom to implement {@linkplain ##repEquivalence\n+     * representation equivalence} on {@code double} values is\n+     * {@snippet lang=\"java\" :\n+     * Double.compare(a, b) == 0\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -885,0 +885,3 @@\n+     * In other words, {@linkplain Double##repEquivalence\n+     * representation equivalence} is used to compare the {@code\n+     * float} values.\n@@ -1290,0 +1293,8 @@\n+     * @apiNote\n+     * One idiom to implement {@linkplain\n+     * Double##repEquivalence representation equivalence} on {@code\n+     * float} values is\n+     * {@snippet lang=\"java\" :\n+     * Float.compare(a, b) == 0\n+     * }\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,6 @@\n-     * Apart from the semantics described above, the precise algorithm\n+     * Note that these rules imply that {@linkplain\n+     * Double##repEquivalence representation equivalence} is used for\n+     * the equality comparison of both primitive floating-point values\n+     * and wrapped floating-point values.\n+     *\n+     * <p>Apart from the semantics described above, the precise algorithm\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Record.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,2 +160,4 @@\n-        logRuntimeExit(status);         \/\/ Log without holding the lock;\n-\n+        \/\/ log only if VM is fully initialized\n+        if (VM.isBooted()) {\n+            logRuntimeExit(status);         \/\/ Log without holding the lock;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Shutdown.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -844,2 +845,3 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -847,1 +849,1 @@\n-     * the preferred provider order for the specified algorithm. This\n+     * the preferred provider order for the specified keystore type. This\n@@ -850,0 +852,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -872,0 +882,5 @@\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -891,0 +906,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -920,1 +943,2 @@\n-        if (provider == null || provider.isEmpty())\n+\n+        if (provider == null || provider.isEmpty()) {\n@@ -922,0 +946,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -938,0 +968,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -966,1 +1004,2 @@\n-        if (provider == null)\n+\n+        if (provider == null) {\n@@ -968,0 +1007,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -1680,0 +1725,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value. Disallowed type will be skipped.\n+     *\n@@ -1733,0 +1786,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value. Disallowed type will be skipped.\n+     *\n@@ -1801,2 +1862,6 @@\n-                                keystore = new KeyStore(impl, p, s.getAlgorithm());\n-                                break;\n+                                String ksAlgo = s.getAlgorithm();\n+                                if (CryptoAlgorithmConstraints.permits(\n+                                        \"KEYSTORE\", ksAlgo)) {\n+                                    keystore = new KeyStore(impl, p, ksAlgo);\n+                                    break;\n+                                }\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyStore.java","additions":72,"deletions":7,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -158,2 +159,4 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses the following\n+     * security properties:\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -164,0 +167,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -187,1 +198,4 @@\n-        MessageDigest md;\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n@@ -191,0 +205,1 @@\n+        MessageDigest md;\n@@ -219,0 +234,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -249,1 +272,2 @@\n-        if (provider == null || provider.isEmpty())\n+\n+        if (provider == null || provider.isEmpty()) {\n@@ -251,0 +275,5 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n@@ -252,1 +281,0 @@\n-        MessageDigest md;\n@@ -255,0 +283,1 @@\n+        MessageDigest md;\n@@ -274,0 +303,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -304,1 +341,2 @@\n-        if (provider == null)\n+\n+        if (provider == null) {\n@@ -306,0 +344,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigest.java","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-import javax.crypto.Cipher;\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.BadPaddingException;\n-import javax.crypto.NoSuchPaddingException;\n@@ -47,0 +43,2 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n+\n@@ -216,14 +214,0 @@\n-    \/\/ name of the special signature alg\n-    private static final String RSA_SIGNATURE = \"NONEwithRSA\";\n-\n-    \/\/ name of the equivalent cipher alg\n-    private static final String RSA_CIPHER = \"RSA\/ECB\/PKCS1Padding\";\n-\n-    \/\/ all the services we need to lookup for compatibility with Cipher\n-    private static final List<ServiceId> rsaIds = List.of(\n-        new ServiceId(\"Signature\", \"NONEwithRSA\"),\n-        new ServiceId(\"Cipher\", \"RSA\/ECB\/PKCS1Padding\"),\n-        new ServiceId(\"Cipher\", \"RSA\/ECB\"),\n-        new ServiceId(\"Cipher\", \"RSA\/\/PKCS1Padding\"),\n-        new ServiceId(\"Cipher\", \"RSA\"));\n-\n@@ -244,2 +228,4 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses the following\n+     * security properties:\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -250,0 +236,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -271,5 +265,3 @@\n-        Iterator<Service> t;\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            t = GetInstance.getServices(rsaIds);\n-        } else {\n-            t = GetInstance.getServices(\"Signature\", algorithm);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -277,0 +269,2 @@\n+\n+        Iterator<Service> t = GetInstance.getServices(\"Signature\", algorithm);\n@@ -332,4 +326,0 @@\n-        if (s.getType().equals(\"Cipher\")) {\n-            \/\/ must be a CipherSpi, which we can wrap with the CipherAdapter\n-            return true;\n-        }\n@@ -373,0 +363,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -401,11 +399,3 @@\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            \/\/ exception compatibility with existing code\n-            if (provider == null || provider.isEmpty()) {\n-                throw new IllegalArgumentException(\"missing provider\");\n-            }\n-            Provider p = Security.getProvider(provider);\n-            if (p == null) {\n-                throw new NoSuchProviderException\n-                    (\"no such provider: \" + provider);\n-            }\n-            return getInstanceRSA(p);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -413,0 +403,1 @@\n+\n@@ -427,0 +418,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -453,6 +452,3 @@\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            \/\/ exception compatibility with existing code\n-            if (provider == null) {\n-                throw new IllegalArgumentException(\"missing provider\");\n-            }\n-            return getInstanceRSA(provider);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -460,0 +456,1 @@\n+\n@@ -465,22 +462,0 @@\n-    \/\/ return an implementation for NONEwithRSA, which is a special case\n-    \/\/ because of the Cipher.RSA\/ECB\/PKCS1Padding compatibility wrapper\n-    private static Signature getInstanceRSA(Provider p)\n-            throws NoSuchAlgorithmException {\n-        \/\/ try Signature first\n-        Service s = p.getService(\"Signature\", RSA_SIGNATURE);\n-        if (s != null) {\n-            Instance instance = GetInstance.getInstance(s, SignatureSpi.class);\n-            return getInstance(instance, RSA_SIGNATURE);\n-        }\n-        \/\/ check Cipher\n-        try {\n-            Cipher c = Cipher.getInstance(RSA_CIPHER, p);\n-            return Delegate.of(new CipherAdapter(c), RSA_SIGNATURE);\n-        } catch (GeneralSecurityException e) {\n-            \/\/ throw Signature style exception message to avoid confusion,\n-            \/\/ but append Cipher exception as cause\n-            throw new NoSuchAlgorithmException(\"no such algorithm: \"\n-                + RSA_SIGNATURE + \" for provider \" + p.getName(), e);\n-        }\n-    }\n-\n@@ -1182,15 +1157,4 @@\n-            if (s.getType().equals(\"Cipher\")) {\n-                \/\/ must be NONEwithRSA\n-                try {\n-                    Cipher c = Cipher.getInstance(RSA_CIPHER, s.getProvider());\n-                    return new CipherAdapter(c);\n-                } catch (NoSuchPaddingException e) {\n-                    throw new NoSuchAlgorithmException(e);\n-                }\n-            } else {\n-                Object o = s.newInstance(null);\n-                if (!(o instanceof SignatureSpi)) {\n-                    throw new NoSuchAlgorithmException\n-                        (\"Not a SignatureSpi: \" + o.getClass().getName());\n-                }\n-                return (SignatureSpi)o;\n+            Object o = s.newInstance(null);\n+            if (!(o instanceof SignatureSpi)) {\n+                throw new NoSuchAlgorithmException\n+                    (\"Not a SignatureSpi: \" + o.getClass().getName());\n@@ -1198,0 +1162,1 @@\n+            return (SignatureSpi)o;\n@@ -1474,88 +1439,0 @@\n-\n-    \/\/ adapter for RSA\/ECB\/PKCS1Padding ciphers\n-    @SuppressWarnings(\"deprecation\")\n-    private static class CipherAdapter extends SignatureSpi {\n-\n-        private final Cipher cipher;\n-\n-        private ByteArrayOutputStream data;\n-\n-        CipherAdapter(Cipher cipher) {\n-            this.cipher = cipher;\n-        }\n-\n-        protected void engineInitVerify(PublicKey publicKey)\n-                throws InvalidKeyException {\n-            cipher.init(Cipher.DECRYPT_MODE, publicKey);\n-            if (data == null) {\n-                data = new ByteArrayOutputStream(128);\n-            } else {\n-                data.reset();\n-            }\n-        }\n-\n-        protected void engineInitSign(PrivateKey privateKey)\n-                throws InvalidKeyException {\n-            cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n-            data = null;\n-        }\n-\n-        protected void engineInitSign(PrivateKey privateKey,\n-                SecureRandom random) throws InvalidKeyException {\n-            cipher.init(Cipher.ENCRYPT_MODE, privateKey, random);\n-            data = null;\n-        }\n-\n-        protected void engineUpdate(byte b) throws SignatureException {\n-            engineUpdate(new byte[] {b}, 0, 1);\n-        }\n-\n-        protected void engineUpdate(byte[] b, int off, int len)\n-                throws SignatureException {\n-            if (data != null) {\n-                data.write(b, off, len);\n-                return;\n-            }\n-            byte[] out = cipher.update(b, off, len);\n-            if ((out != null) && (out.length != 0)) {\n-                throw new SignatureException\n-                    (\"Cipher unexpectedly returned data\");\n-            }\n-        }\n-\n-        protected byte[] engineSign() throws SignatureException {\n-            try {\n-                return cipher.doFinal();\n-            } catch (IllegalBlockSizeException | BadPaddingException e) {\n-                throw new SignatureException(\"doFinal() failed\", e);\n-            }\n-        }\n-\n-        protected boolean engineVerify(byte[] sigBytes)\n-                throws SignatureException {\n-            try {\n-                byte[] out = cipher.doFinal(sigBytes);\n-                byte[] dataBytes = data.toByteArray();\n-                data.reset();\n-                return MessageDigest.isEqual(out, dataBytes);\n-            } catch (BadPaddingException e) {\n-                \/\/ e.g. wrong public key used\n-                \/\/ return false rather than throwing exception\n-                return false;\n-            } catch (IllegalBlockSizeException e) {\n-                throw new SignatureException(\"doFinal() failed\", e);\n-            }\n-        }\n-\n-        protected void engineSetParameter(String param, Object value)\n-                throws InvalidParameterException {\n-            throw new InvalidParameterException(\"Parameters not supported\");\n-        }\n-\n-        protected Object engineGetParameter(String param)\n-                throws InvalidParameterException {\n-            throw new InvalidParameterException(\"Parameters not supported\");\n-        }\n-\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":48,"deletions":171,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -114,2 +114,7 @@\n- * for {@link CollationKey}\n- * for an example using {@code CollationKey}s.\n+ * for {@link CollationKey} for an example using {@code CollationKey}s.\n+ *\n+ * @implNote Significant thread contention may occur during concurrent usage\n+ * of the JDK Reference Implementation's {@link RuleBasedCollator}, which is the\n+ * subtype returned by the default provider of the {@link #getInstance()} factory\n+ * methods. As such, users should consider retrieving a separate instance for\n+ * each thread when used in multithreaded environments.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Collator.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,4 +41,0 @@\n-import java.text.Normalizer;\n-import java.util.Vector;\n-import java.util.Locale;\n-\n@@ -242,0 +238,5 @@\n+ * @implNote For this implementation, concurrent usage of this class may\n+ * lead to significant thread contention since {@code synchronized} is employed\n+ * to ensure thread-safety. As such, users of this class should consider creating\n+ * a separate instance for each thread when used in multithreaded environments.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/text\/RuleBasedCollator.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-    private final byte month;\n+    private final short month;\n@@ -197,1 +197,1 @@\n-    private final byte day;\n+    private final short day;\n@@ -501,2 +501,2 @@\n-        this.month = (byte) month;\n-        this.day = (byte) dayOfMonth;\n+        this.month = (short) month;\n+        this.day = (short) dayOfMonth;\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    private final byte month;\n+    private final int month;\n@@ -161,1 +161,1 @@\n-    private final byte day;\n+    private final int day;\n@@ -330,2 +330,2 @@\n-        this.month = (byte) month;\n-        this.day = (byte) dayOfMonth;\n+        this.month = month;\n+        this.day = dayOfMonth;\n","filename":"src\/java.base\/share\/classes\/java\/time\/MonthDay.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-    private final byte month;\n+    private final int month;\n@@ -317,1 +317,1 @@\n-        this.month = (byte) month;\n+        this.month = month;\n","filename":"src\/java.base\/share\/classes\/java\/time\/YearMonth.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-    private final transient byte monthOfYear;\n+    private final transient int monthOfYear;\n@@ -152,1 +152,1 @@\n-    private final transient byte dayOfMonth;\n+    private final transient int dayOfMonth;\n@@ -284,2 +284,2 @@\n-        this.monthOfYear = (byte) monthOfYear;\n-        this.dayOfMonth = (byte) dayOfMonth;\n+        this.monthOfYear = monthOfYear;\n+        this.dayOfMonth = dayOfMonth;\n@@ -298,2 +298,2 @@\n-        this.monthOfYear = (byte) dateInfo[1];\n-        this.dayOfMonth = (byte) dateInfo[2];\n+        this.monthOfYear = dateInfo[1];\n+        this.dayOfMonth = dateInfo[2];\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/HijrahDate.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-\n@@ -49,0 +48,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -300,0 +300,1 @@\n+\n@@ -485,2 +486,4 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses the following\n+     * security properties:\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -494,0 +497,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -522,0 +533,7 @@\n+\n+        \/\/ throws NoSuchAlgorithmException if java.security disables it\n+        if (!CryptoAlgorithmConstraints.permits(\"Cipher\", transformation)) {\n+            throw new NoSuchAlgorithmException(transformation +\n+                    \" is disabled\");\n+        }\n+\n@@ -585,0 +603,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -658,0 +684,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -695,0 +729,7 @@\n+\n+        \/\/ throws NoSuchAlgorithmException if java.security disables it\n+        if (!CryptoAlgorithmConstraints.permits(\"Cipher\", transformation)) {\n+            throw new NoSuchAlgorithmException(transformation +\n+                    \" is disabled\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":44,"deletions":3,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                String.format(\"%s out of range of %d: %d\", fieldName, typeName, value));\n+                String.format(\"%s out of range of %s: %d\", fieldName, typeName, value));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -427,1 +427,0 @@\n-            Objects.requireNonNull(name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/SystemModuleFinders.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,7 +109,0 @@\n-  static {\n-      Reflection.registerFieldsToFilter(ConstantPool.class, Set.of(\"constantPoolOop\"));\n-  }\n-\n-  \/\/ HotSpot-internal constant pool object (set by the VM, name known to the VM)\n-  private Object constantPoolOop;\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ConstantPool.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+    \/\/ Maximum number of bytes allowed for a Modified UTF-8 encoded string\n+    \/\/ in a ClassFile constant pool entry (CONSTANT_Utf8_info).\n+    public static final int CONSTANT_POOL_UTF8_MAX_BYTES = 65535;\n+\n@@ -71,0 +75,22 @@\n+\n+    \/**\n+     * Checks whether the Modified UTF-8 encoded length of the given string\n+     * fits within the ClassFile constant pool limit (u2 length = 65535 bytes).\n+     * @param str the string to check\n+     *\/\n+    @ForceInline\n+    public static boolean isValidLengthInConstantPool(String str) {\n+        \/\/ Quick approximation: each char can be at most 3 bytes in Modified UTF-8.\n+        \/\/ If the string is short enough, it definitely fits.\n+        int strLen = str.length();\n+        if (strLen <= CONSTANT_POOL_UTF8_MAX_BYTES \/ 3) {\n+            return true;\n+        }\n+        if (strLen > CONSTANT_POOL_UTF8_MAX_BYTES) {\n+            return false;\n+        }\n+        \/\/ Check exact Modified UTF-8 length.\n+        \/\/ The check strLen > CONSTANT_POOL_UTF8_MAX_BYTES above ensures that utfLen can't overflow here.\n+        int utfLen = utfLen(str, 0);\n+        return utfLen <= CONSTANT_POOL_UTF8_MAX_BYTES;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ModifiedUtf.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -640,14 +640,0 @@\n-\n-    \/**\n-     * Returns true if trust anchor certificate matches specified\n-     * certificate constraints.\n-     *\/\n-    private static boolean anchorIsTarget(TrustAnchor anchor,\n-                                          CertSelector sel)\n-    {\n-        X509Certificate anchorCert = anchor.getTrustedCert();\n-        if (anchorCert != null) {\n-            return sel.match(anchorCert);\n-        }\n-        return false;\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/SunCertPathBuilder.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -170,3 +170,1 @@\n-        if (socket != null && socket.isConnected() &&\n-                socket instanceof SSLSocket sslSocket) {\n-\n+        if (socket instanceof SSLSocket sslSocket && sslSocket.isConnected()) {\n@@ -175,14 +173,8 @@\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        \/\/ Peer supported certificate signature algorithms\n-                        \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n-                        peerSupportedSignAlgs =\n-                                extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forSocket(\n-                            sslSocket, peerSupportedSignAlgs, true);\n-                }\n+            if (session instanceof ExtendedSSLSession extSession\n+                    && ProtocolVersion.useTLS12PlusSpec(\n+                    extSession.getProtocol())) {\n+                \/\/ Use peer supported certificate signature algorithms\n+                \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n+                return SSLAlgorithmConstraints.forSocket(sslSocket,\n+                        extSession.getPeerSupportedSignatureAlgorithms(),\n+                        true);\n@@ -206,14 +198,9 @@\n-            if (session != null) {\n-                if (ProtocolVersion.useTLS12PlusSpec(session.getProtocol())) {\n-                    String[] peerSupportedSignAlgs = null;\n-\n-                    if (session instanceof ExtendedSSLSession extSession) {\n-                        \/\/ Peer supported certificate signature algorithms\n-                        \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n-                        peerSupportedSignAlgs =\n-                                extSession.getPeerSupportedSignatureAlgorithms();\n-                    }\n-\n-                    return SSLAlgorithmConstraints.forEngine(\n-                            engine, peerSupportedSignAlgs, true);\n-                }\n+\n+            if (session instanceof ExtendedSSLSession extSession\n+                    && ProtocolVersion.useTLS12PlusSpec(\n+                    extSession.getProtocol())) {\n+                \/\/ Use peer supported certificate signature algorithms\n+                \/\/ sent with \"signature_algorithms_cert\" TLS extension.\n+                return SSLAlgorithmConstraints.forEngine(engine,\n+                        extSession.getPeerSupportedSignatureAlgorithms(),\n+                        true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerCertChecking.java","additions":18,"deletions":31,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,10 @@\n-        String property = Security.getProperty(propertyName);\n+        return getAlgorithms(propertyName, false);\n+    }\n+\n+    \/\/ Get algorithm constraints from the specified security property or\n+    \/\/ system property if allowSystemOverride == true.\n+    static Set<String> getAlgorithms(String propertyName,\n+            boolean allowSystemOverride) {\n+        String property = allowSystemOverride ?\n+                SecurityProperties.getOverridableProperty(propertyName) :\n+                Security.getProperty(propertyName);\n@@ -68,1 +77,2 @@\n-        Set<String> algorithmsInPropertySet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n+        Set<String> algorithmsInPropertySet =\n+                new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n@@ -83,2 +93,3 @@\n-        \/\/ decompose the algorithm into sub-elements\n-        Set<String> elements = decomposer.decompose(algorithm);\n+        if (decomposer != null) {\n+            \/\/ decompose the algorithm into sub-elements\n+            Set<String> elements = decomposer.decompose(algorithm);\n@@ -86,4 +97,5 @@\n-        \/\/ check the element of the elements\n-        for (String element : elements) {\n-            if (algorithms.contains(element)) {\n-                return false;\n+            \/\/ check the element of the elements\n+            for (String element : elements) {\n+                if (algorithms.contains(element)) {\n+                    return false;\n+                }\n@@ -92,1 +104,0 @@\n-\n@@ -95,1 +106,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AbstractAlgorithmConstraints.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.lang.ref.SoftReference;\n+import java.security.AlgorithmParameters;\n+import java.security.CryptoPrimitive;\n+import java.security.Key;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+\/**\n+ * This class implements the algorithm constraints for the\n+ * \"jdk.crypto.disabledAlgorithms\" security property. This security property\n+ * can be overridden by the system property of the same name. See the\n+ * java.security file for the syntax of the property value.\n+ *\/\n+public class CryptoAlgorithmConstraints extends AbstractAlgorithmConstraints {\n+    private static final Debug debug = Debug.getInstance(\"jca\");\n+\n+    \/\/ for validating the service\n+    private static final Set<String> SUPPORTED_SERVICES =\n+            Set.of(\"Cipher\", \"KeyStore\", \"MessageDigest\", \"Signature\");\n+\n+    \/\/ Disabled algorithm security property for JCE crypto services\n+    private static final String PROPERTY_CRYPTO_DISABLED_ALGS =\n+            \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static class CryptoHolder {\n+        static final CryptoAlgorithmConstraints CONSTRAINTS =\n+                new CryptoAlgorithmConstraints(PROPERTY_CRYPTO_DISABLED_ALGS);\n+    }\n+\n+    private static void debug(String msg) {\n+        if (debug != null) {\n+            debug.println(\"CryptoAlgoConstraints: \", msg);\n+        }\n+    }\n+\n+    public static boolean permits(String service, String algo) {\n+        return CryptoHolder.CONSTRAINTS.cachedCheckAlgorithm(\n+                service + \".\" + algo);\n+    }\n+\n+    private final Set<String> disabledServices; \/\/ syntax is <service>.<algo>\n+    private volatile SoftReference<Map<String, Boolean>> cacheRef =\n+            new SoftReference<>(null);\n+\n+    \/**\n+     * Initialize algorithm constraints with the specified security property\n+     * {@code propertyName}. Note that if a system property of the same name\n+     * is set, it overrides the security property.\n+     *\n+     * @param propertyName the security property name that define the disabled\n+     *        algorithm constraints\n+     *\/\n+    CryptoAlgorithmConstraints(String propertyName) {\n+        super(null);\n+        disabledServices = getAlgorithms(propertyName, true);\n+        debug(\"Before \" + Arrays.deepToString(disabledServices.toArray()));\n+        for (String dk : disabledServices) {\n+            int idx = dk.indexOf(\".\");\n+            if (idx < 1 || idx == dk.length() - 1) {\n+                \/\/ wrong syntax: missing \".\" or empty service or algorithm\n+                throw new IllegalArgumentException(\"Invalid entry: \" + dk);\n+            }\n+            String service = dk.substring(0, idx);\n+            String algo = dk.substring(idx + 1);\n+            if (SUPPORTED_SERVICES.stream().anyMatch(e -> e.equalsIgnoreCase\n+                    (service))) {\n+                KnownOIDs oid = KnownOIDs.findMatch(algo);\n+                if (oid != null) {\n+                    debug(\"Add oid: \" + oid.value());\n+                    disabledServices.add(service + \".\" + oid.value());\n+                    debug(\"Add oid stdName: \" + oid.stdName());\n+                    disabledServices.add(service + \".\" + oid.stdName());\n+                    for (String a : oid.aliases()) {\n+                        debug(\"Add oid alias: \" + a);\n+                        disabledServices.add(service + \".\" + a);\n+                    }\n+                }\n+            } else {\n+                \/\/ unsupported service\n+                throw new IllegalArgumentException(\"Invalid entry: \" + dk);\n+            }\n+        }\n+        debug(\"After \" + Arrays.deepToString(disabledServices.toArray()));\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> notUsed1,\n+            String serviceDesc, AlgorithmParameters notUsed2) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> primitives, Key key) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> primitives,\n+            String algorithm, Key key, AlgorithmParameters parameters) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    \/\/ Return false if algorithm is found in the disabledServices Set.\n+    \/\/ Otherwise, return true.\n+    private boolean cachedCheckAlgorithm(String serviceDesc) {\n+        Map<String, Boolean> cache;\n+        if ((cache = cacheRef.get()) == null) {\n+            synchronized (this) {\n+                if ((cache = cacheRef.get()) == null) {\n+                    cache = new ConcurrentHashMap<>();\n+                    cacheRef = new SoftReference<>(cache);\n+                }\n+            }\n+        }\n+        Boolean result = cache.get(serviceDesc);\n+        if (result != null) {\n+            return result;\n+        }\n+        result = checkAlgorithm(disabledServices, serviceDesc, null);\n+        cache.put(serviceDesc, result);\n+        return result;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/CryptoAlgorithmConstraints.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -187,1 +187,1 @@\n-    RSA(\"1.2.840.113549.1.1.1\"), \/\/ RSA encryption\n+    RSA(\"1.2.840.113549.1.1.1\", \"RSA\", \"RSA\/ECB\/PKCS1Padding\"), \/\/ RSA encryption\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -774,0 +774,48 @@\n+#\n+# Algorithm restrictions for Java Crypto API services\n+#\n+# In some environments, certain algorithms may be undesirable for certain\n+# cryptographic services. For example, \"MD2\" is generally no longer considered\n+# to be a secure hash algorithm.  This section describes the mechanism for\n+# disabling algorithms at the JCA\/JCE level based on service name and algorithm\n+# name.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# The syntax of the disabled services string is described as follows:\n+#       \"DisabledService {, DisabledService}\"\n+#\n+#   DisabledService:\n+#       Service.AlgorithmName\n+#\n+# Service:  (one of the following, more services may be added later)\n+#     Cipher | KeyStore | MessageDigest | Signature\n+#\n+#   AlgorithmName:\n+#       (see below)\n+#\n+# The \"AlgorithmName\" is the standard algorithm name of the disabled\n+# service. See the Java Security Standard Algorithm Names Specification\n+# for information about Standard Algorithm Names.  Matching is\n+# performed using a case-insensitive exact matching rule. For Cipher service,\n+# its algorithm is the transformation string.\n+#\n+# Note: If the property value contains entries with invalid syntax or\n+# unsupported services at the time of checking, an ExceptionInInitializerError\n+# with a cause of IllegalArgumentException will be thrown.\n+#\n+# Note: The restriction is applied in the various getInstance(...) methods\n+# of the supported Service classes, i.e. Cipher, KeyStore, MessageDigest,\n+# and Signature. If the algorithm is disabled, a NoSuchAlgorithmException will\n+# be thrown by the getInstance methods of Cipher, MessageDigest, and Signature\n+# and a KeyStoreException by the getInstance methods of KeyStore.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+# Example:\n+#   jdk.crypto.disabledAlgorithms=Cipher.RSA\/ECB\/PKCS1Padding, MessageDigest.MD2\n+#\n+#jdk.crypto.disabledAlgorithms=\n+\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -340,14 +340,0 @@\n-    \/\/ Override if the platform uses different Unicode normalization form\n-    \/\/ for native file path. For example on MacOSX, the native path is stored\n-    \/\/ in Unicode NFD form.\n-    String normalizeNativePath(String path) {\n-        return path;\n-    }\n-\n-    \/\/ Override if the native file path use non-NFC form. For example on MacOSX,\n-    \/\/ the native path is stored in Unicode NFD form, the path need to be\n-    \/\/ normalized back to NFC before passed back to Java level.\n-    String normalizeJavaPath(String path) {\n-        return path;\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -62,1 +63,1 @@\n-    private String stringValue;\n+    private @Stable String stringValue;\n@@ -127,1 +128,0 @@\n-        input = fs.normalizeNativePath(input);\n@@ -817,1 +817,1 @@\n-            this.stringValue = stringValue = fs.normalizeJavaPath(Util.toString(path));     \/\/ platform encoding\n+            this.stringValue = stringValue = Util.toString(path);     \/\/ platform encoding\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,1 +259,0 @@\n-\n@@ -370,0 +369,1 @@\n+     * @throws IllegalArgumentException if any of the parameters are null.\n@@ -381,2 +381,2 @@\n-        if (string.length() == 0) {\n-            throw new IllegalArgumentException(\"Zero length string passed to TextLayout constructor.\");\n+        if (frc == null) {\n+            throw new IllegalArgumentException(\"Null font render context passed to TextLayout constructor.\");\n@@ -418,0 +418,1 @@\n+     * @throws IllegalArgumentException if any of the parameters are null.\n@@ -430,2 +431,2 @@\n-        if (string.length() == 0) {\n-            throw new IllegalArgumentException(\"Zero length string passed to TextLayout constructor.\");\n+        if (frc == null) {\n+            throw new IllegalArgumentException(\"Null font render context passed to TextLayout constructor.\");\n@@ -502,0 +503,1 @@\n+     * @throws IllegalArgumentException if any of the parameters are null.\n@@ -509,4 +511,2 @@\n-        int start = text.getBeginIndex();\n-        int limit = text.getEndIndex();\n-        if (start == limit) {\n-            throw new IllegalArgumentException(\"Zero length iterator passed to TextLayout constructor.\");\n+        if (frc == null) {\n+            throw new IllegalArgumentException(\"Null font render context passed to TextLayout constructor.\");\n@@ -515,0 +515,2 @@\n+        int start = text.getBeginIndex();\n+        int limit = text.getEndIndex();\n@@ -516,1 +518,0 @@\n-        text.first();\n@@ -1128,1 +1129,6 @@\n-        if (caret == 0 || caret == characterCount) {\n+        if (caret == 0 && characterCount == 0) {\n+\n+            top1X = top2X = 0;\n+            bottom1X = bottom2X = 0;\n+\n+        } else if (caret == 0 || caret == characterCount) {\n@@ -1146,2 +1152,2 @@\n-        }\n-        else {\n+\n+        } else {\n@@ -1887,1 +1893,0 @@\n-\n@@ -2183,2 +2188,2 @@\n-        if(bounds == null) {\n-                throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getVisualHighlightShape()\");\n+        if (bounds == null) {\n+            throw new IllegalArgumentException(\"Null Rectangle2D passed to TextLayout.getVisualHighlightShape()\");\n@@ -2189,0 +2194,4 @@\n+        if (characterCount == 0) {\n+            return result;\n+        }\n+\n@@ -2197,1 +2206,1 @@\n-            if (!ls.getBounds().isEmpty())\n+            if (!ls.getBounds().isEmpty()) {\n@@ -2199,0 +2208,1 @@\n+            }\n@@ -2285,1 +2295,1 @@\n-        if(firstEndpoint < 0 || secondEndpoint > characterCount) {\n+        if (firstEndpoint < 0 || secondEndpoint > characterCount) {\n@@ -2291,0 +2301,4 @@\n+        if (characterCount == 0) {\n+            return result;\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/TextLayout.java","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -839,1 +839,1 @@\n-            result = new Rectangle2D.Float(Float.MAX_VALUE, Float.MAX_VALUE, Float.MIN_VALUE, Float.MIN_VALUE);\n+            result = new Rectangle2D.Float(0, 0, 0, 0);\n@@ -847,0 +847,4 @@\n+        if (fComponents.length == 0) {\n+            return new Rectangle2D.Float(0, 0, 0, 0);\n+        }\n+\n@@ -930,1 +934,1 @@\n-            requiresBidi = Bidi.requiresBidi(chars, 0, chars.length);\n+            requiresBidi = Bidi.requiresBidi(chars, 0, characterCount);\n@@ -938,1 +942,1 @@\n-          bidi = new Bidi(chars, 0, embs, 0, chars.length, bidiflags);\n+          bidi = new Bidi(chars, 0, embs, 0, characterCount, bidiflags);\n@@ -948,1 +952,0 @@\n-\n@@ -953,2 +956,1 @@\n-\n-        components = createComponentsOnRun(0, chars.length,\n+        components = createComponentsOnRun(0, characterCount,\n@@ -975,1 +977,1 @@\n-                            chars, 0, chars.length, charsLtoV, levels, isDirectionLTR);\n+                            chars, 0, characterCount, charsLtoV, levels, isDirectionLTR);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/TextLine.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.awt.MediaTracker;\n@@ -46,1 +47,0 @@\n-import javax.swing.Icon;\n@@ -276,0 +276,4 @@\n+            String altAtt = (String) attr.getAttribute(HTML.Attribute.ALT);\n+            if (altAtt == null) {\n+                altAtt = srcAtt;\n+            }\n@@ -281,2 +285,4 @@\n-                Icon icon = new ImageIcon(srcURL);\n-                button  = new JButton(icon);\n+                ImageIcon icon = new ImageIcon(srcURL, altAtt);\n+                button = icon.getImageLoadStatus() == MediaTracker.COMPLETE\n+                         ? new JButton(icon)\n+                         : new JButton(altAtt);\n@@ -284,1 +290,1 @@\n-                button = new JButton(srcAtt);\n+                button = new JButton(altAtt);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/FormView.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-    if (start >= limit || start < lineStart || limit > lineLimit) {\n+    if (start > limit || start < lineStart || limit > lineLimit) {\n@@ -148,1 +148,1 @@\n-    if (start >= limit || start < lineStart || limit > lineLimit) {\n+    if (start > limit || start < lineStart || limit > lineLimit) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TextLabelFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import javax.naming.ServiceUnavailableException;\n@@ -442,14 +441,0 @@\n-        BerDecoder rber;\n-\n-        \/\/ If socket closed, don't even try\n-        lock.lock();\n-        try {\n-            if (sock == null) {\n-                throw new ServiceUnavailableException(host + \":\" + port +\n-                    \"; socket closed\");\n-            }\n-        } finally {\n-            lock.unlock();\n-        }\n-\n-        IOException ioException = null;\n@@ -460,1 +445,1 @@\n-            rber = ldr.getReplyBer(readTimeout);\n+            return ldr.getReplyBer(readTimeout);\n@@ -465,7 +450,1 @@\n-            \/\/ Connection is timed out OR closed\/cancelled\n-            \/\/ getReplyBer throws IOException when the requests needs to be abandoned\n-            ioException = ioe;\n-            rber = null;\n-        }\n-\n-        if (rber == null) {\n+            \/\/ getReplyBer() throws IOException when request needs to be abandoned\n@@ -473,13 +452,3 @@\n-        }\n-        \/\/ ioException can be not null in the following cases:\n-        \/\/  a) The response is timed-out\n-        \/\/  b) LDAP request connection has been closed\n-        \/\/ If the request has been cancelled - CommunicationException is\n-        \/\/ thrown directly from LdapRequest.getReplyBer, since there is no\n-        \/\/ need to abandon request.\n-        \/\/ The exception message is initialized in LdapRequest::getReplyBer\n-        if (ioException != null) {\n-            \/\/ Throw CommunicationException after all cleanups are done\n-            String message = ioException.getMessage();\n-            var ce = new CommunicationException(message);\n-            ce.initCause(ioException);\n+            \/\/ rethrow as CommunicationException (which is a NamingException)\n+            var ce = new CommunicationException(ioe.getMessage());\n+            ce.initCause(ioe);\n@@ -488,1 +457,0 @@\n-        return rber;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":6,"deletions":38,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -37,1 +36,2 @@\n-    private static final BerDecoder EOF = new BerDecoder(new byte[]{}, -1, 0);\n+    private static final BerDecoder CLOSED_MARKER = new BerDecoder(new byte[]{}, -1, 0);\n+    private static final BerDecoder CANCELLED_MARKER = new BerDecoder(new byte[]{}, -1, 0);\n@@ -39,1 +39,0 @@\n-    private static final String TIMEOUT_MSG_FMT = \"LDAP response read timed out, timeout used: %d ms.\";\n@@ -45,0 +44,2 @@\n+    private final boolean pauseAfterReceipt;\n+\n@@ -48,3 +49,0 @@\n-    private final boolean pauseAfterReceipt;\n-    \/\/ LdapRequest instance lock\n-    private final ReentrantLock lock = new ReentrantLock();\n@@ -64,1 +62,1 @@\n-        replies.offer(EOF);\n+        replies.offer(CANCELLED_MARKER);\n@@ -68,11 +66,2 @@\n-        lock.lock();\n-        try {\n-            closed = true;\n-            replies.offer(EOF);\n-        } finally {\n-            lock.unlock();\n-        }\n-    }\n-\n-    private boolean isClosed() {\n-        return closed && (replies.size() == 0 || replies.peek() == EOF);\n+        closed = true;\n+        replies.offer(CLOSED_MARKER);\n@@ -82,9 +71,12 @@\n-        lock.lock();\n-        try {\n-            \/\/ check the closed boolean value here as we don't want anything\n-            \/\/ to be added to the queue after close() has been called.\n-            if (cancelled || closed) {\n-                return false;\n-            }\n-\n-            \/\/ peek at the BER buffer to check if it is a SearchResultDone PDU\n+        \/\/ check if the request is closed or cancelled, if yes then don't\n+        \/\/ add the reply since it won't be returned back later through getReplyBer().\n+        \/\/ this is merely a best effort basis check and if we do add the reply\n+        \/\/ due to a race, that's OK since the replies queue would have necessary\n+        \/\/ markers for cancelled\/closed state and those will be detected by getReplyBer().\n+        if (cancelled || closed) {\n+            return false;\n+        }\n+        \/\/ if the request is not already completed, check if the reply being added\n+        \/\/ is a LDAP_REP_RESULT, representing a SearchResultDone PDU\n+        if (!completed) {\n+            boolean isLdapResResult = false;\n@@ -94,1 +86,1 @@\n-                completed = (ber.peekByte() == LdapClient.LDAP_REP_RESULT);\n+                isLdapResResult = (ber.peekByte() == LdapClient.LDAP_REP_RESULT);\n@@ -100,5 +92,2 @@\n-            \/\/ Add a new reply to the queue of unprocessed replies.\n-            try {\n-                replies.put(ber);\n-            } catch (InterruptedException e) {\n-                \/\/ ignore\n+            if (isLdapResResult) {\n+                completed = true;\n@@ -106,0 +95,1 @@\n+        }\n@@ -107,3 +97,5 @@\n-            return pauseAfterReceipt;\n-        } finally {\n-            lock.unlock();\n+        \/\/ Add a new reply to the queue of unprocessed replies.\n+        try {\n+            replies.put(ber);\n+        } catch (InterruptedException e) {\n+            \/\/ ignore\n@@ -111,0 +103,1 @@\n+        return pauseAfterReceipt;\n@@ -117,3 +110,7 @@\n-     * @throws CommunicationException request has been canceled and request does not need to be abandoned\n-     * @throws IOException            request has been closed or timed out. Request does need to be abandoned\n-     * @throws InterruptedException   LDAP operation has been interrupted\n+     * @throws CommunicationException request has been canceled and request\n+     *                                does not need to be abandoned (i.e. a LDAP_REQ_ABANDON\n+     *                                message need not be sent across)\n+     * @throws IOException            request has been closed or timed out.\n+     *                                Request needs to be abandoned (i.e. a LDAP_REQ_ABANDON\n+     *                                message needs to be sent across)\n+     * @throws InterruptedException   the wait to read a reply has been interrupted\n@@ -121,0 +118,1 @@\n+    \/\/ more than one thread invoking this method concurrently isn't expected\n@@ -123,10 +121,0 @@\n-        if (cancelled) {\n-            throw new CommunicationException(\"Request: \" + msgId +\n-                \" cancelled\");\n-        }\n-        if (isClosed()) {\n-            throw new IOException(CLOSE_MSG);\n-        }\n-\n-        BerDecoder result = millis > 0 ?\n-                replies.poll(millis, TimeUnit.MILLISECONDS) : replies.take();\n@@ -134,3 +122,11 @@\n-        if (cancelled) {\n-            throw new CommunicationException(\"Request: \" + msgId +\n-                \" cancelled\");\n+        final boolean hasReplies = replies.peek() != null;\n+        if (!hasReplies) {\n+            \/\/ no replies have been queued, so if the request has\n+            \/\/ been cancelled or closed, then raise an exception\n+            if (cancelled) {\n+                throw new CommunicationException(\"Request: \" + msgId +\n+                        \" cancelled\");\n+            }\n+            if (closed) {\n+                throw new IOException(CLOSE_MSG);\n+            }\n@@ -138,1 +134,7 @@\n-\n+        \/\/ either there already are queued replies or the request is still\n+        \/\/ alive (i.e. not cancelled or closed). we wait for a reply to arrive\n+        \/\/ or the request to be cancelled\/closed, in which case the replies\n+        \/\/ queue will contain the relevant marker.\n+        final BerDecoder result = millis > 0\n+                ? replies.poll(millis, TimeUnit.MILLISECONDS)\n+                : replies.take();\n@@ -141,1 +143,5 @@\n-            throw new IOException(String.format(TIMEOUT_MSG_FMT, millis));\n+            throw new IOException(\"LDAP response read timed out, timeout used: \" + millis + \" ms.\");\n+        }\n+        if (result == CANCELLED_MARKER) {\n+            throw new CommunicationException(\"Request: \" + msgId +\n+                \" cancelled\");\n@@ -143,2 +149,1 @@\n-        \/\/ Unexpected EOF can be caused by connection closure or cancellation\n-        if (result == EOF) {\n+        if (result == CLOSED_MARKER) {\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapRequest.java","additions":62,"deletions":57,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -613,0 +613,2 @@\n+        p1.setSignatureSchemes(p.getSignatureSchemes());\n+        p1.setNamedGroups(p.getNamedGroups());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureSpi;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.ProviderException;\n+import java.security.SignatureException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import sun.security.pkcs11.wrapper.PKCS11Exception;\n+\n+\/**\n+ * NONEwithRSA Signature implementation using the RSA\/ECB\/PKCS1Padding Cipher\n+ * implementation from SunPKCS11.\n+ *\/\n+public final class RSACipherAdaptor extends SignatureSpi {\n+\n+    private final P11RSACipher c;\n+    private ByteArrayOutputStream verifyBuf;\n+\n+    public RSACipherAdaptor(Token token, long mechanism) {\n+        try {\n+            c = new P11RSACipher(token, \"\", mechanism);\n+            c.engineSetPadding(\"pkcs1padding\");\n+        } catch (PKCS11Exception | NoSuchPaddingException e) {\n+            \/\/ should not happen, but wrap and re-throw if it were to happen\n+            throw new ProviderException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.DECRYPT_MODE, publicKey, null);\n+        if (verifyBuf == null) {\n+            verifyBuf = new ByteArrayOutputStream(128);\n+        } else {\n+            verifyBuf.reset();\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, null);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, random);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        engineUpdate(new byte[] {b}, 0, 1);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len)\n+            throws SignatureException {\n+        if (verifyBuf != null) {\n+            verifyBuf.write(b, off, len);\n+        } else {\n+            byte[] out = c.engineUpdate(b, off, len);\n+            if ((out != null) && (out.length != 0)) {\n+                throw new SignatureException\n+                       (\"Cipher unexpectedly returned data\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        try {\n+            return c.engineDoFinal(null, 0, 0);\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+           throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sigBytes) throws SignatureException {\n+        try {\n+            byte[] out = c.engineDoFinal(sigBytes, 0, sigBytes.length);\n+            byte[] data = verifyBuf.toByteArray();\n+            verifyBuf.reset();\n+            return MessageDigest.isEqual(out, data);\n+        } catch (BadPaddingException e) {\n+            \/\/ e.g. wrong public key used\n+            \/\/ return false rather than throwing exception\n+            return false;\n+        } catch (IllegalBlockSizeException e) {\n+            throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidParameterException(\"Parameters not supported\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/RSACipherAdaptor.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -977,0 +977,2 @@\n+        d(SIG, \"NONEwithRSA\",    \"sun.security.pkcs11.RSACipherAdaptor\",\n+                m(CKM_RSA_PKCS));\n@@ -1428,0 +1430,2 @@\n+                } else if (algorithm.equals(\"NONEwithRSA\")) {\n+                    return new RSACipherAdaptor(token, mechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -893,1 +893,3 @@\n-     * {@code double} represented by this object.\n+     * {@code Float16} represented by this object.\n+     * {@linkplain Double##repEquivalence Representation\n+     * equivalence} is used to compare the {@code Float16} values.\n@@ -991,0 +993,7 @@\n+     * @apiNote\n+     * One idiom to implement {@linkplain Double##repEquivalence\n+     * representation equivalence} on {@code Float16} values is\n+     * {@snippet lang=\"java\" :\n+     * Float16.compare(a, b) == 0\n+     * }\n+     *\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+                .put(HtmlAttr.ARIA_LABEL, resources.getText(\"doclet.selectModule\"))\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SearchWriter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -790,0 +790,3 @@\n+\n+doclet.selectModule=\\\n+    Select the module to search in.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,10 @@\n+void enableConsoleCtrlHandler(bool enable) {\n+    if (!SetConsoleCtrlHandler(NULL, enable ? FALSE : TRUE)) {\n+        JP_THROW(SysError(tstrings::any() << \"SetConsoleCtrlHandler(NULL, \"\n+                                            << (enable ? \"FALSE\" : \"TRUE\")\n+                                            << \") failed\",\n+                                                    SetConsoleCtrlHandler));\n+    }\n+}\n+\n+\n@@ -313,0 +323,13 @@\n+        exec.afterProcessCreated([&](HANDLE pid) {\n+            \/\/\n+            \/\/ Ignore Ctrl+C in the current process.\n+            \/\/ This will prevent child process termination without allowing\n+            \/\/ it to handle Ctrl+C events.\n+            \/\/\n+            \/\/ Disable the default Ctrl+C handler *after* the child process\n+            \/\/ has been created as it is inheritable and we want the child\n+            \/\/ process to have the default handler.\n+            \/\/\n+            enableConsoleCtrlHandler(false);\n+        });\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/applauncher\/WinLauncher.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,0 +164,4 @@\n+    if (afterProcessCreatedCallback) {\n+      afterProcessCreatedCallback(processInfo.hProcess);\n+    }\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Executor.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include <functional>\n+\n@@ -100,0 +102,8 @@\n+    \/**\n+     * Call provided function after the process hass been created.\n+     *\/\n+    Executor& afterProcessCreated(const std::function<void(HANDLE)>& v) {\n+        afterProcessCreatedCallback = v;\n+        return *this;\n+    }\n+\n@@ -109,0 +119,1 @@\n+    std::function<void(HANDLE)> afterProcessCreatedCallback;\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/Executor.h","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-                            prefixOpt.orElse(\"\").substring(cursor - anchor[0]);\n+                            prefixOpt.orElse(\"\");\n@@ -399,1 +399,1 @@\n-                    if (!prefix.isEmpty() && !command) {\n+                    if (prefix.length() > cursor - anchor[0] && !command) {\n@@ -408,0 +408,1 @@\n+                                                       anchor[0],\n@@ -612,0 +613,1 @@\n+        private final int anchor;\n@@ -617,0 +619,1 @@\n+                                      int anchor,\n@@ -621,0 +624,1 @@\n+            this.anchor = anchor;\n@@ -633,1 +637,8 @@\n-            in.putString(prefix);\n+            String existingPrefix = in.getBuffer().substring(anchor, cursor);\n+\n+            if (prefix.startsWith(existingPrefix)) {\n+                in.putString(prefix.substring(existingPrefix.length()));\n+            } else {\n+                in.getBuffer().backspace(existingPrefix.length());\n+                in.putString(prefix);\n+            }\n@@ -642,1 +653,1 @@\n-            if (!prefix.isEmpty())\n+            if (prefix.length() > existingPrefix.length())\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ConsoleIOContext.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import com.sun.source.tree.NewArrayTree;\n@@ -114,0 +115,1 @@\n+import java.util.Optional;\n@@ -313,2 +315,2 @@\n-        return computeSuggestions(codeWrap, cursor, requiredPrefix, anchor).stream()\n-                .filter(s -> s.continuation().startsWith(requiredPrefix[0]) && !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))\n+        return computeSuggestions(codeWrap, code, cursor, requiredPrefix, anchor).stream()\n+                .filter(s -> filteringText(s).startsWith(requiredPrefix[0]) && !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))\n@@ -319,1 +321,7 @@\n-    private List<Suggestion> computeSuggestions(OuterWrap code, int cursor, String[] requiredPrefix, int[] anchor) {\n+    private static String filteringText(Suggestion suggestion) {\n+        return suggestion instanceof SuggestionImpl impl\n+                ? impl.filteringText\n+                : suggestion.continuation();\n+    }\n+\n+    private List<Suggestion> computeSuggestions(OuterWrap code, String inputCode, int cursor, String[] requiredPrefix, int[] anchor) {\n@@ -482,0 +490,13 @@\n+                        if (isAnnotation(tp)) {\n+                            if (getAnnotationAttributeNameOrNull(tp.getParentPath(), true) != null) {\n+                                \/\/nested annotation\n+                                result = completionSuggestionsImpl(inputCode, cursor - 1, anchor);\n+                                requiredPrefix[0] = \"@\" + requiredPrefix[0];\n+                                return result;\n+                            }\n+\n+                            Predicate<Element> accept = accessibility.and(STATIC_ONLY)\n+                                    .and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));\n+                            addScopeElements(at, scope, IDENTITY, accept, IS_PACKAGE.negate().and(smartTypeFilter), result);\n+                            break;\n+                        }\n@@ -515,0 +536,1 @@\n+                        boolean insertPrimitiveTypes = true;\n@@ -542,0 +564,71 @@\n+                        } else if (tp.getParentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                            AnnotationTree annotation = (AnnotationTree) tp.getParentPath().getLeaf();\n+                            Element annotationType = at.trees().getElement(tp.getParentPath());\n+                            Set<String> present = annotation.getArguments()\n+                                                            .stream()\n+                                                            .filter(expr -> expr.getKind() == Kind.ASSIGNMENT)\n+                                                            .map(expr -> (AssignmentTree) expr)\n+                                                            .map(assign -> assign.getVariable())\n+                                                            .filter(var -> var.getKind() == Kind.IDENTIFIER)\n+                                                            .map(var -> ((IdentifierTree) var).getName().toString())\n+                                                            .collect(Collectors.toSet());\n+                            addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), el -> !present.contains(el.getSimpleName().toString()), TRUE, _ -> \" = \", result);\n+                            break;\n+                        } else if (getAnnotationAttributeNameOrNull(tp, true) instanceof String attributeName) {\n+                            Element annotationType = tp.getParentPath().getParentPath().getLeaf().getKind() == Kind.ANNOTATION\n+                                    ? at.trees().getElement(tp.getParentPath().getParentPath())\n+                                    : at.trees().getElement(tp.getParentPath().getParentPath().getParentPath());\n+                            if (sp.getEndPosition(topLevel, tp.getParentPath().getLeaf()) == (-1)) {\n+                                \/\/synthetic 'value':\n+                                addElements(ElementFilter.methodsIn(annotationType.getEnclosedElements()), TRUE, TRUE, _ -> \" = \", result);\n+                                boolean hasValue = findAnnotationAttributeIfAny(annotationType, \"value\").isPresent();\n+                                if (!hasValue) {\n+                                    break;\n+                                }\n+                            }\n+                            Optional<ExecutableElement> ee = findAnnotationAttributeIfAny(annotationType, attributeName);\n+                            if (ee.isEmpty()) {\n+                                break;\n+                            }\n+                            TypeMirror relevantAttributeType = ee.orElseThrow().getReturnType();\n+                            if (relevantAttributeType.getKind() == TypeKind.ARRAY) {\n+                                relevantAttributeType = ((ArrayType) relevantAttributeType).getComponentType();\n+                            }\n+                            if (relevantAttributeType.getKind() == TypeKind.DECLARED &&\n+                                at.getTypes().asElement(relevantAttributeType) instanceof Element attributeTypeEl) {\n+                                if (attributeTypeEl.getKind() == ElementKind.ANNOTATION_TYPE) {\n+                                    boolean hasAnyAttributes =\n+                                            ElementFilter.methodsIn(attributeTypeEl.getEnclosedElements())\n+                                                         .stream()\n+                                                         .anyMatch(attribute -> attribute.getParameters().isEmpty());\n+                                    String paren = hasAnyAttributes ? \"(\" : \"\";\n+                                    String name = scopeContent(at, scope, IDENTITY).contains(attributeTypeEl)\n+                                            ? attributeTypeEl.getSimpleName().toString() \/\/simple name ought to be enough:\n+                                            : ((TypeElement) attributeTypeEl).getQualifiedName().toString();\n+                                    result.add(new SuggestionImpl(\"@\" + name + paren, true));\n+                                    break;\n+                                } else if (attributeTypeEl.getKind() == ElementKind.ENUM) {\n+                                    String typeName = scopeContent(at, scope, IDENTITY).contains(attributeTypeEl)\n+                                            ? attributeTypeEl.getSimpleName().toString() \/\/simple name ought to be enough:\n+                                            : ((TypeElement) attributeTypeEl).getQualifiedName().toString();\n+                                    result.add(new SuggestionImpl(typeName, true));\n+                                    result.addAll(ElementFilter.fieldsIn(attributeTypeEl.getEnclosedElements())\n+                                                               .stream()\n+                                                               .filter(e -> e.getKind() == ElementKind.ENUM_CONSTANT)\n+                                                               .map(c -> new SuggestionImpl(scopeContent(at, scope, IDENTITY).contains(c)\n+                                                                       ? c.getSimpleName().toString()\n+                                                                       : typeName + \".\" + c.getSimpleName(), c.getSimpleName().toString(),\n+                                                                       true))\n+                                                               .toList());\n+                                    break;\n+                                }\n+                            }\n+                            accept = accessibility.and(el -> {\n+                                return switch (el.getKind()) {\n+                                    case PACKAGE, ANNOTATION_TYPE, ENUM, INTERFACE, RECORD, ENUM_CONSTANT -> true;\n+                                    case CLASS -> !((TypeElement) el).asType().getKind().isPrimitive();\n+                                    case FIELD -> isPermittedAnnotationAttributeFieldType(at, el.asType());\n+                                    default -> false;\n+                                };\n+                            });\n+                            insertPrimitiveTypes = false;\n@@ -546,10 +639,20 @@\n-                        Tree parent = tp.getParentPath().getLeaf();\n-                        accept = switch (parent.getKind()) {\n-                            case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n-                                             IS_VOID.negate() :\n-                                             TRUE;\n-                            case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n-                            case TYPE_PARAMETER, CLASS, INTERFACE, ENUM, RECORD -> FALSE;\n-                            default -> TRUE;\n-                        };\n-                        addElements(primitivesOrVoid(at), accept, smartFilter, result);\n+                        if (insertPrimitiveTypes) {\n+                            Tree parent = tp.getParentPath().getLeaf();\n+                            accept = switch (parent.getKind()) {\n+                                case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n+                                                 IS_VOID.negate() :\n+                                                 TRUE;\n+                                case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n+                                case TYPE_PARAMETER, CLASS, INTERFACE, ENUM, RECORD -> FALSE;\n+                                default -> TRUE;\n+                            };\n+                            addElements(primitivesOrVoid(at), accept, smartFilter, result);\n+                        }\n+\n+                        boolean hasBooleanSmartType = targetTypes != null &&\n+                                StreamSupport.stream(targetTypes.spliterator(), false)\n+                                             .anyMatch(tm -> tm.getKind() == TypeKind.BOOLEAN);\n+                        if (hasBooleanSmartType) {\n+                            result.add(new SuggestionImpl(\"true\", true));\n+                            result.add(new SuggestionImpl(\"false\", true));\n+                        }\n@@ -920,0 +1023,6 @@\n+                if (end == (-1) && tree.getKind() == Kind.ASSIGNMENT &&\n+                    getCurrentPath() != null &&\n+                    getCurrentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                    \/\/the assignment is synthetically generated, take the end pos of the nested tree:\n+                    end = sp.getEndPosition(topLevel, ((AssignmentTree) tree).getExpression());\n+                }\n@@ -949,0 +1058,6 @@\n+    private boolean isAnnotation(TreePath tp) {\n+        Tree parent = tp.getParentPath().getLeaf();\n+        return parent.getKind() == Kind.ANNOTATION &&\n+                ((AnnotationTree)parent).getAnnotationType().equals(tp.getLeaf());\n+    }\n+\n@@ -964,0 +1079,33 @@\n+    private String getAnnotationAttributeNameOrNull(TreePath tp, boolean acceptArray) {\n+        if (tp.getParentPath() == null) {\n+            return null;\n+        }\n+        if (tp.getParentPath().getLeaf().getKind() == Kind.NEW_ARRAY &&\n+            ((NewArrayTree) tp.getParentPath().getLeaf()).getInitializers().contains(tp.getLeaf())) {\n+            if (acceptArray) {\n+                return getAnnotationAttributeNameOrNull(tp.getParentPath(), false);\n+            } else {\n+                return null;\n+            }\n+        }\n+        if (tp.getParentPath().getParentPath() == null ||\n+            tp.getParentPath().getLeaf().getKind() != Kind.ASSIGNMENT ||\n+            tp.getParentPath().getParentPath().getLeaf().getKind() != Kind.ANNOTATION) {\n+            return null;\n+        }\n+        AssignmentTree assign = (AssignmentTree) tp.getParentPath().getLeaf();\n+        if (assign.getVariable().getKind() != Kind.IDENTIFIER) {\n+            return null;\n+        }\n+        return ((IdentifierTree) assign.getVariable()).getName().toString();\n+    }\n+\n+    private Optional<ExecutableElement> findAnnotationAttributeIfAny(Element annotationType,\n+                                                                     String attributeName) {\n+        return ElementFilter.methodsIn(annotationType.getEnclosedElements())\n+                            .stream()\n+                            .filter(ee -> ee.getSimpleName().contentEquals(attributeName))\n+                            .filter(ee -> ee.getParameters().isEmpty())\n+                            .findAny();\n+    }\n+\n@@ -990,0 +1138,11 @@\n+    private boolean isPermittedAnnotationAttributeFieldType(AnalyzeTask at, TypeMirror type) {\n+        if (type.getKind().isPrimitive()) {\n+            return true;\n+        }\n+        if (type.getKind() == TypeKind.DECLARED) {\n+            Element el = ((DeclaredType) type).asElement();\n+            return el.getKind() == ElementKind.ENUM || el.equals(at.getElements().getTypeElement(\"java.lang.String\"));\n+        }\n+        return false;\n+    }\n+\n@@ -1240,1 +1399,1 @@\n-    private Iterable<? extends Element> scopeContent(AnalyzeTask at, Scope scope, Function<Element, Iterable<? extends Element>> elementConvertor) {\n+    private Collection<? extends Element> scopeContent(AnalyzeTask at, Scope scope, Function<Element, Iterable<? extends Element>> elementConvertor) {\n@@ -1309,0 +1468,20 @@\n+        if (current.getKind() == Kind.ANNOTATION) {\n+            Element type = at.trees().getElement(forPath);\n+            if (type != null) {\n+                Optional<ExecutableElement> valueAttr =\n+                        ElementFilter.methodsIn(type.getEnclosedElements())\n+                                     .stream()\n+                                     .filter(ee -> ee.getSimpleName().contentEquals(\"value\"))\n+                                     .findAny();\n+                if (valueAttr.isPresent()) {\n+                    TypeMirror returnType = valueAttr.orElseThrow().getReturnType();\n+\n+                    if (returnType.getKind() == TypeKind.ARRAY) {\n+                        returnType = ((ArrayType) returnType).getComponentType();\n+                    }\n+\n+                    return Collections.singletonList(returnType);\n+                }\n+            }\n+        }\n+\n@@ -1310,0 +1489,8 @@\n+            case NEW_ARRAY:\n+                if (getAnnotationAttributeNameOrNull(forPath, true) != null) {\n+                    forPath = forPath.getParentPath();\n+                    current = forPath.getLeaf();\n+                    \/\/fall-through\n+                } else {\n+                    break;\n+                }\n@@ -1312,2 +1499,17 @@\n-                if (tree.getExpression() == current)\n-                    return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));\n+                if (tree.getExpression() == current) {\n+                    if (forPath.getParentPath().getParentPath().getLeaf().getKind() == Kind.ANNOTATION) {\n+                        Element method = at.trees().getElement(new TreePath(forPath.getParentPath(), tree.getVariable()));\n+                        if (method != null && method.getKind() == ElementKind.METHOD) {\n+                            TypeMirror returnType = ((ExecutableElement) method).getReturnType();\n+\n+                            if (returnType.getKind() == TypeKind.ARRAY) {\n+                                returnType = ((ArrayType) returnType).getComponentType();\n+                            }\n+\n+                            return Collections.singletonList(returnType);\n+                        }\n+                        return null;\n+                    } else {\n+                        return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));\n+                    }\n+                }\n@@ -1561,1 +1763,2 @@\n-                   tp.getLeaf().getKind() != Kind.MEMBER_SELECT) {\n+                   tp.getLeaf().getKind() != Kind.MEMBER_SELECT &&\n+                   tp.getLeaf().getKind() != Kind.ANNOTATION) {\n@@ -1614,0 +1817,12 @@\n+            } else if (tp.getLeaf().getKind() == Kind.ANNOTATION) {\n+                Element el = at.trees().getElement(tp);\n+\n+                if (el == null ||\n+                    el.getKind() != ElementKind.ANNOTATION_TYPE) {\n+                    \/\/erroneous state:\n+                    return Collections.emptyList();\n+                }\n+\n+                elements = ElementFilter.methodsIn(el.getEnclosedElements())\n+                                        .stream()\n+                                        .map(ee -> (Element) ee);\n@@ -2223,0 +2438,1 @@\n+        private final String filteringText;\n@@ -2232,0 +2448,11 @@\n+            this(continuation, continuation, matchesType);\n+        }\n+\n+        \/**\n+         * Create a {@code Suggestion} instance.\n+         *\n+         * @param continuation a candidate continuation of the user's input\n+         * @param filteringText a text that should be used for filtering\n+         * @param matchesType does the candidate match the target type\n+         *\/\n+        public SuggestionImpl(String continuation, String filteringText, boolean matchesType) {\n@@ -2233,0 +2460,1 @@\n+            this.filteringText = filteringText;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":245,"deletions":17,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    Atomic::add(&_sum, chunk);\n-    Atomic::store(&_max, max_chunks);\n+    AtomicAccess::add(&_sum, chunk);\n+    AtomicAccess::store(&_max, max_chunks);\n@@ -38,2 +38,2 @@\n-  int sum() { return Atomic::load(&_sum); }\n-  int max() { return Atomic::load(&_max); }\n+  int sum() { return AtomicAccess::load(&_sum); }\n+  int max() { return AtomicAccess::load(&_max); }\n","filename":"test\/hotspot\/gtest\/cds\/test_archiveWorkers.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -65,2 +65,2 @@\n-    Atomic::inc(&_num_do_work);\n-    bool orig_value = Atomic::cmpxchg(&_do_work_called_by[worker_id], false, true);\n+    AtomicAccess::inc(&_num_do_work);\n+    bool orig_value = AtomicAccess::cmpxchg(&_do_work_called_by[worker_id], false, true);\n@@ -71,1 +71,1 @@\n-    ASSERT_EQ(Atomic::load(&_num_do_work), num_workers);\n+    ASSERT_EQ(AtomicAccess::load(&_num_do_work), num_workers);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1BatchedGangTask.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -416,2 +416,2 @@\n-    Atomic::add(&_added, added);\n-    Atomic::add(&_found, found);\n+    AtomicAccess::add(&_added, added);\n+    AtomicAccess::add(&_found, found);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -46,1 +46,1 @@\n-  static uintx head(const G1FreeIdSet& set) { return Atomic::load(&set._head); }\n+  static uintx head(const G1FreeIdSet& set) { return AtomicAccess::load(&set._head); }\n@@ -109,1 +109,1 @@\n-    while (Atomic::load_acquire(_continue_running)) {\n+    while (AtomicAccess::load_acquire(_continue_running)) {\n@@ -116,1 +116,1 @@\n-    Atomic::add(_total_allocations, _allocations);\n+    AtomicAccess::add(_total_allocations, _allocations);\n@@ -148,1 +148,1 @@\n-  Atomic::release_store(&continue_running, false);\n+  AtomicAccess::release_store(&continue_running, false);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1FreeIdSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -62,1 +62,1 @@\n-    uint index = Atomic::fetch_then_add(&_claim_id, 1u);\n+    uint index = AtomicAccess::fetch_then_add(&_claim_id, 1u);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -138,1 +138,1 @@\n-    while (Atomic::load_acquire(_continue_running)) {\n+    while (AtomicAccess::load_acquire(_continue_running)) {\n@@ -145,1 +145,1 @@\n-    Atomic::add(_total_allocations, _allocations);\n+    AtomicAccess::add(_total_allocations, _allocations);\n@@ -175,1 +175,1 @@\n-      } else if (!Atomic::load_acquire(_continue_running)) {\n+      } else if (!AtomicAccess::load_acquire(_continue_running)) {\n@@ -225,1 +225,1 @@\n-  Atomic::release_store(&allocator_running, false);\n+  AtomicAccess::release_store(&allocator_running, false);\n@@ -230,1 +230,1 @@\n-  Atomic::release_store(&processor_running, false);\n+  AtomicAccess::release_store(&processor_running, false);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_bufferNodeAllocator.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n","filename":"test\/hotspot\/gtest\/oops\/test_markWord.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    ASSERT_TRUE(!rm.is_AllStack());\n+    ASSERT_TRUE(!rm.is_infinite_stack());\n@@ -87,2 +87,2 @@\n-  \/\/ Set_All sets AllStack bit\n-  ASSERT_TRUE(rm.is_AllStack());\n+  \/\/ Set_All sets the infinite bit\n+  ASSERT_TRUE(rm.is_infinite_stack());\n@@ -138,1 +138,1 @@\n-  ASSERT_TRUE(rm1.is_AllStack());\n+  ASSERT_TRUE(rm1.is_infinite_stack());\n@@ -154,2 +154,2 @@\n-  \/\/ AllStack bit does not count as a bound register\n-  rm.set_AllStack();\n+  \/\/ The infinite bit does not count as a bound register\n+  rm.set_infinite_stack();\n@@ -171,1 +171,1 @@\n-  \/\/ A pair with the AllStack bit does not count as a bound pair\n+  \/\/ A pair with the infinite bit does not count as a bound pair\n@@ -190,1 +190,1 @@\n-    \/\/ A set with the AllStack bit does not count as a bound set\n+    \/\/ A set with the infinite bit does not count as a bound set\n@@ -197,1 +197,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,350 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"runtime\/atomic.hpp\"\n-#include \"unittest.hpp\"\n-\n-\/\/ These tests of Atomic only verify functionality.  They don't verify atomicity.\n-\n-template<typename T>\n-struct AtomicAddTestSupport {\n-  volatile T _test_value;\n-\n-  AtomicAddTestSupport() : _test_value{} {}\n-\n-  void test_add() {\n-    T zero = 0;\n-    T five = 5;\n-    Atomic::store(&_test_value, zero);\n-    T value = Atomic::add(&_test_value, five);\n-    EXPECT_EQ(five, value);\n-    EXPECT_EQ(five, Atomic::load(&_test_value));\n-  }\n-\n-  void test_fetch_add() {\n-    T zero = 0;\n-    T five = 5;\n-    Atomic::store(&_test_value, zero);\n-    T value = Atomic::fetch_then_add(&_test_value, five);\n-    EXPECT_EQ(zero, value);\n-    EXPECT_EQ(five, Atomic::load(&_test_value));\n-  }\n-};\n-\n-TEST_VM(AtomicAddTest, int32) {\n-  using Support = AtomicAddTestSupport<int32_t>;\n-  Support().test_add();\n-  Support().test_fetch_add();\n-}\n-\n-TEST_VM(AtomicAddTest, int64) {\n-  using Support = AtomicAddTestSupport<int64_t>;\n-  Support().test_add();\n-  Support().test_fetch_add();\n-}\n-\n-TEST_VM(AtomicAddTest, ptr) {\n-  uint _test_values[10] = {};\n-  uint* volatile _test_value{};\n-\n-  uint* zero = &_test_values[0];\n-  uint* five = &_test_values[5];\n-  uint* six  = &_test_values[6];\n-\n-  Atomic::store(&_test_value, zero);\n-  uint* value = Atomic::add(&_test_value, 5);\n-  EXPECT_EQ(five, value);\n-  EXPECT_EQ(five, Atomic::load(&_test_value));\n-\n-  Atomic::store(&_test_value, zero);\n-  value = Atomic::fetch_then_add(&_test_value, 6);\n-  EXPECT_EQ(zero, value);\n-  EXPECT_EQ(six, Atomic::load(&_test_value));\n-};\n-\n-template<typename T>\n-struct AtomicXchgTestSupport {\n-  volatile T _test_value;\n-\n-  AtomicXchgTestSupport() : _test_value{} {}\n-\n-  void test() {\n-    T zero = 0;\n-    T five = 5;\n-    Atomic::store(&_test_value, zero);\n-    T res = Atomic::xchg(&_test_value, five);\n-    EXPECT_EQ(zero, res);\n-    EXPECT_EQ(five, Atomic::load(&_test_value));\n-  }\n-};\n-\n-TEST_VM(AtomicXchgTest, int32) {\n-  using Support = AtomicXchgTestSupport<int32_t>;\n-  Support().test();\n-}\n-\n-TEST_VM(AtomicXchgTest, int64) {\n-  using Support = AtomicXchgTestSupport<int64_t>;\n-  Support().test();\n-}\n-\n-template<typename T>\n-struct AtomicCmpxchgTestSupport {\n-  volatile T _test_value;\n-\n-  AtomicCmpxchgTestSupport() : _test_value{} {}\n-\n-  void test() {\n-    T zero = 0;\n-    T five = 5;\n-    T ten = 10;\n-    Atomic::store(&_test_value, zero);\n-    T res = Atomic::cmpxchg(&_test_value, five, ten);\n-    EXPECT_EQ(zero, res);\n-    EXPECT_EQ(zero, Atomic::load(&_test_value));\n-    res = Atomic::cmpxchg(&_test_value, zero, ten);\n-    EXPECT_EQ(zero, res);\n-    EXPECT_EQ(ten, Atomic::load(&_test_value));\n-  }\n-};\n-\n-TEST_VM(AtomicCmpxchgTest, int32) {\n-  using Support = AtomicCmpxchgTestSupport<int32_t>;\n-  Support().test();\n-}\n-\n-TEST_VM(AtomicCmpxchgTest, int64) {\n-  \/\/ Check if 64-bit atomics are available on the machine.\n-  if (!VM_Version::supports_cx8()) return;\n-\n-  using Support = AtomicCmpxchgTestSupport<int64_t>;\n-  Support().test();\n-}\n-\n-struct AtomicCmpxchg1ByteStressSupport {\n-  char _default_val;\n-  int  _base;\n-  char _array[7+32+7];\n-\n-  AtomicCmpxchg1ByteStressSupport() : _default_val(0x7a), _base(7), _array{} {}\n-\n-  void validate(char val, char val2, int index) {\n-    for (int i = 0; i < 7; i++) {\n-      EXPECT_EQ(_array[i], _default_val);\n-    }\n-    for (int i = 7; i < (7+32); i++) {\n-      if (i == index) {\n-        EXPECT_EQ(_array[i], val2);\n-      } else {\n-        EXPECT_EQ(_array[i], val);\n-      }\n-    }\n-    for (int i = 0; i < 7; i++) {\n-      EXPECT_EQ(_array[i], _default_val);\n-    }\n-  }\n-\n-  void test_index(int index) {\n-    char one = 1;\n-    Atomic::cmpxchg(&_array[index], _default_val, one);\n-    validate(_default_val, one, index);\n-\n-    Atomic::cmpxchg(&_array[index], one, _default_val);\n-    validate(_default_val, _default_val, index);\n-  }\n-\n-  void test() {\n-    memset(_array, _default_val, sizeof(_array));\n-    for (int i = _base; i < (_base+32); i++) {\n-      test_index(i);\n-    }\n-  }\n-};\n-\n-TEST_VM(AtomicCmpxchg1Byte, stress) {\n-  AtomicCmpxchg1ByteStressSupport support;\n-  support.test();\n-}\n-\n-template<typename T>\n-struct AtomicEnumTestSupport {\n-  volatile T _test_value;\n-\n-  AtomicEnumTestSupport() : _test_value{} {}\n-\n-  void test_store_load(T value) {\n-    EXPECT_NE(value, Atomic::load(&_test_value));\n-    Atomic::store(&_test_value, value);\n-    EXPECT_EQ(value, Atomic::load(&_test_value));\n-  }\n-\n-  void test_cmpxchg(T value1, T value2) {\n-    EXPECT_NE(value1, Atomic::load(&_test_value));\n-    Atomic::store(&_test_value, value1);\n-    EXPECT_EQ(value1, Atomic::cmpxchg(&_test_value, value2, value2));\n-    EXPECT_EQ(value1, Atomic::load(&_test_value));\n-    EXPECT_EQ(value1, Atomic::cmpxchg(&_test_value, value1, value2));\n-    EXPECT_EQ(value2, Atomic::load(&_test_value));\n-  }\n-\n-  void test_xchg(T value1, T value2) {\n-    EXPECT_NE(value1, Atomic::load(&_test_value));\n-    Atomic::store(&_test_value, value1);\n-    EXPECT_EQ(value1, Atomic::xchg(&_test_value, value2));\n-    EXPECT_EQ(value2, Atomic::load(&_test_value));\n-  }\n-};\n-\n-namespace AtomicEnumTestUnscoped {       \/\/ Scope the enumerators.\n-  enum TestEnum { A, B, C };\n-}\n-\n-TEST_VM(AtomicEnumTest, unscoped_enum) {\n-  using namespace AtomicEnumTestUnscoped;\n-  using Support = AtomicEnumTestSupport<TestEnum>;\n-\n-  Support().test_store_load(B);\n-  Support().test_cmpxchg(B, C);\n-  Support().test_xchg(B, C);\n-}\n-\n-enum class AtomicEnumTestScoped { A, B, C };\n-\n-TEST_VM(AtomicEnumTest, scoped_enum) {\n-  const AtomicEnumTestScoped B = AtomicEnumTestScoped::B;\n-  const AtomicEnumTestScoped C = AtomicEnumTestScoped::C;\n-  using Support = AtomicEnumTestSupport<AtomicEnumTestScoped>;\n-\n-  Support().test_store_load(B);\n-  Support().test_cmpxchg(B, C);\n-  Support().test_xchg(B, C);\n-}\n-\n-template<typename T>\n-struct AtomicBitopsTestSupport {\n-  volatile T _test_value;\n-\n-  \/\/ At least one byte differs between _old_value and _old_value op _change_value.\n-  static const T _old_value =    static_cast<T>(UCONST64(0x7f5300007f530044));\n-  static const T _change_value = static_cast<T>(UCONST64(0x3800530038005322));\n-\n-  AtomicBitopsTestSupport() : _test_value(0) {}\n-\n-  void fetch_then_and() {\n-    Atomic::store(&_test_value, _old_value);\n-    T expected = _old_value & _change_value;\n-    EXPECT_NE(_old_value, expected);\n-    T result = Atomic::fetch_then_and(&_test_value, _change_value);\n-    EXPECT_EQ(_old_value, result);\n-    EXPECT_EQ(expected, Atomic::load(&_test_value));\n-  }\n-\n-  void fetch_then_or() {\n-    Atomic::store(&_test_value, _old_value);\n-    T expected = _old_value | _change_value;\n-    EXPECT_NE(_old_value, expected);\n-    T result = Atomic::fetch_then_or(&_test_value, _change_value);\n-    EXPECT_EQ(_old_value, result);\n-    EXPECT_EQ(expected, Atomic::load(&_test_value));\n-  }\n-\n-  void fetch_then_xor() {\n-    Atomic::store(&_test_value, _old_value);\n-    T expected = _old_value ^ _change_value;\n-    EXPECT_NE(_old_value, expected);\n-    T result = Atomic::fetch_then_xor(&_test_value, _change_value);\n-    EXPECT_EQ(_old_value, result);\n-    EXPECT_EQ(expected, Atomic::load(&_test_value));\n-  }\n-\n-  void and_then_fetch() {\n-    Atomic::store(&_test_value, _old_value);\n-    T expected = _old_value & _change_value;\n-    EXPECT_NE(_old_value, expected);\n-    T result = Atomic::and_then_fetch(&_test_value, _change_value);\n-    EXPECT_EQ(expected, result);\n-    EXPECT_EQ(expected, Atomic::load(&_test_value));\n-  }\n-\n-  void or_then_fetch() {\n-    Atomic::store(&_test_value, _old_value);\n-    T expected = _old_value | _change_value;\n-    EXPECT_NE(_old_value, expected);\n-    T result = Atomic::or_then_fetch(&_test_value, _change_value);\n-    EXPECT_EQ(expected, result);\n-    EXPECT_EQ(expected, Atomic::load(&_test_value));\n-  }\n-\n-  void xor_then_fetch() {\n-    Atomic::store(&_test_value, _old_value);\n-    T expected = _old_value ^ _change_value;\n-    EXPECT_NE(_old_value, expected);\n-    T result = Atomic::xor_then_fetch(&_test_value, _change_value);\n-    EXPECT_EQ(expected, result);\n-    EXPECT_EQ(expected, Atomic::load(&_test_value));\n-  }\n-\n-#define TEST_BITOP(name) { SCOPED_TRACE(XSTR(name)); name(); }\n-\n-  void operator()() {\n-    TEST_BITOP(fetch_then_and)\n-    TEST_BITOP(fetch_then_or)\n-    TEST_BITOP(fetch_then_xor)\n-    TEST_BITOP(and_then_fetch)\n-    TEST_BITOP(or_then_fetch)\n-    TEST_BITOP(xor_then_fetch)\n-  }\n-\n-#undef TEST_BITOP\n-};\n-\n-template<typename T>\n-const T AtomicBitopsTestSupport<T>::_old_value;\n-\n-template<typename T>\n-const T AtomicBitopsTestSupport<T>::_change_value;\n-\n-TEST_VM(AtomicBitopsTest, int8) {\n-  AtomicBitopsTestSupport<int8_t>()();\n-}\n-\n-TEST_VM(AtomicBitopsTest, uint8) {\n-  AtomicBitopsTestSupport<uint8_t>()();\n-}\n-\n-TEST_VM(AtomicBitopsTest, int32) {\n-  AtomicBitopsTestSupport<int32_t>()();\n-}\n-\n-TEST_VM(AtomicBitopsTest, uint32) {\n-  AtomicBitopsTestSupport<uint32_t>()();\n-}\n-\n-TEST_VM(AtomicBitopsTest, int64) {\n-  AtomicBitopsTestSupport<int64_t>()();\n-}\n-\n-TEST_VM(AtomicBitopsTest, uint64) {\n-  AtomicBitopsTestSupport<uint64_t>()();\n-}\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomic.cpp","additions":0,"deletions":350,"binary":false,"changes":350,"status":"deleted"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/atomicAccess.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ These tests of AtomicAccess only verify functionality.  They don't verify\n+\/\/ atomicity.\n+\n+template<typename T>\n+struct AtomicAccessAddTestSupport {\n+  volatile T _test_value;\n+\n+  AtomicAccessAddTestSupport() : _test_value{} {}\n+\n+  void test_add() {\n+    T zero = 0;\n+    T five = 5;\n+    AtomicAccess::store(&_test_value, zero);\n+    T value = AtomicAccess::add(&_test_value, five);\n+    EXPECT_EQ(five, value);\n+    EXPECT_EQ(five, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void test_fetch_add() {\n+    T zero = 0;\n+    T five = 5;\n+    AtomicAccess::store(&_test_value, zero);\n+    T value = AtomicAccess::fetch_then_add(&_test_value, five);\n+    EXPECT_EQ(zero, value);\n+    EXPECT_EQ(five, AtomicAccess::load(&_test_value));\n+  }\n+};\n+\n+TEST_VM(AtomicAccessAddTest, int32) {\n+  using Support = AtomicAccessAddTestSupport<int32_t>;\n+  Support().test_add();\n+  Support().test_fetch_add();\n+}\n+\n+TEST_VM(AtomicAccessAddTest, int64) {\n+  using Support = AtomicAccessAddTestSupport<int64_t>;\n+  Support().test_add();\n+  Support().test_fetch_add();\n+}\n+\n+TEST_VM(AtomicAccessAddTest, ptr) {\n+  uint _test_values[10] = {};\n+  uint* volatile _test_value{};\n+\n+  uint* zero = &_test_values[0];\n+  uint* five = &_test_values[5];\n+  uint* six  = &_test_values[6];\n+\n+  AtomicAccess::store(&_test_value, zero);\n+  uint* value = AtomicAccess::add(&_test_value, 5);\n+  EXPECT_EQ(five, value);\n+  EXPECT_EQ(five, AtomicAccess::load(&_test_value));\n+\n+  AtomicAccess::store(&_test_value, zero);\n+  value = AtomicAccess::fetch_then_add(&_test_value, 6);\n+  EXPECT_EQ(zero, value);\n+  EXPECT_EQ(six, AtomicAccess::load(&_test_value));\n+};\n+\n+template<typename T>\n+struct AtomicAccessXchgTestSupport {\n+  volatile T _test_value;\n+\n+  AtomicAccessXchgTestSupport() : _test_value{} {}\n+\n+  void test() {\n+    T zero = 0;\n+    T five = 5;\n+    AtomicAccess::store(&_test_value, zero);\n+    T res = AtomicAccess::xchg(&_test_value, five);\n+    EXPECT_EQ(zero, res);\n+    EXPECT_EQ(five, AtomicAccess::load(&_test_value));\n+  }\n+};\n+\n+TEST_VM(AtomicAccessXchgTest, int32) {\n+  using Support = AtomicAccessXchgTestSupport<int32_t>;\n+  Support().test();\n+}\n+\n+TEST_VM(AtomicAccessXchgTest, int64) {\n+  using Support = AtomicAccessXchgTestSupport<int64_t>;\n+  Support().test();\n+}\n+\n+template<typename T>\n+struct AtomicAccessCmpxchgTestSupport {\n+  volatile T _test_value;\n+\n+  AtomicAccessCmpxchgTestSupport() : _test_value{} {}\n+\n+  void test() {\n+    T zero = 0;\n+    T five = 5;\n+    T ten = 10;\n+    AtomicAccess::store(&_test_value, zero);\n+    T res = AtomicAccess::cmpxchg(&_test_value, five, ten);\n+    EXPECT_EQ(zero, res);\n+    EXPECT_EQ(zero, AtomicAccess::load(&_test_value));\n+    res = AtomicAccess::cmpxchg(&_test_value, zero, ten);\n+    EXPECT_EQ(zero, res);\n+    EXPECT_EQ(ten, AtomicAccess::load(&_test_value));\n+  }\n+};\n+\n+TEST_VM(AtomicAccessCmpxchgTest, int32) {\n+  using Support = AtomicAccessCmpxchgTestSupport<int32_t>;\n+  Support().test();\n+}\n+\n+TEST_VM(AtomicAccessCmpxchgTest, int64) {\n+  \/\/ Check if 64-bit atomics are available on the machine.\n+  if (!VM_Version::supports_cx8()) return;\n+\n+  using Support = AtomicAccessCmpxchgTestSupport<int64_t>;\n+  Support().test();\n+}\n+\n+struct AtomicAccessCmpxchg1ByteStressSupport {\n+  char _default_val;\n+  int  _base;\n+  char _array[7+32+7];\n+\n+  AtomicAccessCmpxchg1ByteStressSupport() : _default_val(0x7a), _base(7), _array{} {}\n+\n+  void validate(char val, char val2, int index) {\n+    for (int i = 0; i < 7; i++) {\n+      EXPECT_EQ(_array[i], _default_val);\n+    }\n+    for (int i = 7; i < (7+32); i++) {\n+      if (i == index) {\n+        EXPECT_EQ(_array[i], val2);\n+      } else {\n+        EXPECT_EQ(_array[i], val);\n+      }\n+    }\n+    for (int i = 0; i < 7; i++) {\n+      EXPECT_EQ(_array[i], _default_val);\n+    }\n+  }\n+\n+  void test_index(int index) {\n+    char one = 1;\n+    AtomicAccess::cmpxchg(&_array[index], _default_val, one);\n+    validate(_default_val, one, index);\n+\n+    AtomicAccess::cmpxchg(&_array[index], one, _default_val);\n+    validate(_default_val, _default_val, index);\n+  }\n+\n+  void test() {\n+    memset(_array, _default_val, sizeof(_array));\n+    for (int i = _base; i < (_base+32); i++) {\n+      test_index(i);\n+    }\n+  }\n+};\n+\n+TEST_VM(AtomicAccessCmpxchg1Byte, stress) {\n+  AtomicAccessCmpxchg1ByteStressSupport support;\n+  support.test();\n+}\n+\n+template<typename T>\n+struct AtomicAccessEnumTestSupport {\n+  volatile T _test_value;\n+\n+  AtomicAccessEnumTestSupport() : _test_value{} {}\n+\n+  void test_store_load(T value) {\n+    EXPECT_NE(value, AtomicAccess::load(&_test_value));\n+    AtomicAccess::store(&_test_value, value);\n+    EXPECT_EQ(value, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void test_cmpxchg(T value1, T value2) {\n+    EXPECT_NE(value1, AtomicAccess::load(&_test_value));\n+    AtomicAccess::store(&_test_value, value1);\n+    EXPECT_EQ(value1, AtomicAccess::cmpxchg(&_test_value, value2, value2));\n+    EXPECT_EQ(value1, AtomicAccess::load(&_test_value));\n+    EXPECT_EQ(value1, AtomicAccess::cmpxchg(&_test_value, value1, value2));\n+    EXPECT_EQ(value2, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void test_xchg(T value1, T value2) {\n+    EXPECT_NE(value1, AtomicAccess::load(&_test_value));\n+    AtomicAccess::store(&_test_value, value1);\n+    EXPECT_EQ(value1, AtomicAccess::xchg(&_test_value, value2));\n+    EXPECT_EQ(value2, AtomicAccess::load(&_test_value));\n+  }\n+};\n+\n+namespace AtomicAccessEnumTestUnscoped {       \/\/ Scope the enumerators.\n+  enum TestEnum { A, B, C };\n+}\n+\n+TEST_VM(AtomicAccessEnumTest, unscoped_enum) {\n+  using namespace AtomicAccessEnumTestUnscoped;\n+  using Support = AtomicAccessEnumTestSupport<TestEnum>;\n+\n+  Support().test_store_load(B);\n+  Support().test_cmpxchg(B, C);\n+  Support().test_xchg(B, C);\n+}\n+\n+enum class AtomicAccessEnumTestScoped { A, B, C };\n+\n+TEST_VM(AtomicAccessEnumTest, scoped_enum) {\n+  const AtomicAccessEnumTestScoped B = AtomicAccessEnumTestScoped::B;\n+  const AtomicAccessEnumTestScoped C = AtomicAccessEnumTestScoped::C;\n+  using Support = AtomicAccessEnumTestSupport<AtomicAccessEnumTestScoped>;\n+\n+  Support().test_store_load(B);\n+  Support().test_cmpxchg(B, C);\n+  Support().test_xchg(B, C);\n+}\n+\n+template<typename T>\n+struct AtomicAccessBitopsTestSupport {\n+  volatile T _test_value;\n+\n+  \/\/ At least one byte differs between _old_value and _old_value op _change_value.\n+  static const T _old_value =    static_cast<T>(UCONST64(0x7f5300007f530044));\n+  static const T _change_value = static_cast<T>(UCONST64(0x3800530038005322));\n+\n+  AtomicAccessBitopsTestSupport() : _test_value(0) {}\n+\n+  void fetch_then_and() {\n+    AtomicAccess::store(&_test_value, _old_value);\n+    T expected = _old_value & _change_value;\n+    EXPECT_NE(_old_value, expected);\n+    T result = AtomicAccess::fetch_then_and(&_test_value, _change_value);\n+    EXPECT_EQ(_old_value, result);\n+    EXPECT_EQ(expected, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void fetch_then_or() {\n+    AtomicAccess::store(&_test_value, _old_value);\n+    T expected = _old_value | _change_value;\n+    EXPECT_NE(_old_value, expected);\n+    T result = AtomicAccess::fetch_then_or(&_test_value, _change_value);\n+    EXPECT_EQ(_old_value, result);\n+    EXPECT_EQ(expected, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void fetch_then_xor() {\n+    AtomicAccess::store(&_test_value, _old_value);\n+    T expected = _old_value ^ _change_value;\n+    EXPECT_NE(_old_value, expected);\n+    T result = AtomicAccess::fetch_then_xor(&_test_value, _change_value);\n+    EXPECT_EQ(_old_value, result);\n+    EXPECT_EQ(expected, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void and_then_fetch() {\n+    AtomicAccess::store(&_test_value, _old_value);\n+    T expected = _old_value & _change_value;\n+    EXPECT_NE(_old_value, expected);\n+    T result = AtomicAccess::and_then_fetch(&_test_value, _change_value);\n+    EXPECT_EQ(expected, result);\n+    EXPECT_EQ(expected, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void or_then_fetch() {\n+    AtomicAccess::store(&_test_value, _old_value);\n+    T expected = _old_value | _change_value;\n+    EXPECT_NE(_old_value, expected);\n+    T result = AtomicAccess::or_then_fetch(&_test_value, _change_value);\n+    EXPECT_EQ(expected, result);\n+    EXPECT_EQ(expected, AtomicAccess::load(&_test_value));\n+  }\n+\n+  void xor_then_fetch() {\n+    AtomicAccess::store(&_test_value, _old_value);\n+    T expected = _old_value ^ _change_value;\n+    EXPECT_NE(_old_value, expected);\n+    T result = AtomicAccess::xor_then_fetch(&_test_value, _change_value);\n+    EXPECT_EQ(expected, result);\n+    EXPECT_EQ(expected, AtomicAccess::load(&_test_value));\n+  }\n+\n+#define TEST_BITOP(name) { SCOPED_TRACE(XSTR(name)); name(); }\n+\n+  void operator()() {\n+    TEST_BITOP(fetch_then_and)\n+    TEST_BITOP(fetch_then_or)\n+    TEST_BITOP(fetch_then_xor)\n+    TEST_BITOP(and_then_fetch)\n+    TEST_BITOP(or_then_fetch)\n+    TEST_BITOP(xor_then_fetch)\n+  }\n+\n+#undef TEST_BITOP\n+};\n+\n+template<typename T>\n+const T AtomicAccessBitopsTestSupport<T>::_old_value;\n+\n+template<typename T>\n+const T AtomicAccessBitopsTestSupport<T>::_change_value;\n+\n+TEST_VM(AtomicAccessBitopsTest, int8) {\n+  AtomicAccessBitopsTestSupport<int8_t>()();\n+}\n+\n+TEST_VM(AtomicAccessBitopsTest, uint8) {\n+  AtomicAccessBitopsTestSupport<uint8_t>()();\n+}\n+\n+TEST_VM(AtomicAccessBitopsTest, int32) {\n+  AtomicAccessBitopsTestSupport<int32_t>()();\n+}\n+\n+TEST_VM(AtomicAccessBitopsTest, uint32) {\n+  AtomicAccessBitopsTestSupport<uint32_t>()();\n+}\n+\n+TEST_VM(AtomicAccessBitopsTest, int64) {\n+  AtomicAccessBitopsTestSupport<int64_t>()();\n+}\n+\n+TEST_VM(AtomicAccessBitopsTest, uint64) {\n+  AtomicAccessBitopsTestSupport<uint64_t>()();\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_atomicAccess.cpp","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -41,4 +41,6 @@\n-    VirtualMemoryTracker::Instance::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n-\n-    \/\/ snapshot current stack usage\n-    VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n+    {\n+      MemTracker::NmtVirtualMemoryLocker nvml;\n+      VirtualMemoryTracker::Instance::add_reserved_region(stack_end, stack_size, CALLER_PC, mtThreadStack);\n+      \/\/ snapshot current stack usage\n+      VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n+    }\n@@ -109,3 +111,6 @@\n-    VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n-\n-    ReservedMemoryRegion rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    ReservedMemoryRegion rmr_found;\n+    {\n+      MemTracker::NmtVirtualMemoryLocker nvml;\n+      VirtualMemoryTracker::Instance::snapshot_thread_stacks();\n+      rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    }\n@@ -117,9 +122,12 @@\n-    VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr){\n-      if (cmr.size() == size) {\n-        return false;\n-      } else {\n-        precise_tracking_supported = true;\n-        check_covered_pages(cmr.base(), cmr.size(), (address)base, touch_pages, page_num);\n-      }\n-      return true;\n-    });\n+    {\n+      MemTracker::NmtVirtualMemoryLocker nvml;\n+      VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr_found, [&](const CommittedMemoryRegion& cmr){\n+        if (cmr.size() == size) {\n+          return false;\n+        } else {\n+          precise_tracking_supported = true;\n+          check_covered_pages(cmr.base(), cmr.size(), (address)base, touch_pages, page_num);\n+        }\n+        return true;\n+      });\n+    }\n@@ -136,2 +144,5 @@\n-    VirtualMemoryTracker::Instance::remove_released_region((address)base, size);\n-    rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    {\n+      MemTracker::NmtVirtualMemoryLocker nvml;\n+      VirtualMemoryTracker::Instance::remove_released_region((address)base, size);\n+      rmr_found = VirtualMemoryTracker::Instance::tree()->find_reserved_region((address)base);\n+    }\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":29,"deletions":18,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  VirtualMemoryTracker::Instance::tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n+  vmt.tree()->visit_committed_regions(rmr, [&](CommittedMemoryRegion& region) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1200,1 +1200,1 @@\n-    Atomic::add(_total_scanned, par_scan._count);\n+    AtomicAccess::add(_total_scanned, par_scan._count);\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -47,2 +47,2 @@\n-      volatile TestData* read_test = Atomic::load_acquire(_test);\n-      long value = Atomic::load_acquire(&read_test->test_value);\n+      volatile TestData* read_test = AtomicAccess::load_acquire(_test);\n+      long value = AtomicAccess::load_acquire(&read_test->test_value);\n@@ -53,2 +53,2 @@\n-        volatile TestData* test = Atomic::load_acquire(_test);\n-        long value = Atomic::load_acquire(&test->test_value);\n+        volatile TestData* test = AtomicAccess::load_acquire(_test);\n+        long value = AtomicAccess::load_acquire(&test->test_value);\n@@ -64,1 +64,1 @@\n-  Atomic::release_store(&test, tmp);\n+  AtomicAccess::release_store(&test, tmp);\n@@ -77,1 +77,1 @@\n-    Atomic::release_store(&test, tmp);\n+    AtomicAccess::release_store(&test, tmp);\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalCounter.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -55,1 +55,1 @@\n-    Atomic::release_store(&_state, new_state);\n+    AtomicAccess::release_store(&_state, new_state);\n@@ -60,2 +60,2 @@\n-    Atomic::release_store(&_state, new_state);\n-    while (!Atomic::load_acquire(&_proceed)) {\n+    AtomicAccess::release_store(&_state, new_state);\n+    while (!AtomicAccess::load_acquire(&_proceed)) {\n@@ -64,1 +64,1 @@\n-    Atomic::release_store(&_proceed, false);\n+    AtomicAccess::release_store(&_proceed, false);\n@@ -69,1 +69,1 @@\n-    return Atomic::load_acquire(&_state);\n+    return AtomicAccess::load_acquire(&_state);\n@@ -80,1 +80,1 @@\n-    Atomic::release_store(&_proceed, true);\n+    AtomicAccess::release_store(&_proceed, true);\n","filename":"test\/hotspot\/gtest\/utilities\/test_globalCounter_nested.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -228,1 +228,1 @@\n-    Atomic::release_store_fence(&_ready, true);\n+    AtomicAccess::release_store_fence(&_ready, true);\n@@ -233,1 +233,1 @@\n-        Atomic::inc(_processed);\n+        AtomicAccess::inc(_processed);\n@@ -235,1 +235,1 @@\n-      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n+      } else if (AtomicAccess::load_acquire(_processed) == _process_limit) {\n@@ -242,1 +242,1 @@\n-  bool ready() const { return Atomic::load_acquire(&_ready); }\n+  bool ready() const { return AtomicAccess::load_acquire(&_ready); }\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeStack.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -205,1 +205,1 @@\n-    Atomic::release_store_fence(&_ready, true);\n+    AtomicAccess::release_store_fence(&_ready, true);\n@@ -210,1 +210,1 @@\n-        Atomic::inc(_processed);\n+        AtomicAccess::inc(_processed);\n@@ -212,1 +212,1 @@\n-      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n+      } else if (AtomicAccess::load_acquire(_processed) == _process_limit) {\n@@ -219,1 +219,1 @@\n-  bool ready() const { return Atomic::load_acquire(&_ready); }\n+  bool ready() const { return AtomicAccess::load_acquire(&_ready); }\n","filename":"test\/hotspot\/gtest\/utilities\/test_nonblockingQueue.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -58,1 +58,1 @@\n-    while (Atomic::load_acquire(_continue_running) != 0) {\n+    while (AtomicAccess::load_acquire(_continue_running) != 0) {\n@@ -62,1 +62,1 @@\n-      uintx value = Atomic::load_acquire(_synchronized_value);\n+      uintx value = AtomicAccess::load_acquire(_synchronized_value);\n@@ -65,1 +65,1 @@\n-        new_value = Atomic::load_acquire(_synchronized_value);\n+        new_value = AtomicAccess::load_acquire(_synchronized_value);\n@@ -99,1 +99,1 @@\n-    while (Atomic::load_acquire(_continue_running) != 0) {\n+    while (AtomicAccess::load_acquire(_continue_running) != 0) {\n","filename":"test\/hotspot\/gtest\/utilities\/test_singleWriterSynchronizer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -51,1 +51,1 @@\n-      tag = Atomic::load_acquire(&wait_tag);\n+      tag = AtomicAccess::load_acquire(&wait_tag);\n@@ -53,1 +53,1 @@\n-      Atomic::release_store(&_on_barrier, tag);\n+      AtomicAccess::release_store(&_on_barrier, tag);\n@@ -62,1 +62,1 @@\n-      vv = Atomic::load_acquire(&valid_value);\n+      vv = AtomicAccess::load_acquire(&valid_value);\n@@ -64,1 +64,1 @@\n-      Atomic::release_store(&_on_barrier, 0);\n+      AtomicAccess::release_store(&_on_barrier, 0);\n@@ -106,1 +106,1 @@\n-      Atomic::release_store_fence(&wait_tag, next_tag);\n+      AtomicAccess::release_store_fence(&wait_tag, next_tag);\n@@ -117,1 +117,1 @@\n-      Atomic::release_store(&valid_value, valid_value + 1); \/\/ odd\n+      AtomicAccess::release_store(&valid_value, valid_value + 1); \/\/ odd\n@@ -120,1 +120,1 @@\n-      Atomic::release_store(&valid_value, valid_value + 1); \/\/ even\n+      AtomicAccess::release_store(&valid_value, valid_value + 1); \/\/ even\n@@ -122,1 +122,1 @@\n-      Atomic::release_store_fence(&wait_tag, 0); \/\/ Stores in WB must not float up.\n+      AtomicAccess::release_store_fence(&wait_tag, 0); \/\/ Stores in WB must not float up.\n","filename":"test\/hotspot\/gtest\/utilities\/test_waitBarrier.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -292,1 +292,1 @@\n-    __ eaddl(r28, Address(r24, rcx, (Address::ScaleFactor)3, -0x6053edc2), r28, false); \/\/    {EVEX}add r28d, dword ptr [r24+rcx*8-0x6053edc2], r28d    IID268\n+    __ eaddl(r28, Address(r24, rcx, (Address::ScaleFactor)3, -0x6053edc2), r28, false); \/\/    add r28d, dword ptr [r24+rcx*8-0x6053edc2]    IID268\n@@ -295,33 +295,47 @@\n-    __ eorl(r30, Address(rbx, rdx, (Address::ScaleFactor)3, -0x463540b4), r28, false); \/\/    {EVEX}or r30d, dword ptr [rbx+rdx*8-0x463540b4], r28d    IID271\n-    __ eorl(r18, Address(r28, r10, (Address::ScaleFactor)3, +0x3523a73b), r18, false); \/\/    {EVEX}or r18d, dword ptr [r28+r10*8+0x3523a73b], r18d    IID272\n-    __ eorl(r9, Address(r15, r15, (Address::ScaleFactor)1, -0x2a0bdd56), r21, true); \/\/    {NF}or r9d, dword ptr [r15+r15*2-0x2a0bdd56], r21d    IID273\n-    __ eorl(r16, Address(r23, -0x165064ff), r16, true);                         \/\/    {NF}or r16d, dword ptr [r23-0x165064ff], r16d    IID274\n-    __ eorb(r28, Address(r30, r11, (Address::ScaleFactor)0, +0x17281e3a), r20, false); \/\/    {EVEX}or r28b, byte ptr [r30+r11*1+0x17281e3a], r20b    IID275\n-    __ eorb(rdx, Address(rbx, r31, (Address::ScaleFactor)2, +0x2477b5bb), rdx, false); \/\/    {EVEX}or dl, byte ptr [rbx+r31*4+0x2477b5bb], dl    IID276\n-    __ eorb(r16, Address(r11, rcx, (Address::ScaleFactor)1, -0x3175d1af), r24, true); \/\/    {NF}or r16b, byte ptr [r11+rcx*2-0x3175d1af], r24b    IID277\n-    __ eorb(rbx, Address(r11, r20, (Address::ScaleFactor)3, -0x22d67bd3), rbx, true); \/\/    {NF}or bl, byte ptr [r11+r20*8-0x22d67bd3], bl    IID278\n-    __ esubl(r26, Address(r27, r30, (Address::ScaleFactor)1, -0x3d9bce2e), rdx, false); \/\/    {EVEX}sub r26d, dword ptr [r27+r30*2-0x3d9bce2e], edx    IID279\n-    __ esubl(r31, Address(r22, r29, (Address::ScaleFactor)1, +0x14218519), r31, false); \/\/    {EVEX}sub r31d, dword ptr [r22+r29*2+0x14218519], r31d    IID280\n-    __ esubl(r21, Address(r9, -0x1050127a), r13, true);                         \/\/    {NF}sub r21d, dword ptr [r9-0x1050127a], r13d    IID281\n-    __ esubl(r31, Address(r9, r8, (Address::ScaleFactor)0, -0xae18961), r31, true); \/\/    {NF}sub r31d, dword ptr [r9+r8*1-0xae18961], r31d    IID282\n-    __ exorl(r15, Address(r18, +0x5c2bbce5), r12, false);                       \/\/    {EVEX}xor r15d, dword ptr [r18+0x5c2bbce5], r12d    IID283\n-    __ exorl(r27, Address(r25, r23, (Address::ScaleFactor)0, +0x5c6078b3), r27, false); \/\/    {EVEX}xor r27d, dword ptr [r25+r23*1+0x5c6078b3], r27d    IID284\n-    __ exorl(r18, Address(r8, rdx, (Address::ScaleFactor)3, -0x9ed3881), r14, true); \/\/    {NF}xor r18d, dword ptr [r8+rdx*8-0x9ed3881], r14d    IID285\n-    __ exorl(r9, Address(r15, +0x775acdad), r9, true);                          \/\/    {NF}xor r9d, dword ptr [r15+0x775acdad], r9d    IID286\n-    __ exorb(r21, Address(r18, r26, (Address::ScaleFactor)1, +0x2fe31fd5), r23, false); \/\/    {EVEX}xor r21b, byte ptr [r18+r26*2+0x2fe31fd5], r23b    IID287\n-    __ exorb(r10, Address(r27, +0xa3150de), r10, false);                        \/\/    {EVEX}xor r10b, byte ptr [r27+0xa3150de], r10b    IID288\n-    __ exorb(r18, Address(r22, r30, (Address::ScaleFactor)3, +0x1ad4e897), r24, true); \/\/    {NF}xor r18b, byte ptr [r22+r30*8+0x1ad4e897], r24b    IID289\n-    __ exorb(r8, Address(r16, r20, (Address::ScaleFactor)0, +0x626eae82), r8, true); \/\/    {NF}xor r8b, byte ptr [r16+r20*1+0x626eae82], r8b    IID290\n-    __ eaddl(r21, r15, 1048576, false);                                         \/\/    {EVEX}add r21d, r15d, 1048576    IID291\n-    __ eaddl(rax, r18, 1048576, false);                                         \/\/    {EVEX}add eax, r18d, 1048576    IID292\n-    __ eaddl(r18, r18, 256, false);                                             \/\/    add r18d, 256    IID293\n-    __ eaddl(r13, r19, 16, true);                                               \/\/    {NF}add r13d, r19d, 16    IID294\n-    __ eaddl(rax, r23, 16, true);                                               \/\/    {NF}add eax, r23d, 16    IID295\n-    __ eaddl(r25, r25, 16777216, true);                                         \/\/    {NF}add r25d, r25d, 16777216    IID296\n-    __ eandl(r29, r18, 1048576, false);                                         \/\/    {EVEX}and r29d, r18d, 1048576    IID297\n-    __ eandl(rax, r14, 1048576, false);                                         \/\/    {EVEX}and eax, r14d, 1048576    IID298\n-    __ eandl(r19, r19, 65536, false);                                           \/\/    and r19d, 65536    IID299\n-    __ eandl(r27, r25, 1048576, true);                                          \/\/    {NF}and r27d, r25d, 1048576    IID300\n-    __ eandl(rax, r20, 1048576, true);                                          \/\/    {NF}and eax, r20d, 1048576    IID301\n-    __ eandl(r28, r28, 16, true);                                               \/\/    {NF}and r28d, r28d, 16    IID302\n-    __ eimull(r31, r22, 4096, false);                                           \/\/    {EVEX}imul r31d, r22d, 4096    IID303\n+    __ eandl(r30, Address(rbx, rdx, (Address::ScaleFactor)3, -0x463540b4), r28, false); \/\/    {EVEX}and r30d, dword ptr [rbx+rdx*8-0x463540b4], r28d    IID271\n+    __ eandl(r18, Address(r28, r10, (Address::ScaleFactor)3, +0x3523a73b), r18, false); \/\/    and r18d, dword ptr [r28+r10*8+0x3523a73b]    IID272\n+    __ eandl(r9, Address(r15, r15, (Address::ScaleFactor)1, -0x2a0bdd56), r21, true); \/\/    {NF}and r9d, dword ptr [r15+r15*2-0x2a0bdd56], r21d    IID273\n+    __ eandl(r16, Address(r23, -0x165064ff), r16, true);                        \/\/    {NF}and r16d, dword ptr [r23-0x165064ff], r16d    IID274\n+    __ eorl(r28, Address(r30, r11, (Address::ScaleFactor)0, +0x17281e3a), r20, false); \/\/    {EVEX}or r28d, dword ptr [r30+r11*1+0x17281e3a], r20d    IID275\n+    __ eorl(rdx, Address(rbx, r31, (Address::ScaleFactor)2, +0x2477b5bb), rdx, false); \/\/    or edx, dword ptr [rbx+r31*4+0x2477b5bb]    IID276\n+    __ eorl(r16, Address(r11, rcx, (Address::ScaleFactor)1, -0x3175d1af), r24, true); \/\/    {NF}or r16d, dword ptr [r11+rcx*2-0x3175d1af], r24d    IID277\n+    __ eorl(rbx, Address(r11, r20, (Address::ScaleFactor)3, -0x22d67bd3), rbx, true); \/\/    {NF}or ebx, dword ptr [r11+r20*8-0x22d67bd3], ebx    IID278\n+    __ eorb(r26, Address(r27, r30, (Address::ScaleFactor)1, -0x3d9bce2e), rdx, false); \/\/    {EVEX}or r26b, byte ptr [r27+r30*2-0x3d9bce2e], dl    IID279\n+    __ eorb(r31, Address(r22, r29, (Address::ScaleFactor)1, +0x14218519), r31, false); \/\/    or r31b, byte ptr [r22+r29*2+0x14218519]    IID280\n+    __ eorb(r21, Address(r9, -0x1050127a), r13, true);                          \/\/    {NF}or r21b, byte ptr [r9-0x1050127a], r13b    IID281\n+    __ eorb(r31, Address(r9, r8, (Address::ScaleFactor)0, -0xae18961), r31, true); \/\/    {NF}or r31b, byte ptr [r9+r8*1-0xae18961], r31b    IID282\n+    __ esubl(r15, Address(r18, +0x5c2bbce5), r12, false);                       \/\/    {EVEX}sub r15d, dword ptr [r18+0x5c2bbce5], r12d    IID283\n+    __ esubl(r27, Address(r25, r23, (Address::ScaleFactor)0, +0x5c6078b3), r27, false); \/\/    {EVEX}sub r27d, dword ptr [r25+r23*1+0x5c6078b3], r27d    IID284\n+    __ esubl(r18, Address(r8, rdx, (Address::ScaleFactor)3, -0x9ed3881), r14, true); \/\/    {NF}sub r18d, dword ptr [r8+rdx*8-0x9ed3881], r14d    IID285\n+    __ esubl(r9, Address(r15, +0x775acdad), r9, true);                          \/\/    {NF}sub r9d, dword ptr [r15+0x775acdad], r9d    IID286\n+    __ exorl(r21, Address(r18, r26, (Address::ScaleFactor)1, +0x2fe31fd5), r23, false); \/\/    {EVEX}xor r21d, dword ptr [r18+r26*2+0x2fe31fd5], r23d    IID287\n+    __ exorl(r10, Address(r27, +0xa3150de), r10, false);                        \/\/    xor r10d, dword ptr [r27+0xa3150de]    IID288\n+    __ exorl(r18, Address(r22, r30, (Address::ScaleFactor)3, +0x1ad4e897), r24, true); \/\/    {NF}xor r18d, dword ptr [r22+r30*8+0x1ad4e897], r24d    IID289\n+    __ exorl(r8, Address(r16, r20, (Address::ScaleFactor)0, +0x626eae82), r8, true); \/\/    {NF}xor r8d, dword ptr [r16+r20*1+0x626eae82], r8d    IID290\n+    __ exorb(r16, Address(r21, r15, (Address::ScaleFactor)0, -0x1403b60d), r18, false); \/\/    {EVEX}xor r16b, byte ptr [r21+r15*1-0x1403b60d], r18b    IID291\n+    __ exorb(r13, Address(r19, r23, (Address::ScaleFactor)2, +0x237ef1e1), r13, false); \/\/    xor r13b, byte ptr [r19+r23*4+0x237ef1e1]    IID292\n+    __ exorb(r29, Address(r18, r14, (Address::ScaleFactor)2, +0x5cc0095b), r14, true); \/\/    {NF}xor r29b, byte ptr [r18+r14*4+0x5cc0095b], r14b    IID293\n+    __ exorb(r27, Address(r25, r20, (Address::ScaleFactor)3, +0x1cf7b958), r27, true); \/\/    {NF}xor r27b, byte ptr [r25+r20*8+0x1cf7b958], r27b    IID294\n+    __ eaddl(r16, r24, 16, false);                                              \/\/    {EVEX}add r16d, r24d, 16    IID295\n+    __ eaddl(rax, r24, 16, false);                                              \/\/    {EVEX}add eax, r24d, 16    IID296\n+    __ eaddl(r21, r21, 65536, false);                                           \/\/    add r21d, 65536    IID297\n+    __ eaddl(r24, r8, 1048576, true);                                           \/\/    {NF}add r24d, r8d, 1048576    IID298\n+    __ eaddl(rax, r13, 1048576, true);                                          \/\/    {NF}add eax, r13d, 1048576    IID299\n+    __ eaddl(r29, r29, 16777216, true);                                         \/\/    {NF}add r29d, r29d, 16777216    IID300\n+    __ eandl(r12, r12, 16, false);                                              \/\/    and r12d, 16    IID301\n+    __ eandl(rax, r30, 16, false);                                              \/\/    {EVEX}and eax, r30d, 16    IID302\n+    __ eandl(r24, r24, 16, false);                                              \/\/    and r24d, 16    IID303\n+    __ eandl(r8, r12, 1, true);                                                 \/\/    {NF}and r8d, r12d, 1    IID304\n+    __ eandl(rax, r13, 1, true);                                                \/\/    {NF}and eax, r13d, 1    IID305\n+    __ eandl(r25, r25, 16, true);                                               \/\/    {NF}and r25d, r25d, 16    IID306\n+    __ eimull(r18, r23, 65536, false);                                          \/\/    {EVEX}imul r18d, r23d, 65536    IID307\n+    __ eimull(rax, r9, 65536, false);                                           \/\/    {EVEX}imul eax, r9d, 65536    IID308\n+    __ eimull(r26, r26, 268435456, false);                                      \/\/    {EVEX}imul r26d, r26d, 268435456    IID309\n+    __ eimull(r25, r21, 1, true);                                               \/\/    {NF}imul r25d, r21d, 1    IID310\n+    __ eimull(rax, r24, 1, true);                                               \/\/    {NF}imul eax, r24d, 1    IID311\n+    __ eimull(r24, r24, 16777216, true);                                        \/\/    {NF}imul r24d, r24d, 16777216    IID312\n+    __ eorl(r30, r26, 1, false);                                                \/\/    {EVEX}or r30d, r26d, 1    IID313\n+    __ eorl(rax, r22, 1, false);                                                \/\/    {EVEX}or eax, r22d, 1    IID314\n+    __ eorl(r17, r17, 1048576, false);                                          \/\/    or r17d, 1048576    IID315\n+    __ eorl(r24, r8, 1, true);                                                  \/\/    {NF}or r24d, r8d, 1    IID316\n+    __ eorl(rax, r27, 1, true);                                                 \/\/    {NF}or eax, r27d, 1    IID317\n@@ -329,1 +343,1 @@\n-    __ eimull(rax, rbx, 4096, false);                                           \/\/    {EVEX}imul eax, ebx, 4096    IID304\n+    __ eorl(rdx, rdx, 268435456, true);                                         \/\/    {NF}or edx, edx, 268435456    IID318\n@@ -331,14 +345,49 @@\n-    __ eimull(r24, r24, 1048576, false);                                        \/\/    {EVEX}imul r24d, r24d, 1048576    IID305\n-    __ eimull(r21, r16, 65536, true);                                           \/\/    {NF}imul r21d, r16d, 65536    IID306\n-    __ eimull(rax, r24, 65536, true);                                           \/\/    {NF}imul eax, r24d, 65536    IID307\n-    __ eimull(r13, r13, 16, true);                                              \/\/    {NF}imul r13d, r13d, 16    IID308\n-    __ eorl(r29, r8, 16777216, false);                                          \/\/    {EVEX}or r29d, r8d, 16777216    IID309\n-    __ eorl(rax, r12, 16777216, false);                                         \/\/    {EVEX}or eax, r12d, 16777216    IID310\n-    __ eorl(r30, r30, 4096, false);                                             \/\/    or r30d, 4096    IID311\n-    __ eorl(r24, rdx, 16, true);                                                \/\/    {NF}or r24d, edx, 16    IID312\n-    __ eorl(rax, r8, 16, true);                                                 \/\/    {NF}or eax, r8d, 16    IID313\n-    __ eorl(r13, r13, 4096, true);                                              \/\/    {NF}or r13d, r13d, 4096    IID314\n-    __ ercll(r25, r13, 1);                                                      \/\/    {EVEX}rcl r25d, r13d, 1    IID315\n-    __ ercll(rax, r18, 1);                                                      \/\/    {EVEX}rcl eax, r18d, 1    IID316\n-    __ ercll(r9, r9, 16);                                                       \/\/    rcl r9d, 16    IID317\n-    __ eroll(r26, r25, 8, false);                                               \/\/    {EVEX}rol r26d, r25d, 8    IID318\n+    __ ercll(r22, r22, 8);                                                      \/\/    rcl r22d, 8    IID319\n+    __ ercll(rax, r23, 8);                                                      \/\/    {EVEX}rcl eax, r23d, 8    IID320\n+    __ ercll(r19, r19, 4);                                                      \/\/    rcl r19d, 4    IID321\n+    __ eroll(r30, r24, 2, false);                                               \/\/    {EVEX}rol r30d, r24d, 2    IID322\n+    __ eroll(rax, r29, 2, false);                                               \/\/    {EVEX}rol eax, r29d, 2    IID323\n+    __ eroll(r8, r8, 2, false);                                                 \/\/    rol r8d, 2    IID324\n+    __ eroll(r18, r24, 16, true);                                               \/\/    {NF}rol r18d, r24d, 16    IID325\n+    __ eroll(rax, r13, 16, true);                                               \/\/    {NF}rol eax, r13d, 16    IID326\n+    __ eroll(r24, r24, 1, true);                                                \/\/    {NF}rol r24d, r24d, 1    IID327\n+    __ erorl(r28, r17, 16, false);                                              \/\/    {EVEX}ror r28d, r17d, 16    IID328\n+    __ erorl(rax, r24, 16, false);                                              \/\/    {EVEX}ror eax, r24d, 16    IID329\n+    __ erorl(r17, r17, 4, false);                                               \/\/    ror r17d, 4    IID330\n+    __ erorl(r24, rcx, 4, true);                                                \/\/    {NF}ror r24d, ecx, 4    IID331\n+    __ erorl(rax, r16, 4, true);                                                \/\/    {NF}ror eax, r16d, 4    IID332\n+    __ erorl(r15, r15, 2, true);                                                \/\/    {NF}ror r15d, r15d, 2    IID333\n+    __ esall(r14, r27, 4, false);                                               \/\/    {EVEX}sal r14d, r27d, 4    IID334\n+    __ esall(rax, r23, 4, false);                                               \/\/    {EVEX}sal eax, r23d, 4    IID335\n+    __ esall(r30, r30, 4, false);                                               \/\/    sal r30d, 4    IID336\n+    __ esall(r27, rdx, 2, true);                                                \/\/    {NF}sal r27d, edx, 2    IID337\n+    __ esall(rax, r19, 2, true);                                                \/\/    {NF}sal eax, r19d, 2    IID338\n+    __ esall(r20, r20, 2, true);                                                \/\/    {NF}sal r20d, r20d, 2    IID339\n+    __ esarl(r21, r23, 1, false);                                               \/\/    {EVEX}sar r21d, r23d, 1    IID340\n+    __ esarl(rax, r30, 1, false);                                               \/\/    {EVEX}sar eax, r30d, 1    IID341\n+    __ esarl(r25, r25, 2, false);                                               \/\/    sar r25d, 2    IID342\n+    __ esarl(r24, r19, 4, true);                                                \/\/    {NF}sar r24d, r19d, 4    IID343\n+    __ esarl(rax, r14, 4, true);                                                \/\/    {NF}sar eax, r14d, 4    IID344\n+    __ esarl(r26, r26, 16, true);                                               \/\/    {NF}sar r26d, r26d, 16    IID345\n+    __ eshll(r22, r13, 8, false);                                               \/\/    {EVEX}shl r22d, r13d, 8    IID346\n+    __ eshll(rax, r24, 8, false);                                               \/\/    {EVEX}shl eax, r24d, 8    IID347\n+    __ eshll(r14, r14, 16, false);                                              \/\/    shl r14d, 16    IID348\n+    __ eshll(r28, r25, 8, true);                                                \/\/    {NF}shl r28d, r25d, 8    IID349\n+    __ eshll(rax, r10, 8, true);                                                \/\/    {NF}shl eax, r10d, 8    IID350\n+    __ eshll(r20, r20, 1, true);                                                \/\/    {NF}shl r20d, r20d, 1    IID351\n+    __ eshrl(r12, rbx, 4, false);                                               \/\/    {EVEX}shr r12d, ebx, 4    IID352\n+    __ eshrl(rax, r23, 4, false);                                               \/\/    {EVEX}shr eax, r23d, 4    IID353\n+    __ eshrl(r28, r28, 16, false);                                              \/\/    shr r28d, 16    IID354\n+    __ eshrl(r24, r30, 4, true);                                                \/\/    {NF}shr r24d, r30d, 4    IID355\n+    __ eshrl(rax, r31, 4, true);                                                \/\/    {NF}shr eax, r31d, 4    IID356\n+    __ eshrl(r31, r31, 2, true);                                                \/\/    {NF}shr r31d, r31d, 2    IID357\n+    __ esubl(r20, r10, 256, false);                                             \/\/    {EVEX}sub r20d, r10d, 256    IID358\n+    __ esubl(rax, r13, 256, false);                                             \/\/    {EVEX}sub eax, r13d, 256    IID359\n+    __ esubl(r25, r25, 256, false);                                             \/\/    sub r25d, 256    IID360\n+    __ esubl(r23, r12, 268435456, true);                                        \/\/    {NF}sub r23d, r12d, 268435456    IID361\n+    __ esubl(rax, r16, 268435456, true);                                        \/\/    {NF}sub eax, r16d, 268435456    IID362\n+    __ esubl(r31, r31, 1, true);                                                \/\/    {NF}sub r31d, r31d, 1    IID363\n+    __ exorl(r9, r15, 16777216, false);                                         \/\/    {EVEX}xor r9d, r15d, 16777216    IID364\n+    __ exorl(rax, r13, 16777216, false);                                        \/\/    {EVEX}xor eax, r13d, 16777216    IID365\n+    __ exorl(r28, r28, 16, false);                                              \/\/    xor r28d, 16    IID366\n+    __ exorl(r29, r22, 16, true);                                               \/\/    {NF}xor r29d, r22d, 16    IID367\n@@ -346,1 +395,1 @@\n-    __ eroll(rax, rdx, 8, false);                                               \/\/    {EVEX}rol eax, edx, 8    IID319\n+    __ exorl(rax, rbx, 16, true);                                               \/\/    {NF}xor eax, ebx, 16    IID368\n@@ -348,5 +397,62 @@\n-    __ eroll(r24, r24, 16, false);                                              \/\/    rol r24d, 16    IID320\n-    __ eroll(r24, rcx, 8, true);                                                \/\/    {NF}rol r24d, ecx, 8    IID321\n-    __ eroll(rax, r30, 8, true);                                                \/\/    {NF}rol eax, r30d, 8    IID322\n-    __ eroll(r28, r28, 16, true);                                               \/\/    {NF}rol r28d, r28d, 16    IID323\n-    __ erorl(r17, r28, 4, false);                                               \/\/    {EVEX}ror r17d, r28d, 4    IID324\n+    __ exorl(r8, r8, 16, true);                                                 \/\/    {NF}xor r8d, r8d, 16    IID369\n+    __ esubl_imm32(r16, r13, 4194304, false);                                   \/\/    {EVEX}sub r16d, r13d, 4194304    IID370\n+    __ esubl_imm32(rax, r12, 4194304, false);                                   \/\/    {EVEX}sub eax, r12d, 4194304    IID371\n+    __ esubl_imm32(r17, r17, 67108864, false);                                  \/\/    sub r17d, 67108864    IID372\n+    __ esubl_imm32(r22, r26, 1073741824, true);                                 \/\/    {NF}sub r22d, r26d, 1073741824    IID373\n+    __ esubl_imm32(rax, r10, 1073741824, true);                                 \/\/    {NF}sub eax, r10d, 1073741824    IID374\n+    __ esubl_imm32(r11, r11, 1073741824, true);                                 \/\/    {NF}sub r11d, r11d, 1073741824    IID375\n+    __ eaddl(r19, r12, Address(r30, r8, (Address::ScaleFactor)0, +0x6a1a0a73), false); \/\/    {EVEX}add r19d, r12d, dword ptr [r30+r8*1+0x6a1a0a73]    IID376\n+    __ eaddl(r30, r30, Address(r18, r19, (Address::ScaleFactor)2, +0x25f990cf), false); \/\/    add r30d, dword ptr [r18+r19*4+0x25f990cf]    IID377\n+    __ eaddl(rcx, r25, Address(r19, r16, (Address::ScaleFactor)0, +0x482d5dbc), true); \/\/    {NF}add ecx, r25d, dword ptr [r19+r16*1+0x482d5dbc]    IID378\n+    __ eaddl(r9, r9, Address(r11, +0x43d5ee01), true);                          \/\/    {NF}add r9d, r9d, dword ptr [r11+0x43d5ee01]    IID379\n+    __ eandl(rcx, r23, Address(r21, r15, (Address::ScaleFactor)2, +0x2825c2bc), false); \/\/    {EVEX}and ecx, r23d, dword ptr [r21+r15*4+0x2825c2bc]    IID380\n+    __ eandl(r27, r27, Address(r13, r15, (Address::ScaleFactor)3, -0x1268b895), false); \/\/    and r27d, dword ptr [r13+r15*8-0x1268b895]    IID381\n+    __ eandl(r9, r23, Address(r22, r30, (Address::ScaleFactor)0, -0x715acbb), true); \/\/    {NF}and r9d, r23d, dword ptr [r22+r30*1-0x715acbb]    IID382\n+    __ eandl(rbx, rbx, Address(r28, r16, (Address::ScaleFactor)2, +0xb0223ee), true); \/\/    {NF}and ebx, ebx, dword ptr [r28+r16*4+0xb0223ee]    IID383\n+    __ eimull(r15, r29, Address(r15, r28, (Address::ScaleFactor)1, -0x1f297a69), false); \/\/    {EVEX}imul r15d, r29d, dword ptr [r15+r28*2-0x1f297a69]    IID384\n+    __ eimull(r17, r17, Address(r23, rbx, (Address::ScaleFactor)1, +0xadc7545), false); \/\/    imul r17d, dword ptr [r23+rbx*2+0xadc7545]    IID385\n+    __ eimull(r27, r9, Address(rdx, r22, (Address::ScaleFactor)2, -0x43d90f61), true); \/\/    {NF}imul r27d, r9d, dword ptr [rdx+r22*4-0x43d90f61]    IID386\n+    __ eimull(rbx, rbx, Address(r28, r22, (Address::ScaleFactor)3, -0x519d9a27), true); \/\/    {NF}imul ebx, ebx, dword ptr [r28+r22*8-0x519d9a27]    IID387\n+    __ eorl(r17, rcx, Address(r14, +0x10642223), false);                        \/\/    {EVEX}or r17d, ecx, dword ptr [r14+0x10642223]    IID388\n+    __ eorl(r26, r26, Address(r31, -0x7a9a83ba), false);                        \/\/    or r26d, dword ptr [r31-0x7a9a83ba]    IID389\n+    __ eorl(r15, r22, Address(r12, r12, (Address::ScaleFactor)2, +0x743b6997), true); \/\/    {NF}or r15d, r22d, dword ptr [r12+r12*4+0x743b6997]    IID390\n+    __ eorl(r8, r8, Address(rdx, r22, (Address::ScaleFactor)3, -0x588414dc), true); \/\/    {NF}or r8d, r8d, dword ptr [rdx+r22*8-0x588414dc]    IID391\n+    __ esubl(rcx, r28, Address(r30, r13, (Address::ScaleFactor)2, +0xe9310e5), false); \/\/    {EVEX}sub ecx, r28d, dword ptr [r30+r13*4+0xe9310e5]    IID392\n+    __ esubl(rcx, rcx, Address(r30, r10, (Address::ScaleFactor)1, -0x1b076ed1), false); \/\/    sub ecx, dword ptr [r30+r10*2-0x1b076ed1]    IID393\n+    __ esubl(r9, r21, Address(r30, +0x2f79ffd3), true);                         \/\/    {NF}sub r9d, r21d, dword ptr [r30+0x2f79ffd3]    IID394\n+    __ esubl(r16, r16, Address(rdx, r14, (Address::ScaleFactor)2, +0x675d71c1), true); \/\/    {NF}sub r16d, r16d, dword ptr [rdx+r14*4+0x675d71c1]    IID395\n+    __ exorl(r27, r28, Address(rbx, r26, (Address::ScaleFactor)2, -0x78c20b81), false); \/\/    {EVEX}xor r27d, r28d, dword ptr [rbx+r26*4-0x78c20b81]    IID396\n+    __ exorl(r14, r14, Address(r31, r19, (Address::ScaleFactor)1, -0x4ff251cc), false); \/\/    xor r14d, dword ptr [r31+r19*2-0x4ff251cc]    IID397\n+    __ exorl(r20, r18, Address(r13, r16, (Address::ScaleFactor)2, -0x19efc6e2), true); \/\/    {NF}xor r20d, r18d, dword ptr [r13+r16*4-0x19efc6e2]    IID398\n+    __ exorl(r19, r19, Address(r13, r23, (Address::ScaleFactor)1, -0x2d1bd8aa), true); \/\/    {NF}xor r19d, r19d, dword ptr [r13+r23*2-0x2d1bd8aa]    IID399\n+    __ exorb(r29, r17, Address(rdx, r29, (Address::ScaleFactor)2, +0x66573e84), false); \/\/    {EVEX}xor r29b, r17b, byte ptr [rdx+r29*4+0x66573e84]    IID400\n+    __ exorb(r22, r22, Address(r24, r25, (Address::ScaleFactor)3, +0x3a94a93f), false); \/\/    xor r22b, byte ptr [r24+r25*8+0x3a94a93f]    IID401\n+    __ exorb(r13, r29, Address(r15, r23, (Address::ScaleFactor)1, +0x76d43532), true); \/\/    {NF}xor r13b, r29b, byte ptr [r15+r23*2+0x76d43532]    IID402\n+    __ exorb(r15, r15, Address(r13, r9, (Address::ScaleFactor)0, -0x474e6d1a), true); \/\/    {NF}xor r15b, r15b, byte ptr [r13+r9*1-0x474e6d1a]    IID403\n+    __ exorw(r17, r16, Address(r23, rdx, (Address::ScaleFactor)0, +0x562a291), false); \/\/    {EVEX}xor r17w, r16w, word ptr [r23+rdx*1+0x562a291]    IID404\n+    __ exorw(r29, r29, Address(r18, r28, (Address::ScaleFactor)3, -0x541967f2), false); \/\/    xor r29w, word ptr [r18+r28*8-0x541967f2]    IID405\n+    __ exorw(r27, r11, Address(r10, +0xa911c5a), true);                         \/\/    {NF}xor r27w, r11w, word ptr [r10+0xa911c5a]    IID406\n+    __ exorw(r31, r31, Address(r30, r19, (Address::ScaleFactor)2, -0xf6a3da), true); \/\/    {NF}xor r31w, r31w, word ptr [r30+r19*4-0xf6a3da]    IID407\n+    __ eaddl(r12, r13, r23, false);                                             \/\/    {load}{EVEX}add r12d, r13d, r23d    IID408\n+    __ eaddl(r28, r28, r20, false);                                             \/\/    {load}add r28d, r20d    IID409\n+    __ eaddl(r20, r24, r20, false);                                             \/\/    {load}add r20d, r24d    IID410\n+    __ eaddl(r11, r10, r15, true);                                              \/\/    {load}{NF}add r11d, r10d, r15d    IID411\n+    __ eaddl(r19, r19, r20, true);                                              \/\/    {load}{NF}add r19d, r19d, r20d    IID412\n+    __ eaddl(r23, r15, r23, true);                                              \/\/    {load}{NF}add r23d, r15d, r23d    IID413\n+    __ eandl(r26, r19, r24, false);                                             \/\/    {load}{EVEX}and r26d, r19d, r24d    IID414\n+    __ eandl(r23, r23, r28, false);                                             \/\/    {load}and r23d, r28d    IID415\n+    __ eandl(r11, r13, r11, false);                                             \/\/    {load}and r11d, r13d    IID416\n+    __ eandl(r13, rdx, r31, true);                                              \/\/    {load}{NF}and r13d, edx, r31d    IID417\n+    __ eandl(r23, r23, r23, true);                                              \/\/    {load}{NF}and r23d, r23d, r23d    IID418\n+    __ eandl(r9, r27, r9, true);                                                \/\/    {load}{NF}and r9d, r27d, r9d    IID419\n+    __ eimull(r21, r20, r24, false);                                            \/\/    {load}{EVEX}imul r21d, r20d, r24d    IID420\n+    __ eimull(r21, r21, r29, false);                                            \/\/    {load}imul r21d, r29d    IID421\n+    __ eimull(rbx, r11, rbx, false);                                            \/\/    {load}imul ebx, r11d    IID422\n+    __ eimull(r21, rbx, rcx, true);                                             \/\/    {load}{NF}imul r21d, ebx, ecx    IID423\n+    __ eimull(r31, r31, r21, true);                                             \/\/    {load}{NF}imul r31d, r31d, r21d    IID424\n+    __ eimull(r15, r25, r15, true);                                             \/\/    {load}{NF}imul r15d, r25d, r15d    IID425\n+    __ eorw(r30, r23, r25, false);                                              \/\/    {load}{EVEX}or r30w, r23w, r25w    IID426\n+    __ eorw(r18, r18, rcx, false);                                              \/\/    {load}or r18w, cx    IID427\n+    __ eorw(r10, rcx, r10, false);                                              \/\/    {load}or r10w, cx    IID428\n+    __ eorw(r31, r21, r26, true);                                               \/\/    {load}{NF}or r31w, r21w, r26w    IID429\n+    __ eorw(r21, r21, r19, true);                                               \/\/    {load}{NF}or r21w, r21w, r19w    IID430\n@@ -354,1 +460,1 @@\n-    __ erorl(rax, rdx, 4, false);                                               \/\/    {EVEX}ror eax, edx, 4    IID325\n+    __ eorw(rdx, rbx, rdx, true);                                               \/\/    {load}{NF}or dx, bx, dx    IID431\n@@ -356,36 +462,96 @@\n-    __ erorl(r8, r8, 16, false);                                                \/\/    ror r8d, 16    IID326\n-    __ erorl(r19, rdx, 16, true);                                               \/\/    {NF}ror r19d, edx, 16    IID327\n-    __ erorl(rax, r31, 16, true);                                               \/\/    {NF}ror eax, r31d, 16    IID328\n-    __ erorl(r22, r22, 8, true);                                                \/\/    {NF}ror r22d, r22d, 8    IID329\n-    __ esall(r23, r25, 16, false);                                              \/\/    {EVEX}sal r23d, r25d, 16    IID330\n-    __ esall(rax, r14, 16, false);                                              \/\/    {EVEX}sal eax, r14d, 16    IID331\n-    __ esall(r31, r31, 8, false);                                               \/\/    sal r31d, 8    IID332\n-    __ esall(r30, r24, 2, true);                                                \/\/    {NF}sal r30d, r24d, 2    IID333\n-    __ esall(rax, r29, 2, true);                                                \/\/    {NF}sal eax, r29d, 2    IID334\n-    __ esall(r8, r8, 2, true);                                                  \/\/    {NF}sal r8d, r8d, 2    IID335\n-    __ esarl(r18, r24, 16, false);                                              \/\/    {EVEX}sar r18d, r24d, 16    IID336\n-    __ esarl(rax, r13, 16, false);                                              \/\/    {EVEX}sar eax, r13d, 16    IID337\n-    __ esarl(r24, r24, 1, false);                                               \/\/    sar r24d, 1    IID338\n-    __ esarl(r28, r17, 16, true);                                               \/\/    {NF}sar r28d, r17d, 16    IID339\n-    __ esarl(rax, r24, 16, true);                                               \/\/    {NF}sar eax, r24d, 16    IID340\n-    __ esarl(r17, r17, 4, true);                                                \/\/    {NF}sar r17d, r17d, 4    IID341\n-    __ eshll(r24, rcx, 4, false);                                               \/\/    {EVEX}shl r24d, ecx, 4    IID342\n-    __ eshll(rax, r16, 4, false);                                               \/\/    {EVEX}shl eax, r16d, 4    IID343\n-    __ eshll(r15, r15, 2, false);                                               \/\/    shl r15d, 2    IID344\n-    __ eshll(r14, r27, 4, true);                                                \/\/    {NF}shl r14d, r27d, 4    IID345\n-    __ eshll(rax, r23, 4, true);                                                \/\/    {NF}shl eax, r23d, 4    IID346\n-    __ eshll(r30, r30, 4, true);                                                \/\/    {NF}shl r30d, r30d, 4    IID347\n-    __ eshrl(r27, rdx, 2, false);                                               \/\/    {EVEX}shr r27d, edx, 2    IID348\n-    __ eshrl(rax, r19, 2, false);                                               \/\/    {EVEX}shr eax, r19d, 2    IID349\n-    __ eshrl(r20, r20, 2, false);                                               \/\/    shr r20d, 2    IID350\n-    __ eshrl(r21, r23, 1, true);                                                \/\/    {NF}shr r21d, r23d, 1    IID351\n-    __ eshrl(rax, r30, 1, true);                                                \/\/    {NF}shr eax, r30d, 1    IID352\n-    __ eshrl(r25, r25, 2, true);                                                \/\/    {NF}shr r25d, r25d, 2    IID353\n-    __ esubl(r24, r19, 1048576, false);                                         \/\/    {EVEX}sub r24d, r19d, 1048576    IID354\n-    __ esubl(rax, r14, 1048576, false);                                         \/\/    {EVEX}sub eax, r14d, 1048576    IID355\n-    __ esubl(r22, r22, 268435456, false);                                       \/\/    sub r22d, 268435456    IID356\n-    __ esubl(r24, r24, 65536, true);                                            \/\/    {NF}sub r24d, r24d, 65536    IID357\n-    __ esubl(rax, r14, 65536, true);                                            \/\/    {NF}sub eax, r14d, 65536    IID358\n-    __ esubl(r28, r28, 268435456, true);                                        \/\/    {NF}sub r28d, r28d, 268435456    IID359\n-    __ exorl(rbx, r20, 256, false);                                             \/\/    {EVEX}xor ebx, r20d, 256    IID360\n-    __ exorl(rax, r15, 256, false);                                             \/\/    {EVEX}xor eax, r15d, 256    IID361\n+    __ eorl(rcx, r24, r22, false);                                              \/\/    {load}{EVEX}or ecx, r24d, r22d    IID432\n+    __ eorl(rcx, rcx, r19, false);                                              \/\/    {load}or ecx, r19d    IID433\n+    __ eorl(r27, r27, r27, false);                                              \/\/    {load}or r27d, r27d    IID434\n+    __ eorl(r31, r9, r13, true);                                                \/\/    {load}{NF}or r31d, r9d, r13d    IID435\n+    __ eorl(r31, r31, r23, true);                                               \/\/    {load}{NF}or r31d, r31d, r23d    IID436\n+    __ eorl(r19, r17, r19, true);                                               \/\/    {load}{NF}or r19d, r17d, r19d    IID437\n+    __ eshldl(r20, r16, r24, false);                                            \/\/    {load}{EVEX}shld r20d, r16d, r24d, cl    IID438\n+    __ eshldl(rdx, rdx, r12, false);                                            \/\/    {load}shld edx, r12d    IID439\n+    __ eshldl(r29, r9, r31, true);                                              \/\/    {load}{NF}shld r29d, r9d, r31d, cl    IID440\n+    __ eshldl(r17, r17, r20, true);                                             \/\/    {load}{NF}shld r17d, r17d, r20d, cl    IID441\n+    __ eshrdl(r20, r15, r18, false);                                            \/\/    {load}{EVEX}shrd r20d, r15d, r18d, cl    IID442\n+    __ eshrdl(rcx, rcx, r12, false);                                            \/\/    {load}shrd ecx, r12d    IID443\n+    __ eshrdl(r14, r9, r23, true);                                              \/\/    {load}{NF}shrd r14d, r9d, r23d, cl    IID444\n+    __ eshrdl(r19, r19, r13, true);                                             \/\/    {load}{NF}shrd r19d, r19d, r13d, cl    IID445\n+    __ esubl(r30, r27, r27, false);                                             \/\/    {load}{EVEX}sub r30d, r27d, r27d    IID446\n+    __ esubl(rdx, rdx, r11, false);                                             \/\/    {load}sub edx, r11d    IID447\n+    __ esubl(r15, r11, r24, true);                                              \/\/    {load}{NF}sub r15d, r11d, r24d    IID448\n+    __ esubl(r14, r14, r25, true);                                              \/\/    {load}{NF}sub r14d, r14d, r25d    IID449\n+    __ exorl(r31, r16, r12, false);                                             \/\/    {load}{EVEX}xor r31d, r16d, r12d    IID450\n+    __ exorl(r20, r20, r14, false);                                             \/\/    {load}xor r20d, r14d    IID451\n+    __ exorl(r30, r13, r30, false);                                             \/\/    {load}xor r30d, r13d    IID452\n+    __ exorl(r24, r17, r17, true);                                              \/\/    {load}{NF}xor r24d, r17d, r17d    IID453\n+    __ exorl(r26, r26, r21, true);                                              \/\/    {load}{NF}xor r26d, r26d, r21d    IID454\n+    __ exorl(r11, r13, r11, true);                                              \/\/    {load}{NF}xor r11d, r13d, r11d    IID455\n+    __ eshldl(r27, r25, r21, 4, false);                                         \/\/    {EVEX}shld r27d, r25d, r21d, 4    IID456\n+    __ eshldl(r22, r22, r10, 4, false);                                         \/\/    shld r22d, r10d, 4    IID457\n+    __ eshldl(r21, r15, r24, 16, true);                                         \/\/    {NF}shld r21d, r15d, r24d, 16    IID458\n+    __ eshldl(rdx, rdx, r19, 1, true);                                          \/\/    {NF}shld edx, edx, r19d, 1    IID459\n+    __ eshrdl(r23, r13, r8, 16, false);                                         \/\/    {EVEX}shrd r23d, r13d, r8d, 16    IID460\n+    __ eshrdl(r26, r26, r22, 1, false);                                         \/\/    shrd r26d, r22d, 1    IID461\n+    __ eshrdl(r24, r9, r30, 16, true);                                          \/\/    {NF}shrd r24d, r9d, r30d, 16    IID462\n+    __ eshrdl(r19, r19, r8, 4, true);                                           \/\/    {NF}shrd r19d, r19d, r8d, 4    IID463\n+    __ ecmovl (Assembler::Condition::overflow, r30, r26, r17);                  \/\/    cmovo r30d, r26d, r17d    IID464\n+    __ ecmovl (Assembler::Condition::overflow, r14, r14, r26);                  \/\/    cmovo r14d, r26d    IID465\n+    __ ecmovl (Assembler::Condition::noOverflow, r24, r19, r29);                \/\/    cmovno r24d, r19d, r29d    IID466\n+    __ ecmovl (Assembler::Condition::noOverflow, r25, r25, r20);                \/\/    cmovno r25d, r20d    IID467\n+    __ ecmovl (Assembler::Condition::below, r11, r10, r14);                     \/\/    cmovb r11d, r10d, r14d    IID468\n+    __ ecmovl (Assembler::Condition::below, r30, r30, r25);                     \/\/    cmovb r30d, r25d    IID469\n+    __ ecmovl (Assembler::Condition::aboveEqual, r13, r22, r27);                \/\/    cmovae r13d, r22d, r27d    IID470\n+    __ ecmovl (Assembler::Condition::aboveEqual, r16, r16, r24);                \/\/    cmovae r16d, r24d    IID471\n+    __ ecmovl (Assembler::Condition::zero, r28, r13, r30);                      \/\/    cmovz r28d, r13d, r30d    IID472\n+    __ ecmovl (Assembler::Condition::zero, r30, r30, r24);                      \/\/    cmovz r30d, r24d    IID473\n+    __ ecmovl (Assembler::Condition::notZero, r21, r20, r31);                   \/\/    cmovnz r21d, r20d, r31d    IID474\n+    __ ecmovl (Assembler::Condition::notZero, r8, r8, r16);                     \/\/    cmovnz r8d, r16d    IID475\n+    __ ecmovl (Assembler::Condition::belowEqual, r15, r26, r22);                \/\/    cmovbe r15d, r26d, r22d    IID476\n+    __ ecmovl (Assembler::Condition::belowEqual, r31, r31, rdx);                \/\/    cmovbe r31d, edx    IID477\n+    __ ecmovl (Assembler::Condition::above, r27, r8, r10);                      \/\/    cmova r27d, r8d, r10d    IID478\n+    __ ecmovl (Assembler::Condition::above, r18, r18, r11);                     \/\/    cmova r18d, r11d    IID479\n+    __ ecmovl (Assembler::Condition::negative, r27, rbx, r21);                  \/\/    cmovs r27d, ebx, r21d    IID480\n+    __ ecmovl (Assembler::Condition::negative, r12, r12, r31);                  \/\/    cmovs r12d, r31d    IID481\n+    __ ecmovl (Assembler::Condition::positive, r12, rdx, r18);                  \/\/    cmovns r12d, edx, r18d    IID482\n+    __ ecmovl (Assembler::Condition::positive, r18, r18, r19);                  \/\/    cmovns r18d, r19d    IID483\n+    __ ecmovl (Assembler::Condition::parity, r16, r20, r23);                    \/\/    cmovp r16d, r20d, r23d    IID484\n+    __ ecmovl (Assembler::Condition::parity, r18, r18, r16);                    \/\/    cmovp r18d, r16d    IID485\n+    __ ecmovl (Assembler::Condition::noParity, rbx, r31, r30);                  \/\/    cmovnp ebx, r31d, r30d    IID486\n+    __ ecmovl (Assembler::Condition::noParity, r31, r31, r29);                  \/\/    cmovnp r31d, r29d    IID487\n+    __ ecmovl (Assembler::Condition::less, r28, r25, r10);                      \/\/    cmovl r28d, r25d, r10d    IID488\n+    __ ecmovl (Assembler::Condition::less, r24, r24, r20);                      \/\/    cmovl r24d, r20d    IID489\n+    __ ecmovl (Assembler::Condition::greaterEqual, r16, rdx, r26);              \/\/    cmovge r16d, edx, r26d    IID490\n+    __ ecmovl (Assembler::Condition::greaterEqual, r28, r28, r28);              \/\/    cmovge r28d, r28d    IID491\n+    __ ecmovl (Assembler::Condition::lessEqual, r9, r20, r24);                  \/\/    cmovle r9d, r20d, r24d    IID492\n+    __ ecmovl (Assembler::Condition::lessEqual, r24, r24, r29);                 \/\/    cmovle r24d, r29d    IID493\n+    __ ecmovl (Assembler::Condition::greater, r23, r27, r15);                   \/\/    cmovg r23d, r27d, r15d    IID494\n+    __ ecmovl (Assembler::Condition::greater, r12, r12, r18);                   \/\/    cmovg r12d, r18d    IID495\n+    __ ecmovl (Assembler::Condition::overflow, r19, r9, Address(r31, rcx, (Address::ScaleFactor)1, -0x2be98bd)); \/\/    cmovo r19d, r9d, dword ptr [r31+rcx*2-0x2be98bd]    IID496\n+    __ ecmovl (Assembler::Condition::overflow, r8, r8, Address(r21, r24, (Address::ScaleFactor)1, +0x41e6a0cb)); \/\/    cmovo r8d, dword ptr [r21+r24*2+0x41e6a0cb]    IID497\n+    __ ecmovl (Assembler::Condition::noOverflow, r23, r15, Address(r19, r30, (Address::ScaleFactor)3, -0x55adfe2d)); \/\/    cmovno r23d, r15d, dword ptr [r19+r30*8-0x55adfe2d]    IID498\n+    __ ecmovl (Assembler::Condition::noOverflow, rdx, rdx, Address(r27, rdx, (Address::ScaleFactor)0, -0x1aa12735)); \/\/    cmovno edx, dword ptr [r27+rdx*1-0x1aa12735]    IID499\n+    __ ecmovl (Assembler::Condition::below, rbx, r29, Address(r31, r12, (Address::ScaleFactor)0, +0xbd42246)); \/\/    cmovb ebx, r29d, dword ptr [r31+r12*1+0xbd42246]    IID500\n+    __ ecmovl (Assembler::Condition::below, r21, r21, Address(r19, r21, (Address::ScaleFactor)1, -0x41518818)); \/\/    cmovb r21d, dword ptr [r19+r21*2-0x41518818]    IID501\n+    __ ecmovl (Assembler::Condition::aboveEqual, r23, r29, Address(r22, r9, (Address::ScaleFactor)2, -0x35addbd8)); \/\/    cmovae r23d, r29d, dword ptr [r22+r9*4-0x35addbd8]    IID502\n+    __ ecmovl (Assembler::Condition::aboveEqual, r18, r18, Address(r25, +0x632184c3)); \/\/    cmovae r18d, dword ptr [r25+0x632184c3]    IID503\n+    __ ecmovl (Assembler::Condition::zero, r29, r13, Address(r18, r13, (Address::ScaleFactor)0, -0x3972eac6)); \/\/    cmovz r29d, r13d, dword ptr [r18+r13*1-0x3972eac6]    IID504\n+    __ ecmovl (Assembler::Condition::zero, r29, r29, Address(r12, r9, (Address::ScaleFactor)3, -0x668cdfd2)); \/\/    cmovz r29d, dword ptr [r12+r9*8-0x668cdfd2]    IID505\n+    __ ecmovl (Assembler::Condition::notZero, r25, r18, Address(r9, r22, (Address::ScaleFactor)2, +0x7f6ac91f)); \/\/    cmovnz r25d, r18d, dword ptr [r9+r22*4+0x7f6ac91f]    IID506\n+    __ ecmovl (Assembler::Condition::notZero, r28, r28, Address(r30, +0x562e6594)); \/\/    cmovnz r28d, dword ptr [r30+0x562e6594]    IID507\n+    __ ecmovl (Assembler::Condition::belowEqual, r27, r24, Address(r15, r20, (Address::ScaleFactor)2, -0x466538b7)); \/\/    cmovbe r27d, r24d, dword ptr [r15+r20*4-0x466538b7]    IID508\n+    __ ecmovl (Assembler::Condition::belowEqual, r25, r25, Address(r26, r11, (Address::ScaleFactor)3, -0x593812a9)); \/\/    cmovbe r25d, dword ptr [r26+r11*8-0x593812a9]    IID509\n+    __ ecmovl (Assembler::Condition::above, rcx, r20, Address(r16, -0x1389a3eb)); \/\/    cmova ecx, r20d, dword ptr [r16-0x1389a3eb]    IID510\n+    __ ecmovl (Assembler::Condition::above, rbx, rbx, Address(r29, r8, (Address::ScaleFactor)0, +0x1d022615)); \/\/    cmova ebx, dword ptr [r29+r8*1+0x1d022615]    IID511\n+    __ ecmovl (Assembler::Condition::negative, rdx, r14, Address(r12, r28, (Address::ScaleFactor)1, -0x51725a91)); \/\/    cmovs edx, r14d, dword ptr [r12+r28*2-0x51725a91]    IID512\n+    __ ecmovl (Assembler::Condition::negative, r24, r24, Address(r17, r18, (Address::ScaleFactor)1, -0x1725c4e4)); \/\/    cmovs r24d, dword ptr [r17+r18*2-0x1725c4e4]    IID513\n+    __ ecmovl (Assembler::Condition::positive, rcx, rcx, Address(r15, r23, (Address::ScaleFactor)2, -0x6bd22ccf)); \/\/    cmovns ecx, dword ptr [r15+r23*4-0x6bd22ccf]    IID514\n+    __ ecmovl (Assembler::Condition::positive, r24, r24, Address(r15, r10, (Address::ScaleFactor)1, -0x7ffb3d09)); \/\/    cmovns r24d, dword ptr [r15+r10*2-0x7ffb3d09]    IID515\n+    __ ecmovl (Assembler::Condition::parity, r23, rcx, Address(r11, r23, (Address::ScaleFactor)0, +0x3738c585)); \/\/    cmovp r23d, ecx, dword ptr [r11+r23*1+0x3738c585]    IID516\n+    __ ecmovl (Assembler::Condition::parity, r24, r24, Address(r30, r10, (Address::ScaleFactor)0, +0xfcc15a8)); \/\/    cmovp r24d, dword ptr [r30+r10*1+0xfcc15a8]    IID517\n+    __ ecmovl (Assembler::Condition::noParity, r14, r26, Address(r14, r21, (Address::ScaleFactor)1, -0x4430ce9f)); \/\/    cmovnp r14d, r26d, dword ptr [r14+r21*2-0x4430ce9f]    IID518\n+    __ ecmovl (Assembler::Condition::noParity, r10, r10, Address(r28, +0x3d7c59f)); \/\/    cmovnp r10d, dword ptr [r28+0x3d7c59f]    IID519\n+    __ ecmovl (Assembler::Condition::less, r10, r21, Address(r8, r8, (Address::ScaleFactor)3, +0x4a6584b4)); \/\/    cmovl r10d, r21d, dword ptr [r8+r8*8+0x4a6584b4]    IID520\n+    __ ecmovl (Assembler::Condition::less, r26, r26, Address(r19, r20, (Address::ScaleFactor)3, +0x47c660ef)); \/\/    cmovl r26d, dword ptr [r19+r20*8+0x47c660ef]    IID521\n+    __ ecmovl (Assembler::Condition::greaterEqual, r26, r10, Address(rcx, +0x61977a97)); \/\/    cmovge r26d, r10d, dword ptr [rcx+0x61977a97]    IID522\n+    __ ecmovl (Assembler::Condition::greaterEqual, r30, r30, Address(r15, r19, (Address::ScaleFactor)3, +0x53c601cb)); \/\/    cmovge r30d, dword ptr [r15+r19*8+0x53c601cb]    IID523\n+    __ ecmovl (Assembler::Condition::lessEqual, r14, r9, Address(r17, -0x566ceee2)); \/\/    cmovle r14d, r9d, dword ptr [r17-0x566ceee2]    IID524\n+    __ ecmovl (Assembler::Condition::lessEqual, r15, r15, Address(r27, r20, (Address::ScaleFactor)0, +0x76164792)); \/\/    cmovle r15d, dword ptr [r27+r20*1+0x76164792]    IID525\n+    __ ecmovl (Assembler::Condition::greater, r27, r14, Address(r9, r13, (Address::ScaleFactor)2, +0xf5752d7)); \/\/    cmovg r27d, r14d, dword ptr [r9+r13*4+0xf5752d7]    IID526\n+    __ ecmovl (Assembler::Condition::greater, r12, r12, Address(rbx, rcx, (Address::ScaleFactor)3, -0x5501b4c6)); \/\/    cmovg r12d, dword ptr [rbx+rcx*8-0x5501b4c6]    IID527\n@@ -393,1 +559,0 @@\n-    __ exorl(rbx, rbx, 4096, false);                                            \/\/    xor ebx, 4096    IID362\n@@ -395,558 +560,477 @@\n-    __ exorl(r24, r30, 65536, true);                                            \/\/    {NF}xor r24d, r30d, 65536    IID363\n-    __ exorl(rax, r31, 65536, true);                                            \/\/    {NF}xor eax, r31d, 65536    IID364\n-    __ exorl(r31, r31, 4096, true);                                             \/\/    {NF}xor r31d, r31d, 4096    IID365\n-    __ esubl_imm32(r20, r10, 1048576, false);                                   \/\/    {EVEX}sub r20d, r10d, 1048576    IID366\n-    __ esubl_imm32(rax, r13, 1048576, false);                                   \/\/    {EVEX}sub eax, r13d, 1048576    IID367\n-    __ esubl_imm32(r25, r25, 1048576, false);                                   \/\/    sub r25d, 1048576    IID368\n-    __ esubl_imm32(r23, r12, 1073741824, true);                                 \/\/    {NF}sub r23d, r12d, 1073741824    IID369\n-    __ esubl_imm32(rax, r16, 1073741824, true);                                 \/\/    {NF}sub eax, r16d, 1073741824    IID370\n-    __ esubl_imm32(r31, r31, 65536, true);                                      \/\/    {NF}sub r31d, r31d, 65536    IID371\n-    __ eaddl(r17, r13, Address(r9, +0x7fef2f98), false);                        \/\/    {EVEX}add r17d, r13d, dword ptr [r9+0x7fef2f98]    IID372\n-    __ eaddl(r29, r8, Address(r22, -0x4df70aac), true);                         \/\/    {NF}add r29d, r8d, dword ptr [r22-0x4df70aac]    IID373\n-    __ eandl(r13, r17, Address(r12, r15, (Address::ScaleFactor)3, +0x50a8a902), false); \/\/    {EVEX}and r13d, r17d, dword ptr [r12+r15*8+0x50a8a902]    IID374\n-    __ eandl(r22, r25, Address(r26, r10, (Address::ScaleFactor)2, +0x70ea2754), true); \/\/    {NF}and r22d, r25d, dword ptr [r26+r10*4+0x70ea2754]    IID375\n-    __ eimull(r19, r12, Address(r30, r8, (Address::ScaleFactor)0, +0x6a1a0a73), false); \/\/    {EVEX}imul r19d, r12d, dword ptr [r30+r8*1+0x6a1a0a73]    IID376\n-    __ eimull(r30, r18, Address(r18, r19, (Address::ScaleFactor)2, -0x7fcd28c7), true); \/\/    {NF}imul r30d, r18d, dword ptr [r18+r19*4-0x7fcd28c7]    IID377\n-    __ eorl(r16, r31, Address(r25, r11, (Address::ScaleFactor)3, +0x482d5dbc), false); \/\/    {EVEX}or r16d, r31d, dword ptr [r25+r11*8+0x482d5dbc]    IID378\n-    __ eorl(r9, r27, Address(r11, +0x43d5ee01), true);                          \/\/    {NF}or r9d, r27d, dword ptr [r11+0x43d5ee01]    IID379\n-    __ esubl(rcx, r23, Address(r21, r15, (Address::ScaleFactor)2, +0x2825c2bc), false); \/\/    {EVEX}sub ecx, r23d, dword ptr [r21+r15*4+0x2825c2bc]    IID380\n-    __ esubl(r27, r22, Address(r13, r15, (Address::ScaleFactor)1, +0x771f0da7), true); \/\/    {NF}sub r27d, r22d, dword ptr [r13+r15*2+0x771f0da7]    IID381\n-    __ exorl(r9, r30, Address(r9, r22, (Address::ScaleFactor)3, -0x4ad6c88e), false); \/\/    {EVEX}xor r9d, r30d, dword ptr [r9+r22*8-0x4ad6c88e]    IID382\n-    __ exorl(r11, r16, Address(rbx, r28, (Address::ScaleFactor)2, +0xb0223ee), true); \/\/    {NF}xor r11d, r16d, dword ptr [rbx+r28*4+0xb0223ee]    IID383\n-    __ exorb(r15, r29, Address(r15, r28, (Address::ScaleFactor)1, -0x1f297a69), false); \/\/    {EVEX}xor r15b, r29b, byte ptr [r15+r28*2-0x1f297a69]    IID384\n-    __ exorb(r17, r30, Address(r23, rbx, (Address::ScaleFactor)1, +0xadc7545), true); \/\/    {NF}xor r17b, r30b, byte ptr [r23+rbx*2+0xadc7545]    IID385\n-    __ exorw(r27, r9, Address(rdx, r22, (Address::ScaleFactor)2, -0x43d90f61), false); \/\/    {EVEX}xor r27w, r9w, word ptr [rdx+r22*4-0x43d90f61]    IID386\n-    __ exorw(rbx, r22, Address(r28, r22, (Address::ScaleFactor)0, -0x7d30a0b1), true); \/\/    {NF}xor bx, r22w, word ptr [r28+r22*1-0x7d30a0b1]    IID387\n-    __ eaddl(r14, r24, rcx, false);                                             \/\/    {load}{EVEX}add r14d, r24d, ecx    IID388\n-    __ eaddl(r8, r8, r17, false);                                               \/\/    {load}add r8d, r17d    IID389\n-    __ eaddl(r26, r24, r12, true);                                              \/\/    {load}{NF}add r26d, r24d, r12d    IID390\n-    __ eaddl(r24, r24, r23, true);                                              \/\/    {load}{NF}add r24d, r24d, r23d    IID391\n-    __ eandl(r13, r26, r31, false);                                             \/\/    {load}{EVEX}and r13d, r26d, r31d    IID392\n-    __ eandl(r11, r11, r8, false);                                              \/\/    {load}and r11d, r8d    IID393\n-    __ eandl(rcx, r19, r15, true);                                              \/\/    {load}{NF}and ecx, r19d, r15d    IID394\n-    __ eandl(r12, r12, r12, true);                                              \/\/    {load}{NF}and r12d, r12d, r12d    IID395\n-    __ eimull(r22, r20, r19, false);                                            \/\/    {load}{EVEX}imul r22d, r20d, r19d    IID396\n-    __ eimull(r8, r8, rdx, false);                                              \/\/    {load}imul r8d, edx    IID397\n-    __ eimull(r22, r27, r23, true);                                             \/\/    {load}{NF}imul r22d, r27d, r23d    IID398\n-    __ eimull(r9, r9, r18, true);                                               \/\/    {load}{NF}imul r9d, r9d, r18d    IID399\n-    __ eorw(rcx, r30, r13, false);                                              \/\/    {load}{EVEX}or cx, r30w, r13w    IID400\n-    __ eorw(r28, r28, r19, false);                                              \/\/    {load}or r28w, r19w    IID401\n-    __ eorw(r12, r30, r27, true);                                               \/\/    {load}{NF}or r12w, r30w, r27w    IID402\n-    __ eorw(r8, r8, r22, true);                                                 \/\/    {load}{NF}or r8w, r8w, r22w    IID403\n-    __ eorl(r16, rcx, r30, false);                                              \/\/    {load}{EVEX}or r16d, ecx, r30d    IID404\n-    __ eorl(r10, r10, r25, false);                                              \/\/    {load}or r10d, r25d    IID405\n-    __ eorl(r15, r17, r17, true);                                               \/\/    {load}{NF}or r15d, r17d, r17d    IID406\n-    __ eorl(r9, r9, r30, true);                                                 \/\/    {load}{NF}or r9d, r9d, r30d    IID407\n-    __ eshldl(r20, r21, r8, false);                                             \/\/    {load}{EVEX}shld r20d, r21d, r8d, cl    IID408\n-    __ eshldl(r26, r26, r14, false);                                            \/\/    {load}shld r26d, r14d    IID409\n-    __ eshldl(r16, rdx, r14, true);                                             \/\/    {load}{NF}shld r16d, edx, r14d, cl    IID410\n-    __ eshldl(r19, r19, r8, true);                                              \/\/    {load}{NF}shld r19d, r19d, r8d, cl    IID411\n-    __ eshrdl(r27, rbx, r26, false);                                            \/\/    {load}{EVEX}shrd r27d, ebx, r26d, cl    IID412\n-    __ eshrdl(r28, r28, r19, false);                                            \/\/    {load}shrd r28d, r19d    IID413\n-    __ eshrdl(rcx, r11, r14, true);                                             \/\/    {load}{NF}shrd ecx, r11d, r14d, cl    IID414\n-    __ eshrdl(r31, r31, r19, true);                                             \/\/    {load}{NF}shrd r31d, r31d, r19d, cl    IID415\n-    __ esubl(r26, r13, r25, false);                                             \/\/    {load}{EVEX}sub r26d, r13d, r25d    IID416\n-    __ esubl(r24, r24, r11, false);                                             \/\/    {load}sub r24d, r11d    IID417\n-    __ esubl(r18, r20, r13, true);                                              \/\/    {load}{NF}sub r18d, r20d, r13d    IID418\n-    __ esubl(r16, r16, r18, true);                                              \/\/    {load}{NF}sub r16d, r16d, r18d    IID419\n-    __ exorl(r19, r17, r8, false);                                              \/\/    {load}{EVEX}xor r19d, r17d, r8d    IID420\n-    __ exorl(r19, r19, r13, false);                                             \/\/    {load}xor r19d, r13d    IID421\n-    __ exorl(r23, r13, r15, true);                                              \/\/    {load}{NF}xor r23d, r13d, r15d    IID422\n-    __ exorl(r11, r11, r29, true);                                              \/\/    {load}{NF}xor r11d, r11d, r29d    IID423\n-    __ eshldl(r29, r17, r17, 1, false);                                         \/\/    {EVEX}shld r29d, r17d, r17d, 1    IID424\n-    __ eshldl(r22, r22, r24, 4, false);                                         \/\/    shld r22d, r24d, 4    IID425\n-    __ eshldl(r8, r28, r11, 16, true);                                          \/\/    {NF}shld r8d, r28d, r11d, 16    IID426\n-    __ eshldl(r15, r15, r23, 4, true);                                          \/\/    {NF}shld r15d, r15d, r23d, 4    IID427\n-    __ eshrdl(r29, r22, r16, 4, false);                                         \/\/    {EVEX}shrd r29d, r22d, r16d, 4    IID428\n-    __ eshrdl(r13, r13, r9, 4, false);                                          \/\/    shrd r13d, r9d, 4    IID429\n-    __ eshrdl(r15, r21, r12, 2, true);                                          \/\/    {NF}shrd r15d, r21d, r12d, 2    IID430\n-    __ eshrdl(r17, r17, r23, 2, true);                                          \/\/    {NF}shrd r17d, r17d, r23d, 2    IID431\n-    __ ecmovl (Assembler::Condition::overflow, rdx, r16, r29);                  \/\/    cmovo edx, r16d, r29d    IID432\n-    __ ecmovl (Assembler::Condition::overflow, r10, r10, r21);                  \/\/    cmovo r10d, r21d    IID433\n-    __ ecmovl (Assembler::Condition::noOverflow, r17, r29, r18);                \/\/    cmovno r17d, r29d, r18d    IID434\n-    __ ecmovl (Assembler::Condition::noOverflow, r28, r28, r24);                \/\/    cmovno r28d, r24d    IID435\n-    __ ecmovl (Assembler::Condition::below, r10, r20, r27);                     \/\/    cmovb r10d, r20d, r27d    IID436\n-    __ ecmovl (Assembler::Condition::below, r10, r10, r14);                     \/\/    cmovb r10d, r14d    IID437\n-    __ ecmovl (Assembler::Condition::aboveEqual, r11, r27, rcx);                \/\/    cmovae r11d, r27d, ecx    IID438\n-    __ ecmovl (Assembler::Condition::aboveEqual, r22, r22, r15);                \/\/    cmovae r22d, r15d    IID439\n-    __ ecmovl (Assembler::Condition::zero, r31, r30, r19);                      \/\/    cmovz r31d, r30d, r19d    IID440\n-    __ ecmovl (Assembler::Condition::zero, r19, r19, r26);                      \/\/    cmovz r19d, r26d    IID441\n-    __ ecmovl (Assembler::Condition::notZero, r21, r14, r26);                   \/\/    cmovnz r21d, r14d, r26d    IID442\n-    __ ecmovl (Assembler::Condition::notZero, r20, r20, r15);                   \/\/    cmovnz r20d, r15d    IID443\n-    __ ecmovl (Assembler::Condition::belowEqual, r12, r13, r23);                \/\/    cmovbe r12d, r13d, r23d    IID444\n-    __ ecmovl (Assembler::Condition::belowEqual, r28, r28, r20);                \/\/    cmovbe r28d, r20d    IID445\n-    __ ecmovl (Assembler::Condition::above, r20, r24, r11);                     \/\/    cmova r20d, r24d, r11d    IID446\n-    __ ecmovl (Assembler::Condition::above, r10, r10, r15);                     \/\/    cmova r10d, r15d    IID447\n-    __ ecmovl (Assembler::Condition::negative, r19, r20, r23);                  \/\/    cmovs r19d, r20d, r23d    IID448\n-    __ ecmovl (Assembler::Condition::negative, r15, r15, r26);                  \/\/    cmovs r15d, r26d    IID449\n-    __ ecmovl (Assembler::Condition::positive, r19, r24, r23);                  \/\/    cmovns r19d, r24d, r23d    IID450\n-    __ ecmovl (Assembler::Condition::positive, r28, r28, r11);                  \/\/    cmovns r28d, r11d    IID451\n-    __ ecmovl (Assembler::Condition::parity, r13, r13, rdx);                    \/\/    cmovp r13d, edx    IID452\n-    __ ecmovl (Assembler::Condition::parity, r31, r31, r23);                    \/\/    cmovp r31d, r23d    IID453\n-    __ ecmovl (Assembler::Condition::noParity, r23, r9, r27);                   \/\/    cmovnp r23d, r9d, r27d    IID454\n-    __ ecmovl (Assembler::Condition::noParity, r21, r21, r20);                  \/\/    cmovnp r21d, r20d    IID455\n-    __ ecmovl (Assembler::Condition::less, r24, r21, r29);                      \/\/    cmovl r24d, r21d, r29d    IID456\n-    __ ecmovl (Assembler::Condition::less, rbx, rbx, r11);                      \/\/    cmovl ebx, r11d    IID457\n-    __ ecmovl (Assembler::Condition::greaterEqual, r21, rbx, rcx);              \/\/    cmovge r21d, ebx, ecx    IID458\n-    __ ecmovl (Assembler::Condition::greaterEqual, r31, r31, r21);              \/\/    cmovge r31d, r21d    IID459\n-    __ ecmovl (Assembler::Condition::lessEqual, r15, r25, r30);                 \/\/    cmovle r15d, r25d, r30d    IID460\n-    __ ecmovl (Assembler::Condition::lessEqual, r23, r23, r25);                 \/\/    cmovle r23d, r25d    IID461\n-    __ ecmovl (Assembler::Condition::greater, r18, rcx, r10);                   \/\/    cmovg r18d, ecx, r10d    IID462\n-    __ ecmovl (Assembler::Condition::greater, rcx, rcx, r31);                   \/\/    cmovg ecx, r31d    IID463\n-    __ ecmovl (Assembler::Condition::overflow, r21, r19, Address(r26, -0x6e290873)); \/\/    cmovo r21d, r19d, dword ptr [r26-0x6e290873]    IID464\n-    __ ecmovl (Assembler::Condition::noOverflow, r24, r19, Address(r22, rcx, (Address::ScaleFactor)0, +0x11f85f9a)); \/\/    cmovno r24d, r19d, dword ptr [r22+rcx*1+0x11f85f9a]    IID465\n-    __ ecmovl (Assembler::Condition::below, r17, r24, Address(r20, +0x534d775e)); \/\/    cmovb r17d, r24d, dword ptr [r20+0x534d775e]    IID466\n-    __ ecmovl (Assembler::Condition::aboveEqual, r20, r18, Address(r20, -0x47c94ecd)); \/\/    cmovae r20d, r18d, dword ptr [r20-0x47c94ecd]    IID467\n-    __ ecmovl (Assembler::Condition::zero, r9, r13, Address(r23, -0x4b83c563)); \/\/    cmovz r9d, r13d, dword ptr [r23-0x4b83c563]    IID468\n-    __ ecmovl (Assembler::Condition::notZero, r11, r25, Address(r24, r14, (Address::ScaleFactor)1, -0x446507af)); \/\/    cmovnz r11d, r25d, dword ptr [r24+r14*2-0x446507af]    IID469\n-    __ ecmovl (Assembler::Condition::belowEqual, r14, r24, Address(r30, r13, (Address::ScaleFactor)2, +0xd0661d)); \/\/    cmovbe r14d, r24d, dword ptr [r30+r13*4+0xd0661d]    IID470\n-    __ ecmovl (Assembler::Condition::above, r13, r25, Address(r14, r27, (Address::ScaleFactor)3, +0x47e1403)); \/\/    cmova r13d, r25d, dword ptr [r14+r27*8+0x47e1403]    IID471\n-    __ ecmovl (Assembler::Condition::negative, r24, r19, Address(rcx, rdx, (Address::ScaleFactor)3, -0x644a5318)); \/\/    cmovs r24d, r19d, dword ptr [rcx+rdx*8-0x644a5318]    IID472\n-    __ ecmovl (Assembler::Condition::positive, r26, r24, Address(r22, r22, (Address::ScaleFactor)0, +0x70352446)); \/\/    cmovns r26d, r24d, dword ptr [r22+r22*1+0x70352446]    IID473\n-    __ ecmovl (Assembler::Condition::parity, r19, r26, Address(r8, r30, (Address::ScaleFactor)2, +0x78a12f5c)); \/\/    cmovp r19d, r26d, dword ptr [r8+r30*4+0x78a12f5c]    IID474\n-    __ ecmovl (Assembler::Condition::noParity, r29, r11, Address(r25, r20, (Address::ScaleFactor)0, +0x27a8303a)); \/\/    cmovnp r29d, r11d, dword ptr [r25+r20*1+0x27a8303a]    IID475\n-    __ ecmovl (Assembler::Condition::less, r22, r24, Address(r27, r16, (Address::ScaleFactor)1, +0x2541a10)); \/\/    cmovl r22d, r24d, dword ptr [r27+r16*2+0x2541a10]    IID476\n-    __ ecmovl (Assembler::Condition::greaterEqual, r31, r15, Address(r8, r16, (Address::ScaleFactor)3, +0x558e3251)); \/\/    cmovge r31d, r15d, dword ptr [r8+r16*8+0x558e3251]    IID477\n-    __ ecmovl (Assembler::Condition::lessEqual, r27, r18, Address(r8, r10, (Address::ScaleFactor)0, -0x471987b7)); \/\/    cmovle r27d, r18d, dword ptr [r8+r10*1-0x471987b7]    IID478\n-    __ ecmovl (Assembler::Condition::greater, r18, r16, Address(r18, r19, (Address::ScaleFactor)2, -0x120ae81e)); \/\/    cmovg r18d, r16d, dword ptr [r18+r19*4-0x120ae81e]    IID479\n-#endif \/\/ _LP64\n-#ifdef _LP64\n-    __ adcq(rbx, r31);                                                          \/\/    {load}adc rbx, r31    IID480\n-    __ cmpq(r30, r31);                                                          \/\/    {load}cmp r30, r31    IID481\n-    __ imulq(r29, r28);                                                         \/\/    {load}imul r29, r28    IID482\n-    __ popcntq(r25, r10);                                                       \/\/    {load}popcnt r25, r10    IID483\n-    __ sbbq(r24, r20);                                                          \/\/    {load}sbb r24, r20    IID484\n-    __ subq(r16, rdx);                                                          \/\/    {load}sub r16, rdx    IID485\n-    __ tzcntq(r26, r28);                                                        \/\/    {load}tzcnt r26, r28    IID486\n-    __ lzcntq(r28, r9);                                                         \/\/    {load}lzcnt r28, r9    IID487\n-    __ addq(r20, r24);                                                          \/\/    {load}add r20, r24    IID488\n-    __ andq(r24, r29);                                                          \/\/    {load}and r24, r29    IID489\n-    __ orq(r23, r27);                                                           \/\/    {load}or r23, r27    IID490\n-    __ xorq(r15, r12);                                                          \/\/    {load}xor r15, r12    IID491\n-    __ movq(r18, r19);                                                          \/\/    {load}mov r18, r19    IID492\n-    __ bsfq(r31, rcx);                                                          \/\/    {load}bsf r31, rcx    IID493\n-    __ bsrq(r9, r13);                                                           \/\/    {load}bsr r9, r13    IID494\n-    __ btq(r20, rcx);                                                           \/\/    {load}bt r20, rcx    IID495\n-    __ xchgq(r8, r21);                                                          \/\/    {load}xchg r8, r21    IID496\n-    __ testq(r24, r14);                                                         \/\/    {load}test r24, r14    IID497\n-    __ addq(Address(rcx, r23, (Address::ScaleFactor)2, +0x4ff06c4d), r29);      \/\/    add qword ptr [rcx+r23*4+0x4ff06c4d], r29    IID498\n-    __ andq(Address(r24, r10, (Address::ScaleFactor)1, -0x75d9a189), r26);      \/\/    and qword ptr [r24+r10*2-0x75d9a189], r26    IID499\n-    __ cmpq(Address(rbx, rbx, (Address::ScaleFactor)0, +0x4033d59c), r17);      \/\/    cmp qword ptr [rbx+rbx*1+0x4033d59c], r17    IID500\n-    __ orq(Address(r22, r12, (Address::ScaleFactor)3, -0x3893347d), r18);       \/\/    or qword ptr [r22+r12*8-0x3893347d], r18    IID501\n-    __ xorq(Address(r20, r23, (Address::ScaleFactor)3, +0x4b311560), r12);      \/\/    xor qword ptr [r20+r23*8+0x4b311560], r12    IID502\n-    __ subq(Address(r10, r28, (Address::ScaleFactor)2, +0x5c3a2657), r29);      \/\/    sub qword ptr [r10+r28*4+0x5c3a2657], r29    IID503\n-    __ movq(Address(r13, r25, (Address::ScaleFactor)3, +0x1a3d6f3f), r22);      \/\/    mov qword ptr [r13+r25*8+0x1a3d6f3f], r22    IID504\n-    __ xaddq(Address(r17, r24, (Address::ScaleFactor)3, -0x35addbd8), r25);     \/\/    xadd qword ptr [r17+r24*8-0x35addbd8], r25    IID505\n-    __ andq(Address(r25, +0x632184c3), 16777216);                               \/\/    and qword ptr [r25+0x632184c3], 16777216    IID506\n-    __ addq(Address(r13, r13, (Address::ScaleFactor)0, -0x3972eac6), 16777216); \/\/    add qword ptr [r13+r13*1-0x3972eac6], 16777216    IID507\n-    __ cmpq(Address(r9, -0x13b4c806), 4096);                                    \/\/    cmp qword ptr [r9-0x13b4c806], 4096    IID508\n-    __ sarq(Address(r31, +0x4fa7f551), 1);                                      \/\/    sar qword ptr [r31+0x4fa7f551], 1    IID509\n-    __ salq(Address(r21, r31, (Address::ScaleFactor)2, +0x31aa8232), 1);        \/\/    sal qword ptr [r21+r31*4+0x31aa8232], 1    IID510\n-    __ sbbq(Address(r24, r31, (Address::ScaleFactor)2, -0x466538b7), 268435456); \/\/    sbb qword ptr [r24+r31*4-0x466538b7], 268435456    IID511\n-    __ shrq(Address(r28, r22, (Address::ScaleFactor)0, -0x3efe85b1), 2);        \/\/    shr qword ptr [r28+r22*1-0x3efe85b1], 2    IID512\n-    __ subq(Address(r16, -0x1389a3eb), 1048576);                                \/\/    sub qword ptr [r16-0x1389a3eb], 1048576    IID513\n-    __ xorq(Address(r29, r8, (Address::ScaleFactor)0, +0x1d022615), 16);        \/\/    xor qword ptr [r29+r8*1+0x1d022615], 16    IID514\n-    __ orq(Address(r12, r28, (Address::ScaleFactor)1, -0x34c898e2), 1);         \/\/    or qword ptr [r12+r28*2-0x34c898e2], 1    IID515\n-    __ movq(Address(rcx, r24, (Address::ScaleFactor)2, -0x1644eb08), 256);      \/\/    mov qword ptr [rcx+r24*4-0x1644eb08], 256    IID516\n-    __ testq(Address(r29, -0x7d23890b), -65536);                                \/\/    test qword ptr [r29-0x7d23890b], -65536    IID517\n-    __ addq(r23, Address(rcx, r19, (Address::ScaleFactor)2, +0x70eac654));      \/\/    add r23, qword ptr [rcx+r19*4+0x70eac654]    IID518\n-    __ andq(rdx, Address(r24, r15, (Address::ScaleFactor)0, -0x204ddaa9));      \/\/    and rdx, qword ptr [r24+r15*1-0x204ddaa9]    IID519\n-    __ cmpq(rdx, Address(r23, r11, (Address::ScaleFactor)3, +0x32c930bd));      \/\/    cmp rdx, qword ptr [r23+r11*8+0x32c930bd]    IID520\n-    __ lzcntq(r28, Address(rdx, -0x5433c28f));                                  \/\/    lzcnt r28, qword ptr [rdx-0x5433c28f]    IID521\n-    __ orq(r22, Address(r19, r14, (Address::ScaleFactor)1, -0x2cc67d38));       \/\/    or r22, qword ptr [r19+r14*2-0x2cc67d38]    IID522\n-    __ adcq(r10, Address(r10, +0x3d7c59f));                                     \/\/    adc r10, qword ptr [r10+0x3d7c59f]    IID523\n-    __ imulq(r10, Address(r8, r8, (Address::ScaleFactor)3, -0xe61862d));        \/\/    imul r10, qword ptr [r8+r8*8-0xe61862d]    IID524\n-    __ popcntq(r23, Address(r29, -0x777ed96d));                                 \/\/    popcnt r23, qword ptr [r29-0x777ed96d]    IID525\n-    __ sbbq(rcx, Address(rbx, r19, (Address::ScaleFactor)1, +0x53c601cb));      \/\/    sbb rcx, qword ptr [rbx+r19*2+0x53c601cb]    IID526\n-    __ subq(r14, Address(r17, rbx, (Address::ScaleFactor)0, -0x768bf073));      \/\/    sub r14, qword ptr [r17+rbx*1-0x768bf073]    IID527\n-    __ tzcntq(r29, Address(r10, r19, (Address::ScaleFactor)1, +0x30c98d3c));    \/\/    tzcnt r29, qword ptr [r10+r19*2+0x30c98d3c]    IID528\n-    __ xorq(r10, Address(r16, r27, (Address::ScaleFactor)0, -0x3d08d602));      \/\/    xor r10, qword ptr [r16+r27*1-0x3d08d602]    IID529\n-    __ movq(r18, Address(r28, r28, (Address::ScaleFactor)3, -0x62fbac91));      \/\/    mov r18, qword ptr [r28+r28*8-0x62fbac91]    IID530\n-    __ leaq(rbx, Address(rcx, +0x450602a5));                                    \/\/    lea rbx, qword ptr [rcx+0x450602a5]    IID531\n-    __ cvttsd2siq(r12, Address(r30, r31, (Address::ScaleFactor)0, -0x6798a630)); \/\/    cvttsd2si r12, qword ptr [r30+r31*1-0x6798a630]    IID532\n-    __ xchgq(r31, Address(r24, r10, (Address::ScaleFactor)1, -0x706712ed));     \/\/    xchg r31, qword ptr [r24+r10*2-0x706712ed]    IID533\n-    __ testq(r14, Address(r13, r20, (Address::ScaleFactor)3, +0x171081f2));     \/\/    test r14, qword ptr [r13+r20*8+0x171081f2]    IID534\n-    __ addq(r31, 16);                                                           \/\/    add r31, 16    IID535\n-    __ andq(r25, 16);                                                           \/\/    and r25, 16    IID536\n-    __ adcq(r23, 256);                                                          \/\/    adc r23, 256    IID537\n-    __ cmpq(r19, 268435456);                                                    \/\/    cmp r19, 268435456    IID538\n-    __ rclq(r31, 1);                                                            \/\/    rcl r31, 1    IID539\n-    __ rcrq(r17, 1);                                                            \/\/    rcr r17, 1    IID540\n-    __ rolq(r25, 2);                                                            \/\/    rol r25, 2    IID541\n-    __ rorq(r17, 4);                                                            \/\/    ror r17, 4    IID542\n-    __ sarq(r28, 1);                                                            \/\/    sar r28, 1    IID543\n-    __ salq(r15, 4);                                                            \/\/    sal r15, 4    IID544\n-    __ sbbq(rbx, 65536);                                                        \/\/    sbb rbx, 65536    IID545\n-    __ shlq(r21, 1);                                                            \/\/    shl r21, 1    IID546\n-    __ shrq(r10, 1);                                                            \/\/    shr r10, 1    IID547\n-    __ subq(r14, 16);                                                           \/\/    sub r14, 16    IID548\n-    __ xorq(r18, 268435456);                                                    \/\/    xor r18, 268435456    IID549\n-    __ movq(r23, 16);                                                           \/\/    mov r23, 16    IID550\n-    __ mov64(r12, 1099511627776);                                               \/\/    mov r12, 1099511627776    IID551\n-    __ btq(r14, 4);                                                             \/\/    bt r14, 4    IID552\n-    __ testq(r24, -4096);                                                       \/\/    test r24, -4096    IID553\n-    __ orq_imm32(r19, 1048576);                                                 \/\/    or r19, 1048576    IID554\n-    __ subq_imm32(rcx, 268435456);                                              \/\/    sub rcx, 268435456    IID555\n-    __ cmovq(Assembler::Condition::overflow, rdx, Address(r19, rbx, (Address::ScaleFactor)3, +0x211c8c4)); \/\/    cmovo rdx, qword ptr [r19+rbx*8+0x211c8c4]    IID556\n-    __ cmovq(Assembler::Condition::noOverflow, rbx, Address(r21, +0x49267743)); \/\/    cmovno rbx, qword ptr [r21+0x49267743]    IID557\n-    __ cmovq(Assembler::Condition::below, r21, Address(r8, r28, (Address::ScaleFactor)1, -0x4c8c2946)); \/\/    cmovb r21, qword ptr [r8+r28*2-0x4c8c2946]    IID558\n-    __ cmovq(Assembler::Condition::aboveEqual, r12, Address(r26, r20, (Address::ScaleFactor)0, -0x264df89c)); \/\/    cmovae r12, qword ptr [r26+r20*1-0x264df89c]    IID559\n-    __ cmovq(Assembler::Condition::zero, r17, Address(r28, r9, (Address::ScaleFactor)2, +0x3497196b)); \/\/    cmovz r17, qword ptr [r28+r9*4+0x3497196b]    IID560\n-    __ cmovq(Assembler::Condition::notZero, r13, Address(r15, r23, (Address::ScaleFactor)1, -0x27a30999)); \/\/    cmovnz r13, qword ptr [r15+r23*2-0x27a30999]    IID561\n-    __ cmovq(Assembler::Condition::belowEqual, r22, Address(r22, +0xf39ab05));  \/\/    cmovbe r22, qword ptr [r22+0xf39ab05]    IID562\n-    __ cmovq(Assembler::Condition::above, rcx, Address(r22, r26, (Address::ScaleFactor)3, -0x48c954c)); \/\/    cmova rcx, qword ptr [r22+r26*8-0x48c954c]    IID563\n-    __ cmovq(Assembler::Condition::negative, r25, Address(r19, r21, (Address::ScaleFactor)0, +0xe405b0b)); \/\/    cmovs r25, qword ptr [r19+r21*1+0xe405b0b]    IID564\n-    __ cmovq(Assembler::Condition::positive, r12, Address(r19, r29, (Address::ScaleFactor)3, -0x7762044b)); \/\/    cmovns r12, qword ptr [r19+r29*8-0x7762044b]    IID565\n-    __ cmovq(Assembler::Condition::parity, rbx, Address(r30, r10, (Address::ScaleFactor)1, -0x19798323)); \/\/    cmovp rbx, qword ptr [r30+r10*2-0x19798323]    IID566\n-    __ cmovq(Assembler::Condition::noParity, r21, Address(r24, r31, (Address::ScaleFactor)0, -0x5731652b)); \/\/    cmovnp r21, qword ptr [r24+r31*1-0x5731652b]    IID567\n-    __ cmovq(Assembler::Condition::less, r18, Address(r8, r10, (Address::ScaleFactor)1, -0x5613be89)); \/\/    cmovl r18, qword ptr [r8+r10*2-0x5613be89]    IID568\n-    __ cmovq(Assembler::Condition::greaterEqual, r28, Address(r21, r21, (Address::ScaleFactor)3, +0x65a0fdc4)); \/\/    cmovge r28, qword ptr [r21+r21*8+0x65a0fdc4]    IID569\n-    __ cmovq(Assembler::Condition::lessEqual, r23, Address(r11, r18, (Address::ScaleFactor)0, -0x1d1af10c)); \/\/    cmovle r23, qword ptr [r11+r18*1-0x1d1af10c]    IID570\n-    __ cmovq(Assembler::Condition::greater, r22, Address(r18, r12, (Address::ScaleFactor)1, +0x1a5f1c38)); \/\/    cmovg r22, qword ptr [r18+r12*2+0x1a5f1c38]    IID571\n-    __ call(r23);                                                               \/\/    call r23    IID572\n-    __ divq(r30);                                                               \/\/    div r30    IID573\n-    __ idivq(r19);                                                              \/\/    idiv r19    IID574\n-    __ imulq(r9);                                                               \/\/    imul r9    IID575\n-    __ mulq(r13);                                                               \/\/    mul r13    IID576\n-    __ negq(r16);                                                               \/\/    neg r16    IID577\n-    __ notq(r29);                                                               \/\/    not r29    IID578\n-    __ rolq(rcx);                                                               \/\/    rol rcx, cl    IID579\n-    __ rorq(r25);                                                               \/\/    ror r25, cl    IID580\n-    __ sarq(r8);                                                                \/\/    sar r8, cl    IID581\n-    __ salq(r27);                                                               \/\/    sal r27, cl    IID582\n-    __ shlq(r30);                                                               \/\/    shl r30, cl    IID583\n-    __ shrq(r23);                                                               \/\/    shr r23, cl    IID584\n-    __ incrementq(rbx);                                                         \/\/    inc rbx    IID585\n-    __ decrementq(r14);                                                         \/\/    dec r14    IID586\n-    __ pushp(r21);                                                              \/\/    pushp r21    IID587\n-    __ popp(r21);                                                               \/\/    popp r21    IID588\n-    __ call(Address(r20, r21, (Address::ScaleFactor)1, +0x56c6af2f));           \/\/    call qword ptr [r20+r21*2+0x56c6af2f]    IID589\n-    __ mulq(Address(r31, r19, (Address::ScaleFactor)3, -0x1b4eb23));            \/\/    mul qword ptr [r31+r19*8-0x1b4eb23]    IID590\n-    __ negq(Address(r27, r27, (Address::ScaleFactor)0, -0x58dbfc1f));           \/\/    neg qword ptr [r27+r27*1-0x58dbfc1f]    IID591\n-    __ sarq(Address(rbx, r22, (Address::ScaleFactor)2, -0x606349d1));           \/\/    sar qword ptr [rbx+r22*4-0x606349d1], cl    IID592\n-    __ salq(Address(r26, r23, (Address::ScaleFactor)3, +0xb95a079));            \/\/    sal qword ptr [r26+r23*8+0xb95a079], cl    IID593\n-    __ shrq(Address(r14, r26, (Address::ScaleFactor)0, +0x3544e09));            \/\/    shr qword ptr [r14+r26*1+0x3544e09], cl    IID594\n-    __ incrementq(Address(r27, rdx, (Address::ScaleFactor)0, +0x120b3250));     \/\/    inc qword ptr [r27+rdx*1+0x120b3250]    IID595\n-    __ decrementq(Address(r9, r25, (Address::ScaleFactor)2, -0x34aaeccb));      \/\/    dec qword ptr [r9+r25*4-0x34aaeccb]    IID596\n-    __ imulq(r20, Address(r16, r28, (Address::ScaleFactor)1, -0x59de05a5), 1048576); \/\/    imul r20, qword ptr [r16+r28*2-0x59de05a5], 1048576    IID597\n-    __ imulq(r17, r23, 256);                                                    \/\/    imul r17, r23, 256    IID598\n-    __ shldq(r19, r11, 8);                                                      \/\/    shld r19, r11, 8    IID599\n-    __ shrdq(r28, r10, 8);                                                      \/\/    shrd r28, r10, 8    IID600\n-    __ pop2(r29, r26);                                                          \/\/    {load}pop2 r26, r29    IID601\n-    __ pop2p(r22, r10);                                                         \/\/    {load}pop2p r10, r22    IID602\n-    __ push2(r25, r30);                                                         \/\/    {load}push2 r30, r25    IID603\n-    __ push2p(r28, r15);                                                        \/\/    {load}push2p r15, r28    IID604\n-    __ movzbq(r11, Address(r29, r19, (Address::ScaleFactor)2, -0x12368d34));    \/\/    movzx r11, byte ptr [r29+r19*4-0x12368d34]    IID605\n-    __ movzwq(r14, Address(r8, r30, (Address::ScaleFactor)2, -0x4a9392de));     \/\/    movzx r14, word ptr [r8+r30*4-0x4a9392de]    IID606\n-    __ movsbq(r28, Address(r23, r15, (Address::ScaleFactor)0, +0x6189cb54));    \/\/    movsx r28, byte ptr [r23+r15*1+0x6189cb54]    IID607\n-    __ movswq(r28, Address(rbx, r23, (Address::ScaleFactor)3, -0x2de86561));    \/\/    movsx r28, word ptr [rbx+r23*8-0x2de86561]    IID608\n-    __ movzbq(r11, rcx);                                                        \/\/    movzx r11, cl    IID609\n-    __ movzwq(r30, r15);                                                        \/\/    movzx r30, r15w    IID610\n-    __ movsbq(r14, rcx);                                                        \/\/    movsx r14, cl    IID611\n-    __ movswq(r23, r9);                                                         \/\/    movsx r23, r9w    IID612\n-    __ cmpxchgq(r12, Address(r13, r10, (Address::ScaleFactor)1, -0x7c62c3a));   \/\/    cmpxchg qword ptr [r13+r10*2-0x7c62c3a], r12    IID613\n-    __ eidivq(rcx, false);                                                      \/\/    {EVEX}idiv rcx    IID614\n-    __ eidivq(r15, true);                                                       \/\/    {NF}idiv r15    IID615\n-    __ edivq(r23, false);                                                       \/\/    {EVEX}div r23    IID616\n-    __ edivq(r24, true);                                                        \/\/    {NF}div r24    IID617\n-    __ eimulq(r27, false);                                                      \/\/    {EVEX}imul r27    IID618\n-    __ eimulq(r30, true);                                                       \/\/    {NF}imul r30    IID619\n-    __ emulq(r12, false);                                                       \/\/    {EVEX}mul r12    IID620\n-    __ emulq(rcx, true);                                                        \/\/    {NF}mul rcx    IID621\n-    __ emulq(Address(r13, r9, (Address::ScaleFactor)3, -0x226aab94), false);    \/\/    {EVEX}mul qword ptr [r13+r9*8-0x226aab94]    IID622\n-    __ emulq(Address(r13, r24, (Address::ScaleFactor)3, -0x286c7605), true);    \/\/    {NF}mul qword ptr [r13+r24*8-0x286c7605]    IID623\n-    __ eimulq(r21, r30, false);                                                 \/\/    {EVEX}imul r21, r30    IID624\n-    __ eimulq(r17, r17, false);                                                 \/\/    imul r17    IID625\n-    __ eimulq(r29, r12, true);                                                  \/\/    {NF}imul r29, r12    IID626\n-    __ eimulq(r30, r30, true);                                                  \/\/    {NF}imul r30, r30    IID627\n-    __ elzcntq(r24, r15, false);                                                \/\/    {EVEX}lzcnt r24, r15    IID628\n-    __ elzcntq(r25, r25, false);                                                \/\/    {EVEX}lzcnt r25, r25    IID629\n-    __ elzcntq(r25, r21, true);                                                 \/\/    {NF}lzcnt r25, r21    IID630\n-    __ elzcntq(r22, r22, true);                                                 \/\/    {NF}lzcnt r22, r22    IID631\n-    __ enegq(r17, r30, false);                                                  \/\/    {EVEX}neg r17, r30    IID632\n-    __ enegq(r17, r17, false);                                                  \/\/    neg r17    IID633\n-    __ enegq(r31, r17, true);                                                   \/\/    {NF}neg r31, r17    IID634\n-    __ enegq(r29, r29, true);                                                   \/\/    {NF}neg r29, r29    IID635\n-    __ enotq(r10, r9);                                                          \/\/    {EVEX}not r10, r9    IID636\n-    __ enotq(r24, r24);                                                         \/\/    not r24    IID637\n-    __ epopcntq(r28, r15, false);                                               \/\/    {EVEX}popcnt r28, r15    IID638\n-    __ epopcntq(r10, r10, false);                                               \/\/    {EVEX}popcnt r10, r10    IID639\n-    __ epopcntq(r27, r30, true);                                                \/\/    {NF}popcnt r27, r30    IID640\n-    __ epopcntq(r28, r28, true);                                                \/\/    {NF}popcnt r28, r28    IID641\n-    __ erolq(r28, r14, false);                                                  \/\/    {EVEX}rol r28, r14, cl    IID642\n-    __ erolq(r23, r23, false);                                                  \/\/    rol r23, cl    IID643\n-    __ erolq(r23, r24, true);                                                   \/\/    {NF}rol r23, r24, cl    IID644\n-    __ erolq(r21, r21, true);                                                   \/\/    {NF}rol r21, r21, cl    IID645\n-    __ erorq(r31, r22, false);                                                  \/\/    {EVEX}ror r31, r22, cl    IID646\n-    __ erorq(r28, r28, false);                                                  \/\/    ror r28, cl    IID647\n-    __ erorq(r17, r10, true);                                                   \/\/    {NF}ror r17, r10, cl    IID648\n-    __ erorq(r9, r9, true);                                                     \/\/    {NF}ror r9, r9, cl    IID649\n-    __ esalq(r29, r30, false);                                                  \/\/    {EVEX}sal r29, r30, cl    IID650\n-    __ esalq(r11, r11, false);                                                  \/\/    sal r11, cl    IID651\n-    __ esalq(r26, r11, true);                                                   \/\/    {NF}sal r26, r11, cl    IID652\n-    __ esalq(r16, r16, true);                                                   \/\/    {NF}sal r16, r16, cl    IID653\n-    __ esarq(rbx, r15, false);                                                  \/\/    {EVEX}sar rbx, r15, cl    IID654\n-    __ esarq(r14, r14, false);                                                  \/\/    sar r14, cl    IID655\n-    __ esarq(r25, r16, true);                                                   \/\/    {NF}sar r25, r16, cl    IID656\n-    __ esarq(r8, r8, true);                                                     \/\/    {NF}sar r8, r8, cl    IID657\n-    __ edecq(r11, r13, false);                                                  \/\/    {EVEX}dec r11, r13    IID658\n-    __ edecq(rcx, rcx, false);                                                  \/\/    dec rcx    IID659\n-    __ edecq(r21, r18, true);                                                   \/\/    {NF}dec r21, r18    IID660\n-    __ edecq(r28, r28, true);                                                   \/\/    {NF}dec r28, r28    IID661\n-    __ eincq(r16, r16, false);                                                  \/\/    inc r16    IID662\n-    __ eincq(r29, r29, false);                                                  \/\/    inc r29    IID663\n-    __ eincq(r18, r9, true);                                                    \/\/    {NF}inc r18, r9    IID664\n-    __ eincq(r19, r19, true);                                                   \/\/    {NF}inc r19, r19    IID665\n-    __ eshlq(r19, r18, false);                                                  \/\/    {EVEX}shl r19, r18, cl    IID666\n-    __ eshlq(r8, r8, false);                                                    \/\/    shl r8, cl    IID667\n-    __ eshlq(r12, r15, true);                                                   \/\/    {NF}shl r12, r15, cl    IID668\n-    __ eshlq(r29, r29, true);                                                   \/\/    {NF}shl r29, r29, cl    IID669\n-    __ eshrq(r28, r24, false);                                                  \/\/    {EVEX}shr r28, r24, cl    IID670\n-    __ eshrq(r19, r19, false);                                                  \/\/    shr r19, cl    IID671\n-    __ eshrq(r8, r28, true);                                                    \/\/    {NF}shr r8, r28, cl    IID672\n-    __ eshrq(r17, r17, true);                                                   \/\/    {NF}shr r17, r17, cl    IID673\n-    __ etzcntq(r28, r16, false);                                                \/\/    {EVEX}tzcnt r28, r16    IID674\n-    __ etzcntq(r14, r14, false);                                                \/\/    {EVEX}tzcnt r14, r14    IID675\n-    __ etzcntq(r12, r31, true);                                                 \/\/    {NF}tzcnt r12, r31    IID676\n-    __ etzcntq(r14, r14, true);                                                 \/\/    {NF}tzcnt r14, r14    IID677\n-    __ eimulq(r31, Address(r13, -0x69c4b352), false);                           \/\/    {EVEX}imul r31, qword ptr [r13-0x69c4b352]    IID678\n-    __ eimulq(r17, Address(r18, -0x60ab1105), true);                            \/\/    {NF}imul r17, qword ptr [r18-0x60ab1105]    IID679\n-    __ elzcntq(r27, Address(r14, r25, (Address::ScaleFactor)2, +0x2798bf83), false); \/\/    {EVEX}lzcnt r27, qword ptr [r14+r25*4+0x2798bf83]    IID680\n-    __ elzcntq(r23, Address(r10, r11, (Address::ScaleFactor)0, -0x378e635d), true); \/\/    {NF}lzcnt r23, qword ptr [r10+r11*1-0x378e635d]    IID681\n-    __ enegq(rcx, Address(r19, r9, (Address::ScaleFactor)3, -0x6847d440), false); \/\/    {EVEX}neg rcx, qword ptr [r19+r9*8-0x6847d440]    IID682\n-    __ enegq(rcx, Address(rbx, rcx, (Address::ScaleFactor)0, +0x6f92d38d), true); \/\/    {NF}neg rcx, qword ptr [rbx+rcx*1+0x6f92d38d]    IID683\n-    __ epopcntq(r20, Address(r12, -0x2a8b27d6), false);                         \/\/    {EVEX}popcnt r20, qword ptr [r12-0x2a8b27d6]    IID684\n-    __ epopcntq(r31, Address(r30, +0x4603f6d0), true);                          \/\/    {NF}popcnt r31, qword ptr [r30+0x4603f6d0]    IID685\n-    __ esalq(rbx, Address(r24, +0x567d06f9), false);                            \/\/    {EVEX}sal rbx, qword ptr [r24+0x567d06f9], cl    IID686\n-    __ esalq(r12, Address(r24, r28, (Address::ScaleFactor)0, -0x1c4c584e), true); \/\/    {NF}sal r12, qword ptr [r24+r28*1-0x1c4c584e], cl    IID687\n-    __ esarq(r12, Address(r23, r24, (Address::ScaleFactor)2, -0x3157bcba), false); \/\/    {EVEX}sar r12, qword ptr [r23+r24*4-0x3157bcba], cl    IID688\n-    __ esarq(r8, Address(r14, r24, (Address::ScaleFactor)2, -0x714290a5), true); \/\/    {NF}sar r8, qword ptr [r14+r24*4-0x714290a5], cl    IID689\n-    __ edecq(r23, Address(r8, r15, (Address::ScaleFactor)1, -0x5ae272dd), false); \/\/    {EVEX}dec r23, qword ptr [r8+r15*2-0x5ae272dd]    IID690\n-    __ edecq(r13, Address(r29, r9, (Address::ScaleFactor)3, -0x5b5174a9), true); \/\/    {NF}dec r13, qword ptr [r29+r9*8-0x5b5174a9]    IID691\n-    __ eincq(r11, Address(r21, r31, (Address::ScaleFactor)3, -0x2176b4dc), false); \/\/    {EVEX}inc r11, qword ptr [r21+r31*8-0x2176b4dc]    IID692\n-    __ eincq(r13, Address(rcx, r16, (Address::ScaleFactor)0, -0x36b448c9), true); \/\/    {NF}inc r13, qword ptr [rcx+r16*1-0x36b448c9]    IID693\n-    __ eshrq(r26, Address(r25, rcx, (Address::ScaleFactor)2, -0x5f894993), false); \/\/    {EVEX}shr r26, qword ptr [r25+rcx*4-0x5f894993], cl    IID694\n-    __ eshrq(r25, Address(r9, +0x51798d21), true);                              \/\/    {NF}shr r25, qword ptr [r9+0x51798d21], cl    IID695\n-    __ etzcntq(r28, Address(r13, r26, (Address::ScaleFactor)2, +0x207196f6), false); \/\/    {EVEX}tzcnt r28, qword ptr [r13+r26*4+0x207196f6]    IID696\n-    __ etzcntq(rbx, Address(r19, r13, (Address::ScaleFactor)0, -0x24d937d5), true); \/\/    {NF}tzcnt rbx, qword ptr [r19+r13*1-0x24d937d5]    IID697\n-    __ eaddq(r17, Address(r30, +0x3935ccff), r31, false);                       \/\/    {EVEX}add r17, qword ptr [r30+0x3935ccff], r31    IID698\n-    __ eaddq(r14, Address(r27, r10, (Address::ScaleFactor)2, -0x34ad9bab), r14, false); \/\/    {EVEX}add r14, qword ptr [r27+r10*4-0x34ad9bab], r14    IID699\n-    __ eaddq(r18, Address(r20, r23, (Address::ScaleFactor)0, +0x5ad3ed4b), r30, true); \/\/    {NF}add r18, qword ptr [r20+r23*1+0x5ad3ed4b], r30    IID700\n-    __ eaddq(r20, Address(rdx, -0x322a99e5), r20, true);                        \/\/    {NF}add r20, qword ptr [rdx-0x322a99e5], r20    IID701\n-    __ eandq(r31, Address(rbx, r27, (Address::ScaleFactor)3, +0x4ce247d2), r17, false); \/\/    {EVEX}and r31, qword ptr [rbx+r27*8+0x4ce247d2], r17    IID702\n-    __ eandq(r30, Address(r18, r19, (Address::ScaleFactor)1, -0x4ee3d14), r30, false); \/\/    {EVEX}and r30, qword ptr [r18+r19*2-0x4ee3d14], r30    IID703\n-    __ eandq(r28, Address(r11, rbx, (Address::ScaleFactor)3, -0x28994bbf), r24, true); \/\/    {NF}and r28, qword ptr [r11+rbx*8-0x28994bbf], r24    IID704\n-    __ eandq(r30, Address(r22, +0x7d21c24), r30, true);                         \/\/    {NF}and r30, qword ptr [r22+0x7d21c24], r30    IID705\n-    __ eorq(r26, Address(r15, r19, (Address::ScaleFactor)3, +0x58c21792), r20, false); \/\/    {EVEX}or r26, qword ptr [r15+r19*8+0x58c21792], r20    IID706\n-    __ eorq(r13, Address(r10, r27, (Address::ScaleFactor)2, -0x2c70d333), r13, false); \/\/    {EVEX}or r13, qword ptr [r10+r27*4-0x2c70d333], r13    IID707\n-    __ eorq(rbx, Address(r12, rbx, (Address::ScaleFactor)0, -0x1fb0f1bc), r26, true); \/\/    {NF}or rbx, qword ptr [r12+rbx*1-0x1fb0f1bc], r26    IID708\n-    __ eorq(r31, Address(r27, r31, (Address::ScaleFactor)1, +0x28d1756), r31, true); \/\/    {NF}or r31, qword ptr [r27+r31*2+0x28d1756], r31    IID709\n-    __ esubq(r24, Address(r28, r23, (Address::ScaleFactor)1, +0x6980f610), r27, false); \/\/    {EVEX}sub r24, qword ptr [r28+r23*2+0x6980f610], r27    IID710\n-    __ esubq(r15, Address(r11, r30, (Address::ScaleFactor)3, -0x49777e7), r15, false); \/\/    {EVEX}sub r15, qword ptr [r11+r30*8-0x49777e7], r15    IID711\n-    __ esubq(r17, Address(r25, r13, (Address::ScaleFactor)2, +0x31619e46), r31, true); \/\/    {NF}sub r17, qword ptr [r25+r13*4+0x31619e46], r31    IID712\n-    __ esubq(r18, Address(r11, r10, (Address::ScaleFactor)2, +0x1922861a), r18, true); \/\/    {NF}sub r18, qword ptr [r11+r10*4+0x1922861a], r18    IID713\n-    __ exorq(rbx, Address(r11, -0x4716d420), r21, false);                       \/\/    {EVEX}xor rbx, qword ptr [r11-0x4716d420], r21    IID714\n-    __ exorq(r8, Address(rdx, r9, (Address::ScaleFactor)2, -0x4cfe39c), r8, false); \/\/    {EVEX}xor r8, qword ptr [rdx+r9*4-0x4cfe39c], r8    IID715\n-    __ exorq(r16, Address(r14, r27, (Address::ScaleFactor)0, +0x7c6654d9), r25, true); \/\/    {NF}xor r16, qword ptr [r14+r27*1+0x7c6654d9], r25    IID716\n-    __ exorq(r29, Address(r15, -0x5efab479), r29, true);                        \/\/    {NF}xor r29, qword ptr [r15-0x5efab479], r29    IID717\n-    __ eaddq(r19, Address(r13, r22, (Address::ScaleFactor)2, +0x68b64559), 16777216, false); \/\/    {EVEX}add r19, qword ptr [r13+r22*4+0x68b64559], 16777216    IID718\n-    __ eaddq(r16, Address(r13, r31, (Address::ScaleFactor)3, -0x65143af5), 1, true); \/\/    {NF}add r16, qword ptr [r13+r31*8-0x65143af5], 1    IID719\n-    __ eandq(r31, Address(r24, r13, (Address::ScaleFactor)1, -0x25b16a0e), 1, false); \/\/    {EVEX}and r31, qword ptr [r24+r13*2-0x25b16a0e], 1    IID720\n-    __ eandq(r11, Address(r28, -0xf6d4b26), 65536, true);                       \/\/    {NF}and r11, qword ptr [r28-0xf6d4b26], 65536    IID721\n-    __ eimulq(rcx, Address(r18, r10, (Address::ScaleFactor)0, +0x46ec6da1), 16777216, false); \/\/    {EVEX}imul rcx, qword ptr [r18+r10*1+0x46ec6da1], 16777216    IID722\n-    __ eimulq(r15, Address(r9, r10, (Address::ScaleFactor)3, -0x7fc36af3), 16, true); \/\/    {NF}imul r15, qword ptr [r9+r10*8-0x7fc36af3], 16    IID723\n-    __ eorq(r17, Address(r27, r30, (Address::ScaleFactor)0, +0x1b4cda2c), 1, false); \/\/    {EVEX}or r17, qword ptr [r27+r30*1+0x1b4cda2c], 1    IID724\n-    __ eorq(rdx, Address(r25, r14, (Address::ScaleFactor)2, -0x59aa6b85), 4096, true); \/\/    {NF}or rdx, qword ptr [r25+r14*4-0x59aa6b85], 4096    IID725\n-    __ esalq(r17, Address(r26, r21, (Address::ScaleFactor)1, -0x6ab1f15f), 8, false); \/\/    {EVEX}sal r17, qword ptr [r26+r21*2-0x6ab1f15f], 8    IID726\n-    __ esalq(r12, Address(r22, r17, (Address::ScaleFactor)0, -0x43ac14ab), 2, true); \/\/    {NF}sal r12, qword ptr [r22+r17*1-0x43ac14ab], 2    IID727\n-    __ esarq(r29, Address(r18, r16, (Address::ScaleFactor)0, -0x59dc0c61), 4, false); \/\/    {EVEX}sar r29, qword ptr [r18+r16*1-0x59dc0c61], 4    IID728\n-    __ esarq(r16, Address(r11, -0x7bdd314), 4, true);                           \/\/    {NF}sar r16, qword ptr [r11-0x7bdd314], 4    IID729\n-    __ eshrq(r26, Address(r23, r27, (Address::ScaleFactor)3, -0x55b92314), 16, false); \/\/    {EVEX}shr r26, qword ptr [r23+r27*8-0x55b92314], 16    IID730\n-    __ eshrq(r23, Address(r16, r29, (Address::ScaleFactor)1, +0x71311a1d), 2, true); \/\/    {NF}shr r23, qword ptr [r16+r29*2+0x71311a1d], 2    IID731\n-    __ esubq(r25, Address(r9, -0x9532bac), 1048576, false);                     \/\/    {EVEX}sub r25, qword ptr [r9-0x9532bac], 1048576    IID732\n-    __ esubq(r17, Address(r8, r23, (Address::ScaleFactor)0, +0x55d06ca2), 1048576, true); \/\/    {NF}sub r17, qword ptr [r8+r23*1+0x55d06ca2], 1048576    IID733\n-    __ exorq(r29, Address(r9, r24, (Address::ScaleFactor)0, -0x2c141c1), 1048576, false); \/\/    {EVEX}xor r29, qword ptr [r9+r24*1-0x2c141c1], 1048576    IID734\n-    __ exorq(r28, Address(r22, r19, (Address::ScaleFactor)1, -0x2d9d9abd), 16, true); \/\/    {NF}xor r28, qword ptr [r22+r19*2-0x2d9d9abd], 16    IID735\n-    __ eaddq(r22, r14, 16, false);                                              \/\/    {EVEX}add r22, r14, 16    IID736\n-    __ eaddq(rax, r12, 16, false);                                              \/\/    {EVEX}add rax, r12, 16    IID737\n-    __ eaddq(r24, r24, 65536, false);                                           \/\/    add r24, 65536    IID738\n-    __ eaddq(r21, rbx, 65536, true);                                            \/\/    {NF}add r21, rbx, 65536    IID739\n-    __ eaddq(rax, rbx, 65536, true);                                            \/\/    {NF}add rax, rbx, 65536    IID740\n-    __ eaddq(r24, r24, 65536, true);                                            \/\/    {NF}add r24, r24, 65536    IID741\n-    __ eandq(r21, r27, 16777216, false);                                        \/\/    {EVEX}and r21, r27, 16777216    IID742\n-    __ eandq(rax, r27, 16777216, false);                                        \/\/    {EVEX}and rax, r27, 16777216    IID743\n-    __ eandq(r24, r24, 65536, false);                                           \/\/    and r24, 65536    IID744\n-    __ eandq(r13, r31, 1048576, true);                                          \/\/    {NF}and r13, r31, 1048576    IID745\n-    __ eandq(rax, r21, 1048576, true);                                          \/\/    {NF}and rax, r21, 1048576    IID746\n-    __ eandq(r30, r30, 1048576, true);                                          \/\/    {NF}and r30, r30, 1048576    IID747\n-    __ eimulq(r8, r13, 268435456, false);                                       \/\/    {EVEX}imul r8, r13, 268435456    IID748\n-    __ eimulq(rax, r31, 268435456, false);                                      \/\/    {EVEX}imul rax, r31, 268435456    IID749\n-    __ eimulq(r13, r13, 65536, false);                                          \/\/    {EVEX}imul r13, r13, 65536    IID750\n-    __ eimulq(r14, r29, 1048576, true);                                         \/\/    {NF}imul r14, r29, 1048576    IID751\n-    __ eimulq(rax, r22, 1048576, true);                                         \/\/    {NF}imul rax, r22, 1048576    IID752\n-    __ eimulq(r8, r8, 268435456, true);                                         \/\/    {NF}imul r8, r8, 268435456    IID753\n-    __ eorq(r30, r15, 4096, false);                                             \/\/    {EVEX}or r30, r15, 4096    IID754\n-    __ eorq(rax, r28, 4096, false);                                             \/\/    {EVEX}or rax, r28, 4096    IID755\n-    __ eorq(r26, r26, 1048576, false);                                          \/\/    or r26, 1048576    IID756\n-    __ eorq(r16, r12, 268435456, true);                                         \/\/    {NF}or r16, r12, 268435456    IID757\n-    __ eorq(rax, r9, 268435456, true);                                          \/\/    {NF}or rax, r9, 268435456    IID758\n-    __ eorq(r23, r23, 256, true);                                               \/\/    {NF}or r23, r23, 256    IID759\n-    __ erclq(r15, r9, 16);                                                      \/\/    {EVEX}rcl r15, r9, 16    IID760\n-    __ erclq(rax, r8, 16);                                                      \/\/    {EVEX}rcl rax, r8, 16    IID761\n-    __ erclq(r25, r25, 1);                                                      \/\/    rcl r25, 1    IID762\n-    __ erolq(r9, r17, 16, false);                                               \/\/    {EVEX}rol r9, r17, 16    IID763\n-    __ erolq(rax, r20, 16, false);                                              \/\/    {EVEX}rol rax, r20, 16    IID764\n-    __ erolq(r27, r27, 1, false);                                               \/\/    rol r27, 1    IID765\n-    __ erolq(r20, r31, 1, true);                                                \/\/    {NF}rol r20, r31, 1    IID766\n-    __ erolq(rax, r18, 1, true);                                                \/\/    {NF}rol rax, r18, 1    IID767\n-    __ erolq(r28, r28, 16, true);                                               \/\/    {NF}rol r28, r28, 16    IID768\n-    __ erorq(r26, r18, 16, false);                                              \/\/    {EVEX}ror r26, r18, 16    IID769\n-    __ erorq(rax, r24, 16, false);                                              \/\/    {EVEX}ror rax, r24, 16    IID770\n-    __ erorq(r22, r22, 16, false);                                              \/\/    ror r22, 16    IID771\n-    __ erorq(r27, r29, 1, true);                                                \/\/    {NF}ror r27, r29, 1    IID772\n-    __ erorq(rax, r18, 1, true);                                                \/\/    {NF}ror rax, r18, 1    IID773\n-    __ erorq(r21, r21, 1, true);                                                \/\/    {NF}ror r21, r21, 1    IID774\n-    __ esalq(r12, rcx, 2, false);                                               \/\/    {EVEX}sal r12, rcx, 2    IID775\n-    __ esalq(rax, r24, 2, false);                                               \/\/    {EVEX}sal rax, r24, 2    IID776\n-    __ esalq(r22, r22, 8, false);                                               \/\/    sal r22, 8    IID777\n-    __ esalq(r17, r23, 8, true);                                                \/\/    {NF}sal r17, r23, 8    IID778\n-    __ esalq(rax, r27, 8, true);                                                \/\/    {NF}sal rax, r27, 8    IID779\n-    __ esalq(r23, r23, 1, true);                                                \/\/    {NF}sal r23, r23, 1    IID780\n-    __ esarq(r8, r25, 16, false);                                               \/\/    {EVEX}sar r8, r25, 16    IID781\n-    __ esarq(rax, r23, 16, false);                                              \/\/    {EVEX}sar rax, r23, 16    IID782\n-    __ esarq(r9, r9, 4, false);                                                 \/\/    sar r9, 4    IID783\n-    __ esarq(r22, r13, 1, true);                                                \/\/    {NF}sar r22, r13, 1    IID784\n-    __ esarq(rax, r11, 1, true);                                                \/\/    {NF}sar rax, r11, 1    IID785\n-    __ esarq(r12, r12, 2, true);                                                \/\/    {NF}sar r12, r12, 2    IID786\n-    __ eshlq(rcx, r30, 8, false);                                               \/\/    {EVEX}shl rcx, r30, 8    IID787\n-    __ eshlq(rax, r19, 8, false);                                               \/\/    {EVEX}shl rax, r19, 8    IID788\n-    __ eshlq(r13, r13, 2, false);                                               \/\/    shl r13, 2    IID789\n-    __ eshlq(r18, r11, 8, true);                                                \/\/    {NF}shl r18, r11, 8    IID790\n-    __ eshlq(rax, r9, 8, true);                                                 \/\/    {NF}shl rax, r9, 8    IID791\n-    __ eshlq(rcx, rcx, 16, true);                                               \/\/    {NF}shl rcx, rcx, 16    IID792\n-    __ eshrq(r10, r22, 4, false);                                               \/\/    {EVEX}shr r10, r22, 4    IID793\n-    __ eshrq(rax, r9, 4, false);                                                \/\/    {EVEX}shr rax, r9, 4    IID794\n-    __ eshrq(r12, r12, 2, false);                                               \/\/    shr r12, 2    IID795\n-    __ eshrq(r26, r31, 8, true);                                                \/\/    {NF}shr r26, r31, 8    IID796\n-    __ eshrq(rax, r12, 8, true);                                                \/\/    {NF}shr rax, r12, 8    IID797\n-    __ eshrq(r28, r28, 1, true);                                                \/\/    {NF}shr r28, r28, 1    IID798\n-    __ esubq(r15, r30, 65536, false);                                           \/\/    {EVEX}sub r15, r30, 65536    IID799\n-    __ esubq(rax, rcx, 65536, false);                                           \/\/    {EVEX}sub rax, rcx, 65536    IID800\n-    __ esubq(r26, r26, 16, false);                                              \/\/    sub r26, 16    IID801\n-    __ esubq(r12, r14, 1, true);                                                \/\/    {NF}sub r12, r14, 1    IID802\n-    __ esubq(rax, r21, 1, true);                                                \/\/    {NF}sub rax, r21, 1    IID803\n-    __ esubq(r20, r20, 1048576, true);                                          \/\/    {NF}sub r20, r20, 1048576    IID804\n-    __ exorq(r11, rbx, 16777216, false);                                        \/\/    {EVEX}xor r11, rbx, 16777216    IID805\n-    __ exorq(rax, r23, 16777216, false);                                        \/\/    {EVEX}xor rax, r23, 16777216    IID806\n-    __ exorq(r31, r31, 268435456, false);                                       \/\/    xor r31, 268435456    IID807\n-    __ exorq(r29, r28, 4096, true);                                             \/\/    {NF}xor r29, r28, 4096    IID808\n-    __ exorq(rax, r19, 4096, true);                                             \/\/    {NF}xor rax, r19, 4096    IID809\n-    __ exorq(rdx, rdx, 268435456, true);                                        \/\/    {NF}xor rdx, rdx, 268435456    IID810\n-    __ eorq_imm32(rdx, rdx, 1048576, false);                                    \/\/    or rdx, 1048576    IID811\n-    __ eorq_imm32(rax, r22, 1048576, false);                                    \/\/    {EVEX}or rax, r22, 1048576    IID812\n-    __ eorq_imm32(r29, r29, 1048576, false);                                    \/\/    or r29, 1048576    IID813\n-    __ eorq_imm32(r17, rcx, 4194304, false);                                    \/\/    {EVEX}or r17, rcx, 4194304    IID814\n-    __ eorq_imm32(rax, r25, 4194304, false);                                    \/\/    {EVEX}or rax, r25, 4194304    IID815\n-    __ eorq_imm32(r27, r27, 1073741824, false);                                 \/\/    or r27, 1073741824    IID816\n-    __ esubq_imm32(r16, r19, 4194304, false);                                   \/\/    {EVEX}sub r16, r19, 4194304    IID817\n-    __ esubq_imm32(rax, r31, 4194304, false);                                   \/\/    {EVEX}sub rax, r31, 4194304    IID818\n-    __ esubq_imm32(r26, r26, 262144, false);                                    \/\/    sub r26, 262144    IID819\n-    __ esubq_imm32(r17, r22, 1073741824, true);                                 \/\/    {NF}sub r17, r22, 1073741824    IID820\n-    __ esubq_imm32(rax, r18, 1073741824, true);                                 \/\/    {NF}sub rax, r18, 1073741824    IID821\n-    __ esubq_imm32(r23, r23, 268435456, true);                                  \/\/    {NF}sub r23, r23, 268435456    IID822\n-    __ eaddq(r13, r30, Address(r24, r19, (Address::ScaleFactor)1, +0x56ea3a3b), false); \/\/    {EVEX}add r13, r30, qword ptr [r24+r19*2+0x56ea3a3b]    IID823\n-    __ eaddq(r29, r15, Address(r26, r27, (Address::ScaleFactor)3, -0x4b113958), true); \/\/    {NF}add r29, r15, qword ptr [r26+r27*8-0x4b113958]    IID824\n-    __ eandq(r12, r30, Address(r31, -0x46103c74), false);                       \/\/    {EVEX}and r12, r30, qword ptr [r31-0x46103c74]    IID825\n-    __ eandq(r27, r10, Address(r22, r25, (Address::ScaleFactor)1, +0x6a1ebee5), true); \/\/    {NF}and r27, r10, qword ptr [r22+r25*2+0x6a1ebee5]    IID826\n-    __ eorq(r30, r26, Address(r11, r18, (Address::ScaleFactor)2, -0x2b9fff29), false); \/\/    {EVEX}or r30, r26, qword ptr [r11+r18*4-0x2b9fff29]    IID827\n-    __ eorq(r9, r12, Address(r18, r17, (Address::ScaleFactor)0, +0xb4859f6), true); \/\/    {NF}or r9, r12, qword ptr [r18+r17*1+0xb4859f6]    IID828\n-    __ eimulq(rdx, r17, Address(r24, rdx, (Address::ScaleFactor)2, +0x3d284cd8), false); \/\/    {EVEX}imul rdx, r17, qword ptr [r24+rdx*4+0x3d284cd8]    IID829\n-    __ eimulq(r29, r26, Address(r30, r12, (Address::ScaleFactor)1, +0x6e813124), true); \/\/    {NF}imul r29, r26, qword ptr [r30+r12*2+0x6e813124]    IID830\n-    __ esubq(rbx, r13, Address(r22, -0x702a289e), false);                       \/\/    {EVEX}sub rbx, r13, qword ptr [r22-0x702a289e]    IID831\n-    __ esubq(r23, r29, Address(r25, rdx, (Address::ScaleFactor)0, -0x6252a7ed), true); \/\/    {NF}sub r23, r29, qword ptr [r25+rdx*1-0x6252a7ed]    IID832\n-    __ exorq(r8, r18, Address(r19, r14, (Address::ScaleFactor)2, -0xebfa697), false); \/\/    {EVEX}xor r8, r18, qword ptr [r19+r14*4-0xebfa697]    IID833\n-    __ exorq(r10, r28, Address(r26, +0x168381ca), true);                        \/\/    {NF}xor r10, r28, qword ptr [r26+0x168381ca]    IID834\n-    __ eaddq(rcx, r18, r8, false);                                              \/\/    {load}{EVEX}add rcx, r18, r8    IID835\n-    __ eaddq(rcx, rcx, r14, false);                                             \/\/    {load}add rcx, r14    IID836\n-    __ eaddq(r23, r10, r16, true);                                              \/\/    {load}{NF}add r23, r10, r16    IID837\n-    __ eaddq(r11, r11, r24, true);                                              \/\/    {load}{NF}add r11, r11, r24    IID838\n-    __ eadcxq(r9, r18, rdx);                                                    \/\/    {load}{EVEX}adcx r9, r18, rdx    IID839\n-    __ eadcxq(r8, r8, r15);                                                     \/\/    {load}adcx r8, r15    IID840\n-    __ eadoxq(r15, r22, r26);                                                   \/\/    {load}{EVEX}adox r15, r22, r26    IID841\n-    __ eadoxq(r11, r11, rdx);                                                   \/\/    {load}adox r11, rdx    IID842\n-    __ eandq(r19, rdx, r22, false);                                             \/\/    {load}{EVEX}and r19, rdx, r22    IID843\n-    __ eandq(r29, r29, r17, false);                                             \/\/    {load}and r29, r17    IID844\n-    __ eandq(r23, r27, r15, true);                                              \/\/    {load}{NF}and r23, r27, r15    IID845\n-    __ eandq(r9, r9, r13, true);                                                \/\/    {load}{NF}and r9, r9, r13    IID846\n-    __ eimulq(r18, r15, r16, false);                                            \/\/    {load}{EVEX}imul r18, r15, r16    IID847\n-    __ eimulq(rcx, rcx, r17, false);                                            \/\/    {load}imul rcx, r17    IID848\n-    __ eimulq(r23, r12, r20, true);                                             \/\/    {load}{NF}imul r23, r12, r20    IID849\n-    __ eimulq(r10, r10, r9, true);                                              \/\/    {load}{NF}imul r10, r10, r9    IID850\n-    __ eorq(rdx, r19, r14, false);                                              \/\/    {load}{EVEX}or rdx, r19, r14    IID851\n-    __ eorq(rcx, rcx, r13, false);                                              \/\/    {load}or rcx, r13    IID852\n-    __ eorq(r9, r25, r29, true);                                                \/\/    {load}{NF}or r9, r25, r29    IID853\n-    __ eorq(rdx, rdx, r25, true);                                               \/\/    {load}{NF}or rdx, rdx, r25    IID854\n-    __ esubq(r23, r8, r16, false);                                              \/\/    {load}{EVEX}sub r23, r8, r16    IID855\n-    __ esubq(r13, r13, r13, false);                                             \/\/    {load}sub r13, r13    IID856\n-    __ esubq(r19, r12, r15, true);                                              \/\/    {load}{NF}sub r19, r12, r15    IID857\n-    __ esubq(r9, r9, rdx, true);                                                \/\/    {load}{NF}sub r9, r9, rdx    IID858\n-    __ exorq(r13, r16, r31, false);                                             \/\/    {load}{EVEX}xor r13, r16, r31    IID859\n-    __ exorq(r17, r17, r30, false);                                             \/\/    {load}xor r17, r30    IID860\n-    __ exorq(r19, r30, r20, true);                                              \/\/    {load}{NF}xor r19, r30, r20    IID861\n-    __ exorq(r31, r31, r13, true);                                              \/\/    {load}{NF}xor r31, r31, r13    IID862\n-    __ eshldq(r22, r10, r13, 4, false);                                         \/\/    {EVEX}shld r22, r10, r13, 4    IID863\n-    __ eshldq(r24, r24, r21, 16, false);                                        \/\/    shld r24, r21, 16    IID864\n-    __ eshldq(r20, r13, r27, 16, true);                                         \/\/    {NF}shld r20, r13, r27, 16    IID865\n-    __ eshldq(r31, r31, r19, 2, true);                                          \/\/    {NF}shld r31, r31, r19, 2    IID866\n-    __ eshrdq(r30, r20, r11, 8, false);                                         \/\/    {EVEX}shrd r30, r20, r11, 8    IID867\n-    __ eshrdq(rdx, rdx, r15, 1, false);                                         \/\/    shrd rdx, r15, 1    IID868\n-    __ eshrdq(r28, r30, r14, 2, true);                                          \/\/    {NF}shrd r28, r30, r14, 2    IID869\n-    __ eshrdq(r20, r20, r16, 1, true);                                          \/\/    {NF}shrd r20, r20, r16, 1    IID870\n-    __ ecmovq (Assembler::Condition::overflow, r21, r17, r28);                  \/\/    cmovo r21, r17, r28    IID871\n-    __ ecmovq (Assembler::Condition::overflow, r15, r15, r30);                  \/\/    cmovo r15, r30    IID872\n-    __ ecmovq (Assembler::Condition::noOverflow, rcx, r15, r15);                \/\/    cmovno rcx, r15, r15    IID873\n-    __ ecmovq (Assembler::Condition::noOverflow, rcx, rcx, r13);                \/\/    cmovno rcx, r13    IID874\n-    __ ecmovq (Assembler::Condition::below, rdx, r26, r26);                     \/\/    cmovb rdx, r26, r26    IID875\n-    __ ecmovq (Assembler::Condition::below, r28, r28, r15);                     \/\/    cmovb r28, r15    IID876\n-    __ ecmovq (Assembler::Condition::aboveEqual, r8, rdx, rcx);                 \/\/    cmovae r8, rdx, rcx    IID877\n-    __ ecmovq (Assembler::Condition::aboveEqual, rcx, rcx, rcx);                \/\/    cmovae rcx, rcx    IID878\n-    __ ecmovq (Assembler::Condition::zero, r10, r13, r9);                       \/\/    cmovz r10, r13, r9    IID879\n-    __ ecmovq (Assembler::Condition::zero, r14, r14, r27);                      \/\/    cmovz r14, r27    IID880\n-    __ ecmovq (Assembler::Condition::notZero, r11, r23, r9);                    \/\/    cmovnz r11, r23, r9    IID881\n-    __ ecmovq (Assembler::Condition::notZero, r11, r11, rdx);                   \/\/    cmovnz r11, rdx    IID882\n-    __ ecmovq (Assembler::Condition::belowEqual, r31, r14, r25);                \/\/    cmovbe r31, r14, r25    IID883\n-    __ ecmovq (Assembler::Condition::belowEqual, r20, r20, r12);                \/\/    cmovbe r20, r12    IID884\n-    __ ecmovq (Assembler::Condition::above, rdx, r10, r28);                     \/\/    cmova rdx, r10, r28    IID885\n-    __ ecmovq (Assembler::Condition::above, r8, r8, r17);                       \/\/    cmova r8, r17    IID886\n-    __ ecmovq (Assembler::Condition::negative, rcx, r30, r23);                  \/\/    cmovs rcx, r30, r23    IID887\n-    __ ecmovq (Assembler::Condition::negative, r26, r26, r18);                  \/\/    cmovs r26, r18    IID888\n-    __ ecmovq (Assembler::Condition::positive, rdx, rbx, r18);                  \/\/    cmovns rdx, rbx, r18    IID889\n-    __ ecmovq (Assembler::Condition::positive, r21, r21, r13);                  \/\/    cmovns r21, r13    IID890\n-    __ ecmovq (Assembler::Condition::parity, r27, r28, r27);                    \/\/    cmovp r27, r28, r27    IID891\n-    __ ecmovq (Assembler::Condition::parity, r11, r11, r30);                    \/\/    cmovp r11, r30    IID892\n-    __ ecmovq (Assembler::Condition::noParity, rcx, r21, r18);                  \/\/    cmovnp rcx, r21, r18    IID893\n-    __ ecmovq (Assembler::Condition::noParity, rcx, rcx, r29);                  \/\/    cmovnp rcx, r29    IID894\n-    __ ecmovq (Assembler::Condition::less, rdx, r21, r12);                      \/\/    cmovl rdx, r21, r12    IID895\n-    __ ecmovq (Assembler::Condition::less, rdx, rdx, r26);                      \/\/    cmovl rdx, r26    IID896\n-    __ ecmovq (Assembler::Condition::greaterEqual, r17, rbx, r22);              \/\/    cmovge r17, rbx, r22    IID897\n-    __ ecmovq (Assembler::Condition::greaterEqual, rdx, rdx, r11);              \/\/    cmovge rdx, r11    IID898\n-    __ ecmovq (Assembler::Condition::lessEqual, rdx, r14, r8);                  \/\/    cmovle rdx, r14, r8    IID899\n-    __ ecmovq (Assembler::Condition::lessEqual, r14, r14, r8);                  \/\/    cmovle r14, r8    IID900\n-    __ ecmovq (Assembler::Condition::greater, r25, r29, r21);                   \/\/    cmovg r25, r29, r21    IID901\n-    __ ecmovq (Assembler::Condition::greater, r26, r26, r30);                   \/\/    cmovg r26, r30    IID902\n-    __ ecmovq (Assembler::Condition::overflow, r24, r21, Address(r13, r11, (Address::ScaleFactor)1, +0x439c521e)); \/\/    cmovo r24, r21, qword ptr [r13+r11*2+0x439c521e]    IID903\n-    __ ecmovq (Assembler::Condition::noOverflow, r11, r18, Address(r29, r16, (Address::ScaleFactor)0, +0x632127f)); \/\/    cmovno r11, r18, qword ptr [r29+r16*1+0x632127f]    IID904\n-    __ ecmovq (Assembler::Condition::below, r16, r8, Address(r8, r26, (Address::ScaleFactor)1, +0x10633def)); \/\/    cmovb r16, r8, qword ptr [r8+r26*2+0x10633def]    IID905\n-    __ ecmovq (Assembler::Condition::aboveEqual, r13, r14, Address(r18, -0x54f69e38)); \/\/    cmovae r13, r14, qword ptr [r18-0x54f69e38]    IID906\n-    __ ecmovq (Assembler::Condition::zero, r12, r8, Address(r31, r26, (Address::ScaleFactor)1, -0x7a1e447a)); \/\/    cmovz r12, r8, qword ptr [r31+r26*2-0x7a1e447a]    IID907\n-    __ ecmovq (Assembler::Condition::notZero, r29, r29, Address(r19, r11, (Address::ScaleFactor)2, -0x35d82dd2)); \/\/    cmovnz r29, qword ptr [r19+r11*4-0x35d82dd2]    IID908\n-    __ ecmovq (Assembler::Condition::belowEqual, rcx, r18, Address(r25, r28, (Address::ScaleFactor)0, +0x30be64a0)); \/\/    cmovbe rcx, r18, qword ptr [r25+r28*1+0x30be64a0]    IID909\n-    __ ecmovq (Assembler::Condition::above, r28, r12, Address(r10, r16, (Address::ScaleFactor)1, -0x22b8fefa)); \/\/    cmova r28, r12, qword ptr [r10+r16*2-0x22b8fefa]    IID910\n-    __ ecmovq (Assembler::Condition::negative, r11, r8, Address(rbx, r11, (Address::ScaleFactor)3, +0x25cc9e96)); \/\/    cmovs r11, r8, qword ptr [rbx+r11*8+0x25cc9e96]    IID911\n-    __ ecmovq (Assembler::Condition::positive, r12, r27, Address(r11, -0xc2d70fe)); \/\/    cmovns r12, r27, qword ptr [r11-0xc2d70fe]    IID912\n-    __ ecmovq (Assembler::Condition::parity, r8, r26, Address(r19, rbx, (Address::ScaleFactor)1, -0x486db7ea)); \/\/    cmovp r8, r26, qword ptr [r19+rbx*2-0x486db7ea]    IID913\n-    __ ecmovq (Assembler::Condition::noParity, r30, r10, Address(r14, r18, (Address::ScaleFactor)3, +0x14884884)); \/\/    cmovnp r30, r10, qword ptr [r14+r18*8+0x14884884]    IID914\n-    __ ecmovq (Assembler::Condition::less, r27, r8, Address(r29, r14, (Address::ScaleFactor)2, +0x92b7a8)); \/\/    cmovl r27, r8, qword ptr [r29+r14*4+0x92b7a8]    IID915\n-    __ ecmovq (Assembler::Condition::greaterEqual, r14, r28, Address(r19, rdx, (Address::ScaleFactor)0, +0x9c2d45)); \/\/    cmovge r14, r28, qword ptr [r19+rdx*1+0x9c2d45]    IID916\n-    __ ecmovq (Assembler::Condition::lessEqual, r25, r8, Address(rcx, r18, (Address::ScaleFactor)2, +0x6655c86b)); \/\/    cmovle r25, r8, qword ptr [rcx+r18*4+0x6655c86b]    IID917\n-    __ ecmovq (Assembler::Condition::greater, r19, r21, Address(r10, r25, (Address::ScaleFactor)0, -0x1005430b)); \/\/    cmovg r19, r21, qword ptr [r10+r25*1-0x1005430b]    IID918\n+    __ adcq(r30, r31);                                                          \/\/    {load}adc r30, r31    IID528\n+    __ cmpq(r12, rdx);                                                          \/\/    {load}cmp r12, rdx    IID529\n+    __ imulq(r21, r24);                                                         \/\/    {load}imul r21, r24    IID530\n+    __ popcntq(r9, r25);                                                        \/\/    {load}popcnt r9, r25    IID531\n+    __ sbbq(r8, r12);                                                           \/\/    {load}sbb r8, r12    IID532\n+    __ subq(r31, r24);                                                          \/\/    {load}sub r31, r24    IID533\n+    __ tzcntq(r10, r16);                                                        \/\/    {load}tzcnt r10, r16    IID534\n+    __ lzcntq(r20, r21);                                                        \/\/    {load}lzcnt r20, r21    IID535\n+    __ addq(rdx, r17);                                                          \/\/    {load}add rdx, r17    IID536\n+    __ andq(r14, r13);                                                          \/\/    {load}and r14, r13    IID537\n+    __ orq(r20, r24);                                                           \/\/    {load}or r20, r24    IID538\n+    __ xorq(r21, r22);                                                          \/\/    {load}xor r21, r22    IID539\n+    __ movq(r12, r27);                                                          \/\/    {load}mov r12, r27    IID540\n+    __ bsfq(r23, rdx);                                                          \/\/    {load}bsf r23, rdx    IID541\n+    __ bsrq(r31, r28);                                                          \/\/    {load}bsr r31, r28    IID542\n+    __ btq(r8, r25);                                                            \/\/    {load}bt r8, r25    IID543\n+    __ xchgq(r21, rbx);                                                         \/\/    {load}xchg r21, rbx    IID544\n+    __ testq(r23, r23);                                                         \/\/    {load}test r23, r23    IID545\n+    __ addq(Address(r19, -0x180d3ea1), r10);                                    \/\/    add qword ptr [r19-0x180d3ea1], r10    IID546\n+    __ andq(Address(r11, r17, (Address::ScaleFactor)1, -0x78976be8), r25);      \/\/    and qword ptr [r11+r17*2-0x78976be8], r25    IID547\n+    __ cmpq(Address(rbx, r28, (Address::ScaleFactor)3, +0x35f72102), r13);      \/\/    cmp qword ptr [rbx+r28*8+0x35f72102], r13    IID548\n+    __ orq(Address(r8, -0x34465011), r21);                                      \/\/    or qword ptr [r8-0x34465011], r21    IID549\n+    __ xorq(Address(r19, -0x404b22dd), r18);                                    \/\/    xor qword ptr [r19-0x404b22dd], r18    IID550\n+    __ subq(Address(r23, r27, (Address::ScaleFactor)3, -0x428d2646), r14);      \/\/    sub qword ptr [r23+r27*8-0x428d2646], r14    IID551\n+    __ movq(Address(r9, rcx, (Address::ScaleFactor)2, -0x72611661), r28);       \/\/    mov qword ptr [r9+rcx*4-0x72611661], r28    IID552\n+    __ xaddq(Address(r24, r21, (Address::ScaleFactor)2, +0x3a6be990), rbx);     \/\/    xadd qword ptr [r24+r21*4+0x3a6be990], rbx    IID553\n+    __ andq(Address(r22, r10, (Address::ScaleFactor)0, +0x7ef8bdd), 1048576);   \/\/    and qword ptr [r22+r10*1+0x7ef8bdd], 1048576    IID554\n+    __ addq(Address(r13, r28, (Address::ScaleFactor)0, -0x754789b1), 65536);    \/\/    add qword ptr [r13+r28*1-0x754789b1], 65536    IID555\n+    __ cmpq(Address(r10, -0xbd2a8da), 268435456);                               \/\/    cmp qword ptr [r10-0xbd2a8da], 268435456    IID556\n+    __ sarq(Address(r23, r14, (Address::ScaleFactor)1, +0x6a16d9f5), 4);        \/\/    sar qword ptr [r23+r14*2+0x6a16d9f5], 4    IID557\n+    __ salq(Address(rcx, r21, (Address::ScaleFactor)1, +0x5f66ac1e), 8);        \/\/    sal qword ptr [rcx+r21*2+0x5f66ac1e], 8    IID558\n+    __ sbbq(Address(rcx, r22, (Address::ScaleFactor)3, -0x48c954c), 268435456); \/\/    sbb qword ptr [rcx+r22*8-0x48c954c], 268435456    IID559\n+    __ shrq(Address(r21, r30, (Address::ScaleFactor)0, +0xe405b0b), 8);         \/\/    shr qword ptr [r21+r30*1+0xe405b0b], 8    IID560\n+    __ subq(Address(r19, r29, (Address::ScaleFactor)3, -0x7762044b), 4096);     \/\/    sub qword ptr [r19+r29*8-0x7762044b], 4096    IID561\n+    __ xorq(Address(r30, r10, (Address::ScaleFactor)1, -0x19798323), 16);       \/\/    xor qword ptr [r30+r10*2-0x19798323], 16    IID562\n+    __ orq(Address(rdx, r24, (Address::ScaleFactor)3, +0x18d9b316), 4096);      \/\/    or qword ptr [rdx+r24*8+0x18d9b316], 4096    IID563\n+    __ movq(Address(rbx, -0x3058074d), 256);                                    \/\/    mov qword ptr [rbx-0x3058074d], 256    IID564\n+    __ testq(Address(r28, r21, (Address::ScaleFactor)3, +0x65a0fdc4), -268435456); \/\/    test qword ptr [r28+r21*8+0x65a0fdc4], -268435456    IID565\n+    __ addq(r23, Address(r11, r18, (Address::ScaleFactor)0, -0x1d1af10c));      \/\/    add r23, qword ptr [r11+r18*1-0x1d1af10c]    IID566\n+    __ andq(r22, Address(r18, r12, (Address::ScaleFactor)1, +0x1a5f1c38));      \/\/    and r22, qword ptr [r18+r12*2+0x1a5f1c38]    IID567\n+    __ cmpq(r23, Address(r30, r19, (Address::ScaleFactor)0, -0x3e912f7f));      \/\/    cmp r23, qword ptr [r30+r19*1-0x3e912f7f]    IID568\n+    __ lzcntq(r29, Address(rcx, +0x12e3fbe4));                                  \/\/    lzcnt r29, qword ptr [rcx+0x12e3fbe4]    IID569\n+    __ orq(r14, Address(r21, r21, (Address::ScaleFactor)2, +0xd73042));         \/\/    or r14, qword ptr [r21+r21*4+0xd73042]    IID570\n+    __ adcq(r31, Address(r17, r31, (Address::ScaleFactor)2, +0xabde912));       \/\/    adc r31, qword ptr [r17+r31*4+0xabde912]    IID571\n+    __ imulq(r20, Address(r13, r27, (Address::ScaleFactor)0, -0x58dbfc1f));     \/\/    imul r20, qword ptr [r13+r27*1-0x58dbfc1f]    IID572\n+    __ popcntq(rbx, Address(r22, -0x72c66c23));                                 \/\/    popcnt rbx, qword ptr [r22-0x72c66c23]    IID573\n+    __ sbbq(r26, Address(r9, +0x334aba09));                                     \/\/    sbb r26, qword ptr [r9+0x334aba09]    IID574\n+    __ subq(r9, Address(r9, r30, (Address::ScaleFactor)3, -0x219a6102));        \/\/    sub r9, qword ptr [r9+r30*8-0x219a6102]    IID575\n+    __ tzcntq(r25, Address(r20, -0x2131bab1));                                  \/\/    tzcnt r25, qword ptr [r20-0x2131bab1]    IID576\n+    __ xorq(r16, Address(r28, r16, (Address::ScaleFactor)1, +0x48c483b9));      \/\/    xor r16, qword ptr [r28+r16*2+0x48c483b9]    IID577\n+    __ movq(r30, Address(r9, r16, (Address::ScaleFactor)0, -0x88ce84f));        \/\/    mov r30, qword ptr [r9+r16*1-0x88ce84f]    IID578\n+    __ leaq(r11, Address(r30, r29, (Address::ScaleFactor)2, +0x3eeb8fd0));      \/\/    lea r11, qword ptr [r30+r29*4+0x3eeb8fd0]    IID579\n+    __ cvttsd2siq(r26, Address(r29, r10, (Address::ScaleFactor)3, +0x3ef4822e)); \/\/    cvttsd2si r26, qword ptr [r29+r10*8+0x3ef4822e]    IID580\n+    __ xchgq(r29, Address(r19, r20, (Address::ScaleFactor)2, -0x3f0f3db9));     \/\/    xchg r29, qword ptr [r19+r20*4-0x3f0f3db9]    IID581\n+    __ testq(r8, Address(r30, r20, (Address::ScaleFactor)0, +0x15b56a17));      \/\/    test r8, qword ptr [r30+r20*1+0x15b56a17]    IID582\n+    __ addq(r26, 4096);                                                         \/\/    add r26, 4096    IID583\n+    __ andq(r20, 16);                                                           \/\/    and r20, 16    IID584\n+    __ adcq(r23, 1048576);                                                      \/\/    adc r23, 1048576    IID585\n+    __ cmpq(r12, 4096);                                                         \/\/    cmp r12, 4096    IID586\n+    __ rclq(rcx, 4);                                                            \/\/    rcl rcx, 4    IID587\n+    __ rcrq(r14, 1);                                                            \/\/    rcr r14, 1    IID588\n+    __ rolq(r23, 2);                                                            \/\/    rol r23, 2    IID589\n+    __ rorq(r12, 4);                                                            \/\/    ror r12, 4    IID590\n+    __ sarq(r10, 4);                                                            \/\/    sar r10, 4    IID591\n+    __ salq(r20, 4);                                                            \/\/    sal r20, 4    IID592\n+    __ sbbq(rcx, 1048576);                                                      \/\/    sbb rcx, 1048576    IID593\n+    __ shlq(r23, 16);                                                           \/\/    shl r23, 16    IID594\n+    __ shrq(r27, 2);                                                            \/\/    shr r27, 2    IID595\n+    __ subq(rcx, 65536);                                                        \/\/    sub rcx, 65536    IID596\n+    __ xorq(r9, 1048576);                                                       \/\/    xor r9, 1048576    IID597\n+    __ movq(r16, 65536);                                                        \/\/    mov r16, 65536    IID598\n+    __ mov64(r24, 4503599627370496);                                            \/\/    mov r24, 4503599627370496    IID599\n+    __ btq(r18, 64);                                                            \/\/    bt r18, 64    IID600\n+    __ testq(r29, -4096);                                                       \/\/    test r29, -4096    IID601\n+    __ orq_imm32(r30, 67108864);                                                \/\/    or r30, 67108864    IID602\n+    __ subq_imm32(r25, 268435456);                                              \/\/    sub r25, 268435456    IID603\n+    __ cmovq(Assembler::Condition::overflow, r30, Address(r17, r31, (Address::ScaleFactor)2, +0x47ff92f0)); \/\/    cmovo r30, qword ptr [r17+r31*4+0x47ff92f0]    IID604\n+    __ cmovq(Assembler::Condition::noOverflow, r9, Address(r24, r28, (Address::ScaleFactor)1, +0x384904c0)); \/\/    cmovno r9, qword ptr [r24+r28*2+0x384904c0]    IID605\n+    __ cmovq(Assembler::Condition::below, r23, Address(r23, r24, (Address::ScaleFactor)3, -0x197f1266)); \/\/    cmovb r23, qword ptr [r23+r24*8-0x197f1266]    IID606\n+    __ cmovq(Assembler::Condition::aboveEqual, r9, Address(r29, r30, (Address::ScaleFactor)0, +0x2b5d49c8)); \/\/    cmovae r9, qword ptr [r29+r30*1+0x2b5d49c8]    IID607\n+    __ cmovq(Assembler::Condition::zero, r16, Address(rbx, r15, (Address::ScaleFactor)1, +0x22379381)); \/\/    cmovz r16, qword ptr [rbx+r15*2+0x22379381]    IID608\n+    __ cmovq(Assembler::Condition::notZero, r8, Address(r11, +0x49d67a0));      \/\/    cmovnz r8, qword ptr [r11+0x49d67a0]    IID609\n+    __ cmovq(Assembler::Condition::belowEqual, r28, Address(r16, r16, (Address::ScaleFactor)2, -0x5e941da9)); \/\/    cmovbe r28, qword ptr [r16+r16*4-0x5e941da9]    IID610\n+    __ cmovq(Assembler::Condition::above, r19, Address(r18, r8, (Address::ScaleFactor)0, -0xa5e55ec)); \/\/    cmova r19, qword ptr [r18+r8*1-0xa5e55ec]    IID611\n+    __ cmovq(Assembler::Condition::negative, r28, Address(r17, r28, (Address::ScaleFactor)1, -0x3264220c)); \/\/    cmovs r28, qword ptr [r17+r28*2-0x3264220c]    IID612\n+    __ cmovq(Assembler::Condition::positive, r31, Address(r14, r31, (Address::ScaleFactor)1, +0x5001bc5a)); \/\/    cmovns r31, qword ptr [r14+r31*2+0x5001bc5a]    IID613\n+    __ cmovq(Assembler::Condition::parity, rbx, Address(r18, r17, (Address::ScaleFactor)2, -0x286f2379)); \/\/    cmovp rbx, qword ptr [r18+r17*4-0x286f2379]    IID614\n+    __ cmovq(Assembler::Condition::noParity, r17, Address(r20, -0x5549f838));   \/\/    cmovnp r17, qword ptr [r20-0x5549f838]    IID615\n+    __ cmovq(Assembler::Condition::less, r30, Address(r9, r28, (Address::ScaleFactor)1, -0x25b00cf3)); \/\/    cmovl r30, qword ptr [r9+r28*2-0x25b00cf3]    IID616\n+    __ cmovq(Assembler::Condition::greaterEqual, r19, Address(r9, -0x2aabf22c)); \/\/    cmovge r19, qword ptr [r9-0x2aabf22c]    IID617\n+    __ cmovq(Assembler::Condition::lessEqual, rbx, Address(rcx, r12, (Address::ScaleFactor)1, -0x432d68cc)); \/\/    cmovle rbx, qword ptr [rcx+r12*2-0x432d68cc]    IID618\n+    __ cmovq(Assembler::Condition::greater, rbx, Address(r15, r17, (Address::ScaleFactor)3, -0x2b97565e)); \/\/    cmovg rbx, qword ptr [r15+r17*8-0x2b97565e]    IID619\n+    __ call(r24);                                                               \/\/    call r24    IID620\n+    __ divq(r9);                                                                \/\/    div r9    IID621\n+    __ idivq(r28);                                                              \/\/    idiv r28    IID622\n+    __ imulq(rdx);                                                              \/\/    imul rdx    IID623\n+    __ mulq(r31);                                                               \/\/    mul r31    IID624\n+    __ negq(r12);                                                               \/\/    neg r12    IID625\n+    __ notq(r12);                                                               \/\/    not r12    IID626\n+    __ rolq(r24);                                                               \/\/    rol r24, cl    IID627\n+    __ rorq(r28);                                                               \/\/    ror r28, cl    IID628\n+    __ sarq(r11);                                                               \/\/    sar r11, cl    IID629\n+    __ salq(r27);                                                               \/\/    sal r27, cl    IID630\n+    __ shlq(r23);                                                               \/\/    shl r23, cl    IID631\n+    __ shrq(r17);                                                               \/\/    shr r17, cl    IID632\n+    __ incrementq(r16);                                                         \/\/    inc r16    IID633\n+    __ decrementq(r12);                                                         \/\/    dec r12    IID634\n+    __ pushp(r23);                                                              \/\/    pushp r23    IID635\n+    __ popp(r24);                                                               \/\/    popp r24    IID636\n+    __ call(Address(r18, r14, (Address::ScaleFactor)0, -0x66639d32));           \/\/    call qword ptr [r18+r14*1-0x66639d32]    IID637\n+    __ mulq(Address(r24, -0x660a2421));                                         \/\/    mul qword ptr [r24-0x660a2421]    IID638\n+    __ negq(Address(r14, r18, (Address::ScaleFactor)0, +0x40f3936e));           \/\/    neg qword ptr [r14+r18*1+0x40f3936e]    IID639\n+    __ sarq(Address(r10, r13, (Address::ScaleFactor)0, +0x7d04cb72));           \/\/    sar qword ptr [r10+r13*1+0x7d04cb72], cl    IID640\n+    __ salq(Address(r18, r11, (Address::ScaleFactor)3, -0x2176b4dc));           \/\/    sal qword ptr [r18+r11*8-0x2176b4dc], cl    IID641\n+    __ shrq(Address(r13, rcx, (Address::ScaleFactor)1, +0x7996aa80));           \/\/    shr qword ptr [r13+rcx*2+0x7996aa80], cl    IID642\n+    __ incrementq(Address(r14, +0x67c2d02a));                                   \/\/    inc qword ptr [r14+0x67c2d02a]    IID643\n+    __ decrementq(Address(r22, r26, (Address::ScaleFactor)0, +0x224f62c0));     \/\/    dec qword ptr [r22+r26*1+0x224f62c0]    IID644\n+    __ imulq(rdx, Address(r31, rbx, (Address::ScaleFactor)1, +0x2b00bb10), 16777216); \/\/    imul rdx, qword ptr [r31+rbx*2+0x2b00bb10], 16777216    IID645\n+    __ imulq(r21, r31, 4096);                                                   \/\/    imul r21, r31, 4096    IID646\n+    __ shldq(rbx, r19, 1);                                                      \/\/    shld rbx, r19, 1    IID647\n+    __ shrdq(r11, r23, 4);                                                      \/\/    shrd r11, r23, 4    IID648\n+    __ pop2(r16, r30);                                                          \/\/    {load}pop2 r30, r16    IID649\n+    __ pop2p(r17, rbx);                                                         \/\/    {load}pop2p rbx, r17    IID650\n+    __ push2(r20, r30);                                                         \/\/    {load}push2 r30, r20    IID651\n+    __ push2p(r8, r31);                                                         \/\/    {load}push2p r31, r8    IID652\n+    __ movzbq(r28, Address(r8, r14, (Address::ScaleFactor)0, +0x469ae67a));     \/\/    movzx r28, byte ptr [r8+r14*1+0x469ae67a]    IID653\n+    __ movzwq(r14, Address(r8, r18, (Address::ScaleFactor)2, -0x48699e02));     \/\/    movzx r14, word ptr [r8+r18*4-0x48699e02]    IID654\n+    __ movsbq(r21, Address(rbx, -0x64dae06b));                                  \/\/    movsx r21, byte ptr [rbx-0x64dae06b]    IID655\n+    __ movswq(r19, Address(r31, rbx, (Address::ScaleFactor)2, +0x60318819));    \/\/    movsx r19, word ptr [r31+rbx*4+0x60318819]    IID656\n+    __ movzbq(r30, r13);                                                        \/\/    movzx r30, r13b    IID657\n+    __ movzwq(r30, r18);                                                        \/\/    movzx r30, r18w    IID658\n+    __ movsbq(r19, r15);                                                        \/\/    movsx r19, r15b    IID659\n+    __ movswq(r20, r16);                                                        \/\/    movsx r20, r16w    IID660\n+    __ cmpxchgq(r28, Address(r11, rbx, (Address::ScaleFactor)3, +0xfc3479d));   \/\/    cmpxchg qword ptr [r11+rbx*8+0xfc3479d], r28    IID661\n+    __ eidivq(r20, false);                                                      \/\/    {EVEX}idiv r20    IID662\n+    __ eidivq(r30, true);                                                       \/\/    {NF}idiv r30    IID663\n+    __ edivq(r22, false);                                                       \/\/    {EVEX}div r22    IID664\n+    __ edivq(r11, true);                                                        \/\/    {NF}div r11    IID665\n+    __ eimulq(rcx, false);                                                      \/\/    {EVEX}imul rcx    IID666\n+    __ eimulq(r28, true);                                                       \/\/    {NF}imul r28    IID667\n+    __ emulq(r21, false);                                                       \/\/    {EVEX}mul r21    IID668\n+    __ emulq(r13, true);                                                        \/\/    {NF}mul r13    IID669\n+    __ emulq(Address(r26, r15, (Address::ScaleFactor)2, +0x70a1ce6e), false);   \/\/    {EVEX}mul qword ptr [r26+r15*4+0x70a1ce6e]    IID670\n+    __ emulq(Address(r24, r19, (Address::ScaleFactor)1, -0x1670855c), true);    \/\/    {NF}mul qword ptr [r24+r19*2-0x1670855c]    IID671\n+    __ eimulq(r10, r27, false);                                                 \/\/    {EVEX}imul r10, r27    IID672\n+    __ eimulq(r17, r17, false);                                                 \/\/    imul r17    IID673\n+    __ eimulq(rdx, r22, true);                                                  \/\/    {NF}imul rdx, r22    IID674\n+    __ eimulq(rbx, rbx, true);                                                  \/\/    {NF}imul rbx, rbx    IID675\n+    __ elzcntq(r28, r15, false);                                                \/\/    {EVEX}lzcnt r28, r15    IID676\n+    __ elzcntq(r15, r15, false);                                                \/\/    {EVEX}lzcnt r15, r15    IID677\n+    __ elzcntq(rbx, r12, true);                                                 \/\/    {NF}lzcnt rbx, r12    IID678\n+    __ elzcntq(rbx, rbx, true);                                                 \/\/    {NF}lzcnt rbx, rbx    IID679\n+    __ enegq(r26, r11, false);                                                  \/\/    {EVEX}neg r26, r11    IID680\n+    __ enegq(r17, r17, false);                                                  \/\/    neg r17    IID681\n+    __ enegq(rdx, r31, true);                                                   \/\/    {NF}neg rdx, r31    IID682\n+    __ enegq(r27, r27, true);                                                   \/\/    {NF}neg r27, r27    IID683\n+    __ enotq(r31, r15);                                                         \/\/    {EVEX}not r31, r15    IID684\n+    __ enotq(r21, r21);                                                         \/\/    not r21    IID685\n+    __ epopcntq(rbx, r24, false);                                               \/\/    {EVEX}popcnt rbx, r24    IID686\n+    __ epopcntq(r28, r28, false);                                               \/\/    {EVEX}popcnt r28, r28    IID687\n+    __ epopcntq(r23, r27, true);                                                \/\/    {NF}popcnt r23, r27    IID688\n+    __ epopcntq(r13, r13, true);                                                \/\/    {NF}popcnt r13, r13    IID689\n+    __ erolq(r25, r28, false);                                                  \/\/    {EVEX}rol r25, r28, cl    IID690\n+    __ erolq(r31, r31, false);                                                  \/\/    rol r31, cl    IID691\n+    __ erolq(r25, r23, true);                                                   \/\/    {NF}rol r25, r23, cl    IID692\n+    __ erolq(rcx, rcx, true);                                                   \/\/    {NF}rol rcx, rcx, cl    IID693\n+    __ erorq(r22, r14, false);                                                  \/\/    {EVEX}ror r22, r14, cl    IID694\n+    __ erorq(r15, r15, false);                                                  \/\/    ror r15, cl    IID695\n+    __ erorq(r11, r30, true);                                                   \/\/    {NF}ror r11, r30, cl    IID696\n+    __ erorq(r24, r24, true);                                                   \/\/    {NF}ror r24, r24, cl    IID697\n+    __ esalq(r10, r20, false);                                                  \/\/    {EVEX}sal r10, r20, cl    IID698\n+    __ esalq(r19, r19, false);                                                  \/\/    sal r19, cl    IID699\n+    __ esalq(r17, r25, true);                                                   \/\/    {NF}sal r17, r25, cl    IID700\n+    __ esalq(r13, r13, true);                                                   \/\/    {NF}sal r13, r13, cl    IID701\n+    __ esarq(r31, r30, false);                                                  \/\/    {EVEX}sar r31, r30, cl    IID702\n+    __ esarq(r18, r18, false);                                                  \/\/    sar r18, cl    IID703\n+    __ esarq(r25, r25, true);                                                   \/\/    {NF}sar r25, r25, cl    IID704\n+    __ esarq(r28, r28, true);                                                   \/\/    {NF}sar r28, r28, cl    IID705\n+    __ edecq(r22, r27, false);                                                  \/\/    {EVEX}dec r22, r27    IID706\n+    __ edecq(r12, r12, false);                                                  \/\/    dec r12    IID707\n+    __ edecq(r18, r11, true);                                                   \/\/    {NF}dec r18, r11    IID708\n+    __ edecq(r10, r10, true);                                                   \/\/    {NF}dec r10, r10    IID709\n+    __ eincq(r20, r24, false);                                                  \/\/    {EVEX}inc r20, r24    IID710\n+    __ eincq(r18, r18, false);                                                  \/\/    inc r18    IID711\n+    __ eincq(rbx, r11, true);                                                   \/\/    {NF}inc rbx, r11    IID712\n+    __ eincq(r26, r26, true);                                                   \/\/    {NF}inc r26, r26    IID713\n+    __ eshlq(r21, r8, false);                                                   \/\/    {EVEX}shl r21, r8, cl    IID714\n+    __ eshlq(rbx, rbx, false);                                                  \/\/    shl rbx, cl    IID715\n+    __ eshlq(r22, r21, true);                                                   \/\/    {NF}shl r22, r21, cl    IID716\n+    __ eshlq(r27, r27, true);                                                   \/\/    {NF}shl r27, r27, cl    IID717\n+    __ eshrq(r12, r16, false);                                                  \/\/    {EVEX}shr r12, r16, cl    IID718\n+    __ eshrq(r8, r8, false);                                                    \/\/    shr r8, cl    IID719\n+    __ eshrq(rdx, r9, true);                                                    \/\/    {NF}shr rdx, r9, cl    IID720\n+    __ eshrq(r20, r20, true);                                                   \/\/    {NF}shr r20, r20, cl    IID721\n+    __ etzcntq(r31, r21, false);                                                \/\/    {EVEX}tzcnt r31, r21    IID722\n+    __ etzcntq(r20, r20, false);                                                \/\/    {EVEX}tzcnt r20, r20    IID723\n+    __ etzcntq(rcx, r16, true);                                                 \/\/    {NF}tzcnt rcx, r16    IID724\n+    __ etzcntq(r14, r14, true);                                                 \/\/    {NF}tzcnt r14, r14    IID725\n+    __ eimulq(r27, Address(r25, r9, (Address::ScaleFactor)1, +0x445a2393), false); \/\/    {EVEX}imul r27, qword ptr [r25+r9*2+0x445a2393]    IID726\n+    __ eimulq(r23, Address(rcx, r9, (Address::ScaleFactor)1, -0x1480ef0c), true); \/\/    {NF}imul r23, qword ptr [rcx+r9*2-0x1480ef0c]    IID727\n+    __ elzcntq(r13, Address(r22, r17, (Address::ScaleFactor)1, -0x750c1996), false); \/\/    {EVEX}lzcnt r13, qword ptr [r22+r17*2-0x750c1996]    IID728\n+    __ elzcntq(r13, Address(r31, -0x342b6259), true);                           \/\/    {NF}lzcnt r13, qword ptr [r31-0x342b6259]    IID729\n+    __ enegq(r31, Address(r24, r13, (Address::ScaleFactor)1, -0x25b16a0e), false); \/\/    {EVEX}neg r31, qword ptr [r24+r13*2-0x25b16a0e]    IID730\n+    __ enegq(r13, Address(r11, r28, (Address::ScaleFactor)3, +0x5c0013ab), true); \/\/    {NF}neg r13, qword ptr [r11+r28*8+0x5c0013ab]    IID731\n+    __ epopcntq(rdx, Address(r18, rcx, (Address::ScaleFactor)2, -0x6113eaaf), false); \/\/    {EVEX}popcnt rdx, qword ptr [r18+rcx*4-0x6113eaaf]    IID732\n+    __ epopcntq(r9, Address(r10, -0x5ca7d588), true);                           \/\/    {NF}popcnt r9, qword ptr [r10-0x5ca7d588]    IID733\n+    __ esalq(r17, Address(r27, r30, (Address::ScaleFactor)0, +0x1b4cda2c), false); \/\/    {EVEX}sal r17, qword ptr [r27+r30*1+0x1b4cda2c], cl    IID734\n+    __ esalq(r25, Address(r12, rdx, (Address::ScaleFactor)1, +0x62823bce), true); \/\/    {NF}sal r25, qword ptr [r12+rdx*2+0x62823bce], cl    IID735\n+    __ esarq(r9, Address(r10, r18, (Address::ScaleFactor)2, -0x264a7a48), false); \/\/    {EVEX}sar r9, qword ptr [r10+r18*4-0x264a7a48], cl    IID736\n+    __ esarq(rbx, Address(r14, r27, (Address::ScaleFactor)0, +0x20291e00), true); \/\/    {NF}sar rbx, qword ptr [r14+r27*1+0x20291e00], cl    IID737\n+    __ edecq(r12, Address(r15, r14, (Address::ScaleFactor)2, -0x20f7dabb), false); \/\/    {EVEX}dec r12, qword ptr [r15+r14*4-0x20f7dabb]    IID738\n+    __ edecq(r9, Address(r10, r25, (Address::ScaleFactor)1, +0x21411d84), true); \/\/    {NF}dec r9, qword ptr [r10+r25*2+0x21411d84]    IID739\n+    __ eincq(r20, Address(rbx, r25, (Address::ScaleFactor)3, +0x2f0329e), false); \/\/    {EVEX}inc r20, qword ptr [rbx+r25*8+0x2f0329e]    IID740\n+    __ eincq(r10, Address(r12, r31, (Address::ScaleFactor)0, -0x37505c8c), true); \/\/    {NF}inc r10, qword ptr [r12+r31*1-0x37505c8c]    IID741\n+    __ eshrq(r24, Address(r23, r14, (Address::ScaleFactor)3, -0x71e75ab0), false); \/\/    {EVEX}shr r24, qword ptr [r23+r14*8-0x71e75ab0], cl    IID742\n+    __ eshrq(r25, Address(r19, r10, (Address::ScaleFactor)1, +0x507b0a88), true); \/\/    {NF}shr r25, qword ptr [r19+r10*2+0x507b0a88], cl    IID743\n+    __ etzcntq(r31, Address(rbx, r16, (Address::ScaleFactor)0, +0x19d5192a), false); \/\/    {EVEX}tzcnt r31, qword ptr [rbx+r16*1+0x19d5192a]    IID744\n+    __ etzcntq(r9, Address(r22, r28, (Address::ScaleFactor)2, +0x211007cd), true); \/\/    {NF}tzcnt r9, qword ptr [r22+r28*4+0x211007cd]    IID745\n+    __ eaddq(r16, Address(r21, rbx, (Address::ScaleFactor)3, -0x823fa1e), r28, false); \/\/    {EVEX}add r16, qword ptr [r21+rbx*8-0x823fa1e], r28    IID746\n+    __ eaddq(r15, Address(rdx, r8, (Address::ScaleFactor)3, -0x34b9a058), r15, false); \/\/    add r15, qword ptr [rdx+r8*8-0x34b9a058]    IID747\n+    __ eaddq(r24, Address(r14, r24, (Address::ScaleFactor)3, +0x6cdc59d2), r13, true); \/\/    {NF}add r24, qword ptr [r14+r24*8+0x6cdc59d2], r13    IID748\n+    __ eaddq(rbx, Address(r27, r14, (Address::ScaleFactor)3, +0x36c5e8de), rbx, true); \/\/    {NF}add rbx, qword ptr [r27+r14*8+0x36c5e8de], rbx    IID749\n+    __ eandq(r21, Address(r27, r27, (Address::ScaleFactor)1, -0x2c023b13), r27, false); \/\/    {EVEX}and r21, qword ptr [r27+r27*2-0x2c023b13], r27    IID750\n+    __ eandq(r31, Address(r21, r15, (Address::ScaleFactor)2, +0x6ef2c74a), r31, false); \/\/    and r31, qword ptr [r21+r15*4+0x6ef2c74a]    IID751\n+    __ eandq(r13, Address(r31, r25, (Address::ScaleFactor)1, +0x734fe9ab), r27, true); \/\/    {NF}and r13, qword ptr [r31+r25*2+0x734fe9ab], r27    IID752\n+    __ eandq(r15, Address(r14, r29, (Address::ScaleFactor)3, -0x6e68556), r15, true); \/\/    {NF}and r15, qword ptr [r14+r29*8-0x6e68556], r15    IID753\n+    __ eorq(r12, Address(r30, r15, (Address::ScaleFactor)3, +0x3ba33f9e), r28, false); \/\/    {EVEX}or r12, qword ptr [r30+r15*8+0x3ba33f9e], r28    IID754\n+    __ eorq(r16, Address(r12, r9, (Address::ScaleFactor)0, -0x28e03b33), r16, false); \/\/    or r16, qword ptr [r12+r9*1-0x28e03b33]    IID755\n+    __ eorq(r8, Address(r8, r25, (Address::ScaleFactor)3, -0x1e42bd95), r27, true); \/\/    {NF}or r8, qword ptr [r8+r25*8-0x1e42bd95], r27    IID756\n+    __ eorq(rcx, Address(r27, rbx, (Address::ScaleFactor)2, +0x7be4bcad), rcx, true); \/\/    {NF}or rcx, qword ptr [r27+rbx*4+0x7be4bcad], rcx    IID757\n+    __ esubq(r24, Address(r23, r22, (Address::ScaleFactor)2, +0x6f8827d7), rdx, false); \/\/    {EVEX}sub r24, qword ptr [r23+r22*4+0x6f8827d7], rdx    IID758\n+    __ esubq(r21, Address(r10, -0x635b8c8), r21, false);                        \/\/    {EVEX}sub r21, qword ptr [r10-0x635b8c8], r21    IID759\n+    __ esubq(r23, Address(r27, r26, (Address::ScaleFactor)3, +0x922bcc0), rbx, true); \/\/    {NF}sub r23, qword ptr [r27+r26*8+0x922bcc0], rbx    IID760\n+    __ esubq(r25, Address(r23, r15, (Address::ScaleFactor)0, -0x38f494ac), r25, true); \/\/    {NF}sub r25, qword ptr [r23+r15*1-0x38f494ac], r25    IID761\n+    __ exorq(r11, Address(r12, r19, (Address::ScaleFactor)2, -0x5b71ec17), rcx, false); \/\/    {EVEX}xor r11, qword ptr [r12+r19*4-0x5b71ec17], rcx    IID762\n+    __ exorq(r28, Address(r19, r18, (Address::ScaleFactor)0, +0x716b9b7e), r28, false); \/\/    xor r28, qword ptr [r19+r18*1+0x716b9b7e]    IID763\n+    __ exorq(r21, Address(rcx, r29, (Address::ScaleFactor)0, -0x5af0441e), r16, true); \/\/    {NF}xor r21, qword ptr [rcx+r29*1-0x5af0441e], r16    IID764\n+    __ exorq(r12, Address(r20, r26, (Address::ScaleFactor)0, +0xe0b7fb1), r12, true); \/\/    {NF}xor r12, qword ptr [r20+r26*1+0xe0b7fb1], r12    IID765\n+    __ eaddq(r30, Address(rcx, +0x2d3b7b4f), 1048576, false);                   \/\/    {EVEX}add r30, qword ptr [rcx+0x2d3b7b4f], 1048576    IID766\n+    __ eaddq(r14, Address(r21, r15, (Address::ScaleFactor)2, -0x1222aee8), 4096, true); \/\/    {NF}add r14, qword ptr [r21+r15*4-0x1222aee8], 4096    IID767\n+    __ eandq(r23, Address(r20, r31, (Address::ScaleFactor)0, -0x96e4d6a), 16, false); \/\/    {EVEX}and r23, qword ptr [r20+r31*1-0x96e4d6a], 16    IID768\n+    __ eandq(r10, Address(rdx, rdx, (Address::ScaleFactor)3, +0x3875f17c), 1, true); \/\/    {NF}and r10, qword ptr [rdx+rdx*8+0x3875f17c], 1    IID769\n+    __ eimulq(r17, Address(rcx, r25, (Address::ScaleFactor)2, +0x32c71076), 4096, false); \/\/    {EVEX}imul r17, qword ptr [rcx+r25*4+0x32c71076], 4096    IID770\n+    __ eimulq(r19, Address(r31, rbx, (Address::ScaleFactor)2, +0x7bada60d), 1048576, true); \/\/    {NF}imul r19, qword ptr [r31+rbx*4+0x7bada60d], 1048576    IID771\n+    __ eorq(r25, Address(r18, r23, (Address::ScaleFactor)1, +0x48147444), 16777216, false); \/\/    {EVEX}or r25, qword ptr [r18+r23*2+0x48147444], 16777216    IID772\n+    __ eorq(r29, Address(r26, r27, (Address::ScaleFactor)1, -0x4b113958), 1048576, true); \/\/    {NF}or r29, qword ptr [r26+r27*2-0x4b113958], 1048576    IID773\n+    __ esalq(r31, Address(r18, -0x46103c74), 2, false);                         \/\/    {EVEX}sal r31, qword ptr [r18-0x46103c74], 2    IID774\n+    __ esalq(r25, Address(r10, r15, (Address::ScaleFactor)0, +0x48925da4), 16, true); \/\/    {NF}sal r25, qword ptr [r10+r15*1+0x48925da4], 16    IID775\n+    __ esarq(r26, Address(r18, -0x5ea1c542), 8, false);                         \/\/    {EVEX}sar r26, qword ptr [r18-0x5ea1c542], 8    IID776\n+    __ esarq(r12, Address(r10, r22, (Address::ScaleFactor)2, +0x5d958264), 8, true); \/\/    {NF}sar r12, qword ptr [r10+r22*4+0x5d958264], 8    IID777\n+    __ eshrq(rdx, Address(r17, r20, (Address::ScaleFactor)2, +0x295add23), 16, false); \/\/    {EVEX}shr rdx, qword ptr [r17+r20*4+0x295add23], 16    IID778\n+    __ eshrq(rbx, Address(r22, r28, (Address::ScaleFactor)1, +0x782929cb), 2, true); \/\/    {NF}shr rbx, qword ptr [r22+r28*2+0x782929cb], 2    IID779\n+    __ esubq(r19, Address(r23, -0x49811d72), 1, false);                         \/\/    {EVEX}sub r19, qword ptr [r23-0x49811d72], 1    IID780\n+    __ esubq(r8, Address(r19, r14, (Address::ScaleFactor)2, -0x1b2bae9a), 1048576, true); \/\/    {NF}sub r8, qword ptr [r19+r14*4-0x1b2bae9a], 1048576    IID781\n+    __ exorq(r19, Address(rcx, r10, (Address::ScaleFactor)0, +0x45a66ee9), 1048576, false); \/\/    {EVEX}xor r19, qword ptr [rcx+r10*1+0x45a66ee9], 1048576    IID782\n+    __ exorq(r28, Address(r9, r29, (Address::ScaleFactor)0, -0x28a19314), 16, true); \/\/    {NF}xor r28, qword ptr [r9+r29*1-0x28a19314], 16    IID783\n+    __ eaddq(r8, rcx, 16777216, false);                                         \/\/    {EVEX}add r8, rcx, 16777216    IID784\n+    __ eaddq(rax, r14, 16777216, false);                                        \/\/    {EVEX}add rax, r14, 16777216    IID785\n+    __ eaddq(r16, r16, 256, false);                                             \/\/    add r16, 256    IID786\n+    __ eaddq(r24, r9, 4096, true);                                              \/\/    {NF}add r24, r9, 4096    IID787\n+    __ eaddq(rax, r18, 4096, true);                                             \/\/    {NF}add rax, r18, 4096    IID788\n+    __ eaddq(r8, r8, 1, true);                                                  \/\/    {NF}add r8, r8, 1    IID789\n+    __ eandq(r15, r22, 1048576, false);                                         \/\/    {EVEX}and r15, r22, 1048576    IID790\n+    __ eandq(rax, r26, 1048576, false);                                         \/\/    {EVEX}and rax, r26, 1048576    IID791\n+    __ eandq(rdx, rdx, 4096, false);                                            \/\/    and rdx, 4096    IID792\n+    __ eandq(rdx, r22, 268435456, true);                                        \/\/    {NF}and rdx, r22, 268435456    IID793\n+    __ eandq(rax, r29, 268435456, true);                                        \/\/    {NF}and rax, r29, 268435456    IID794\n+    __ eandq(r23, r23, 16777216, true);                                         \/\/    {NF}and r23, r23, 16777216    IID795\n+    __ eimulq(r9, r13, 1048576, false);                                         \/\/    {EVEX}imul r9, r13, 1048576    IID796\n+    __ eimulq(rax, r18, 1048576, false);                                        \/\/    {EVEX}imul rax, r18, 1048576    IID797\n+    __ eimulq(r16, r16, 1048576, false);                                        \/\/    {EVEX}imul r16, r16, 1048576    IID798\n+    __ eimulq(r17, r23, 1, true);                                               \/\/    {NF}imul r17, r23, 1    IID799\n+    __ eimulq(rax, r12, 1, true);                                               \/\/    {NF}imul rax, r12, 1    IID800\n+    __ eimulq(r10, r10, 268435456, true);                                       \/\/    {NF}imul r10, r10, 268435456    IID801\n+    __ eorq(rdx, r19, 256, false);                                              \/\/    {EVEX}or rdx, r19, 256    IID802\n+    __ eorq(rax, r14, 256, false);                                              \/\/    {EVEX}or rax, r14, 256    IID803\n+    __ eorq(r13, r13, 1, false);                                                \/\/    or r13, 1    IID804\n+    __ eorq(r25, r29, 256, true);                                               \/\/    {NF}or r25, r29, 256    IID805\n+    __ eorq(rax, rdx, 256, true);                                               \/\/    {NF}or rax, rdx, 256    IID806\n+    __ eorq(r16, r16, 16, true);                                                \/\/    {NF}or r16, r16, 16    IID807\n+    __ erclq(r13, r19, 4);                                                      \/\/    {EVEX}rcl r13, r19, 4    IID808\n+    __ erclq(rax, r12, 4);                                                      \/\/    {EVEX}rcl rax, r12, 4    IID809\n+    __ erclq(r9, r9, 4);                                                        \/\/    rcl r9, 4    IID810\n+    __ erolq(r13, r16, 1, false);                                               \/\/    {EVEX}rol r13, r16, 1    IID811\n+    __ erolq(rax, r31, 1, false);                                               \/\/    {EVEX}rol rax, r31, 1    IID812\n+    __ erolq(r30, r30, 8, false);                                               \/\/    rol r30, 8    IID813\n+    __ erolq(r30, r20, 8, true);                                                \/\/    {NF}rol r30, r20, 8    IID814\n+    __ erolq(rax, r31, 8, true);                                                \/\/    {NF}rol rax, r31, 8    IID815\n+    __ erolq(r31, r31, 4, true);                                                \/\/    {NF}rol r31, r31, 4    IID816\n+    __ erorq(r22, r10, 4, false);                                               \/\/    {EVEX}ror r22, r10, 4    IID817\n+    __ erorq(rax, r13, 4, false);                                               \/\/    {EVEX}ror rax, r13, 4    IID818\n+    __ erorq(r24, r24, 16, false);                                              \/\/    ror r24, 16    IID819\n+    __ erorq(r29, r22, 16, true);                                               \/\/    {NF}ror r29, r22, 16    IID820\n+    __ erorq(rax, r20, 16, true);                                               \/\/    {NF}ror rax, r20, 16    IID821\n+    __ erorq(r27, r27, 4, true);                                                \/\/    {NF}ror r27, r27, 4    IID822\n+    __ esalq(r31, r19, 2, false);                                               \/\/    {EVEX}sal r31, r19, 2    IID823\n+    __ esalq(rax, r20, 2, false);                                               \/\/    {EVEX}sal rax, r20, 2    IID824\n+    __ esalq(r11, r11, 8, false);                                               \/\/    sal r11, 8    IID825\n+    __ esalq(rdx, r15, 1, true);                                                \/\/    {NF}sal rdx, r15, 1    IID826\n+    __ esalq(rax, r10, 1, true);                                                \/\/    {NF}sal rax, r10, 1    IID827\n+    __ esalq(r29, r29, 4, true);                                                \/\/    {NF}sal r29, r29, 4    IID828\n+    __ esarq(r20, r16, 1, false);                                               \/\/    {EVEX}sar r20, r16, 1    IID829\n+    __ esarq(rax, r21, 1, false);                                               \/\/    {EVEX}sar rax, r21, 1    IID830\n+    __ esarq(r28, r28, 8, false);                                               \/\/    sar r28, 8    IID831\n+    __ esarq(r30, rcx, 4, true);                                                \/\/    {NF}sar r30, rcx, 4    IID832\n+    __ esarq(rax, r15, 4, true);                                                \/\/    {NF}sar rax, r15, 4    IID833\n+    __ esarq(rcx, rcx, 4, true);                                                \/\/    {NF}sar rcx, rcx, 4    IID834\n+    __ eshlq(rdx, r26, 4, false);                                               \/\/    {EVEX}shl rdx, r26, 4    IID835\n+    __ eshlq(rax, r26, 4, false);                                               \/\/    {EVEX}shl rax, r26, 4    IID836\n+    __ eshlq(r8, r8, 4, false);                                                 \/\/    shl r8, 4    IID837\n+    __ eshlq(rcx, rcx, 1, true);                                                \/\/    {NF}shl rcx, rcx, 1    IID838\n+    __ eshlq(rax, rcx, 1, true);                                                \/\/    {NF}shl rax, rcx, 1    IID839\n+    __ eshlq(r13, r13, 2, true);                                                \/\/    {NF}shl r13, r13, 2    IID840\n+    __ eshrq(r14, r27, 2, false);                                               \/\/    {EVEX}shr r14, r27, 2    IID841\n+    __ eshrq(rax, r11, 2, false);                                               \/\/    {EVEX}shr rax, r11, 2    IID842\n+    __ eshrq(r9, r9, 16, false);                                                \/\/    shr r9, 16    IID843\n+    __ eshrq(rdx, r31, 2, true);                                                \/\/    {NF}shr rdx, r31, 2    IID844\n+    __ eshrq(rax, r14, 2, true);                                                \/\/    {NF}shr rax, r14, 2    IID845\n+    __ eshrq(r12, r12, 8, true);                                                \/\/    {NF}shr r12, r12, 8    IID846\n+    __ esubq(r10, r28, 1, false);                                               \/\/    {EVEX}sub r10, r28, 1    IID847\n+    __ esubq(rax, r8, 1, false);                                                \/\/    {EVEX}sub rax, r8, 1    IID848\n+    __ esubq(rcx, rcx, 16777216, false);                                        \/\/    sub rcx, 16777216    IID849\n+    __ esubq(rdx, rbx, 16777216, true);                                         \/\/    {NF}sub rdx, rbx, 16777216    IID850\n+    __ esubq(rax, r18, 16777216, true);                                         \/\/    {NF}sub rax, r18, 16777216    IID851\n+    __ esubq(r27, r27, 65536, true);                                            \/\/    {NF}sub r27, r27, 65536    IID852\n+    __ exorq(r30, rcx, 4096, false);                                            \/\/    {EVEX}xor r30, rcx, 4096    IID853\n+    __ exorq(rax, r21, 4096, false);                                            \/\/    {EVEX}xor rax, r21, 4096    IID854\n+    __ exorq(rcx, rcx, 16777216, false);                                        \/\/    xor rcx, 16777216    IID855\n+    __ exorq(r21, r12, 1, true);                                                \/\/    {NF}xor r21, r12, 1    IID856\n+    __ exorq(rax, rdx, 1, true);                                                \/\/    {NF}xor rax, rdx, 1    IID857\n+    __ exorq(rbx, rbx, 16777216, true);                                         \/\/    {NF}xor rbx, rbx, 16777216    IID858\n+    __ eorq_imm32(r11, rdx, 65536, false);                                      \/\/    {EVEX}or r11, rdx, 65536    IID859\n+    __ eorq_imm32(rax, r14, 65536, false);                                      \/\/    {EVEX}or rax, r14, 65536    IID860\n+    __ eorq_imm32(r14, r14, 262144, false);                                     \/\/    or r14, 262144    IID861\n+    __ eorq_imm32(r25, r29, 262144, false);                                     \/\/    {EVEX}or r25, r29, 262144    IID862\n+    __ eorq_imm32(rax, r21, 262144, false);                                     \/\/    {EVEX}or rax, r21, 262144    IID863\n+    __ eorq_imm32(r11, r11, 16777216, false);                                   \/\/    or r11, 16777216    IID864\n+    __ esubq_imm32(r29, r19, 67108864, false);                                  \/\/    {EVEX}sub r29, r19, 67108864    IID865\n+    __ esubq_imm32(rax, r11, 67108864, false);                                  \/\/    {EVEX}sub rax, r11, 67108864    IID866\n+    __ esubq_imm32(r18, r18, 67108864, false);                                  \/\/    sub r18, 67108864    IID867\n+    __ esubq_imm32(r28, r23, 4194304, true);                                    \/\/    {NF}sub r28, r23, 4194304    IID868\n+    __ esubq_imm32(rax, r21, 4194304, true);                                    \/\/    {NF}sub rax, r21, 4194304    IID869\n+    __ esubq_imm32(r16, r16, 16777216, true);                                   \/\/    {NF}sub r16, r16, 16777216    IID870\n+    __ eaddq(r8, r25, Address(r26, r8, (Address::ScaleFactor)1, +0x10633def), false); \/\/    {EVEX}add r8, r25, qword ptr [r26+r8*2+0x10633def]    IID871\n+    __ eaddq(r13, r13, Address(r18, r16, (Address::ScaleFactor)1, -0x74204508), false); \/\/    add r13, qword ptr [r18+r16*2-0x74204508]    IID872\n+    __ eaddq(r17, r26, Address(r12, +0x23a80abf), true);                        \/\/    {NF}add r17, r26, qword ptr [r12+0x23a80abf]    IID873\n+    __ eaddq(r9, r9, Address(r29, r19, (Address::ScaleFactor)0, -0x29e9e52), true); \/\/    {NF}add r9, r9, qword ptr [r29+r19*1-0x29e9e52]    IID874\n+    __ eandq(r9, r28, Address(rcx, r25, (Address::ScaleFactor)2, +0x4261ffaa), false); \/\/    {EVEX}and r9, r28, qword ptr [rcx+r25*4+0x4261ffaa]    IID875\n+    __ eandq(r27, r27, Address(rdx, r28, (Address::ScaleFactor)0, -0x26bdc9c1), false); \/\/    and r27, qword ptr [rdx+r28*1-0x26bdc9c1]    IID876\n+    __ eandq(r14, r11, Address(r16, +0x63ba0ddf), true);                        \/\/    {NF}and r14, r11, qword ptr [r16+0x63ba0ddf]    IID877\n+    __ eandq(r8, r8, Address(r22, r25, (Address::ScaleFactor)1, -0x43b6ab44), true); \/\/    {NF}and r8, r8, qword ptr [r22+r25*2-0x43b6ab44]    IID878\n+    __ eorq(r19, rcx, Address(r27, rcx, (Address::ScaleFactor)2, -0x7f687fc6), false); \/\/    {EVEX}or r19, rcx, qword ptr [r27+rcx*4-0x7f687fc6]    IID879\n+    __ eorq(r19, r19, Address(rbx, r26, (Address::ScaleFactor)1, -0x486db7ea), false); \/\/    or r19, qword ptr [rbx+r26*2-0x486db7ea]    IID880\n+    __ eorq(r30, r10, Address(r14, r18, (Address::ScaleFactor)3, +0x14884884), true); \/\/    {NF}or r30, r10, qword ptr [r14+r18*8+0x14884884]    IID881\n+    __ eorq(r27, r27, Address(r29, +0x20337180), true);                         \/\/    {NF}or r27, r27, qword ptr [r29+0x20337180]    IID882\n+    __ eimulq(rcx, r21, Address(r21, rbx, (Address::ScaleFactor)0, -0x3303888e), false); \/\/    {EVEX}imul rcx, r21, qword ptr [r21+rbx*1-0x3303888e]    IID883\n+    __ eimulq(rdx, rdx, Address(r28, r9, (Address::ScaleFactor)3, -0x7ad8f741), false); \/\/    imul rdx, qword ptr [r28+r9*8-0x7ad8f741]    IID884\n+    __ eimulq(r8, r29, Address(r17, r12, (Address::ScaleFactor)0, +0x6e85396a), true); \/\/    {NF}imul r8, r29, qword ptr [r17+r12*1+0x6e85396a]    IID885\n+    __ eimulq(r16, r16, Address(r19, r10, (Address::ScaleFactor)3, -0x49599300), true); \/\/    {NF}imul r16, r16, qword ptr [r19+r10*8-0x49599300]    IID886\n+    __ esubq(r20, r17, Address(r13, r22, (Address::ScaleFactor)0, +0x1d219a4f), false); \/\/    {EVEX}sub r20, r17, qword ptr [r13+r22*1+0x1d219a4f]    IID887\n+    __ esubq(r25, r25, Address(r21, r21, (Address::ScaleFactor)3, -0x6868a8c7), false); \/\/    sub r25, qword ptr [r21+r21*8-0x6868a8c7]    IID888\n+    __ esubq(r20, r24, Address(rbx, r20, (Address::ScaleFactor)2, +0x32c59da6), true); \/\/    {NF}sub r20, r24, qword ptr [rbx+r20*4+0x32c59da6]    IID889\n+    __ esubq(r8, r8, Address(r12, r17, (Address::ScaleFactor)0, -0x26be2dcf), true); \/\/    {NF}sub r8, r8, qword ptr [r12+r17*1-0x26be2dcf]    IID890\n+    __ exorq(rdx, r19, Address(r9, +0x7d903b91), false);                        \/\/    {EVEX}xor rdx, r19, qword ptr [r9+0x7d903b91]    IID891\n+    __ exorq(r28, r28, Address(r29, r27, (Address::ScaleFactor)2, +0x53091f6f), false); \/\/    xor r28, qword ptr [r29+r27*4+0x53091f6f]    IID892\n+    __ exorq(r17, r16, Address(r27, +0x7c6e9207), true);                        \/\/    {NF}xor r17, r16, qword ptr [r27+0x7c6e9207]    IID893\n+    __ exorq(r15, r15, Address(r13, r24, (Address::ScaleFactor)3, -0x75c87960), true); \/\/    {NF}xor r15, r15, qword ptr [r13+r24*8-0x75c87960]    IID894\n+    __ eaddq(r16, rbx, r18, false);                                             \/\/    {load}{EVEX}add r16, rbx, r18    IID895\n+    __ eaddq(r24, r24, r18, false);                                             \/\/    {load}add r24, r18    IID896\n+    __ eaddq(r9, r15, r9, false);                                               \/\/    {load}add r9, r15    IID897\n+    __ eaddq(r19, r26, r13, true);                                              \/\/    {load}{NF}add r19, r26, r13    IID898\n+    __ eaddq(r28, r28, r22, true);                                              \/\/    {load}{NF}add r28, r28, r22    IID899\n+    __ eaddq(r22, r11, r22, true);                                              \/\/    {load}{NF}add r22, r11, r22    IID900\n+    __ eadcxq(rcx, r12, r13);                                                   \/\/    {load}{EVEX}adcx rcx, r12, r13    IID901\n+    __ eadcxq(r30, r30, r12);                                                   \/\/    {load}adcx r30, r12    IID902\n+    __ eadoxq(r28, r14, r18);                                                   \/\/    {load}{EVEX}adox r28, r14, r18    IID903\n+    __ eadoxq(r30, r30, r19);                                                   \/\/    {load}adox r30, r19    IID904\n+    __ eandq(r20, r14, r14, false);                                             \/\/    {load}{EVEX}and r20, r14, r14    IID905\n+    __ eandq(r17, r17, r23, false);                                             \/\/    {load}and r17, r23    IID906\n+    __ eandq(r17, r14, r17, false);                                             \/\/    {load}and r17, r14    IID907\n+    __ eandq(r19, r20, r15, true);                                              \/\/    {load}{NF}and r19, r20, r15    IID908\n+    __ eandq(rbx, rbx, r13, true);                                              \/\/    {load}{NF}and rbx, rbx, r13    IID909\n+    __ eandq(r22, r30, r22, true);                                              \/\/    {load}{NF}and r22, r30, r22    IID910\n+    __ eimulq(r17, r24, rcx, false);                                            \/\/    {load}{EVEX}imul r17, r24, rcx    IID911\n+    __ eimulq(r21, r21, r8, false);                                             \/\/    {load}imul r21, r8    IID912\n+    __ eimulq(r29, r21, r29, false);                                            \/\/    {load}imul r29, r21    IID913\n+    __ eimulq(r27, r13, r23, true);                                             \/\/    {load}{NF}imul r27, r13, r23    IID914\n+    __ eimulq(r26, r26, r8, true);                                              \/\/    {load}{NF}imul r26, r26, r8    IID915\n+    __ eimulq(r22, r13, r22, true);                                             \/\/    {load}{NF}imul r22, r13, r22    IID916\n+    __ eorq(r11, rdx, r29, false);                                              \/\/    {load}{EVEX}or r11, rdx, r29    IID917\n+    __ eorq(rdx, rdx, r31, false);                                              \/\/    {load}or rdx, r31    IID918\n+    __ eorq(r10, r29, r10, false);                                              \/\/    {load}or r10, r29    IID919\n+    __ eorq(r27, r28, rcx, true);                                               \/\/    {load}{NF}or r27, r28, rcx    IID920\n+    __ eorq(r25, r25, r9, true);                                                \/\/    {load}{NF}or r25, r25, r9    IID921\n+    __ eorq(rcx, r8, rcx, true);                                                \/\/    {load}{NF}or rcx, r8, rcx    IID922\n+    __ esubq(rcx, r10, r16, false);                                             \/\/    {load}{EVEX}sub rcx, r10, r16    IID923\n+    __ esubq(r17, r17, rcx, false);                                             \/\/    {load}sub r17, rcx    IID924\n+    __ esubq(r13, r21, r24, true);                                              \/\/    {load}{NF}sub r13, r21, r24    IID925\n+    __ esubq(r31, r31, r28, true);                                              \/\/    {load}{NF}sub r31, r31, r28    IID926\n+    __ exorq(r23, r28, r23, false);                                             \/\/    {load}xor r23, r28    IID927\n+    __ exorq(r10, r10, r11, false);                                             \/\/    {load}xor r10, r11    IID928\n+    __ exorq(r19, r18, r19, false);                                             \/\/    {load}xor r19, r18    IID929\n+    __ exorq(r31, r9, rdx, true);                                               \/\/    {load}{NF}xor r31, r9, rdx    IID930\n+    __ exorq(r13, r13, r9, true);                                               \/\/    {load}{NF}xor r13, r13, r9    IID931\n+    __ exorq(rcx, r10, rcx, true);                                              \/\/    {load}{NF}xor rcx, r10, rcx    IID932\n+    __ eshldq(r12, r24, r22, 8, false);                                         \/\/    {EVEX}shld r12, r24, r22, 8    IID933\n+    __ eshldq(r25, r25, r25, 8, false);                                         \/\/    shld r25, r25, 8    IID934\n+    __ eshldq(r21, r20, r15, 8, true);                                          \/\/    {NF}shld r21, r20, r15, 8    IID935\n+    __ eshldq(r21, r21, r10, 8, true);                                          \/\/    {NF}shld r21, r21, r10, 8    IID936\n+    __ eshrdq(r18, r18, r8, 2, false);                                          \/\/    shrd r18, r8, 2    IID937\n+    __ eshrdq(r26, r26, r29, 8, false);                                         \/\/    shrd r26, r29, 8    IID938\n+    __ eshrdq(r29, r26, r19, 2, true);                                          \/\/    {NF}shrd r29, r26, r19, 2    IID939\n+    __ eshrdq(r12, r12, rcx, 4, true);                                          \/\/    {NF}shrd r12, r12, rcx, 4    IID940\n+    __ ecmovq (Assembler::Condition::overflow, r21, r22, r23);                  \/\/    cmovo r21, r22, r23    IID941\n+    __ ecmovq (Assembler::Condition::overflow, r9, r9, r13);                    \/\/    cmovo r9, r13    IID942\n+    __ ecmovq (Assembler::Condition::noOverflow, rcx, r23, r24);                \/\/    cmovno rcx, r23, r24    IID943\n+    __ ecmovq (Assembler::Condition::noOverflow, r28, r28, rdx);                \/\/    cmovno r28, rdx    IID944\n+    __ ecmovq (Assembler::Condition::below, r14, r31, r23);                     \/\/    cmovb r14, r31, r23    IID945\n+    __ ecmovq (Assembler::Condition::below, r30, r30, r23);                     \/\/    cmovb r30, r23    IID946\n+    __ ecmovq (Assembler::Condition::aboveEqual, r10, r29, r22);                \/\/    cmovae r10, r29, r22    IID947\n+    __ ecmovq (Assembler::Condition::aboveEqual, rbx, rbx, r26);                \/\/    cmovae rbx, r26    IID948\n+    __ ecmovq (Assembler::Condition::zero, r23, r21, r13);                      \/\/    cmovz r23, r21, r13    IID949\n+    __ ecmovq (Assembler::Condition::zero, r10, r10, r20);                      \/\/    cmovz r10, r20    IID950\n+    __ ecmovq (Assembler::Condition::notZero, rbx, r9, r29);                    \/\/    cmovnz rbx, r9, r29    IID951\n+    __ ecmovq (Assembler::Condition::notZero, r16, r16, r30);                   \/\/    cmovnz r16, r30    IID952\n+    __ ecmovq (Assembler::Condition::belowEqual, r13, rcx, r29);                \/\/    cmovbe r13, rcx, r29    IID953\n+    __ ecmovq (Assembler::Condition::belowEqual, r31, r31, r13);                \/\/    cmovbe r31, r13    IID954\n+    __ ecmovq (Assembler::Condition::above, r27, r9, r30);                      \/\/    cmova r27, r9, r30    IID955\n+    __ ecmovq (Assembler::Condition::above, r26, r26, r20);                     \/\/    cmova r26, r20    IID956\n+    __ ecmovq (Assembler::Condition::negative, r8, r12, r22);                   \/\/    cmovs r8, r12, r22    IID957\n+    __ ecmovq (Assembler::Condition::negative, r31, r31, r17);                  \/\/    cmovs r31, r17    IID958\n+    __ ecmovq (Assembler::Condition::positive, r29, rcx, r25);                  \/\/    cmovns r29, rcx, r25    IID959\n+    __ ecmovq (Assembler::Condition::positive, r22, r22, r14);                  \/\/    cmovns r22, r14    IID960\n+    __ ecmovq (Assembler::Condition::parity, rcx, r27, r9);                     \/\/    cmovp rcx, r27, r9    IID961\n+    __ ecmovq (Assembler::Condition::parity, r22, r22, r11);                    \/\/    cmovp r22, r11    IID962\n+    __ ecmovq (Assembler::Condition::noParity, r14, r19, r24);                  \/\/    cmovnp r14, r19, r24    IID963\n+    __ ecmovq (Assembler::Condition::noParity, r24, r24, r17);                  \/\/    cmovnp r24, r17    IID964\n+    __ ecmovq (Assembler::Condition::less, r17, r19, r30);                      \/\/    cmovl r17, r19, r30    IID965\n+    __ ecmovq (Assembler::Condition::less, r19, r19, r14);                      \/\/    cmovl r19, r14    IID966\n+    __ ecmovq (Assembler::Condition::greaterEqual, r25, r11, r29);              \/\/    cmovge r25, r11, r29    IID967\n+    __ ecmovq (Assembler::Condition::greaterEqual, r12, r12, r26);              \/\/    cmovge r12, r26    IID968\n+    __ ecmovq (Assembler::Condition::lessEqual, r11, rbx, r10);                 \/\/    cmovle r11, rbx, r10    IID969\n+    __ ecmovq (Assembler::Condition::lessEqual, rdx, rdx, r22);                 \/\/    cmovle rdx, r22    IID970\n+    __ ecmovq (Assembler::Condition::greater, r14, r15, r23);                   \/\/    cmovg r14, r15, r23    IID971\n+    __ ecmovq (Assembler::Condition::greater, r8, r8, r24);                     \/\/    cmovg r8, r24    IID972\n+    __ ecmovq (Assembler::Condition::overflow, rbx, r31, Address(r10, r8, (Address::ScaleFactor)3, -0x313f60e0)); \/\/    cmovo rbx, r31, qword ptr [r10+r8*8-0x313f60e0]    IID973\n+    __ ecmovq (Assembler::Condition::overflow, r23, r23, Address(rcx, r24, (Address::ScaleFactor)2, +0x17f41d9c)); \/\/    cmovo r23, qword ptr [rcx+r24*4+0x17f41d9c]    IID974\n+    __ ecmovq (Assembler::Condition::noOverflow, r31, r11, Address(r16, +0x2c018942)); \/\/    cmovno r31, r11, qword ptr [r16+0x2c018942]    IID975\n+    __ ecmovq (Assembler::Condition::noOverflow, r11, r11, Address(r16, r20, (Address::ScaleFactor)3, +0x674b6a55)); \/\/    cmovno r11, qword ptr [r16+r20*8+0x674b6a55]    IID976\n+    __ ecmovq (Assembler::Condition::below, r9, r13, Address(r9, rcx, (Address::ScaleFactor)0, +0x394a11df)); \/\/    cmovb r9, r13, qword ptr [r9+rcx*1+0x394a11df]    IID977\n+    __ ecmovq (Assembler::Condition::below, r30, r30, Address(rdx, r22, (Address::ScaleFactor)1, -0x6c362b88)); \/\/    cmovb r30, qword ptr [rdx+r22*2-0x6c362b88]    IID978\n+    __ ecmovq (Assembler::Condition::aboveEqual, r13, rcx, Address(r24, rcx, (Address::ScaleFactor)3, +0x46500b66)); \/\/    cmovae r13, rcx, qword ptr [r24+rcx*8+0x46500b66]    IID979\n+    __ ecmovq (Assembler::Condition::aboveEqual, r24, r24, Address(r18, r25, (Address::ScaleFactor)1, +0x53283b7c)); \/\/    cmovae r24, qword ptr [r18+r25*2+0x53283b7c]    IID980\n+    __ ecmovq (Assembler::Condition::zero, r23, r25, Address(r15, r9, (Address::ScaleFactor)0, -0x5f03031e)); \/\/    cmovz r23, r25, qword ptr [r15+r9*1-0x5f03031e]    IID981\n+    __ ecmovq (Assembler::Condition::zero, r25, r25, Address(r28, r16, (Address::ScaleFactor)1, -0x53cef514)); \/\/    cmovz r25, qword ptr [r28+r16*2-0x53cef514]    IID982\n+    __ ecmovq (Assembler::Condition::notZero, rbx, r25, Address(r24, r25, (Address::ScaleFactor)2, -0x66caac87)); \/\/    cmovnz rbx, r25, qword ptr [r24+r25*4-0x66caac87]    IID983\n+    __ ecmovq (Assembler::Condition::notZero, r16, r16, Address(r27, r30, (Address::ScaleFactor)3, +0x797f455d)); \/\/    cmovnz r16, qword ptr [r27+r30*8+0x797f455d]    IID984\n+    __ ecmovq (Assembler::Condition::belowEqual, r25, r30, Address(r18, r18, (Address::ScaleFactor)1, +0x1c9daacd)); \/\/    cmovbe r25, r30, qword ptr [r18+r18*2+0x1c9daacd]    IID985\n+    __ ecmovq (Assembler::Condition::belowEqual, r22, r22, Address(rcx, r25, (Address::ScaleFactor)1, -0x3dcbfaa9)); \/\/    cmovbe r22, qword ptr [rcx+r25*2-0x3dcbfaa9]    IID986\n+    __ ecmovq (Assembler::Condition::above, r24, r26, Address(r25, +0x747060b5)); \/\/    cmova r24, r26, qword ptr [r25+0x747060b5]    IID987\n+    __ ecmovq (Assembler::Condition::above, r8, r8, Address(r24, r20, (Address::ScaleFactor)3, +0x47d285f6)); \/\/    cmova r8, qword ptr [r24+r20*8+0x47d285f6]    IID988\n+    __ ecmovq (Assembler::Condition::negative, r12, r16, Address(r13, r10, (Address::ScaleFactor)2, +0x34e5b214)); \/\/    cmovs r12, r16, qword ptr [r13+r10*4+0x34e5b214]    IID989\n+    __ ecmovq (Assembler::Condition::negative, rdx, rdx, Address(r15, r19, (Address::ScaleFactor)0, -0x405138b1)); \/\/    cmovs rdx, qword ptr [r15+r19*1-0x405138b1]    IID990\n+    __ ecmovq (Assembler::Condition::positive, r18, r21, Address(rbx, r13, (Address::ScaleFactor)2, +0x51b19197)); \/\/    cmovns r18, r21, qword ptr [rbx+r13*4+0x51b19197]    IID991\n+    __ ecmovq (Assembler::Condition::positive, r24, r24, Address(r11, r31, (Address::ScaleFactor)3, +0x3e01520a)); \/\/    cmovns r24, qword ptr [r11+r31*8+0x3e01520a]    IID992\n+    __ ecmovq (Assembler::Condition::parity, r29, r26, Address(r10, r25, (Address::ScaleFactor)3, -0x5f7c3872)); \/\/    cmovp r29, r26, qword ptr [r10+r25*8-0x5f7c3872]    IID993\n+    __ ecmovq (Assembler::Condition::parity, r11, r11, Address(r22, r10, (Address::ScaleFactor)3, -0x68731453)); \/\/    cmovp r11, qword ptr [r22+r10*8-0x68731453]    IID994\n+    __ ecmovq (Assembler::Condition::noParity, r20, r15, Address(r9, r25, (Address::ScaleFactor)0, +0x4a37edaa)); \/\/    cmovnp r20, r15, qword ptr [r9+r25*1+0x4a37edaa]    IID995\n+    __ ecmovq (Assembler::Condition::noParity, r31, r31, Address(r9, r20, (Address::ScaleFactor)0, +0x4f999f86)); \/\/    cmovnp r31, qword ptr [r9+r20*1+0x4f999f86]    IID996\n+    __ ecmovq (Assembler::Condition::less, r18, r23, Address(r9, r27, (Address::ScaleFactor)0, -0x3410441d)); \/\/    cmovl r18, r23, qword ptr [r9+r27*1-0x3410441d]    IID997\n+    __ ecmovq (Assembler::Condition::less, r16, r16, Address(r24, r10, (Address::ScaleFactor)3, +0x52ed66ee)); \/\/    cmovl r16, qword ptr [r24+r10*8+0x52ed66ee]    IID998\n+    __ ecmovq (Assembler::Condition::greaterEqual, r11, r18, Address(rcx, +0x1de09163)); \/\/    cmovge r11, r18, qword ptr [rcx+0x1de09163]    IID999\n+    __ ecmovq (Assembler::Condition::greaterEqual, r14, r14, Address(r24, r23, (Address::ScaleFactor)1, +0x5df3b4da)); \/\/    cmovge r14, qword ptr [r24+r23*2+0x5df3b4da]    IID1000\n+    __ ecmovq (Assembler::Condition::lessEqual, r15, r14, Address(r30, r20, (Address::ScaleFactor)1, +0x5c9ab976)); \/\/    cmovle r15, r14, qword ptr [r30+r20*2+0x5c9ab976]    IID1001\n+    __ ecmovq (Assembler::Condition::lessEqual, r26, r26, Address(r18, r27, (Address::ScaleFactor)2, -0xd8c329)); \/\/    cmovle r26, qword ptr [r18+r27*4-0xd8c329]    IID1002\n+    __ ecmovq (Assembler::Condition::greater, r29, r9, Address(r30, r20, (Address::ScaleFactor)3, -0x37a9cf8d)); \/\/    cmovg r29, r9, qword ptr [r30+r20*8-0x37a9cf8d]    IID1003\n+    __ ecmovq (Assembler::Condition::greater, r20, r20, Address(r8, rbx, (Address::ScaleFactor)1, +0x1bdc7def)); \/\/    cmovg r20, qword ptr [r8+rbx*2+0x1bdc7def]    IID1004\n@@ -1246,1 +1330,1 @@\n-    0x62, 0x4c, 0x1c, 0x10, 0x01, 0xa4, 0xc8, 0x3e, 0x12, 0xac, 0x9f,                \/\/ IID268\n+    0xd5, 0x55, 0x03, 0xa4, 0xc8, 0x3e, 0x12, 0xac, 0x9f,                            \/\/ IID268\n@@ -1249,50 +1333,47 @@\n-    0x62, 0x64, 0x0c, 0x10, 0x09, 0xa4, 0xd3, 0x4c, 0xbf, 0xca, 0xb9,                \/\/ IID271\n-    0x62, 0x8c, 0x6c, 0x10, 0x09, 0x94, 0xd4, 0x3b, 0xa7, 0x23, 0x35,                \/\/ IID272\n-    0x62, 0x84, 0x34, 0x1c, 0x09, 0xac, 0x7f, 0xaa, 0x22, 0xf4, 0xd5,                \/\/ IID273\n-    0x62, 0xec, 0x7c, 0x14, 0x09, 0x87, 0x01, 0x9b, 0xaf, 0xe9,                      \/\/ IID274\n-    0x62, 0x8c, 0x1c, 0x10, 0x08, 0xa4, 0x1e, 0x3a, 0x1e, 0x28, 0x17,                \/\/ IID275\n-    0x62, 0xb4, 0x68, 0x18, 0x08, 0x94, 0xbb, 0xbb, 0xb5, 0x77, 0x24,                \/\/ IID276\n-    0x62, 0x44, 0x7c, 0x14, 0x08, 0x84, 0x4b, 0x51, 0x2e, 0x8a, 0xce,                \/\/ IID277\n-    0x62, 0xd4, 0x60, 0x1c, 0x08, 0x9c, 0xe3, 0x2d, 0x84, 0x29, 0xdd,                \/\/ IID278\n-    0x62, 0x9c, 0x28, 0x10, 0x29, 0x94, 0x73, 0xd2, 0x31, 0x64, 0xc2,                \/\/ IID279\n-    0x62, 0x2c, 0x00, 0x10, 0x29, 0xbc, 0x6e, 0x19, 0x85, 0x21, 0x14,                \/\/ IID280\n-    0x62, 0x54, 0x54, 0x14, 0x29, 0xa9, 0x86, 0xed, 0xaf, 0xef,                      \/\/ IID281\n-    0x62, 0x04, 0x04, 0x14, 0x29, 0xbc, 0x01, 0x9f, 0x76, 0x1e, 0xf5,                \/\/ IID282\n-    0x62, 0x7c, 0x04, 0x18, 0x31, 0xa2, 0xe5, 0xbc, 0x2b, 0x5c,                      \/\/ IID283\n-    0x62, 0x4c, 0x20, 0x10, 0x31, 0x9c, 0x39, 0xb3, 0x78, 0x60, 0x5c,                \/\/ IID284\n-    0x62, 0x54, 0x6c, 0x14, 0x31, 0xb4, 0xd0, 0x7f, 0xc7, 0x12, 0xf6,                \/\/ IID285\n-    0x62, 0x54, 0x34, 0x1c, 0x31, 0x8f, 0xad, 0xcd, 0x5a, 0x77,                      \/\/ IID286\n-    0x62, 0xac, 0x50, 0x10, 0x30, 0xbc, 0x52, 0xd5, 0x1f, 0xe3, 0x2f,                \/\/ IID287\n-    0x62, 0x5c, 0x2c, 0x18, 0x30, 0x93, 0xde, 0x50, 0x31, 0x0a,                      \/\/ IID288\n-    0x62, 0x2c, 0x68, 0x14, 0x30, 0x84, 0xf6, 0x97, 0xe8, 0xd4, 0x1a,                \/\/ IID289\n-    0x62, 0x7c, 0x38, 0x1c, 0x30, 0x84, 0x20, 0x82, 0xae, 0x6e, 0x62,                \/\/ IID290\n-    0x62, 0xd4, 0x54, 0x10, 0x81, 0xc7, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID291\n-    0x62, 0xfc, 0x7c, 0x18, 0x81, 0xc2, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID292\n-    0xd5, 0x10, 0x81, 0xc2, 0x00, 0x01, 0x00, 0x00,                                  \/\/ IID293\n-    0x62, 0xfc, 0x14, 0x1c, 0x83, 0xc3, 0x10,                                        \/\/ IID294\n-    0x62, 0xfc, 0x7c, 0x1c, 0x83, 0xc7, 0x10,                                        \/\/ IID295\n-    0x62, 0xdc, 0x34, 0x14, 0x81, 0xc1, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID296\n-    0x62, 0xfc, 0x14, 0x10, 0x81, 0xe2, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID297\n-    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xe6, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID298\n-    0xd5, 0x10, 0x81, 0xe3, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID299\n-    0x62, 0xdc, 0x24, 0x14, 0x81, 0xe1, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID300\n-    0x62, 0xfc, 0x7c, 0x1c, 0x81, 0xe4, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID301\n-    0x62, 0xdc, 0x1c, 0x14, 0x83, 0xe4, 0x10,                                        \/\/ IID302\n-    0x62, 0x6c, 0x7c, 0x08, 0x69, 0xfe, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID303\n-#endif \/\/ _LP64\n-    0x62, 0xf4, 0x7c, 0x08, 0x69, 0xc3, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID304\n-#ifdef _LP64\n-    0x62, 0x4c, 0x7c, 0x08, 0x69, 0xc0, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID305\n-    0x62, 0xec, 0x7c, 0x0c, 0x69, 0xe8, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID306\n-    0x62, 0xdc, 0x7c, 0x0c, 0x69, 0xc0, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID307\n-    0x62, 0x54, 0x7c, 0x0c, 0x6b, 0xed, 0x10,                                        \/\/ IID308\n-    0x62, 0xd4, 0x14, 0x10, 0x81, 0xc8, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID309\n-    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xcc, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID310\n-    0xd5, 0x11, 0x81, 0xce, 0x00, 0x10, 0x00, 0x00,                                  \/\/ IID311\n-    0x62, 0xf4, 0x3c, 0x14, 0x83, 0xca, 0x10,                                        \/\/ IID312\n-    0x62, 0xd4, 0x7c, 0x1c, 0x83, 0xc8, 0x10,                                        \/\/ IID313\n-    0x62, 0xd4, 0x14, 0x1c, 0x81, 0xcd, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID314\n-    0x62, 0xd4, 0x34, 0x10, 0xd1, 0xd5,                                              \/\/ IID315\n-    0x62, 0xfc, 0x7c, 0x18, 0xd1, 0xd2,                                              \/\/ IID316\n-    0x41, 0xc1, 0xd1, 0x10,                                                          \/\/ IID317\n-    0x62, 0xdc, 0x2c, 0x10, 0xc1, 0xc1, 0x08,                                        \/\/ IID318\n+    0x62, 0x64, 0x0c, 0x10, 0x21, 0xa4, 0xd3, 0x4c, 0xbf, 0xca, 0xb9,                \/\/ IID271\n+    0xd5, 0x53, 0x23, 0x94, 0xd4, 0x3b, 0xa7, 0x23, 0x35,                            \/\/ IID272\n+    0x62, 0x84, 0x34, 0x1c, 0x21, 0xac, 0x7f, 0xaa, 0x22, 0xf4, 0xd5,                \/\/ IID273\n+    0x62, 0xec, 0x7c, 0x14, 0x21, 0x87, 0x01, 0x9b, 0xaf, 0xe9,                      \/\/ IID274\n+    0x62, 0x8c, 0x1c, 0x10, 0x09, 0xa4, 0x1e, 0x3a, 0x1e, 0x28, 0x17,                \/\/ IID275\n+    0xd5, 0x22, 0x0b, 0x94, 0xbb, 0xbb, 0xb5, 0x77, 0x24,                            \/\/ IID276\n+    0x62, 0x44, 0x7c, 0x14, 0x09, 0x84, 0x4b, 0x51, 0x2e, 0x8a, 0xce,                \/\/ IID277\n+    0x62, 0xd4, 0x60, 0x1c, 0x09, 0x9c, 0xe3, 0x2d, 0x84, 0x29, 0xdd,                \/\/ IID278\n+    0x62, 0x9c, 0x28, 0x10, 0x08, 0x94, 0x73, 0xd2, 0x31, 0x64, 0xc2,                \/\/ IID279\n+    0xd5, 0x76, 0x0a, 0xbc, 0x6e, 0x19, 0x85, 0x21, 0x14,                            \/\/ IID280\n+    0x62, 0x54, 0x54, 0x14, 0x08, 0xa9, 0x86, 0xed, 0xaf, 0xef,                      \/\/ IID281\n+    0x62, 0x04, 0x04, 0x14, 0x08, 0xbc, 0x01, 0x9f, 0x76, 0x1e, 0xf5,                \/\/ IID282\n+    0x62, 0x7c, 0x04, 0x18, 0x29, 0xa2, 0xe5, 0xbc, 0x2b, 0x5c,                      \/\/ IID283\n+    0x62, 0x4c, 0x20, 0x10, 0x29, 0x9c, 0x39, 0xb3, 0x78, 0x60, 0x5c,                \/\/ IID284\n+    0x62, 0x54, 0x6c, 0x14, 0x29, 0xb4, 0xd0, 0x7f, 0xc7, 0x12, 0xf6,                \/\/ IID285\n+    0x62, 0x54, 0x34, 0x1c, 0x29, 0x8f, 0xad, 0xcd, 0x5a, 0x77,                      \/\/ IID286\n+    0x62, 0xac, 0x50, 0x10, 0x31, 0xbc, 0x52, 0xd5, 0x1f, 0xe3, 0x2f,                \/\/ IID287\n+    0xd5, 0x15, 0x33, 0x93, 0xde, 0x50, 0x31, 0x0a,                                  \/\/ IID288\n+    0x62, 0x2c, 0x68, 0x14, 0x31, 0x84, 0xf6, 0x97, 0xe8, 0xd4, 0x1a,                \/\/ IID289\n+    0x62, 0x7c, 0x38, 0x1c, 0x31, 0x84, 0x20, 0x82, 0xae, 0x6e, 0x62,                \/\/ IID290\n+    0x62, 0xac, 0x7c, 0x10, 0x30, 0x94, 0x3d, 0xf3, 0x49, 0xfc, 0xeb,                \/\/ IID291\n+    0xd5, 0x34, 0x32, 0xac, 0xbb, 0xe1, 0xf1, 0x7e, 0x23,                            \/\/ IID292\n+    0x62, 0x3c, 0x14, 0x14, 0x30, 0xb4, 0xb2, 0x5b, 0x09, 0xc0, 0x5c,                \/\/ IID293\n+    0x62, 0x4c, 0x20, 0x14, 0x30, 0x9c, 0xe1, 0x58, 0xb9, 0xf7, 0x1c,                \/\/ IID294\n+    0x62, 0xdc, 0x7c, 0x10, 0x83, 0xc0, 0x10,                                        \/\/ IID295\n+    0x62, 0xdc, 0x7c, 0x18, 0x83, 0xc0, 0x10,                                        \/\/ IID296\n+    0xd5, 0x10, 0x81, 0xc5, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID297\n+    0x62, 0xd4, 0x3c, 0x14, 0x81, 0xc0, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID298\n+    0x62, 0xd4, 0x7c, 0x1c, 0x81, 0xc5, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID299\n+    0x62, 0xdc, 0x14, 0x14, 0x81, 0xc5, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID300\n+    0x41, 0x83, 0xe4, 0x10,                                                          \/\/ IID301\n+    0x62, 0xdc, 0x7c, 0x18, 0x83, 0xe6, 0x10,                                        \/\/ IID302\n+    0xd5, 0x11, 0x83, 0xe0, 0x10,                                                    \/\/ IID303\n+    0x62, 0xd4, 0x3c, 0x1c, 0x83, 0xe4, 0x01,                                        \/\/ IID304\n+    0x62, 0xd4, 0x7c, 0x1c, 0x83, 0xe5, 0x01,                                        \/\/ IID305\n+    0x62, 0xdc, 0x34, 0x14, 0x83, 0xe1, 0x10,                                        \/\/ IID306\n+    0x62, 0xec, 0x7c, 0x08, 0x69, 0xd7, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID307\n+    0x62, 0xd4, 0x7c, 0x08, 0x69, 0xc1, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID308\n+    0x62, 0x4c, 0x7c, 0x08, 0x69, 0xd2, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID309\n+    0x62, 0x6c, 0x7c, 0x0c, 0x6b, 0xcd, 0x01,                                        \/\/ IID310\n+    0x62, 0xdc, 0x7c, 0x0c, 0x6b, 0xc0, 0x01,                                        \/\/ IID311\n+    0x62, 0x4c, 0x7c, 0x0c, 0x69, 0xc0, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID312\n+    0x62, 0xdc, 0x0c, 0x10, 0x83, 0xca, 0x01,                                        \/\/ IID313\n+    0x62, 0xfc, 0x7c, 0x18, 0x83, 0xce, 0x01,                                        \/\/ IID314\n+    0xd5, 0x10, 0x81, 0xc9, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID315\n+    0x62, 0xd4, 0x3c, 0x14, 0x83, 0xc8, 0x01,                                        \/\/ IID316\n+    0x62, 0xdc, 0x7c, 0x1c, 0x83, 0xcb, 0x01,                                        \/\/ IID317\n@@ -1300,1 +1381,1 @@\n-    0x62, 0xf4, 0x7c, 0x18, 0xc1, 0xc2, 0x08,                                        \/\/ IID319\n+    0x62, 0xf4, 0x6c, 0x1c, 0x81, 0xca, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID318\n@@ -1302,5 +1383,49 @@\n-    0xd5, 0x11, 0xc1, 0xc0, 0x10,                                                    \/\/ IID320\n-    0x62, 0xf4, 0x3c, 0x14, 0xc1, 0xc1, 0x08,                                        \/\/ IID321\n-    0x62, 0xdc, 0x7c, 0x1c, 0xc1, 0xc6, 0x08,                                        \/\/ IID322\n-    0x62, 0xdc, 0x1c, 0x14, 0xc1, 0xc4, 0x10,                                        \/\/ IID323\n-    0x62, 0xdc, 0x74, 0x10, 0xc1, 0xcc, 0x04,                                        \/\/ IID324\n+    0xd5, 0x10, 0xc1, 0xd6, 0x08,                                                    \/\/ IID319\n+    0x62, 0xfc, 0x7c, 0x18, 0xc1, 0xd7, 0x08,                                        \/\/ IID320\n+    0xd5, 0x10, 0xc1, 0xd3, 0x04,                                                    \/\/ IID321\n+    0x62, 0xdc, 0x0c, 0x10, 0xc1, 0xc0, 0x02,                                        \/\/ IID322\n+    0x62, 0xdc, 0x7c, 0x18, 0xc1, 0xc5, 0x02,                                        \/\/ IID323\n+    0x41, 0xc1, 0xc0, 0x02,                                                          \/\/ IID324\n+    0x62, 0xdc, 0x6c, 0x14, 0xc1, 0xc0, 0x10,                                        \/\/ IID325\n+    0x62, 0xd4, 0x7c, 0x1c, 0xc1, 0xc5, 0x10,                                        \/\/ IID326\n+    0x62, 0xdc, 0x3c, 0x14, 0xd1, 0xc0,                                              \/\/ IID327\n+    0x62, 0xfc, 0x1c, 0x10, 0xc1, 0xc9, 0x10,                                        \/\/ IID328\n+    0x62, 0xdc, 0x7c, 0x18, 0xc1, 0xc8, 0x10,                                        \/\/ IID329\n+    0xd5, 0x10, 0xc1, 0xc9, 0x04,                                                    \/\/ IID330\n+    0x62, 0xf4, 0x3c, 0x14, 0xc1, 0xc9, 0x04,                                        \/\/ IID331\n+    0x62, 0xfc, 0x7c, 0x1c, 0xc1, 0xc8, 0x04,                                        \/\/ IID332\n+    0x62, 0xd4, 0x04, 0x1c, 0xc1, 0xcf, 0x02,                                        \/\/ IID333\n+    0x62, 0xdc, 0x0c, 0x18, 0xc1, 0xe3, 0x04,                                        \/\/ IID334\n+    0x62, 0xfc, 0x7c, 0x18, 0xc1, 0xe7, 0x04,                                        \/\/ IID335\n+    0xd5, 0x11, 0xc1, 0xe6, 0x04,                                                    \/\/ IID336\n+    0x62, 0xf4, 0x24, 0x14, 0xc1, 0xe2, 0x02,                                        \/\/ IID337\n+    0x62, 0xfc, 0x7c, 0x1c, 0xc1, 0xe3, 0x02,                                        \/\/ IID338\n+    0x62, 0xfc, 0x5c, 0x14, 0xc1, 0xe4, 0x02,                                        \/\/ IID339\n+    0x62, 0xfc, 0x54, 0x10, 0xd1, 0xff,                                              \/\/ IID340\n+    0x62, 0xdc, 0x7c, 0x18, 0xd1, 0xfe,                                              \/\/ IID341\n+    0xd5, 0x11, 0xc1, 0xf9, 0x02,                                                    \/\/ IID342\n+    0x62, 0xfc, 0x3c, 0x14, 0xc1, 0xfb, 0x04,                                        \/\/ IID343\n+    0x62, 0xd4, 0x7c, 0x1c, 0xc1, 0xfe, 0x04,                                        \/\/ IID344\n+    0x62, 0xdc, 0x2c, 0x14, 0xc1, 0xfa, 0x10,                                        \/\/ IID345\n+    0x62, 0xd4, 0x4c, 0x10, 0xc1, 0xe5, 0x08,                                        \/\/ IID346\n+    0x62, 0xdc, 0x7c, 0x18, 0xc1, 0xe0, 0x08,                                        \/\/ IID347\n+    0x41, 0xc1, 0xe6, 0x10,                                                          \/\/ IID348\n+    0x62, 0xdc, 0x1c, 0x14, 0xc1, 0xe1, 0x08,                                        \/\/ IID349\n+    0x62, 0xd4, 0x7c, 0x1c, 0xc1, 0xe2, 0x08,                                        \/\/ IID350\n+    0x62, 0xfc, 0x5c, 0x14, 0xd1, 0xe4,                                              \/\/ IID351\n+    0x62, 0xf4, 0x1c, 0x18, 0xc1, 0xeb, 0x04,                                        \/\/ IID352\n+    0x62, 0xfc, 0x7c, 0x18, 0xc1, 0xef, 0x04,                                        \/\/ IID353\n+    0xd5, 0x11, 0xc1, 0xec, 0x10,                                                    \/\/ IID354\n+    0x62, 0xdc, 0x3c, 0x14, 0xc1, 0xee, 0x04,                                        \/\/ IID355\n+    0x62, 0xdc, 0x7c, 0x1c, 0xc1, 0xef, 0x04,                                        \/\/ IID356\n+    0x62, 0xdc, 0x04, 0x14, 0xc1, 0xef, 0x02,                                        \/\/ IID357\n+    0x62, 0xd4, 0x5c, 0x10, 0x81, 0xea, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID358\n+    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xed, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID359\n+    0xd5, 0x11, 0x81, 0xe9, 0x00, 0x01, 0x00, 0x00,                                  \/\/ IID360\n+    0x62, 0xd4, 0x44, 0x14, 0x81, 0xec, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID361\n+    0x62, 0xfc, 0x7c, 0x1c, 0x81, 0xe8, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID362\n+    0x62, 0xdc, 0x04, 0x14, 0x83, 0xef, 0x01,                                        \/\/ IID363\n+    0x62, 0xd4, 0x34, 0x18, 0x81, 0xf7, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID364\n+    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xf5, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID365\n+    0xd5, 0x11, 0x83, 0xf4, 0x10,                                                    \/\/ IID366\n+    0x62, 0xfc, 0x14, 0x14, 0x83, 0xf6, 0x10,                                        \/\/ IID367\n@@ -1308,1 +1433,1 @@\n-    0x62, 0xf4, 0x7c, 0x18, 0xc1, 0xca, 0x04,                                        \/\/ IID325\n+    0x62, 0xf4, 0x7c, 0x1c, 0x83, 0xf3, 0x10,                                        \/\/ IID368\n@@ -1310,36 +1435,62 @@\n-    0x41, 0xc1, 0xc8, 0x10,                                                          \/\/ IID326\n-    0x62, 0xf4, 0x64, 0x14, 0xc1, 0xca, 0x10,                                        \/\/ IID327\n-    0x62, 0xdc, 0x7c, 0x1c, 0xc1, 0xcf, 0x10,                                        \/\/ IID328\n-    0x62, 0xfc, 0x4c, 0x14, 0xc1, 0xce, 0x08,                                        \/\/ IID329\n-    0x62, 0xdc, 0x44, 0x10, 0xc1, 0xe1, 0x10,                                        \/\/ IID330\n-    0x62, 0xd4, 0x7c, 0x18, 0xc1, 0xe6, 0x10,                                        \/\/ IID331\n-    0xd5, 0x11, 0xc1, 0xe7, 0x08,                                                    \/\/ IID332\n-    0x62, 0xdc, 0x0c, 0x14, 0xc1, 0xe0, 0x02,                                        \/\/ IID333\n-    0x62, 0xdc, 0x7c, 0x1c, 0xc1, 0xe5, 0x02,                                        \/\/ IID334\n-    0x62, 0xd4, 0x3c, 0x1c, 0xc1, 0xe0, 0x02,                                        \/\/ IID335\n-    0x62, 0xdc, 0x6c, 0x10, 0xc1, 0xf8, 0x10,                                        \/\/ IID336\n-    0x62, 0xd4, 0x7c, 0x18, 0xc1, 0xfd, 0x10,                                        \/\/ IID337\n-    0xd5, 0x11, 0xd1, 0xf8,                                                          \/\/ IID338\n-    0x62, 0xfc, 0x1c, 0x14, 0xc1, 0xf9, 0x10,                                        \/\/ IID339\n-    0x62, 0xdc, 0x7c, 0x1c, 0xc1, 0xf8, 0x10,                                        \/\/ IID340\n-    0x62, 0xfc, 0x74, 0x14, 0xc1, 0xf9, 0x04,                                        \/\/ IID341\n-    0x62, 0xf4, 0x3c, 0x10, 0xc1, 0xe1, 0x04,                                        \/\/ IID342\n-    0x62, 0xfc, 0x7c, 0x18, 0xc1, 0xe0, 0x04,                                        \/\/ IID343\n-    0x41, 0xc1, 0xe7, 0x02,                                                          \/\/ IID344\n-    0x62, 0xdc, 0x0c, 0x1c, 0xc1, 0xe3, 0x04,                                        \/\/ IID345\n-    0x62, 0xfc, 0x7c, 0x1c, 0xc1, 0xe7, 0x04,                                        \/\/ IID346\n-    0x62, 0xdc, 0x0c, 0x14, 0xc1, 0xe6, 0x04,                                        \/\/ IID347\n-    0x62, 0xf4, 0x24, 0x10, 0xc1, 0xea, 0x02,                                        \/\/ IID348\n-    0x62, 0xfc, 0x7c, 0x18, 0xc1, 0xeb, 0x02,                                        \/\/ IID349\n-    0xd5, 0x10, 0xc1, 0xec, 0x02,                                                    \/\/ IID350\n-    0x62, 0xfc, 0x54, 0x14, 0xd1, 0xef,                                              \/\/ IID351\n-    0x62, 0xdc, 0x7c, 0x1c, 0xd1, 0xee,                                              \/\/ IID352\n-    0x62, 0xdc, 0x34, 0x14, 0xc1, 0xe9, 0x02,                                        \/\/ IID353\n-    0x62, 0xfc, 0x3c, 0x10, 0x81, 0xeb, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID354\n-    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xee, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID355\n-    0xd5, 0x10, 0x81, 0xee, 0x00, 0x00, 0x00, 0x10,                                  \/\/ IID356\n-    0x62, 0xdc, 0x3c, 0x14, 0x81, 0xe8, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID357\n-    0x62, 0xd4, 0x7c, 0x1c, 0x81, 0xee, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID358\n-    0x62, 0xdc, 0x1c, 0x14, 0x81, 0xec, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID359\n-    0x62, 0xfc, 0x64, 0x18, 0x81, 0xf4, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID360\n-    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xf7, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID361\n+    0x62, 0xd4, 0x3c, 0x1c, 0x83, 0xf0, 0x10,                                        \/\/ IID369\n+    0x62, 0xd4, 0x7c, 0x10, 0x81, 0xed, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID370\n+    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xec, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID371\n+    0xd5, 0x10, 0x81, 0xe9, 0x00, 0x00, 0x00, 0x04,                                  \/\/ IID372\n+    0x62, 0xdc, 0x4c, 0x14, 0x81, 0xea, 0x00, 0x00, 0x00, 0x40,                      \/\/ IID373\n+    0x62, 0xd4, 0x7c, 0x1c, 0x81, 0xea, 0x00, 0x00, 0x00, 0x40,                      \/\/ IID374\n+    0x62, 0xd4, 0x24, 0x1c, 0x81, 0xeb, 0x00, 0x00, 0x00, 0x40,                      \/\/ IID375\n+    0x62, 0x1c, 0x64, 0x10, 0x03, 0xa4, 0x06, 0x73, 0x0a, 0x1a, 0x6a,                \/\/ IID376\n+    0xd5, 0x74, 0x03, 0xb4, 0x9a, 0xcf, 0x90, 0xf9, 0x25,                            \/\/ IID377\n+    0x62, 0x6c, 0x70, 0x1c, 0x03, 0x8c, 0x03, 0xbc, 0x5d, 0x2d, 0x48,                \/\/ IID378\n+    0x62, 0x54, 0x34, 0x1c, 0x03, 0x8b, 0x01, 0xee, 0xd5, 0x43,                      \/\/ IID379\n+    0x62, 0xac, 0x74, 0x18, 0x23, 0xbc, 0xbd, 0xbc, 0xc2, 0x25, 0x28,                \/\/ IID380\n+    0xd5, 0x47, 0x23, 0x9c, 0xfd, 0x6b, 0x47, 0x97, 0xed,                            \/\/ IID381\n+    0x62, 0xac, 0x30, 0x1c, 0x23, 0xbc, 0x36, 0x45, 0x53, 0xea, 0xf8,                \/\/ IID382\n+    0x62, 0xdc, 0x60, 0x1c, 0x23, 0x9c, 0x84, 0xee, 0x23, 0x02, 0x0b,                \/\/ IID383\n+    0x62, 0x04, 0x00, 0x18, 0xaf, 0xac, 0x67, 0x97, 0x85, 0xd6, 0xe0,                \/\/ IID384\n+    0xd5, 0xd0, 0xaf, 0x8c, 0x5f, 0x45, 0x75, 0xdc, 0x0a,                            \/\/ IID385\n+    0x62, 0x74, 0x20, 0x14, 0xaf, 0x8c, 0xb2, 0x9f, 0xf0, 0x26, 0xbc,                \/\/ IID386\n+    0x62, 0xdc, 0x60, 0x1c, 0xaf, 0x9c, 0xf4, 0xd9, 0x65, 0x62, 0xae,                \/\/ IID387\n+    0x62, 0xd4, 0x74, 0x10, 0x0b, 0x8e, 0x23, 0x22, 0x64, 0x10,                      \/\/ IID388\n+    0xd5, 0x55, 0x0b, 0x97, 0x46, 0x7c, 0x65, 0x85,                                  \/\/ IID389\n+    0x62, 0x84, 0x04, 0x1c, 0x0b, 0xb4, 0xa4, 0x97, 0x69, 0x3b, 0x74,                \/\/ IID390\n+    0x62, 0x74, 0x38, 0x1c, 0x0b, 0x84, 0xf2, 0x24, 0xeb, 0x7b, 0xa7,                \/\/ IID391\n+    0x62, 0x0c, 0x74, 0x18, 0x2b, 0xa4, 0xae, 0xe5, 0x10, 0x93, 0x0e,                \/\/ IID392\n+    0xd5, 0x13, 0x2b, 0x8c, 0x56, 0x2f, 0x91, 0xf8, 0xe4,                            \/\/ IID393\n+    0x62, 0xcc, 0x34, 0x1c, 0x2b, 0xae, 0xd3, 0xff, 0x79, 0x2f,                      \/\/ IID394\n+    0x62, 0xa4, 0x7c, 0x14, 0x2b, 0x84, 0xb2, 0xc1, 0x71, 0x5d, 0x67,                \/\/ IID395\n+    0x62, 0x24, 0x20, 0x10, 0x33, 0xa4, 0x93, 0x7f, 0xf4, 0x3d, 0x87,                \/\/ IID396\n+    0xd5, 0x35, 0x33, 0xb4, 0x5f, 0x34, 0xae, 0x0d, 0xb0,                            \/\/ IID397\n+    0x62, 0xc4, 0x58, 0x14, 0x33, 0x94, 0x85, 0x1e, 0x39, 0x10, 0xe6,                \/\/ IID398\n+    0x62, 0xc4, 0x60, 0x14, 0x33, 0x9c, 0x7d, 0x56, 0x27, 0xe4, 0xd2,                \/\/ IID399\n+    0x62, 0xa4, 0x10, 0x10, 0x32, 0x8c, 0xaa, 0x84, 0x3e, 0x57, 0x66,                \/\/ IID400\n+    0xd5, 0x73, 0x32, 0xb4, 0xc8, 0x3f, 0xa9, 0x94, 0x3a,                            \/\/ IID401\n+    0x62, 0x44, 0x10, 0x1c, 0x32, 0xac, 0x7f, 0x32, 0x35, 0xd4, 0x76,                \/\/ IID402\n+    0x62, 0x14, 0x04, 0x1c, 0x32, 0xbc, 0x0d, 0xe6, 0x92, 0xb1, 0xb8,                \/\/ IID403\n+    0x62, 0xec, 0x75, 0x10, 0x33, 0x84, 0x17, 0x91, 0xa2, 0x62, 0x05,                \/\/ IID404\n+    0x66, 0xd5, 0x76, 0x33, 0xac, 0xe2, 0x0e, 0x98, 0xe6, 0xab,                      \/\/ IID405\n+    0x62, 0x54, 0x25, 0x14, 0x33, 0x9a, 0x5a, 0x1c, 0x91, 0x0a,                      \/\/ IID406\n+    0x62, 0x4c, 0x01, 0x14, 0x33, 0xbc, 0x9e, 0x26, 0x5c, 0x09, 0xff,                \/\/ IID407\n+    0x62, 0x7c, 0x1c, 0x18, 0x03, 0xef,                                              \/\/ IID408\n+    0xd5, 0x54, 0x03, 0xe4,                                                          \/\/ IID409\n+    0xd5, 0x51, 0x03, 0xe0,                                                          \/\/ IID410\n+    0x62, 0x54, 0x24, 0x1c, 0x03, 0xd7,                                              \/\/ IID411\n+    0x62, 0xec, 0x64, 0x14, 0x03, 0xdc,                                              \/\/ IID412\n+    0x62, 0x7c, 0x44, 0x14, 0x03, 0xff,                                              \/\/ IID413\n+    0x62, 0xcc, 0x2c, 0x10, 0x23, 0xd8,                                              \/\/ IID414\n+    0xd5, 0x51, 0x23, 0xfc,                                                          \/\/ IID415\n+    0x45, 0x23, 0xdd,                                                                \/\/ IID416\n+    0x62, 0xdc, 0x14, 0x1c, 0x23, 0xd7,                                              \/\/ IID417\n+    0x62, 0xec, 0x44, 0x14, 0x23, 0xff,                                              \/\/ IID418\n+    0x62, 0x44, 0x34, 0x1c, 0x23, 0xd9,                                              \/\/ IID419\n+    0x62, 0xcc, 0x54, 0x10, 0xaf, 0xe0,                                              \/\/ IID420\n+    0xd5, 0xd1, 0xaf, 0xed,                                                          \/\/ IID421\n+    0x41, 0x0f, 0xaf, 0xdb,                                                          \/\/ IID422\n+    0x62, 0xf4, 0x54, 0x14, 0xaf, 0xd9,                                              \/\/ IID423\n+    0x62, 0x6c, 0x04, 0x14, 0xaf, 0xfd,                                              \/\/ IID424\n+    0x62, 0x44, 0x04, 0x1c, 0xaf, 0xcf,                                              \/\/ IID425\n+    0x62, 0xcc, 0x0d, 0x10, 0x0b, 0xf9,                                              \/\/ IID426\n+    0x66, 0xd5, 0x40, 0x0b, 0xd1,                                                    \/\/ IID427\n+    0x66, 0x44, 0x0b, 0xd1,                                                          \/\/ IID428\n+    0x62, 0xcc, 0x05, 0x14, 0x0b, 0xea,                                              \/\/ IID429\n+    0x62, 0xec, 0x55, 0x14, 0x0b, 0xeb,                                              \/\/ IID430\n@@ -1347,1 +1498,1 @@\n-    0x81, 0xf3, 0x00, 0x10, 0x00, 0x00,                                              \/\/ IID362\n+    0x62, 0xf4, 0x6d, 0x1c, 0x0b, 0xda,                                              \/\/ IID431\n@@ -1349,556 +1500,573 @@\n-    0x62, 0xdc, 0x3c, 0x14, 0x81, 0xf6, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID363\n-    0x62, 0xdc, 0x7c, 0x1c, 0x81, 0xf7, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID364\n-    0x62, 0xdc, 0x04, 0x14, 0x81, 0xf7, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID365\n-    0x62, 0xd4, 0x5c, 0x10, 0x81, 0xea, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID366\n-    0x62, 0xd4, 0x7c, 0x18, 0x81, 0xed, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID367\n-    0xd5, 0x11, 0x81, 0xe9, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID368\n-    0x62, 0xd4, 0x44, 0x14, 0x81, 0xec, 0x00, 0x00, 0x00, 0x40,                      \/\/ IID369\n-    0x62, 0xfc, 0x7c, 0x1c, 0x81, 0xe8, 0x00, 0x00, 0x00, 0x40,                      \/\/ IID370\n-    0x62, 0xdc, 0x04, 0x14, 0x81, 0xef, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID371\n-    0x62, 0x54, 0x74, 0x10, 0x03, 0xa9, 0x98, 0x2f, 0xef, 0x7f,                      \/\/ IID372\n-    0x62, 0x7c, 0x14, 0x14, 0x03, 0x86, 0x54, 0xf5, 0x08, 0xb2,                      \/\/ IID373\n-    0x62, 0x84, 0x14, 0x18, 0x23, 0x8c, 0xfc, 0x02, 0xa9, 0xa8, 0x50,                \/\/ IID374\n-    0x62, 0x0c, 0x4c, 0x14, 0x23, 0x8c, 0x92, 0x54, 0x27, 0xea, 0x70,                \/\/ IID375\n-    0x62, 0x1c, 0x64, 0x10, 0xaf, 0xa4, 0x06, 0x73, 0x0a, 0x1a, 0x6a,                \/\/ IID376\n-    0x62, 0xec, 0x08, 0x14, 0xaf, 0x94, 0x9a, 0x39, 0xd7, 0x32, 0x80,                \/\/ IID377\n-    0x62, 0x0c, 0x7c, 0x10, 0x0b, 0xbc, 0xd9, 0xbc, 0x5d, 0x2d, 0x48,                \/\/ IID378\n-    0x62, 0x44, 0x34, 0x1c, 0x0b, 0x9b, 0x01, 0xee, 0xd5, 0x43,                      \/\/ IID379\n-    0x62, 0xac, 0x74, 0x18, 0x2b, 0xbc, 0xbd, 0xbc, 0xc2, 0x25, 0x28,                \/\/ IID380\n-    0x62, 0x84, 0x24, 0x14, 0x2b, 0xb4, 0x7d, 0xa7, 0x0d, 0x1f, 0x77,                \/\/ IID381\n-    0x62, 0x44, 0x30, 0x18, 0x33, 0xb4, 0xf1, 0x72, 0x37, 0x29, 0xb5,                \/\/ IID382\n-    0x62, 0xa4, 0x20, 0x1c, 0x33, 0x84, 0xa3, 0xee, 0x23, 0x02, 0x0b,                \/\/ IID383\n-    0x62, 0x04, 0x00, 0x18, 0x32, 0xac, 0x67, 0x97, 0x85, 0xd6, 0xe0,                \/\/ IID384\n-    0x62, 0x6c, 0x74, 0x14, 0x32, 0xb4, 0x5f, 0x45, 0x75, 0xdc, 0x0a,                \/\/ IID385\n-    0x62, 0x74, 0x21, 0x10, 0x33, 0x8c, 0xb2, 0x9f, 0xf0, 0x26, 0xbc,                \/\/ IID386\n-    0x62, 0xcc, 0x61, 0x1c, 0x33, 0xb4, 0x34, 0x4f, 0x5f, 0xcf, 0x82,                \/\/ IID387\n-    0x62, 0x64, 0x0c, 0x18, 0x03, 0xc1,                                              \/\/ IID388\n-    0xd5, 0x14, 0x03, 0xc1,                                                          \/\/ IID389\n-    0x62, 0x44, 0x2c, 0x14, 0x03, 0xc4,                                              \/\/ IID390\n-    0x62, 0x6c, 0x3c, 0x14, 0x03, 0xc7,                                              \/\/ IID391\n-    0x62, 0x4c, 0x14, 0x18, 0x23, 0xd7,                                              \/\/ IID392\n-    0x45, 0x23, 0xd8,                                                                \/\/ IID393\n-    0x62, 0xc4, 0x74, 0x1c, 0x23, 0xdf,                                              \/\/ IID394\n-    0x62, 0x54, 0x1c, 0x1c, 0x23, 0xe4,                                              \/\/ IID395\n-    0x62, 0xec, 0x4c, 0x10, 0xaf, 0xe3,                                              \/\/ IID396\n-    0x44, 0x0f, 0xaf, 0xc2,                                                          \/\/ IID397\n-    0x62, 0x6c, 0x4c, 0x14, 0xaf, 0xdf,                                              \/\/ IID398\n-    0x62, 0x7c, 0x34, 0x1c, 0xaf, 0xca,                                              \/\/ IID399\n-    0x62, 0x44, 0x75, 0x18, 0x0b, 0xf5,                                              \/\/ IID400\n-    0x66, 0xd5, 0x54, 0x0b, 0xe3,                                                    \/\/ IID401\n-    0x62, 0x4c, 0x1d, 0x1c, 0x0b, 0xf3,                                              \/\/ IID402\n-    0x62, 0x7c, 0x3d, 0x1c, 0x0b, 0xc6,                                              \/\/ IID403\n-    0x62, 0xdc, 0x7c, 0x10, 0x0b, 0xce,                                              \/\/ IID404\n-    0xd5, 0x15, 0x0b, 0xd1,                                                          \/\/ IID405\n-    0x62, 0xec, 0x04, 0x1c, 0x0b, 0xc9,                                              \/\/ IID406\n-    0x62, 0x5c, 0x34, 0x1c, 0x0b, 0xce,                                              \/\/ IID407\n-    0x62, 0x7c, 0x5c, 0x10, 0xa5, 0xc5,                                              \/\/ IID408\n-    0xd5, 0x95, 0xa5, 0xf2,                                                          \/\/ IID409\n-    0x62, 0x74, 0x7c, 0x14, 0xa5, 0xf2,                                              \/\/ IID410\n-    0x62, 0x7c, 0x64, 0x14, 0xa5, 0xc3,                                              \/\/ IID411\n-    0x62, 0x64, 0x24, 0x10, 0xad, 0xd3,                                              \/\/ IID412\n-    0xd5, 0xd1, 0xad, 0xdc,                                                          \/\/ IID413\n-    0x62, 0x54, 0x74, 0x1c, 0xad, 0xf3,                                              \/\/ IID414\n-    0x62, 0xcc, 0x04, 0x14, 0xad, 0xdf,                                              \/\/ IID415\n-    0x62, 0x5c, 0x2c, 0x10, 0x2b, 0xe9,                                              \/\/ IID416\n-    0xd5, 0x45, 0x2b, 0xc3,                                                          \/\/ IID417\n-    0x62, 0xc4, 0x6c, 0x14, 0x2b, 0xe5,                                              \/\/ IID418\n-    0x62, 0xec, 0x7c, 0x14, 0x2b, 0xc2,                                              \/\/ IID419\n-    0x62, 0xc4, 0x64, 0x10, 0x33, 0xc8,                                              \/\/ IID420\n-    0xd5, 0x41, 0x33, 0xdd,                                                          \/\/ IID421\n-    0x62, 0x54, 0x44, 0x14, 0x33, 0xef,                                              \/\/ IID422\n-    0x62, 0x5c, 0x24, 0x1c, 0x33, 0xdd,                                              \/\/ IID423\n-    0x62, 0xec, 0x14, 0x10, 0x24, 0xc9, 0x01,                                        \/\/ IID424\n-    0xd5, 0xd4, 0xa4, 0xc6, 0x04,                                                    \/\/ IID425\n-    0x62, 0x5c, 0x3c, 0x1c, 0x24, 0xdc, 0x10,                                        \/\/ IID426\n-    0x62, 0xc4, 0x04, 0x1c, 0x24, 0xff, 0x04,                                        \/\/ IID427\n-    0x62, 0xec, 0x14, 0x10, 0x2c, 0xc6, 0x04,                                        \/\/ IID428\n-    0x45, 0x0f, 0xac, 0xcd, 0x04,                                                    \/\/ IID429\n-    0x62, 0x7c, 0x04, 0x1c, 0x2c, 0xe5, 0x02,                                        \/\/ IID430\n-    0x62, 0xec, 0x74, 0x14, 0x2c, 0xf9, 0x02,                                        \/\/ IID431\n-    0x62, 0xcc, 0x6c, 0x18, 0x40, 0xc5,                                              \/\/ IID432\n-    0xd5, 0x94, 0x40, 0xd5,                                                          \/\/ IID433\n-    0x62, 0x6c, 0x74, 0x10, 0x41, 0xea,                                              \/\/ IID434\n-    0xd5, 0xd5, 0x41, 0xe0,                                                          \/\/ IID435\n-    0x62, 0xcc, 0x2c, 0x18, 0x42, 0xe3,                                              \/\/ IID436\n-    0x45, 0x0f, 0x42, 0xd6,                                                          \/\/ IID437\n-    0x62, 0x64, 0x24, 0x18, 0x43, 0xd9,                                              \/\/ IID438\n-    0xd5, 0xc1, 0x43, 0xf7,                                                          \/\/ IID439\n-    0x62, 0x6c, 0x04, 0x10, 0x44, 0xf3,                                              \/\/ IID440\n-    0xd5, 0xd1, 0x44, 0xda,                                                          \/\/ IID441\n-    0x62, 0x5c, 0x54, 0x10, 0x45, 0xf2,                                              \/\/ IID442\n-    0xd5, 0xc1, 0x45, 0xe7,                                                          \/\/ IID443\n-    0x62, 0x7c, 0x1c, 0x18, 0x46, 0xef,                                              \/\/ IID444\n-    0xd5, 0xd4, 0x46, 0xe4,                                                          \/\/ IID445\n-    0x62, 0x44, 0x5c, 0x10, 0x47, 0xc3,                                              \/\/ IID446\n-    0x45, 0x0f, 0x47, 0xd7,                                                          \/\/ IID447\n-    0x62, 0xec, 0x64, 0x10, 0x48, 0xe7,                                              \/\/ IID448\n-    0xd5, 0x95, 0x48, 0xfa,                                                          \/\/ IID449\n-    0x62, 0x6c, 0x64, 0x10, 0x49, 0xc7,                                              \/\/ IID450\n-    0xd5, 0xc5, 0x49, 0xe3,                                                          \/\/ IID451\n-    0x44, 0x0f, 0x4a, 0xea,                                                          \/\/ IID452\n-    0xd5, 0xd4, 0x4a, 0xff,                                                          \/\/ IID453\n-    0x62, 0x5c, 0x44, 0x10, 0x4b, 0xcb,                                              \/\/ IID454\n-    0xd5, 0xd0, 0x4b, 0xec,                                                          \/\/ IID455\n-    0x62, 0xcc, 0x3c, 0x10, 0x4c, 0xed,                                              \/\/ IID456\n-    0x41, 0x0f, 0x4c, 0xdb,                                                          \/\/ IID457\n-    0x62, 0xf4, 0x54, 0x10, 0x4d, 0xd9,                                              \/\/ IID458\n-    0xd5, 0xd4, 0x4d, 0xfd,                                                          \/\/ IID459\n-    0x62, 0x4c, 0x04, 0x18, 0x4e, 0xce,                                              \/\/ IID460\n-    0xd5, 0xd1, 0x4e, 0xf9,                                                          \/\/ IID461\n-    0x62, 0xd4, 0x6c, 0x10, 0x4f, 0xca,                                              \/\/ IID462\n-    0xd5, 0x91, 0x4f, 0xcf,                                                          \/\/ IID463\n-    0x62, 0xcc, 0x54, 0x10, 0x40, 0x9a, 0x8d, 0xf7, 0xd6, 0x91,                      \/\/ IID464\n-    0x62, 0xec, 0x3c, 0x10, 0x41, 0x9c, 0x0e, 0x9a, 0x5f, 0xf8, 0x11,                \/\/ IID465\n-    0x62, 0x6c, 0x74, 0x10, 0x42, 0x84, 0x24, 0x5e, 0x77, 0x4d, 0x53,                \/\/ IID466\n-    0x62, 0xec, 0x5c, 0x10, 0x43, 0x94, 0x24, 0x33, 0xb1, 0x36, 0xb8,                \/\/ IID467\n-    0x62, 0x7c, 0x34, 0x18, 0x44, 0xaf, 0x9d, 0x3a, 0x7c, 0xb4,                      \/\/ IID468\n-    0x62, 0x0c, 0x24, 0x18, 0x45, 0x8c, 0x70, 0x51, 0xf8, 0x9a, 0xbb,                \/\/ IID469\n-    0x62, 0x0c, 0x0c, 0x18, 0x46, 0x84, 0xae, 0x1d, 0x66, 0xd0, 0x00,                \/\/ IID470\n-    0x62, 0x04, 0x10, 0x18, 0x47, 0x8c, 0xde, 0x03, 0x14, 0x7e, 0x04,                \/\/ IID471\n-    0x62, 0xe4, 0x3c, 0x10, 0x48, 0x9c, 0xd1, 0xe8, 0xac, 0xb5, 0x9b,                \/\/ IID472\n-    0x62, 0x6c, 0x28, 0x10, 0x49, 0x84, 0x36, 0x46, 0x24, 0x35, 0x70,                \/\/ IID473\n-    0x62, 0x04, 0x60, 0x10, 0x4a, 0x94, 0xb0, 0x5c, 0x2f, 0xa1, 0x78,                \/\/ IID474\n-    0x62, 0x5c, 0x10, 0x10, 0x4b, 0x9c, 0x21, 0x3a, 0x30, 0xa8, 0x27,                \/\/ IID475\n-    0x62, 0x4c, 0x48, 0x10, 0x4c, 0x84, 0x43, 0x10, 0x1a, 0x54, 0x02,                \/\/ IID476\n-    0x62, 0x54, 0x00, 0x10, 0x4d, 0xbc, 0xc0, 0x51, 0x32, 0x8e, 0x55,                \/\/ IID477\n-    0x62, 0x84, 0x24, 0x10, 0x4e, 0x94, 0x10, 0x49, 0x78, 0xe6, 0xb8,                \/\/ IID478\n-    0x62, 0xec, 0x68, 0x10, 0x4f, 0x84, 0x9a, 0xe2, 0x17, 0xf5, 0xed,                \/\/ IID479\n-    0xd5, 0x19, 0x13, 0xdf,                                                          \/\/ IID480\n-    0xd5, 0x5d, 0x3b, 0xf7,                                                          \/\/ IID481\n-    0xd5, 0xdd, 0xaf, 0xec,                                                          \/\/ IID482\n-    0xf3, 0xd5, 0xcd, 0xb8, 0xca,                                                    \/\/ IID483\n-    0xd5, 0x5c, 0x1b, 0xc4,                                                          \/\/ IID484\n-    0xd5, 0x48, 0x2b, 0xc2,                                                          \/\/ IID485\n-    0xf3, 0xd5, 0xdd, 0xbc, 0xd4,                                                    \/\/ IID486\n-    0xf3, 0xd5, 0xcd, 0xbd, 0xe1,                                                    \/\/ IID487\n-    0xd5, 0x59, 0x03, 0xe0,                                                          \/\/ IID488\n-    0xd5, 0x5d, 0x23, 0xc5,                                                          \/\/ IID489\n-    0xd5, 0x59, 0x0b, 0xfb,                                                          \/\/ IID490\n-    0x4d, 0x33, 0xfc,                                                                \/\/ IID491\n-    0xd5, 0x58, 0x8b, 0xd3,                                                          \/\/ IID492\n-    0xd5, 0xcc, 0xbc, 0xf9,                                                          \/\/ IID493\n-    0x4d, 0x0f, 0xbd, 0xcd,                                                          \/\/ IID494\n-    0xd5, 0x98, 0xa3, 0xcc,                                                          \/\/ IID495\n-    0xd5, 0x1c, 0x87, 0xc5,                                                          \/\/ IID496\n-    0xd5, 0x4d, 0x85, 0xc6,                                                          \/\/ IID497\n-    0xd5, 0x6c, 0x01, 0xac, 0xb9, 0x4d, 0x6c, 0xf0, 0x4f,                            \/\/ IID498\n-    0xd5, 0x5f, 0x21, 0x94, 0x50, 0x77, 0x5e, 0x26, 0x8a,                            \/\/ IID499\n-    0xd5, 0x48, 0x39, 0x8c, 0x1b, 0x9c, 0xd5, 0x33, 0x40,                            \/\/ IID500\n-    0xd5, 0x5a, 0x09, 0x94, 0xe6, 0x83, 0xcb, 0x6c, 0xc7,                            \/\/ IID501\n-    0xd5, 0x3c, 0x31, 0xa4, 0xfc, 0x60, 0x15, 0x31, 0x4b,                            \/\/ IID502\n-    0xd5, 0x6f, 0x29, 0xac, 0xa2, 0x57, 0x26, 0x3a, 0x5c,                            \/\/ IID503\n-    0xd5, 0x6b, 0x89, 0xb4, 0xcd, 0x3f, 0x6f, 0x3d, 0x1a,                            \/\/ IID504\n-    0xd5, 0xfe, 0xc1, 0x8c, 0xc1, 0x28, 0x24, 0x52, 0xca,                            \/\/ IID505\n-    0xd5, 0x19, 0x81, 0xa1, 0xc3, 0x84, 0x21, 0x63, 0x00, 0x00, 0x00, 0x01,          \/\/ IID506\n-    0x4b, 0x81, 0x84, 0x2d, 0x3a, 0x15, 0x8d, 0xc6, 0x00, 0x00, 0x00, 0x01,          \/\/ IID507\n-    0x49, 0x81, 0xb9, 0xfa, 0x37, 0x4b, 0xec, 0x00, 0x10, 0x00, 0x00,                \/\/ IID508\n-    0xd5, 0x19, 0xd1, 0xbf, 0x51, 0xf5, 0xa7, 0x4f,                                  \/\/ IID509\n-    0xd5, 0x3a, 0xd1, 0xa4, 0xbd, 0x32, 0x82, 0xaa, 0x31,                            \/\/ IID510\n-    0xd5, 0x3b, 0x81, 0x9c, 0xb8, 0x49, 0xc7, 0x9a, 0xb9, 0x00, 0x00, 0x00, 0x10,    \/\/ IID511\n-    0xd5, 0x39, 0xc1, 0xac, 0x34, 0x4f, 0x7a, 0x01, 0xc1, 0x02,                      \/\/ IID512\n-    0xd5, 0x18, 0x81, 0xa8, 0x15, 0x5c, 0x76, 0xec, 0x00, 0x00, 0x10, 0x00,          \/\/ IID513\n-    0xd5, 0x1b, 0x83, 0xb4, 0x05, 0x15, 0x26, 0x02, 0x1d, 0x10,                      \/\/ IID514\n-    0xd5, 0x2b, 0x83, 0x8c, 0x64, 0x1e, 0x67, 0x37, 0xcb, 0x01,                      \/\/ IID515\n-    0xd5, 0x2a, 0xc7, 0x84, 0x81, 0xf8, 0x14, 0xbb, 0xe9, 0x00, 0x01, 0x00, 0x00,    \/\/ IID516\n-    0xd5, 0x19, 0xf7, 0x85, 0xf5, 0x76, 0xdc, 0x82, 0x00, 0x00, 0xff, 0xff,          \/\/ IID517\n-    0xd5, 0x68, 0x03, 0xbc, 0x99, 0x54, 0xc6, 0xea, 0x70,                            \/\/ IID518\n-    0xd5, 0x1b, 0x23, 0x94, 0x38, 0x57, 0x25, 0xb2, 0xdf,                            \/\/ IID519\n-    0xd5, 0x1a, 0x3b, 0x94, 0xdf, 0xbd, 0x30, 0xc9, 0x32,                            \/\/ IID520\n-    0xf3, 0xd5, 0xcc, 0xbd, 0xa2, 0x71, 0x3d, 0xcc, 0xab,                            \/\/ IID521\n-    0xd5, 0x5a, 0x0b, 0xb4, 0x73, 0xc8, 0x82, 0x39, 0xd3,                            \/\/ IID522\n-    0x4d, 0x13, 0x92, 0x9f, 0xc5, 0xd7, 0x03,                                        \/\/ IID523\n-    0x4f, 0x0f, 0xaf, 0x94, 0xc0, 0xd3, 0x79, 0x9e, 0xf1,                            \/\/ IID524\n-    0xf3, 0xd5, 0xd9, 0xb8, 0xbd, 0x93, 0x26, 0x81, 0x88,                            \/\/ IID525\n-    0xd5, 0x28, 0x1b, 0x8c, 0x5b, 0xcb, 0x01, 0xc6, 0x53,                            \/\/ IID526\n-    0xd5, 0x1c, 0x2b, 0xb4, 0x19, 0x8d, 0x0f, 0x74, 0x89,                            \/\/ IID527\n-    0xf3, 0xd5, 0xed, 0xbc, 0xac, 0x5a, 0x3c, 0x8d, 0xc9, 0x30,                      \/\/ IID528\n-    0xd5, 0x3e, 0x33, 0x94, 0x18, 0xfe, 0x29, 0xf7, 0xc2,                            \/\/ IID529\n-    0xd5, 0x7b, 0x8b, 0x94, 0xe4, 0x6f, 0x53, 0x04, 0x9d,                            \/\/ IID530\n-    0x48, 0x8d, 0x99, 0xa5, 0x02, 0x06, 0x45,                                        \/\/ IID531\n-    0xf2, 0xd5, 0xbf, 0x2c, 0xa4, 0x3e, 0xd0, 0x59, 0x67, 0x98,                      \/\/ IID532\n-    0xd5, 0x5f, 0x87, 0xbc, 0x50, 0x13, 0xed, 0x98, 0x8f,                            \/\/ IID533\n-    0xd5, 0x2d, 0x85, 0xb4, 0xe5, 0xf2, 0x81, 0x10, 0x17,                            \/\/ IID534\n-    0xd5, 0x19, 0x83, 0xc7, 0x10,                                                    \/\/ IID535\n-    0xd5, 0x19, 0x83, 0xe1, 0x10,                                                    \/\/ IID536\n-    0xd5, 0x18, 0x81, 0xd7, 0x00, 0x01, 0x00, 0x00,                                  \/\/ IID537\n-    0xd5, 0x18, 0x81, 0xfb, 0x00, 0x00, 0x00, 0x10,                                  \/\/ IID538\n-    0xd5, 0x19, 0xd1, 0xd7,                                                          \/\/ IID539\n-    0xd5, 0x18, 0xd1, 0xd9,                                                          \/\/ IID540\n-    0xd5, 0x19, 0xc1, 0xc1, 0x02,                                                    \/\/ IID541\n-    0xd5, 0x18, 0xc1, 0xc9, 0x04,                                                    \/\/ IID542\n-    0xd5, 0x19, 0xd1, 0xfc,                                                          \/\/ IID543\n-    0x49, 0xc1, 0xe7, 0x04,                                                          \/\/ IID544\n-    0x48, 0x81, 0xdb, 0x00, 0x00, 0x01, 0x00,                                        \/\/ IID545\n-    0xd5, 0x18, 0xd1, 0xe5,                                                          \/\/ IID546\n-    0x49, 0xd1, 0xea,                                                                \/\/ IID547\n-    0x49, 0x83, 0xee, 0x10,                                                          \/\/ IID548\n-    0xd5, 0x18, 0x81, 0xf2, 0x00, 0x00, 0x00, 0x10,                                  \/\/ IID549\n-    0xd5, 0x18, 0xc7, 0xc7, 0x10, 0x00, 0x00, 0x00,                                  \/\/ IID550\n-    0x49, 0xbc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID551\n-    0x49, 0x0f, 0xba, 0xe6, 0x04,                                                    \/\/ IID552\n-    0xd5, 0x19, 0xf7, 0xc0, 0x00, 0xf0, 0xff, 0xff,                                  \/\/ IID553\n-    0xd5, 0x18, 0x81, 0xcb, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID554\n-    0x48, 0x81, 0xe9, 0x00, 0x00, 0x00, 0x10,                                        \/\/ IID555\n-    0xd5, 0x98, 0x40, 0x94, 0xdb, 0xc4, 0xc8, 0x11, 0x02,                            \/\/ IID556\n-    0xd5, 0x98, 0x41, 0x9d, 0x43, 0x77, 0x26, 0x49,                                  \/\/ IID557\n-    0xd5, 0xeb, 0x42, 0xac, 0x60, 0xba, 0xd6, 0x73, 0xb3,                            \/\/ IID558\n-    0xd5, 0xbd, 0x43, 0xa4, 0x22, 0x64, 0x07, 0xb2, 0xd9,                            \/\/ IID559\n-    0xd5, 0xdb, 0x44, 0x8c, 0x8c, 0x6b, 0x19, 0x97, 0x34,                            \/\/ IID560\n-    0xd5, 0xad, 0x45, 0xac, 0x7f, 0x67, 0xf6, 0x5c, 0xd8,                            \/\/ IID561\n-    0xd5, 0xd8, 0x46, 0xb6, 0x05, 0xab, 0x39, 0x0f,                                  \/\/ IID562\n-    0xd5, 0xba, 0x47, 0x8c, 0xd6, 0xb4, 0x6a, 0x73, 0xfb,                            \/\/ IID563\n-    0xd5, 0xfc, 0x48, 0x8c, 0x2b, 0x0b, 0x5b, 0x40, 0x0e,                            \/\/ IID564\n-    0xd5, 0xbe, 0x49, 0xa4, 0xeb, 0xb5, 0xfb, 0x9d, 0x88,                            \/\/ IID565\n-    0xd5, 0x9b, 0x4a, 0x9c, 0x56, 0xdd, 0x7c, 0x86, 0xe6,                            \/\/ IID566\n-    0xd5, 0xfb, 0x4b, 0xac, 0x38, 0xd5, 0x9a, 0xce, 0xa8,                            \/\/ IID567\n-    0xd5, 0xcb, 0x4c, 0x94, 0x50, 0x77, 0x41, 0xec, 0xa9,                            \/\/ IID568\n-    0xd5, 0xfc, 0x4d, 0xa4, 0xed, 0xc4, 0xfd, 0xa0, 0x65,                            \/\/ IID569\n-    0xd5, 0xe9, 0x4e, 0xbc, 0x13, 0xf4, 0x0e, 0xe5, 0xe2,                            \/\/ IID570\n-    0xd5, 0xda, 0x4f, 0xb4, 0x62, 0x38, 0x1c, 0x5f, 0x1a,                            \/\/ IID571\n-    0xd5, 0x10, 0xff, 0xd7,                                                          \/\/ IID572\n-    0xd5, 0x19, 0xf7, 0xf6,                                                          \/\/ IID573\n-    0xd5, 0x18, 0xf7, 0xfb,                                                          \/\/ IID574\n-    0x49, 0xf7, 0xe9,                                                                \/\/ IID575\n-    0x49, 0xf7, 0xe5,                                                                \/\/ IID576\n-    0xd5, 0x18, 0xf7, 0xd8,                                                          \/\/ IID577\n-    0xd5, 0x19, 0xf7, 0xd5,                                                          \/\/ IID578\n-    0x48, 0xd3, 0xc1,                                                                \/\/ IID579\n-    0xd5, 0x19, 0xd3, 0xc9,                                                          \/\/ IID580\n-    0x49, 0xd3, 0xf8,                                                                \/\/ IID581\n-    0xd5, 0x19, 0xd3, 0xe3,                                                          \/\/ IID582\n-    0xd5, 0x19, 0xd3, 0xe6,                                                          \/\/ IID583\n-    0xd5, 0x18, 0xd3, 0xef,                                                          \/\/ IID584\n-    0x48, 0xff, 0xc3,                                                                \/\/ IID585\n-    0x49, 0xff, 0xce,                                                                \/\/ IID586\n-    0xd5, 0x18, 0x55,                                                                \/\/ IID587\n-    0xd5, 0x18, 0x5d,                                                                \/\/ IID588\n-    0xd5, 0x30, 0xff, 0x94, 0x6c, 0x2f, 0xaf, 0xc6, 0x56,                            \/\/ IID589\n-    0xd5, 0x39, 0xf7, 0xa4, 0xdf, 0xdd, 0x14, 0x4b, 0xfe,                            \/\/ IID590\n-    0xd5, 0x3b, 0xf7, 0x9c, 0x1b, 0xe1, 0x03, 0x24, 0xa7,                            \/\/ IID591\n-    0xd5, 0x28, 0xd3, 0xbc, 0xb3, 0x2f, 0xb6, 0x9c, 0x9f,                            \/\/ IID592\n-    0xd5, 0x39, 0xd3, 0xa4, 0xfa, 0x79, 0xa0, 0x95, 0x0b,                            \/\/ IID593\n-    0xd5, 0x2b, 0xd3, 0xac, 0x16, 0x09, 0x4e, 0x54, 0x03,                            \/\/ IID594\n-    0xd5, 0x19, 0xff, 0x84, 0x13, 0x50, 0x32, 0x0b, 0x12,                            \/\/ IID595\n-    0xd5, 0x2b, 0xff, 0x8c, 0x89, 0x35, 0x13, 0x55, 0xcb,                            \/\/ IID596\n-    0xd5, 0x7a, 0x69, 0xa4, 0x60, 0x5b, 0xfa, 0x21, 0xa6, 0x00, 0x00, 0x10, 0x00,    \/\/ IID597\n-    0xd5, 0x58, 0x69, 0xcf, 0x00, 0x01, 0x00, 0x00,                                  \/\/ IID598\n-    0xd5, 0x9c, 0xa4, 0xdb, 0x08,                                                    \/\/ IID599\n-    0xd5, 0x9d, 0xac, 0xd4, 0x08,                                                    \/\/ IID600\n-    0x62, 0xdc, 0x2c, 0x10, 0x8f, 0xc5,                                              \/\/ IID601\n-    0x62, 0xfc, 0xac, 0x18, 0x8f, 0xc6,                                              \/\/ IID602\n-    0x62, 0xdc, 0x0c, 0x10, 0xff, 0xf1,                                              \/\/ IID603\n-    0x62, 0xdc, 0x84, 0x18, 0xff, 0xf4,                                              \/\/ IID604\n-    0xd5, 0xbd, 0xb6, 0x9c, 0x9d, 0xcc, 0x72, 0xc9, 0xed,                            \/\/ IID605\n-    0xd5, 0xaf, 0xb7, 0xb4, 0xb0, 0x22, 0x6d, 0x6c, 0xb5,                            \/\/ IID606\n-    0xd5, 0xde, 0xbe, 0xa4, 0x3f, 0x54, 0xcb, 0x89, 0x61,                            \/\/ IID607\n-    0xd5, 0xec, 0xbf, 0xa4, 0xfb, 0x9f, 0x9a, 0x17, 0xd2,                            \/\/ IID608\n-    0x4c, 0x0f, 0xb6, 0xd9,                                                          \/\/ IID609\n-    0xd5, 0xcd, 0xb7, 0xf7,                                                          \/\/ IID610\n-    0x4c, 0x0f, 0xbe, 0xf1,                                                          \/\/ IID611\n-    0xd5, 0xc9, 0xbf, 0xf9,                                                          \/\/ IID612\n-    0x4f, 0x0f, 0xb1, 0xa4, 0x55, 0xc6, 0xd3, 0x39, 0xf8,                            \/\/ IID613\n-    0x62, 0xf4, 0xfc, 0x08, 0xf7, 0xf9,                                              \/\/ IID614\n-    0x62, 0xd4, 0xfc, 0x0c, 0xf7, 0xff,                                              \/\/ IID615\n-    0x62, 0xfc, 0xfc, 0x08, 0xf7, 0xf7,                                              \/\/ IID616\n-    0x62, 0xdc, 0xfc, 0x0c, 0xf7, 0xf0,                                              \/\/ IID617\n-    0x62, 0xdc, 0xfc, 0x08, 0xf7, 0xeb,                                              \/\/ IID618\n-    0x62, 0xdc, 0xfc, 0x0c, 0xf7, 0xee,                                              \/\/ IID619\n-    0x62, 0xd4, 0xfc, 0x08, 0xf7, 0xe4,                                              \/\/ IID620\n-    0x62, 0xf4, 0xfc, 0x0c, 0xf7, 0xe1,                                              \/\/ IID621\n-    0x62, 0x94, 0xfc, 0x08, 0xf7, 0xa4, 0xcd, 0x6c, 0x54, 0x95, 0xdd,                \/\/ IID622\n-    0x62, 0x94, 0xf8, 0x0c, 0xf7, 0xa4, 0xc5, 0xfb, 0x89, 0x93, 0xd7,                \/\/ IID623\n-    0x62, 0xcc, 0xfc, 0x08, 0xaf, 0xee,                                              \/\/ IID624\n-    0xd5, 0x18, 0xf7, 0xe9,                                                          \/\/ IID625\n-    0x62, 0x44, 0xfc, 0x0c, 0xaf, 0xec,                                              \/\/ IID626\n-    0x62, 0x4c, 0xfc, 0x0c, 0xaf, 0xf6,                                              \/\/ IID627\n-    0x62, 0x44, 0xfc, 0x08, 0xf5, 0xc7,                                              \/\/ IID628\n-    0x62, 0x4c, 0xfc, 0x08, 0xf5, 0xc9,                                              \/\/ IID629\n-    0x62, 0x6c, 0xfc, 0x0c, 0xf5, 0xcd,                                              \/\/ IID630\n-    0x62, 0xec, 0xfc, 0x0c, 0xf5, 0xf6,                                              \/\/ IID631\n-    0x62, 0xdc, 0xf4, 0x10, 0xf7, 0xde,                                              \/\/ IID632\n-    0xd5, 0x18, 0xf7, 0xd9,                                                          \/\/ IID633\n-    0x62, 0xfc, 0x84, 0x14, 0xf7, 0xd9,                                              \/\/ IID634\n-    0x62, 0xdc, 0x94, 0x14, 0xf7, 0xdd,                                              \/\/ IID635\n-    0x62, 0xd4, 0xac, 0x18, 0xf7, 0xd1,                                              \/\/ IID636\n-    0xd5, 0x19, 0xf7, 0xd0,                                                          \/\/ IID637\n-    0x62, 0x44, 0xfc, 0x08, 0x88, 0xe7,                                              \/\/ IID638\n-    0x62, 0x54, 0xfc, 0x08, 0x88, 0xd2,                                              \/\/ IID639\n-    0x62, 0x4c, 0xfc, 0x0c, 0x88, 0xde,                                              \/\/ IID640\n-    0x62, 0x4c, 0xfc, 0x0c, 0x88, 0xe4,                                              \/\/ IID641\n-    0x62, 0xd4, 0x9c, 0x10, 0xd3, 0xc6,                                              \/\/ IID642\n-    0xd5, 0x18, 0xd3, 0xc7,                                                          \/\/ IID643\n-    0x62, 0xdc, 0xc4, 0x14, 0xd3, 0xc0,                                              \/\/ IID644\n-    0x62, 0xfc, 0xd4, 0x14, 0xd3, 0xc5,                                              \/\/ IID645\n-    0x62, 0xfc, 0x84, 0x10, 0xd3, 0xce,                                              \/\/ IID646\n-    0xd5, 0x19, 0xd3, 0xcc,                                                          \/\/ IID647\n-    0x62, 0xd4, 0xf4, 0x14, 0xd3, 0xca,                                              \/\/ IID648\n-    0x62, 0xd4, 0xb4, 0x1c, 0xd3, 0xc9,                                              \/\/ IID649\n-    0x62, 0xdc, 0x94, 0x10, 0xd3, 0xe6,                                              \/\/ IID650\n-    0x49, 0xd3, 0xe3,                                                                \/\/ IID651\n-    0x62, 0xd4, 0xac, 0x14, 0xd3, 0xe3,                                              \/\/ IID652\n-    0x62, 0xfc, 0xfc, 0x14, 0xd3, 0xe0,                                              \/\/ IID653\n-    0x62, 0xd4, 0xe4, 0x18, 0xd3, 0xff,                                              \/\/ IID654\n-    0x49, 0xd3, 0xfe,                                                                \/\/ IID655\n-    0x62, 0xfc, 0xb4, 0x14, 0xd3, 0xf8,                                              \/\/ IID656\n-    0x62, 0xd4, 0xbc, 0x1c, 0xd3, 0xf8,                                              \/\/ IID657\n-    0x62, 0xd4, 0xa4, 0x18, 0xff, 0xcd,                                              \/\/ IID658\n-    0x48, 0xff, 0xc9,                                                                \/\/ IID659\n-    0x62, 0xfc, 0xd4, 0x14, 0xff, 0xca,                                              \/\/ IID660\n-    0x62, 0xdc, 0x9c, 0x14, 0xff, 0xcc,                                              \/\/ IID661\n-    0xd5, 0x18, 0xff, 0xc0,                                                          \/\/ IID662\n-    0xd5, 0x19, 0xff, 0xc5,                                                          \/\/ IID663\n-    0x62, 0xd4, 0xec, 0x14, 0xff, 0xc1,                                              \/\/ IID664\n-    0x62, 0xfc, 0xe4, 0x14, 0xff, 0xc3,                                              \/\/ IID665\n-    0x62, 0xfc, 0xe4, 0x10, 0xd3, 0xe2,                                              \/\/ IID666\n-    0x49, 0xd3, 0xe0,                                                                \/\/ IID667\n-    0x62, 0xd4, 0x9c, 0x1c, 0xd3, 0xe7,                                              \/\/ IID668\n-    0x62, 0xdc, 0x94, 0x14, 0xd3, 0xe5,                                              \/\/ IID669\n-    0x62, 0xdc, 0x9c, 0x10, 0xd3, 0xe8,                                              \/\/ IID670\n-    0xd5, 0x18, 0xd3, 0xeb,                                                          \/\/ IID671\n-    0x62, 0xdc, 0xbc, 0x1c, 0xd3, 0xec,                                              \/\/ IID672\n-    0x62, 0xfc, 0xf4, 0x14, 0xd3, 0xe9,                                              \/\/ IID673\n-    0x62, 0x6c, 0xfc, 0x08, 0xf4, 0xe0,                                              \/\/ IID674\n-    0x62, 0x54, 0xfc, 0x08, 0xf4, 0xf6,                                              \/\/ IID675\n-    0x62, 0x5c, 0xfc, 0x0c, 0xf4, 0xe7,                                              \/\/ IID676\n-    0x62, 0x54, 0xfc, 0x0c, 0xf4, 0xf6,                                              \/\/ IID677\n-    0x62, 0x44, 0xfc, 0x08, 0xaf, 0xbd, 0xae, 0x4c, 0x3b, 0x96,                      \/\/ IID678\n-    0x62, 0xec, 0xfc, 0x0c, 0xaf, 0x8a, 0xfb, 0xee, 0x54, 0x9f,                      \/\/ IID679\n-    0x62, 0x04, 0xf8, 0x08, 0xf5, 0x9c, 0x8e, 0x83, 0xbf, 0x98, 0x27,                \/\/ IID680\n-    0x62, 0x84, 0xfc, 0x0c, 0xf5, 0xbc, 0x1a, 0xa3, 0x9c, 0x71, 0xc8,                \/\/ IID681\n-    0x62, 0xbc, 0xf4, 0x18, 0xf7, 0x9c, 0xcb, 0xc0, 0x2b, 0xb8, 0x97,                \/\/ IID682\n-    0x62, 0xf4, 0xf4, 0x1c, 0xf7, 0x9c, 0x0b, 0x8d, 0xd3, 0x92, 0x6f,                \/\/ IID683\n-    0x62, 0xc4, 0xfc, 0x08, 0x88, 0xa4, 0x24, 0x2a, 0xd8, 0x74, 0xd5,                \/\/ IID684\n-    0x62, 0x4c, 0xfc, 0x0c, 0x88, 0xbe, 0xd0, 0xf6, 0x03, 0x46,                      \/\/ IID685\n-    0x62, 0xdc, 0xe4, 0x18, 0xd3, 0xa0, 0xf9, 0x06, 0x7d, 0x56,                      \/\/ IID686\n-    0x62, 0x9c, 0x98, 0x1c, 0xd3, 0xa4, 0x20, 0xb2, 0xa7, 0xb3, 0xe3,                \/\/ IID687\n-    0x62, 0xbc, 0x98, 0x18, 0xd3, 0xbc, 0x87, 0x46, 0x43, 0xa8, 0xce,                \/\/ IID688\n-    0x62, 0x94, 0xb8, 0x1c, 0xd3, 0xbc, 0x86, 0x5b, 0x6f, 0xbd, 0x8e,                \/\/ IID689\n-    0x62, 0x94, 0xc4, 0x10, 0xff, 0x8c, 0x78, 0x23, 0x8d, 0x1d, 0xa5,                \/\/ IID690\n-    0x62, 0x9c, 0x94, 0x1c, 0xff, 0x8c, 0xcd, 0x57, 0x8b, 0xae, 0xa4,                \/\/ IID691\n-    0x62, 0xbc, 0xa0, 0x18, 0xff, 0x84, 0xfd, 0x24, 0x4b, 0x89, 0xde,                \/\/ IID692\n-    0x62, 0xf4, 0x90, 0x1c, 0xff, 0x84, 0x01, 0x37, 0xb7, 0x4b, 0xc9,                \/\/ IID693\n-    0x62, 0xdc, 0xac, 0x10, 0xd3, 0xac, 0x89, 0x6d, 0xb6, 0x76, 0xa0,                \/\/ IID694\n-    0x62, 0xd4, 0xb4, 0x14, 0xd3, 0xa9, 0x21, 0x8d, 0x79, 0x51,                      \/\/ IID695\n-    0x62, 0x04, 0xf8, 0x08, 0xf4, 0xa4, 0x95, 0xf6, 0x96, 0x71, 0x20,                \/\/ IID696\n-    0x62, 0xbc, 0xfc, 0x0c, 0xf4, 0x9c, 0x2b, 0x2b, 0xc8, 0x26, 0xdb,                \/\/ IID697\n-    0x62, 0x4c, 0xf4, 0x10, 0x01, 0xbe, 0xff, 0xcc, 0x35, 0x39,                      \/\/ IID698\n-    0x62, 0x1c, 0x8c, 0x18, 0x01, 0xb4, 0x93, 0x55, 0x64, 0x52, 0xcb,                \/\/ IID699\n-    0x62, 0x6c, 0xe8, 0x14, 0x01, 0xb4, 0x3c, 0x4b, 0xed, 0xd3, 0x5a,                \/\/ IID700\n-    0x62, 0xe4, 0xdc, 0x14, 0x01, 0xa2, 0x1b, 0x66, 0xd5, 0xcd,                      \/\/ IID701\n-    0x62, 0xa4, 0x80, 0x10, 0x21, 0x8c, 0xdb, 0xd2, 0x47, 0xe2, 0x4c,                \/\/ IID702\n-    0x62, 0x6c, 0x88, 0x10, 0x21, 0xb4, 0x5a, 0xec, 0xc2, 0x11, 0xfb,                \/\/ IID703\n-    0x62, 0x44, 0x9c, 0x14, 0x21, 0x84, 0xdb, 0x41, 0xb4, 0x66, 0xd7,                \/\/ IID704\n-    0x62, 0x6c, 0x8c, 0x14, 0x21, 0xb6, 0x24, 0x1c, 0xd2, 0x07,                      \/\/ IID705\n-    0x62, 0xc4, 0xa8, 0x10, 0x09, 0xa4, 0xdf, 0x92, 0x17, 0xc2, 0x58,                \/\/ IID706\n-    0x62, 0x14, 0x90, 0x18, 0x09, 0xac, 0x9a, 0xcd, 0x2c, 0x8f, 0xd3,                \/\/ IID707\n-    0x62, 0x44, 0xe4, 0x1c, 0x09, 0x94, 0x1c, 0x44, 0x0e, 0x4f, 0xe0,                \/\/ IID708\n-    0x62, 0x0c, 0x80, 0x14, 0x09, 0xbc, 0x7b, 0x56, 0x17, 0x8d, 0x02,                \/\/ IID709\n-    0x62, 0x4c, 0xb8, 0x10, 0x29, 0x9c, 0x7c, 0x10, 0xf6, 0x80, 0x69,                \/\/ IID710\n-    0x62, 0x14, 0x80, 0x18, 0x29, 0xbc, 0xf3, 0x19, 0x88, 0x68, 0xfb,                \/\/ IID711\n-    0x62, 0x0c, 0xf4, 0x14, 0x29, 0xbc, 0xa9, 0x46, 0x9e, 0x61, 0x31,                \/\/ IID712\n-    0x62, 0x84, 0xec, 0x14, 0x29, 0x94, 0x93, 0x1a, 0x86, 0x22, 0x19,                \/\/ IID713\n-    0x62, 0xc4, 0xe4, 0x18, 0x31, 0xab, 0xe0, 0x2b, 0xe9, 0xb8,                      \/\/ IID714\n-    0x62, 0x34, 0xbc, 0x18, 0x31, 0x84, 0x8a, 0x64, 0x1c, 0x30, 0xfb,                \/\/ IID715\n-    0x62, 0x04, 0xf8, 0x14, 0x31, 0x8c, 0x1e, 0xd9, 0x54, 0x66, 0x7c,                \/\/ IID716\n-    0x62, 0x44, 0x94, 0x14, 0x31, 0xaf, 0x87, 0x4b, 0x05, 0xa1,                      \/\/ IID717\n-    0x62, 0xd4, 0xe0, 0x10, 0x81, 0x84, 0xb5, 0x59, 0x45, 0xb6, 0x68, 0x00, 0x00, 0x00, 0x01, \/\/ IID718\n-    0x62, 0x94, 0xf8, 0x14, 0x83, 0x84, 0xfd, 0x0b, 0xc5, 0xeb, 0x9a, 0x01,          \/\/ IID719\n-    0x62, 0x9c, 0x84, 0x10, 0x83, 0xa4, 0x68, 0xf2, 0x95, 0x4e, 0xda, 0x01,          \/\/ IID720\n-    0x62, 0xdc, 0xa4, 0x1c, 0x81, 0xa4, 0x24, 0xda, 0xb4, 0x92, 0xf0, 0x00, 0x00, 0x01, 0x00, \/\/ IID721\n-    0x62, 0xbc, 0xfc, 0x08, 0x69, 0x8c, 0x12, 0xa1, 0x6d, 0xec, 0x46, 0x00, 0x00, 0x00, 0x01, \/\/ IID722\n-    0x62, 0x14, 0xfc, 0x0c, 0x6b, 0xbc, 0xd1, 0x0d, 0x95, 0x3c, 0x80, 0x10,          \/\/ IID723\n-    0x62, 0x9c, 0xf0, 0x10, 0x83, 0x8c, 0x33, 0x2c, 0xda, 0x4c, 0x1b, 0x01,          \/\/ IID724\n-    0x62, 0x9c, 0xec, 0x1c, 0x81, 0x8c, 0xb1, 0x7b, 0x94, 0x55, 0xa6, 0x00, 0x10, 0x00, 0x00, \/\/ IID725\n-    0x62, 0xdc, 0xf0, 0x10, 0xc1, 0xa4, 0x6a, 0xa1, 0x0e, 0x4e, 0x95, 0x08,          \/\/ IID726\n-    0x62, 0xfc, 0x98, 0x1c, 0xc1, 0xa4, 0x0e, 0x55, 0xeb, 0x53, 0xbc, 0x02,          \/\/ IID727\n-    0x62, 0xfc, 0x90, 0x10, 0xc1, 0xbc, 0x02, 0x9f, 0xf3, 0x23, 0xa6, 0x04,          \/\/ IID728\n-    0x62, 0xd4, 0xfc, 0x14, 0xc1, 0xbb, 0xec, 0x2c, 0x42, 0xf8, 0x04,                \/\/ IID729\n-    0x62, 0xbc, 0xa8, 0x10, 0xc1, 0xac, 0xdf, 0xec, 0xdc, 0x46, 0xaa, 0x10,          \/\/ IID730\n-    0x62, 0xbc, 0xc0, 0x14, 0xc1, 0xac, 0x68, 0x1d, 0x1a, 0x31, 0x71, 0x02,          \/\/ IID731\n-    0x62, 0xd4, 0xb4, 0x10, 0x81, 0xa9, 0x54, 0xd4, 0xac, 0xf6, 0x00, 0x00, 0x10, 0x00, \/\/ IID732\n-    0x62, 0xd4, 0xf0, 0x14, 0x81, 0xac, 0x38, 0xa2, 0x6c, 0xd0, 0x55, 0x00, 0x00, 0x10, 0x00, \/\/ IID733\n-    0x62, 0x94, 0x90, 0x10, 0x81, 0xb4, 0x01, 0x3f, 0xbe, 0x3e, 0xfd, 0x00, 0x00, 0x10, 0x00, \/\/ IID734\n-    0x62, 0xfc, 0x98, 0x14, 0x83, 0xb4, 0x5e, 0x43, 0x65, 0x62, 0xd2, 0x10,          \/\/ IID735\n-    0x62, 0xd4, 0xcc, 0x10, 0x83, 0xc6, 0x10,                                        \/\/ IID736\n-    0x62, 0xd4, 0xfc, 0x18, 0x83, 0xc4, 0x10,                                        \/\/ IID737\n-    0xd5, 0x19, 0x81, 0xc0, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID738\n-    0x62, 0xf4, 0xd4, 0x14, 0x81, 0xc3, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID739\n-    0x62, 0xf4, 0xfc, 0x1c, 0x81, 0xc3, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID740\n-    0x62, 0xdc, 0xbc, 0x14, 0x81, 0xc0, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID741\n-    0x62, 0xdc, 0xd4, 0x10, 0x81, 0xe3, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID742\n-    0x62, 0xdc, 0xfc, 0x18, 0x81, 0xe3, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID743\n-    0xd5, 0x19, 0x81, 0xe0, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID744\n-    0x62, 0xdc, 0x94, 0x1c, 0x81, 0xe7, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID745\n-    0x62, 0xfc, 0xfc, 0x1c, 0x81, 0xe5, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID746\n-    0x62, 0xdc, 0x8c, 0x14, 0x81, 0xe6, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID747\n-    0x62, 0x54, 0xfc, 0x08, 0x69, 0xc5, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID748\n-    0x62, 0xdc, 0xfc, 0x08, 0x69, 0xc7, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID749\n-    0x62, 0x54, 0xfc, 0x08, 0x69, 0xed, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID750\n-    0x62, 0x5c, 0xfc, 0x0c, 0x69, 0xf5, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID751\n-    0x62, 0xfc, 0xfc, 0x0c, 0x69, 0xc6, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID752\n-    0x62, 0x54, 0xfc, 0x0c, 0x69, 0xc0, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID753\n-    0x62, 0xd4, 0x8c, 0x10, 0x81, 0xcf, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID754\n-    0x62, 0xdc, 0xfc, 0x18, 0x81, 0xcc, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID755\n-    0xd5, 0x19, 0x81, 0xca, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID756\n-    0x62, 0xd4, 0xfc, 0x14, 0x81, 0xcc, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID757\n-    0x62, 0xd4, 0xfc, 0x1c, 0x81, 0xc9, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID758\n-    0x62, 0xfc, 0xc4, 0x14, 0x81, 0xcf, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID759\n-    0x62, 0xd4, 0x84, 0x18, 0xc1, 0xd1, 0x10,                                        \/\/ IID760\n-    0x62, 0xd4, 0xfc, 0x18, 0xc1, 0xd0, 0x10,                                        \/\/ IID761\n-    0xd5, 0x19, 0xd1, 0xd1,                                                          \/\/ IID762\n-    0x62, 0xfc, 0xb4, 0x18, 0xc1, 0xc1, 0x10,                                        \/\/ IID763\n-    0x62, 0xfc, 0xfc, 0x18, 0xc1, 0xc4, 0x10,                                        \/\/ IID764\n-    0xd5, 0x19, 0xd1, 0xc3,                                                          \/\/ IID765\n-    0x62, 0xdc, 0xdc, 0x14, 0xd1, 0xc7,                                              \/\/ IID766\n-    0x62, 0xfc, 0xfc, 0x1c, 0xd1, 0xc2,                                              \/\/ IID767\n-    0x62, 0xdc, 0x9c, 0x14, 0xc1, 0xc4, 0x10,                                        \/\/ IID768\n-    0x62, 0xfc, 0xac, 0x10, 0xc1, 0xca, 0x10,                                        \/\/ IID769\n-    0x62, 0xdc, 0xfc, 0x18, 0xc1, 0xc8, 0x10,                                        \/\/ IID770\n-    0xd5, 0x18, 0xc1, 0xce, 0x10,                                                    \/\/ IID771\n-    0x62, 0xdc, 0xa4, 0x14, 0xd1, 0xcd,                                              \/\/ IID772\n-    0x62, 0xfc, 0xfc, 0x1c, 0xd1, 0xca,                                              \/\/ IID773\n-    0x62, 0xfc, 0xd4, 0x14, 0xd1, 0xcd,                                              \/\/ IID774\n-    0x62, 0xf4, 0x9c, 0x18, 0xc1, 0xe1, 0x02,                                        \/\/ IID775\n-    0x62, 0xdc, 0xfc, 0x18, 0xc1, 0xe0, 0x02,                                        \/\/ IID776\n-    0xd5, 0x18, 0xc1, 0xe6, 0x08,                                                    \/\/ IID777\n-    0x62, 0xfc, 0xf4, 0x14, 0xc1, 0xe7, 0x08,                                        \/\/ IID778\n-    0x62, 0xdc, 0xfc, 0x1c, 0xc1, 0xe3, 0x08,                                        \/\/ IID779\n-    0x62, 0xfc, 0xc4, 0x14, 0xd1, 0xe7,                                              \/\/ IID780\n-    0x62, 0xdc, 0xbc, 0x18, 0xc1, 0xf9, 0x10,                                        \/\/ IID781\n-    0x62, 0xfc, 0xfc, 0x18, 0xc1, 0xff, 0x10,                                        \/\/ IID782\n-    0x49, 0xc1, 0xf9, 0x04,                                                          \/\/ IID783\n-    0x62, 0xd4, 0xcc, 0x14, 0xd1, 0xfd,                                              \/\/ IID784\n-    0x62, 0xd4, 0xfc, 0x1c, 0xd1, 0xfb,                                              \/\/ IID785\n-    0x62, 0xd4, 0x9c, 0x1c, 0xc1, 0xfc, 0x02,                                        \/\/ IID786\n-    0x62, 0xdc, 0xf4, 0x18, 0xc1, 0xe6, 0x08,                                        \/\/ IID787\n-    0x62, 0xfc, 0xfc, 0x18, 0xc1, 0xe3, 0x08,                                        \/\/ IID788\n-    0x49, 0xc1, 0xe5, 0x02,                                                          \/\/ IID789\n-    0x62, 0xd4, 0xec, 0x14, 0xc1, 0xe3, 0x08,                                        \/\/ IID790\n-    0x62, 0xd4, 0xfc, 0x1c, 0xc1, 0xe1, 0x08,                                        \/\/ IID791\n-    0x62, 0xf4, 0xf4, 0x1c, 0xc1, 0xe1, 0x10,                                        \/\/ IID792\n-    0x62, 0xfc, 0xac, 0x18, 0xc1, 0xee, 0x04,                                        \/\/ IID793\n-    0x62, 0xd4, 0xfc, 0x18, 0xc1, 0xe9, 0x04,                                        \/\/ IID794\n-    0x49, 0xc1, 0xec, 0x02,                                                          \/\/ IID795\n-    0x62, 0xdc, 0xac, 0x14, 0xc1, 0xef, 0x08,                                        \/\/ IID796\n-    0x62, 0xd4, 0xfc, 0x1c, 0xc1, 0xec, 0x08,                                        \/\/ IID797\n-    0x62, 0xdc, 0x9c, 0x14, 0xd1, 0xec,                                              \/\/ IID798\n-    0x62, 0xdc, 0x84, 0x18, 0x81, 0xee, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID799\n-    0x62, 0xf4, 0xfc, 0x18, 0x81, 0xe9, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID800\n-    0xd5, 0x19, 0x83, 0xea, 0x10,                                                    \/\/ IID801\n-    0x62, 0xd4, 0x9c, 0x1c, 0x83, 0xee, 0x01,                                        \/\/ IID802\n-    0x62, 0xfc, 0xfc, 0x1c, 0x83, 0xed, 0x01,                                        \/\/ IID803\n-    0x62, 0xfc, 0xdc, 0x14, 0x81, 0xec, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID804\n-    0x62, 0xf4, 0xa4, 0x18, 0x81, 0xf3, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID805\n-    0x62, 0xfc, 0xfc, 0x18, 0x81, 0xf7, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID806\n-    0xd5, 0x19, 0x81, 0xf7, 0x00, 0x00, 0x00, 0x10,                                  \/\/ IID807\n-    0x62, 0xdc, 0x94, 0x14, 0x81, 0xf4, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID808\n-    0x62, 0xfc, 0xfc, 0x1c, 0x81, 0xf3, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID809\n-    0x62, 0xf4, 0xec, 0x1c, 0x81, 0xf2, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID810\n-    0x48, 0x81, 0xca, 0x00, 0x00, 0x10, 0x00,                                        \/\/ IID811\n-    0x62, 0xfc, 0xfc, 0x18, 0x81, 0xce, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID812\n-    0xd5, 0x19, 0x81, 0xcd, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID813\n-    0x62, 0xf4, 0xf4, 0x10, 0x81, 0xc9, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID814\n-    0x62, 0xdc, 0xfc, 0x18, 0x81, 0xc9, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID815\n-    0xd5, 0x19, 0x81, 0xcb, 0x00, 0x00, 0x00, 0x40,                                  \/\/ IID816\n-    0x62, 0xfc, 0xfc, 0x10, 0x81, 0xeb, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID817\n-    0x62, 0xdc, 0xfc, 0x18, 0x81, 0xef, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID818\n-    0xd5, 0x19, 0x81, 0xea, 0x00, 0x00, 0x04, 0x00,                                  \/\/ IID819\n-    0x62, 0xfc, 0xf4, 0x14, 0x81, 0xee, 0x00, 0x00, 0x00, 0x40,                      \/\/ IID820\n-    0x62, 0xfc, 0xfc, 0x1c, 0x81, 0xea, 0x00, 0x00, 0x00, 0x40,                      \/\/ IID821\n-    0x62, 0xfc, 0xc4, 0x14, 0x81, 0xef, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID822\n-    0x62, 0x4c, 0x90, 0x18, 0x03, 0xb4, 0x58, 0x3b, 0x3a, 0xea, 0x56,                \/\/ IID823\n-    0x62, 0x1c, 0x90, 0x14, 0x03, 0xbc, 0xda, 0xa8, 0xc6, 0xee, 0xb4,                \/\/ IID824\n-    0x62, 0x4c, 0x9c, 0x18, 0x23, 0xb7, 0x8c, 0xc3, 0xef, 0xb9,                      \/\/ IID825\n-    0x62, 0x3c, 0xa0, 0x14, 0x23, 0x94, 0x4e, 0xe5, 0xbe, 0x1e, 0x6a,                \/\/ IID826\n-    0x62, 0x44, 0x88, 0x10, 0x0b, 0x94, 0x93, 0xd7, 0x00, 0x60, 0xd4,                \/\/ IID827\n-    0x62, 0x7c, 0xb0, 0x1c, 0x0b, 0xa4, 0x0a, 0xf6, 0x59, 0x48, 0x0b,                \/\/ IID828\n-    0x62, 0xcc, 0xec, 0x18, 0xaf, 0x8c, 0x90, 0xd8, 0x4c, 0x28, 0x3d,                \/\/ IID829\n-    0x62, 0x0c, 0x94, 0x14, 0xaf, 0x94, 0x66, 0x24, 0x31, 0x81, 0x6e,                \/\/ IID830\n-    0x62, 0x7c, 0xe4, 0x18, 0x2b, 0xae, 0x62, 0xd7, 0xd5, 0x8f,                      \/\/ IID831\n-    0x62, 0x4c, 0xc4, 0x14, 0x2b, 0xac, 0x11, 0x13, 0x58, 0xad, 0x9d,                \/\/ IID832\n-    0x62, 0xac, 0xbc, 0x18, 0x33, 0x94, 0xb3, 0x69, 0x59, 0x40, 0xf1,                \/\/ IID833\n-    0x62, 0x4c, 0xac, 0x1c, 0x33, 0xa2, 0xca, 0x81, 0x83, 0x16,                      \/\/ IID834\n-    0x62, 0xc4, 0xf4, 0x18, 0x03, 0xd0,                                              \/\/ IID835\n-    0x49, 0x03, 0xce,                                                                \/\/ IID836\n-    0x62, 0x7c, 0xc4, 0x14, 0x03, 0xd0,                                              \/\/ IID837\n-    0x62, 0x5c, 0xa4, 0x1c, 0x03, 0xd8,                                              \/\/ IID838\n-    0x62, 0xe4, 0xb5, 0x18, 0x66, 0xd2,                                              \/\/ IID839\n-    0x66, 0x4d, 0x0f, 0x38, 0xf6, 0xc7,                                              \/\/ IID840\n-    0x62, 0xcc, 0x86, 0x18, 0x66, 0xf2,                                              \/\/ IID841\n-    0xf3, 0x4c, 0x0f, 0x38, 0xf6, 0xda,                                              \/\/ IID842\n-    0x62, 0xfc, 0xe4, 0x10, 0x23, 0xd6,                                              \/\/ IID843\n-    0xd5, 0x5c, 0x23, 0xe9,                                                          \/\/ IID844\n-    0x62, 0x44, 0xc4, 0x14, 0x23, 0xdf,                                              \/\/ IID845\n-    0x62, 0x54, 0xb4, 0x1c, 0x23, 0xcd,                                              \/\/ IID846\n-    0x62, 0x7c, 0xec, 0x10, 0xaf, 0xf8,                                              \/\/ IID847\n-    0xd5, 0x98, 0xaf, 0xc9,                                                          \/\/ IID848\n-    0x62, 0x7c, 0xc4, 0x14, 0xaf, 0xe4,                                              \/\/ IID849\n-    0x62, 0x54, 0xac, 0x1c, 0xaf, 0xd1,                                              \/\/ IID850\n-    0x62, 0xc4, 0xec, 0x18, 0x0b, 0xde,                                              \/\/ IID851\n-    0x49, 0x0b, 0xcd,                                                                \/\/ IID852\n-    0x62, 0x4c, 0xb4, 0x1c, 0x0b, 0xcd,                                              \/\/ IID853\n-    0x62, 0xdc, 0xec, 0x1c, 0x0b, 0xd1,                                              \/\/ IID854\n-    0x62, 0x7c, 0xc4, 0x10, 0x2b, 0xc0,                                              \/\/ IID855\n-    0x4d, 0x2b, 0xed,                                                                \/\/ IID856\n-    0x62, 0x54, 0xe4, 0x14, 0x2b, 0xe7,                                              \/\/ IID857\n-    0x62, 0x74, 0xb4, 0x1c, 0x2b, 0xca,                                              \/\/ IID858\n-    0x62, 0xcc, 0x94, 0x18, 0x33, 0xc7,                                              \/\/ IID859\n-    0xd5, 0x59, 0x33, 0xce,                                                          \/\/ IID860\n-    0x62, 0x6c, 0xe4, 0x14, 0x33, 0xf4,                                              \/\/ IID861\n-    0x62, 0x44, 0x84, 0x14, 0x33, 0xfd,                                              \/\/ IID862\n-    0x62, 0x54, 0xcc, 0x10, 0x24, 0xea, 0x04,                                        \/\/ IID863\n-    0xd5, 0xd9, 0xa4, 0xe8, 0x10,                                                    \/\/ IID864\n-    0x62, 0x44, 0xdc, 0x14, 0x24, 0xdd, 0x10,                                        \/\/ IID865\n-    0x62, 0xcc, 0x84, 0x14, 0x24, 0xdf, 0x02,                                        \/\/ IID866\n-    0x62, 0x7c, 0x8c, 0x10, 0x2c, 0xdc, 0x08,                                        \/\/ IID867\n-    0x4c, 0x0f, 0xac, 0xfa, 0x01,                                                    \/\/ IID868\n-    0x62, 0x5c, 0x9c, 0x14, 0x2c, 0xf6, 0x02,                                        \/\/ IID869\n-    0x62, 0xec, 0xdc, 0x14, 0x2c, 0xc4, 0x01,                                        \/\/ IID870\n-    0x62, 0xcc, 0xd4, 0x10, 0x40, 0xcc,                                              \/\/ IID871\n-    0xd5, 0x9d, 0x40, 0xfe,                                                          \/\/ IID872\n-    0x62, 0x54, 0xf4, 0x18, 0x41, 0xff,                                              \/\/ IID873\n-    0x49, 0x0f, 0x41, 0xcd,                                                          \/\/ IID874\n-    0x62, 0x4c, 0xec, 0x18, 0x42, 0xd2,                                              \/\/ IID875\n-    0xd5, 0xcd, 0x42, 0xe7,                                                          \/\/ IID876\n-    0x62, 0xf4, 0xbc, 0x18, 0x43, 0xd1,                                              \/\/ IID877\n-    0x48, 0x0f, 0x43, 0xc9,                                                          \/\/ IID878\n-    0x62, 0x54, 0xac, 0x18, 0x44, 0xe9,                                              \/\/ IID879\n-    0xd5, 0x9d, 0x44, 0xf3,                                                          \/\/ IID880\n-    0x62, 0xc4, 0xa4, 0x18, 0x45, 0xf9,                                              \/\/ IID881\n-    0x4c, 0x0f, 0x45, 0xda,                                                          \/\/ IID882\n-    0x62, 0x5c, 0x84, 0x10, 0x46, 0xf1,                                              \/\/ IID883\n-    0xd5, 0xc9, 0x46, 0xe4,                                                          \/\/ IID884\n-    0x62, 0x5c, 0xec, 0x18, 0x47, 0xd4,                                              \/\/ IID885\n-    0xd5, 0x9c, 0x47, 0xc1,                                                          \/\/ IID886\n-    0x62, 0x6c, 0xf4, 0x18, 0x48, 0xf7,                                              \/\/ IID887\n-    0xd5, 0xdc, 0x48, 0xd2,                                                          \/\/ IID888\n-    0x62, 0xfc, 0xec, 0x18, 0x49, 0xda,                                              \/\/ IID889\n-    0xd5, 0xc9, 0x49, 0xed,                                                          \/\/ IID890\n-    0x62, 0x4c, 0xa4, 0x10, 0x4a, 0xe3,                                              \/\/ IID891\n-    0xd5, 0x9d, 0x4a, 0xde,                                                          \/\/ IID892\n-    0x62, 0xec, 0xf4, 0x18, 0x4b, 0xea,                                              \/\/ IID893\n-    0xd5, 0x99, 0x4b, 0xcd,                                                          \/\/ IID894\n-    0x62, 0xc4, 0xec, 0x18, 0x4c, 0xec,                                              \/\/ IID895\n-    0xd5, 0x99, 0x4c, 0xd2,                                                          \/\/ IID896\n-    0x62, 0xfc, 0xf4, 0x10, 0x4d, 0xde,                                              \/\/ IID897\n-    0x49, 0x0f, 0x4d, 0xd3,                                                          \/\/ IID898\n-    0x62, 0x54, 0xec, 0x18, 0x4e, 0xf0,                                              \/\/ IID899\n-    0x4d, 0x0f, 0x4e, 0xf0,                                                          \/\/ IID900\n-    0x62, 0x6c, 0xb4, 0x10, 0x4f, 0xed,                                              \/\/ IID901\n-    0xd5, 0xdd, 0x4f, 0xd6,                                                          \/\/ IID902\n-    0x62, 0x84, 0xbc, 0x10, 0x40, 0xac, 0x5d, 0x1e, 0x52, 0x9c, 0x43,                \/\/ IID903\n-    0x62, 0xcc, 0xa0, 0x18, 0x41, 0x94, 0x05, 0x7f, 0x12, 0x32, 0x06,                \/\/ IID904\n-    0x62, 0x14, 0xf8, 0x10, 0x42, 0x84, 0x50, 0xef, 0x3d, 0x63, 0x10,                \/\/ IID905\n-    0x62, 0x7c, 0x94, 0x18, 0x43, 0xb2, 0xc8, 0x61, 0x09, 0xab,                      \/\/ IID906\n-    0x62, 0x1c, 0x98, 0x18, 0x44, 0x84, 0x57, 0x86, 0xbb, 0xe1, 0x85,                \/\/ IID907\n-    0xd5, 0xde, 0x45, 0xac, 0x9b, 0x2e, 0xd2, 0x27, 0xca,                            \/\/ IID908\n-    0x62, 0x8c, 0xf0, 0x18, 0x46, 0x94, 0x21, 0xa0, 0x64, 0xbe, 0x30,                \/\/ IID909\n-    0x62, 0x54, 0x98, 0x10, 0x47, 0xa4, 0x42, 0x06, 0x01, 0x47, 0xdd,                \/\/ IID910\n-    0x62, 0x34, 0xa4, 0x18, 0x48, 0x84, 0xdb, 0x96, 0x9e, 0xcc, 0x25,                \/\/ IID911\n-    0x62, 0x44, 0x9c, 0x18, 0x49, 0x9b, 0x02, 0x8f, 0xd2, 0xf3,                      \/\/ IID912\n-    0x62, 0x6c, 0xbc, 0x18, 0x4a, 0x94, 0x5b, 0x16, 0x48, 0x92, 0xb7,                \/\/ IID913\n-    0x62, 0x54, 0x88, 0x10, 0x4b, 0x94, 0xd6, 0x84, 0x48, 0x88, 0x14,                \/\/ IID914\n-    0x62, 0x1c, 0xa4, 0x10, 0x4c, 0x84, 0xb5, 0xa8, 0xb7, 0x92, 0x00,                \/\/ IID915\n-    0x62, 0x6c, 0x8c, 0x18, 0x4d, 0xa4, 0x13, 0x45, 0x2d, 0x9c, 0x00,                \/\/ IID916\n-    0x62, 0x74, 0xb0, 0x10, 0x4e, 0x84, 0x91, 0x6b, 0xc8, 0x55, 0x66,                \/\/ IID917\n-    0x62, 0x84, 0xe0, 0x10, 0x4f, 0xac, 0x0a, 0xf5, 0xbc, 0xfa, 0xef,                \/\/ IID918\n+    0x62, 0x6c, 0x74, 0x18, 0x0b, 0xc6,                                              \/\/ IID432\n+    0xd5, 0x10, 0x0b, 0xcb,                                                          \/\/ IID433\n+    0xd5, 0x55, 0x0b, 0xdb,                                                          \/\/ IID434\n+    0x62, 0x54, 0x04, 0x14, 0x0b, 0xcd,                                              \/\/ IID435\n+    0x62, 0x6c, 0x04, 0x14, 0x0b, 0xff,                                              \/\/ IID436\n+    0x62, 0xec, 0x64, 0x14, 0x0b, 0xcb,                                              \/\/ IID437\n+    0x62, 0x6c, 0x5c, 0x10, 0xa5, 0xc0,                                              \/\/ IID438\n+    0x44, 0x0f, 0xa5, 0xe2,                                                          \/\/ IID439\n+    0x62, 0x44, 0x14, 0x14, 0xa5, 0xf9,                                              \/\/ IID440\n+    0x62, 0xec, 0x74, 0x14, 0xa5, 0xe1,                                              \/\/ IID441\n+    0x62, 0xc4, 0x5c, 0x10, 0xad, 0xd7,                                              \/\/ IID442\n+    0x44, 0x0f, 0xad, 0xe1,                                                          \/\/ IID443\n+    0x62, 0xc4, 0x0c, 0x1c, 0xad, 0xf9,                                              \/\/ IID444\n+    0x62, 0x7c, 0x64, 0x14, 0xad, 0xeb,                                              \/\/ IID445\n+    0x62, 0x4c, 0x0c, 0x10, 0x2b, 0xdb,                                              \/\/ IID446\n+    0x41, 0x2b, 0xd3,                                                                \/\/ IID447\n+    0x62, 0x5c, 0x04, 0x1c, 0x2b, 0xd8,                                              \/\/ IID448\n+    0x62, 0x5c, 0x0c, 0x1c, 0x2b, 0xf1,                                              \/\/ IID449\n+    0x62, 0xc4, 0x04, 0x10, 0x33, 0xc4,                                              \/\/ IID450\n+    0xd5, 0x41, 0x33, 0xe6,                                                          \/\/ IID451\n+    0xd5, 0x45, 0x33, 0xf5,                                                          \/\/ IID452\n+    0x62, 0xec, 0x3c, 0x14, 0x33, 0xc9,                                              \/\/ IID453\n+    0x62, 0x6c, 0x2c, 0x14, 0x33, 0xd5,                                              \/\/ IID454\n+    0x62, 0x54, 0x24, 0x1c, 0x33, 0xeb,                                              \/\/ IID455\n+    0x62, 0xcc, 0x24, 0x10, 0x24, 0xe9, 0x04,                                        \/\/ IID456\n+    0xd5, 0x94, 0xa4, 0xd6, 0x04,                                                    \/\/ IID457\n+    0x62, 0x44, 0x54, 0x14, 0x24, 0xc7, 0x10,                                        \/\/ IID458\n+    0x62, 0xe4, 0x6c, 0x1c, 0x24, 0xda, 0x01,                                        \/\/ IID459\n+    0x62, 0x54, 0x44, 0x10, 0x2c, 0xc5, 0x10,                                        \/\/ IID460\n+    0xd5, 0xd1, 0xac, 0xf2, 0x01,                                                    \/\/ IID461\n+    0x62, 0x44, 0x3c, 0x14, 0x2c, 0xf1, 0x10,                                        \/\/ IID462\n+    0x62, 0x7c, 0x64, 0x14, 0x2c, 0xc3, 0x04,                                        \/\/ IID463\n+    0x62, 0x6c, 0x0c, 0x10, 0x40, 0xd1,                                              \/\/ IID464\n+    0xd5, 0x95, 0x40, 0xf2,                                                          \/\/ IID465\n+    0x62, 0xcc, 0x3c, 0x10, 0x41, 0xdd,                                              \/\/ IID466\n+    0xd5, 0xd4, 0x41, 0xcc,                                                          \/\/ IID467\n+    0x62, 0x54, 0x24, 0x18, 0x42, 0xd6,                                              \/\/ IID468\n+    0xd5, 0xd5, 0x42, 0xf1,                                                          \/\/ IID469\n+    0x62, 0xcc, 0x14, 0x18, 0x43, 0xf3,                                              \/\/ IID470\n+    0xd5, 0xd1, 0x43, 0xc0,                                                          \/\/ IID471\n+    0x62, 0x5c, 0x1c, 0x10, 0x44, 0xee,                                              \/\/ IID472\n+    0xd5, 0xd5, 0x44, 0xf0,                                                          \/\/ IID473\n+    0x62, 0xcc, 0x54, 0x10, 0x45, 0xe7,                                              \/\/ IID474\n+    0xd5, 0x94, 0x45, 0xc0,                                                          \/\/ IID475\n+    0x62, 0x6c, 0x04, 0x18, 0x46, 0xd6,                                              \/\/ IID476\n+    0xd5, 0xc4, 0x46, 0xfa,                                                          \/\/ IID477\n+    0x62, 0x54, 0x24, 0x10, 0x47, 0xc2,                                              \/\/ IID478\n+    0xd5, 0xc1, 0x47, 0xd3,                                                          \/\/ IID479\n+    0x62, 0xfc, 0x24, 0x10, 0x48, 0xdd,                                              \/\/ IID480\n+    0xd5, 0x95, 0x48, 0xe7,                                                          \/\/ IID481\n+    0x62, 0xfc, 0x1c, 0x18, 0x49, 0xd2,                                              \/\/ IID482\n+    0xd5, 0xd0, 0x49, 0xd3,                                                          \/\/ IID483\n+    0x62, 0xec, 0x7c, 0x10, 0x4a, 0xe7,                                              \/\/ IID484\n+    0xd5, 0xd0, 0x4a, 0xd0,                                                          \/\/ IID485\n+    0x62, 0x4c, 0x64, 0x18, 0x4b, 0xfe,                                              \/\/ IID486\n+    0xd5, 0xd5, 0x4b, 0xfd,                                                          \/\/ IID487\n+    0x62, 0x44, 0x1c, 0x10, 0x4c, 0xca,                                              \/\/ IID488\n+    0xd5, 0xd4, 0x4c, 0xc4,                                                          \/\/ IID489\n+    0x62, 0xdc, 0x7c, 0x10, 0x4d, 0xd2,                                              \/\/ IID490\n+    0xd5, 0xd5, 0x4d, 0xe4,                                                          \/\/ IID491\n+    0x62, 0xcc, 0x34, 0x18, 0x4e, 0xe0,                                              \/\/ IID492\n+    0xd5, 0xd5, 0x4e, 0xc5,                                                          \/\/ IID493\n+    0x62, 0x44, 0x44, 0x10, 0x4f, 0xdf,                                              \/\/ IID494\n+    0xd5, 0x94, 0x4f, 0xe2,                                                          \/\/ IID495\n+    0x62, 0x5c, 0x64, 0x10, 0x40, 0x8c, 0x4f, 0x43, 0x67, 0x41, 0xfd,                \/\/ IID496\n+    0xd5, 0xb6, 0x40, 0x84, 0x45, 0xcb, 0xa0, 0xe6, 0x41,                            \/\/ IID497\n+    0x62, 0x3c, 0x40, 0x10, 0x41, 0xbc, 0xf3, 0xd3, 0x01, 0x52, 0xaa,                \/\/ IID498\n+    0xd5, 0x91, 0x41, 0x94, 0x13, 0xcb, 0xd8, 0x5e, 0xe5,                            \/\/ IID499\n+    0x62, 0x0c, 0x64, 0x18, 0x42, 0xac, 0x27, 0x46, 0x22, 0xd4, 0x0b,                \/\/ IID500\n+    0xd5, 0xf0, 0x42, 0xac, 0x6b, 0xe8, 0x77, 0xae, 0xbe,                            \/\/ IID501\n+    0x62, 0x2c, 0x44, 0x10, 0x43, 0xac, 0x8e, 0x28, 0x24, 0x52, 0xca,                \/\/ IID502\n+    0xd5, 0xd1, 0x43, 0x91, 0xc3, 0x84, 0x21, 0x63,                                  \/\/ IID503\n+    0x62, 0x3c, 0x14, 0x10, 0x44, 0xac, 0x2a, 0x3a, 0x15, 0x8d, 0xc6,                \/\/ IID504\n+    0xd5, 0xc7, 0x44, 0xac, 0xcc, 0x2e, 0x20, 0x73, 0x99,                            \/\/ IID505\n+    0x62, 0xc4, 0x30, 0x10, 0x45, 0x94, 0xb1, 0x1f, 0xc9, 0x6a, 0x7f,                \/\/ IID506\n+    0xd5, 0xd5, 0x45, 0xa6, 0x94, 0x65, 0x2e, 0x56,                                  \/\/ IID507\n+    0x62, 0x44, 0x20, 0x10, 0x46, 0x84, 0xa7, 0x49, 0xc7, 0x9a, 0xb9,                \/\/ IID508\n+    0xd5, 0xd7, 0x46, 0x8c, 0xda, 0x57, 0xed, 0xc7, 0xa6,                            \/\/ IID509\n+    0x62, 0xec, 0x74, 0x18, 0x47, 0xa0, 0x15, 0x5c, 0x76, 0xec,                      \/\/ IID510\n+    0xd5, 0x93, 0x47, 0x9c, 0x05, 0x15, 0x26, 0x02, 0x1d,                            \/\/ IID511\n+    0x62, 0x14, 0x68, 0x18, 0x48, 0xb4, 0x64, 0x6f, 0xa5, 0x8d, 0xae,                \/\/ IID512\n+    0xd5, 0xf4, 0x48, 0x84, 0x51, 0x1c, 0x3b, 0xda, 0xe8,                            \/\/ IID513\n+    0xd5, 0xa1, 0x49, 0x8c, 0xbf, 0x31, 0xd3, 0x2d, 0x94,                            \/\/ IID514\n+    0xd5, 0xc7, 0x49, 0x84, 0x57, 0xf7, 0xc2, 0x04, 0x80,                            \/\/ IID515\n+    0x62, 0xd4, 0x40, 0x10, 0x4a, 0x8c, 0x3b, 0x85, 0xc5, 0x38, 0x37,                \/\/ IID516\n+    0xd5, 0xd7, 0x4a, 0x84, 0x16, 0xa8, 0x15, 0xcc, 0x0f,                            \/\/ IID517\n+    0x62, 0x44, 0x08, 0x18, 0x4b, 0x94, 0x6e, 0x61, 0x31, 0xcf, 0xbb,                \/\/ IID518\n+    0xd5, 0x95, 0x4b, 0x94, 0x24, 0x9f, 0xc5, 0xd7, 0x03,                            \/\/ IID519\n+    0x62, 0x84, 0x2c, 0x18, 0x4c, 0xac, 0xc0, 0xb4, 0x84, 0x65, 0x4a,                \/\/ IID520\n+    0xd5, 0xf4, 0x4c, 0x94, 0xe3, 0xef, 0x60, 0xc6, 0x47,                            \/\/ IID521\n+    0x62, 0x74, 0x2c, 0x10, 0x4d, 0x91, 0x97, 0x7a, 0x97, 0x61,                      \/\/ IID522\n+    0xd5, 0xe5, 0x4d, 0xb4, 0xdf, 0xcb, 0x01, 0xc6, 0x53,                            \/\/ IID523\n+    0x62, 0x7c, 0x0c, 0x18, 0x4e, 0x89, 0x1e, 0x11, 0x93, 0xa9,                      \/\/ IID524\n+    0xd5, 0xb5, 0x4e, 0xbc, 0x23, 0x92, 0x47, 0x16, 0x76,                            \/\/ IID525\n+    0x62, 0x14, 0x24, 0x10, 0x4f, 0xb4, 0xa9, 0xd7, 0x52, 0x57, 0x0f,                \/\/ IID526\n+    0x44, 0x0f, 0x4f, 0xa4, 0xcb, 0x3a, 0x4b, 0xfe, 0xaa,                            \/\/ IID527\n+    0xd5, 0x5d, 0x13, 0xf7,                                                          \/\/ IID528\n+    0x4c, 0x3b, 0xe2,                                                                \/\/ IID529\n+    0xd5, 0xd9, 0xaf, 0xe8,                                                          \/\/ IID530\n+    0xf3, 0xd5, 0x9d, 0xb8, 0xc9,                                                    \/\/ IID531\n+    0x4d, 0x1b, 0xc4,                                                                \/\/ IID532\n+    0xd5, 0x5d, 0x2b, 0xf8,                                                          \/\/ IID533\n+    0xf3, 0xd5, 0x9c, 0xbc, 0xd0,                                                    \/\/ IID534\n+    0xf3, 0xd5, 0xd8, 0xbd, 0xe5,                                                    \/\/ IID535\n+    0xd5, 0x18, 0x03, 0xd1,                                                          \/\/ IID536\n+    0x4d, 0x23, 0xf5,                                                                \/\/ IID537\n+    0xd5, 0x59, 0x0b, 0xe0,                                                          \/\/ IID538\n+    0xd5, 0x58, 0x33, 0xee,                                                          \/\/ IID539\n+    0xd5, 0x1d, 0x8b, 0xe3,                                                          \/\/ IID540\n+    0xd5, 0xc8, 0xbc, 0xfa,                                                          \/\/ IID541\n+    0xd5, 0xdd, 0xbd, 0xfc,                                                          \/\/ IID542\n+    0xd5, 0xcd, 0xa3, 0xc8,                                                          \/\/ IID543\n+    0xd5, 0x48, 0x87, 0xeb,                                                          \/\/ IID544\n+    0xd5, 0x58, 0x85, 0xff,                                                          \/\/ IID545\n+    0xd5, 0x1c, 0x01, 0x93, 0x5f, 0xc1, 0xf2, 0xe7,                                  \/\/ IID546\n+    0xd5, 0x6d, 0x21, 0x8c, 0x4b, 0x18, 0x94, 0x68, 0x87,                            \/\/ IID547\n+    0xd5, 0x2e, 0x39, 0xac, 0xe3, 0x02, 0x21, 0xf7, 0x35,                            \/\/ IID548\n+    0xd5, 0x49, 0x09, 0xa8, 0xef, 0xaf, 0xb9, 0xcb,                                  \/\/ IID549\n+    0xd5, 0x58, 0x31, 0x93, 0x23, 0xdd, 0xb4, 0xbf,                                  \/\/ IID550\n+    0xd5, 0x3e, 0x29, 0xb4, 0xdf, 0xba, 0xd9, 0x72, 0xbd,                            \/\/ IID551\n+    0xd5, 0x4d, 0x89, 0xa4, 0x89, 0x9f, 0xe9, 0x9e, 0x8d,                            \/\/ IID552\n+    0xd5, 0xb9, 0xc1, 0x9c, 0xa8, 0x90, 0xe9, 0x6b, 0x3a,                            \/\/ IID553\n+    0xd5, 0x1a, 0x81, 0xa4, 0x16, 0xdd, 0x8b, 0xef, 0x07, 0x00, 0x00, 0x10, 0x00,    \/\/ IID554\n+    0xd5, 0x2b, 0x81, 0x84, 0x25, 0x4f, 0x76, 0xb8, 0x8a, 0x00, 0x00, 0x01, 0x00,    \/\/ IID555\n+    0x49, 0x81, 0xba, 0x26, 0x57, 0x2d, 0xf4, 0x00, 0x00, 0x00, 0x10,                \/\/ IID556\n+    0xd5, 0x1a, 0xc1, 0xbc, 0x77, 0xf5, 0xd9, 0x16, 0x6a, 0x04,                      \/\/ IID557\n+    0xd5, 0x28, 0xc1, 0xa4, 0x69, 0x1e, 0xac, 0x66, 0x5f, 0x08,                      \/\/ IID558\n+    0xd5, 0x28, 0x81, 0x9c, 0xf1, 0xb4, 0x6a, 0x73, 0xfb, 0x00, 0x00, 0x00, 0x10,    \/\/ IID559\n+    0xd5, 0x3a, 0xc1, 0xac, 0x35, 0x0b, 0x5b, 0x40, 0x0e, 0x08,                      \/\/ IID560\n+    0xd5, 0x3a, 0x81, 0xac, 0xeb, 0xb5, 0xfb, 0x9d, 0x88, 0x00, 0x10, 0x00, 0x00,    \/\/ IID561\n+    0xd5, 0x1b, 0x83, 0xb4, 0x56, 0xdd, 0x7c, 0x86, 0xe6, 0x10,                      \/\/ IID562\n+    0xd5, 0x2a, 0x81, 0x8c, 0xc2, 0x16, 0xb3, 0xd9, 0x18, 0x00, 0x10, 0x00, 0x00,    \/\/ IID563\n+    0x48, 0xc7, 0x83, 0xb3, 0xf8, 0xa7, 0xcf, 0x00, 0x01, 0x00, 0x00,                \/\/ IID564\n+    0xd5, 0x39, 0xf7, 0x84, 0xec, 0xc4, 0xfd, 0xa0, 0x65, 0x00, 0x00, 0x00, 0xf0,    \/\/ IID565\n+    0xd5, 0x69, 0x03, 0xbc, 0x13, 0xf4, 0x0e, 0xe5, 0xe2,                            \/\/ IID566\n+    0xd5, 0x5a, 0x23, 0xb4, 0x62, 0x38, 0x1c, 0x5f, 0x1a,                            \/\/ IID567\n+    0xd5, 0x79, 0x3b, 0xbc, 0x1e, 0x81, 0xd0, 0x6e, 0xc1,                            \/\/ IID568\n+    0xf3, 0xd5, 0xcc, 0xbd, 0xa9, 0xe4, 0xfb, 0xe3, 0x12,                            \/\/ IID569\n+    0xd5, 0x3c, 0x0b, 0xb4, 0xad, 0x42, 0x30, 0xd7, 0x00,                            \/\/ IID570\n+    0xd5, 0x7e, 0x13, 0xbc, 0xb9, 0x12, 0xe9, 0xbd, 0x0a,                            \/\/ IID571\n+    0xd5, 0xeb, 0xaf, 0xa4, 0x1d, 0xe1, 0x03, 0x24, 0xa7,                            \/\/ IID572\n+    0xf3, 0xd5, 0x98, 0xb8, 0x9e, 0xdd, 0x93, 0x39, 0x8d,                            \/\/ IID573\n+    0xd5, 0x4d, 0x1b, 0x91, 0x09, 0xba, 0x4a, 0x33,                                  \/\/ IID574\n+    0xd5, 0x2f, 0x2b, 0x8c, 0xf1, 0xfe, 0x9e, 0x65, 0xde,                            \/\/ IID575\n+    0xf3, 0xd5, 0xdc, 0xbc, 0x8c, 0x24, 0x4f, 0x45, 0xce, 0xde,                      \/\/ IID576\n+    0xd5, 0x79, 0x33, 0x84, 0x44, 0xb9, 0x83, 0xc4, 0x48,                            \/\/ IID577\n+    0xd5, 0x6d, 0x8b, 0xb4, 0x01, 0xb1, 0x17, 0x73, 0xf7,                            \/\/ IID578\n+    0xd5, 0x3f, 0x8d, 0x9c, 0xae, 0xd0, 0x8f, 0xeb, 0x3e,                            \/\/ IID579\n+    0xf2, 0xd5, 0xdf, 0x2c, 0x94, 0xd5, 0x2e, 0x82, 0xf4, 0x3e,                      \/\/ IID580\n+    0xd5, 0x7c, 0x87, 0xac, 0xa3, 0x47, 0xc2, 0xf0, 0xc0,                            \/\/ IID581\n+    0xd5, 0x3d, 0x85, 0x84, 0x26, 0x17, 0x6a, 0xb5, 0x15,                            \/\/ IID582\n+    0xd5, 0x19, 0x81, 0xc2, 0x00, 0x10, 0x00, 0x00,                                  \/\/ IID583\n+    0xd5, 0x18, 0x83, 0xe4, 0x10,                                                    \/\/ IID584\n+    0xd5, 0x18, 0x81, 0xd7, 0x00, 0x00, 0x10, 0x00,                                  \/\/ IID585\n+    0x49, 0x81, 0xfc, 0x00, 0x10, 0x00, 0x00,                                        \/\/ IID586\n+    0x48, 0xc1, 0xd1, 0x04,                                                          \/\/ IID587\n+    0x49, 0xd1, 0xde,                                                                \/\/ IID588\n+    0xd5, 0x18, 0xc1, 0xc7, 0x02,                                                    \/\/ IID589\n+    0x49, 0xc1, 0xcc, 0x04,                                                          \/\/ IID590\n+    0x49, 0xc1, 0xfa, 0x04,                                                          \/\/ IID591\n+    0xd5, 0x18, 0xc1, 0xe4, 0x04,                                                    \/\/ IID592\n+    0x48, 0x81, 0xd9, 0x00, 0x00, 0x10, 0x00,                                        \/\/ IID593\n+    0xd5, 0x18, 0xc1, 0xe7, 0x10,                                                    \/\/ IID594\n+    0xd5, 0x19, 0xc1, 0xeb, 0x02,                                                    \/\/ IID595\n+    0x48, 0x81, 0xe9, 0x00, 0x00, 0x01, 0x00,                                        \/\/ IID596\n+    0x49, 0x81, 0xf1, 0x00, 0x00, 0x10, 0x00,                                        \/\/ IID597\n+    0xd5, 0x18, 0xc7, 0xc0, 0x00, 0x00, 0x01, 0x00,                                  \/\/ IID598\n+    0xd5, 0x19, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,                \/\/ IID599\n+    0xd5, 0x98, 0xba, 0xe2, 0x40,                                                    \/\/ IID600\n+    0xd5, 0x19, 0xf7, 0xc5, 0x00, 0xf0, 0xff, 0xff,                                  \/\/ IID601\n+    0xd5, 0x19, 0x81, 0xce, 0x00, 0x00, 0x00, 0x04,                                  \/\/ IID602\n+    0xd5, 0x19, 0x81, 0xe9, 0x00, 0x00, 0x00, 0x10,                                  \/\/ IID603\n+    0xd5, 0xfe, 0x40, 0xb4, 0xb9, 0xf0, 0x92, 0xff, 0x47,                            \/\/ IID604\n+    0xd5, 0xbf, 0x41, 0x8c, 0x60, 0xc0, 0x04, 0x49, 0x38,                            \/\/ IID605\n+    0xd5, 0xfa, 0x42, 0xbc, 0xc7, 0x9a, 0xed, 0x80, 0xe6,                            \/\/ IID606\n+    0xd5, 0xbf, 0x43, 0x8c, 0x35, 0xc8, 0x49, 0x5d, 0x2b,                            \/\/ IID607\n+    0xd5, 0xca, 0x44, 0x84, 0x7b, 0x81, 0x93, 0x37, 0x22,                            \/\/ IID608\n+    0x4d, 0x0f, 0x45, 0x83, 0xa0, 0x67, 0x9d, 0x04,                                  \/\/ IID609\n+    0xd5, 0xfc, 0x46, 0xa4, 0x80, 0x57, 0xe2, 0x6b, 0xa1,                            \/\/ IID610\n+    0xd5, 0xda, 0x47, 0x9c, 0x02, 0x14, 0xaa, 0xa1, 0xf5,                            \/\/ IID611\n+    0xd5, 0xfe, 0x48, 0xa4, 0x61, 0xf4, 0xdd, 0x9b, 0xcd,                            \/\/ IID612\n+    0xd5, 0xef, 0x49, 0xbc, 0x7e, 0x5a, 0xbc, 0x01, 0x50,                            \/\/ IID613\n+    0xd5, 0xb8, 0x4a, 0x9c, 0x8a, 0x87, 0xdc, 0x90, 0xd7,                            \/\/ IID614\n+    0xd5, 0xd8, 0x4b, 0x8c, 0x24, 0xc8, 0x07, 0xb6, 0xaa,                            \/\/ IID615\n+    0xd5, 0xef, 0x4c, 0xb4, 0x61, 0x0d, 0xf3, 0x4f, 0xda,                            \/\/ IID616\n+    0xd5, 0xc9, 0x4d, 0x99, 0xd4, 0x0d, 0x54, 0xd5,                                  \/\/ IID617\n+    0x4a, 0x0f, 0x4e, 0x9c, 0x61, 0x34, 0x97, 0xd2, 0xbc,                            \/\/ IID618\n+    0xd5, 0xa9, 0x4f, 0x9c, 0xcf, 0xa2, 0xa9, 0x68, 0xd4,                            \/\/ IID619\n+    0xd5, 0x11, 0xff, 0xd0,                                                          \/\/ IID620\n+    0x49, 0xf7, 0xf1,                                                                \/\/ IID621\n+    0xd5, 0x19, 0xf7, 0xfc,                                                          \/\/ IID622\n+    0x48, 0xf7, 0xea,                                                                \/\/ IID623\n+    0xd5, 0x19, 0xf7, 0xe7,                                                          \/\/ IID624\n+    0x49, 0xf7, 0xdc,                                                                \/\/ IID625\n+    0x49, 0xf7, 0xd4,                                                                \/\/ IID626\n+    0xd5, 0x19, 0xd3, 0xc0,                                                          \/\/ IID627\n+    0xd5, 0x19, 0xd3, 0xcc,                                                          \/\/ IID628\n+    0x49, 0xd3, 0xfb,                                                                \/\/ IID629\n+    0xd5, 0x19, 0xd3, 0xe3,                                                          \/\/ IID630\n+    0xd5, 0x18, 0xd3, 0xe7,                                                          \/\/ IID631\n+    0xd5, 0x18, 0xd3, 0xe9,                                                          \/\/ IID632\n+    0xd5, 0x18, 0xff, 0xc0,                                                          \/\/ IID633\n+    0x49, 0xff, 0xcc,                                                                \/\/ IID634\n+    0xd5, 0x18, 0x57,                                                                \/\/ IID635\n+    0xd5, 0x19, 0x58,                                                                \/\/ IID636\n+    0xd5, 0x12, 0xff, 0x94, 0x32, 0xce, 0x62, 0x9c, 0x99,                            \/\/ IID637\n+    0xd5, 0x19, 0xf7, 0xa0, 0xdf, 0xdb, 0xf5, 0x99,                                  \/\/ IID638\n+    0xd5, 0x29, 0xf7, 0x9c, 0x16, 0x6e, 0x93, 0xf3, 0x40,                            \/\/ IID639\n+    0x4b, 0xd3, 0xbc, 0x2a, 0x72, 0xcb, 0x04, 0x7d,                                  \/\/ IID640\n+    0xd5, 0x1a, 0xd3, 0xa4, 0xda, 0x24, 0x4b, 0x89, 0xde,                            \/\/ IID641\n+    0x49, 0xd3, 0xac, 0x4d, 0x80, 0xaa, 0x96, 0x79,                                  \/\/ IID642\n+    0x49, 0xff, 0x86, 0x2a, 0xd0, 0xc2, 0x67,                                        \/\/ IID643\n+    0xd5, 0x3a, 0xff, 0x8c, 0x16, 0xc0, 0x62, 0x4f, 0x22,                            \/\/ IID644\n+    0xd5, 0x19, 0x69, 0x94, 0x5f, 0x10, 0xbb, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x01,    \/\/ IID645\n+    0xd5, 0x59, 0x69, 0xef, 0x00, 0x10, 0x00, 0x00,                                  \/\/ IID646\n+    0xd5, 0xc8, 0xa4, 0xdb, 0x01,                                                    \/\/ IID647\n+    0xd5, 0xc9, 0xac, 0xfb, 0x04,                                                    \/\/ IID648\n+    0x62, 0xfc, 0x0c, 0x10, 0x8f, 0xc0,                                              \/\/ IID649\n+    0x62, 0xfc, 0xe4, 0x18, 0x8f, 0xc1,                                              \/\/ IID650\n+    0x62, 0xfc, 0x0c, 0x10, 0xff, 0xf4,                                              \/\/ IID651\n+    0x62, 0xd4, 0x84, 0x10, 0xff, 0xf0,                                              \/\/ IID652\n+    0xd5, 0xcf, 0xb6, 0xa4, 0x30, 0x7a, 0xe6, 0x9a, 0x46,                            \/\/ IID653\n+    0xd5, 0xad, 0xb7, 0xb4, 0x90, 0xfe, 0x61, 0x96, 0xb7,                            \/\/ IID654\n+    0xd5, 0xc8, 0xbe, 0xab, 0x95, 0x1f, 0x25, 0x9b,                                  \/\/ IID655\n+    0xd5, 0xd9, 0xbf, 0x9c, 0x9f, 0x19, 0x88, 0x31, 0x60,                            \/\/ IID656\n+    0xd5, 0xcd, 0xb6, 0xf5,                                                          \/\/ IID657\n+    0xd5, 0xdc, 0xb7, 0xf2,                                                          \/\/ IID658\n+    0xd5, 0xc9, 0xbe, 0xdf,                                                          \/\/ IID659\n+    0xd5, 0xd8, 0xbf, 0xe0,                                                          \/\/ IID660\n+    0xd5, 0xcd, 0xb1, 0xa4, 0xdb, 0x9d, 0x47, 0xc3, 0x0f,                            \/\/ IID661\n+    0x62, 0xfc, 0xfc, 0x08, 0xf7, 0xfc,                                              \/\/ IID662\n+    0x62, 0xdc, 0xfc, 0x0c, 0xf7, 0xfe,                                              \/\/ IID663\n+    0x62, 0xfc, 0xfc, 0x08, 0xf7, 0xf6,                                              \/\/ IID664\n+    0x62, 0xd4, 0xfc, 0x0c, 0xf7, 0xf3,                                              \/\/ IID665\n+    0x62, 0xf4, 0xfc, 0x08, 0xf7, 0xe9,                                              \/\/ IID666\n+    0x62, 0xdc, 0xfc, 0x0c, 0xf7, 0xec,                                              \/\/ IID667\n+    0x62, 0xfc, 0xfc, 0x08, 0xf7, 0xe5,                                              \/\/ IID668\n+    0x62, 0xd4, 0xfc, 0x0c, 0xf7, 0xe5,                                              \/\/ IID669\n+    0x62, 0x9c, 0xfc, 0x08, 0xf7, 0xa4, 0xba, 0x6e, 0xce, 0xa1, 0x70,                \/\/ IID670\n+    0x62, 0xdc, 0xf8, 0x0c, 0xf7, 0xa4, 0x58, 0xa4, 0x7a, 0x8f, 0xe9,                \/\/ IID671\n+    0x62, 0x5c, 0xfc, 0x08, 0xaf, 0xd3,                                              \/\/ IID672\n+    0xd5, 0x18, 0xf7, 0xe9,                                                          \/\/ IID673\n+    0x62, 0xfc, 0xfc, 0x0c, 0xaf, 0xd6,                                              \/\/ IID674\n+    0x62, 0xf4, 0xfc, 0x0c, 0xaf, 0xdb,                                              \/\/ IID675\n+    0x62, 0x44, 0xfc, 0x08, 0xf5, 0xe7,                                              \/\/ IID676\n+    0x62, 0x54, 0xfc, 0x08, 0xf5, 0xff,                                              \/\/ IID677\n+    0x62, 0xd4, 0xfc, 0x0c, 0xf5, 0xdc,                                              \/\/ IID678\n+    0x62, 0xf4, 0xfc, 0x0c, 0xf5, 0xdb,                                              \/\/ IID679\n+    0x62, 0xd4, 0xac, 0x10, 0xf7, 0xdb,                                              \/\/ IID680\n+    0xd5, 0x18, 0xf7, 0xd9,                                                          \/\/ IID681\n+    0x62, 0xdc, 0xec, 0x1c, 0xf7, 0xdf,                                              \/\/ IID682\n+    0x62, 0xdc, 0xa4, 0x14, 0xf7, 0xdb,                                              \/\/ IID683\n+    0x62, 0xd4, 0x84, 0x10, 0xf7, 0xd7,                                              \/\/ IID684\n+    0xd5, 0x18, 0xf7, 0xd5,                                                          \/\/ IID685\n+    0x62, 0xdc, 0xfc, 0x08, 0x88, 0xd8,                                              \/\/ IID686\n+    0x62, 0x4c, 0xfc, 0x08, 0x88, 0xe4,                                              \/\/ IID687\n+    0x62, 0xcc, 0xfc, 0x0c, 0x88, 0xfb,                                              \/\/ IID688\n+    0x62, 0x54, 0xfc, 0x0c, 0x88, 0xed,                                              \/\/ IID689\n+    0x62, 0xdc, 0xb4, 0x10, 0xd3, 0xc4,                                              \/\/ IID690\n+    0xd5, 0x19, 0xd3, 0xc7,                                                          \/\/ IID691\n+    0x62, 0xfc, 0xb4, 0x14, 0xd3, 0xc7,                                              \/\/ IID692\n+    0x62, 0xf4, 0xf4, 0x1c, 0xd3, 0xc1,                                              \/\/ IID693\n+    0x62, 0xd4, 0xcc, 0x10, 0xd3, 0xce,                                              \/\/ IID694\n+    0x49, 0xd3, 0xcf,                                                                \/\/ IID695\n+    0x62, 0xdc, 0xa4, 0x1c, 0xd3, 0xce,                                              \/\/ IID696\n+    0x62, 0xdc, 0xbc, 0x14, 0xd3, 0xc8,                                              \/\/ IID697\n+    0x62, 0xfc, 0xac, 0x18, 0xd3, 0xe4,                                              \/\/ IID698\n+    0xd5, 0x18, 0xd3, 0xe3,                                                          \/\/ IID699\n+    0x62, 0xdc, 0xf4, 0x14, 0xd3, 0xe1,                                              \/\/ IID700\n+    0x62, 0xd4, 0x94, 0x1c, 0xd3, 0xe5,                                              \/\/ IID701\n+    0x62, 0xdc, 0x84, 0x10, 0xd3, 0xfe,                                              \/\/ IID702\n+    0xd5, 0x18, 0xd3, 0xfa,                                                          \/\/ IID703\n+    0x62, 0xdc, 0xb4, 0x14, 0xd3, 0xf9,                                              \/\/ IID704\n+    0x62, 0xdc, 0x9c, 0x14, 0xd3, 0xfc,                                              \/\/ IID705\n+    0x62, 0xdc, 0xcc, 0x10, 0xff, 0xcb,                                              \/\/ IID706\n+    0x49, 0xff, 0xcc,                                                                \/\/ IID707\n+    0x62, 0xd4, 0xec, 0x14, 0xff, 0xcb,                                              \/\/ IID708\n+    0x62, 0xd4, 0xac, 0x1c, 0xff, 0xca,                                              \/\/ IID709\n+    0x62, 0xdc, 0xdc, 0x10, 0xff, 0xc0,                                              \/\/ IID710\n+    0xd5, 0x18, 0xff, 0xc2,                                                          \/\/ IID711\n+    0x62, 0xd4, 0xe4, 0x1c, 0xff, 0xc3,                                              \/\/ IID712\n+    0x62, 0xdc, 0xac, 0x14, 0xff, 0xc2,                                              \/\/ IID713\n+    0x62, 0xd4, 0xd4, 0x10, 0xd3, 0xe0,                                              \/\/ IID714\n+    0x48, 0xd3, 0xe3,                                                                \/\/ IID715\n+    0x62, 0xfc, 0xcc, 0x14, 0xd3, 0xe5,                                              \/\/ IID716\n+    0x62, 0xdc, 0xa4, 0x14, 0xd3, 0xe3,                                              \/\/ IID717\n+    0x62, 0xfc, 0x9c, 0x18, 0xd3, 0xe8,                                              \/\/ IID718\n+    0x49, 0xd3, 0xe8,                                                                \/\/ IID719\n+    0x62, 0xd4, 0xec, 0x1c, 0xd3, 0xe9,                                              \/\/ IID720\n+    0x62, 0xfc, 0xdc, 0x14, 0xd3, 0xec,                                              \/\/ IID721\n+    0x62, 0x6c, 0xfc, 0x08, 0xf4, 0xfd,                                              \/\/ IID722\n+    0x62, 0xec, 0xfc, 0x08, 0xf4, 0xe4,                                              \/\/ IID723\n+    0x62, 0xfc, 0xfc, 0x0c, 0xf4, 0xc8,                                              \/\/ IID724\n+    0x62, 0x54, 0xfc, 0x0c, 0xf4, 0xf6,                                              \/\/ IID725\n+    0x62, 0x0c, 0xfc, 0x08, 0xaf, 0x9c, 0x49, 0x93, 0x23, 0x5a, 0x44,                \/\/ IID726\n+    0x62, 0xa4, 0xfc, 0x0c, 0xaf, 0xbc, 0x49, 0xf4, 0x10, 0x7f, 0xeb,                \/\/ IID727\n+    0x62, 0x7c, 0xf8, 0x08, 0xf5, 0xac, 0x4e, 0x6a, 0xe6, 0xf3, 0x8a,                \/\/ IID728\n+    0x62, 0x5c, 0xfc, 0x0c, 0xf5, 0xaf, 0xa7, 0x9d, 0xd4, 0xcb,                      \/\/ IID729\n+    0x62, 0x9c, 0x84, 0x10, 0xf7, 0x9c, 0x68, 0xf2, 0x95, 0x4e, 0xda,                \/\/ IID730\n+    0x62, 0x94, 0x90, 0x1c, 0xf7, 0x9c, 0xe3, 0xab, 0x13, 0x00, 0x5c,                \/\/ IID731\n+    0x62, 0xfc, 0xfc, 0x08, 0x88, 0x94, 0x8a, 0x51, 0x15, 0xec, 0x9e,                \/\/ IID732\n+    0x62, 0x54, 0xfc, 0x0c, 0x88, 0x8a, 0x78, 0x2a, 0x58, 0xa3,                      \/\/ IID733\n+    0x62, 0x9c, 0xf0, 0x10, 0xd3, 0xa4, 0x33, 0x2c, 0xda, 0x4c, 0x1b,                \/\/ IID734\n+    0x62, 0xd4, 0xb4, 0x14, 0xd3, 0xa4, 0x54, 0xce, 0x3b, 0x82, 0x62,                \/\/ IID735\n+    0x62, 0xd4, 0xb0, 0x18, 0xd3, 0xbc, 0x92, 0xb8, 0x85, 0xb5, 0xd9,                \/\/ IID736\n+    0x62, 0x94, 0xe0, 0x1c, 0xd3, 0xbc, 0x1e, 0x00, 0x1e, 0x29, 0x20,                \/\/ IID737\n+    0x62, 0x94, 0x9c, 0x18, 0xff, 0x8c, 0xb7, 0x45, 0x25, 0x08, 0xdf,                \/\/ IID738\n+    0x62, 0x94, 0xb0, 0x1c, 0xff, 0x8c, 0x4a, 0x84, 0x1d, 0x41, 0x21,                \/\/ IID739\n+    0x62, 0xb4, 0xd8, 0x10, 0xff, 0x84, 0xcb, 0x9e, 0x32, 0xf0, 0x02,                \/\/ IID740\n+    0x62, 0x94, 0xa8, 0x1c, 0xff, 0x84, 0x3c, 0x74, 0xa3, 0xaf, 0xc8,                \/\/ IID741\n+    0x62, 0xbc, 0xbc, 0x10, 0xd3, 0xac, 0xf7, 0x50, 0xa5, 0x18, 0x8e,                \/\/ IID742\n+    0x62, 0xbc, 0xb4, 0x14, 0xd3, 0xac, 0x53, 0x88, 0x0a, 0x7b, 0x50,                \/\/ IID743\n+    0x62, 0x64, 0xf8, 0x08, 0xf4, 0xbc, 0x03, 0x2a, 0x19, 0xd5, 0x19,                \/\/ IID744\n+    0x62, 0x3c, 0xf8, 0x0c, 0xf4, 0x8c, 0xa6, 0xcd, 0x07, 0x10, 0x21,                \/\/ IID745\n+    0x62, 0x6c, 0xfc, 0x10, 0x01, 0xa4, 0xdd, 0xe2, 0x05, 0xdc, 0xf7,                \/\/ IID746\n+    0x4e, 0x03, 0xbc, 0xc2, 0xa8, 0x5f, 0x46, 0xcb,                                  \/\/ IID747\n+    0x62, 0x14, 0xb8, 0x14, 0x01, 0xac, 0xc6, 0xd2, 0x59, 0xdc, 0x6c,                \/\/ IID748\n+    0x62, 0x9c, 0xe4, 0x1c, 0x01, 0x9c, 0xf3, 0xde, 0xe8, 0xc5, 0x36,                \/\/ IID749\n+    0x62, 0x0c, 0xd0, 0x10, 0x21, 0x9c, 0x5b, 0xed, 0xc4, 0xfd, 0xd3,                \/\/ IID750\n+    0xd5, 0x5e, 0x23, 0xbc, 0xbd, 0x4a, 0xc7, 0xf2, 0x6e,                            \/\/ IID751\n+    0x62, 0x0c, 0x90, 0x1c, 0x21, 0x9c, 0x4f, 0xab, 0xe9, 0x4f, 0x73,                \/\/ IID752\n+    0x62, 0x14, 0x80, 0x1c, 0x21, 0xbc, 0xee, 0xaa, 0x7a, 0x19, 0xf9,                \/\/ IID753\n+    0x62, 0x0c, 0x9c, 0x18, 0x09, 0xa4, 0xfe, 0x9e, 0x3f, 0xa3, 0x3b,                \/\/ IID754\n+    0xd5, 0x4b, 0x0b, 0x84, 0x0c, 0xcd, 0xc4, 0x1f, 0xd7,                            \/\/ IID755\n+    0x62, 0x04, 0xb8, 0x1c, 0x09, 0x9c, 0xc8, 0x6b, 0x42, 0xbd, 0xe1,                \/\/ IID756\n+    0x62, 0xdc, 0xf4, 0x1c, 0x09, 0x8c, 0x9b, 0xad, 0xbc, 0xe4, 0x7b,                \/\/ IID757\n+    0x62, 0xfc, 0xb8, 0x10, 0x29, 0x94, 0xb7, 0xd7, 0x27, 0x88, 0x6f,                \/\/ IID758\n+    0x62, 0xc4, 0xd4, 0x10, 0x29, 0xaa, 0x38, 0x47, 0xca, 0xf9,                      \/\/ IID759\n+    0x62, 0x9c, 0xc0, 0x14, 0x29, 0x9c, 0xd3, 0xc0, 0xbc, 0x22, 0x09,                \/\/ IID760\n+    0x62, 0x2c, 0xb4, 0x14, 0x29, 0x8c, 0x3f, 0x54, 0x6b, 0x0b, 0xc7,                \/\/ IID761\n+    0x62, 0xd4, 0xa0, 0x18, 0x31, 0x8c, 0x9c, 0xe9, 0x13, 0x8e, 0xa4,                \/\/ IID762\n+    0xd5, 0x7c, 0x33, 0xa4, 0x13, 0x7e, 0x9b, 0x6b, 0x71,                            \/\/ IID763\n+    0x62, 0xa4, 0xd0, 0x14, 0x31, 0x84, 0x29, 0xe2, 0xbb, 0x0f, 0xa5,                \/\/ IID764\n+    0x62, 0x3c, 0x98, 0x1c, 0x31, 0xa4, 0x14, 0xb1, 0x7f, 0x0b, 0x0e,                \/\/ IID765\n+    0x62, 0xf4, 0x8c, 0x10, 0x81, 0x81, 0x4f, 0x7b, 0x3b, 0x2d, 0x00, 0x00, 0x10, 0x00, \/\/ IID766\n+    0x62, 0xbc, 0x8c, 0x1c, 0x81, 0x84, 0xbd, 0x18, 0x51, 0xdd, 0xed, 0x00, 0x10, 0x00, 0x00, \/\/ IID767\n+    0x62, 0xbc, 0xc0, 0x10, 0x83, 0xa4, 0x3c, 0x96, 0xb2, 0x91, 0xf6, 0x10,          \/\/ IID768\n+    0x62, 0xf4, 0xac, 0x1c, 0x83, 0xa4, 0xd2, 0x7c, 0xf1, 0x75, 0x38, 0x01,          \/\/ IID769\n+    0x62, 0xa4, 0xf8, 0x08, 0x69, 0x8c, 0x89, 0x76, 0x10, 0xc7, 0x32, 0x00, 0x10, 0x00, 0x00, \/\/ IID770\n+    0x62, 0xcc, 0xfc, 0x0c, 0x69, 0x9c, 0x9f, 0x0d, 0xa6, 0xad, 0x7b, 0x00, 0x00, 0x10, 0x00, \/\/ IID771\n+    0x62, 0xfc, 0xb0, 0x10, 0x81, 0x8c, 0x7a, 0x44, 0x74, 0x14, 0x48, 0x00, 0x00, 0x00, 0x01, \/\/ IID772\n+    0x62, 0x9c, 0x90, 0x14, 0x81, 0x8c, 0x5a, 0xa8, 0xc6, 0xee, 0xb4, 0x00, 0x00, 0x10, 0x00, \/\/ IID773\n+    0x62, 0xfc, 0x84, 0x10, 0xc1, 0xa2, 0x8c, 0xc3, 0xef, 0xb9, 0x02,                \/\/ IID774\n+    0x62, 0x94, 0xb4, 0x14, 0xc1, 0xa4, 0x3a, 0xa4, 0x5d, 0x92, 0x48, 0x10,          \/\/ IID775\n+    0x62, 0xfc, 0xac, 0x10, 0xc1, 0xba, 0xbe, 0x3a, 0x5e, 0xa1, 0x08,                \/\/ IID776\n+    0x62, 0xd4, 0x98, 0x1c, 0xc1, 0xbc, 0xb2, 0x64, 0x82, 0x95, 0x5d, 0x08,          \/\/ IID777\n+    0x62, 0xfc, 0xe8, 0x18, 0xc1, 0xac, 0xa1, 0x23, 0xdd, 0x5a, 0x29, 0x10,          \/\/ IID778\n+    0x62, 0xbc, 0xe0, 0x1c, 0xc1, 0xac, 0x66, 0xcb, 0x29, 0x29, 0x78, 0x02,          \/\/ IID779\n+    0x62, 0xfc, 0xe4, 0x10, 0x83, 0xaf, 0x8e, 0xe2, 0x7e, 0xb6, 0x01,                \/\/ IID780\n+    0x62, 0xbc, 0xbc, 0x1c, 0x81, 0xac, 0xb3, 0x66, 0x51, 0xd4, 0xe4, 0x00, 0x00, 0x10, 0x00, \/\/ IID781\n+    0x62, 0xb4, 0xe4, 0x10, 0x81, 0xb4, 0x11, 0xe9, 0x6e, 0xa6, 0x45, 0x00, 0x00, 0x10, 0x00, \/\/ IID782\n+    0x62, 0x94, 0x98, 0x14, 0x83, 0xb4, 0x29, 0xec, 0x6c, 0x5e, 0xd7, 0x10,          \/\/ IID783\n+    0x62, 0xf4, 0xbc, 0x18, 0x81, 0xc1, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID784\n+    0x62, 0xd4, 0xfc, 0x18, 0x81, 0xc6, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID785\n+    0xd5, 0x18, 0x81, 0xc0, 0x00, 0x01, 0x00, 0x00,                                  \/\/ IID786\n+    0x62, 0xd4, 0xbc, 0x14, 0x81, 0xc1, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID787\n+    0x62, 0xfc, 0xfc, 0x1c, 0x81, 0xc2, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID788\n+    0x62, 0xd4, 0xbc, 0x1c, 0x83, 0xc0, 0x01,                                        \/\/ IID789\n+    0x62, 0xfc, 0x84, 0x18, 0x81, 0xe6, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID790\n+    0x62, 0xdc, 0xfc, 0x18, 0x81, 0xe2, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID791\n+    0x48, 0x81, 0xe2, 0x00, 0x10, 0x00, 0x00,                                        \/\/ IID792\n+    0x62, 0xfc, 0xec, 0x1c, 0x81, 0xe6, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID793\n+    0x62, 0xdc, 0xfc, 0x1c, 0x81, 0xe5, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID794\n+    0x62, 0xfc, 0xc4, 0x14, 0x81, 0xe7, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID795\n+    0x62, 0x54, 0xfc, 0x08, 0x69, 0xcd, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID796\n+    0x62, 0xfc, 0xfc, 0x08, 0x69, 0xc2, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID797\n+    0x62, 0xec, 0xfc, 0x08, 0x69, 0xc0, 0x00, 0x00, 0x10, 0x00,                      \/\/ IID798\n+    0x62, 0xec, 0xfc, 0x0c, 0x6b, 0xcf, 0x01,                                        \/\/ IID799\n+    0x62, 0xd4, 0xfc, 0x0c, 0x6b, 0xc4, 0x01,                                        \/\/ IID800\n+    0x62, 0x54, 0xfc, 0x0c, 0x69, 0xd2, 0x00, 0x00, 0x00, 0x10,                      \/\/ IID801\n+    0x62, 0xfc, 0xec, 0x18, 0x81, 0xcb, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID802\n+    0x62, 0xd4, 0xfc, 0x18, 0x81, 0xce, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID803\n+    0x49, 0x83, 0xcd, 0x01,                                                          \/\/ IID804\n+    0x62, 0xdc, 0xb4, 0x14, 0x81, 0xcd, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID805\n+    0x62, 0xf4, 0xfc, 0x1c, 0x81, 0xca, 0x00, 0x01, 0x00, 0x00,                      \/\/ IID806\n+    0x62, 0xfc, 0xfc, 0x14, 0x83, 0xc8, 0x10,                                        \/\/ IID807\n+    0x62, 0xfc, 0x94, 0x18, 0xc1, 0xd3, 0x04,                                        \/\/ IID808\n+    0x62, 0xd4, 0xfc, 0x18, 0xc1, 0xd4, 0x04,                                        \/\/ IID809\n+    0x49, 0xc1, 0xd1, 0x04,                                                          \/\/ IID810\n+    0x62, 0xfc, 0x94, 0x18, 0xd1, 0xc0,                                              \/\/ IID811\n+    0x62, 0xdc, 0xfc, 0x18, 0xd1, 0xc7,                                              \/\/ IID812\n+    0xd5, 0x19, 0xc1, 0xc6, 0x08,                                                    \/\/ IID813\n+    0x62, 0xfc, 0x8c, 0x14, 0xc1, 0xc4, 0x08,                                        \/\/ IID814\n+    0x62, 0xdc, 0xfc, 0x1c, 0xc1, 0xc7, 0x08,                                        \/\/ IID815\n+    0x62, 0xdc, 0x84, 0x14, 0xc1, 0xc7, 0x04,                                        \/\/ IID816\n+    0x62, 0xd4, 0xcc, 0x10, 0xc1, 0xca, 0x04,                                        \/\/ IID817\n+    0x62, 0xd4, 0xfc, 0x18, 0xc1, 0xcd, 0x04,                                        \/\/ IID818\n+    0xd5, 0x19, 0xc1, 0xc8, 0x10,                                                    \/\/ IID819\n+    0x62, 0xfc, 0x94, 0x14, 0xc1, 0xce, 0x10,                                        \/\/ IID820\n+    0x62, 0xfc, 0xfc, 0x1c, 0xc1, 0xcc, 0x10,                                        \/\/ IID821\n+    0x62, 0xdc, 0xa4, 0x14, 0xc1, 0xcb, 0x04,                                        \/\/ IID822\n+    0x62, 0xfc, 0x84, 0x10, 0xc1, 0xe3, 0x02,                                        \/\/ IID823\n+    0x62, 0xfc, 0xfc, 0x18, 0xc1, 0xe4, 0x02,                                        \/\/ IID824\n+    0x49, 0xc1, 0xe3, 0x08,                                                          \/\/ IID825\n+    0x62, 0xd4, 0xec, 0x1c, 0xd1, 0xe7,                                              \/\/ IID826\n+    0x62, 0xd4, 0xfc, 0x1c, 0xd1, 0xe2,                                              \/\/ IID827\n+    0x62, 0xdc, 0x94, 0x14, 0xc1, 0xe5, 0x04,                                        \/\/ IID828\n+    0x62, 0xfc, 0xdc, 0x10, 0xd1, 0xf8,                                              \/\/ IID829\n+    0x62, 0xfc, 0xfc, 0x18, 0xd1, 0xfd,                                              \/\/ IID830\n+    0xd5, 0x19, 0xc1, 0xfc, 0x08,                                                    \/\/ IID831\n+    0x62, 0xf4, 0x8c, 0x14, 0xc1, 0xf9, 0x04,                                        \/\/ IID832\n+    0x62, 0xd4, 0xfc, 0x1c, 0xc1, 0xff, 0x04,                                        \/\/ IID833\n+    0x62, 0xf4, 0xf4, 0x1c, 0xc1, 0xf9, 0x04,                                        \/\/ IID834\n+    0x62, 0xdc, 0xec, 0x18, 0xc1, 0xe2, 0x04,                                        \/\/ IID835\n+    0x62, 0xdc, 0xfc, 0x18, 0xc1, 0xe2, 0x04,                                        \/\/ IID836\n+    0x49, 0xc1, 0xe0, 0x04,                                                          \/\/ IID837\n+    0x62, 0xf4, 0xf4, 0x1c, 0xd1, 0xe1,                                              \/\/ IID838\n+    0x62, 0xf4, 0xfc, 0x1c, 0xd1, 0xe1,                                              \/\/ IID839\n+    0x62, 0xd4, 0x94, 0x1c, 0xc1, 0xe5, 0x02,                                        \/\/ IID840\n+    0x62, 0xdc, 0x8c, 0x18, 0xc1, 0xeb, 0x02,                                        \/\/ IID841\n+    0x62, 0xd4, 0xfc, 0x18, 0xc1, 0xeb, 0x02,                                        \/\/ IID842\n+    0x49, 0xc1, 0xe9, 0x10,                                                          \/\/ IID843\n+    0x62, 0xdc, 0xec, 0x1c, 0xc1, 0xef, 0x02,                                        \/\/ IID844\n+    0x62, 0xd4, 0xfc, 0x1c, 0xc1, 0xee, 0x02,                                        \/\/ IID845\n+    0x62, 0xd4, 0x9c, 0x1c, 0xc1, 0xec, 0x08,                                        \/\/ IID846\n+    0x62, 0xdc, 0xac, 0x18, 0x83, 0xec, 0x01,                                        \/\/ IID847\n+    0x62, 0xd4, 0xfc, 0x18, 0x83, 0xe8, 0x01,                                        \/\/ IID848\n+    0x48, 0x81, 0xe9, 0x00, 0x00, 0x00, 0x01,                                        \/\/ IID849\n+    0x62, 0xf4, 0xec, 0x1c, 0x81, 0xeb, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID850\n+    0x62, 0xfc, 0xfc, 0x1c, 0x81, 0xea, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID851\n+    0x62, 0xdc, 0xa4, 0x14, 0x81, 0xeb, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID852\n+    0x62, 0xf4, 0x8c, 0x10, 0x81, 0xf1, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID853\n+    0x62, 0xfc, 0xfc, 0x18, 0x81, 0xf5, 0x00, 0x10, 0x00, 0x00,                      \/\/ IID854\n+    0x48, 0x81, 0xf1, 0x00, 0x00, 0x00, 0x01,                                        \/\/ IID855\n+    0x62, 0xd4, 0xd4, 0x14, 0x83, 0xf4, 0x01,                                        \/\/ IID856\n+    0x62, 0xf4, 0xfc, 0x1c, 0x83, 0xf2, 0x01,                                        \/\/ IID857\n+    0x62, 0xf4, 0xe4, 0x1c, 0x81, 0xf3, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID858\n+    0x62, 0xf4, 0xa4, 0x18, 0x81, 0xca, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID859\n+    0x62, 0xd4, 0xfc, 0x18, 0x81, 0xce, 0x00, 0x00, 0x01, 0x00,                      \/\/ IID860\n+    0x49, 0x81, 0xce, 0x00, 0x00, 0x04, 0x00,                                        \/\/ IID861\n+    0x62, 0xdc, 0xb4, 0x10, 0x81, 0xcd, 0x00, 0x00, 0x04, 0x00,                      \/\/ IID862\n+    0x62, 0xfc, 0xfc, 0x18, 0x81, 0xcd, 0x00, 0x00, 0x04, 0x00,                      \/\/ IID863\n+    0x49, 0x81, 0xcb, 0x00, 0x00, 0x00, 0x01,                                        \/\/ IID864\n+    0x62, 0xfc, 0x94, 0x10, 0x81, 0xeb, 0x00, 0x00, 0x00, 0x04,                      \/\/ IID865\n+    0x62, 0xd4, 0xfc, 0x18, 0x81, 0xeb, 0x00, 0x00, 0x00, 0x04,                      \/\/ IID866\n+    0xd5, 0x18, 0x81, 0xea, 0x00, 0x00, 0x00, 0x04,                                  \/\/ IID867\n+    0x62, 0xfc, 0x9c, 0x14, 0x81, 0xef, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID868\n+    0x62, 0xfc, 0xfc, 0x1c, 0x81, 0xed, 0x00, 0x00, 0x40, 0x00,                      \/\/ IID869\n+    0x62, 0xfc, 0xfc, 0x14, 0x81, 0xe8, 0x00, 0x00, 0x00, 0x01,                      \/\/ IID870\n+    0x62, 0x0c, 0xbc, 0x18, 0x03, 0x8c, 0x42, 0xef, 0x3d, 0x63, 0x10,                \/\/ IID871\n+    0xd5, 0x3c, 0x03, 0xac, 0x42, 0xf8, 0xba, 0xdf, 0x8b,                            \/\/ IID872\n+    0x62, 0x44, 0xf4, 0x14, 0x03, 0x94, 0x24, 0xbf, 0x0a, 0xa8, 0x23,                \/\/ IID873\n+    0x62, 0x5c, 0xb0, 0x1c, 0x03, 0x8c, 0x1d, 0xae, 0x61, 0x61, 0xfd,                \/\/ IID874\n+    0x62, 0x24, 0xb0, 0x18, 0x23, 0xa4, 0x89, 0xaa, 0xff, 0x61, 0x42,                \/\/ IID875\n+    0xd5, 0x6e, 0x23, 0x9c, 0x22, 0x3f, 0x36, 0x42, 0xd9,                            \/\/ IID876\n+    0x62, 0x7c, 0x8c, 0x1c, 0x23, 0x98, 0xdf, 0x0d, 0xba, 0x63,                      \/\/ IID877\n+    0x62, 0x3c, 0xb8, 0x1c, 0x23, 0x84, 0x4e, 0xbc, 0x54, 0x49, 0xbc,                \/\/ IID878\n+    0x62, 0xdc, 0xe4, 0x10, 0x0b, 0x8c, 0x8b, 0x3a, 0x80, 0x97, 0x80,                \/\/ IID879\n+    0xd5, 0x6a, 0x0b, 0x9c, 0x53, 0x16, 0x48, 0x92, 0xb7,                            \/\/ IID880\n+    0x62, 0x54, 0x88, 0x14, 0x0b, 0x94, 0xd6, 0x84, 0x48, 0x88, 0x14,                \/\/ IID881\n+    0x62, 0x4c, 0xa4, 0x14, 0x0b, 0x9d, 0x80, 0x71, 0x33, 0x20,                      \/\/ IID882\n+    0x62, 0xec, 0xf4, 0x18, 0xaf, 0xac, 0x1d, 0x72, 0x77, 0xfc, 0xcc,                \/\/ IID883\n+    0xd5, 0x9b, 0xaf, 0x94, 0xcc, 0xbf, 0x08, 0x27, 0x85,                            \/\/ IID884\n+    0x62, 0x2c, 0xbc, 0x1c, 0xaf, 0xac, 0x21, 0x6a, 0x39, 0x85, 0x6e,                \/\/ IID885\n+    0x62, 0xac, 0xfc, 0x14, 0xaf, 0x84, 0xd3, 0x00, 0x6d, 0xa6, 0xb6,                \/\/ IID886\n+    0x62, 0xc4, 0xd8, 0x10, 0x2b, 0x8c, 0x35, 0x4f, 0x9a, 0x21, 0x1d,                \/\/ IID887\n+    0xd5, 0x7c, 0x2b, 0x8c, 0xed, 0x39, 0x57, 0x97, 0x97,                            \/\/ IID888\n+    0x62, 0x64, 0xd8, 0x14, 0x2b, 0x84, 0xa3, 0xa6, 0x9d, 0xc5, 0x32,                \/\/ IID889\n+    0x62, 0x54, 0xb8, 0x1c, 0x2b, 0x84, 0x0c, 0x31, 0xd2, 0x41, 0xd9,                \/\/ IID890\n+    0x62, 0xc4, 0xec, 0x18, 0x33, 0x99, 0x91, 0x3b, 0x90, 0x7d,                      \/\/ IID891\n+    0xd5, 0x7f, 0x33, 0xa4, 0x9d, 0x6f, 0x1f, 0x09, 0x53,                            \/\/ IID892\n+    0x62, 0xcc, 0xf4, 0x14, 0x33, 0x83, 0x07, 0x92, 0x6e, 0x7c,                      \/\/ IID893\n+    0x62, 0x14, 0x80, 0x1c, 0x33, 0xbc, 0xc5, 0xa0, 0x86, 0x37, 0x8a,                \/\/ IID894\n+    0x62, 0xfc, 0xfc, 0x10, 0x03, 0xda,                                              \/\/ IID895\n+    0xd5, 0x5c, 0x03, 0xc2,                                                          \/\/ IID896\n+    0x4d, 0x03, 0xcf,                                                                \/\/ IID897\n+    0x62, 0x44, 0xe4, 0x14, 0x03, 0xd5,                                              \/\/ IID898\n+    0x62, 0x6c, 0x9c, 0x14, 0x03, 0xe6,                                              \/\/ IID899\n+    0x62, 0x7c, 0xcc, 0x14, 0x03, 0xde,                                              \/\/ IID900\n+    0x62, 0x54, 0xf5, 0x18, 0x66, 0xe5,                                              \/\/ IID901\n+    0x62, 0x44, 0xfd, 0x08, 0x66, 0xf4,                                              \/\/ IID902\n+    0x62, 0x7c, 0x9e, 0x10, 0x66, 0xf2,                                              \/\/ IID903\n+    0x62, 0x6c, 0xfe, 0x08, 0x66, 0xf3,                                              \/\/ IID904\n+    0x62, 0x54, 0xdc, 0x10, 0x23, 0xf6,                                              \/\/ IID905\n+    0xd5, 0x58, 0x23, 0xcf,                                                          \/\/ IID906\n+    0xd5, 0x49, 0x23, 0xce,                                                          \/\/ IID907\n+    0x62, 0xc4, 0xe4, 0x14, 0x23, 0xe7,                                              \/\/ IID908\n+    0x62, 0xd4, 0xe4, 0x1c, 0x23, 0xdd,                                              \/\/ IID909\n+    0x62, 0x6c, 0xcc, 0x14, 0x23, 0xf6,                                              \/\/ IID910\n+    0x62, 0x64, 0xf4, 0x10, 0xaf, 0xc1,                                              \/\/ IID911\n+    0xd5, 0xc9, 0xaf, 0xe8,                                                          \/\/ IID912\n+    0xd5, 0xdc, 0xaf, 0xed,                                                          \/\/ IID913\n+    0x62, 0x7c, 0xa4, 0x14, 0xaf, 0xef,                                              \/\/ IID914\n+    0x62, 0x44, 0xac, 0x14, 0xaf, 0xd0,                                              \/\/ IID915\n+    0x62, 0x7c, 0xcc, 0x14, 0xaf, 0xee,                                              \/\/ IID916\n+    0x62, 0xdc, 0xa4, 0x18, 0x0b, 0xd5,                                              \/\/ IID917\n+    0xd5, 0x19, 0x0b, 0xd7,                                                          \/\/ IID918\n+    0xd5, 0x1d, 0x0b, 0xd5,                                                          \/\/ IID919\n+    0x62, 0x64, 0xa4, 0x14, 0x0b, 0xe1,                                              \/\/ IID920\n+    0x62, 0x44, 0xb4, 0x14, 0x0b, 0xc9,                                              \/\/ IID921\n+    0x62, 0x74, 0xf4, 0x1c, 0x0b, 0xc1,                                              \/\/ IID922\n+    0x62, 0x7c, 0xf4, 0x18, 0x2b, 0xd0,                                              \/\/ IID923\n+    0xd5, 0x48, 0x2b, 0xc9,                                                          \/\/ IID924\n+    0x62, 0xcc, 0x94, 0x1c, 0x2b, 0xe8,                                              \/\/ IID925\n+    0x62, 0x4c, 0x84, 0x14, 0x2b, 0xfc,                                              \/\/ IID926\n+    0xd5, 0x59, 0x33, 0xfc,                                                          \/\/ IID927\n+    0x4d, 0x33, 0xd3,                                                                \/\/ IID928\n+    0xd5, 0x58, 0x33, 0xda,                                                          \/\/ IID929\n+    0x62, 0x74, 0x84, 0x14, 0x33, 0xca,                                              \/\/ IID930\n+    0x62, 0x54, 0x94, 0x1c, 0x33, 0xe9,                                              \/\/ IID931\n+    0x62, 0x74, 0xf4, 0x1c, 0x33, 0xd1,                                              \/\/ IID932\n+    0x62, 0xcc, 0x9c, 0x18, 0x24, 0xf0, 0x08,                                        \/\/ IID933\n+    0xd5, 0xdd, 0xa4, 0xc9, 0x08,                                                    \/\/ IID934\n+    0x62, 0x7c, 0xd4, 0x14, 0x24, 0xfc, 0x08,                                        \/\/ IID935\n+    0x62, 0x7c, 0xd4, 0x14, 0x24, 0xd5, 0x08,                                        \/\/ IID936\n+    0xd5, 0x9c, 0xac, 0xc2, 0x02,                                                    \/\/ IID937\n+    0xd5, 0xdd, 0xac, 0xea, 0x08,                                                    \/\/ IID938\n+    0x62, 0xcc, 0x94, 0x14, 0x2c, 0xda, 0x02,                                        \/\/ IID939\n+    0x62, 0xd4, 0x9c, 0x1c, 0x2c, 0xcc, 0x04,                                        \/\/ IID940\n+    0x62, 0xec, 0xd4, 0x10, 0x40, 0xf7,                                              \/\/ IID941\n+    0x4d, 0x0f, 0x40, 0xcd,                                                          \/\/ IID942\n+    0x62, 0xcc, 0xf4, 0x18, 0x41, 0xf8,                                              \/\/ IID943\n+    0xd5, 0xcc, 0x41, 0xe2,                                                          \/\/ IID944\n+    0x62, 0x6c, 0x8c, 0x18, 0x42, 0xff,                                              \/\/ IID945\n+    0xd5, 0xdc, 0x42, 0xf7,                                                          \/\/ IID946\n+    0x62, 0x6c, 0xac, 0x18, 0x43, 0xee,                                              \/\/ IID947\n+    0xd5, 0x99, 0x43, 0xda,                                                          \/\/ IID948\n+    0x62, 0xc4, 0xc4, 0x10, 0x44, 0xed,                                              \/\/ IID949\n+    0xd5, 0x9c, 0x44, 0xd4,                                                          \/\/ IID950\n+    0x62, 0x5c, 0xe4, 0x18, 0x45, 0xcd,                                              \/\/ IID951\n+    0xd5, 0xd9, 0x45, 0xc6,                                                          \/\/ IID952\n+    0x62, 0xdc, 0x94, 0x18, 0x46, 0xcd,                                              \/\/ IID953\n+    0xd5, 0xcd, 0x46, 0xfd,                                                          \/\/ IID954\n+    0x62, 0x5c, 0xa4, 0x10, 0x47, 0xce,                                              \/\/ IID955\n+    0xd5, 0xdc, 0x47, 0xd4,                                                          \/\/ IID956\n+    0x62, 0x7c, 0xbc, 0x18, 0x48, 0xe6,                                              \/\/ IID957\n+    0xd5, 0xdc, 0x48, 0xf9,                                                          \/\/ IID958\n+    0x62, 0xdc, 0x94, 0x10, 0x49, 0xc9,                                              \/\/ IID959\n+    0xd5, 0xc9, 0x49, 0xf6,                                                          \/\/ IID960\n+    0x62, 0x44, 0xf4, 0x18, 0x4a, 0xd9,                                              \/\/ IID961\n+    0xd5, 0xc9, 0x4a, 0xf3,                                                          \/\/ IID962\n+    0x62, 0xcc, 0x8c, 0x18, 0x4b, 0xd8,                                              \/\/ IID963\n+    0xd5, 0xdc, 0x4b, 0xc1,                                                          \/\/ IID964\n+    0x62, 0xcc, 0xf4, 0x10, 0x4c, 0xde,                                              \/\/ IID965\n+    0xd5, 0xc9, 0x4c, 0xde,                                                          \/\/ IID966\n+    0x62, 0x5c, 0xb4, 0x10, 0x4d, 0xdd,                                              \/\/ IID967\n+    0xd5, 0x9d, 0x4d, 0xe2,                                                          \/\/ IID968\n+    0x62, 0xd4, 0xa4, 0x18, 0x4e, 0xda,                                              \/\/ IID969\n+    0xd5, 0x98, 0x4e, 0xd6,                                                          \/\/ IID970\n+    0x62, 0x7c, 0x8c, 0x18, 0x4f, 0xff,                                              \/\/ IID971\n+    0xd5, 0x9d, 0x4f, 0xc0,                                                          \/\/ IID972\n+    0x62, 0x04, 0xe4, 0x18, 0x40, 0xbc, 0xc2, 0x20, 0x9f, 0xc0, 0xce,                \/\/ IID973\n+    0xd5, 0xea, 0x40, 0xbc, 0x81, 0x9c, 0x1d, 0xf4, 0x17,                            \/\/ IID974\n+    0x62, 0x7c, 0x84, 0x10, 0x41, 0x98, 0x42, 0x89, 0x01, 0x2c,                      \/\/ IID975\n+    0xd5, 0xbc, 0x41, 0x9c, 0xe0, 0x55, 0x6a, 0x4b, 0x67,                            \/\/ IID976\n+    0x62, 0x54, 0xb4, 0x18, 0x42, 0xac, 0x09, 0xdf, 0x11, 0x4a, 0x39,                \/\/ IID977\n+    0xd5, 0xec, 0x42, 0xb4, 0x72, 0x78, 0xd4, 0xc9, 0x93,                            \/\/ IID978\n+    0x62, 0xdc, 0x94, 0x18, 0x43, 0x8c, 0xc8, 0x66, 0x0b, 0x50, 0x46,                \/\/ IID979\n+    0xd5, 0xfe, 0x43, 0x84, 0x4a, 0x7c, 0x3b, 0x28, 0x53,                            \/\/ IID980\n+    0x62, 0x04, 0xc4, 0x10, 0x44, 0x8c, 0x0f, 0xe2, 0xfc, 0xfc, 0xa0,                \/\/ IID981\n+    0xd5, 0xfd, 0x44, 0x8c, 0x44, 0xec, 0x0a, 0x31, 0xac,                            \/\/ IID982\n+    0x62, 0x0c, 0xe0, 0x18, 0x45, 0x8c, 0x88, 0x79, 0x53, 0x35, 0x99,                \/\/ IID983\n+    0xd5, 0xfb, 0x45, 0x84, 0xf3, 0x5d, 0x45, 0x7f, 0x79,                            \/\/ IID984\n+    0x62, 0x6c, 0xb0, 0x10, 0x46, 0xb4, 0x52, 0xcd, 0xaa, 0x9d, 0x1c,                \/\/ IID985\n+    0xd5, 0xea, 0x46, 0xb4, 0x49, 0x57, 0x05, 0x34, 0xc2,                            \/\/ IID986\n+    0x62, 0x4c, 0xbc, 0x10, 0x47, 0x91, 0xb5, 0x60, 0x70, 0x74,                      \/\/ IID987\n+    0xd5, 0xbd, 0x47, 0x84, 0xe0, 0xf6, 0x85, 0xd2, 0x47,                            \/\/ IID988\n+    0x62, 0x84, 0x9c, 0x18, 0x48, 0x84, 0x95, 0x14, 0xb2, 0xe5, 0x34,                \/\/ IID989\n+    0xd5, 0xa9, 0x48, 0x94, 0x1f, 0x4f, 0xc7, 0xae, 0xbf,                            \/\/ IID990\n+    0x62, 0xa4, 0xec, 0x10, 0x49, 0xac, 0xab, 0x97, 0x91, 0xb1, 0x51,                \/\/ IID991\n+    0xd5, 0xef, 0x49, 0x84, 0xfb, 0x0a, 0x52, 0x01, 0x3e,                            \/\/ IID992\n+    0x62, 0x04, 0x90, 0x10, 0x4a, 0x94, 0xca, 0x8e, 0xc7, 0x83, 0xa0,                \/\/ IID993\n+    0xd5, 0x9e, 0x4a, 0x9c, 0xd6, 0xad, 0xeb, 0x8c, 0x97,                            \/\/ IID994\n+    0x62, 0x14, 0xd8, 0x10, 0x4b, 0xbc, 0x09, 0xaa, 0xed, 0x37, 0x4a,                \/\/ IID995\n+    0xd5, 0xed, 0x4b, 0xbc, 0x21, 0x86, 0x9f, 0x99, 0x4f,                            \/\/ IID996\n+    0x62, 0x84, 0xe8, 0x10, 0x4c, 0xbc, 0x19, 0xe3, 0xbb, 0xef, 0xcb,                \/\/ IID997\n+    0xd5, 0xdb, 0x4c, 0x84, 0xd0, 0xee, 0x66, 0xed, 0x52,                            \/\/ IID998\n+    0x62, 0xe4, 0xa4, 0x18, 0x4d, 0x91, 0x63, 0x91, 0xe0, 0x1d,                      \/\/ IID999\n+    0xd5, 0xbd, 0x4d, 0xb4, 0x78, 0xda, 0xb4, 0xf3, 0x5d,                            \/\/ IID1000\n+    0x62, 0x5c, 0x80, 0x18, 0x4e, 0xb4, 0x66, 0x76, 0xb9, 0x9a, 0x5c,                \/\/ IID1001\n+    0xd5, 0xfe, 0x4e, 0x94, 0x9a, 0xd7, 0x3c, 0x27, 0xff,                            \/\/ IID1002\n+    0x62, 0x5c, 0x90, 0x10, 0x4f, 0x8c, 0xe6, 0x73, 0x30, 0x56, 0xc8,                \/\/ IID1003\n+    0xd5, 0xc9, 0x4f, 0xa4, 0x58, 0xef, 0x7d, 0xdc, 0x1b,                            \/\/ IID1004\n@@ -2199,1 +2367,1 @@\n-    11,   \/\/ IID268\n+    9,    \/\/ IID268\n@@ -2203,1 +2371,1 @@\n-    11,   \/\/ IID272\n+    9,    \/\/ IID272\n@@ -2207,1 +2375,1 @@\n-    11,   \/\/ IID276\n+    9,    \/\/ IID276\n@@ -2211,1 +2379,1 @@\n-    11,   \/\/ IID280\n+    9,    \/\/ IID280\n@@ -2219,1 +2387,1 @@\n-    10,   \/\/ IID288\n+    8,    \/\/ IID288\n@@ -2222,4 +2390,4 @@\n-    10,   \/\/ IID291\n-    10,   \/\/ IID292\n-    8,    \/\/ IID293\n-    7,    \/\/ IID294\n+    11,   \/\/ IID291\n+    9,    \/\/ IID292\n+    11,   \/\/ IID293\n+    11,   \/\/ IID294\n@@ -2227,2 +2395,2 @@\n-    10,   \/\/ IID296\n-    10,   \/\/ IID297\n+    7,    \/\/ IID296\n+    8,    \/\/ IID297\n@@ -2230,1 +2398,1 @@\n-    8,    \/\/ IID299\n+    10,   \/\/ IID299\n@@ -2232,1 +2400,1 @@\n-    10,   \/\/ IID301\n+    4,    \/\/ IID301\n@@ -2234,6 +2402,4 @@\n-    10,   \/\/ IID303\n-#endif \/\/ _LP64\n-    10,   \/\/ IID304\n-#ifdef _LP64\n-    10,   \/\/ IID305\n-    10,   \/\/ IID306\n+    5,    \/\/ IID303\n+    7,    \/\/ IID304\n+    7,    \/\/ IID305\n+    7,    \/\/ IID306\n@@ -2241,1 +2407,1 @@\n-    7,    \/\/ IID308\n+    10,   \/\/ IID308\n@@ -2243,3 +2409,3 @@\n-    10,   \/\/ IID310\n-    8,    \/\/ IID311\n-    7,    \/\/ IID312\n+    7,    \/\/ IID310\n+    7,    \/\/ IID311\n+    10,   \/\/ IID312\n@@ -2247,5 +2413,4 @@\n-    10,   \/\/ IID314\n-    6,    \/\/ IID315\n-    6,    \/\/ IID316\n-    4,    \/\/ IID317\n-    7,    \/\/ IID318\n+    7,    \/\/ IID314\n+    8,    \/\/ IID315\n+    7,    \/\/ IID316\n+    7,    \/\/ IID317\n@@ -2253,1 +2418,1 @@\n-    7,    \/\/ IID319\n+    10,   \/\/ IID318\n@@ -2255,2 +2420,3 @@\n-    5,    \/\/ IID320\n-    7,    \/\/ IID321\n+    5,    \/\/ IID319\n+    7,    \/\/ IID320\n+    5,    \/\/ IID321\n@@ -2259,2 +2425,1 @@\n-    7,    \/\/ IID324\n-#endif \/\/ _LP64\n+    4,    \/\/ IID324\n@@ -2262,3 +2427,2 @@\n-#ifdef _LP64\n-    4,    \/\/ IID326\n-    7,    \/\/ IID327\n+    7,    \/\/ IID326\n+    6,    \/\/ IID327\n@@ -2267,1 +2431,1 @@\n-    7,    \/\/ IID330\n+    5,    \/\/ IID330\n@@ -2269,1 +2433,1 @@\n-    5,    \/\/ IID332\n+    7,    \/\/ IID332\n@@ -2273,1 +2437,1 @@\n-    7,    \/\/ IID336\n+    5,    \/\/ IID336\n@@ -2275,1 +2439,1 @@\n-    4,    \/\/ IID338\n+    7,    \/\/ IID338\n@@ -2277,3 +2441,3 @@\n-    7,    \/\/ IID340\n-    7,    \/\/ IID341\n-    7,    \/\/ IID342\n+    6,    \/\/ IID340\n+    6,    \/\/ IID341\n+    5,    \/\/ IID342\n@@ -2281,1 +2445,1 @@\n-    4,    \/\/ IID344\n+    7,    \/\/ IID344\n@@ -2285,1 +2449,1 @@\n-    7,    \/\/ IID348\n+    4,    \/\/ IID348\n@@ -2287,1 +2451,1 @@\n-    5,    \/\/ IID350\n+    7,    \/\/ IID350\n@@ -2289,1 +2453,1 @@\n-    6,    \/\/ IID352\n+    7,    \/\/ IID352\n@@ -2291,4 +2455,4 @@\n-    10,   \/\/ IID354\n-    10,   \/\/ IID355\n-    8,    \/\/ IID356\n-    10,   \/\/ IID357\n+    5,    \/\/ IID354\n+    7,    \/\/ IID355\n+    7,    \/\/ IID356\n+    7,    \/\/ IID357\n@@ -2297,1 +2461,1 @@\n-    10,   \/\/ IID360\n+    8,    \/\/ IID360\n@@ -2299,4 +2463,2 @@\n-#endif \/\/ _LP64\n-    6,    \/\/ IID362\n-#ifdef _LP64\n-    10,   \/\/ IID363\n+    10,   \/\/ IID362\n+    7,    \/\/ IID363\n@@ -2305,4 +2467,6 @@\n-    10,   \/\/ IID366\n-    10,   \/\/ IID367\n-    8,    \/\/ IID368\n-    10,   \/\/ IID369\n+    5,    \/\/ IID366\n+    7,    \/\/ IID367\n+#endif \/\/ _LP64\n+    7,    \/\/ IID368\n+#ifdef _LP64\n+    7,    \/\/ IID369\n@@ -2311,1 +2475,1 @@\n-    10,   \/\/ IID372\n+    8,    \/\/ IID372\n@@ -2313,2 +2477,2 @@\n-    11,   \/\/ IID374\n-    11,   \/\/ IID375\n+    10,   \/\/ IID374\n+    10,   \/\/ IID375\n@@ -2316,1 +2480,1 @@\n-    11,   \/\/ IID377\n+    9,    \/\/ IID377\n@@ -2320,1 +2484,1 @@\n-    11,   \/\/ IID381\n+    9,    \/\/ IID381\n@@ -2324,1 +2488,1 @@\n-    11,   \/\/ IID385\n+    9,    \/\/ IID385\n@@ -2327,20 +2491,20 @@\n-    6,    \/\/ IID388\n-    4,    \/\/ IID389\n-    6,    \/\/ IID390\n-    6,    \/\/ IID391\n-    6,    \/\/ IID392\n-    3,    \/\/ IID393\n-    6,    \/\/ IID394\n-    6,    \/\/ IID395\n-    6,    \/\/ IID396\n-    4,    \/\/ IID397\n-    6,    \/\/ IID398\n-    6,    \/\/ IID399\n-    6,    \/\/ IID400\n-    5,    \/\/ IID401\n-    6,    \/\/ IID402\n-    6,    \/\/ IID403\n-    6,    \/\/ IID404\n-    4,    \/\/ IID405\n-    6,    \/\/ IID406\n-    6,    \/\/ IID407\n+    10,   \/\/ IID388\n+    8,    \/\/ IID389\n+    11,   \/\/ IID390\n+    11,   \/\/ IID391\n+    11,   \/\/ IID392\n+    9,    \/\/ IID393\n+    10,   \/\/ IID394\n+    11,   \/\/ IID395\n+    11,   \/\/ IID396\n+    9,    \/\/ IID397\n+    11,   \/\/ IID398\n+    11,   \/\/ IID399\n+    11,   \/\/ IID400\n+    9,    \/\/ IID401\n+    11,   \/\/ IID402\n+    11,   \/\/ IID403\n+    11,   \/\/ IID404\n+    10,   \/\/ IID405\n+    10,   \/\/ IID406\n+    11,   \/\/ IID407\n@@ -2349,1 +2513,1 @@\n-    6,    \/\/ IID410\n+    4,    \/\/ IID410\n@@ -2352,1 +2516,1 @@\n-    4,    \/\/ IID413\n+    6,    \/\/ IID413\n@@ -2354,3 +2518,3 @@\n-    6,    \/\/ IID415\n-    6,    \/\/ IID416\n-    4,    \/\/ IID417\n+    4,    \/\/ IID415\n+    3,    \/\/ IID416\n+    6,    \/\/ IID417\n@@ -2361,1 +2525,1 @@\n-    6,    \/\/ IID422\n+    4,    \/\/ IID422\n@@ -2363,8 +2527,10 @@\n-    7,    \/\/ IID424\n-    5,    \/\/ IID425\n-    7,    \/\/ IID426\n-    7,    \/\/ IID427\n-    7,    \/\/ IID428\n-    5,    \/\/ IID429\n-    7,    \/\/ IID430\n-    7,    \/\/ IID431\n+    6,    \/\/ IID424\n+    6,    \/\/ IID425\n+    6,    \/\/ IID426\n+    5,    \/\/ IID427\n+    4,    \/\/ IID428\n+    6,    \/\/ IID429\n+    6,    \/\/ IID430\n+#endif \/\/ _LP64\n+    6,    \/\/ IID431\n+#ifdef _LP64\n@@ -2373,2 +2539,2 @@\n-    6,    \/\/ IID434\n-    4,    \/\/ IID435\n+    4,    \/\/ IID434\n+    6,    \/\/ IID435\n@@ -2376,1 +2542,1 @@\n-    4,    \/\/ IID437\n+    6,    \/\/ IID437\n@@ -2380,1 +2546,1 @@\n-    4,    \/\/ IID441\n+    6,    \/\/ IID441\n@@ -2384,1 +2550,1 @@\n-    4,    \/\/ IID445\n+    6,    \/\/ IID445\n@@ -2386,1 +2552,1 @@\n-    4,    \/\/ IID447\n+    3,    \/\/ IID447\n@@ -2388,1 +2554,1 @@\n-    4,    \/\/ IID449\n+    6,    \/\/ IID449\n@@ -2392,1 +2558,1 @@\n-    4,    \/\/ IID453\n+    6,    \/\/ IID453\n@@ -2394,26 +2560,26 @@\n-    4,    \/\/ IID455\n-    6,    \/\/ IID456\n-    4,    \/\/ IID457\n-    6,    \/\/ IID458\n-    4,    \/\/ IID459\n-    6,    \/\/ IID460\n-    4,    \/\/ IID461\n-    6,    \/\/ IID462\n-    4,    \/\/ IID463\n-    10,   \/\/ IID464\n-    11,   \/\/ IID465\n-    11,   \/\/ IID466\n-    11,   \/\/ IID467\n-    10,   \/\/ IID468\n-    11,   \/\/ IID469\n-    11,   \/\/ IID470\n-    11,   \/\/ IID471\n-    11,   \/\/ IID472\n-    11,   \/\/ IID473\n-    11,   \/\/ IID474\n-    11,   \/\/ IID475\n-    11,   \/\/ IID476\n-    11,   \/\/ IID477\n-    11,   \/\/ IID478\n-    11,   \/\/ IID479\n-    4,    \/\/ IID480\n+    6,    \/\/ IID455\n+    7,    \/\/ IID456\n+    5,    \/\/ IID457\n+    7,    \/\/ IID458\n+    7,    \/\/ IID459\n+    7,    \/\/ IID460\n+    5,    \/\/ IID461\n+    7,    \/\/ IID462\n+    7,    \/\/ IID463\n+    6,    \/\/ IID464\n+    4,    \/\/ IID465\n+    6,    \/\/ IID466\n+    4,    \/\/ IID467\n+    6,    \/\/ IID468\n+    4,    \/\/ IID469\n+    6,    \/\/ IID470\n+    4,    \/\/ IID471\n+    6,    \/\/ IID472\n+    4,    \/\/ IID473\n+    6,    \/\/ IID474\n+    4,    \/\/ IID475\n+    6,    \/\/ IID476\n+    4,    \/\/ IID477\n+    6,    \/\/ IID478\n+    4,    \/\/ IID479\n+    6,    \/\/ IID480\n@@ -2421,3 +2587,3 @@\n-    4,    \/\/ IID482\n-    5,    \/\/ IID483\n-    4,    \/\/ IID484\n+    6,    \/\/ IID482\n+    4,    \/\/ IID483\n+    6,    \/\/ IID484\n@@ -2425,3 +2591,3 @@\n-    5,    \/\/ IID486\n-    5,    \/\/ IID487\n-    4,    \/\/ IID488\n+    6,    \/\/ IID486\n+    4,    \/\/ IID487\n+    6,    \/\/ IID488\n@@ -2429,3 +2595,3 @@\n-    4,    \/\/ IID490\n-    3,    \/\/ IID491\n-    4,    \/\/ IID492\n+    6,    \/\/ IID490\n+    4,    \/\/ IID491\n+    6,    \/\/ IID492\n@@ -2433,1 +2599,1 @@\n-    4,    \/\/ IID494\n+    6,    \/\/ IID494\n@@ -2435,3 +2601,3 @@\n-    4,    \/\/ IID496\n-    4,    \/\/ IID497\n-    9,    \/\/ IID498\n+    11,   \/\/ IID496\n+    9,    \/\/ IID497\n+    11,   \/\/ IID498\n@@ -2439,1 +2605,1 @@\n-    9,    \/\/ IID500\n+    11,   \/\/ IID500\n@@ -2441,3 +2607,3 @@\n-    9,    \/\/ IID502\n-    9,    \/\/ IID503\n-    9,    \/\/ IID504\n+    11,   \/\/ IID502\n+    8,    \/\/ IID503\n+    11,   \/\/ IID504\n@@ -2445,2 +2611,2 @@\n-    12,   \/\/ IID506\n-    12,   \/\/ IID507\n+    11,   \/\/ IID506\n+    8,    \/\/ IID507\n@@ -2448,10 +2614,10 @@\n-    8,    \/\/ IID509\n-    9,    \/\/ IID510\n-    13,   \/\/ IID511\n-    10,   \/\/ IID512\n-    12,   \/\/ IID513\n-    10,   \/\/ IID514\n-    10,   \/\/ IID515\n-    13,   \/\/ IID516\n-    12,   \/\/ IID517\n-    9,    \/\/ IID518\n+    9,    \/\/ IID509\n+    10,   \/\/ IID510\n+    9,    \/\/ IID511\n+    11,   \/\/ IID512\n+    9,    \/\/ IID513\n+    9,    \/\/ IID514\n+    9,    \/\/ IID515\n+    11,   \/\/ IID516\n+    9,    \/\/ IID517\n+    11,   \/\/ IID518\n@@ -2459,1 +2625,1 @@\n-    9,    \/\/ IID520\n+    11,   \/\/ IID520\n@@ -2461,3 +2627,3 @@\n-    9,    \/\/ IID522\n-    7,    \/\/ IID523\n-    9,    \/\/ IID524\n+    10,   \/\/ IID522\n+    9,    \/\/ IID523\n+    10,   \/\/ IID524\n@@ -2465,1 +2631,1 @@\n-    9,    \/\/ IID526\n+    11,   \/\/ IID526\n@@ -2467,7 +2633,7 @@\n-    10,   \/\/ IID528\n-    9,    \/\/ IID529\n-    9,    \/\/ IID530\n-    7,    \/\/ IID531\n-    10,   \/\/ IID532\n-    9,    \/\/ IID533\n-    9,    \/\/ IID534\n+    4,    \/\/ IID528\n+    3,    \/\/ IID529\n+    4,    \/\/ IID530\n+    5,    \/\/ IID531\n+    3,    \/\/ IID532\n+    4,    \/\/ IID533\n+    5,    \/\/ IID534\n@@ -2475,3 +2641,3 @@\n-    5,    \/\/ IID536\n-    8,    \/\/ IID537\n-    8,    \/\/ IID538\n+    4,    \/\/ IID536\n+    3,    \/\/ IID537\n+    4,    \/\/ IID538\n@@ -2480,2 +2646,2 @@\n-    5,    \/\/ IID541\n-    5,    \/\/ IID542\n+    4,    \/\/ IID541\n+    4,    \/\/ IID542\n@@ -2484,4 +2650,4 @@\n-    7,    \/\/ IID545\n-    4,    \/\/ IID546\n-    3,    \/\/ IID547\n-    4,    \/\/ IID548\n+    4,    \/\/ IID545\n+    8,    \/\/ IID546\n+    9,    \/\/ IID547\n+    9,    \/\/ IID548\n@@ -2490,15 +2656,15 @@\n-    10,   \/\/ IID551\n-    5,    \/\/ IID552\n-    8,    \/\/ IID553\n-    8,    \/\/ IID554\n-    7,    \/\/ IID555\n-    9,    \/\/ IID556\n-    8,    \/\/ IID557\n-    9,    \/\/ IID558\n-    9,    \/\/ IID559\n-    9,    \/\/ IID560\n-    9,    \/\/ IID561\n-    8,    \/\/ IID562\n-    9,    \/\/ IID563\n-    9,    \/\/ IID564\n-    9,    \/\/ IID565\n+    9,    \/\/ IID551\n+    9,    \/\/ IID552\n+    9,    \/\/ IID553\n+    13,   \/\/ IID554\n+    13,   \/\/ IID555\n+    11,   \/\/ IID556\n+    10,   \/\/ IID557\n+    10,   \/\/ IID558\n+    13,   \/\/ IID559\n+    10,   \/\/ IID560\n+    13,   \/\/ IID561\n+    10,   \/\/ IID562\n+    13,   \/\/ IID563\n+    11,   \/\/ IID564\n+    13,   \/\/ IID565\n@@ -2511,16 +2677,16 @@\n-    4,    \/\/ IID572\n-    4,    \/\/ IID573\n-    4,    \/\/ IID574\n-    3,    \/\/ IID575\n-    3,    \/\/ IID576\n-    4,    \/\/ IID577\n-    4,    \/\/ IID578\n-    3,    \/\/ IID579\n-    4,    \/\/ IID580\n-    3,    \/\/ IID581\n-    4,    \/\/ IID582\n-    4,    \/\/ IID583\n-    4,    \/\/ IID584\n-    3,    \/\/ IID585\n-    3,    \/\/ IID586\n-    3,    \/\/ IID587\n+    9,    \/\/ IID572\n+    9,    \/\/ IID573\n+    8,    \/\/ IID574\n+    9,    \/\/ IID575\n+    10,   \/\/ IID576\n+    9,    \/\/ IID577\n+    9,    \/\/ IID578\n+    9,    \/\/ IID579\n+    10,   \/\/ IID580\n+    9,    \/\/ IID581\n+    9,    \/\/ IID582\n+    8,    \/\/ IID583\n+    5,    \/\/ IID584\n+    8,    \/\/ IID585\n+    7,    \/\/ IID586\n+    4,    \/\/ IID587\n@@ -2528,9 +2694,9 @@\n-    9,    \/\/ IID589\n-    9,    \/\/ IID590\n-    9,    \/\/ IID591\n-    9,    \/\/ IID592\n-    9,    \/\/ IID593\n-    9,    \/\/ IID594\n-    9,    \/\/ IID595\n-    9,    \/\/ IID596\n-    13,   \/\/ IID597\n+    5,    \/\/ IID589\n+    4,    \/\/ IID590\n+    4,    \/\/ IID591\n+    5,    \/\/ IID592\n+    7,    \/\/ IID593\n+    5,    \/\/ IID594\n+    5,    \/\/ IID595\n+    7,    \/\/ IID596\n+    7,    \/\/ IID597\n@@ -2538,1 +2704,1 @@\n-    5,    \/\/ IID599\n+    11,   \/\/ IID599\n@@ -2540,4 +2706,4 @@\n-    6,    \/\/ IID601\n-    6,    \/\/ IID602\n-    6,    \/\/ IID603\n-    6,    \/\/ IID604\n+    8,    \/\/ IID601\n+    8,    \/\/ IID602\n+    8,    \/\/ IID603\n+    9,    \/\/ IID604\n@@ -2548,4 +2714,4 @@\n-    4,    \/\/ IID609\n-    4,    \/\/ IID610\n-    4,    \/\/ IID611\n-    4,    \/\/ IID612\n+    8,    \/\/ IID609\n+    9,    \/\/ IID610\n+    9,    \/\/ IID611\n+    9,    \/\/ IID612\n@@ -2553,19 +2719,19 @@\n-    6,    \/\/ IID614\n-    6,    \/\/ IID615\n-    6,    \/\/ IID616\n-    6,    \/\/ IID617\n-    6,    \/\/ IID618\n-    6,    \/\/ IID619\n-    6,    \/\/ IID620\n-    6,    \/\/ IID621\n-    11,   \/\/ IID622\n-    11,   \/\/ IID623\n-    6,    \/\/ IID624\n-    4,    \/\/ IID625\n-    6,    \/\/ IID626\n-    6,    \/\/ IID627\n-    6,    \/\/ IID628\n-    6,    \/\/ IID629\n-    6,    \/\/ IID630\n-    6,    \/\/ IID631\n-    6,    \/\/ IID632\n+    9,    \/\/ IID614\n+    9,    \/\/ IID615\n+    9,    \/\/ IID616\n+    8,    \/\/ IID617\n+    9,    \/\/ IID618\n+    9,    \/\/ IID619\n+    4,    \/\/ IID620\n+    3,    \/\/ IID621\n+    4,    \/\/ IID622\n+    3,    \/\/ IID623\n+    4,    \/\/ IID624\n+    3,    \/\/ IID625\n+    3,    \/\/ IID626\n+    4,    \/\/ IID627\n+    4,    \/\/ IID628\n+    3,    \/\/ IID629\n+    4,    \/\/ IID630\n+    4,    \/\/ IID631\n+    4,    \/\/ IID632\n@@ -2573,15 +2739,15 @@\n-    6,    \/\/ IID634\n-    6,    \/\/ IID635\n-    6,    \/\/ IID636\n-    4,    \/\/ IID637\n-    6,    \/\/ IID638\n-    6,    \/\/ IID639\n-    6,    \/\/ IID640\n-    6,    \/\/ IID641\n-    6,    \/\/ IID642\n-    4,    \/\/ IID643\n-    6,    \/\/ IID644\n-    6,    \/\/ IID645\n-    6,    \/\/ IID646\n-    4,    \/\/ IID647\n-    6,    \/\/ IID648\n+    3,    \/\/ IID634\n+    3,    \/\/ IID635\n+    3,    \/\/ IID636\n+    9,    \/\/ IID637\n+    8,    \/\/ IID638\n+    9,    \/\/ IID639\n+    8,    \/\/ IID640\n+    9,    \/\/ IID641\n+    8,    \/\/ IID642\n+    7,    \/\/ IID643\n+    9,    \/\/ IID644\n+    13,   \/\/ IID645\n+    8,    \/\/ IID646\n+    5,    \/\/ IID647\n+    5,    \/\/ IID648\n@@ -2590,1 +2756,1 @@\n-    3,    \/\/ IID651\n+    6,    \/\/ IID651\n@@ -2592,11 +2758,11 @@\n-    6,    \/\/ IID653\n-    6,    \/\/ IID654\n-    3,    \/\/ IID655\n-    6,    \/\/ IID656\n-    6,    \/\/ IID657\n-    6,    \/\/ IID658\n-    3,    \/\/ IID659\n-    6,    \/\/ IID660\n-    6,    \/\/ IID661\n-    4,    \/\/ IID662\n-    4,    \/\/ IID663\n+    9,    \/\/ IID653\n+    9,    \/\/ IID654\n+    8,    \/\/ IID655\n+    9,    \/\/ IID656\n+    4,    \/\/ IID657\n+    4,    \/\/ IID658\n+    4,    \/\/ IID659\n+    4,    \/\/ IID660\n+    9,    \/\/ IID661\n+    6,    \/\/ IID662\n+    6,    \/\/ IID663\n@@ -2606,1 +2772,1 @@\n-    3,    \/\/ IID667\n+    6,    \/\/ IID667\n@@ -2609,2 +2775,2 @@\n-    6,    \/\/ IID670\n-    4,    \/\/ IID671\n+    11,   \/\/ IID670\n+    11,   \/\/ IID671\n@@ -2612,1 +2778,1 @@\n-    6,    \/\/ IID673\n+    4,    \/\/ IID673\n@@ -2617,81 +2783,81 @@\n-    10,   \/\/ IID678\n-    10,   \/\/ IID679\n-    11,   \/\/ IID680\n-    11,   \/\/ IID681\n-    11,   \/\/ IID682\n-    11,   \/\/ IID683\n-    11,   \/\/ IID684\n-    10,   \/\/ IID685\n-    10,   \/\/ IID686\n-    11,   \/\/ IID687\n-    11,   \/\/ IID688\n-    11,   \/\/ IID689\n-    11,   \/\/ IID690\n-    11,   \/\/ IID691\n-    11,   \/\/ IID692\n-    11,   \/\/ IID693\n-    11,   \/\/ IID694\n-    10,   \/\/ IID695\n-    11,   \/\/ IID696\n-    11,   \/\/ IID697\n-    10,   \/\/ IID698\n-    11,   \/\/ IID699\n-    11,   \/\/ IID700\n-    10,   \/\/ IID701\n-    11,   \/\/ IID702\n-    11,   \/\/ IID703\n-    11,   \/\/ IID704\n-    10,   \/\/ IID705\n-    11,   \/\/ IID706\n-    11,   \/\/ IID707\n-    11,   \/\/ IID708\n-    11,   \/\/ IID709\n-    11,   \/\/ IID710\n-    11,   \/\/ IID711\n-    11,   \/\/ IID712\n-    11,   \/\/ IID713\n-    10,   \/\/ IID714\n-    11,   \/\/ IID715\n-    11,   \/\/ IID716\n-    10,   \/\/ IID717\n-    15,   \/\/ IID718\n-    12,   \/\/ IID719\n-    12,   \/\/ IID720\n-    15,   \/\/ IID721\n-    15,   \/\/ IID722\n-    12,   \/\/ IID723\n-    12,   \/\/ IID724\n-    15,   \/\/ IID725\n-    12,   \/\/ IID726\n-    12,   \/\/ IID727\n-    12,   \/\/ IID728\n-    11,   \/\/ IID729\n-    12,   \/\/ IID730\n-    12,   \/\/ IID731\n-    14,   \/\/ IID732\n-    15,   \/\/ IID733\n-    15,   \/\/ IID734\n-    12,   \/\/ IID735\n-    7,    \/\/ IID736\n-    7,    \/\/ IID737\n-    8,    \/\/ IID738\n-    10,   \/\/ IID739\n-    10,   \/\/ IID740\n-    10,   \/\/ IID741\n-    10,   \/\/ IID742\n-    10,   \/\/ IID743\n-    8,    \/\/ IID744\n-    10,   \/\/ IID745\n-    10,   \/\/ IID746\n-    10,   \/\/ IID747\n-    10,   \/\/ IID748\n-    10,   \/\/ IID749\n-    10,   \/\/ IID750\n-    10,   \/\/ IID751\n-    10,   \/\/ IID752\n-    10,   \/\/ IID753\n-    10,   \/\/ IID754\n-    10,   \/\/ IID755\n-    8,    \/\/ IID756\n-    10,   \/\/ IID757\n-    10,   \/\/ IID758\n+    6,    \/\/ IID678\n+    6,    \/\/ IID679\n+    6,    \/\/ IID680\n+    4,    \/\/ IID681\n+    6,    \/\/ IID682\n+    6,    \/\/ IID683\n+    6,    \/\/ IID684\n+    4,    \/\/ IID685\n+    6,    \/\/ IID686\n+    6,    \/\/ IID687\n+    6,    \/\/ IID688\n+    6,    \/\/ IID689\n+    6,    \/\/ IID690\n+    4,    \/\/ IID691\n+    6,    \/\/ IID692\n+    6,    \/\/ IID693\n+    6,    \/\/ IID694\n+    3,    \/\/ IID695\n+    6,    \/\/ IID696\n+    6,    \/\/ IID697\n+    6,    \/\/ IID698\n+    4,    \/\/ IID699\n+    6,    \/\/ IID700\n+    6,    \/\/ IID701\n+    6,    \/\/ IID702\n+    4,    \/\/ IID703\n+    6,    \/\/ IID704\n+    6,    \/\/ IID705\n+    6,    \/\/ IID706\n+    3,    \/\/ IID707\n+    6,    \/\/ IID708\n+    6,    \/\/ IID709\n+    6,    \/\/ IID710\n+    4,    \/\/ IID711\n+    6,    \/\/ IID712\n+    6,    \/\/ IID713\n+    6,    \/\/ IID714\n+    3,    \/\/ IID715\n+    6,    \/\/ IID716\n+    6,    \/\/ IID717\n+    6,    \/\/ IID718\n+    3,    \/\/ IID719\n+    6,    \/\/ IID720\n+    6,    \/\/ IID721\n+    6,    \/\/ IID722\n+    6,    \/\/ IID723\n+    6,    \/\/ IID724\n+    6,    \/\/ IID725\n+    11,   \/\/ IID726\n+    11,   \/\/ IID727\n+    11,   \/\/ IID728\n+    10,   \/\/ IID729\n+    11,   \/\/ IID730\n+    11,   \/\/ IID731\n+    11,   \/\/ IID732\n+    10,   \/\/ IID733\n+    11,   \/\/ IID734\n+    11,   \/\/ IID735\n+    11,   \/\/ IID736\n+    11,   \/\/ IID737\n+    11,   \/\/ IID738\n+    11,   \/\/ IID739\n+    11,   \/\/ IID740\n+    11,   \/\/ IID741\n+    11,   \/\/ IID742\n+    11,   \/\/ IID743\n+    11,   \/\/ IID744\n+    11,   \/\/ IID745\n+    11,   \/\/ IID746\n+    8,    \/\/ IID747\n+    11,   \/\/ IID748\n+    11,   \/\/ IID749\n+    11,   \/\/ IID750\n+    9,    \/\/ IID751\n+    11,   \/\/ IID752\n+    11,   \/\/ IID753\n+    11,   \/\/ IID754\n+    9,    \/\/ IID755\n+    11,   \/\/ IID756\n+    11,   \/\/ IID757\n+    11,   \/\/ IID758\n@@ -2699,32 +2865,32 @@\n-    7,    \/\/ IID760\n-    7,    \/\/ IID761\n-    4,    \/\/ IID762\n-    7,    \/\/ IID763\n-    7,    \/\/ IID764\n-    4,    \/\/ IID765\n-    6,    \/\/ IID766\n-    6,    \/\/ IID767\n-    7,    \/\/ IID768\n-    7,    \/\/ IID769\n-    7,    \/\/ IID770\n-    5,    \/\/ IID771\n-    6,    \/\/ IID772\n-    6,    \/\/ IID773\n-    6,    \/\/ IID774\n-    7,    \/\/ IID775\n-    7,    \/\/ IID776\n-    5,    \/\/ IID777\n-    7,    \/\/ IID778\n-    7,    \/\/ IID779\n-    6,    \/\/ IID780\n-    7,    \/\/ IID781\n-    7,    \/\/ IID782\n-    4,    \/\/ IID783\n-    6,    \/\/ IID784\n-    6,    \/\/ IID785\n-    7,    \/\/ IID786\n-    7,    \/\/ IID787\n-    7,    \/\/ IID788\n-    4,    \/\/ IID789\n-    7,    \/\/ IID790\n-    7,    \/\/ IID791\n+    11,   \/\/ IID760\n+    11,   \/\/ IID761\n+    11,   \/\/ IID762\n+    9,    \/\/ IID763\n+    11,   \/\/ IID764\n+    11,   \/\/ IID765\n+    14,   \/\/ IID766\n+    15,   \/\/ IID767\n+    12,   \/\/ IID768\n+    12,   \/\/ IID769\n+    15,   \/\/ IID770\n+    15,   \/\/ IID771\n+    15,   \/\/ IID772\n+    15,   \/\/ IID773\n+    11,   \/\/ IID774\n+    12,   \/\/ IID775\n+    11,   \/\/ IID776\n+    12,   \/\/ IID777\n+    12,   \/\/ IID778\n+    12,   \/\/ IID779\n+    11,   \/\/ IID780\n+    15,   \/\/ IID781\n+    15,   \/\/ IID782\n+    12,   \/\/ IID783\n+    10,   \/\/ IID784\n+    10,   \/\/ IID785\n+    8,    \/\/ IID786\n+    10,   \/\/ IID787\n+    10,   \/\/ IID788\n+    7,    \/\/ IID789\n+    10,   \/\/ IID790\n+    10,   \/\/ IID791\n@@ -2732,12 +2898,12 @@\n-    7,    \/\/ IID793\n-    7,    \/\/ IID794\n-    4,    \/\/ IID795\n-    7,    \/\/ IID796\n-    7,    \/\/ IID797\n-    6,    \/\/ IID798\n-    10,   \/\/ IID799\n-    10,   \/\/ IID800\n-    5,    \/\/ IID801\n-    7,    \/\/ IID802\n-    7,    \/\/ IID803\n-    10,   \/\/ IID804\n+    10,   \/\/ IID793\n+    10,   \/\/ IID794\n+    10,   \/\/ IID795\n+    10,   \/\/ IID796\n+    10,   \/\/ IID797\n+    10,   \/\/ IID798\n+    7,    \/\/ IID799\n+    7,    \/\/ IID800\n+    10,   \/\/ IID801\n+    10,   \/\/ IID802\n+    10,   \/\/ IID803\n+    4,    \/\/ IID804\n@@ -2746,31 +2912,31 @@\n-    8,    \/\/ IID807\n-    10,   \/\/ IID808\n-    10,   \/\/ IID809\n-    10,   \/\/ IID810\n-    7,    \/\/ IID811\n-    10,   \/\/ IID812\n-    8,    \/\/ IID813\n-    10,   \/\/ IID814\n-    10,   \/\/ IID815\n-    8,    \/\/ IID816\n-    10,   \/\/ IID817\n-    10,   \/\/ IID818\n-    8,    \/\/ IID819\n-    10,   \/\/ IID820\n-    10,   \/\/ IID821\n-    10,   \/\/ IID822\n-    11,   \/\/ IID823\n-    11,   \/\/ IID824\n-    10,   \/\/ IID825\n-    11,   \/\/ IID826\n-    11,   \/\/ IID827\n-    11,   \/\/ IID828\n-    11,   \/\/ IID829\n-    11,   \/\/ IID830\n-    10,   \/\/ IID831\n-    11,   \/\/ IID832\n-    11,   \/\/ IID833\n-    10,   \/\/ IID834\n-    6,    \/\/ IID835\n-    3,    \/\/ IID836\n-    6,    \/\/ IID837\n+    7,    \/\/ IID807\n+    7,    \/\/ IID808\n+    7,    \/\/ IID809\n+    4,    \/\/ IID810\n+    6,    \/\/ IID811\n+    6,    \/\/ IID812\n+    5,    \/\/ IID813\n+    7,    \/\/ IID814\n+    7,    \/\/ IID815\n+    7,    \/\/ IID816\n+    7,    \/\/ IID817\n+    7,    \/\/ IID818\n+    5,    \/\/ IID819\n+    7,    \/\/ IID820\n+    7,    \/\/ IID821\n+    7,    \/\/ IID822\n+    7,    \/\/ IID823\n+    7,    \/\/ IID824\n+    4,    \/\/ IID825\n+    6,    \/\/ IID826\n+    6,    \/\/ IID827\n+    7,    \/\/ IID828\n+    6,    \/\/ IID829\n+    6,    \/\/ IID830\n+    5,    \/\/ IID831\n+    7,    \/\/ IID832\n+    7,    \/\/ IID833\n+    7,    \/\/ IID834\n+    7,    \/\/ IID835\n+    7,    \/\/ IID836\n+    4,    \/\/ IID837\n@@ -2779,55 +2945,55 @@\n-    6,    \/\/ IID840\n-    6,    \/\/ IID841\n-    6,    \/\/ IID842\n-    6,    \/\/ IID843\n-    4,    \/\/ IID844\n-    6,    \/\/ IID845\n-    6,    \/\/ IID846\n-    6,    \/\/ IID847\n-    4,    \/\/ IID848\n-    6,    \/\/ IID849\n-    6,    \/\/ IID850\n-    6,    \/\/ IID851\n-    3,    \/\/ IID852\n-    6,    \/\/ IID853\n-    6,    \/\/ IID854\n-    6,    \/\/ IID855\n-    3,    \/\/ IID856\n-    6,    \/\/ IID857\n-    6,    \/\/ IID858\n-    6,    \/\/ IID859\n-    4,    \/\/ IID860\n-    6,    \/\/ IID861\n-    6,    \/\/ IID862\n-    7,    \/\/ IID863\n-    5,    \/\/ IID864\n-    7,    \/\/ IID865\n-    7,    \/\/ IID866\n-    7,    \/\/ IID867\n-    5,    \/\/ IID868\n-    7,    \/\/ IID869\n-    7,    \/\/ IID870\n-    6,    \/\/ IID871\n-    4,    \/\/ IID872\n-    6,    \/\/ IID873\n-    4,    \/\/ IID874\n-    6,    \/\/ IID875\n-    4,    \/\/ IID876\n-    6,    \/\/ IID877\n-    4,    \/\/ IID878\n-    6,    \/\/ IID879\n-    4,    \/\/ IID880\n-    6,    \/\/ IID881\n-    4,    \/\/ IID882\n-    6,    \/\/ IID883\n-    4,    \/\/ IID884\n-    6,    \/\/ IID885\n-    4,    \/\/ IID886\n-    6,    \/\/ IID887\n-    4,    \/\/ IID888\n-    6,    \/\/ IID889\n-    4,    \/\/ IID890\n-    6,    \/\/ IID891\n-    4,    \/\/ IID892\n-    6,    \/\/ IID893\n-    4,    \/\/ IID894\n+    7,    \/\/ IID840\n+    7,    \/\/ IID841\n+    7,    \/\/ IID842\n+    4,    \/\/ IID843\n+    7,    \/\/ IID844\n+    7,    \/\/ IID845\n+    7,    \/\/ IID846\n+    7,    \/\/ IID847\n+    7,    \/\/ IID848\n+    7,    \/\/ IID849\n+    10,   \/\/ IID850\n+    10,   \/\/ IID851\n+    10,   \/\/ IID852\n+    10,   \/\/ IID853\n+    10,   \/\/ IID854\n+    7,    \/\/ IID855\n+    7,    \/\/ IID856\n+    7,    \/\/ IID857\n+    10,   \/\/ IID858\n+    10,   \/\/ IID859\n+    10,   \/\/ IID860\n+    7,    \/\/ IID861\n+    10,   \/\/ IID862\n+    10,   \/\/ IID863\n+    7,    \/\/ IID864\n+    10,   \/\/ IID865\n+    10,   \/\/ IID866\n+    8,    \/\/ IID867\n+    10,   \/\/ IID868\n+    10,   \/\/ IID869\n+    10,   \/\/ IID870\n+    11,   \/\/ IID871\n+    9,    \/\/ IID872\n+    11,   \/\/ IID873\n+    11,   \/\/ IID874\n+    11,   \/\/ IID875\n+    9,    \/\/ IID876\n+    10,   \/\/ IID877\n+    11,   \/\/ IID878\n+    11,   \/\/ IID879\n+    9,    \/\/ IID880\n+    11,   \/\/ IID881\n+    10,   \/\/ IID882\n+    11,   \/\/ IID883\n+    9,    \/\/ IID884\n+    11,   \/\/ IID885\n+    11,   \/\/ IID886\n+    11,   \/\/ IID887\n+    9,    \/\/ IID888\n+    11,   \/\/ IID889\n+    11,   \/\/ IID890\n+    10,   \/\/ IID891\n+    9,    \/\/ IID892\n+    10,   \/\/ IID893\n+    11,   \/\/ IID894\n@@ -2836,2 +3002,2 @@\n-    6,    \/\/ IID897\n-    4,    \/\/ IID898\n+    3,    \/\/ IID897\n+    6,    \/\/ IID898\n@@ -2839,1 +3005,1 @@\n-    4,    \/\/ IID900\n+    6,    \/\/ IID900\n@@ -2841,17 +3007,103 @@\n-    4,    \/\/ IID902\n-    11,   \/\/ IID903\n-    11,   \/\/ IID904\n-    11,   \/\/ IID905\n-    10,   \/\/ IID906\n-    11,   \/\/ IID907\n-    9,    \/\/ IID908\n-    11,   \/\/ IID909\n-    11,   \/\/ IID910\n-    11,   \/\/ IID911\n-    10,   \/\/ IID912\n-    11,   \/\/ IID913\n-    11,   \/\/ IID914\n-    11,   \/\/ IID915\n-    11,   \/\/ IID916\n-    11,   \/\/ IID917\n-    11,   \/\/ IID918\n+    6,    \/\/ IID902\n+    6,    \/\/ IID903\n+    6,    \/\/ IID904\n+    6,    \/\/ IID905\n+    4,    \/\/ IID906\n+    4,    \/\/ IID907\n+    6,    \/\/ IID908\n+    6,    \/\/ IID909\n+    6,    \/\/ IID910\n+    6,    \/\/ IID911\n+    4,    \/\/ IID912\n+    4,    \/\/ IID913\n+    6,    \/\/ IID914\n+    6,    \/\/ IID915\n+    6,    \/\/ IID916\n+    6,    \/\/ IID917\n+    4,    \/\/ IID918\n+    4,    \/\/ IID919\n+    6,    \/\/ IID920\n+    6,    \/\/ IID921\n+    6,    \/\/ IID922\n+    6,    \/\/ IID923\n+    4,    \/\/ IID924\n+    6,    \/\/ IID925\n+    6,    \/\/ IID926\n+    4,    \/\/ IID927\n+    3,    \/\/ IID928\n+    4,    \/\/ IID929\n+    6,    \/\/ IID930\n+    6,    \/\/ IID931\n+    6,    \/\/ IID932\n+    7,    \/\/ IID933\n+    5,    \/\/ IID934\n+    7,    \/\/ IID935\n+    7,    \/\/ IID936\n+    5,    \/\/ IID937\n+    5,    \/\/ IID938\n+    7,    \/\/ IID939\n+    7,    \/\/ IID940\n+    6,    \/\/ IID941\n+    4,    \/\/ IID942\n+    6,    \/\/ IID943\n+    4,    \/\/ IID944\n+    6,    \/\/ IID945\n+    4,    \/\/ IID946\n+    6,    \/\/ IID947\n+    4,    \/\/ IID948\n+    6,    \/\/ IID949\n+    4,    \/\/ IID950\n+    6,    \/\/ IID951\n+    4,    \/\/ IID952\n+    6,    \/\/ IID953\n+    4,    \/\/ IID954\n+    6,    \/\/ IID955\n+    4,    \/\/ IID956\n+    6,    \/\/ IID957\n+    4,    \/\/ IID958\n+    6,    \/\/ IID959\n+    4,    \/\/ IID960\n+    6,    \/\/ IID961\n+    4,    \/\/ IID962\n+    6,    \/\/ IID963\n+    4,    \/\/ IID964\n+    6,    \/\/ IID965\n+    4,    \/\/ IID966\n+    6,    \/\/ IID967\n+    4,    \/\/ IID968\n+    6,    \/\/ IID969\n+    4,    \/\/ IID970\n+    6,    \/\/ IID971\n+    4,    \/\/ IID972\n+    11,   \/\/ IID973\n+    9,    \/\/ IID974\n+    10,   \/\/ IID975\n+    9,    \/\/ IID976\n+    11,   \/\/ IID977\n+    9,    \/\/ IID978\n+    11,   \/\/ IID979\n+    9,    \/\/ IID980\n+    11,   \/\/ IID981\n+    9,    \/\/ IID982\n+    11,   \/\/ IID983\n+    9,    \/\/ IID984\n+    11,   \/\/ IID985\n+    9,    \/\/ IID986\n+    10,   \/\/ IID987\n+    9,    \/\/ IID988\n+    11,   \/\/ IID989\n+    9,    \/\/ IID990\n+    11,   \/\/ IID991\n+    9,    \/\/ IID992\n+    11,   \/\/ IID993\n+    9,    \/\/ IID994\n+    11,   \/\/ IID995\n+    9,    \/\/ IID996\n+    11,   \/\/ IID997\n+    9,    \/\/ IID998\n+    10,   \/\/ IID999\n+    9,    \/\/ IID1000\n+    11,   \/\/ IID1001\n+    9,    \/\/ IID1002\n+    11,   \/\/ IID1003\n+    9,    \/\/ IID1004\n@@ -3155,50 +3407,47 @@\n-    \"__ eorl(r30, Address(rbx, rdx, (Address::ScaleFactor)3, -0x463540b4), r28, false);\", \/\/ IID271\n-    \"__ eorl(r18, Address(r28, r10, (Address::ScaleFactor)3, +0x3523a73b), r18, false);\", \/\/ IID272\n-    \"__ eorl(r9, Address(r15, r15, (Address::ScaleFactor)1, -0x2a0bdd56), r21, true);\",   \/\/ IID273\n-    \"__ eorl(r16, Address(r23, -0x165064ff), r16, true);\",                                \/\/ IID274\n-    \"__ eorb(r28, Address(r30, r11, (Address::ScaleFactor)0, +0x17281e3a), r20, false);\", \/\/ IID275\n-    \"__ eorb(rdx, Address(rbx, r31, (Address::ScaleFactor)2, +0x2477b5bb), rdx, false);\", \/\/ IID276\n-    \"__ eorb(r16, Address(r11, rcx, (Address::ScaleFactor)1, -0x3175d1af), r24, true);\",  \/\/ IID277\n-    \"__ eorb(rbx, Address(r11, r20, (Address::ScaleFactor)3, -0x22d67bd3), rbx, true);\",  \/\/ IID278\n-    \"__ esubl(r26, Address(r27, r30, (Address::ScaleFactor)1, -0x3d9bce2e), rdx, false);\", \/\/ IID279\n-    \"__ esubl(r31, Address(r22, r29, (Address::ScaleFactor)1, +0x14218519), r31, false);\", \/\/ IID280\n-    \"__ esubl(r21, Address(r9, -0x1050127a), r13, true);\",                                \/\/ IID281\n-    \"__ esubl(r31, Address(r9, r8, (Address::ScaleFactor)0, -0xae18961), r31, true);\",    \/\/ IID282\n-    \"__ exorl(r15, Address(r18, +0x5c2bbce5), r12, false);\",                              \/\/ IID283\n-    \"__ exorl(r27, Address(r25, r23, (Address::ScaleFactor)0, +0x5c6078b3), r27, false);\", \/\/ IID284\n-    \"__ exorl(r18, Address(r8, rdx, (Address::ScaleFactor)3, -0x9ed3881), r14, true);\",   \/\/ IID285\n-    \"__ exorl(r9, Address(r15, +0x775acdad), r9, true);\",                                 \/\/ IID286\n-    \"__ exorb(r21, Address(r18, r26, (Address::ScaleFactor)1, +0x2fe31fd5), r23, false);\", \/\/ IID287\n-    \"__ exorb(r10, Address(r27, +0xa3150de), r10, false);\",                               \/\/ IID288\n-    \"__ exorb(r18, Address(r22, r30, (Address::ScaleFactor)3, +0x1ad4e897), r24, true);\", \/\/ IID289\n-    \"__ exorb(r8, Address(r16, r20, (Address::ScaleFactor)0, +0x626eae82), r8, true);\",   \/\/ IID290\n-    \"__ eaddl(r21, r15, 1048576, false);\",                                                \/\/ IID291\n-    \"__ eaddl(rax, r18, 1048576, false);\",                                                \/\/ IID292\n-    \"__ eaddl(r18, r18, 256, false);\",                                                    \/\/ IID293\n-    \"__ eaddl(r13, r19, 16, true);\",                                                      \/\/ IID294\n-    \"__ eaddl(rax, r23, 16, true);\",                                                      \/\/ IID295\n-    \"__ eaddl(r25, r25, 16777216, true);\",                                                \/\/ IID296\n-    \"__ eandl(r29, r18, 1048576, false);\",                                                \/\/ IID297\n-    \"__ eandl(rax, r14, 1048576, false);\",                                                \/\/ IID298\n-    \"__ eandl(r19, r19, 65536, false);\",                                                  \/\/ IID299\n-    \"__ eandl(r27, r25, 1048576, true);\",                                                 \/\/ IID300\n-    \"__ eandl(rax, r20, 1048576, true);\",                                                 \/\/ IID301\n-    \"__ eandl(r28, r28, 16, true);\",                                                      \/\/ IID302\n-    \"__ eimull(r31, r22, 4096, false);\",                                                  \/\/ IID303\n-#endif \/\/ _LP64\n-    \"__ eimull(rax, rbx, 4096, false);\",                                                  \/\/ IID304\n-#ifdef _LP64\n-    \"__ eimull(r24, r24, 1048576, false);\",                                               \/\/ IID305\n-    \"__ eimull(r21, r16, 65536, true);\",                                                  \/\/ IID306\n-    \"__ eimull(rax, r24, 65536, true);\",                                                  \/\/ IID307\n-    \"__ eimull(r13, r13, 16, true);\",                                                     \/\/ IID308\n-    \"__ eorl(r29, r8, 16777216, false);\",                                                 \/\/ IID309\n-    \"__ eorl(rax, r12, 16777216, false);\",                                                \/\/ IID310\n-    \"__ eorl(r30, r30, 4096, false);\",                                                    \/\/ IID311\n-    \"__ eorl(r24, rdx, 16, true);\",                                                       \/\/ IID312\n-    \"__ eorl(rax, r8, 16, true);\",                                                        \/\/ IID313\n-    \"__ eorl(r13, r13, 4096, true);\",                                                     \/\/ IID314\n-    \"__ ercll(r25, r13, 1);\",                                                             \/\/ IID315\n-    \"__ ercll(rax, r18, 1);\",                                                             \/\/ IID316\n-    \"__ ercll(r9, r9, 16);\",                                                              \/\/ IID317\n-    \"__ eroll(r26, r25, 8, false);\",                                                      \/\/ IID318\n+    \"__ eandl(r30, Address(rbx, rdx, (Address::ScaleFactor)3, -0x463540b4), r28, false);\", \/\/ IID271\n+    \"__ eandl(r18, Address(r28, r10, (Address::ScaleFactor)3, +0x3523a73b), r18, false);\", \/\/ IID272\n+    \"__ eandl(r9, Address(r15, r15, (Address::ScaleFactor)1, -0x2a0bdd56), r21, true);\",  \/\/ IID273\n+    \"__ eandl(r16, Address(r23, -0x165064ff), r16, true);\",                               \/\/ IID274\n+    \"__ eorl(r28, Address(r30, r11, (Address::ScaleFactor)0, +0x17281e3a), r20, false);\", \/\/ IID275\n+    \"__ eorl(rdx, Address(rbx, r31, (Address::ScaleFactor)2, +0x2477b5bb), rdx, false);\", \/\/ IID276\n+    \"__ eorl(r16, Address(r11, rcx, (Address::ScaleFactor)1, -0x3175d1af), r24, true);\",  \/\/ IID277\n+    \"__ eorl(rbx, Address(r11, r20, (Address::ScaleFactor)3, -0x22d67bd3), rbx, true);\",  \/\/ IID278\n+    \"__ eorb(r26, Address(r27, r30, (Address::ScaleFactor)1, -0x3d9bce2e), rdx, false);\", \/\/ IID279\n+    \"__ eorb(r31, Address(r22, r29, (Address::ScaleFactor)1, +0x14218519), r31, false);\", \/\/ IID280\n+    \"__ eorb(r21, Address(r9, -0x1050127a), r13, true);\",                                 \/\/ IID281\n+    \"__ eorb(r31, Address(r9, r8, (Address::ScaleFactor)0, -0xae18961), r31, true);\",     \/\/ IID282\n+    \"__ esubl(r15, Address(r18, +0x5c2bbce5), r12, false);\",                              \/\/ IID283\n+    \"__ esubl(r27, Address(r25, r23, (Address::ScaleFactor)0, +0x5c6078b3), r27, false);\", \/\/ IID284\n+    \"__ esubl(r18, Address(r8, rdx, (Address::ScaleFactor)3, -0x9ed3881), r14, true);\",   \/\/ IID285\n+    \"__ esubl(r9, Address(r15, +0x775acdad), r9, true);\",                                 \/\/ IID286\n+    \"__ exorl(r21, Address(r18, r26, (Address::ScaleFactor)1, +0x2fe31fd5), r23, false);\", \/\/ IID287\n+    \"__ exorl(r10, Address(r27, +0xa3150de), r10, false);\",                               \/\/ IID288\n+    \"__ exorl(r18, Address(r22, r30, (Address::ScaleFactor)3, +0x1ad4e897), r24, true);\", \/\/ IID289\n+    \"__ exorl(r8, Address(r16, r20, (Address::ScaleFactor)0, +0x626eae82), r8, true);\",   \/\/ IID290\n+    \"__ exorb(r16, Address(r21, r15, (Address::ScaleFactor)0, -0x1403b60d), r18, false);\", \/\/ IID291\n+    \"__ exorb(r13, Address(r19, r23, (Address::ScaleFactor)2, +0x237ef1e1), r13, false);\", \/\/ IID292\n+    \"__ exorb(r29, Address(r18, r14, (Address::ScaleFactor)2, +0x5cc0095b), r14, true);\", \/\/ IID293\n+    \"__ exorb(r27, Address(r25, r20, (Address::ScaleFactor)3, +0x1cf7b958), r27, true);\", \/\/ IID294\n+    \"__ eaddl(r16, r24, 16, false);\",                                                     \/\/ IID295\n+    \"__ eaddl(rax, r24, 16, false);\",                                                     \/\/ IID296\n+    \"__ eaddl(r21, r21, 65536, false);\",                                                  \/\/ IID297\n+    \"__ eaddl(r24, r8, 1048576, true);\",                                                  \/\/ IID298\n+    \"__ eaddl(rax, r13, 1048576, true);\",                                                 \/\/ IID299\n+    \"__ eaddl(r29, r29, 16777216, true);\",                                                \/\/ IID300\n+    \"__ eandl(r12, r12, 16, false);\",                                                     \/\/ IID301\n+    \"__ eandl(rax, r30, 16, false);\",                                                     \/\/ IID302\n+    \"__ eandl(r24, r24, 16, false);\",                                                     \/\/ IID303\n+    \"__ eandl(r8, r12, 1, true);\",                                                        \/\/ IID304\n+    \"__ eandl(rax, r13, 1, true);\",                                                       \/\/ IID305\n+    \"__ eandl(r25, r25, 16, true);\",                                                      \/\/ IID306\n+    \"__ eimull(r18, r23, 65536, false);\",                                                 \/\/ IID307\n+    \"__ eimull(rax, r9, 65536, false);\",                                                  \/\/ IID308\n+    \"__ eimull(r26, r26, 268435456, false);\",                                             \/\/ IID309\n+    \"__ eimull(r25, r21, 1, true);\",                                                      \/\/ IID310\n+    \"__ eimull(rax, r24, 1, true);\",                                                      \/\/ IID311\n+    \"__ eimull(r24, r24, 16777216, true);\",                                               \/\/ IID312\n+    \"__ eorl(r30, r26, 1, false);\",                                                       \/\/ IID313\n+    \"__ eorl(rax, r22, 1, false);\",                                                       \/\/ IID314\n+    \"__ eorl(r17, r17, 1048576, false);\",                                                 \/\/ IID315\n+    \"__ eorl(r24, r8, 1, true);\",                                                         \/\/ IID316\n+    \"__ eorl(rax, r27, 1, true);\",                                                        \/\/ IID317\n@@ -3206,1 +3455,1 @@\n-    \"__ eroll(rax, rdx, 8, false);\",                                                      \/\/ IID319\n+    \"__ eorl(rdx, rdx, 268435456, true);\",                                                \/\/ IID318\n@@ -3208,5 +3457,49 @@\n-    \"__ eroll(r24, r24, 16, false);\",                                                     \/\/ IID320\n-    \"__ eroll(r24, rcx, 8, true);\",                                                       \/\/ IID321\n-    \"__ eroll(rax, r30, 8, true);\",                                                       \/\/ IID322\n-    \"__ eroll(r28, r28, 16, true);\",                                                      \/\/ IID323\n-    \"__ erorl(r17, r28, 4, false);\",                                                      \/\/ IID324\n+    \"__ ercll(r22, r22, 8);\",                                                             \/\/ IID319\n+    \"__ ercll(rax, r23, 8);\",                                                             \/\/ IID320\n+    \"__ ercll(r19, r19, 4);\",                                                             \/\/ IID321\n+    \"__ eroll(r30, r24, 2, false);\",                                                      \/\/ IID322\n+    \"__ eroll(rax, r29, 2, false);\",                                                      \/\/ IID323\n+    \"__ eroll(r8, r8, 2, false);\",                                                        \/\/ IID324\n+    \"__ eroll(r18, r24, 16, true);\",                                                      \/\/ IID325\n+    \"__ eroll(rax, r13, 16, true);\",                                                      \/\/ IID326\n+    \"__ eroll(r24, r24, 1, true);\",                                                       \/\/ IID327\n+    \"__ erorl(r28, r17, 16, false);\",                                                     \/\/ IID328\n+    \"__ erorl(rax, r24, 16, false);\",                                                     \/\/ IID329\n+    \"__ erorl(r17, r17, 4, false);\",                                                      \/\/ IID330\n+    \"__ erorl(r24, rcx, 4, true);\",                                                       \/\/ IID331\n+    \"__ erorl(rax, r16, 4, true);\",                                                       \/\/ IID332\n+    \"__ erorl(r15, r15, 2, true);\",                                                       \/\/ IID333\n+    \"__ esall(r14, r27, 4, false);\",                                                      \/\/ IID334\n+    \"__ esall(rax, r23, 4, false);\",                                                      \/\/ IID335\n+    \"__ esall(r30, r30, 4, false);\",                                                      \/\/ IID336\n+    \"__ esall(r27, rdx, 2, true);\",                                                       \/\/ IID337\n+    \"__ esall(rax, r19, 2, true);\",                                                       \/\/ IID338\n+    \"__ esall(r20, r20, 2, true);\",                                                       \/\/ IID339\n+    \"__ esarl(r21, r23, 1, false);\",                                                      \/\/ IID340\n+    \"__ esarl(rax, r30, 1, false);\",                                                      \/\/ IID341\n+    \"__ esarl(r25, r25, 2, false);\",                                                      \/\/ IID342\n+    \"__ esarl(r24, r19, 4, true);\",                                                       \/\/ IID343\n+    \"__ esarl(rax, r14, 4, true);\",                                                       \/\/ IID344\n+    \"__ esarl(r26, r26, 16, true);\",                                                      \/\/ IID345\n+    \"__ eshll(r22, r13, 8, false);\",                                                      \/\/ IID346\n+    \"__ eshll(rax, r24, 8, false);\",                                                      \/\/ IID347\n+    \"__ eshll(r14, r14, 16, false);\",                                                     \/\/ IID348\n+    \"__ eshll(r28, r25, 8, true);\",                                                       \/\/ IID349\n+    \"__ eshll(rax, r10, 8, true);\",                                                       \/\/ IID350\n+    \"__ eshll(r20, r20, 1, true);\",                                                       \/\/ IID351\n+    \"__ eshrl(r12, rbx, 4, false);\",                                                      \/\/ IID352\n+    \"__ eshrl(rax, r23, 4, false);\",                                                      \/\/ IID353\n+    \"__ eshrl(r28, r28, 16, false);\",                                                     \/\/ IID354\n+    \"__ eshrl(r24, r30, 4, true);\",                                                       \/\/ IID355\n+    \"__ eshrl(rax, r31, 4, true);\",                                                       \/\/ IID356\n+    \"__ eshrl(r31, r31, 2, true);\",                                                       \/\/ IID357\n+    \"__ esubl(r20, r10, 256, false);\",                                                    \/\/ IID358\n+    \"__ esubl(rax, r13, 256, false);\",                                                    \/\/ IID359\n+    \"__ esubl(r25, r25, 256, false);\",                                                    \/\/ IID360\n+    \"__ esubl(r23, r12, 268435456, true);\",                                               \/\/ IID361\n+    \"__ esubl(rax, r16, 268435456, true);\",                                               \/\/ IID362\n+    \"__ esubl(r31, r31, 1, true);\",                                                       \/\/ IID363\n+    \"__ exorl(r9, r15, 16777216, false);\",                                                \/\/ IID364\n+    \"__ exorl(rax, r13, 16777216, false);\",                                               \/\/ IID365\n+    \"__ exorl(r28, r28, 16, false);\",                                                     \/\/ IID366\n+    \"__ exorl(r29, r22, 16, true);\",                                                      \/\/ IID367\n@@ -3214,1 +3507,1 @@\n-    \"__ erorl(rax, rdx, 4, false);\",                                                      \/\/ IID325\n+    \"__ exorl(rax, rbx, 16, true);\",                                                      \/\/ IID368\n@@ -3216,36 +3509,62 @@\n-    \"__ erorl(r8, r8, 16, false);\",                                                       \/\/ IID326\n-    \"__ erorl(r19, rdx, 16, true);\",                                                      \/\/ IID327\n-    \"__ erorl(rax, r31, 16, true);\",                                                      \/\/ IID328\n-    \"__ erorl(r22, r22, 8, true);\",                                                       \/\/ IID329\n-    \"__ esall(r23, r25, 16, false);\",                                                     \/\/ IID330\n-    \"__ esall(rax, r14, 16, false);\",                                                     \/\/ IID331\n-    \"__ esall(r31, r31, 8, false);\",                                                      \/\/ IID332\n-    \"__ esall(r30, r24, 2, true);\",                                                       \/\/ IID333\n-    \"__ esall(rax, r29, 2, true);\",                                                       \/\/ IID334\n-    \"__ esall(r8, r8, 2, true);\",                                                         \/\/ IID335\n-    \"__ esarl(r18, r24, 16, false);\",                                                     \/\/ IID336\n-    \"__ esarl(rax, r13, 16, false);\",                                                     \/\/ IID337\n-    \"__ esarl(r24, r24, 1, false);\",                                                      \/\/ IID338\n-    \"__ esarl(r28, r17, 16, true);\",                                                      \/\/ IID339\n-    \"__ esarl(rax, r24, 16, true);\",                                                      \/\/ IID340\n-    \"__ esarl(r17, r17, 4, true);\",                                                       \/\/ IID341\n-    \"__ eshll(r24, rcx, 4, false);\",                                                      \/\/ IID342\n-    \"__ eshll(rax, r16, 4, false);\",                                                      \/\/ IID343\n-    \"__ eshll(r15, r15, 2, false);\",                                                      \/\/ IID344\n-    \"__ eshll(r14, r27, 4, true);\",                                                       \/\/ IID345\n-    \"__ eshll(rax, r23, 4, true);\",                                                       \/\/ IID346\n-    \"__ eshll(r30, r30, 4, true);\",                                                       \/\/ IID347\n-    \"__ eshrl(r27, rdx, 2, false);\",                                                      \/\/ IID348\n-    \"__ eshrl(rax, r19, 2, false);\",                                                      \/\/ IID349\n-    \"__ eshrl(r20, r20, 2, false);\",                                                      \/\/ IID350\n-    \"__ eshrl(r21, r23, 1, true);\",                                                       \/\/ IID351\n-    \"__ eshrl(rax, r30, 1, true);\",                                                       \/\/ IID352\n-    \"__ eshrl(r25, r25, 2, true);\",                                                       \/\/ IID353\n-    \"__ esubl(r24, r19, 1048576, false);\",                                                \/\/ IID354\n-    \"__ esubl(rax, r14, 1048576, false);\",                                                \/\/ IID355\n-    \"__ esubl(r22, r22, 268435456, false);\",                                              \/\/ IID356\n-    \"__ esubl(r24, r24, 65536, true);\",                                                   \/\/ IID357\n-    \"__ esubl(rax, r14, 65536, true);\",                                                   \/\/ IID358\n-    \"__ esubl(r28, r28, 268435456, true);\",                                               \/\/ IID359\n-    \"__ exorl(rbx, r20, 256, false);\",                                                    \/\/ IID360\n-    \"__ exorl(rax, r15, 256, false);\",                                                    \/\/ IID361\n+    \"__ exorl(r8, r8, 16, true);\",                                                        \/\/ IID369\n+    \"__ esubl_imm32(r16, r13, 4194304, false);\",                                          \/\/ IID370\n+    \"__ esubl_imm32(rax, r12, 4194304, false);\",                                          \/\/ IID371\n+    \"__ esubl_imm32(r17, r17, 67108864, false);\",                                         \/\/ IID372\n+    \"__ esubl_imm32(r22, r26, 1073741824, true);\",                                        \/\/ IID373\n+    \"__ esubl_imm32(rax, r10, 1073741824, true);\",                                        \/\/ IID374\n+    \"__ esubl_imm32(r11, r11, 1073741824, true);\",                                        \/\/ IID375\n+    \"__ eaddl(r19, r12, Address(r30, r8, (Address::ScaleFactor)0, +0x6a1a0a73), false);\", \/\/ IID376\n+    \"__ eaddl(r30, r30, Address(r18, r19, (Address::ScaleFactor)2, +0x25f990cf), false);\", \/\/ IID377\n+    \"__ eaddl(rcx, r25, Address(r19, r16, (Address::ScaleFactor)0, +0x482d5dbc), true);\", \/\/ IID378\n+    \"__ eaddl(r9, r9, Address(r11, +0x43d5ee01), true);\",                                 \/\/ IID379\n+    \"__ eandl(rcx, r23, Address(r21, r15, (Address::ScaleFactor)2, +0x2825c2bc), false);\", \/\/ IID380\n+    \"__ eandl(r27, r27, Address(r13, r15, (Address::ScaleFactor)3, -0x1268b895), false);\", \/\/ IID381\n+    \"__ eandl(r9, r23, Address(r22, r30, (Address::ScaleFactor)0, -0x715acbb), true);\",   \/\/ IID382\n+    \"__ eandl(rbx, rbx, Address(r28, r16, (Address::ScaleFactor)2, +0xb0223ee), true);\",  \/\/ IID383\n+    \"__ eimull(r15, r29, Address(r15, r28, (Address::ScaleFactor)1, -0x1f297a69), false);\", \/\/ IID384\n+    \"__ eimull(r17, r17, Address(r23, rbx, (Address::ScaleFactor)1, +0xadc7545), false);\", \/\/ IID385\n+    \"__ eimull(r27, r9, Address(rdx, r22, (Address::ScaleFactor)2, -0x43d90f61), true);\", \/\/ IID386\n+    \"__ eimull(rbx, rbx, Address(r28, r22, (Address::ScaleFactor)3, -0x519d9a27), true);\", \/\/ IID387\n+    \"__ eorl(r17, rcx, Address(r14, +0x10642223), false);\",                               \/\/ IID388\n+    \"__ eorl(r26, r26, Address(r31, -0x7a9a83ba), false);\",                               \/\/ IID389\n+    \"__ eorl(r15, r22, Address(r12, r12, (Address::ScaleFactor)2, +0x743b6997), true);\",  \/\/ IID390\n+    \"__ eorl(r8, r8, Address(rdx, r22, (Address::ScaleFactor)3, -0x588414dc), true);\",    \/\/ IID391\n+    \"__ esubl(rcx, r28, Address(r30, r13, (Address::ScaleFactor)2, +0xe9310e5), false);\", \/\/ IID392\n+    \"__ esubl(rcx, rcx, Address(r30, r10, (Address::ScaleFactor)1, -0x1b076ed1), false);\", \/\/ IID393\n+    \"__ esubl(r9, r21, Address(r30, +0x2f79ffd3), true);\",                                \/\/ IID394\n+    \"__ esubl(r16, r16, Address(rdx, r14, (Address::ScaleFactor)2, +0x675d71c1), true);\", \/\/ IID395\n+    \"__ exorl(r27, r28, Address(rbx, r26, (Address::ScaleFactor)2, -0x78c20b81), false);\", \/\/ IID396\n+    \"__ exorl(r14, r14, Address(r31, r19, (Address::ScaleFactor)1, -0x4ff251cc), false);\", \/\/ IID397\n+    \"__ exorl(r20, r18, Address(r13, r16, (Address::ScaleFactor)2, -0x19efc6e2), true);\", \/\/ IID398\n+    \"__ exorl(r19, r19, Address(r13, r23, (Address::ScaleFactor)1, -0x2d1bd8aa), true);\", \/\/ IID399\n+    \"__ exorb(r29, r17, Address(rdx, r29, (Address::ScaleFactor)2, +0x66573e84), false);\", \/\/ IID400\n+    \"__ exorb(r22, r22, Address(r24, r25, (Address::ScaleFactor)3, +0x3a94a93f), false);\", \/\/ IID401\n+    \"__ exorb(r13, r29, Address(r15, r23, (Address::ScaleFactor)1, +0x76d43532), true);\", \/\/ IID402\n+    \"__ exorb(r15, r15, Address(r13, r9, (Address::ScaleFactor)0, -0x474e6d1a), true);\",  \/\/ IID403\n+    \"__ exorw(r17, r16, Address(r23, rdx, (Address::ScaleFactor)0, +0x562a291), false);\", \/\/ IID404\n+    \"__ exorw(r29, r29, Address(r18, r28, (Address::ScaleFactor)3, -0x541967f2), false);\", \/\/ IID405\n+    \"__ exorw(r27, r11, Address(r10, +0xa911c5a), true);\",                                \/\/ IID406\n+    \"__ exorw(r31, r31, Address(r30, r19, (Address::ScaleFactor)2, -0xf6a3da), true);\",   \/\/ IID407\n+    \"__ eaddl(r12, r13, r23, false);\",                                                    \/\/ IID408\n+    \"__ eaddl(r28, r28, r20, false);\",                                                    \/\/ IID409\n+    \"__ eaddl(r20, r24, r20, false);\",                                                    \/\/ IID410\n+    \"__ eaddl(r11, r10, r15, true);\",                                                     \/\/ IID411\n+    \"__ eaddl(r19, r19, r20, true);\",                                                     \/\/ IID412\n+    \"__ eaddl(r23, r15, r23, true);\",                                                     \/\/ IID413\n+    \"__ eandl(r26, r19, r24, false);\",                                                    \/\/ IID414\n+    \"__ eandl(r23, r23, r28, false);\",                                                    \/\/ IID415\n+    \"__ eandl(r11, r13, r11, false);\",                                                    \/\/ IID416\n+    \"__ eandl(r13, rdx, r31, true);\",                                                     \/\/ IID417\n+    \"__ eandl(r23, r23, r23, true);\",                                                     \/\/ IID418\n+    \"__ eandl(r9, r27, r9, true);\",                                                       \/\/ IID419\n+    \"__ eimull(r21, r20, r24, false);\",                                                   \/\/ IID420\n+    \"__ eimull(r21, r21, r29, false);\",                                                   \/\/ IID421\n+    \"__ eimull(rbx, r11, rbx, false);\",                                                   \/\/ IID422\n+    \"__ eimull(r21, rbx, rcx, true);\",                                                    \/\/ IID423\n+    \"__ eimull(r31, r31, r21, true);\",                                                    \/\/ IID424\n+    \"__ eimull(r15, r25, r15, true);\",                                                    \/\/ IID425\n+    \"__ eorw(r30, r23, r25, false);\",                                                     \/\/ IID426\n+    \"__ eorw(r18, r18, rcx, false);\",                                                     \/\/ IID427\n+    \"__ eorw(r10, rcx, r10, false);\",                                                     \/\/ IID428\n+    \"__ eorw(r31, r21, r26, true);\",                                                      \/\/ IID429\n+    \"__ eorw(r21, r21, r19, true);\",                                                      \/\/ IID430\n@@ -3253,1 +3572,1 @@\n-    \"__ exorl(rbx, rbx, 4096, false);\",                                                   \/\/ IID362\n+    \"__ eorw(rdx, rbx, rdx, true);\",                                                      \/\/ IID431\n@@ -3255,556 +3574,573 @@\n-    \"__ exorl(r24, r30, 65536, true);\",                                                   \/\/ IID363\n-    \"__ exorl(rax, r31, 65536, true);\",                                                   \/\/ IID364\n-    \"__ exorl(r31, r31, 4096, true);\",                                                    \/\/ IID365\n-    \"__ esubl_imm32(r20, r10, 1048576, false);\",                                          \/\/ IID366\n-    \"__ esubl_imm32(rax, r13, 1048576, false);\",                                          \/\/ IID367\n-    \"__ esubl_imm32(r25, r25, 1048576, false);\",                                          \/\/ IID368\n-    \"__ esubl_imm32(r23, r12, 1073741824, true);\",                                        \/\/ IID369\n-    \"__ esubl_imm32(rax, r16, 1073741824, true);\",                                        \/\/ IID370\n-    \"__ esubl_imm32(r31, r31, 65536, true);\",                                             \/\/ IID371\n-    \"__ eaddl(r17, r13, Address(r9, +0x7fef2f98), false);\",                               \/\/ IID372\n-    \"__ eaddl(r29, r8, Address(r22, -0x4df70aac), true);\",                                \/\/ IID373\n-    \"__ eandl(r13, r17, Address(r12, r15, (Address::ScaleFactor)3, +0x50a8a902), false);\", \/\/ IID374\n-    \"__ eandl(r22, r25, Address(r26, r10, (Address::ScaleFactor)2, +0x70ea2754), true);\", \/\/ IID375\n-    \"__ eimull(r19, r12, Address(r30, r8, (Address::ScaleFactor)0, +0x6a1a0a73), false);\", \/\/ IID376\n-    \"__ eimull(r30, r18, Address(r18, r19, (Address::ScaleFactor)2, -0x7fcd28c7), true);\", \/\/ IID377\n-    \"__ eorl(r16, r31, Address(r25, r11, (Address::ScaleFactor)3, +0x482d5dbc), false);\", \/\/ IID378\n-    \"__ eorl(r9, r27, Address(r11, +0x43d5ee01), true);\",                                 \/\/ IID379\n-    \"__ esubl(rcx, r23, Address(r21, r15, (Address::ScaleFactor)2, +0x2825c2bc), false);\", \/\/ IID380\n-    \"__ esubl(r27, r22, Address(r13, r15, (Address::ScaleFactor)1, +0x771f0da7), true);\", \/\/ IID381\n-    \"__ exorl(r9, r30, Address(r9, r22, (Address::ScaleFactor)3, -0x4ad6c88e), false);\",  \/\/ IID382\n-    \"__ exorl(r11, r16, Address(rbx, r28, (Address::ScaleFactor)2, +0xb0223ee), true);\",  \/\/ IID383\n-    \"__ exorb(r15, r29, Address(r15, r28, (Address::ScaleFactor)1, -0x1f297a69), false);\", \/\/ IID384\n-    \"__ exorb(r17, r30, Address(r23, rbx, (Address::ScaleFactor)1, +0xadc7545), true);\",  \/\/ IID385\n-    \"__ exorw(r27, r9, Address(rdx, r22, (Address::ScaleFactor)2, -0x43d90f61), false);\", \/\/ IID386\n-    \"__ exorw(rbx, r22, Address(r28, r22, (Address::ScaleFactor)0, -0x7d30a0b1), true);\", \/\/ IID387\n-    \"__ eaddl(r14, r24, rcx, false);\",                                                    \/\/ IID388\n-    \"__ eaddl(r8, r8, r17, false);\",                                                      \/\/ IID389\n-    \"__ eaddl(r26, r24, r12, true);\",                                                     \/\/ IID390\n-    \"__ eaddl(r24, r24, r23, true);\",                                                     \/\/ IID391\n-    \"__ eandl(r13, r26, r31, false);\",                                                    \/\/ IID392\n-    \"__ eandl(r11, r11, r8, false);\",                                                     \/\/ IID393\n-    \"__ eandl(rcx, r19, r15, true);\",                                                     \/\/ IID394\n-    \"__ eandl(r12, r12, r12, true);\",                                                     \/\/ IID395\n-    \"__ eimull(r22, r20, r19, false);\",                                                   \/\/ IID396\n-    \"__ eimull(r8, r8, rdx, false);\",                                                     \/\/ IID397\n-    \"__ eimull(r22, r27, r23, true);\",                                                    \/\/ IID398\n-    \"__ eimull(r9, r9, r18, true);\",                                                      \/\/ IID399\n-    \"__ eorw(rcx, r30, r13, false);\",                                                     \/\/ IID400\n-    \"__ eorw(r28, r28, r19, false);\",                                                     \/\/ IID401\n-    \"__ eorw(r12, r30, r27, true);\",                                                      \/\/ IID402\n-    \"__ eorw(r8, r8, r22, true);\",                                                        \/\/ IID403\n-    \"__ eorl(r16, rcx, r30, false);\",                                                     \/\/ IID404\n-    \"__ eorl(r10, r10, r25, false);\",                                                     \/\/ IID405\n-    \"__ eorl(r15, r17, r17, true);\",                                                      \/\/ IID406\n-    \"__ eorl(r9, r9, r30, true);\",                                                        \/\/ IID407\n-    \"__ eshldl(r20, r21, r8, false);\",                                                    \/\/ IID408\n-    \"__ eshldl(r26, r26, r14, false);\",                                                   \/\/ IID409\n-    \"__ eshldl(r16, rdx, r14, true);\",                                                    \/\/ IID410\n-    \"__ eshldl(r19, r19, r8, true);\",                                                     \/\/ IID411\n-    \"__ eshrdl(r27, rbx, r26, false);\",                                                   \/\/ IID412\n-    \"__ eshrdl(r28, r28, r19, false);\",                                                   \/\/ IID413\n-    \"__ eshrdl(rcx, r11, r14, true);\",                                                    \/\/ IID414\n-    \"__ eshrdl(r31, r31, r19, true);\",                                                    \/\/ IID415\n-    \"__ esubl(r26, r13, r25, false);\",                                                    \/\/ IID416\n-    \"__ esubl(r24, r24, r11, false);\",                                                    \/\/ IID417\n-    \"__ esubl(r18, r20, r13, true);\",                                                     \/\/ IID418\n-    \"__ esubl(r16, r16, r18, true);\",                                                     \/\/ IID419\n-    \"__ exorl(r19, r17, r8, false);\",                                                     \/\/ IID420\n-    \"__ exorl(r19, r19, r13, false);\",                                                    \/\/ IID421\n-    \"__ exorl(r23, r13, r15, true);\",                                                     \/\/ IID422\n-    \"__ exorl(r11, r11, r29, true);\",                                                     \/\/ IID423\n-    \"__ eshldl(r29, r17, r17, 1, false);\",                                                \/\/ IID424\n-    \"__ eshldl(r22, r22, r24, 4, false);\",                                                \/\/ IID425\n-    \"__ eshldl(r8, r28, r11, 16, true);\",                                                 \/\/ IID426\n-    \"__ eshldl(r15, r15, r23, 4, true);\",                                                 \/\/ IID427\n-    \"__ eshrdl(r29, r22, r16, 4, false);\",                                                \/\/ IID428\n-    \"__ eshrdl(r13, r13, r9, 4, false);\",                                                 \/\/ IID429\n-    \"__ eshrdl(r15, r21, r12, 2, true);\",                                                 \/\/ IID430\n-    \"__ eshrdl(r17, r17, r23, 2, true);\",                                                 \/\/ IID431\n-    \"__ ecmovl (Assembler::Condition::overflow, rdx, r16, r29);\",                         \/\/ IID432\n-    \"__ ecmovl (Assembler::Condition::overflow, r10, r10, r21);\",                         \/\/ IID433\n-    \"__ ecmovl (Assembler::Condition::noOverflow, r17, r29, r18);\",                       \/\/ IID434\n-    \"__ ecmovl (Assembler::Condition::noOverflow, r28, r28, r24);\",                       \/\/ IID435\n-    \"__ ecmovl (Assembler::Condition::below, r10, r20, r27);\",                            \/\/ IID436\n-    \"__ ecmovl (Assembler::Condition::below, r10, r10, r14);\",                            \/\/ IID437\n-    \"__ ecmovl (Assembler::Condition::aboveEqual, r11, r27, rcx);\",                       \/\/ IID438\n-    \"__ ecmovl (Assembler::Condition::aboveEqual, r22, r22, r15);\",                       \/\/ IID439\n-    \"__ ecmovl (Assembler::Condition::zero, r31, r30, r19);\",                             \/\/ IID440\n-    \"__ ecmovl (Assembler::Condition::zero, r19, r19, r26);\",                             \/\/ IID441\n-    \"__ ecmovl (Assembler::Condition::notZero, r21, r14, r26);\",                          \/\/ IID442\n-    \"__ ecmovl (Assembler::Condition::notZero, r20, r20, r15);\",                          \/\/ IID443\n-    \"__ ecmovl (Assembler::Condition::belowEqual, r12, r13, r23);\",                       \/\/ IID444\n-    \"__ ecmovl (Assembler::Condition::belowEqual, r28, r28, r20);\",                       \/\/ IID445\n-    \"__ ecmovl (Assembler::Condition::above, r20, r24, r11);\",                            \/\/ IID446\n-    \"__ ecmovl (Assembler::Condition::above, r10, r10, r15);\",                            \/\/ IID447\n-    \"__ ecmovl (Assembler::Condition::negative, r19, r20, r23);\",                         \/\/ IID448\n-    \"__ ecmovl (Assembler::Condition::negative, r15, r15, r26);\",                         \/\/ IID449\n-    \"__ ecmovl (Assembler::Condition::positive, r19, r24, r23);\",                         \/\/ IID450\n-    \"__ ecmovl (Assembler::Condition::positive, r28, r28, r11);\",                         \/\/ IID451\n-    \"__ ecmovl (Assembler::Condition::parity, r13, r13, rdx);\",                           \/\/ IID452\n-    \"__ ecmovl (Assembler::Condition::parity, r31, r31, r23);\",                           \/\/ IID453\n-    \"__ ecmovl (Assembler::Condition::noParity, r23, r9, r27);\",                          \/\/ IID454\n-    \"__ ecmovl (Assembler::Condition::noParity, r21, r21, r20);\",                         \/\/ IID455\n-    \"__ ecmovl (Assembler::Condition::less, r24, r21, r29);\",                             \/\/ IID456\n-    \"__ ecmovl (Assembler::Condition::less, rbx, rbx, r11);\",                             \/\/ IID457\n-    \"__ ecmovl (Assembler::Condition::greaterEqual, r21, rbx, rcx);\",                     \/\/ IID458\n-    \"__ ecmovl (Assembler::Condition::greaterEqual, r31, r31, r21);\",                     \/\/ IID459\n-    \"__ ecmovl (Assembler::Condition::lessEqual, r15, r25, r30);\",                        \/\/ IID460\n-    \"__ ecmovl (Assembler::Condition::lessEqual, r23, r23, r25);\",                        \/\/ IID461\n-    \"__ ecmovl (Assembler::Condition::greater, r18, rcx, r10);\",                          \/\/ IID462\n-    \"__ ecmovl (Assembler::Condition::greater, rcx, rcx, r31);\",                          \/\/ IID463\n-    \"__ ecmovl (Assembler::Condition::overflow, r21, r19, Address(r26, -0x6e290873));\",   \/\/ IID464\n-    \"__ ecmovl (Assembler::Condition::noOverflow, r24, r19, Address(r22, rcx, (Address::ScaleFactor)0, +0x11f85f9a));\", \/\/ IID465\n-    \"__ ecmovl (Assembler::Condition::below, r17, r24, Address(r20, +0x534d775e));\",      \/\/ IID466\n-    \"__ ecmovl (Assembler::Condition::aboveEqual, r20, r18, Address(r20, -0x47c94ecd));\", \/\/ IID467\n-    \"__ ecmovl (Assembler::Condition::zero, r9, r13, Address(r23, -0x4b83c563));\",        \/\/ IID468\n-    \"__ ecmovl (Assembler::Condition::notZero, r11, r25, Address(r24, r14, (Address::ScaleFactor)1, -0x446507af));\", \/\/ IID469\n-    \"__ ecmovl (Assembler::Condition::belowEqual, r14, r24, Address(r30, r13, (Address::ScaleFactor)2, +0xd0661d));\", \/\/ IID470\n-    \"__ ecmovl (Assembler::Condition::above, r13, r25, Address(r14, r27, (Address::ScaleFactor)3, +0x47e1403));\", \/\/ IID471\n-    \"__ ecmovl (Assembler::Condition::negative, r24, r19, Address(rcx, rdx, (Address::ScaleFactor)3, -0x644a5318));\", \/\/ IID472\n-    \"__ ecmovl (Assembler::Condition::positive, r26, r24, Address(r22, r22, (Address::ScaleFactor)0, +0x70352446));\", \/\/ IID473\n-    \"__ ecmovl (Assembler::Condition::parity, r19, r26, Address(r8, r30, (Address::ScaleFactor)2, +0x78a12f5c));\", \/\/ IID474\n-    \"__ ecmovl (Assembler::Condition::noParity, r29, r11, Address(r25, r20, (Address::ScaleFactor)0, +0x27a8303a));\", \/\/ IID475\n-    \"__ ecmovl (Assembler::Condition::less, r22, r24, Address(r27, r16, (Address::ScaleFactor)1, +0x2541a10));\", \/\/ IID476\n-    \"__ ecmovl (Assembler::Condition::greaterEqual, r31, r15, Address(r8, r16, (Address::ScaleFactor)3, +0x558e3251));\", \/\/ IID477\n-    \"__ ecmovl (Assembler::Condition::lessEqual, r27, r18, Address(r8, r10, (Address::ScaleFactor)0, -0x471987b7));\", \/\/ IID478\n-    \"__ ecmovl (Assembler::Condition::greater, r18, r16, Address(r18, r19, (Address::ScaleFactor)2, -0x120ae81e));\", \/\/ IID479\n-    \"__ adcq(rbx, r31);\",                                                                 \/\/ IID480\n-    \"__ cmpq(r30, r31);\",                                                                 \/\/ IID481\n-    \"__ imulq(r29, r28);\",                                                                \/\/ IID482\n-    \"__ popcntq(r25, r10);\",                                                              \/\/ IID483\n-    \"__ sbbq(r24, r20);\",                                                                 \/\/ IID484\n-    \"__ subq(r16, rdx);\",                                                                 \/\/ IID485\n-    \"__ tzcntq(r26, r28);\",                                                               \/\/ IID486\n-    \"__ lzcntq(r28, r9);\",                                                                \/\/ IID487\n-    \"__ addq(r20, r24);\",                                                                 \/\/ IID488\n-    \"__ andq(r24, r29);\",                                                                 \/\/ IID489\n-    \"__ orq(r23, r27);\",                                                                  \/\/ IID490\n-    \"__ xorq(r15, r12);\",                                                                 \/\/ IID491\n-    \"__ movq(r18, r19);\",                                                                 \/\/ IID492\n-    \"__ bsfq(r31, rcx);\",                                                                 \/\/ IID493\n-    \"__ bsrq(r9, r13);\",                                                                  \/\/ IID494\n-    \"__ btq(r20, rcx);\",                                                                  \/\/ IID495\n-    \"__ xchgq(r8, r21);\",                                                                 \/\/ IID496\n-    \"__ testq(r24, r14);\",                                                                \/\/ IID497\n-    \"__ addq(Address(rcx, r23, (Address::ScaleFactor)2, +0x4ff06c4d), r29);\",             \/\/ IID498\n-    \"__ andq(Address(r24, r10, (Address::ScaleFactor)1, -0x75d9a189), r26);\",             \/\/ IID499\n-    \"__ cmpq(Address(rbx, rbx, (Address::ScaleFactor)0, +0x4033d59c), r17);\",             \/\/ IID500\n-    \"__ orq(Address(r22, r12, (Address::ScaleFactor)3, -0x3893347d), r18);\",              \/\/ IID501\n-    \"__ xorq(Address(r20, r23, (Address::ScaleFactor)3, +0x4b311560), r12);\",             \/\/ IID502\n-    \"__ subq(Address(r10, r28, (Address::ScaleFactor)2, +0x5c3a2657), r29);\",             \/\/ IID503\n-    \"__ movq(Address(r13, r25, (Address::ScaleFactor)3, +0x1a3d6f3f), r22);\",             \/\/ IID504\n-    \"__ xaddq(Address(r17, r24, (Address::ScaleFactor)3, -0x35addbd8), r25);\",            \/\/ IID505\n-    \"__ andq(Address(r25, +0x632184c3), 16777216);\",                                      \/\/ IID506\n-    \"__ addq(Address(r13, r13, (Address::ScaleFactor)0, -0x3972eac6), 16777216);\",        \/\/ IID507\n-    \"__ cmpq(Address(r9, -0x13b4c806), 4096);\",                                           \/\/ IID508\n-    \"__ sarq(Address(r31, +0x4fa7f551), 1);\",                                             \/\/ IID509\n-    \"__ salq(Address(r21, r31, (Address::ScaleFactor)2, +0x31aa8232), 1);\",               \/\/ IID510\n-    \"__ sbbq(Address(r24, r31, (Address::ScaleFactor)2, -0x466538b7), 268435456);\",       \/\/ IID511\n-    \"__ shrq(Address(r28, r22, (Address::ScaleFactor)0, -0x3efe85b1), 2);\",               \/\/ IID512\n-    \"__ subq(Address(r16, -0x1389a3eb), 1048576);\",                                       \/\/ IID513\n-    \"__ xorq(Address(r29, r8, (Address::ScaleFactor)0, +0x1d022615), 16);\",               \/\/ IID514\n-    \"__ orq(Address(r12, r28, (Address::ScaleFactor)1, -0x34c898e2), 1);\",                \/\/ IID515\n-    \"__ movq(Address(rcx, r24, (Address::ScaleFactor)2, -0x1644eb08), 256);\",             \/\/ IID516\n-    \"__ testq(Address(r29, -0x7d23890b), -65536);\",                                       \/\/ IID517\n-    \"__ addq(r23, Address(rcx, r19, (Address::ScaleFactor)2, +0x70eac654));\",             \/\/ IID518\n-    \"__ andq(rdx, Address(r24, r15, (Address::ScaleFactor)0, -0x204ddaa9));\",             \/\/ IID519\n-    \"__ cmpq(rdx, Address(r23, r11, (Address::ScaleFactor)3, +0x32c930bd));\",             \/\/ IID520\n-    \"__ lzcntq(r28, Address(rdx, -0x5433c28f));\",                                         \/\/ IID521\n-    \"__ orq(r22, Address(r19, r14, (Address::ScaleFactor)1, -0x2cc67d38));\",              \/\/ IID522\n-    \"__ adcq(r10, Address(r10, +0x3d7c59f));\",                                            \/\/ IID523\n-    \"__ imulq(r10, Address(r8, r8, (Address::ScaleFactor)3, -0xe61862d));\",               \/\/ IID524\n-    \"__ popcntq(r23, Address(r29, -0x777ed96d));\",                                        \/\/ IID525\n-    \"__ sbbq(rcx, Address(rbx, r19, (Address::ScaleFactor)1, +0x53c601cb));\",             \/\/ IID526\n-    \"__ subq(r14, Address(r17, rbx, (Address::ScaleFactor)0, -0x768bf073));\",             \/\/ IID527\n-    \"__ tzcntq(r29, Address(r10, r19, (Address::ScaleFactor)1, +0x30c98d3c));\",           \/\/ IID528\n-    \"__ xorq(r10, Address(r16, r27, (Address::ScaleFactor)0, -0x3d08d602));\",             \/\/ IID529\n-    \"__ movq(r18, Address(r28, r28, (Address::ScaleFactor)3, -0x62fbac91));\",             \/\/ IID530\n-    \"__ leaq(rbx, Address(rcx, +0x450602a5));\",                                           \/\/ IID531\n-    \"__ cvttsd2siq(r12, Address(r30, r31, (Address::ScaleFactor)0, -0x6798a630));\",       \/\/ IID532\n-    \"__ xchgq(r31, Address(r24, r10, (Address::ScaleFactor)1, -0x706712ed));\",            \/\/ IID533\n-    \"__ testq(r14, Address(r13, r20, (Address::ScaleFactor)3, +0x171081f2));\",            \/\/ IID534\n-    \"__ addq(r31, 16);\",                                                                  \/\/ IID535\n-    \"__ andq(r25, 16);\",                                                                  \/\/ IID536\n-    \"__ adcq(r23, 256);\",                                                                 \/\/ IID537\n-    \"__ cmpq(r19, 268435456);\",                                                           \/\/ IID538\n-    \"__ rclq(r31, 1);\",                                                                   \/\/ IID539\n-    \"__ rcrq(r17, 1);\",                                                                   \/\/ IID540\n-    \"__ rolq(r25, 2);\",                                                                   \/\/ IID541\n-    \"__ rorq(r17, 4);\",                                                                   \/\/ IID542\n-    \"__ sarq(r28, 1);\",                                                                   \/\/ IID543\n-    \"__ salq(r15, 4);\",                                                                   \/\/ IID544\n-    \"__ sbbq(rbx, 65536);\",                                                               \/\/ IID545\n-    \"__ shlq(r21, 1);\",                                                                   \/\/ IID546\n-    \"__ shrq(r10, 1);\",                                                                   \/\/ IID547\n-    \"__ subq(r14, 16);\",                                                                  \/\/ IID548\n-    \"__ xorq(r18, 268435456);\",                                                           \/\/ IID549\n-    \"__ movq(r23, 16);\",                                                                  \/\/ IID550\n-    \"__ mov64(r12, 1099511627776);\",                                                      \/\/ IID551\n-    \"__ btq(r14, 4);\",                                                                    \/\/ IID552\n-    \"__ testq(r24, -4096);\",                                                              \/\/ IID553\n-    \"__ orq_imm32(r19, 1048576);\",                                                        \/\/ IID554\n-    \"__ subq_imm32(rcx, 268435456);\",                                                     \/\/ IID555\n-    \"__ cmovq(Assembler::Condition::overflow, rdx, Address(r19, rbx, (Address::ScaleFactor)3, +0x211c8c4));\", \/\/ IID556\n-    \"__ cmovq(Assembler::Condition::noOverflow, rbx, Address(r21, +0x49267743));\",        \/\/ IID557\n-    \"__ cmovq(Assembler::Condition::below, r21, Address(r8, r28, (Address::ScaleFactor)1, -0x4c8c2946));\", \/\/ IID558\n-    \"__ cmovq(Assembler::Condition::aboveEqual, r12, Address(r26, r20, (Address::ScaleFactor)0, -0x264df89c));\", \/\/ IID559\n-    \"__ cmovq(Assembler::Condition::zero, r17, Address(r28, r9, (Address::ScaleFactor)2, +0x3497196b));\", \/\/ IID560\n-    \"__ cmovq(Assembler::Condition::notZero, r13, Address(r15, r23, (Address::ScaleFactor)1, -0x27a30999));\", \/\/ IID561\n-    \"__ cmovq(Assembler::Condition::belowEqual, r22, Address(r22, +0xf39ab05));\",         \/\/ IID562\n-    \"__ cmovq(Assembler::Condition::above, rcx, Address(r22, r26, (Address::ScaleFactor)3, -0x48c954c));\", \/\/ IID563\n-    \"__ cmovq(Assembler::Condition::negative, r25, Address(r19, r21, (Address::ScaleFactor)0, +0xe405b0b));\", \/\/ IID564\n-    \"__ cmovq(Assembler::Condition::positive, r12, Address(r19, r29, (Address::ScaleFactor)3, -0x7762044b));\", \/\/ IID565\n-    \"__ cmovq(Assembler::Condition::parity, rbx, Address(r30, r10, (Address::ScaleFactor)1, -0x19798323));\", \/\/ IID566\n-    \"__ cmovq(Assembler::Condition::noParity, r21, Address(r24, r31, (Address::ScaleFactor)0, -0x5731652b));\", \/\/ IID567\n-    \"__ cmovq(Assembler::Condition::less, r18, Address(r8, r10, (Address::ScaleFactor)1, -0x5613be89));\", \/\/ IID568\n-    \"__ cmovq(Assembler::Condition::greaterEqual, r28, Address(r21, r21, (Address::ScaleFactor)3, +0x65a0fdc4));\", \/\/ IID569\n-    \"__ cmovq(Assembler::Condition::lessEqual, r23, Address(r11, r18, (Address::ScaleFactor)0, -0x1d1af10c));\", \/\/ IID570\n-    \"__ cmovq(Assembler::Condition::greater, r22, Address(r18, r12, (Address::ScaleFactor)1, +0x1a5f1c38));\", \/\/ IID571\n-    \"__ call(r23);\",                                                                      \/\/ IID572\n-    \"__ divq(r30);\",                                                                      \/\/ IID573\n-    \"__ idivq(r19);\",                                                                     \/\/ IID574\n-    \"__ imulq(r9);\",                                                                      \/\/ IID575\n-    \"__ mulq(r13);\",                                                                      \/\/ IID576\n-    \"__ negq(r16);\",                                                                      \/\/ IID577\n-    \"__ notq(r29);\",                                                                      \/\/ IID578\n-    \"__ rolq(rcx);\",                                                                      \/\/ IID579\n-    \"__ rorq(r25);\",                                                                      \/\/ IID580\n-    \"__ sarq(r8);\",                                                                       \/\/ IID581\n-    \"__ salq(r27);\",                                                                      \/\/ IID582\n-    \"__ shlq(r30);\",                                                                      \/\/ IID583\n-    \"__ shrq(r23);\",                                                                      \/\/ IID584\n-    \"__ incrementq(rbx);\",                                                                \/\/ IID585\n-    \"__ decrementq(r14);\",                                                                \/\/ IID586\n-    \"__ pushp(r21);\",                                                                     \/\/ IID587\n-    \"__ popp(r21);\",                                                                      \/\/ IID588\n-    \"__ call(Address(r20, r21, (Address::ScaleFactor)1, +0x56c6af2f));\",                  \/\/ IID589\n-    \"__ mulq(Address(r31, r19, (Address::ScaleFactor)3, -0x1b4eb23));\",                   \/\/ IID590\n-    \"__ negq(Address(r27, r27, (Address::ScaleFactor)0, -0x58dbfc1f));\",                  \/\/ IID591\n-    \"__ sarq(Address(rbx, r22, (Address::ScaleFactor)2, -0x606349d1));\",                  \/\/ IID592\n-    \"__ salq(Address(r26, r23, (Address::ScaleFactor)3, +0xb95a079));\",                   \/\/ IID593\n-    \"__ shrq(Address(r14, r26, (Address::ScaleFactor)0, +0x3544e09));\",                   \/\/ IID594\n-    \"__ incrementq(Address(r27, rdx, (Address::ScaleFactor)0, +0x120b3250));\",            \/\/ IID595\n-    \"__ decrementq(Address(r9, r25, (Address::ScaleFactor)2, -0x34aaeccb));\",             \/\/ IID596\n-    \"__ imulq(r20, Address(r16, r28, (Address::ScaleFactor)1, -0x59de05a5), 1048576);\",   \/\/ IID597\n-    \"__ imulq(r17, r23, 256);\",                                                           \/\/ IID598\n-    \"__ shldq(r19, r11, 8);\",                                                             \/\/ IID599\n-    \"__ shrdq(r28, r10, 8);\",                                                             \/\/ IID600\n-    \"__ pop2(r29, r26);\",                                                                 \/\/ IID601\n-    \"__ pop2p(r22, r10);\",                                                                \/\/ IID602\n-    \"__ push2(r25, r30);\",                                                                \/\/ IID603\n-    \"__ push2p(r28, r15);\",                                                               \/\/ IID604\n-    \"__ movzbq(r11, Address(r29, r19, (Address::ScaleFactor)2, -0x12368d34));\",           \/\/ IID605\n-    \"__ movzwq(r14, Address(r8, r30, (Address::ScaleFactor)2, -0x4a9392de));\",            \/\/ IID606\n-    \"__ movsbq(r28, Address(r23, r15, (Address::ScaleFactor)0, +0x6189cb54));\",           \/\/ IID607\n-    \"__ movswq(r28, Address(rbx, r23, (Address::ScaleFactor)3, -0x2de86561));\",           \/\/ IID608\n-    \"__ movzbq(r11, rcx);\",                                                               \/\/ IID609\n-    \"__ movzwq(r30, r15);\",                                                               \/\/ IID610\n-    \"__ movsbq(r14, rcx);\",                                                               \/\/ IID611\n-    \"__ movswq(r23, r9);\",                                                                \/\/ IID612\n-    \"__ cmpxchgq(r12, Address(r13, r10, (Address::ScaleFactor)1, -0x7c62c3a));\",          \/\/ IID613\n-    \"__ eidivq(rcx, false);\",                                                             \/\/ IID614\n-    \"__ eidivq(r15, true);\",                                                              \/\/ IID615\n-    \"__ edivq(r23, false);\",                                                              \/\/ IID616\n-    \"__ edivq(r24, true);\",                                                               \/\/ IID617\n-    \"__ eimulq(r27, false);\",                                                             \/\/ IID618\n-    \"__ eimulq(r30, true);\",                                                              \/\/ IID619\n-    \"__ emulq(r12, false);\",                                                              \/\/ IID620\n-    \"__ emulq(rcx, true);\",                                                               \/\/ IID621\n-    \"__ emulq(Address(r13, r9, (Address::ScaleFactor)3, -0x226aab94), false);\",           \/\/ IID622\n-    \"__ emulq(Address(r13, r24, (Address::ScaleFactor)3, -0x286c7605), true);\",           \/\/ IID623\n-    \"__ eimulq(r21, r30, false);\",                                                        \/\/ IID624\n-    \"__ eimulq(r17, r17, false);\",                                                        \/\/ IID625\n-    \"__ eimulq(r29, r12, true);\",                                                         \/\/ IID626\n-    \"__ eimulq(r30, r30, true);\",                                                         \/\/ IID627\n-    \"__ elzcntq(r24, r15, false);\",                                                       \/\/ IID628\n-    \"__ elzcntq(r25, r25, false);\",                                                       \/\/ IID629\n-    \"__ elzcntq(r25, r21, true);\",                                                        \/\/ IID630\n-    \"__ elzcntq(r22, r22, true);\",                                                        \/\/ IID631\n-    \"__ enegq(r17, r30, false);\",                                                         \/\/ IID632\n-    \"__ enegq(r17, r17, false);\",                                                         \/\/ IID633\n-    \"__ enegq(r31, r17, true);\",                                                          \/\/ IID634\n-    \"__ enegq(r29, r29, true);\",                                                          \/\/ IID635\n-    \"__ enotq(r10, r9);\",                                                                 \/\/ IID636\n-    \"__ enotq(r24, r24);\",                                                                \/\/ IID637\n-    \"__ epopcntq(r28, r15, false);\",                                                      \/\/ IID638\n-    \"__ epopcntq(r10, r10, false);\",                                                      \/\/ IID639\n-    \"__ epopcntq(r27, r30, true);\",                                                       \/\/ IID640\n-    \"__ epopcntq(r28, r28, true);\",                                                       \/\/ IID641\n-    \"__ erolq(r28, r14, false);\",                                                         \/\/ IID642\n-    \"__ erolq(r23, r23, false);\",                                                         \/\/ IID643\n-    \"__ erolq(r23, r24, true);\",                                                          \/\/ IID644\n-    \"__ erolq(r21, r21, true);\",                                                          \/\/ IID645\n-    \"__ erorq(r31, r22, false);\",                                                         \/\/ IID646\n-    \"__ erorq(r28, r28, false);\",                                                         \/\/ IID647\n-    \"__ erorq(r17, r10, true);\",                                                          \/\/ IID648\n-    \"__ erorq(r9, r9, true);\",                                                            \/\/ IID649\n-    \"__ esalq(r29, r30, false);\",                                                         \/\/ IID650\n-    \"__ esalq(r11, r11, false);\",                                                         \/\/ IID651\n-    \"__ esalq(r26, r11, true);\",                                                          \/\/ IID652\n-    \"__ esalq(r16, r16, true);\",                                                          \/\/ IID653\n-    \"__ esarq(rbx, r15, false);\",                                                         \/\/ IID654\n-    \"__ esarq(r14, r14, false);\",                                                         \/\/ IID655\n-    \"__ esarq(r25, r16, true);\",                                                          \/\/ IID656\n-    \"__ esarq(r8, r8, true);\",                                                            \/\/ IID657\n-    \"__ edecq(r11, r13, false);\",                                                         \/\/ IID658\n-    \"__ edecq(rcx, rcx, false);\",                                                         \/\/ IID659\n-    \"__ edecq(r21, r18, true);\",                                                          \/\/ IID660\n-    \"__ edecq(r28, r28, true);\",                                                          \/\/ IID661\n-    \"__ eincq(r16, r16, false);\",                                                         \/\/ IID662\n-    \"__ eincq(r29, r29, false);\",                                                         \/\/ IID663\n-    \"__ eincq(r18, r9, true);\",                                                           \/\/ IID664\n-    \"__ eincq(r19, r19, true);\",                                                          \/\/ IID665\n-    \"__ eshlq(r19, r18, false);\",                                                         \/\/ IID666\n-    \"__ eshlq(r8, r8, false);\",                                                           \/\/ IID667\n-    \"__ eshlq(r12, r15, true);\",                                                          \/\/ IID668\n-    \"__ eshlq(r29, r29, true);\",                                                          \/\/ IID669\n-    \"__ eshrq(r28, r24, false);\",                                                         \/\/ IID670\n-    \"__ eshrq(r19, r19, false);\",                                                         \/\/ IID671\n-    \"__ eshrq(r8, r28, true);\",                                                           \/\/ IID672\n-    \"__ eshrq(r17, r17, true);\",                                                          \/\/ IID673\n-    \"__ etzcntq(r28, r16, false);\",                                                       \/\/ IID674\n-    \"__ etzcntq(r14, r14, false);\",                                                       \/\/ IID675\n-    \"__ etzcntq(r12, r31, true);\",                                                        \/\/ IID676\n-    \"__ etzcntq(r14, r14, true);\",                                                        \/\/ IID677\n-    \"__ eimulq(r31, Address(r13, -0x69c4b352), false);\",                                  \/\/ IID678\n-    \"__ eimulq(r17, Address(r18, -0x60ab1105), true);\",                                   \/\/ IID679\n-    \"__ elzcntq(r27, Address(r14, r25, (Address::ScaleFactor)2, +0x2798bf83), false);\",   \/\/ IID680\n-    \"__ elzcntq(r23, Address(r10, r11, (Address::ScaleFactor)0, -0x378e635d), true);\",    \/\/ IID681\n-    \"__ enegq(rcx, Address(r19, r9, (Address::ScaleFactor)3, -0x6847d440), false);\",      \/\/ IID682\n-    \"__ enegq(rcx, Address(rbx, rcx, (Address::ScaleFactor)0, +0x6f92d38d), true);\",      \/\/ IID683\n-    \"__ epopcntq(r20, Address(r12, -0x2a8b27d6), false);\",                                \/\/ IID684\n-    \"__ epopcntq(r31, Address(r30, +0x4603f6d0), true);\",                                 \/\/ IID685\n-    \"__ esalq(rbx, Address(r24, +0x567d06f9), false);\",                                   \/\/ IID686\n-    \"__ esalq(r12, Address(r24, r28, (Address::ScaleFactor)0, -0x1c4c584e), true);\",      \/\/ IID687\n-    \"__ esarq(r12, Address(r23, r24, (Address::ScaleFactor)2, -0x3157bcba), false);\",     \/\/ IID688\n-    \"__ esarq(r8, Address(r14, r24, (Address::ScaleFactor)2, -0x714290a5), true);\",       \/\/ IID689\n-    \"__ edecq(r23, Address(r8, r15, (Address::ScaleFactor)1, -0x5ae272dd), false);\",      \/\/ IID690\n-    \"__ edecq(r13, Address(r29, r9, (Address::ScaleFactor)3, -0x5b5174a9), true);\",       \/\/ IID691\n-    \"__ eincq(r11, Address(r21, r31, (Address::ScaleFactor)3, -0x2176b4dc), false);\",     \/\/ IID692\n-    \"__ eincq(r13, Address(rcx, r16, (Address::ScaleFactor)0, -0x36b448c9), true);\",      \/\/ IID693\n-    \"__ eshrq(r26, Address(r25, rcx, (Address::ScaleFactor)2, -0x5f894993), false);\",     \/\/ IID694\n-    \"__ eshrq(r25, Address(r9, +0x51798d21), true);\",                                     \/\/ IID695\n-    \"__ etzcntq(r28, Address(r13, r26, (Address::ScaleFactor)2, +0x207196f6), false);\",   \/\/ IID696\n-    \"__ etzcntq(rbx, Address(r19, r13, (Address::ScaleFactor)0, -0x24d937d5), true);\",    \/\/ IID697\n-    \"__ eaddq(r17, Address(r30, +0x3935ccff), r31, false);\",                              \/\/ IID698\n-    \"__ eaddq(r14, Address(r27, r10, (Address::ScaleFactor)2, -0x34ad9bab), r14, false);\", \/\/ IID699\n-    \"__ eaddq(r18, Address(r20, r23, (Address::ScaleFactor)0, +0x5ad3ed4b), r30, true);\", \/\/ IID700\n-    \"__ eaddq(r20, Address(rdx, -0x322a99e5), r20, true);\",                               \/\/ IID701\n-    \"__ eandq(r31, Address(rbx, r27, (Address::ScaleFactor)3, +0x4ce247d2), r17, false);\", \/\/ IID702\n-    \"__ eandq(r30, Address(r18, r19, (Address::ScaleFactor)1, -0x4ee3d14), r30, false);\", \/\/ IID703\n-    \"__ eandq(r28, Address(r11, rbx, (Address::ScaleFactor)3, -0x28994bbf), r24, true);\", \/\/ IID704\n-    \"__ eandq(r30, Address(r22, +0x7d21c24), r30, true);\",                                \/\/ IID705\n-    \"__ eorq(r26, Address(r15, r19, (Address::ScaleFactor)3, +0x58c21792), r20, false);\", \/\/ IID706\n-    \"__ eorq(r13, Address(r10, r27, (Address::ScaleFactor)2, -0x2c70d333), r13, false);\", \/\/ IID707\n-    \"__ eorq(rbx, Address(r12, rbx, (Address::ScaleFactor)0, -0x1fb0f1bc), r26, true);\",  \/\/ IID708\n-    \"__ eorq(r31, Address(r27, r31, (Address::ScaleFactor)1, +0x28d1756), r31, true);\",   \/\/ IID709\n-    \"__ esubq(r24, Address(r28, r23, (Address::ScaleFactor)1, +0x6980f610), r27, false);\", \/\/ IID710\n-    \"__ esubq(r15, Address(r11, r30, (Address::ScaleFactor)3, -0x49777e7), r15, false);\", \/\/ IID711\n-    \"__ esubq(r17, Address(r25, r13, (Address::ScaleFactor)2, +0x31619e46), r31, true);\", \/\/ IID712\n-    \"__ esubq(r18, Address(r11, r10, (Address::ScaleFactor)2, +0x1922861a), r18, true);\", \/\/ IID713\n-    \"__ exorq(rbx, Address(r11, -0x4716d420), r21, false);\",                              \/\/ IID714\n-    \"__ exorq(r8, Address(rdx, r9, (Address::ScaleFactor)2, -0x4cfe39c), r8, false);\",    \/\/ IID715\n-    \"__ exorq(r16, Address(r14, r27, (Address::ScaleFactor)0, +0x7c6654d9), r25, true);\", \/\/ IID716\n-    \"__ exorq(r29, Address(r15, -0x5efab479), r29, true);\",                               \/\/ IID717\n-    \"__ eaddq(r19, Address(r13, r22, (Address::ScaleFactor)2, +0x68b64559), 16777216, false);\", \/\/ IID718\n-    \"__ eaddq(r16, Address(r13, r31, (Address::ScaleFactor)3, -0x65143af5), 1, true);\",   \/\/ IID719\n-    \"__ eandq(r31, Address(r24, r13, (Address::ScaleFactor)1, -0x25b16a0e), 1, false);\",  \/\/ IID720\n-    \"__ eandq(r11, Address(r28, -0xf6d4b26), 65536, true);\",                              \/\/ IID721\n-    \"__ eimulq(rcx, Address(r18, r10, (Address::ScaleFactor)0, +0x46ec6da1), 16777216, false);\", \/\/ IID722\n-    \"__ eimulq(r15, Address(r9, r10, (Address::ScaleFactor)3, -0x7fc36af3), 16, true);\",  \/\/ IID723\n-    \"__ eorq(r17, Address(r27, r30, (Address::ScaleFactor)0, +0x1b4cda2c), 1, false);\",   \/\/ IID724\n-    \"__ eorq(rdx, Address(r25, r14, (Address::ScaleFactor)2, -0x59aa6b85), 4096, true);\", \/\/ IID725\n-    \"__ esalq(r17, Address(r26, r21, (Address::ScaleFactor)1, -0x6ab1f15f), 8, false);\",  \/\/ IID726\n-    \"__ esalq(r12, Address(r22, r17, (Address::ScaleFactor)0, -0x43ac14ab), 2, true);\",   \/\/ IID727\n-    \"__ esarq(r29, Address(r18, r16, (Address::ScaleFactor)0, -0x59dc0c61), 4, false);\",  \/\/ IID728\n-    \"__ esarq(r16, Address(r11, -0x7bdd314), 4, true);\",                                  \/\/ IID729\n-    \"__ eshrq(r26, Address(r23, r27, (Address::ScaleFactor)3, -0x55b92314), 16, false);\", \/\/ IID730\n-    \"__ eshrq(r23, Address(r16, r29, (Address::ScaleFactor)1, +0x71311a1d), 2, true);\",   \/\/ IID731\n-    \"__ esubq(r25, Address(r9, -0x9532bac), 1048576, false);\",                            \/\/ IID732\n-    \"__ esubq(r17, Address(r8, r23, (Address::ScaleFactor)0, +0x55d06ca2), 1048576, true);\", \/\/ IID733\n-    \"__ exorq(r29, Address(r9, r24, (Address::ScaleFactor)0, -0x2c141c1), 1048576, false);\", \/\/ IID734\n-    \"__ exorq(r28, Address(r22, r19, (Address::ScaleFactor)1, -0x2d9d9abd), 16, true);\",  \/\/ IID735\n-    \"__ eaddq(r22, r14, 16, false);\",                                                     \/\/ IID736\n-    \"__ eaddq(rax, r12, 16, false);\",                                                     \/\/ IID737\n-    \"__ eaddq(r24, r24, 65536, false);\",                                                  \/\/ IID738\n-    \"__ eaddq(r21, rbx, 65536, true);\",                                                   \/\/ IID739\n-    \"__ eaddq(rax, rbx, 65536, true);\",                                                   \/\/ IID740\n-    \"__ eaddq(r24, r24, 65536, true);\",                                                   \/\/ IID741\n-    \"__ eandq(r21, r27, 16777216, false);\",                                               \/\/ IID742\n-    \"__ eandq(rax, r27, 16777216, false);\",                                               \/\/ IID743\n-    \"__ eandq(r24, r24, 65536, false);\",                                                  \/\/ IID744\n-    \"__ eandq(r13, r31, 1048576, true);\",                                                 \/\/ IID745\n-    \"__ eandq(rax, r21, 1048576, true);\",                                                 \/\/ IID746\n-    \"__ eandq(r30, r30, 1048576, true);\",                                                 \/\/ IID747\n-    \"__ eimulq(r8, r13, 268435456, false);\",                                              \/\/ IID748\n-    \"__ eimulq(rax, r31, 268435456, false);\",                                             \/\/ IID749\n-    \"__ eimulq(r13, r13, 65536, false);\",                                                 \/\/ IID750\n-    \"__ eimulq(r14, r29, 1048576, true);\",                                                \/\/ IID751\n-    \"__ eimulq(rax, r22, 1048576, true);\",                                                \/\/ IID752\n-    \"__ eimulq(r8, r8, 268435456, true);\",                                                \/\/ IID753\n-    \"__ eorq(r30, r15, 4096, false);\",                                                    \/\/ IID754\n-    \"__ eorq(rax, r28, 4096, false);\",                                                    \/\/ IID755\n-    \"__ eorq(r26, r26, 1048576, false);\",                                                 \/\/ IID756\n-    \"__ eorq(r16, r12, 268435456, true);\",                                                \/\/ IID757\n-    \"__ eorq(rax, r9, 268435456, true);\",                                                 \/\/ IID758\n-    \"__ eorq(r23, r23, 256, true);\",                                                      \/\/ IID759\n-    \"__ erclq(r15, r9, 16);\",                                                             \/\/ IID760\n-    \"__ erclq(rax, r8, 16);\",                                                             \/\/ IID761\n-    \"__ erclq(r25, r25, 1);\",                                                             \/\/ IID762\n-    \"__ erolq(r9, r17, 16, false);\",                                                      \/\/ IID763\n-    \"__ erolq(rax, r20, 16, false);\",                                                     \/\/ IID764\n-    \"__ erolq(r27, r27, 1, false);\",                                                      \/\/ IID765\n-    \"__ erolq(r20, r31, 1, true);\",                                                       \/\/ IID766\n-    \"__ erolq(rax, r18, 1, true);\",                                                       \/\/ IID767\n-    \"__ erolq(r28, r28, 16, true);\",                                                      \/\/ IID768\n-    \"__ erorq(r26, r18, 16, false);\",                                                     \/\/ IID769\n-    \"__ erorq(rax, r24, 16, false);\",                                                     \/\/ IID770\n-    \"__ erorq(r22, r22, 16, false);\",                                                     \/\/ IID771\n-    \"__ erorq(r27, r29, 1, true);\",                                                       \/\/ IID772\n-    \"__ erorq(rax, r18, 1, true);\",                                                       \/\/ IID773\n-    \"__ erorq(r21, r21, 1, true);\",                                                       \/\/ IID774\n-    \"__ esalq(r12, rcx, 2, false);\",                                                      \/\/ IID775\n-    \"__ esalq(rax, r24, 2, false);\",                                                      \/\/ IID776\n-    \"__ esalq(r22, r22, 8, false);\",                                                      \/\/ IID777\n-    \"__ esalq(r17, r23, 8, true);\",                                                       \/\/ IID778\n-    \"__ esalq(rax, r27, 8, true);\",                                                       \/\/ IID779\n-    \"__ esalq(r23, r23, 1, true);\",                                                       \/\/ IID780\n-    \"__ esarq(r8, r25, 16, false);\",                                                      \/\/ IID781\n-    \"__ esarq(rax, r23, 16, false);\",                                                     \/\/ IID782\n-    \"__ esarq(r9, r9, 4, false);\",                                                        \/\/ IID783\n-    \"__ esarq(r22, r13, 1, true);\",                                                       \/\/ IID784\n-    \"__ esarq(rax, r11, 1, true);\",                                                       \/\/ IID785\n-    \"__ esarq(r12, r12, 2, true);\",                                                       \/\/ IID786\n-    \"__ eshlq(rcx, r30, 8, false);\",                                                      \/\/ IID787\n-    \"__ eshlq(rax, r19, 8, false);\",                                                      \/\/ IID788\n-    \"__ eshlq(r13, r13, 2, false);\",                                                      \/\/ IID789\n-    \"__ eshlq(r18, r11, 8, true);\",                                                       \/\/ IID790\n-    \"__ eshlq(rax, r9, 8, true);\",                                                        \/\/ IID791\n-    \"__ eshlq(rcx, rcx, 16, true);\",                                                      \/\/ IID792\n-    \"__ eshrq(r10, r22, 4, false);\",                                                      \/\/ IID793\n-    \"__ eshrq(rax, r9, 4, false);\",                                                       \/\/ IID794\n-    \"__ eshrq(r12, r12, 2, false);\",                                                      \/\/ IID795\n-    \"__ eshrq(r26, r31, 8, true);\",                                                       \/\/ IID796\n-    \"__ eshrq(rax, r12, 8, true);\",                                                       \/\/ IID797\n-    \"__ eshrq(r28, r28, 1, true);\",                                                       \/\/ IID798\n-    \"__ esubq(r15, r30, 65536, false);\",                                                  \/\/ IID799\n-    \"__ esubq(rax, rcx, 65536, false);\",                                                  \/\/ IID800\n-    \"__ esubq(r26, r26, 16, false);\",                                                     \/\/ IID801\n-    \"__ esubq(r12, r14, 1, true);\",                                                       \/\/ IID802\n-    \"__ esubq(rax, r21, 1, true);\",                                                       \/\/ IID803\n-    \"__ esubq(r20, r20, 1048576, true);\",                                                 \/\/ IID804\n-    \"__ exorq(r11, rbx, 16777216, false);\",                                               \/\/ IID805\n-    \"__ exorq(rax, r23, 16777216, false);\",                                               \/\/ IID806\n-    \"__ exorq(r31, r31, 268435456, false);\",                                              \/\/ IID807\n-    \"__ exorq(r29, r28, 4096, true);\",                                                    \/\/ IID808\n-    \"__ exorq(rax, r19, 4096, true);\",                                                    \/\/ IID809\n-    \"__ exorq(rdx, rdx, 268435456, true);\",                                               \/\/ IID810\n-    \"__ eorq_imm32(rdx, rdx, 1048576, false);\",                                           \/\/ IID811\n-    \"__ eorq_imm32(rax, r22, 1048576, false);\",                                           \/\/ IID812\n-    \"__ eorq_imm32(r29, r29, 1048576, false);\",                                           \/\/ IID813\n-    \"__ eorq_imm32(r17, rcx, 4194304, false);\",                                           \/\/ IID814\n-    \"__ eorq_imm32(rax, r25, 4194304, false);\",                                           \/\/ IID815\n-    \"__ eorq_imm32(r27, r27, 1073741824, false);\",                                        \/\/ IID816\n-    \"__ esubq_imm32(r16, r19, 4194304, false);\",                                          \/\/ IID817\n-    \"__ esubq_imm32(rax, r31, 4194304, false);\",                                          \/\/ IID818\n-    \"__ esubq_imm32(r26, r26, 262144, false);\",                                           \/\/ IID819\n-    \"__ esubq_imm32(r17, r22, 1073741824, true);\",                                        \/\/ IID820\n-    \"__ esubq_imm32(rax, r18, 1073741824, true);\",                                        \/\/ IID821\n-    \"__ esubq_imm32(r23, r23, 268435456, true);\",                                         \/\/ IID822\n-    \"__ eaddq(r13, r30, Address(r24, r19, (Address::ScaleFactor)1, +0x56ea3a3b), false);\", \/\/ IID823\n-    \"__ eaddq(r29, r15, Address(r26, r27, (Address::ScaleFactor)3, -0x4b113958), true);\", \/\/ IID824\n-    \"__ eandq(r12, r30, Address(r31, -0x46103c74), false);\",                              \/\/ IID825\n-    \"__ eandq(r27, r10, Address(r22, r25, (Address::ScaleFactor)1, +0x6a1ebee5), true);\", \/\/ IID826\n-    \"__ eorq(r30, r26, Address(r11, r18, (Address::ScaleFactor)2, -0x2b9fff29), false);\", \/\/ IID827\n-    \"__ eorq(r9, r12, Address(r18, r17, (Address::ScaleFactor)0, +0xb4859f6), true);\",    \/\/ IID828\n-    \"__ eimulq(rdx, r17, Address(r24, rdx, (Address::ScaleFactor)2, +0x3d284cd8), false);\", \/\/ IID829\n-    \"__ eimulq(r29, r26, Address(r30, r12, (Address::ScaleFactor)1, +0x6e813124), true);\", \/\/ IID830\n-    \"__ esubq(rbx, r13, Address(r22, -0x702a289e), false);\",                              \/\/ IID831\n-    \"__ esubq(r23, r29, Address(r25, rdx, (Address::ScaleFactor)0, -0x6252a7ed), true);\", \/\/ IID832\n-    \"__ exorq(r8, r18, Address(r19, r14, (Address::ScaleFactor)2, -0xebfa697), false);\",  \/\/ IID833\n-    \"__ exorq(r10, r28, Address(r26, +0x168381ca), true);\",                               \/\/ IID834\n-    \"__ eaddq(rcx, r18, r8, false);\",                                                     \/\/ IID835\n-    \"__ eaddq(rcx, rcx, r14, false);\",                                                    \/\/ IID836\n-    \"__ eaddq(r23, r10, r16, true);\",                                                     \/\/ IID837\n-    \"__ eaddq(r11, r11, r24, true);\",                                                     \/\/ IID838\n-    \"__ eadcxq(r9, r18, rdx);\",                                                           \/\/ IID839\n-    \"__ eadcxq(r8, r8, r15);\",                                                            \/\/ IID840\n-    \"__ eadoxq(r15, r22, r26);\",                                                          \/\/ IID841\n-    \"__ eadoxq(r11, r11, rdx);\",                                                          \/\/ IID842\n-    \"__ eandq(r19, rdx, r22, false);\",                                                    \/\/ IID843\n-    \"__ eandq(r29, r29, r17, false);\",                                                    \/\/ IID844\n-    \"__ eandq(r23, r27, r15, true);\",                                                     \/\/ IID845\n-    \"__ eandq(r9, r9, r13, true);\",                                                       \/\/ IID846\n-    \"__ eimulq(r18, r15, r16, false);\",                                                   \/\/ IID847\n-    \"__ eimulq(rcx, rcx, r17, false);\",                                                   \/\/ IID848\n-    \"__ eimulq(r23, r12, r20, true);\",                                                    \/\/ IID849\n-    \"__ eimulq(r10, r10, r9, true);\",                                                     \/\/ IID850\n-    \"__ eorq(rdx, r19, r14, false);\",                                                     \/\/ IID851\n-    \"__ eorq(rcx, rcx, r13, false);\",                                                     \/\/ IID852\n-    \"__ eorq(r9, r25, r29, true);\",                                                       \/\/ IID853\n-    \"__ eorq(rdx, rdx, r25, true);\",                                                      \/\/ IID854\n-    \"__ esubq(r23, r8, r16, false);\",                                                     \/\/ IID855\n-    \"__ esubq(r13, r13, r13, false);\",                                                    \/\/ IID856\n-    \"__ esubq(r19, r12, r15, true);\",                                                     \/\/ IID857\n-    \"__ esubq(r9, r9, rdx, true);\",                                                       \/\/ IID858\n-    \"__ exorq(r13, r16, r31, false);\",                                                    \/\/ IID859\n-    \"__ exorq(r17, r17, r30, false);\",                                                    \/\/ IID860\n-    \"__ exorq(r19, r30, r20, true);\",                                                     \/\/ IID861\n-    \"__ exorq(r31, r31, r13, true);\",                                                     \/\/ IID862\n-    \"__ eshldq(r22, r10, r13, 4, false);\",                                                \/\/ IID863\n-    \"__ eshldq(r24, r24, r21, 16, false);\",                                               \/\/ IID864\n-    \"__ eshldq(r20, r13, r27, 16, true);\",                                                \/\/ IID865\n-    \"__ eshldq(r31, r31, r19, 2, true);\",                                                 \/\/ IID866\n-    \"__ eshrdq(r30, r20, r11, 8, false);\",                                                \/\/ IID867\n-    \"__ eshrdq(rdx, rdx, r15, 1, false);\",                                                \/\/ IID868\n-    \"__ eshrdq(r28, r30, r14, 2, true);\",                                                 \/\/ IID869\n-    \"__ eshrdq(r20, r20, r16, 1, true);\",                                                 \/\/ IID870\n-    \"__ ecmovq (Assembler::Condition::overflow, r21, r17, r28);\",                         \/\/ IID871\n-    \"__ ecmovq (Assembler::Condition::overflow, r15, r15, r30);\",                         \/\/ IID872\n-    \"__ ecmovq (Assembler::Condition::noOverflow, rcx, r15, r15);\",                       \/\/ IID873\n-    \"__ ecmovq (Assembler::Condition::noOverflow, rcx, rcx, r13);\",                       \/\/ IID874\n-    \"__ ecmovq (Assembler::Condition::below, rdx, r26, r26);\",                            \/\/ IID875\n-    \"__ ecmovq (Assembler::Condition::below, r28, r28, r15);\",                            \/\/ IID876\n-    \"__ ecmovq (Assembler::Condition::aboveEqual, r8, rdx, rcx);\",                        \/\/ IID877\n-    \"__ ecmovq (Assembler::Condition::aboveEqual, rcx, rcx, rcx);\",                       \/\/ IID878\n-    \"__ ecmovq (Assembler::Condition::zero, r10, r13, r9);\",                              \/\/ IID879\n-    \"__ ecmovq (Assembler::Condition::zero, r14, r14, r27);\",                             \/\/ IID880\n-    \"__ ecmovq (Assembler::Condition::notZero, r11, r23, r9);\",                           \/\/ IID881\n-    \"__ ecmovq (Assembler::Condition::notZero, r11, r11, rdx);\",                          \/\/ IID882\n-    \"__ ecmovq (Assembler::Condition::belowEqual, r31, r14, r25);\",                       \/\/ IID883\n-    \"__ ecmovq (Assembler::Condition::belowEqual, r20, r20, r12);\",                       \/\/ IID884\n-    \"__ ecmovq (Assembler::Condition::above, rdx, r10, r28);\",                            \/\/ IID885\n-    \"__ ecmovq (Assembler::Condition::above, r8, r8, r17);\",                              \/\/ IID886\n-    \"__ ecmovq (Assembler::Condition::negative, rcx, r30, r23);\",                         \/\/ IID887\n-    \"__ ecmovq (Assembler::Condition::negative, r26, r26, r18);\",                         \/\/ IID888\n-    \"__ ecmovq (Assembler::Condition::positive, rdx, rbx, r18);\",                         \/\/ IID889\n-    \"__ ecmovq (Assembler::Condition::positive, r21, r21, r13);\",                         \/\/ IID890\n-    \"__ ecmovq (Assembler::Condition::parity, r27, r28, r27);\",                           \/\/ IID891\n-    \"__ ecmovq (Assembler::Condition::parity, r11, r11, r30);\",                           \/\/ IID892\n-    \"__ ecmovq (Assembler::Condition::noParity, rcx, r21, r18);\",                         \/\/ IID893\n-    \"__ ecmovq (Assembler::Condition::noParity, rcx, rcx, r29);\",                         \/\/ IID894\n-    \"__ ecmovq (Assembler::Condition::less, rdx, r21, r12);\",                             \/\/ IID895\n-    \"__ ecmovq (Assembler::Condition::less, rdx, rdx, r26);\",                             \/\/ IID896\n-    \"__ ecmovq (Assembler::Condition::greaterEqual, r17, rbx, r22);\",                     \/\/ IID897\n-    \"__ ecmovq (Assembler::Condition::greaterEqual, rdx, rdx, r11);\",                     \/\/ IID898\n-    \"__ ecmovq (Assembler::Condition::lessEqual, rdx, r14, r8);\",                         \/\/ IID899\n-    \"__ ecmovq (Assembler::Condition::lessEqual, r14, r14, r8);\",                         \/\/ IID900\n-    \"__ ecmovq (Assembler::Condition::greater, r25, r29, r21);\",                          \/\/ IID901\n-    \"__ ecmovq (Assembler::Condition::greater, r26, r26, r30);\",                          \/\/ IID902\n-    \"__ ecmovq (Assembler::Condition::overflow, r24, r21, Address(r13, r11, (Address::ScaleFactor)1, +0x439c521e));\", \/\/ IID903\n-    \"__ ecmovq (Assembler::Condition::noOverflow, r11, r18, Address(r29, r16, (Address::ScaleFactor)0, +0x632127f));\", \/\/ IID904\n-    \"__ ecmovq (Assembler::Condition::below, r16, r8, Address(r8, r26, (Address::ScaleFactor)1, +0x10633def));\", \/\/ IID905\n-    \"__ ecmovq (Assembler::Condition::aboveEqual, r13, r14, Address(r18, -0x54f69e38));\", \/\/ IID906\n-    \"__ ecmovq (Assembler::Condition::zero, r12, r8, Address(r31, r26, (Address::ScaleFactor)1, -0x7a1e447a));\", \/\/ IID907\n-    \"__ ecmovq (Assembler::Condition::notZero, r29, r29, Address(r19, r11, (Address::ScaleFactor)2, -0x35d82dd2));\", \/\/ IID908\n-    \"__ ecmovq (Assembler::Condition::belowEqual, rcx, r18, Address(r25, r28, (Address::ScaleFactor)0, +0x30be64a0));\", \/\/ IID909\n-    \"__ ecmovq (Assembler::Condition::above, r28, r12, Address(r10, r16, (Address::ScaleFactor)1, -0x22b8fefa));\", \/\/ IID910\n-    \"__ ecmovq (Assembler::Condition::negative, r11, r8, Address(rbx, r11, (Address::ScaleFactor)3, +0x25cc9e96));\", \/\/ IID911\n-    \"__ ecmovq (Assembler::Condition::positive, r12, r27, Address(r11, -0xc2d70fe));\",    \/\/ IID912\n-    \"__ ecmovq (Assembler::Condition::parity, r8, r26, Address(r19, rbx, (Address::ScaleFactor)1, -0x486db7ea));\", \/\/ IID913\n-    \"__ ecmovq (Assembler::Condition::noParity, r30, r10, Address(r14, r18, (Address::ScaleFactor)3, +0x14884884));\", \/\/ IID914\n-    \"__ ecmovq (Assembler::Condition::less, r27, r8, Address(r29, r14, (Address::ScaleFactor)2, +0x92b7a8));\", \/\/ IID915\n-    \"__ ecmovq (Assembler::Condition::greaterEqual, r14, r28, Address(r19, rdx, (Address::ScaleFactor)0, +0x9c2d45));\", \/\/ IID916\n-    \"__ ecmovq (Assembler::Condition::lessEqual, r25, r8, Address(rcx, r18, (Address::ScaleFactor)2, +0x6655c86b));\", \/\/ IID917\n-    \"__ ecmovq (Assembler::Condition::greater, r19, r21, Address(r10, r25, (Address::ScaleFactor)0, -0x1005430b));\", \/\/ IID918\n+    \"__ eorl(rcx, r24, r22, false);\",                                                     \/\/ IID432\n+    \"__ eorl(rcx, rcx, r19, false);\",                                                     \/\/ IID433\n+    \"__ eorl(r27, r27, r27, false);\",                                                     \/\/ IID434\n+    \"__ eorl(r31, r9, r13, true);\",                                                       \/\/ IID435\n+    \"__ eorl(r31, r31, r23, true);\",                                                      \/\/ IID436\n+    \"__ eorl(r19, r17, r19, true);\",                                                      \/\/ IID437\n+    \"__ eshldl(r20, r16, r24, false);\",                                                   \/\/ IID438\n+    \"__ eshldl(rdx, rdx, r12, false);\",                                                   \/\/ IID439\n+    \"__ eshldl(r29, r9, r31, true);\",                                                     \/\/ IID440\n+    \"__ eshldl(r17, r17, r20, true);\",                                                    \/\/ IID441\n+    \"__ eshrdl(r20, r15, r18, false);\",                                                   \/\/ IID442\n+    \"__ eshrdl(rcx, rcx, r12, false);\",                                                   \/\/ IID443\n+    \"__ eshrdl(r14, r9, r23, true);\",                                                     \/\/ IID444\n+    \"__ eshrdl(r19, r19, r13, true);\",                                                    \/\/ IID445\n+    \"__ esubl(r30, r27, r27, false);\",                                                    \/\/ IID446\n+    \"__ esubl(rdx, rdx, r11, false);\",                                                    \/\/ IID447\n+    \"__ esubl(r15, r11, r24, true);\",                                                     \/\/ IID448\n+    \"__ esubl(r14, r14, r25, true);\",                                                     \/\/ IID449\n+    \"__ exorl(r31, r16, r12, false);\",                                                    \/\/ IID450\n+    \"__ exorl(r20, r20, r14, false);\",                                                    \/\/ IID451\n+    \"__ exorl(r30, r13, r30, false);\",                                                    \/\/ IID452\n+    \"__ exorl(r24, r17, r17, true);\",                                                     \/\/ IID453\n+    \"__ exorl(r26, r26, r21, true);\",                                                     \/\/ IID454\n+    \"__ exorl(r11, r13, r11, true);\",                                                     \/\/ IID455\n+    \"__ eshldl(r27, r25, r21, 4, false);\",                                                \/\/ IID456\n+    \"__ eshldl(r22, r22, r10, 4, false);\",                                                \/\/ IID457\n+    \"__ eshldl(r21, r15, r24, 16, true);\",                                                \/\/ IID458\n+    \"__ eshldl(rdx, rdx, r19, 1, true);\",                                                 \/\/ IID459\n+    \"__ eshrdl(r23, r13, r8, 16, false);\",                                                \/\/ IID460\n+    \"__ eshrdl(r26, r26, r22, 1, false);\",                                                \/\/ IID461\n+    \"__ eshrdl(r24, r9, r30, 16, true);\",                                                 \/\/ IID462\n+    \"__ eshrdl(r19, r19, r8, 4, true);\",                                                  \/\/ IID463\n+    \"__ ecmovl (Assembler::Condition::overflow, r30, r26, r17);\",                         \/\/ IID464\n+    \"__ ecmovl (Assembler::Condition::overflow, r14, r14, r26);\",                         \/\/ IID465\n+    \"__ ecmovl (Assembler::Condition::noOverflow, r24, r19, r29);\",                       \/\/ IID466\n+    \"__ ecmovl (Assembler::Condition::noOverflow, r25, r25, r20);\",                       \/\/ IID467\n+    \"__ ecmovl (Assembler::Condition::below, r11, r10, r14);\",                            \/\/ IID468\n+    \"__ ecmovl (Assembler::Condition::below, r30, r30, r25);\",                            \/\/ IID469\n+    \"__ ecmovl (Assembler::Condition::aboveEqual, r13, r22, r27);\",                       \/\/ IID470\n+    \"__ ecmovl (Assembler::Condition::aboveEqual, r16, r16, r24);\",                       \/\/ IID471\n+    \"__ ecmovl (Assembler::Condition::zero, r28, r13, r30);\",                             \/\/ IID472\n+    \"__ ecmovl (Assembler::Condition::zero, r30, r30, r24);\",                             \/\/ IID473\n+    \"__ ecmovl (Assembler::Condition::notZero, r21, r20, r31);\",                          \/\/ IID474\n+    \"__ ecmovl (Assembler::Condition::notZero, r8, r8, r16);\",                            \/\/ IID475\n+    \"__ ecmovl (Assembler::Condition::belowEqual, r15, r26, r22);\",                       \/\/ IID476\n+    \"__ ecmovl (Assembler::Condition::belowEqual, r31, r31, rdx);\",                       \/\/ IID477\n+    \"__ ecmovl (Assembler::Condition::above, r27, r8, r10);\",                             \/\/ IID478\n+    \"__ ecmovl (Assembler::Condition::above, r18, r18, r11);\",                            \/\/ IID479\n+    \"__ ecmovl (Assembler::Condition::negative, r27, rbx, r21);\",                         \/\/ IID480\n+    \"__ ecmovl (Assembler::Condition::negative, r12, r12, r31);\",                         \/\/ IID481\n+    \"__ ecmovl (Assembler::Condition::positive, r12, rdx, r18);\",                         \/\/ IID482\n+    \"__ ecmovl (Assembler::Condition::positive, r18, r18, r19);\",                         \/\/ IID483\n+    \"__ ecmovl (Assembler::Condition::parity, r16, r20, r23);\",                           \/\/ IID484\n+    \"__ ecmovl (Assembler::Condition::parity, r18, r18, r16);\",                           \/\/ IID485\n+    \"__ ecmovl (Assembler::Condition::noParity, rbx, r31, r30);\",                         \/\/ IID486\n+    \"__ ecmovl (Assembler::Condition::noParity, r31, r31, r29);\",                         \/\/ IID487\n+    \"__ ecmovl (Assembler::Condition::less, r28, r25, r10);\",                             \/\/ IID488\n+    \"__ ecmovl (Assembler::Condition::less, r24, r24, r20);\",                             \/\/ IID489\n+    \"__ ecmovl (Assembler::Condition::greaterEqual, r16, rdx, r26);\",                     \/\/ IID490\n+    \"__ ecmovl (Assembler::Condition::greaterEqual, r28, r28, r28);\",                     \/\/ IID491\n+    \"__ ecmovl (Assembler::Condition::lessEqual, r9, r20, r24);\",                         \/\/ IID492\n+    \"__ ecmovl (Assembler::Condition::lessEqual, r24, r24, r29);\",                        \/\/ IID493\n+    \"__ ecmovl (Assembler::Condition::greater, r23, r27, r15);\",                          \/\/ IID494\n+    \"__ ecmovl (Assembler::Condition::greater, r12, r12, r18);\",                          \/\/ IID495\n+    \"__ ecmovl (Assembler::Condition::overflow, r19, r9, Address(r31, rcx, (Address::ScaleFactor)1, -0x2be98bd));\", \/\/ IID496\n+    \"__ ecmovl (Assembler::Condition::overflow, r8, r8, Address(r21, r24, (Address::ScaleFactor)1, +0x41e6a0cb));\", \/\/ IID497\n+    \"__ ecmovl (Assembler::Condition::noOverflow, r23, r15, Address(r19, r30, (Address::ScaleFactor)3, -0x55adfe2d));\", \/\/ IID498\n+    \"__ ecmovl (Assembler::Condition::noOverflow, rdx, rdx, Address(r27, rdx, (Address::ScaleFactor)0, -0x1aa12735));\", \/\/ IID499\n+    \"__ ecmovl (Assembler::Condition::below, rbx, r29, Address(r31, r12, (Address::ScaleFactor)0, +0xbd42246));\", \/\/ IID500\n+    \"__ ecmovl (Assembler::Condition::below, r21, r21, Address(r19, r21, (Address::ScaleFactor)1, -0x41518818));\", \/\/ IID501\n+    \"__ ecmovl (Assembler::Condition::aboveEqual, r23, r29, Address(r22, r9, (Address::ScaleFactor)2, -0x35addbd8));\", \/\/ IID502\n+    \"__ ecmovl (Assembler::Condition::aboveEqual, r18, r18, Address(r25, +0x632184c3));\", \/\/ IID503\n+    \"__ ecmovl (Assembler::Condition::zero, r29, r13, Address(r18, r13, (Address::ScaleFactor)0, -0x3972eac6));\", \/\/ IID504\n+    \"__ ecmovl (Assembler::Condition::zero, r29, r29, Address(r12, r9, (Address::ScaleFactor)3, -0x668cdfd2));\", \/\/ IID505\n+    \"__ ecmovl (Assembler::Condition::notZero, r25, r18, Address(r9, r22, (Address::ScaleFactor)2, +0x7f6ac91f));\", \/\/ IID506\n+    \"__ ecmovl (Assembler::Condition::notZero, r28, r28, Address(r30, +0x562e6594));\",    \/\/ IID507\n+    \"__ ecmovl (Assembler::Condition::belowEqual, r27, r24, Address(r15, r20, (Address::ScaleFactor)2, -0x466538b7));\", \/\/ IID508\n+    \"__ ecmovl (Assembler::Condition::belowEqual, r25, r25, Address(r26, r11, (Address::ScaleFactor)3, -0x593812a9));\", \/\/ IID509\n+    \"__ ecmovl (Assembler::Condition::above, rcx, r20, Address(r16, -0x1389a3eb));\",      \/\/ IID510\n+    \"__ ecmovl (Assembler::Condition::above, rbx, rbx, Address(r29, r8, (Address::ScaleFactor)0, +0x1d022615));\", \/\/ IID511\n+    \"__ ecmovl (Assembler::Condition::negative, rdx, r14, Address(r12, r28, (Address::ScaleFactor)1, -0x51725a91));\", \/\/ IID512\n+    \"__ ecmovl (Assembler::Condition::negative, r24, r24, Address(r17, r18, (Address::ScaleFactor)1, -0x1725c4e4));\", \/\/ IID513\n+    \"__ ecmovl (Assembler::Condition::positive, rcx, rcx, Address(r15, r23, (Address::ScaleFactor)2, -0x6bd22ccf));\", \/\/ IID514\n+    \"__ ecmovl (Assembler::Condition::positive, r24, r24, Address(r15, r10, (Address::ScaleFactor)1, -0x7ffb3d09));\", \/\/ IID515\n+    \"__ ecmovl (Assembler::Condition::parity, r23, rcx, Address(r11, r23, (Address::ScaleFactor)0, +0x3738c585));\", \/\/ IID516\n+    \"__ ecmovl (Assembler::Condition::parity, r24, r24, Address(r30, r10, (Address::ScaleFactor)0, +0xfcc15a8));\", \/\/ IID517\n+    \"__ ecmovl (Assembler::Condition::noParity, r14, r26, Address(r14, r21, (Address::ScaleFactor)1, -0x4430ce9f));\", \/\/ IID518\n+    \"__ ecmovl (Assembler::Condition::noParity, r10, r10, Address(r28, +0x3d7c59f));\",    \/\/ IID519\n+    \"__ ecmovl (Assembler::Condition::less, r10, r21, Address(r8, r8, (Address::ScaleFactor)3, +0x4a6584b4));\", \/\/ IID520\n+    \"__ ecmovl (Assembler::Condition::less, r26, r26, Address(r19, r20, (Address::ScaleFactor)3, +0x47c660ef));\", \/\/ IID521\n+    \"__ ecmovl (Assembler::Condition::greaterEqual, r26, r10, Address(rcx, +0x61977a97));\", \/\/ IID522\n+    \"__ ecmovl (Assembler::Condition::greaterEqual, r30, r30, Address(r15, r19, (Address::ScaleFactor)3, +0x53c601cb));\", \/\/ IID523\n+    \"__ ecmovl (Assembler::Condition::lessEqual, r14, r9, Address(r17, -0x566ceee2));\",   \/\/ IID524\n+    \"__ ecmovl (Assembler::Condition::lessEqual, r15, r15, Address(r27, r20, (Address::ScaleFactor)0, +0x76164792));\", \/\/ IID525\n+    \"__ ecmovl (Assembler::Condition::greater, r27, r14, Address(r9, r13, (Address::ScaleFactor)2, +0xf5752d7));\", \/\/ IID526\n+    \"__ ecmovl (Assembler::Condition::greater, r12, r12, Address(rbx, rcx, (Address::ScaleFactor)3, -0x5501b4c6));\", \/\/ IID527\n+    \"__ adcq(r30, r31);\",                                                                 \/\/ IID528\n+    \"__ cmpq(r12, rdx);\",                                                                 \/\/ IID529\n+    \"__ imulq(r21, r24);\",                                                                \/\/ IID530\n+    \"__ popcntq(r9, r25);\",                                                               \/\/ IID531\n+    \"__ sbbq(r8, r12);\",                                                                  \/\/ IID532\n+    \"__ subq(r31, r24);\",                                                                 \/\/ IID533\n+    \"__ tzcntq(r10, r16);\",                                                               \/\/ IID534\n+    \"__ lzcntq(r20, r21);\",                                                               \/\/ IID535\n+    \"__ addq(rdx, r17);\",                                                                 \/\/ IID536\n+    \"__ andq(r14, r13);\",                                                                 \/\/ IID537\n+    \"__ orq(r20, r24);\",                                                                  \/\/ IID538\n+    \"__ xorq(r21, r22);\",                                                                 \/\/ IID539\n+    \"__ movq(r12, r27);\",                                                                 \/\/ IID540\n+    \"__ bsfq(r23, rdx);\",                                                                 \/\/ IID541\n+    \"__ bsrq(r31, r28);\",                                                                 \/\/ IID542\n+    \"__ btq(r8, r25);\",                                                                   \/\/ IID543\n+    \"__ xchgq(r21, rbx);\",                                                                \/\/ IID544\n+    \"__ testq(r23, r23);\",                                                                \/\/ IID545\n+    \"__ addq(Address(r19, -0x180d3ea1), r10);\",                                           \/\/ IID546\n+    \"__ andq(Address(r11, r17, (Address::ScaleFactor)1, -0x78976be8), r25);\",             \/\/ IID547\n+    \"__ cmpq(Address(rbx, r28, (Address::ScaleFactor)3, +0x35f72102), r13);\",             \/\/ IID548\n+    \"__ orq(Address(r8, -0x34465011), r21);\",                                             \/\/ IID549\n+    \"__ xorq(Address(r19, -0x404b22dd), r18);\",                                           \/\/ IID550\n+    \"__ subq(Address(r23, r27, (Address::ScaleFactor)3, -0x428d2646), r14);\",             \/\/ IID551\n+    \"__ movq(Address(r9, rcx, (Address::ScaleFactor)2, -0x72611661), r28);\",              \/\/ IID552\n+    \"__ xaddq(Address(r24, r21, (Address::ScaleFactor)2, +0x3a6be990), rbx);\",            \/\/ IID553\n+    \"__ andq(Address(r22, r10, (Address::ScaleFactor)0, +0x7ef8bdd), 1048576);\",          \/\/ IID554\n+    \"__ addq(Address(r13, r28, (Address::ScaleFactor)0, -0x754789b1), 65536);\",           \/\/ IID555\n+    \"__ cmpq(Address(r10, -0xbd2a8da), 268435456);\",                                      \/\/ IID556\n+    \"__ sarq(Address(r23, r14, (Address::ScaleFactor)1, +0x6a16d9f5), 4);\",               \/\/ IID557\n+    \"__ salq(Address(rcx, r21, (Address::ScaleFactor)1, +0x5f66ac1e), 8);\",               \/\/ IID558\n+    \"__ sbbq(Address(rcx, r22, (Address::ScaleFactor)3, -0x48c954c), 268435456);\",        \/\/ IID559\n+    \"__ shrq(Address(r21, r30, (Address::ScaleFactor)0, +0xe405b0b), 8);\",                \/\/ IID560\n+    \"__ subq(Address(r19, r29, (Address::ScaleFactor)3, -0x7762044b), 4096);\",            \/\/ IID561\n+    \"__ xorq(Address(r30, r10, (Address::ScaleFactor)1, -0x19798323), 16);\",              \/\/ IID562\n+    \"__ orq(Address(rdx, r24, (Address::ScaleFactor)3, +0x18d9b316), 4096);\",             \/\/ IID563\n+    \"__ movq(Address(rbx, -0x3058074d), 256);\",                                           \/\/ IID564\n+    \"__ testq(Address(r28, r21, (Address::ScaleFactor)3, +0x65a0fdc4), -268435456);\",     \/\/ IID565\n+    \"__ addq(r23, Address(r11, r18, (Address::ScaleFactor)0, -0x1d1af10c));\",             \/\/ IID566\n+    \"__ andq(r22, Address(r18, r12, (Address::ScaleFactor)1, +0x1a5f1c38));\",             \/\/ IID567\n+    \"__ cmpq(r23, Address(r30, r19, (Address::ScaleFactor)0, -0x3e912f7f));\",             \/\/ IID568\n+    \"__ lzcntq(r29, Address(rcx, +0x12e3fbe4));\",                                         \/\/ IID569\n+    \"__ orq(r14, Address(r21, r21, (Address::ScaleFactor)2, +0xd73042));\",                \/\/ IID570\n+    \"__ adcq(r31, Address(r17, r31, (Address::ScaleFactor)2, +0xabde912));\",              \/\/ IID571\n+    \"__ imulq(r20, Address(r13, r27, (Address::ScaleFactor)0, -0x58dbfc1f));\",            \/\/ IID572\n+    \"__ popcntq(rbx, Address(r22, -0x72c66c23));\",                                        \/\/ IID573\n+    \"__ sbbq(r26, Address(r9, +0x334aba09));\",                                            \/\/ IID574\n+    \"__ subq(r9, Address(r9, r30, (Address::ScaleFactor)3, -0x219a6102));\",               \/\/ IID575\n+    \"__ tzcntq(r25, Address(r20, -0x2131bab1));\",                                         \/\/ IID576\n+    \"__ xorq(r16, Address(r28, r16, (Address::ScaleFactor)1, +0x48c483b9));\",             \/\/ IID577\n+    \"__ movq(r30, Address(r9, r16, (Address::ScaleFactor)0, -0x88ce84f));\",               \/\/ IID578\n+    \"__ leaq(r11, Address(r30, r29, (Address::ScaleFactor)2, +0x3eeb8fd0));\",             \/\/ IID579\n+    \"__ cvttsd2siq(r26, Address(r29, r10, (Address::ScaleFactor)3, +0x3ef4822e));\",       \/\/ IID580\n+    \"__ xchgq(r29, Address(r19, r20, (Address::ScaleFactor)2, -0x3f0f3db9));\",            \/\/ IID581\n+    \"__ testq(r8, Address(r30, r20, (Address::ScaleFactor)0, +0x15b56a17));\",             \/\/ IID582\n+    \"__ addq(r26, 4096);\",                                                                \/\/ IID583\n+    \"__ andq(r20, 16);\",                                                                  \/\/ IID584\n+    \"__ adcq(r23, 1048576);\",                                                             \/\/ IID585\n+    \"__ cmpq(r12, 4096);\",                                                                \/\/ IID586\n+    \"__ rclq(rcx, 4);\",                                                                   \/\/ IID587\n+    \"__ rcrq(r14, 1);\",                                                                   \/\/ IID588\n+    \"__ rolq(r23, 2);\",                                                                   \/\/ IID589\n+    \"__ rorq(r12, 4);\",                                                                   \/\/ IID590\n+    \"__ sarq(r10, 4);\",                                                                   \/\/ IID591\n+    \"__ salq(r20, 4);\",                                                                   \/\/ IID592\n+    \"__ sbbq(rcx, 1048576);\",                                                             \/\/ IID593\n+    \"__ shlq(r23, 16);\",                                                                  \/\/ IID594\n+    \"__ shrq(r27, 2);\",                                                                   \/\/ IID595\n+    \"__ subq(rcx, 65536);\",                                                               \/\/ IID596\n+    \"__ xorq(r9, 1048576);\",                                                              \/\/ IID597\n+    \"__ movq(r16, 65536);\",                                                               \/\/ IID598\n+    \"__ mov64(r24, 4503599627370496);\",                                                   \/\/ IID599\n+    \"__ btq(r18, 64);\",                                                                   \/\/ IID600\n+    \"__ testq(r29, -4096);\",                                                              \/\/ IID601\n+    \"__ orq_imm32(r30, 67108864);\",                                                       \/\/ IID602\n+    \"__ subq_imm32(r25, 268435456);\",                                                     \/\/ IID603\n+    \"__ cmovq(Assembler::Condition::overflow, r30, Address(r17, r31, (Address::ScaleFactor)2, +0x47ff92f0));\", \/\/ IID604\n+    \"__ cmovq(Assembler::Condition::noOverflow, r9, Address(r24, r28, (Address::ScaleFactor)1, +0x384904c0));\", \/\/ IID605\n+    \"__ cmovq(Assembler::Condition::below, r23, Address(r23, r24, (Address::ScaleFactor)3, -0x197f1266));\", \/\/ IID606\n+    \"__ cmovq(Assembler::Condition::aboveEqual, r9, Address(r29, r30, (Address::ScaleFactor)0, +0x2b5d49c8));\", \/\/ IID607\n+    \"__ cmovq(Assembler::Condition::zero, r16, Address(rbx, r15, (Address::ScaleFactor)1, +0x22379381));\", \/\/ IID608\n+    \"__ cmovq(Assembler::Condition::notZero, r8, Address(r11, +0x49d67a0));\",             \/\/ IID609\n+    \"__ cmovq(Assembler::Condition::belowEqual, r28, Address(r16, r16, (Address::ScaleFactor)2, -0x5e941da9));\", \/\/ IID610\n+    \"__ cmovq(Assembler::Condition::above, r19, Address(r18, r8, (Address::ScaleFactor)0, -0xa5e55ec));\", \/\/ IID611\n+    \"__ cmovq(Assembler::Condition::negative, r28, Address(r17, r28, (Address::ScaleFactor)1, -0x3264220c));\", \/\/ IID612\n+    \"__ cmovq(Assembler::Condition::positive, r31, Address(r14, r31, (Address::ScaleFactor)1, +0x5001bc5a));\", \/\/ IID613\n+    \"__ cmovq(Assembler::Condition::parity, rbx, Address(r18, r17, (Address::ScaleFactor)2, -0x286f2379));\", \/\/ IID614\n+    \"__ cmovq(Assembler::Condition::noParity, r17, Address(r20, -0x5549f838));\",          \/\/ IID615\n+    \"__ cmovq(Assembler::Condition::less, r30, Address(r9, r28, (Address::ScaleFactor)1, -0x25b00cf3));\", \/\/ IID616\n+    \"__ cmovq(Assembler::Condition::greaterEqual, r19, Address(r9, -0x2aabf22c));\",       \/\/ IID617\n+    \"__ cmovq(Assembler::Condition::lessEqual, rbx, Address(rcx, r12, (Address::ScaleFactor)1, -0x432d68cc));\", \/\/ IID618\n+    \"__ cmovq(Assembler::Condition::greater, rbx, Address(r15, r17, (Address::ScaleFactor)3, -0x2b97565e));\", \/\/ IID619\n+    \"__ call(r24);\",                                                                      \/\/ IID620\n+    \"__ divq(r9);\",                                                                       \/\/ IID621\n+    \"__ idivq(r28);\",                                                                     \/\/ IID622\n+    \"__ imulq(rdx);\",                                                                     \/\/ IID623\n+    \"__ mulq(r31);\",                                                                      \/\/ IID624\n+    \"__ negq(r12);\",                                                                      \/\/ IID625\n+    \"__ notq(r12);\",                                                                      \/\/ IID626\n+    \"__ rolq(r24);\",                                                                      \/\/ IID627\n+    \"__ rorq(r28);\",                                                                      \/\/ IID628\n+    \"__ sarq(r11);\",                                                                      \/\/ IID629\n+    \"__ salq(r27);\",                                                                      \/\/ IID630\n+    \"__ shlq(r23);\",                                                                      \/\/ IID631\n+    \"__ shrq(r17);\",                                                                      \/\/ IID632\n+    \"__ incrementq(r16);\",                                                                \/\/ IID633\n+    \"__ decrementq(r12);\",                                                                \/\/ IID634\n+    \"__ pushp(r23);\",                                                                     \/\/ IID635\n+    \"__ popp(r24);\",                                                                      \/\/ IID636\n+    \"__ call(Address(r18, r14, (Address::ScaleFactor)0, -0x66639d32));\",                  \/\/ IID637\n+    \"__ mulq(Address(r24, -0x660a2421));\",                                                \/\/ IID638\n+    \"__ negq(Address(r14, r18, (Address::ScaleFactor)0, +0x40f3936e));\",                  \/\/ IID639\n+    \"__ sarq(Address(r10, r13, (Address::ScaleFactor)0, +0x7d04cb72));\",                  \/\/ IID640\n+    \"__ salq(Address(r18, r11, (Address::ScaleFactor)3, -0x2176b4dc));\",                  \/\/ IID641\n+    \"__ shrq(Address(r13, rcx, (Address::ScaleFactor)1, +0x7996aa80));\",                  \/\/ IID642\n+    \"__ incrementq(Address(r14, +0x67c2d02a));\",                                          \/\/ IID643\n+    \"__ decrementq(Address(r22, r26, (Address::ScaleFactor)0, +0x224f62c0));\",            \/\/ IID644\n+    \"__ imulq(rdx, Address(r31, rbx, (Address::ScaleFactor)1, +0x2b00bb10), 16777216);\",  \/\/ IID645\n+    \"__ imulq(r21, r31, 4096);\",                                                          \/\/ IID646\n+    \"__ shldq(rbx, r19, 1);\",                                                             \/\/ IID647\n+    \"__ shrdq(r11, r23, 4);\",                                                             \/\/ IID648\n+    \"__ pop2(r16, r30);\",                                                                 \/\/ IID649\n+    \"__ pop2p(r17, rbx);\",                                                                \/\/ IID650\n+    \"__ push2(r20, r30);\",                                                                \/\/ IID651\n+    \"__ push2p(r8, r31);\",                                                                \/\/ IID652\n+    \"__ movzbq(r28, Address(r8, r14, (Address::ScaleFactor)0, +0x469ae67a));\",            \/\/ IID653\n+    \"__ movzwq(r14, Address(r8, r18, (Address::ScaleFactor)2, -0x48699e02));\",            \/\/ IID654\n+    \"__ movsbq(r21, Address(rbx, -0x64dae06b));\",                                         \/\/ IID655\n+    \"__ movswq(r19, Address(r31, rbx, (Address::ScaleFactor)2, +0x60318819));\",           \/\/ IID656\n+    \"__ movzbq(r30, r13);\",                                                               \/\/ IID657\n+    \"__ movzwq(r30, r18);\",                                                               \/\/ IID658\n+    \"__ movsbq(r19, r15);\",                                                               \/\/ IID659\n+    \"__ movswq(r20, r16);\",                                                               \/\/ IID660\n+    \"__ cmpxchgq(r28, Address(r11, rbx, (Address::ScaleFactor)3, +0xfc3479d));\",          \/\/ IID661\n+    \"__ eidivq(r20, false);\",                                                             \/\/ IID662\n+    \"__ eidivq(r30, true);\",                                                              \/\/ IID663\n+    \"__ edivq(r22, false);\",                                                              \/\/ IID664\n+    \"__ edivq(r11, true);\",                                                               \/\/ IID665\n+    \"__ eimulq(rcx, false);\",                                                             \/\/ IID666\n+    \"__ eimulq(r28, true);\",                                                              \/\/ IID667\n+    \"__ emulq(r21, false);\",                                                              \/\/ IID668\n+    \"__ emulq(r13, true);\",                                                               \/\/ IID669\n+    \"__ emulq(Address(r26, r15, (Address::ScaleFactor)2, +0x70a1ce6e), false);\",          \/\/ IID670\n+    \"__ emulq(Address(r24, r19, (Address::ScaleFactor)1, -0x1670855c), true);\",           \/\/ IID671\n+    \"__ eimulq(r10, r27, false);\",                                                        \/\/ IID672\n+    \"__ eimulq(r17, r17, false);\",                                                        \/\/ IID673\n+    \"__ eimulq(rdx, r22, true);\",                                                         \/\/ IID674\n+    \"__ eimulq(rbx, rbx, true);\",                                                         \/\/ IID675\n+    \"__ elzcntq(r28, r15, false);\",                                                       \/\/ IID676\n+    \"__ elzcntq(r15, r15, false);\",                                                       \/\/ IID677\n+    \"__ elzcntq(rbx, r12, true);\",                                                        \/\/ IID678\n+    \"__ elzcntq(rbx, rbx, true);\",                                                        \/\/ IID679\n+    \"__ enegq(r26, r11, false);\",                                                         \/\/ IID680\n+    \"__ enegq(r17, r17, false);\",                                                         \/\/ IID681\n+    \"__ enegq(rdx, r31, true);\",                                                          \/\/ IID682\n+    \"__ enegq(r27, r27, true);\",                                                          \/\/ IID683\n+    \"__ enotq(r31, r15);\",                                                                \/\/ IID684\n+    \"__ enotq(r21, r21);\",                                                                \/\/ IID685\n+    \"__ epopcntq(rbx, r24, false);\",                                                      \/\/ IID686\n+    \"__ epopcntq(r28, r28, false);\",                                                      \/\/ IID687\n+    \"__ epopcntq(r23, r27, true);\",                                                       \/\/ IID688\n+    \"__ epopcntq(r13, r13, true);\",                                                       \/\/ IID689\n+    \"__ erolq(r25, r28, false);\",                                                         \/\/ IID690\n+    \"__ erolq(r31, r31, false);\",                                                         \/\/ IID691\n+    \"__ erolq(r25, r23, true);\",                                                          \/\/ IID692\n+    \"__ erolq(rcx, rcx, true);\",                                                          \/\/ IID693\n+    \"__ erorq(r22, r14, false);\",                                                         \/\/ IID694\n+    \"__ erorq(r15, r15, false);\",                                                         \/\/ IID695\n+    \"__ erorq(r11, r30, true);\",                                                          \/\/ IID696\n+    \"__ erorq(r24, r24, true);\",                                                          \/\/ IID697\n+    \"__ esalq(r10, r20, false);\",                                                         \/\/ IID698\n+    \"__ esalq(r19, r19, false);\",                                                         \/\/ IID699\n+    \"__ esalq(r17, r25, true);\",                                                          \/\/ IID700\n+    \"__ esalq(r13, r13, true);\",                                                          \/\/ IID701\n+    \"__ esarq(r31, r30, false);\",                                                         \/\/ IID702\n+    \"__ esarq(r18, r18, false);\",                                                         \/\/ IID703\n+    \"__ esarq(r25, r25, true);\",                                                          \/\/ IID704\n+    \"__ esarq(r28, r28, true);\",                                                          \/\/ IID705\n+    \"__ edecq(r22, r27, false);\",                                                         \/\/ IID706\n+    \"__ edecq(r12, r12, false);\",                                                         \/\/ IID707\n+    \"__ edecq(r18, r11, true);\",                                                          \/\/ IID708\n+    \"__ edecq(r10, r10, true);\",                                                          \/\/ IID709\n+    \"__ eincq(r20, r24, false);\",                                                         \/\/ IID710\n+    \"__ eincq(r18, r18, false);\",                                                         \/\/ IID711\n+    \"__ eincq(rbx, r11, true);\",                                                          \/\/ IID712\n+    \"__ eincq(r26, r26, true);\",                                                          \/\/ IID713\n+    \"__ eshlq(r21, r8, false);\",                                                          \/\/ IID714\n+    \"__ eshlq(rbx, rbx, false);\",                                                         \/\/ IID715\n+    \"__ eshlq(r22, r21, true);\",                                                          \/\/ IID716\n+    \"__ eshlq(r27, r27, true);\",                                                          \/\/ IID717\n+    \"__ eshrq(r12, r16, false);\",                                                         \/\/ IID718\n+    \"__ eshrq(r8, r8, false);\",                                                           \/\/ IID719\n+    \"__ eshrq(rdx, r9, true);\",                                                           \/\/ IID720\n+    \"__ eshrq(r20, r20, true);\",                                                          \/\/ IID721\n+    \"__ etzcntq(r31, r21, false);\",                                                       \/\/ IID722\n+    \"__ etzcntq(r20, r20, false);\",                                                       \/\/ IID723\n+    \"__ etzcntq(rcx, r16, true);\",                                                        \/\/ IID724\n+    \"__ etzcntq(r14, r14, true);\",                                                        \/\/ IID725\n+    \"__ eimulq(r27, Address(r25, r9, (Address::ScaleFactor)1, +0x445a2393), false);\",     \/\/ IID726\n+    \"__ eimulq(r23, Address(rcx, r9, (Address::ScaleFactor)1, -0x1480ef0c), true);\",      \/\/ IID727\n+    \"__ elzcntq(r13, Address(r22, r17, (Address::ScaleFactor)1, -0x750c1996), false);\",   \/\/ IID728\n+    \"__ elzcntq(r13, Address(r31, -0x342b6259), true);\",                                  \/\/ IID729\n+    \"__ enegq(r31, Address(r24, r13, (Address::ScaleFactor)1, -0x25b16a0e), false);\",     \/\/ IID730\n+    \"__ enegq(r13, Address(r11, r28, (Address::ScaleFactor)3, +0x5c0013ab), true);\",      \/\/ IID731\n+    \"__ epopcntq(rdx, Address(r18, rcx, (Address::ScaleFactor)2, -0x6113eaaf), false);\",  \/\/ IID732\n+    \"__ epopcntq(r9, Address(r10, -0x5ca7d588), true);\",                                  \/\/ IID733\n+    \"__ esalq(r17, Address(r27, r30, (Address::ScaleFactor)0, +0x1b4cda2c), false);\",     \/\/ IID734\n+    \"__ esalq(r25, Address(r12, rdx, (Address::ScaleFactor)1, +0x62823bce), true);\",      \/\/ IID735\n+    \"__ esarq(r9, Address(r10, r18, (Address::ScaleFactor)2, -0x264a7a48), false);\",      \/\/ IID736\n+    \"__ esarq(rbx, Address(r14, r27, (Address::ScaleFactor)0, +0x20291e00), true);\",      \/\/ IID737\n+    \"__ edecq(r12, Address(r15, r14, (Address::ScaleFactor)2, -0x20f7dabb), false);\",     \/\/ IID738\n+    \"__ edecq(r9, Address(r10, r25, (Address::ScaleFactor)1, +0x21411d84), true);\",       \/\/ IID739\n+    \"__ eincq(r20, Address(rbx, r25, (Address::ScaleFactor)3, +0x2f0329e), false);\",      \/\/ IID740\n+    \"__ eincq(r10, Address(r12, r31, (Address::ScaleFactor)0, -0x37505c8c), true);\",      \/\/ IID741\n+    \"__ eshrq(r24, Address(r23, r14, (Address::ScaleFactor)3, -0x71e75ab0), false);\",     \/\/ IID742\n+    \"__ eshrq(r25, Address(r19, r10, (Address::ScaleFactor)1, +0x507b0a88), true);\",      \/\/ IID743\n+    \"__ etzcntq(r31, Address(rbx, r16, (Address::ScaleFactor)0, +0x19d5192a), false);\",   \/\/ IID744\n+    \"__ etzcntq(r9, Address(r22, r28, (Address::ScaleFactor)2, +0x211007cd), true);\",     \/\/ IID745\n+    \"__ eaddq(r16, Address(r21, rbx, (Address::ScaleFactor)3, -0x823fa1e), r28, false);\", \/\/ IID746\n+    \"__ eaddq(r15, Address(rdx, r8, (Address::ScaleFactor)3, -0x34b9a058), r15, false);\", \/\/ IID747\n+    \"__ eaddq(r24, Address(r14, r24, (Address::ScaleFactor)3, +0x6cdc59d2), r13, true);\", \/\/ IID748\n+    \"__ eaddq(rbx, Address(r27, r14, (Address::ScaleFactor)3, +0x36c5e8de), rbx, true);\", \/\/ IID749\n+    \"__ eandq(r21, Address(r27, r27, (Address::ScaleFactor)1, -0x2c023b13), r27, false);\", \/\/ IID750\n+    \"__ eandq(r31, Address(r21, r15, (Address::ScaleFactor)2, +0x6ef2c74a), r31, false);\", \/\/ IID751\n+    \"__ eandq(r13, Address(r31, r25, (Address::ScaleFactor)1, +0x734fe9ab), r27, true);\", \/\/ IID752\n+    \"__ eandq(r15, Address(r14, r29, (Address::ScaleFactor)3, -0x6e68556), r15, true);\",  \/\/ IID753\n+    \"__ eorq(r12, Address(r30, r15, (Address::ScaleFactor)3, +0x3ba33f9e), r28, false);\", \/\/ IID754\n+    \"__ eorq(r16, Address(r12, r9, (Address::ScaleFactor)0, -0x28e03b33), r16, false);\",  \/\/ IID755\n+    \"__ eorq(r8, Address(r8, r25, (Address::ScaleFactor)3, -0x1e42bd95), r27, true);\",    \/\/ IID756\n+    \"__ eorq(rcx, Address(r27, rbx, (Address::ScaleFactor)2, +0x7be4bcad), rcx, true);\",  \/\/ IID757\n+    \"__ esubq(r24, Address(r23, r22, (Address::ScaleFactor)2, +0x6f8827d7), rdx, false);\", \/\/ IID758\n+    \"__ esubq(r21, Address(r10, -0x635b8c8), r21, false);\",                               \/\/ IID759\n+    \"__ esubq(r23, Address(r27, r26, (Address::ScaleFactor)3, +0x922bcc0), rbx, true);\",  \/\/ IID760\n+    \"__ esubq(r25, Address(r23, r15, (Address::ScaleFactor)0, -0x38f494ac), r25, true);\", \/\/ IID761\n+    \"__ exorq(r11, Address(r12, r19, (Address::ScaleFactor)2, -0x5b71ec17), rcx, false);\", \/\/ IID762\n+    \"__ exorq(r28, Address(r19, r18, (Address::ScaleFactor)0, +0x716b9b7e), r28, false);\", \/\/ IID763\n+    \"__ exorq(r21, Address(rcx, r29, (Address::ScaleFactor)0, -0x5af0441e), r16, true);\", \/\/ IID764\n+    \"__ exorq(r12, Address(r20, r26, (Address::ScaleFactor)0, +0xe0b7fb1), r12, true);\",  \/\/ IID765\n+    \"__ eaddq(r30, Address(rcx, +0x2d3b7b4f), 1048576, false);\",                          \/\/ IID766\n+    \"__ eaddq(r14, Address(r21, r15, (Address::ScaleFactor)2, -0x1222aee8), 4096, true);\", \/\/ IID767\n+    \"__ eandq(r23, Address(r20, r31, (Address::ScaleFactor)0, -0x96e4d6a), 16, false);\",  \/\/ IID768\n+    \"__ eandq(r10, Address(rdx, rdx, (Address::ScaleFactor)3, +0x3875f17c), 1, true);\",   \/\/ IID769\n+    \"__ eimulq(r17, Address(rcx, r25, (Address::ScaleFactor)2, +0x32c71076), 4096, false);\", \/\/ IID770\n+    \"__ eimulq(r19, Address(r31, rbx, (Address::ScaleFactor)2, +0x7bada60d), 1048576, true);\", \/\/ IID771\n+    \"__ eorq(r25, Address(r18, r23, (Address::ScaleFactor)1, +0x48147444), 16777216, false);\", \/\/ IID772\n+    \"__ eorq(r29, Address(r26, r27, (Address::ScaleFactor)1, -0x4b113958), 1048576, true);\", \/\/ IID773\n+    \"__ esalq(r31, Address(r18, -0x46103c74), 2, false);\",                                \/\/ IID774\n+    \"__ esalq(r25, Address(r10, r15, (Address::ScaleFactor)0, +0x48925da4), 16, true);\",  \/\/ IID775\n+    \"__ esarq(r26, Address(r18, -0x5ea1c542), 8, false);\",                                \/\/ IID776\n+    \"__ esarq(r12, Address(r10, r22, (Address::ScaleFactor)2, +0x5d958264), 8, true);\",   \/\/ IID777\n+    \"__ eshrq(rdx, Address(r17, r20, (Address::ScaleFactor)2, +0x295add23), 16, false);\", \/\/ IID778\n+    \"__ eshrq(rbx, Address(r22, r28, (Address::ScaleFactor)1, +0x782929cb), 2, true);\",   \/\/ IID779\n+    \"__ esubq(r19, Address(r23, -0x49811d72), 1, false);\",                                \/\/ IID780\n+    \"__ esubq(r8, Address(r19, r14, (Address::ScaleFactor)2, -0x1b2bae9a), 1048576, true);\", \/\/ IID781\n+    \"__ exorq(r19, Address(rcx, r10, (Address::ScaleFactor)0, +0x45a66ee9), 1048576, false);\", \/\/ IID782\n+    \"__ exorq(r28, Address(r9, r29, (Address::ScaleFactor)0, -0x28a19314), 16, true);\",   \/\/ IID783\n+    \"__ eaddq(r8, rcx, 16777216, false);\",                                                \/\/ IID784\n+    \"__ eaddq(rax, r14, 16777216, false);\",                                               \/\/ IID785\n+    \"__ eaddq(r16, r16, 256, false);\",                                                    \/\/ IID786\n+    \"__ eaddq(r24, r9, 4096, true);\",                                                     \/\/ IID787\n+    \"__ eaddq(rax, r18, 4096, true);\",                                                    \/\/ IID788\n+    \"__ eaddq(r8, r8, 1, true);\",                                                         \/\/ IID789\n+    \"__ eandq(r15, r22, 1048576, false);\",                                                \/\/ IID790\n+    \"__ eandq(rax, r26, 1048576, false);\",                                                \/\/ IID791\n+    \"__ eandq(rdx, rdx, 4096, false);\",                                                   \/\/ IID792\n+    \"__ eandq(rdx, r22, 268435456, true);\",                                               \/\/ IID793\n+    \"__ eandq(rax, r29, 268435456, true);\",                                               \/\/ IID794\n+    \"__ eandq(r23, r23, 16777216, true);\",                                                \/\/ IID795\n+    \"__ eimulq(r9, r13, 1048576, false);\",                                                \/\/ IID796\n+    \"__ eimulq(rax, r18, 1048576, false);\",                                               \/\/ IID797\n+    \"__ eimulq(r16, r16, 1048576, false);\",                                               \/\/ IID798\n+    \"__ eimulq(r17, r23, 1, true);\",                                                      \/\/ IID799\n+    \"__ eimulq(rax, r12, 1, true);\",                                                      \/\/ IID800\n+    \"__ eimulq(r10, r10, 268435456, true);\",                                              \/\/ IID801\n+    \"__ eorq(rdx, r19, 256, false);\",                                                     \/\/ IID802\n+    \"__ eorq(rax, r14, 256, false);\",                                                     \/\/ IID803\n+    \"__ eorq(r13, r13, 1, false);\",                                                       \/\/ IID804\n+    \"__ eorq(r25, r29, 256, true);\",                                                      \/\/ IID805\n+    \"__ eorq(rax, rdx, 256, true);\",                                                      \/\/ IID806\n+    \"__ eorq(r16, r16, 16, true);\",                                                       \/\/ IID807\n+    \"__ erclq(r13, r19, 4);\",                                                             \/\/ IID808\n+    \"__ erclq(rax, r12, 4);\",                                                             \/\/ IID809\n+    \"__ erclq(r9, r9, 4);\",                                                               \/\/ IID810\n+    \"__ erolq(r13, r16, 1, false);\",                                                      \/\/ IID811\n+    \"__ erolq(rax, r31, 1, false);\",                                                      \/\/ IID812\n+    \"__ erolq(r30, r30, 8, false);\",                                                      \/\/ IID813\n+    \"__ erolq(r30, r20, 8, true);\",                                                       \/\/ IID814\n+    \"__ erolq(rax, r31, 8, true);\",                                                       \/\/ IID815\n+    \"__ erolq(r31, r31, 4, true);\",                                                       \/\/ IID816\n+    \"__ erorq(r22, r10, 4, false);\",                                                      \/\/ IID817\n+    \"__ erorq(rax, r13, 4, false);\",                                                      \/\/ IID818\n+    \"__ erorq(r24, r24, 16, false);\",                                                     \/\/ IID819\n+    \"__ erorq(r29, r22, 16, true);\",                                                      \/\/ IID820\n+    \"__ erorq(rax, r20, 16, true);\",                                                      \/\/ IID821\n+    \"__ erorq(r27, r27, 4, true);\",                                                       \/\/ IID822\n+    \"__ esalq(r31, r19, 2, false);\",                                                      \/\/ IID823\n+    \"__ esalq(rax, r20, 2, false);\",                                                      \/\/ IID824\n+    \"__ esalq(r11, r11, 8, false);\",                                                      \/\/ IID825\n+    \"__ esalq(rdx, r15, 1, true);\",                                                       \/\/ IID826\n+    \"__ esalq(rax, r10, 1, true);\",                                                       \/\/ IID827\n+    \"__ esalq(r29, r29, 4, true);\",                                                       \/\/ IID828\n+    \"__ esarq(r20, r16, 1, false);\",                                                      \/\/ IID829\n+    \"__ esarq(rax, r21, 1, false);\",                                                      \/\/ IID830\n+    \"__ esarq(r28, r28, 8, false);\",                                                      \/\/ IID831\n+    \"__ esarq(r30, rcx, 4, true);\",                                                       \/\/ IID832\n+    \"__ esarq(rax, r15, 4, true);\",                                                       \/\/ IID833\n+    \"__ esarq(rcx, rcx, 4, true);\",                                                       \/\/ IID834\n+    \"__ eshlq(rdx, r26, 4, false);\",                                                      \/\/ IID835\n+    \"__ eshlq(rax, r26, 4, false);\",                                                      \/\/ IID836\n+    \"__ eshlq(r8, r8, 4, false);\",                                                        \/\/ IID837\n+    \"__ eshlq(rcx, rcx, 1, true);\",                                                       \/\/ IID838\n+    \"__ eshlq(rax, rcx, 1, true);\",                                                       \/\/ IID839\n+    \"__ eshlq(r13, r13, 2, true);\",                                                       \/\/ IID840\n+    \"__ eshrq(r14, r27, 2, false);\",                                                      \/\/ IID841\n+    \"__ eshrq(rax, r11, 2, false);\",                                                      \/\/ IID842\n+    \"__ eshrq(r9, r9, 16, false);\",                                                       \/\/ IID843\n+    \"__ eshrq(rdx, r31, 2, true);\",                                                       \/\/ IID844\n+    \"__ eshrq(rax, r14, 2, true);\",                                                       \/\/ IID845\n+    \"__ eshrq(r12, r12, 8, true);\",                                                       \/\/ IID846\n+    \"__ esubq(r10, r28, 1, false);\",                                                      \/\/ IID847\n+    \"__ esubq(rax, r8, 1, false);\",                                                       \/\/ IID848\n+    \"__ esubq(rcx, rcx, 16777216, false);\",                                               \/\/ IID849\n+    \"__ esubq(rdx, rbx, 16777216, true);\",                                                \/\/ IID850\n+    \"__ esubq(rax, r18, 16777216, true);\",                                                \/\/ IID851\n+    \"__ esubq(r27, r27, 65536, true);\",                                                   \/\/ IID852\n+    \"__ exorq(r30, rcx, 4096, false);\",                                                   \/\/ IID853\n+    \"__ exorq(rax, r21, 4096, false);\",                                                   \/\/ IID854\n+    \"__ exorq(rcx, rcx, 16777216, false);\",                                               \/\/ IID855\n+    \"__ exorq(r21, r12, 1, true);\",                                                       \/\/ IID856\n+    \"__ exorq(rax, rdx, 1, true);\",                                                       \/\/ IID857\n+    \"__ exorq(rbx, rbx, 16777216, true);\",                                                \/\/ IID858\n+    \"__ eorq_imm32(r11, rdx, 65536, false);\",                                             \/\/ IID859\n+    \"__ eorq_imm32(rax, r14, 65536, false);\",                                             \/\/ IID860\n+    \"__ eorq_imm32(r14, r14, 262144, false);\",                                            \/\/ IID861\n+    \"__ eorq_imm32(r25, r29, 262144, false);\",                                            \/\/ IID862\n+    \"__ eorq_imm32(rax, r21, 262144, false);\",                                            \/\/ IID863\n+    \"__ eorq_imm32(r11, r11, 16777216, false);\",                                          \/\/ IID864\n+    \"__ esubq_imm32(r29, r19, 67108864, false);\",                                         \/\/ IID865\n+    \"__ esubq_imm32(rax, r11, 67108864, false);\",                                         \/\/ IID866\n+    \"__ esubq_imm32(r18, r18, 67108864, false);\",                                         \/\/ IID867\n+    \"__ esubq_imm32(r28, r23, 4194304, true);\",                                           \/\/ IID868\n+    \"__ esubq_imm32(rax, r21, 4194304, true);\",                                           \/\/ IID869\n+    \"__ esubq_imm32(r16, r16, 16777216, true);\",                                          \/\/ IID870\n+    \"__ eaddq(r8, r25, Address(r26, r8, (Address::ScaleFactor)1, +0x10633def), false);\",  \/\/ IID871\n+    \"__ eaddq(r13, r13, Address(r18, r16, (Address::ScaleFactor)1, -0x74204508), false);\", \/\/ IID872\n+    \"__ eaddq(r17, r26, Address(r12, +0x23a80abf), true);\",                               \/\/ IID873\n+    \"__ eaddq(r9, r9, Address(r29, r19, (Address::ScaleFactor)0, -0x29e9e52), true);\",    \/\/ IID874\n+    \"__ eandq(r9, r28, Address(rcx, r25, (Address::ScaleFactor)2, +0x4261ffaa), false);\", \/\/ IID875\n+    \"__ eandq(r27, r27, Address(rdx, r28, (Address::ScaleFactor)0, -0x26bdc9c1), false);\", \/\/ IID876\n+    \"__ eandq(r14, r11, Address(r16, +0x63ba0ddf), true);\",                               \/\/ IID877\n+    \"__ eandq(r8, r8, Address(r22, r25, (Address::ScaleFactor)1, -0x43b6ab44), true);\",   \/\/ IID878\n+    \"__ eorq(r19, rcx, Address(r27, rcx, (Address::ScaleFactor)2, -0x7f687fc6), false);\", \/\/ IID879\n+    \"__ eorq(r19, r19, Address(rbx, r26, (Address::ScaleFactor)1, -0x486db7ea), false);\", \/\/ IID880\n+    \"__ eorq(r30, r10, Address(r14, r18, (Address::ScaleFactor)3, +0x14884884), true);\",  \/\/ IID881\n+    \"__ eorq(r27, r27, Address(r29, +0x20337180), true);\",                                \/\/ IID882\n+    \"__ eimulq(rcx, r21, Address(r21, rbx, (Address::ScaleFactor)0, -0x3303888e), false);\", \/\/ IID883\n+    \"__ eimulq(rdx, rdx, Address(r28, r9, (Address::ScaleFactor)3, -0x7ad8f741), false);\", \/\/ IID884\n+    \"__ eimulq(r8, r29, Address(r17, r12, (Address::ScaleFactor)0, +0x6e85396a), true);\", \/\/ IID885\n+    \"__ eimulq(r16, r16, Address(r19, r10, (Address::ScaleFactor)3, -0x49599300), true);\", \/\/ IID886\n+    \"__ esubq(r20, r17, Address(r13, r22, (Address::ScaleFactor)0, +0x1d219a4f), false);\", \/\/ IID887\n+    \"__ esubq(r25, r25, Address(r21, r21, (Address::ScaleFactor)3, -0x6868a8c7), false);\", \/\/ IID888\n+    \"__ esubq(r20, r24, Address(rbx, r20, (Address::ScaleFactor)2, +0x32c59da6), true);\", \/\/ IID889\n+    \"__ esubq(r8, r8, Address(r12, r17, (Address::ScaleFactor)0, -0x26be2dcf), true);\",   \/\/ IID890\n+    \"__ exorq(rdx, r19, Address(r9, +0x7d903b91), false);\",                               \/\/ IID891\n+    \"__ exorq(r28, r28, Address(r29, r27, (Address::ScaleFactor)2, +0x53091f6f), false);\", \/\/ IID892\n+    \"__ exorq(r17, r16, Address(r27, +0x7c6e9207), true);\",                               \/\/ IID893\n+    \"__ exorq(r15, r15, Address(r13, r24, (Address::ScaleFactor)3, -0x75c87960), true);\", \/\/ IID894\n+    \"__ eaddq(r16, rbx, r18, false);\",                                                    \/\/ IID895\n+    \"__ eaddq(r24, r24, r18, false);\",                                                    \/\/ IID896\n+    \"__ eaddq(r9, r15, r9, false);\",                                                      \/\/ IID897\n+    \"__ eaddq(r19, r26, r13, true);\",                                                     \/\/ IID898\n+    \"__ eaddq(r28, r28, r22, true);\",                                                     \/\/ IID899\n+    \"__ eaddq(r22, r11, r22, true);\",                                                     \/\/ IID900\n+    \"__ eadcxq(rcx, r12, r13);\",                                                          \/\/ IID901\n+    \"__ eadcxq(r30, r30, r12);\",                                                          \/\/ IID902\n+    \"__ eadoxq(r28, r14, r18);\",                                                          \/\/ IID903\n+    \"__ eadoxq(r30, r30, r19);\",                                                          \/\/ IID904\n+    \"__ eandq(r20, r14, r14, false);\",                                                    \/\/ IID905\n+    \"__ eandq(r17, r17, r23, false);\",                                                    \/\/ IID906\n+    \"__ eandq(r17, r14, r17, false);\",                                                    \/\/ IID907\n+    \"__ eandq(r19, r20, r15, true);\",                                                     \/\/ IID908\n+    \"__ eandq(rbx, rbx, r13, true);\",                                                     \/\/ IID909\n+    \"__ eandq(r22, r30, r22, true);\",                                                     \/\/ IID910\n+    \"__ eimulq(r17, r24, rcx, false);\",                                                   \/\/ IID911\n+    \"__ eimulq(r21, r21, r8, false);\",                                                    \/\/ IID912\n+    \"__ eimulq(r29, r21, r29, false);\",                                                   \/\/ IID913\n+    \"__ eimulq(r27, r13, r23, true);\",                                                    \/\/ IID914\n+    \"__ eimulq(r26, r26, r8, true);\",                                                     \/\/ IID915\n+    \"__ eimulq(r22, r13, r22, true);\",                                                    \/\/ IID916\n+    \"__ eorq(r11, rdx, r29, false);\",                                                     \/\/ IID917\n+    \"__ eorq(rdx, rdx, r31, false);\",                                                     \/\/ IID918\n+    \"__ eorq(r10, r29, r10, false);\",                                                     \/\/ IID919\n+    \"__ eorq(r27, r28, rcx, true);\",                                                      \/\/ IID920\n+    \"__ eorq(r25, r25, r9, true);\",                                                       \/\/ IID921\n+    \"__ eorq(rcx, r8, rcx, true);\",                                                       \/\/ IID922\n+    \"__ esubq(rcx, r10, r16, false);\",                                                    \/\/ IID923\n+    \"__ esubq(r17, r17, rcx, false);\",                                                    \/\/ IID924\n+    \"__ esubq(r13, r21, r24, true);\",                                                     \/\/ IID925\n+    \"__ esubq(r31, r31, r28, true);\",                                                     \/\/ IID926\n+    \"__ exorq(r23, r28, r23, false);\",                                                    \/\/ IID927\n+    \"__ exorq(r10, r10, r11, false);\",                                                    \/\/ IID928\n+    \"__ exorq(r19, r18, r19, false);\",                                                    \/\/ IID929\n+    \"__ exorq(r31, r9, rdx, true);\",                                                      \/\/ IID930\n+    \"__ exorq(r13, r13, r9, true);\",                                                      \/\/ IID931\n+    \"__ exorq(rcx, r10, rcx, true);\",                                                     \/\/ IID932\n+    \"__ eshldq(r12, r24, r22, 8, false);\",                                                \/\/ IID933\n+    \"__ eshldq(r25, r25, r25, 8, false);\",                                                \/\/ IID934\n+    \"__ eshldq(r21, r20, r15, 8, true);\",                                                 \/\/ IID935\n+    \"__ eshldq(r21, r21, r10, 8, true);\",                                                 \/\/ IID936\n+    \"__ eshrdq(r18, r18, r8, 2, false);\",                                                 \/\/ IID937\n+    \"__ eshrdq(r26, r26, r29, 8, false);\",                                                \/\/ IID938\n+    \"__ eshrdq(r29, r26, r19, 2, true);\",                                                 \/\/ IID939\n+    \"__ eshrdq(r12, r12, rcx, 4, true);\",                                                 \/\/ IID940\n+    \"__ ecmovq (Assembler::Condition::overflow, r21, r22, r23);\",                         \/\/ IID941\n+    \"__ ecmovq (Assembler::Condition::overflow, r9, r9, r13);\",                           \/\/ IID942\n+    \"__ ecmovq (Assembler::Condition::noOverflow, rcx, r23, r24);\",                       \/\/ IID943\n+    \"__ ecmovq (Assembler::Condition::noOverflow, r28, r28, rdx);\",                       \/\/ IID944\n+    \"__ ecmovq (Assembler::Condition::below, r14, r31, r23);\",                            \/\/ IID945\n+    \"__ ecmovq (Assembler::Condition::below, r30, r30, r23);\",                            \/\/ IID946\n+    \"__ ecmovq (Assembler::Condition::aboveEqual, r10, r29, r22);\",                       \/\/ IID947\n+    \"__ ecmovq (Assembler::Condition::aboveEqual, rbx, rbx, r26);\",                       \/\/ IID948\n+    \"__ ecmovq (Assembler::Condition::zero, r23, r21, r13);\",                             \/\/ IID949\n+    \"__ ecmovq (Assembler::Condition::zero, r10, r10, r20);\",                             \/\/ IID950\n+    \"__ ecmovq (Assembler::Condition::notZero, rbx, r9, r29);\",                           \/\/ IID951\n+    \"__ ecmovq (Assembler::Condition::notZero, r16, r16, r30);\",                          \/\/ IID952\n+    \"__ ecmovq (Assembler::Condition::belowEqual, r13, rcx, r29);\",                       \/\/ IID953\n+    \"__ ecmovq (Assembler::Condition::belowEqual, r31, r31, r13);\",                       \/\/ IID954\n+    \"__ ecmovq (Assembler::Condition::above, r27, r9, r30);\",                             \/\/ IID955\n+    \"__ ecmovq (Assembler::Condition::above, r26, r26, r20);\",                            \/\/ IID956\n+    \"__ ecmovq (Assembler::Condition::negative, r8, r12, r22);\",                          \/\/ IID957\n+    \"__ ecmovq (Assembler::Condition::negative, r31, r31, r17);\",                         \/\/ IID958\n+    \"__ ecmovq (Assembler::Condition::positive, r29, rcx, r25);\",                         \/\/ IID959\n+    \"__ ecmovq (Assembler::Condition::positive, r22, r22, r14);\",                         \/\/ IID960\n+    \"__ ecmovq (Assembler::Condition::parity, rcx, r27, r9);\",                            \/\/ IID961\n+    \"__ ecmovq (Assembler::Condition::parity, r22, r22, r11);\",                           \/\/ IID962\n+    \"__ ecmovq (Assembler::Condition::noParity, r14, r19, r24);\",                         \/\/ IID963\n+    \"__ ecmovq (Assembler::Condition::noParity, r24, r24, r17);\",                         \/\/ IID964\n+    \"__ ecmovq (Assembler::Condition::less, r17, r19, r30);\",                             \/\/ IID965\n+    \"__ ecmovq (Assembler::Condition::less, r19, r19, r14);\",                             \/\/ IID966\n+    \"__ ecmovq (Assembler::Condition::greaterEqual, r25, r11, r29);\",                     \/\/ IID967\n+    \"__ ecmovq (Assembler::Condition::greaterEqual, r12, r12, r26);\",                     \/\/ IID968\n+    \"__ ecmovq (Assembler::Condition::lessEqual, r11, rbx, r10);\",                        \/\/ IID969\n+    \"__ ecmovq (Assembler::Condition::lessEqual, rdx, rdx, r22);\",                        \/\/ IID970\n+    \"__ ecmovq (Assembler::Condition::greater, r14, r15, r23);\",                          \/\/ IID971\n+    \"__ ecmovq (Assembler::Condition::greater, r8, r8, r24);\",                            \/\/ IID972\n+    \"__ ecmovq (Assembler::Condition::overflow, rbx, r31, Address(r10, r8, (Address::ScaleFactor)3, -0x313f60e0));\", \/\/ IID973\n+    \"__ ecmovq (Assembler::Condition::overflow, r23, r23, Address(rcx, r24, (Address::ScaleFactor)2, +0x17f41d9c));\", \/\/ IID974\n+    \"__ ecmovq (Assembler::Condition::noOverflow, r31, r11, Address(r16, +0x2c018942));\", \/\/ IID975\n+    \"__ ecmovq (Assembler::Condition::noOverflow, r11, r11, Address(r16, r20, (Address::ScaleFactor)3, +0x674b6a55));\", \/\/ IID976\n+    \"__ ecmovq (Assembler::Condition::below, r9, r13, Address(r9, rcx, (Address::ScaleFactor)0, +0x394a11df));\", \/\/ IID977\n+    \"__ ecmovq (Assembler::Condition::below, r30, r30, Address(rdx, r22, (Address::ScaleFactor)1, -0x6c362b88));\", \/\/ IID978\n+    \"__ ecmovq (Assembler::Condition::aboveEqual, r13, rcx, Address(r24, rcx, (Address::ScaleFactor)3, +0x46500b66));\", \/\/ IID979\n+    \"__ ecmovq (Assembler::Condition::aboveEqual, r24, r24, Address(r18, r25, (Address::ScaleFactor)1, +0x53283b7c));\", \/\/ IID980\n+    \"__ ecmovq (Assembler::Condition::zero, r23, r25, Address(r15, r9, (Address::ScaleFactor)0, -0x5f03031e));\", \/\/ IID981\n+    \"__ ecmovq (Assembler::Condition::zero, r25, r25, Address(r28, r16, (Address::ScaleFactor)1, -0x53cef514));\", \/\/ IID982\n+    \"__ ecmovq (Assembler::Condition::notZero, rbx, r25, Address(r24, r25, (Address::ScaleFactor)2, -0x66caac87));\", \/\/ IID983\n+    \"__ ecmovq (Assembler::Condition::notZero, r16, r16, Address(r27, r30, (Address::ScaleFactor)3, +0x797f455d));\", \/\/ IID984\n+    \"__ ecmovq (Assembler::Condition::belowEqual, r25, r30, Address(r18, r18, (Address::ScaleFactor)1, +0x1c9daacd));\", \/\/ IID985\n+    \"__ ecmovq (Assembler::Condition::belowEqual, r22, r22, Address(rcx, r25, (Address::ScaleFactor)1, -0x3dcbfaa9));\", \/\/ IID986\n+    \"__ ecmovq (Assembler::Condition::above, r24, r26, Address(r25, +0x747060b5));\",      \/\/ IID987\n+    \"__ ecmovq (Assembler::Condition::above, r8, r8, Address(r24, r20, (Address::ScaleFactor)3, +0x47d285f6));\", \/\/ IID988\n+    \"__ ecmovq (Assembler::Condition::negative, r12, r16, Address(r13, r10, (Address::ScaleFactor)2, +0x34e5b214));\", \/\/ IID989\n+    \"__ ecmovq (Assembler::Condition::negative, rdx, rdx, Address(r15, r19, (Address::ScaleFactor)0, -0x405138b1));\", \/\/ IID990\n+    \"__ ecmovq (Assembler::Condition::positive, r18, r21, Address(rbx, r13, (Address::ScaleFactor)2, +0x51b19197));\", \/\/ IID991\n+    \"__ ecmovq (Assembler::Condition::positive, r24, r24, Address(r11, r31, (Address::ScaleFactor)3, +0x3e01520a));\", \/\/ IID992\n+    \"__ ecmovq (Assembler::Condition::parity, r29, r26, Address(r10, r25, (Address::ScaleFactor)3, -0x5f7c3872));\", \/\/ IID993\n+    \"__ ecmovq (Assembler::Condition::parity, r11, r11, Address(r22, r10, (Address::ScaleFactor)3, -0x68731453));\", \/\/ IID994\n+    \"__ ecmovq (Assembler::Condition::noParity, r20, r15, Address(r9, r25, (Address::ScaleFactor)0, +0x4a37edaa));\", \/\/ IID995\n+    \"__ ecmovq (Assembler::Condition::noParity, r31, r31, Address(r9, r20, (Address::ScaleFactor)0, +0x4f999f86));\", \/\/ IID996\n+    \"__ ecmovq (Assembler::Condition::less, r18, r23, Address(r9, r27, (Address::ScaleFactor)0, -0x3410441d));\", \/\/ IID997\n+    \"__ ecmovq (Assembler::Condition::less, r16, r16, Address(r24, r10, (Address::ScaleFactor)3, +0x52ed66ee));\", \/\/ IID998\n+    \"__ ecmovq (Assembler::Condition::greaterEqual, r11, r18, Address(rcx, +0x1de09163));\", \/\/ IID999\n+    \"__ ecmovq (Assembler::Condition::greaterEqual, r14, r14, Address(r24, r23, (Address::ScaleFactor)1, +0x5df3b4da));\", \/\/ IID1000\n+    \"__ ecmovq (Assembler::Condition::lessEqual, r15, r14, Address(r30, r20, (Address::ScaleFactor)1, +0x5c9ab976));\", \/\/ IID1001\n+    \"__ ecmovq (Assembler::Condition::lessEqual, r26, r26, Address(r18, r27, (Address::ScaleFactor)2, -0xd8c329));\", \/\/ IID1002\n+    \"__ ecmovq (Assembler::Condition::greater, r29, r9, Address(r30, r20, (Address::ScaleFactor)3, -0x37a9cf8d));\", \/\/ IID1003\n+    \"__ ecmovq (Assembler::Condition::greater, r20, r20, Address(r8, rbx, (Address::ScaleFactor)1, +0x1bdc7def));\", \/\/ IID1004\n","filename":"test\/hotspot\/gtest\/x86\/asmtest.out.h","additions":2802,"deletions":2466,"binary":false,"changes":5268,"status":"modified"},{"patch":"@@ -95,0 +95,2 @@\n+commutative_instrs = ['imul', 'add', 'and', 'xor', 'or']\n+\n@@ -403,0 +405,9 @@\n+        self.demote = True\n+    \n+    def astr(self):\n+        if self.demote:\n+            ops = [op.cstr() for op in self.operands]\n+            # imul does not support RegMemReg\n+            if self._aname in commutative_instrs[1:] and ops[0] == ops[2] and (not self.no_flag):\n+                return  f'{self._aname} ' + ', '.join([op.astr() for op in self.operands[:2]])\n+        return super().astr()\n@@ -451,0 +462,3 @@\n+            if self._aname in commutative_instrs and ops[0] == ops[2] and (not self.no_flag):\n+                return  hdr + f'{self._aname} ' + ', '.join([op.astr() for op in self.operands[:2]])\n+            \n@@ -577,0 +591,12 @@\n+            \n+            demote = True if TEST_DEMOTION else False\n+            commute = True if op[1] in commutative_instrs else False\n+            if RegOp in [RegRegRegNddInstruction] and demote and commute :\n+                for i in range(len(test_regs) if full_set else 1):\n+                    test_reg1 = test_regs[i] if full_set else random.choice(test_regs)\n+                    test_reg2 = test_regs[(i + 2) % len(test_regs)] if full_set else random.choice(test_regs)\n+                    test_reg3 = test_reg1\n+                    \n+                    lp64_flag = handle_lp64_flag(lp64_flag, print_lp64_flag, test_reg1, test_reg2, test_reg3)\n+                    instr = RegOp(*op, reg1=test_reg1, reg2=test_reg2, reg3=test_reg3)\n+                    print_instruction(instr, lp64_flag, print_lp64_flag)\n@@ -702,1 +728,1 @@\n-            demote_options = [False] if TEST_DEMOTION and RegOp not in [RegMemRegNddInstruction] else [False, True]\n+            demote_options = [False, True]\n@@ -1026,0 +1052,2 @@\n+        ('eandl', 'and', 32, False),\n+        ('eandl', 'and', 32, True),\n","filename":"test\/hotspot\/gtest\/x86\/x86-asmtest.py","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -557,11 +557,1 @@\n- -runtime\/cds\/appcds\/dynamicArchive\/LambdaContainsOldInf.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/LambdaCustomLoader.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/LambdaForOldInfInBaseArchive.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/LambdasInTwoArchives.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/ModulePath.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/NestHostOldInf.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/OldClassAndInf.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/OldClassInBaseArchive.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/OldClassVerifierTrouble.java \\\n- -runtime\/cds\/appcds\/dynamicArchive\/RedefineCallerClassTest.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+        double timeoutFactor = 1.0;\n+        try {\n+            timeoutFactor = Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n+        } catch (NumberFormatException ignored) {}\n+\n@@ -52,1 +57,2 @@\n-        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=2000\", \"--version\")\n+        int timeout = (int)(500.0 * timeoutFactor);\n+        ProcessTools.executeTestJava(\"-Xcomp\", \"-XX:CompileTaskTimeout=\" + timeout, \"--version\")\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompileTaskTimeout.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.generators.RestrictableGenerator;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.ForceInline;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8356813\n+ * @summary Test that Value method of ModINode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.ModINodeValueTests\n+ *\/\n+public class ModINodeValueTests {\n+    private static final RestrictableGenerator<Integer> INT_GEN = Generators.G.ints();\n+    private static final int POS_INT = INT_GEN.restricted(1, Integer.MAX_VALUE).next();\n+    private static final int NEG_INT = INT_GEN.restricted(Integer.MIN_VALUE, -1).next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"nonNegativeDividend\", \"nonNegativeDividendInRange\",\n+        \"negativeDividend\", \"negativeDividendInRange\",\n+        \"modByKnownBoundsUpper\", \"modByKnownBoundsUpperInRange\",\n+        \"modByKnownBoundsLower\", \"modByKnownBoundsLowerInRange\",\n+        \"modByKnownBoundsLimitedByDividendUpper\", \"modByKnownBoundsLimitedByDividendUpperInRange\",\n+        \"modByKnownBoundsLimitedByDividendLower\", \"modByKnownBoundsLimitedByDividendLowerInRange\",\n+        \"testRandomLimits\"\n+    })\n+    public void runMethod() {\n+        int a = INT_GEN.next();\n+        int b = INT_GEN.next();\n+\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int x, int y) {\n+        Asserts.assertEQ(x != 0 && POS_INT % x < 0, nonNegativeDividend(x));\n+        Asserts.assertEQ(x != 0 && POS_INT % x <= 0, nonNegativeDividendInRange(x));\n+        Asserts.assertEQ(x != 0 && NEG_INT % x > 0, negativeDividend(x));\n+        Asserts.assertEQ(x != 0 && NEG_INT % x >= 0, negativeDividendInRange(x));\n+        Asserts.assertEQ(x % (((byte) y) + 129) > 255, modByKnownBoundsUpper(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) >= 255, modByKnownBoundsUpperInRange(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) < -255, modByKnownBoundsLower(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129) <= -255, modByKnownBoundsLowerInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) > 127, modByKnownBoundsLimitedByDividendUpper(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) >= 127, modByKnownBoundsLimitedByDividendUpperInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) < -128, modByKnownBoundsLimitedByDividendLower(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1) <= -128, modByKnownBoundsLimitedByDividendLowerInRange(x, y));\n+\n+        int res;\n+        try {\n+            res = testRandomLimitsInterpreted(x, y);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testRandomLimits(x, y);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testRandomLimits(x, y));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., POS_INT % x < 0 => false.\n+    public boolean nonNegativeDividend(int x) {\n+        return x != 0 && POS_INT % x < 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., POS_INT % x < 0 => false.\n+    \/\/ This uses <= to verify the % is not optimized away\n+    public boolean nonNegativeDividendInRange(int x) {\n+        return x != 0 && POS_INT % x <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., NEG_INT % x > 0 => false.\n+    public boolean negativeDividend(int x) {\n+        return x != 0 && NEG_INT % x > 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., NEG_INT % x > 0 => false.\n+    \/\/ This uses >= to verify the % is not optimized away\n+    public boolean negativeDividendInRange(int x) {\n+        return x != 0 && NEG_INT % x >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpper(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129) > 255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpperInRange(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129) >= 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLower(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129) < -255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLowerInRange(int x, int y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129) <= -255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpper(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1) > 127;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpperInRange(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1) >= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_I, IRNode.CMP_I})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLower(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1) < -128;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_I, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLowerInRange(int x, int y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1) <= -128;\n+    }\n+\n+    private static final int LIMIT_1 = INT_GEN.next();\n+    private static final int LIMIT_2 = INT_GEN.next();\n+    private static final int LIMIT_3 = INT_GEN.next();\n+    private static final int LIMIT_4 = INT_GEN.next();\n+    private static final int LIMIT_5 = INT_GEN.next();\n+    private static final int LIMIT_6 = INT_GEN.next();\n+    private static final int LIMIT_7 = INT_GEN.next();\n+    private static final int LIMIT_8 = INT_GEN.next();\n+    private static final Range RANGE_1 = Range.generate(INT_GEN);\n+    private static final Range RANGE_2 = Range.generate(INT_GEN);\n+\n+    @Test\n+    public int testRandomLimits(int x, int y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        int z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @DontCompile\n+    public int testRandomLimitsInterpreted(int x, int y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        int z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    record Range(int lo, int hi) {\n+        Range {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        @ForceInline\n+        int clamp(int v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static Range generate(Generator<Integer> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new Range(a, b);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModINodeValueTests.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.Generator;\n+import compiler.lib.generators.Generators;\n+import compiler.lib.ir_framework.DontCompile;\n+import compiler.lib.ir_framework.ForceInline;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8356813\n+ * @summary Test that Value method of ModLNode is working as expected.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.ModLNodeValueTests\n+ *\/\n+public class ModLNodeValueTests {\n+    private static final Generator<Long> LONG_GEN = Generators.G.longs();\n+    private static final long POS_LONG = Generators.G.longs().restricted(1L, Long.MAX_VALUE).next();\n+    private static final long NEG_LONG = Generators.G.longs().restricted(Long.MIN_VALUE, -1L).next();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+        \"nonNegativeDividend\", \"nonNegativeDividendInRange\",\n+        \"negativeDividend\", \"negativeDividendInRange\",\n+        \"modByKnownBoundsUpper\", \"modByKnownBoundsUpperInRange\",\n+        \"modByKnownBoundsLower\", \"modByKnownBoundsLowerInRange\",\n+        \"modByKnownBoundsLimitedByDividendUpper\", \"modByKnownBoundsLimitedByDividendUpperInRange\",\n+        \"modByKnownBoundsLimitedByDividendLower\", \"modByKnownBoundsLimitedByDividendLowerInRange\",\n+        \"testRandomLimits\"\n+    })\n+    public void runMethod() {\n+        long a = LONG_GEN.next();\n+        long b = LONG_GEN.next();\n+\n+        long min = Long.MIN_VALUE;\n+        long max = Long.MAX_VALUE;\n+\n+        assertResult(0, 0);\n+        assertResult(a, b);\n+        assertResult(min, min);\n+        assertResult(max, max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(long x, long y) {\n+        Asserts.assertEQ(x != 0 && POS_LONG % x < 0, nonNegativeDividend(x));\n+        Asserts.assertEQ(x != 0 && POS_LONG % x <= 0, nonNegativeDividendInRange(x));\n+        Asserts.assertEQ(x != 0 && NEG_LONG % x > 0, negativeDividend(x));\n+        Asserts.assertEQ(x != 0 && NEG_LONG % x >= 0, negativeDividendInRange(x));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) > 255, modByKnownBoundsUpper(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) >= 255, modByKnownBoundsUpperInRange(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) < -255, modByKnownBoundsLower(x, y));\n+        Asserts.assertEQ(x % (((byte) y) + 129L) <= -255, modByKnownBoundsLowerInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) > 127, modByKnownBoundsLimitedByDividendUpper(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) >= 127, modByKnownBoundsLimitedByDividendUpperInRange(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) < -128, modByKnownBoundsLimitedByDividendLower(x, y));\n+        Asserts.assertEQ(((byte) x) % (((char) y) + 1L) <= -128, modByKnownBoundsLimitedByDividendLowerInRange(x, y));\n+\n+        int res;\n+        try {\n+            res = testRandomLimitsInterpreted(x, y);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testRandomLimits(x, y);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testRandomLimits(x, y));\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    public boolean nonNegativeDividend(long x) {\n+        return x != 0 && POS_LONG % x < 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., posVal % x < 0 => false.\n+    \/\/ This uses <= to verify the % is not optimized away\n+    public boolean nonNegativeDividendInRange(long x) {\n+        return x != 0 && POS_LONG % x <= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    public boolean negativeDividend(long x) {\n+        return x != 0 && NEG_LONG % x > 0;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The sign of the result of % is the same as the sign of the dividend,\n+    \/\/ i.e., negValue % x > 0 => false.\n+    \/\/ This uses >= to verify the % is not optimized away\n+    public boolean negativeDividendInRange(long x) {\n+        return x != 0 && NEG_LONG % x >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpper(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129L) > 255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor.\n+    public boolean modByKnownBoundsUpperInRange(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129L) >= 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLower(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        return x % (((byte) y) + 129L) < -255;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The magnitude of the result is less than the divisor\n+    public boolean modByKnownBoundsLowerInRange(long x, long y) {\n+        \/\/ d = ((byte) y) + 129 => [1, 256] divisor\n+        \/\/ x % d => [-255, 255]\n+        \/\/ in bounds, cannot optimize\n+        return x % (((byte) y) + 129L) <= -255;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpper(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1L) > 127;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendUpperInRange(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1L) >= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.MOD_L, IRNode.CMP_L})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLower(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        return ((byte) x) % (((char) y) + 1L) < -128;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MOD_L, \"1\"})\n+    \/\/ The result is closer to zero than or equal to the dividend.\n+    public boolean modByKnownBoundsLimitedByDividendLowerInRange(long x, long y) {\n+        \/\/ d = ((char) y) + 1 => [1, 65536] divisor\n+        \/\/ e = ((byte) x) => [-128, 127]\n+        \/\/ e % d => [-128, 127]\n+        \/\/ in bounds, cannot optimize\n+        return ((byte) x) % (((char) y) + 1L) <= -128;\n+    }\n+\n+\n+    private static final long LIMIT_1 = LONG_GEN.next();\n+    private static final long LIMIT_2 = LONG_GEN.next();\n+    private static final long LIMIT_3 = LONG_GEN.next();\n+    private static final long LIMIT_4 = LONG_GEN.next();\n+    private static final long LIMIT_5 = LONG_GEN.next();\n+    private static final long LIMIT_6 = LONG_GEN.next();\n+    private static final long LIMIT_7 = LONG_GEN.next();\n+    private static final long LIMIT_8 = LONG_GEN.next();\n+    private static final Range RANGE_1 = Range.generate(LONG_GEN);\n+    private static final Range RANGE_2 = Range.generate(LONG_GEN);\n+\n+    @Test\n+    public int testRandomLimits(long x, long y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        long z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @DontCompile\n+    public int testRandomLimitsInterpreted(long x, long y) {\n+        x = RANGE_1.clamp(x);\n+        y = RANGE_2.clamp(y);\n+        long z = x % y;\n+\n+        int sum = 0;\n+        if (z < LIMIT_1) sum += 1;\n+        if (z < LIMIT_2) sum += 2;\n+        if (z < LIMIT_3) sum += 4;\n+        if (z < LIMIT_4) sum += 8;\n+        if (z > LIMIT_5) sum += 16;\n+        if (z > LIMIT_6) sum += 32;\n+        if (z > LIMIT_7) sum += 64;\n+        if (z > LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    record Range(long lo, long hi) {\n+        Range {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        @ForceInline\n+        long clamp(long v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static Range generate(Generator<Long> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new Range(a, b);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/ModLNodeValueTests.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361699\n+ * @summary Check that NSR state propagate correctly to initially reducible Phis\n+ *          and turns them into non-reducible Phis.\n+ * @run main\/othervm -XX:CompileCommand=compileonly,*TestReduceAllocationNotReducibleAnymore*::*\n+ *                   -XX:CompileCommand=dontinline,*TestReduceAllocationNotReducibleAnymore*::*\n+ *                   -Xcomp compiler.escapeAnalysis.TestReduceAllocationNotReducibleAnymore\n+ * @run main compiler.escapeAnalysis.TestReduceAllocationNotReducibleAnymore\n+ *\/\n+\n+package compiler.escapeAnalysis;\n+\n+public class TestReduceAllocationNotReducibleAnymore {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 100; i++) {\n+            test(4, null);\n+        }\n+    }\n+\n+    static void test(int x, A a) {\n+        Object[] objects = { new Object() };\n+        Object object = new Object();\n+        for (int i = 0; i < 150; i++) {\n+            try {\n+                objects[x] = object;\n+                object = new byte[10];\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+            }\n+            try {\n+                a.foo();\n+            } catch (NullPointerException e) {\n+            }\n+        }\n+    }\n+\n+    class A {\n+        void foo() {}\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestReduceAllocationNotReducibleAnymore.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8367483\n+ * @summary Missed worklist notification during IGVN for CastX2P(SubX(x, y)) pattern,\n+ *          leads to missed optimization.\n+ * @run main\/othervm\n+ *           -XX:CompileCommand=compileonly,compiler.igvn.MissedOptimizationWithCastX2PSubX::test\n+ *           -XX:-TieredCompilation\n+ *           -XX:+IgnoreUnrecognizedVMOptions\n+ *           -XX:VerifyIterativeGVN=1110\n+ *           compiler.igvn.MissedOptimizationWithCastX2PSubX\n+ * @run main compiler.igvn.MissedOptimizationWithCastX2PSubX\n+ *\/\n+\n+package compiler.igvn;\n+\n+import java.lang.foreign.*;\n+\n+public class MissedOptimizationWithCastX2PSubX {\n+    public static void main(String[] args) {\n+        MemorySegment a  = Arena.ofAuto().allocate(74660);\n+        MemorySegment b  = Arena.ofAuto().allocate(74660);\n+\n+        for (int i = 0; i < 1_000; i++) {\n+            test(a, 69830\/2 - 100, b, -10_000, 0, 1_000);\n+        }\n+    }\n+\n+    public static void test(MemorySegment a, long invarA, MemorySegment b, long invarB, long ivLo, long ivHi) {\n+        for (long i = ivHi-1; i >= ivLo; i-=1) {\n+            a.set(ValueLayout.JAVA_CHAR_UNALIGNED, 69830L + 2L * i + -2L * invarA, (char)42);\n+            b.set(ValueLayout.JAVA_FLOAT_UNALIGNED, 9071L + -4L * i + -4L * invarB, 42);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/MissedOptimizationWithCastX2PSubX.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -955,3 +955,0 @@\n-        if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ConstantPool.class)) && f.getName().equals(\"constantPoolOop\")) {\n-            return true;\n-        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2355,0 +2355,5 @@\n+    public static final String VECTOR_MASK_CMP = PREFIX + \"VECTOR_MASK_CMP\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(VECTOR_MASK_CMP, \"VectorMaskCmp\");\n+    }\n+\n@@ -2765,0 +2770,5 @@\n+    public static final String XOR_V = PREFIX + \"XOR_V\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(XOR_V, \"XorV\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run driver compiler.loopopts.superword.TestAliasingFuzzer vanilla\n+ * @run driver\/timeout=200 compiler.loopopts.superword.TestAliasingFuzzer vanilla\n@@ -45,1 +45,1 @@\n- * @run driver compiler.loopopts.superword.TestAliasingFuzzer random-flags\n+ * @run driver\/timeout=200 compiler.loopopts.superword.TestAliasingFuzzer random-flags\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8361702\n+ * @summary C2: assert(is_dominator(compute_early_ctrl(limit, limit_ctrl), pre_end)) failed: node pinned on loop exit test?\n+  *\n+ * @run main\/othervm -XX:CompileCommand=compileonly,*TestSunkRangeFromPreLoopRCE2*::* -Xbatch TestSunkRangeFromPreLoopRCE2\n+ * @run main TestSunkRangeFromPreLoopRCE2\n+ *\/\n+\n+public class TestSunkRangeFromPreLoopRCE2 {\n+    static int iFld;\n+    static long lArr[] = new long[400];\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 1000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() {\n+        int iArr[] = new int[400];\n+        for (int i = 8; i < 128; i++) {\n+            for (int j = 209; j > 9; j--) {\n+                switch ((j % 5) + 58) {\n+                    case 58:\n+                        iArr[i] = 194;\n+                        break;\n+                    case 59:\n+                        iFld = 3;\n+                    case 62:\n+                    default:\n+                        iArr[1] = i;\n+                }\n+                for (int k = 2; k > 1; --k) {\n+                    lArr[k] -= iFld;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestSunkRangeFromPreLoopRCE2.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8361702\n+ * @summary C2: assert(is_dominator(compute_early_ctrl(limit, limit_ctrl), pre_end)) failed: node pinned on loop exit test?\n+ * @requires vm.flavor == \"server\"\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:LoopUnrollLimit=100 -XX:-UseLoopPredicate -XX:-UseProfiledLoopPredicate TestSunkRangeFromPreLoopRCE3\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8361702\n+ * @summary C2: assert(is_dominator(compute_early_ctrl(limit, limit_ctrl), pre_end)) failed: node pinned on loop exit test?\n+ * @run main TestSunkRangeFromPreLoopRCE3\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestSunkRangeFromPreLoopRCE3 {\n+\n+    static final int nbIterations = 100;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(0);\n+            test1(0);\n+        }\n+    }\n+\n+    private static float test1(int k) {\n+        float v = 0;\n+        int j = 0;\n+        int[] lengths = new int[2];\n+        test1Helper(lengths);\n+        int constantFoldedTo4AfterCCP = 2;\n+        for (; constantFoldedTo4AfterCCP < 4; constantFoldedTo4AfterCCP *= 2);\n+\n+        int constantFoldedTo0AfterCCPAnd1RoundLoopOpts;\n+        for (constantFoldedTo0AfterCCPAnd1RoundLoopOpts = 0; constantFoldedTo0AfterCCPAnd1RoundLoopOpts < 40; constantFoldedTo0AfterCCPAnd1RoundLoopOpts += constantFoldedTo4AfterCCP) {\n+        }\n+        constantFoldedTo0AfterCCPAnd1RoundLoopOpts -= 40;\n+        for (int i = 0; i < nbIterations; i++) {\n+            int arrayLength2 = Integer.max(Integer.min(lengths[j * k], 1000), 0);\n+            float[] array = new float[arrayLength2];\n+            v += array[(constantFoldedTo0AfterCCPAnd1RoundLoopOpts + 1) * i];\n+\n+            int arrayLength = Integer.max(Integer.min(lengths[k], 1000), 0);\n+\n+            v += arrayLength & constantFoldedTo0AfterCCPAnd1RoundLoopOpts;\n+\n+            j = 1;\n+        }\n+        return v;\n+    }\n+\n+    private static void test1Helper(int[] lengths) {\n+        lengths[0] = nbIterations+1;\n+        lengths[1] = nbIterations+1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestSunkRangeFromPreLoopRCE3.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -67,1 +67,1 @@\n-        for (int i = 0; i < 200; i++) {\n+        for (int i = 0; i < 50; i++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/startup\/StartupOutput.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+\/*\n+ * @test\n+ * @bug 8367333\n+ * @requires vm.compiler2.enabled\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressIncrementalInlining\n+ *                   -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,compiler.vectorapi.TestVectorMathLib::test*\n+ *                   compiler.vectorapi.TestVectorMathLib\n+ *\/\n+\n+public class TestVectorMathLib {\n+    private static final VectorSpecies SPECIES = FloatVector.SPECIES_PREFERRED;\n+\n+    static FloatVector testTAN(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.TAN);\n+    }\n+    static FloatVector testTANH(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.TANH);\n+    }\n+    static FloatVector testSIN(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.SIN);\n+    }\n+    static FloatVector testSINH(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.SINH);\n+    }\n+    static FloatVector testCOS(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.COS);\n+    }\n+    static FloatVector testCOSH(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.COSH);\n+    }\n+    static FloatVector testASIN(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.ASIN);\n+    }\n+    static FloatVector testACOS(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.ACOS);\n+    }\n+    static FloatVector testATAN(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.ATAN);\n+    }\n+    static FloatVector testATAN2(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.ATAN2, fv);\n+    }\n+    static FloatVector testCBRT(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.CBRT);\n+    }\n+    static FloatVector testLOG(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.LOG);\n+    }\n+    static FloatVector testLOG10(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.LOG10);\n+    }\n+    static FloatVector testLOG1P(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.LOG1P);\n+    }\n+    static FloatVector testPOW(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.POW, fv);\n+    }\n+    static FloatVector testEXP(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.EXP);\n+    }\n+    static FloatVector testEXPM1(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.EXPM1);\n+    }\n+    static FloatVector testHYPOT(FloatVector fv) {\n+        return fv.lanewise(VectorOperators.HYPOT, fv);\n+    }\n+\n+    public static void main(String[] args) {\n+        FloatVector z = FloatVector.zero(SPECIES);\n+        for (int i = 0; i < 20_000; i++) {\n+            z.neg();  \/\/ unary\n+            z.add(z); \/\/ binary\n+\n+            testTAN(z);\n+            testTANH(z);\n+            testSIN(z);\n+            testSINH(z);\n+            testCOS(z);\n+            testCOSH(z);\n+            testASIN(z);\n+            testACOS(z);\n+            testATAN(z);\n+            testATAN2(z);\n+            testCBRT(z);\n+            testLOG(z);\n+            testLOG10(z);\n+            testLOG1P(z);\n+            testPOW(z);\n+            testEXP(z);\n+            testEXPM1(z);\n+            testHYPOT(z);\n+        }\n+\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMathLib.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,1299 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8354242\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary test combining vector not operation with compare\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorMaskCompareNotTest\n+ *\/\n+\n+public class VectorMaskCompareNotTest {\n+    private static int LENGTH = 128;\n+\n+    private static final VectorSpecies<Byte> B_SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+    private static final VectorSpecies<Short> S_SPECIES = VectorSpecies.ofLargestShape(short.class);\n+    private static final VectorSpecies<Integer> I_SPECIES = VectorSpecies.ofLargestShape(int.class);\n+    private static final VectorSpecies<Long> L_SPECIES = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Float> F_SPECIES = VectorSpecies.ofLargestShape(float.class);\n+    private static final VectorSpecies<Double> D_SPECIES = VectorSpecies.ofLargestShape(double.class);\n+\n+    \/\/ Vector species for vector mask cast operation between int and long types,\n+    \/\/ they must have the same number of elements.\n+    \/\/ For other types, use a vector species of the specified width.\n+    private static final VectorSpecies<Long> L_SPECIES_FOR_CAST = VectorSpecies.ofLargestShape(long.class);\n+    private static final VectorSpecies<Integer> I_SPECIES_FOR_CAST = VectorSpecies.of(int.class, VectorShape.forBitSize(L_SPECIES_FOR_CAST.vectorBitSize() \/ 2));\n+\n+    private static final Generators RD = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ic;\n+    private static long[] la;\n+    private static long[] lb;\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fnan;\n+    private static float[] fpinf;\n+    private static float[] fninf;\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dnan;\n+    private static double[] dpinf;\n+    private static double[] dninf;\n+    private static boolean[] mr;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        bb = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sb = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lb = new long[LENGTH];\n+        fa = new float[LENGTH];\n+        fb = new float[LENGTH];\n+        fnan = new float[LENGTH];\n+        fpinf = new float[LENGTH];\n+        fninf = new float[LENGTH];\n+        da = new double[LENGTH];\n+        db = new double[LENGTH];\n+        dnan = new double[LENGTH];\n+        dpinf = new double[LENGTH];\n+        dninf = new double[LENGTH];\n+        mr = new boolean[LENGTH];\n+\n+        Generator<Integer> iGen = RD.ints();\n+        Generator<Long> lGen = RD.longs();\n+        \/\/ Use uniform generators for floating point numbers not to generate NaN values.\n+        Generator<Float> fGen = RD.uniformFloats(Float.MIN_VALUE, Float.MAX_VALUE);\n+        Generator<Double> dGen = RD.uniformDoubles(Double.MIN_VALUE, Double.MAX_VALUE);\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = iGen.next().byteValue();\n+            bb[i] = iGen.next().byteValue();\n+            sa[i] = iGen.next().shortValue();\n+            sb[i] = iGen.next().shortValue();\n+            ia[i] = iGen.next();\n+            ib[i] = iGen.next();\n+            la[i] = lGen.next();\n+            lb[i] = lGen.next();\n+            fa[i] = fGen.next();\n+            fb[i] = fGen.next();\n+            fnan[i] = Float.NaN;\n+            fpinf[i] = Float.POSITIVE_INFINITY;\n+            fninf[i] = Float.NEGATIVE_INFINITY;\n+            da[i] = dGen.next();\n+            db[i] = dGen.next();\n+            dnan[i] = Double.NaN;\n+            dpinf[i] = Double.POSITIVE_INFINITY;\n+            dninf[i] = Double.NEGATIVE_INFINITY;\n+        }\n+    }\n+\n+    public static int compareUnsigned(Number a, Number b) {\n+        if (a instanceof Byte) {\n+            return Integer.compareUnsigned(Byte.toUnsignedInt(a.byteValue()), Byte.toUnsignedInt(b.byteValue()));\n+        } else if (a instanceof Short) {\n+            return Integer.compareUnsigned(Short.toUnsignedInt(a.shortValue()), Short.toUnsignedInt(b.shortValue()));\n+        } else if (a instanceof Integer) {\n+            return Integer.compareUnsigned(a.intValue(), b.intValue());\n+        } else if (a instanceof Long) {\n+            return Long.compareUnsigned(a.longValue(), b.longValue());\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported type for unsigned comparison: \" + a.getClass() + \", \" + b.getClass());\n+        }\n+    }\n+\n+    public static <T extends Number & Comparable<T>> void compareResults(T a, T b, boolean r, VectorOperators.Comparison op) {\n+        if (op == VectorOperators.EQ) {\n+            \/\/ For floating point numbers, a is not NaN, b may be NaN. If b is NaN,\n+            \/\/ a.compareTo(b) will return 1, 1 != 0 is true, r is expected to be true.\n+            Asserts.assertEquals(a.compareTo(b) != 0, r);\n+        } else if (op == VectorOperators.NE) {\n+            \/\/ For floating point numbers, a is not NaN, b may be NaN. If b is NaN,\n+            \/\/ a.compareTo(b) will return 1, 1 == 0 is false, r is expected to be false.\n+            Asserts.assertEquals(a.compareTo(b) == 0, r);\n+        } else if (op == VectorOperators.LE) {\n+            Asserts.assertEquals(a.compareTo(b) > 0, r);\n+        } else if (op == VectorOperators.GE) {\n+            Asserts.assertEquals(a.compareTo(b) < 0, r);\n+        } else if (op == VectorOperators.LT) {\n+            Asserts.assertEquals(a.compareTo(b) >= 0, r);\n+        } else if (op == VectorOperators.GT) {\n+            Asserts.assertEquals(a.compareTo(b) <= 0, r);\n+        } else if (op == VectorOperators.ULE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) > 0, r);\n+        } else if (op == VectorOperators.UGE) {\n+            Asserts.assertEquals(compareUnsigned(a, b) < 0, r);\n+        } else if (op == VectorOperators.ULT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) >= 0, r);\n+        } else if (op == VectorOperators.UGT) {\n+            Asserts.assertEquals(compareUnsigned(a, b) <= 0, r);\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown comparison operator: \" + op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsByte(VectorSpecies<Byte> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(ba[i], bb[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsShort(VectorSpecies<Short> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(sa[i], sb[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsInt(VectorSpecies<Integer> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(ia[i], ib[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsLong(VectorSpecies<Long> vs, VectorOperators.Comparison op) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(la[i], lb[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsFloat(VectorSpecies<Float> vs, VectorOperators.Comparison op, float[] a, float[] b) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    @DontInline\n+    public static void verifyResultsDouble(VectorSpecies<Double> vs, VectorOperators.Comparison op, double[] a, double[] b) {\n+        for (int i = 0; i < vs.length(); i++) {\n+            compareResults(a[i], b[i], mr[i], op);\n+        }\n+    }\n+\n+    interface VectorMaskOperator {\n+        public VectorMask apply(VectorMask m);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotByte(VectorSpecies<Byte> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        ByteVector av = ByteVector.fromArray(vs, ba, 0);\n+        ByteVector bv = ByteVector.fromArray(vs, bb, 0);\n+        VectorMask<Byte> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotShort(VectorSpecies<Short> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        ShortVector av = ShortVector.fromArray(vs, sa, 0);\n+        ShortVector bv = ShortVector.fromArray(vs, sb, 0);\n+        VectorMask<Short> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotInt(VectorSpecies<Integer> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        IntVector av = IntVector.fromArray(vs, ia, 0);\n+        IntVector bv = IntVector.fromArray(vs, ib, 0);\n+        VectorMask<Integer> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotLong(VectorSpecies<Long> vs, VectorOperators.Comparison op, VectorMaskOperator func) {\n+        LongVector av = LongVector.fromArray(vs, la, 0);\n+        LongVector bv = LongVector.fromArray(vs, lb, 0);\n+        VectorMask<Long> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotFloat(VectorSpecies<Float> vs, VectorOperators.Comparison op, float[] a, float[] b, VectorMaskOperator func) {\n+        FloatVector av = FloatVector.fromArray(vs, a, 0);\n+        FloatVector bv = FloatVector.fromArray(vs, b, 0);\n+        VectorMask<Float> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    @ForceInline\n+    public static void testCompareMaskNotDouble(VectorSpecies<Double> vs, VectorOperators.Comparison op, double[] a, double[] b, VectorMaskOperator func) {\n+        DoubleVector av = DoubleVector.fromArray(vs, a, 0);\n+        DoubleVector bv = DoubleVector.fromArray(vs, b, 0);\n+        VectorMask<Double> m = av.compare(op, bv);\n+        func.apply(m).intoArray(mr, 0);\n+    }\n+\n+    \/\/ Byte tests\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.EQ, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.NE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.NE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.LT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.GT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.LE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.LE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.GE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.GE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.ULT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGT, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.UGT, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.ULE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.ULE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotByte() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.UGE, (m) -> { return B_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotByte(ByteVector.SPECIES_64, VectorOperators.UGE, (m) -> { return m.cast(ShortVector.SPECIES_128).not(); });\n+        verifyResultsByte(ByteVector.SPECIES_64, VectorOperators.UGE);\n+    }\n+\n+    \/\/ Short tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.EQ, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.EQ);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.EQ, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.NE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.NE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.NE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.NE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.LT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.LT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.LT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.GT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.GT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.GT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.LE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.LE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.LE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.LE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.GE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.GE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.GE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.GE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.ULT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.ULT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.ULT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGT, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.UGT, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.UGT);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.UGT, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.ULE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.ULE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.ULE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.ULE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotShort() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.UGE, (m) -> { return S_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotShort(ShortVector.SPECIES_64, VectorOperators.UGE, (m) -> { return IntVector.SPECIES_128.maskAll(true).xor(m.cast(IntVector.SPECIES_128)); });\n+        verifyResultsShort(ShortVector.SPECIES_64, VectorOperators.UGE);\n+        testCompareMaskNotShort(ShortVector.SPECIES_128, VectorOperators.UGE, (m) -> { return m.cast(ByteVector.SPECIES_64).not(); });\n+        verifyResultsShort(ShortVector.SPECIES_128, VectorOperators.UGE);\n+    }\n+\n+    \/\/ Int tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.EQ, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.EQ);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.EQ, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.NE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.NE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.NE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.NE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.LT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.LT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.LT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.GT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.GT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.GT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.LE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.LE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.LE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.LE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.GE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.GE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.GE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.GE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.ULT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.ULT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.ULT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGT, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.UGT, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.UGT);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.UGT, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.ULE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.ULE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.ULE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.ULE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 4\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotInt() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.UGE, (m) -> { return I_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotInt(I_SPECIES_FOR_CAST, VectorOperators.UGE, (m) -> { return L_SPECIES_FOR_CAST.maskAll(true).xor(m.cast(L_SPECIES_FOR_CAST)); });\n+        verifyResultsInt(I_SPECIES_FOR_CAST, VectorOperators.UGE);\n+        testCompareMaskNotInt(IntVector.SPECIES_128, VectorOperators.UGE, (m) -> { return m.cast(ShortVector.SPECIES_64).not(); });\n+        verifyResultsInt(IntVector.SPECIES_128, VectorOperators.UGE);\n+    }\n+\n+    \/\/ Long tests\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.EQ);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.EQ);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.EQ, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.EQ);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.NE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.NE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.NE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.NE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.NE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.LT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.LT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.GT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.GT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareLEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.LE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.LE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.LE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.LE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareGEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.GE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.GE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.GE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.GE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.ULT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.ULT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGTMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGT, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGT);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGT, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGT);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.UGT, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.UGT);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareULEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.ULE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.ULE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.ULE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.ULE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CAST, \"= 1\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareUGEMaskNotLong() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGE, (m) -> { return m.not(); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGE);\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.UGE, (m) -> { return L_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.UGE);\n+\n+        testCompareMaskNotLong(L_SPECIES_FOR_CAST, VectorOperators.UGE, (m) -> { return m.cast(I_SPECIES_FOR_CAST).not(); });\n+        verifyResultsLong(L_SPECIES_FOR_CAST, VectorOperators.UGE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloat() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fb);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloat() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fb, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fb);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fb, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fnan, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fnan);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fnan, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloatNaN() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fnan, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fnan);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fnan, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloatPositiveInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fpinf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fpinf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fpinf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fninf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fninf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fninf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotFloatNegativeInfinity() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fninf, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fninf);\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.NE, fa, fninf, (m) -> { return F_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDouble() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, db);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, db);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDouble() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, db, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, db);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, db, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, db);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dnan, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dnan);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dnan, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDoubleNaN() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dnan, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dnan);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dnan, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dnan);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dpinf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dpinf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dpinf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDoublePositiveInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dpinf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dpinf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dpinf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dpinf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareEQMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dninf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dninf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, dninf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, dninf);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 0\",\n+                   IRNode.XOR_V, \"= 0\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"asimd\", \"true\", \"avx2\", \"true\", \"rvv\", \"true\" })\n+    public static void testCompareNEMaskNotDoubleNegativeInfinity() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dninf, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dninf);\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.NE, da, dninf, (m) -> { return D_SPECIES.maskAll(true).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, dninf);\n+    }\n+\n+    \/\/ negative tests\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotByteNegative() {\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsByte(B_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotByte(B_SPECIES, VectorOperators.EQ, (m) -> { return B_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsByte(B_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotShortNegative() {\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsShort(S_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotShort(S_SPECIES, VectorOperators.EQ, (m) -> { return S_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsShort(S_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotIntNegative() {\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsInt(I_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotInt(I_SPECIES, VectorOperators.EQ, (m) -> { return I_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsInt(I_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 2\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 2\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotLongNegative() {\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsLong(L_SPECIES, VectorOperators.EQ);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotLong(L_SPECIES, VectorOperators.EQ, (m) -> { return L_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsLong(L_SPECIES, VectorOperators.NE);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotFloatNegative() {\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.EQ, fa, fb);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.EQ, fa, fb, (m) -> { return F_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.NE, fa, fb);\n+\n+        \/\/ Float vectors use the LT comparison.\n+        testCompareMaskNotFloat(F_SPECIES, VectorOperators.LT, fa, fb, (m) -> { return m.not(); });\n+        verifyResultsFloat(F_SPECIES, VectorOperators.LT, fa, fb);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.XOR_V_MASK, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureOr = { \"sve\", \"true\", \"avx512\", \"true\", \"rvv\", \"true\"  })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"asimd\", \"true\", \"sve\", \"false\" })\n+    @IR(counts = { IRNode.XOR_V, \"= 3\",\n+                   IRNode.VECTOR_MASK_CMP, \"= 3\" },\n+        applyIfCPUFeatureAnd = { \"avx2\", \"true\" })\n+    public static void testCompareMaskNotDoubleNegative() {\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> {\n+            \/\/ The vector mask is used multiple times.\n+            ic[0] = m.trueCount();\n+            return m.not();\n+        });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.EQ, da, db);\n+\n+        \/\/ One of the operands of XOR is not all ones vector.\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.EQ, da, db, (m) -> { return D_SPECIES.maskAll(false).xor(m); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.NE, da, db);\n+\n+        \/\/ Double vectors use the LT comparison.\n+        testCompareMaskNotDouble(D_SPECIES, VectorOperators.LT, da, db, (m) -> { return m.not(); });\n+        verifyResultsDouble(D_SPECIES, VectorOperators.LT, da, db);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(5000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .start();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCompareNotTest.java","additions":1299,"deletions":0,"binary":false,"changes":1299,"status":"added"},{"patch":"@@ -158,1 +158,1 @@\n-                                      \"than or equal to heap size(\" + heapSize + \"b) (available memory: \" + available + \")\");\n+                                      \"than or equal to heap size(\" + heapSize + \"b) (available memory: \" + available + \"). On Linux Kernel < 4.14 RSS can be inaccurate\");\n","filename":"test\/hotspot\/jtreg\/gc\/TestAlwaysPreTouchBehavior.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires vm.bits == \"64\"\n","filename":"test\/hotspot\/jtreg\/gc\/TestObjectAlignmentCardSize.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8352969\n+ * @summary Tests optional evacuation.\n+ * @requires vm.gc.G1\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver gc.g1.TestOptionalRegionGC\n+ *\/\n+\n+package gc.g1;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestOptionalRegionGC {\n+\n+  private static OutputAnalyzer run() throws Exception {\n+    return ProcessTools.executeLimitedTestJava(\n+      \"-XX:+WhiteBoxAPI\",\n+      \"-Xbootclasspath\/a:.\",\n+      \"-Xmx300M\",\n+      \"-Xms300M\",\n+      \"-XX:G1HeapRegionSize=1M\",\n+      \"-XX:+UseG1GC\",\n+      \"-XX:MaxTenuringThreshold=1\",\n+      \"-Xlog:gc+ergo+cset=trace\",\n+      \"-XX:+G1ForceOptionalEvacuation\",\n+      \"-XX:+VerifyAfterGC\",\n+      TestOptionalRegionGC.Action.class.getName());\n+  }\n+\n+  public static void main(String args[]) throws Exception {\n+    OutputAnalyzer out = run();\n+    out.shouldHaveExitValue(0);\n+    Pattern pattern = Pattern.compile(\"Prepared (\\\\d+) regions out of (\\\\d+) for optional evacuation\");\n+    Matcher matcher = pattern.matcher(out.getOutput());\n+    Asserts.assertTrue(matcher.find());\n+    String selectedNum = matcher.group(1);\n+    String totalNum = matcher.group(2);\n+    Asserts.assertTrue(Objects.equals(selectedNum, totalNum), \"Error info: \" + selectedNum + \", \" + totalNum);\n+  }\n+\n+  public static class Action {\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final int MIN_OBJECT_SIZE = 64 * 1024;\n+    private static final int MAX_OBJECT_SIZE = 120 * 1024;\n+    private static final int NUM_OBJECTS = 1200;\n+\n+    public static void main(String [] args) throws Exception {\n+      \/\/ Remove garbage from VM initialization.\n+      wb.fullGC();\n+      Random rand = new Random(42);\n+      List<byte[]> objectList = new ArrayList<>();\n+      for (int i = 0; i < NUM_OBJECTS; i++) {\n+        int objSize = MIN_OBJECT_SIZE + rand.nextInt(MAX_OBJECT_SIZE - MIN_OBJECT_SIZE);\n+        byte[] obj = new byte[objSize];\n+        objectList.add(obj);\n+      }\n+      \/\/ Young GC promotes some objects to the old generation.\n+      wb.youngGC();\n+      \/\/ Clear certain references for mixed GC.\n+      for (int i = 0; i < NUM_OBJECTS; i+=2) {\n+        objectList.set(i, null);\n+      }\n+      wb.g1RunConcurrentGC();\n+      \/\/ Perform the \"Prepare Mixed\" GC.\n+      wb.youngGC();\n+      \/\/ Perform the \"Mixed\" GC.\n+      wb.youngGC();\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestOptionalRegionGC.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+class OuterTest1 {\n+    class Inner {\n+        public void foo() { System.out.println(\"Inner.foo\"); }\n+    };\n+}\n+\n+Nested class acccess flags are made invalid in this jcod file.\n+*\/\n+\n+class OuterTest1 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"OuterTest1\"; \/\/ #8\n+    Utf8 \"Code\"; \/\/ #9\n+    Utf8 \"LineNumberTable\"; \/\/ #10\n+    Utf8 \"SourceFile\"; \/\/ #11\n+    Utf8 \"OuterTest1.java\"; \/\/ #12\n+    Utf8 \"NestMembers\"; \/\/ #13\n+    class #15; \/\/ #14\n+    Utf8 \"OuterTest1$Inner\"; \/\/ #15\n+    Utf8 \"InnerClasses\"; \/\/ #16\n+    Utf8 \"Inner\"; \/\/ #17\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #7;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#9) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#10) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#11) { \/\/ SourceFile\n+      #12;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#13) { \/\/ NestMembers\n+      [] { \/\/ classes\n+        #14;\n+      }\n+    } \/\/ end NestMembers\n+    ;\n+    Attr(#16) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #14 #7 #17 0x0fff;   \/\/ This access flag sets is_interface & is_final, so invalid.\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class OuterTest1\n","filename":"test\/hotspot\/jtreg\/runtime\/InnerClassesAttr\/OuterTest1.jcod","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+class OuterTest2 {\n+    interface Greeting {\n+        void sayHello();\n+    }\n+\n+    public static void test2() throws ClassFormatError {\n+        Greeting greeting = new Greeting() {\n+            @Override\n+            public void sayHello() {\n+                System.out.println(\"Hello from an anonymous inner class!\");\n+            }\n+        };\n+\n+        greeting.sayHello(); \/\/ Calls the method in the anonymous inner class\n+    }\n+}\n+\n+Nested class acccess flags are made invalid in this jcod file, the inner class is unnamed.\n+*\/\n+\n+class OuterTest2 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  70; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Object\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    class #8; \/\/ #7\n+    Utf8 \"OuterTest2$1\"; \/\/ #8\n+    Method #7 #3; \/\/ #9\n+    InterfaceMethod #11 #12; \/\/ #10\n+    class #13; \/\/ #11\n+    NameAndType #14 #6; \/\/ #12\n+    Utf8 \"OuterTest2$Greeting\"; \/\/ #13\n+    Utf8 \"sayHello\"; \/\/ #14\n+    class #16; \/\/ #15\n+    Utf8 \"OuterTest2\"; \/\/ #16\n+    Utf8 \"Code\"; \/\/ #17\n+    Utf8 \"LineNumberTable\"; \/\/ #18\n+    Utf8 \"test2\"; \/\/ #19\n+    Utf8 \"Exceptions\"; \/\/ #20\n+    class #22; \/\/ #21\n+    Utf8 \"java\/lang\/ClassFormatError\"; \/\/ #22\n+    Utf8 \"SourceFile\"; \/\/ #23\n+    Utf8 \"OuterTest2.java\"; \/\/ #24\n+    Utf8 \"NestMembers\"; \/\/ #25\n+    Utf8 \"InnerClasses\"; \/\/ #26\n+    Utf8 \"Greeting\"; \/\/ #27\n+  } \/\/ Constant Pool\n+\n+  0x0020; \/\/ access\n+  #15;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB70001B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0009; \/\/ access\n+      #19; \/\/ name_index\n+      #6; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#17) { \/\/ Code\n+          2; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0xBB000759B700094B;\n+            0x2AB9000A0100B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#18) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  9;\n+                8  16;\n+                14  17;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#20) { \/\/ Exceptions\n+          [] { \/\/ Exceptions\n+            #21;\n+          }\n+        } \/\/ end Exceptions\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#23) { \/\/ SourceFile\n+      #24;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#25) { \/\/ NestMembers\n+      [] { \/\/ classes\n+        #11;\n+        #7;\n+      }\n+    } \/\/ end NestMembers\n+    ;\n+    Attr(#26) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #7 #0 #0 0x0fff; \/\/ This access flag sets is_interface & is_final, so invalid.\n+        #11 #15 #27 1544;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class OuterTest2\n","filename":"test\/hotspot\/jtreg\/runtime\/InnerClassesAttr\/OuterTest2.jcod","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8079784\n+ * @summary Test that CFE with bad inner class attribute has a nice message.\n+ * @library \/test\/lib\n+ * @compile OuterTest1.jcod OuterTest2.jcod\n+ * @run main TestInnerClassAccessFlagErrorMessage\n+ *\/\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+public class TestInnerClassAccessFlagErrorMessage {\n+\n+    static String msg1 = \"inner class Inner\";\n+    static String msg2 = \"anonymous inner class\";\n+\n+    public static void main(java.lang.String[] unused) {\n+        try {\n+            Class<?> outer = Class.forName(\"OuterTest1\");\n+            fail(\"Should not reach here\");\n+        } catch (ClassFormatError err) {\n+            System.out.println(err.getMessage());\n+            assertTrue(err.getMessage().contains(msg1));\n+        } catch (ClassNotFoundException cfne) {\n+            cfne.printStackTrace();\n+            fail(\"Should not reach here\");\n+        }\n+\n+        try {\n+            Class<?> outer = Class.forName(\"OuterTest2\");\n+            fail(\"Should not reach here\");\n+        } catch (ClassFormatError err) {\n+            System.out.println(err.getMessage());\n+            assertTrue(err.getMessage().contains(msg2));\n+        } catch (ClassNotFoundException cfne) {\n+            cfne.printStackTrace();\n+            fail(\"Should not reach here\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/InnerClassesAttr\/TestInnerClassAccessFlagErrorMessage.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.flagless\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TooSmallStackSize.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,14 +43,0 @@\n-\/*\n- * @test id=dynamic\n- * @requires vm.cds.supports.aot.class.linking\n- * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n- * @build InitiatingLoaderTester BadOldClassA BadOldClassB\n- * @build jdk.test.whitebox.WhiteBox BulkLoaderTest SimpleCusty\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar BulkLoaderTestApp.jar BulkLoaderTestApp MyUtil InitiatingLoaderTester\n- *                 BadOldClassA BadOldClassB\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar cust.jar\n- *                 SimpleCusty\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:WhiteBox.jar BulkLoaderTest DYNAMIC\n- *\/\n-\n@@ -282,4 +268,0 @@\n-            \/\/ In dynamic dump, the VM loads BadOldClassB and then attempts to\n-            \/\/ link it. This will leave BadOldClassB in a \"failed verification\" state.\n-            \/\/ All refernces to BadOldClassB from the CP should be purged from the CDS\n-            \/\/ archive.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+        if (Platform.isRoot()) {\n+            throw new jtreg.SkippedException(\"Test skipped when executed by root user.\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestFileSafety.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,1 +76,3 @@\n-        test(args, true);\n+        if (!args[0].equals(\"DYNAMIC\")) {\n+            test(args, true);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n- * @comment CDS archive heap mapping is not supported with large pages\n- * @requires vm.opt.UseLargePages == null | !vm.opt.UseLargePages\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/sharedStrings\/InternSharedString.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import java.lang.reflect.Array;\n@@ -1368,1 +1369,1 @@\n-            Class.forName(null);\n+            Array.getLength(null);\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NullPointerException\/NullPointerExceptionTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+                \/\/ Graphics clinits may run, force headless mode\n+                \"-Djava.awt.headless=true\",\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,1 +263,0 @@\n-java\/awt\/Choice\/ChoiceMouseWheelTest\/ChoiceMouseWheelTest.java 8366852 generic-all\n@@ -457,1 +456,0 @@\n-java\/awt\/SplashScreen\/MultiResolutionSplash\/unix\/UnixMultiResolutionSplashTest.java 8203004 linux-all\n@@ -476,1 +474,1 @@\n-java\/awt\/PopupMenu\/PopupMenuLocation.java 8259913,8315878 windows-all,macosx-aarch64\n+java\/awt\/PopupMenu\/PopupMenuLocation.java 8259913 windows-all\n@@ -495,1 +493,0 @@\n-java\/awt\/Window\/GetScreenLocation\/GetScreenLocationTest.java 8225787 linux-x64\n@@ -800,1 +797,0 @@\n-javax\/swing\/JTabbedPane\/bug4666224.java 8144124  macosx-all\n@@ -825,1 +821,0 @@\n-java\/awt\/Focus\/AppletInitialFocusTest\/AppletInitialFocusTest1.java 8256289 windows-x64\n@@ -831,1 +826,0 @@\n-java\/awt\/Focus\/InactiveFocusRace.java 8023263 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8366833\n+ * @summary Poly1305 does not always correctly update position for array-backed\n+ *          ByteBuffers after processMultipleBlocks\n+ * @run main UpdateAADTest\n+ *\/\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.security.GeneralSecurityException;\n+import java.security.SecureRandom;\n+import java.util.HexFormat;\n+\n+public class UpdateAADTest {\n+    private static final SecureRandom RAND;\n+    private static final KeyGenerator CC20GEN;\n+    private static final HexFormat HEX = HexFormat.of();\n+\n+    private static final byte[] TEST_KEY_BYTES = HEX.parseHex(\n+            \"3cb1283912536e4108c3094dc2940d0d020afbd7701de267bbfb359bc7d54dd7\");\n+    private static final byte[] TEST_NONCE_BYTES = HEX.parseHex(\n+            \"9bd647a43b6fa7826e2cc26d\");\n+    private static final byte[] TEST_AAD_BYTES =\n+            \"This is a bunch of additional data to throw into the mix.\".\n+                    getBytes(StandardCharsets.UTF_8);\n+    private static final byte[] TEST_INPUT_BYTES =\n+        \"This is a plaintext message\".getBytes(StandardCharsets.UTF_8);\n+    private static final byte[] TEST_CT_BYTES = HEX.parseHex(\n+            \"8536c999809f4b9d6a1594ee1084c751d1bd8a991e6a4b4ac26386f04b9a1303\" +\n+            \"f40cbe6788d72af2d0c617\");\n+    private static final ByteBuffer EXPOUTBUF = ByteBuffer.wrap(TEST_CT_BYTES);\n+\n+    static {\n+        try {\n+            RAND = new SecureRandom();\n+            CC20GEN = KeyGenerator.getInstance(\"ChaCha20\");\n+        } catch (GeneralSecurityException gse) {\n+            throw new RuntimeException(\"Failed to init static JCE components\",\n+                    gse);\n+        }\n+    }\n+\n+    public interface TestAction {\n+        void runTest(ByteBuffer buffer) throws Exception;\n+    }\n+\n+    public static void main(final String[] args) throws Exception {\n+        ByteBuffer twoKBuf = ByteBuffer.allocate(2048);\n+        ByteBuffer nonBABuf = ByteBuffer.allocate(1329);\n+\n+        System.out.println(\"----- Test 1: Baseline test -----\");\n+        System.out.println(\"Make an array backed buffer that is 16-byte \" +\n+                           \"aligned, treat all data as AAD and feed it to \" +\n+                           \" updateAAD.\");\n+        aadUpdateTest.runTest(twoKBuf);\n+\n+        System.out.println(\"----- Test 2: Non Block Aligned Offset -----\");\n+        System.out.println(\"Use the same buffer, but place the offset such \" +\n+                           \"that the remaining data is not block aligned.\");\n+        aadUpdateTest.runTest(twoKBuf.position(395));\n+\n+        System.out.println(\"----- Test 3: Non Block Aligned Buf\/Off -----\");\n+        System.out.println(\"Make a buffer of non-block aligned size with an \" +\n+                           \"offset that keeps the remaining data non-block \" +\n+                           \"aligned.\");\n+        aadUpdateTest.runTest(nonBABuf.position(602));\n+\n+        System.out.println(\"----- Test 4: Aligned Buffer Slice -----\");\n+        System.out.println(\"Use a buffer of block aligned size, but slice \" +\n+                           \"the buffer such that the slice offset is part \" +\n+                           \"way into the original buffer.\");\n+        aadUpdateTest.runTest(twoKBuf.rewind().slice(1024,1024).position(42));\n+\n+        System.out.println(\"----- Test 5: Non-Aligned Buffer Slice -----\");\n+        System.out.println(\"Try the same test as #4, this time with \" +\n+                           \"non-block aligned buffers\/slices.\");\n+        aadUpdateTest.runTest(nonBABuf.rewind().slice(347, 347).position(86));\n+\n+        System.out.println(\"----- Test 6: MemorySegment Buffer -----\");\n+        System.out.println(\"Make a ByteBuffer from an array-backed \" +\n+                           \"MemorySegment, and try updating\");\n+        MemorySegment mseg = MemorySegment.ofArray(new byte[2048]);\n+        ByteBuffer msegBuf = mseg.asByteBuffer();\n+        aadUpdateTest.runTest(msegBuf.position(55));\n+\n+        System.out.println(\"----- Test 7: Buffer of MemorySegment Slice -----\");\n+        System.out.println(\"Use a slice from the MemorySegment and create a \" +\n+                           \"buffer from that for testing\");\n+        MemorySegment msegSlice = mseg.asSlice(1024);\n+        aadUpdateTest.runTest(msegSlice.asByteBuffer().position(55));\n+\n+        System.out.println(\"----- Test 8: MemorySegment Buffer Slice -----\");\n+        System.out.println(\"Create a slice from the ByteBuffer from the \" +\n+                           \"original MemorySegment.\");\n+        aadUpdateTest.runTest(msegBuf.rewind().slice(1024, 1024));\n+\n+        System.out.println(\"Test vector processing\");\n+        System.out.println(\"----------------------\");\n+        System.out.println(\"----- Test 9: AAD + Plaintext on buffer ------\");\n+        System.out.println(\"Place the AAD, followed by plaintext and verify \" +\n+                           \"the ciphertext\");\n+        \/\/ Create a ByteBuffer where the AAD and plaintext actually sit\n+        \/\/ somewhere in the middle of the underlying array, with non-test-vector\n+        \/\/ memory on either side of the data.\n+        ByteBuffer vectorBuf = ByteBuffer.allocate(1024).position(600).\n+                put(TEST_AAD_BYTES).put(TEST_INPUT_BYTES).flip().position(600);\n+        vectorTest.runTest(vectorBuf);\n+\n+        System.out.println(\"----- Test 10: AAD + Plaintext on slice -----\");\n+        System.out.println(\"Perform the same test, this time on a slice\" +\n+                           \"of the test vector buffer\");\n+        ByteBuffer vectorSlice = vectorBuf.slice(600,\n+                TEST_AAD_BYTES.length + TEST_INPUT_BYTES.length);\n+        vectorTest.runTest(vectorSlice);\n+    }\n+\n+    \/\/ Simple test callback for taking a ByteBuffer and throwing all\n+    \/\/ remaining bytes into an updateAAD call.\n+    public static TestAction aadUpdateTest = buffer -> {\n+        SecretKey key = CC20GEN.generateKey();\n+        byte[] nonce = new byte[12];\n+        RAND.nextBytes(nonce);\n+\n+        Cipher cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(nonce));\n+\n+        cipher.updateAAD(buffer);\n+        \/\/ Per the API the buffer's position and limit should be equal\n+        if (buffer.position() != buffer.limit()) {\n+            throw new RuntimeException(\"Buffer position and limit \" +\n+                    \"should be equal but are not: p = \" +\n+                    buffer.position() + \", l = \" + buffer.limit());\n+        }\n+    };\n+\n+    \/\/ Test callback for making sure that the updateAAD method, when\n+    \/\/ put in with a complete encryption operation still gets the\n+    \/\/ expected answer.\n+    public static TestAction vectorTest = buffer -> {\n+        Cipher cipher = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        cipher.init(Cipher.ENCRYPT_MODE,\n+                new SecretKeySpec(TEST_KEY_BYTES, \"ChaCha20\"),\n+                new IvParameterSpec(TEST_NONCE_BYTES));\n+        ByteBuffer outbuf = ByteBuffer.allocate(cipher.getOutputSize(\n+                TEST_INPUT_BYTES.length));\n+\n+        \/\/ Adjust the limit to be the end of the aad\n+        int origLim = buffer.limit();\n+        buffer.limit(buffer.position() + TEST_AAD_BYTES.length);\n+        cipher.updateAAD(buffer);\n+        buffer.limit(origLim);\n+        cipher.doFinal(buffer, outbuf);\n+        if (!outbuf.flip().equals(EXPOUTBUF)) {\n+            throw new RuntimeException(\"Output data mismatch\");\n+        }\n+    };\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/UpdateAADTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -50,2 +50,1 @@\n-    private static final MemoryPoolMXBean tenuredGenPool =\n-            findTenuredGenPool();\n+    private static final MemoryPoolMXBean tenuredGenPool = findTenuredGenPool();\n@@ -58,1 +57,1 @@\n-        setPercentageUsageThreshold(0.1);\n+        setPercentageUsageThreshold(0.2);\n@@ -77,1 +76,1 @@\n-        Collection<Object[]> numbers = new LinkedList();\n+        Collection<int[]> numbers = new LinkedList();\n@@ -79,0 +78,1 @@\n+        System.out.println(tenuredGenPool.getName() + \": \" + tenuredGenPool.getUsage());\n@@ -80,1 +80,1 @@\n-            numbers.add(new Object[1000]);\n+            numbers.add(new int[1000]);\n@@ -83,1 +83,17 @@\n-                Thread.sleep(100);\n+                System.gc();       \/\/ Encourage promotion into old\/tenured generation\n+                Thread.sleep(100); \/\/ Give the notification a bit of time to happen\n+                MemoryUsage usage = tenuredGenPool.getUsage();\n+                long used = usage.getUsed();\n+                long max = usage.getMax();\n+                System.out.println(tenuredGenPool.getName() + \": \" + tenuredGenPool.getUsage());\n+                if ((float)used \/ (float)max > .50) {\n+                    \/\/ If we have allocated 50% of the heap pool, block here until the\n+                    \/\/ notication arrives\n+                    System.out.println(\"counter: \" + counter);\n+                    System.out.println(tenuredGenPool.getName() + \": \" + tenuredGenPool.getUsage());\n+                    System.out.println(\">50% of heap pool allocated (\" + used + \"). Blocking...\");\n+                    while (!done) {\n+                        Thread.sleep(100);\n+                    }\n+                    System.out.println(\"Finished blocking\");\n+                }\n@@ -86,0 +102,1 @@\n+\n@@ -90,5 +107,20 @@\n-        for (MemoryPoolMXBean pool :\n-                ManagementFactory.getMemoryPoolMXBeans()) {\n-            if (pool.getType() == MemoryType.HEAP &&\n-                    pool.isUsageThresholdSupported()) {\n-                return pool;\n+        \/\/ List of supported GC pools\n+        String[] supportedPools = {\n+            \"Tenured Gen\",        \/\/ Serial GC\n+            \"PS Old Gen\",         \/\/ Parallel GC\n+            \"G1 Old Gen\",         \/\/ G1 GC\n+            \"ZGC Old Generation\", \/\/ Z GC\n+            \"Shenandoah\",         \/\/ Shenandoah GC\n+            \"Shenandoah Old Gen\"  \/\/ Shenandoah generational mode GC\n+        };\n+\n+        for (MemoryPoolMXBean pool : ManagementFactory.getMemoryPoolMXBeans()) {\n+            if (pool.getType() == MemoryType.HEAP && pool.isUsageThresholdSupported()) {\n+                System.out.println(\"Verify pool: \" + pool.getName());\n+                for (String str : supportedPools) {\n+                    String poolName = pool.getName();\n+                    if (str.equals(poolName)) {\n+                        System.out.println(\"Pool Verified: \" + pool.getName());\n+                        return pool;\n+                    }\n+                }\n@@ -97,1 +129,4 @@\n-        throw new RuntimeException(\"Could not find tenured space\");\n+\n+        RuntimeException ex =  new RuntimeException(\"Could not find tenured space\");\n+        ex.printStackTrace(System.out);\n+        throw ex;\n@@ -104,1 +139,1 @@\n-        System.out.println(\"Setting threashold for pool \" + tenuredGenPool.getName() + \" percentage:\" + percentage);\n+        System.out.println(\"Setting threshold for pool \" + tenuredGenPool.getName() + \" percentage:\" + percentage);\n@@ -116,1 +151,1 @@\n-    private static final String[] DEBUGGEE_OPTIONS = {\"-Xmx256M\"};\n+    private static final String[] DEBUGGEE_OPTIONS = {\"-Xmx128M\"};\n","filename":"test\/jdk\/com\/sun\/jdi\/JdbStopInNotificationThreadTest.java","additions":49,"deletions":14,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8357708\n+ * @summary verify that com.sun.jndi.ldap.Connection does not ignore the LDAP replies\n+ *          that were received before the Connection was closed.\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run junit\/othervm LdapClientConnTest\n+ *\/\n+public class LdapClientConnTest {\n+\n+    private static final byte BER_TYPE_LDAP_SEQUENCE = 0x30;\n+    private static final byte BER_TYPE_INTEGER = 0x02;\n+    private static final byte BER_TYPE_OCTET_STRING = 0x04;\n+    private static final byte BER_TYPE_ENUM = 0x0a;\n+    private static final byte BER_TYPE_LDAP_SEARCH_REQUEST_OP = 0x63;\n+    private static final byte BER_TYPE_LDAP_SEARCH_RESULT_ENTRY_OP = 0x64;\n+    private static final byte BER_TYPE_LDAP_SEARCH_RESULT_DONE_OP = 0x65;\n+    private static final byte BER_TYPE_LDAP_SEARCH_RESULT_REFERENCE_OP = 0x73;\n+    private static final byte LDAP_SEARCH_RESULT_DONE_SUCCESS = 0x00;\n+\n+    private static final String SEARCH_REQ_DN_PREFIX = \"CN=foo-\";\n+    private static final String SEARCH_REQ_DN_SUFFIX = \"-bar\";\n+\n+    private static Server server;\n+    private static final List<Throwable> serverSideFailures =\n+            Collections.synchronizedList(new ArrayList<>());\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        server = startServer();\n+        System.out.println(\"server started \" + server.getAddress());\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"stopping server \" + server.getAddress());\n+            server.close();\n+        }\n+    }\n+\n+    \/*\n+     * Launches several concurrent tasks, all of which use a LdapClient of their own to trigger\n+     * a LDAP SEARCH request. The server side handles the LDAP SEARCH request and writes out the\n+     * response over the Socket and then after the response is written out, closes the\n+     * OutputStream of the Socket. The test then verifies that each of these tasks complete\n+     * normally without any exception being raised.\n+     *\/\n+    @Test\n+    public void testLdapRepliesNotIgnored() throws Throwable {\n+        final Map<String, Future<Void>> results = new HashMap<>();\n+        final int numTasks = 10;\n+        try (final ExecutorService executor = Executors.newCachedThreadPool()) {\n+            for (int i = 1; i <= numTasks; i++) {\n+                final String taskName = \"task-\" + i;\n+                results.put(taskName, executor.submit(new LdapRequestsTask(taskName)));\n+            }\n+            System.out.println(\"waiting for \" + numTasks + \" to complete\");\n+            for (final Map.Entry<String, Future<Void>> entry : results.entrySet()) {\n+                try {\n+                    entry.getValue().get();\n+                } catch (ExecutionException ee) {\n+                    final Throwable cause = ee.getCause();\n+                    System.out.println(\"failed for \" + entry.getKey() + \", exception: \" + cause);\n+                    throw cause;\n+                }\n+            }\n+        }\n+        \/\/ verify there weren't any server side failures\n+        if (!serverSideFailures.isEmpty()) {\n+            System.err.println(\"server side failure(s) follow:\");\n+            for (final Throwable t : serverSideFailures) {\n+                t.printStackTrace();\n+            }\n+            fail(\"unexpected server side failures\");\n+        }\n+    }\n+\n+    private static Server startServer() throws IOException {\n+        final ServerSocket serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+        final Server s = new Server(serverSocket);\n+        s.start();\n+        return s;\n+    }\n+\n+    \/\/ accepts connections on a ServerSocket and hands off the request processing\n+    \/\/ to the RequestHandler\n+    private static final class Server implements Runnable, AutoCloseable {\n+        private final ServerSocket serverSocket;\n+        private final AtomicInteger reqHandlerTid = new AtomicInteger();\n+        private volatile boolean stop;\n+\n+        private Server(final ServerSocket serverSocket) {\n+            this.serverSocket = serverSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            System.err.println(\"Server accepting connections at \"\n+                    + serverSocket.getLocalSocketAddress());\n+            while (!stop) {\n+                try {\n+                    final Socket accepted = serverSocket.accept();\n+                    System.err.println(\"Accepted connection from \" + accepted);\n+                    dispatchRequest(accepted);\n+                } catch (Throwable t) {\n+                    if (!stop) {\n+                        System.err.println(\"Server thread ran into unexpected exception: \" + t);\n+                        t.printStackTrace();\n+                        \/\/ keep track of this failure to eventually fail the test\n+                        serverSideFailures.add(t);\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void start() {\n+            final Thread serverThread = new Thread(this);\n+            serverThread.setName(\"server\");\n+            serverThread.setDaemon(true);\n+            serverThread.start();\n+        }\n+\n+        private InetSocketAddress getAddress() {\n+            return (InetSocketAddress) this.serverSocket.getLocalSocketAddress();\n+        }\n+\n+        private void dispatchRequest(final Socket incomingConnection) {\n+            final RequestHandler handler = new RequestHandler(incomingConnection);\n+            \/\/ handle the request in a separate thread\n+            final Thread reqHandlerThread = new Thread(handler);\n+            reqHandlerThread.setName(\"request-handler-\" + reqHandlerTid.incrementAndGet());\n+            reqHandlerThread.setDaemon(true);\n+            reqHandlerThread.start();\n+        }\n+\n+        @Override\n+        public void close() {\n+            this.stop = true;\n+            try {\n+                System.err.println(\"closing server socket \" + this.serverSocket);\n+                this.serverSocket.close();\n+            } catch (IOException _) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/\/ Handles a single request over the Socket and responds back on the same Socket\n+    private static final class RequestHandler implements Runnable {\n+\n+        private record SearchRequest(byte msgId, String dn) {\n+        }\n+\n+        private final Socket clientSocket;\n+\n+        private RequestHandler(final Socket clientSocket) {\n+            this.clientSocket = clientSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            final String threadName = Thread.currentThread().getName();\n+            System.err.println(threadName + \" - handling request on socket: \" + clientSocket);\n+            try (InputStream is = clientSocket.getInputStream();\n+                 OutputStream os = clientSocket.getOutputStream()) {\n+                final SearchRequest searchRequest = parseLDAPSearchRequest(is);\n+                \/\/ generate a LDAP response\n+                final byte[] responseBytes = makeResponse(searchRequest.msgId,\n+                        searchRequest.dn, server.getAddress());\n+                System.err.println(threadName + \" - responding to: \" + searchRequest);\n+                os.write(responseBytes);\n+            } catch (Throwable t) {\n+                System.err.println(threadName + \" - exception in request handler: \" + t);\n+                t.printStackTrace();\n+                \/\/ keep track of this failure to eventually fail the test\n+                serverSideFailures.add(t);\n+            } finally {\n+                System.err.println(threadName + \" - request handler done\");\n+            }\n+        }\n+\n+        private static SearchRequest parseLDAPSearchRequest(final InputStream is)\n+                throws IOException {\n+            final String threadName = Thread.currentThread().getName();\n+            final HexFormat hf = HexFormat.of();\n+            \/\/ read the BER elements\n+            \/\/ each BER element is 3 parts:\n+            \/\/ Type, length, value\n+            final int berType = is.read();\n+            if (berType != BER_TYPE_LDAP_SEQUENCE) {\n+                \/\/ unexpected content\n+                throw new IOException(threadName + \" - unexpected request, not a LDAP_SEQUENCE: \"\n+                        + hf.formatHex(new byte[]{(byte) berType}));\n+            }\n+            \/\/ BER element length\n+            int seqLen = is.read();\n+            \/\/ 0x81, 0x82, 0x84 (and a few others) represent length that is represented\n+            \/\/ in multiple bytes. for this test we only consider length represented in\n+            \/\/ single byte or multiple bytes through 0x81 and 0x82\n+            if (seqLen == 0x81) {\n+                seqLen = is.read() & 0xff;\n+            } else if (seqLen == 0x82) {\n+                seqLen = (is.read() & 0xff) << 8 + (is.read() & 0xff);\n+            }\n+            if (seqLen < 0) {\n+                \/\/ unexpected BER element length\n+                throw new IOException(threadName + \" - unexpected BER element length: \" + seqLen);\n+            }\n+            \/\/ read the BER element value\n+            final byte[] ldapSeq = new byte[seqLen];\n+            System.err.println(threadName + \" - reading \" + seqLen + \" bytes from request\");\n+            is.readNBytes(ldapSeq, 0, seqLen);\n+\n+            final String ldapSeqHex = HexFormat.of().formatHex(ldapSeq); \/\/ just for debug logging\n+            System.err.println(threadName + \" - request LDAP sequence: 0x\" + ldapSeqHex);\n+\n+            \/\/ read the message id BER element from the LDAP sequence\n+            final byte msgIdType = ldapSeq[0];\n+            if (msgIdType != BER_TYPE_INTEGER) {\n+                \/\/ unexpected content\n+                throw new IOException(threadName + \" - unexpected BER type for message id element: \"\n+                        + hf.formatHex(new byte[]{msgIdType}));\n+            }\n+            final byte msgIdLen = ldapSeq[1];\n+            final byte msgId = ldapSeq[2];\n+            \/\/ read LDAP operation type\n+            final byte ldapOpType = ldapSeq[3];\n+            if (ldapOpType != BER_TYPE_LDAP_SEARCH_REQUEST_OP) {\n+                \/\/ we only support LDAP search requests in this handler\n+                throw new IOException(threadName + \" - unexpected BER type for LDAP operation: \"\n+                        + hf.formatHex(new byte[]{ldapOpType}));\n+            }\n+            final byte searchReqSeqLen = ldapSeq[4];\n+            if (searchReqSeqLen < 0) {\n+                \/\/ implies the length is represented in multiple bytes. we don't\n+                \/\/ expect that big a search request payload in this test, so fail.\n+                throw new IOException(threadName + \" - unexpected length for SEARCH request: \"\n+                        + hf.formatHex(new byte[]{searchReqSeqLen}));\n+            }\n+            \/\/ not all characters will be ASCII, but that's OK, this is here merely as a check\n+            \/\/ for unexpected requests\n+            final String remainingPayload = new String(ldapSeq, 5, (ldapSeq.length - 5));\n+            final int dnPrefixIndex = remainingPayload.indexOf(SEARCH_REQ_DN_PREFIX);\n+            final int dnSuffixIndex = remainingPayload.indexOf(SEARCH_REQ_DN_SUFFIX);\n+            if (dnPrefixIndex < 0 || dnSuffixIndex < 0) {\n+                throw new IOException(threadName + \" - missing expected DN in SEARCH request: \"\n+                        + remainingPayload);\n+            }\n+            final String dn = remainingPayload.substring(dnPrefixIndex,\n+                    dnSuffixIndex + SEARCH_REQ_DN_SUFFIX.length());\n+            return new SearchRequest(msgId, dn);\n+        }\n+\n+        \/\/ constructs and returns a byte[] response containing the following (in that order):\n+        \/\/  - Search Result Reference\n+        \/\/  - Search Result Entry\n+        \/\/  - Search Result Done\n+        private static byte[] makeResponse(final byte msgId, final String origDN,\n+                                           final InetSocketAddress targetServer)\n+                throws IOException {\n+            \/\/ construct a URI with a different DN for using as referral URI\n+            final String newPrefix = SEARCH_REQ_DN_PREFIX + \"dummy-referral-\";\n+            final String newDN = origDN.replace(SEARCH_REQ_DN_PREFIX, newPrefix);\n+            final String referralURI = URIBuilder.newBuilder()\n+                    .scheme(\"ldap\")\n+                    .host(targetServer.getAddress().getHostAddress())\n+                    .port(targetServer.getPort())\n+                    .path(\"\/\" + newDN)\n+                    .buildUnchecked()\n+                    .toString();\n+            final byte msgIdLen = 1;\n+            final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+            \/\/ write the BER elements\n+            \/\/ each BER element is 3 parts:\n+            \/\/ Type, length, value\n+\n+            \/\/ Search Result Reference BER element (refer to LDAPv3 wire format for details)\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            bout.write(referralURI.length() + 7);\n+            bout.write(new byte[]{BER_TYPE_INTEGER, msgIdLen, msgId});\n+            bout.write(BER_TYPE_LDAP_SEARCH_RESULT_REFERENCE_OP);\n+            bout.write(referralURI.length() + 2);\n+            bout.write(BER_TYPE_OCTET_STRING);\n+            bout.write(referralURI.length());\n+            bout.write(referralURI.getBytes(US_ASCII));\n+\n+            \/\/ Search Result Entry BER element (refer to LDAPv3 wire format for details)\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            bout.write(origDN.length() + 9);\n+            bout.write(new byte[]{BER_TYPE_INTEGER, msgIdLen, msgId});\n+            bout.write(BER_TYPE_LDAP_SEARCH_RESULT_ENTRY_OP);\n+            bout.write(origDN.length() + 2);\n+            bout.write(BER_TYPE_OCTET_STRING);\n+            bout.write(origDN.length());\n+            bout.write(origDN.getBytes(US_ASCII));\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            \/\/ 0 length for the LDAP sequence, implying no attributes in this Search Result Entry\n+            bout.write(0);\n+\n+            \/\/ Search Result Done BER element (refer to LDAPv3 wire format for details)\n+            bout.write(BER_TYPE_LDAP_SEQUENCE);\n+            bout.write(origDN.length() + 12);\n+            bout.write(new byte[]{BER_TYPE_INTEGER, msgIdLen, msgId});\n+            bout.write(BER_TYPE_LDAP_SEARCH_RESULT_DONE_OP);\n+            bout.write(7);\n+            bout.write(new byte[]{BER_TYPE_ENUM, 1, LDAP_SEARCH_RESULT_DONE_SUCCESS});\n+            \/\/ the matched DN\n+            bout.write(BER_TYPE_OCTET_STRING);\n+            bout.write(origDN.length());\n+            bout.write(origDN.getBytes(US_ASCII));\n+            \/\/ 0 length implies no diagnostic message\n+            bout.write(new byte[]{BER_TYPE_OCTET_STRING, 0});\n+            return bout.toByteArray();\n+        }\n+    }\n+\n+    \/\/ a task that triggers LDAP SEARCH request\n+    private static final class LdapRequestsTask implements Callable<Void> {\n+        private final String taskName;\n+\n+        private LdapRequestsTask(final String taskName) {\n+            this.taskName = taskName;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            Context ldapCtx = null;\n+            try {\n+                final InetSocketAddress serverAddr = server.getAddress();\n+                final Hashtable<String, String> envProps = new Hashtable<>();\n+                envProps.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+                final String providerUrl = URIBuilder.newBuilder()\n+                        .scheme(\"ldap\")\n+                        .host(serverAddr.getAddress())\n+                        .port(serverAddr.getPort())\n+                        .build().toString();\n+                envProps.put(Context.PROVIDER_URL, providerUrl);\n+                \/\/ explicitly set LDAP version to 3 to prevent LDAP BIND requests\n+                \/\/ during LdapCtx instantiation\n+                envProps.put(\"java.naming.ldap.version\", \"3\");\n+                ldapCtx = new InitialContext(envProps);\n+                final String name = SEARCH_REQ_DN_PREFIX + taskName + SEARCH_REQ_DN_SUFFIX;\n+                \/\/ trigger the LDAP SEARCH requests through the lookup call. we are not\n+                \/\/ interested in the returned value and are merely interested in a normal\n+                \/\/ completion of the call.\n+                final var _ = ldapCtx.lookup(name);\n+                return null;\n+            } finally {\n+                if (ldapCtx != null) {\n+                    ldapCtx.close();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapClientConnTest.java","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,9 +25,8 @@\n-  @test\n-  @key headful\n-  @bug 7050935\n-  @summary closed\/java\/awt\/Choice\/WheelEventsConsumed\/WheelEventsConsumed.html fails on win32\n-  @library ..\/..\/regtesthelpers\n-  @author Oleg Pekhovskiy: area=awt-choice\n-  @build Util\n-  @run main ChoiceMouseWheelTest\n-*\/\n+ * @test\n+ * @key headful\n+ * @bug 7050935\n+ * @summary closed\/java\/awt\/Choice\/WheelEventsConsumed\/WheelEventsConsumed.html fails on win32\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build Util\n+ * @run main ChoiceMouseWheelTest\n+ *\/\n@@ -37,2 +36,14 @@\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.Choice;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n@@ -45,0 +56,1 @@\n+    private final Choice choice;\n@@ -46,2 +58,7 @@\n-    public static void main(String[] args) {\n-        new ChoiceMouseWheelTest();\n+    public static void main(String[] args) throws Exception {\n+        ChoiceMouseWheelTest test = Util.invokeOnEDT(ChoiceMouseWheelTest::new);\n+        try {\n+            test.test();\n+        } finally {\n+            EventQueue.invokeAndWait(test::dispose);\n+        }\n@@ -54,2 +71,0 @@\n-        Choice choice = new Choice();\n-\n@@ -59,1 +74,1 @@\n-                System.exit(0);\n+                e.getWindow().dispose();\n@@ -63,2 +78,3 @@\n-        for(Integer i = 0; i < 50; i++) {\n-            choice.add(i.toString());\n+        choice = new Choice();\n+        for(int i = 0; i < 50; i++) {\n+            choice.add(Integer.toString(i));\n@@ -67,10 +83,2 @@\n-        choice.addItemListener(new ItemListener() {\n-            public void itemStateChanged(ItemEvent e) {\n-                itemChanged = true;\n-            }\n-        });\n-        choice.addMouseWheelListener(new MouseWheelListener() {\n-            public void mouseWheelMoved(MouseWheelEvent e) {\n-                wheelMoved = true;\n-            }\n-        });\n+        choice.addItemListener(e -> itemChanged = true);\n+        choice.addMouseWheelListener(e -> wheelMoved = true);\n@@ -87,0 +95,1 @@\n+        setLocationRelativeTo(null);\n@@ -89,0 +98,1 @@\n+    }\n@@ -90,4 +100,5 @@\n-        try {\n-            Robot robot = new Robot();\n-            robot.setAutoDelay(20);\n-            Util.waitForIdle(robot);\n+    private void test() throws Exception {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(20);\n+        robot.waitForIdle();\n+        robot.delay(500);\n@@ -95,0 +106,1 @@\n+        Rectangle choiceBounds = Util.invokeOnEDT(() -> {\n@@ -97,2 +109,5 @@\n-            int x = pt.x + size.width \/ 3;\n-            robot.mouseMove(x, pt.y + size.height \/ 2);\n+            return new Rectangle(pt, size);\n+        });\n+\n+        int x = choiceBounds.x + choiceBounds.width \/ 3;\n+        robot.mouseMove(x, choiceBounds.y + choiceBounds.height \/ 2);\n@@ -100,2 +115,4 @@\n-            \/\/ Test mouse wheel over the choice\n-            String name = Toolkit.getDefaultToolkit().getClass().getName();\n+        \/\/ Test mouse wheel over the choice\n+        String name = Toolkit.getDefaultToolkit().getClass().getName();\n+        boolean isXtoolkit = name.equals(\"sun.awt.X11.XToolkit\");\n+        boolean isLWCToolkit = name.equals(\"sun.lwawt.macosx.LWCToolkit\");\n@@ -103,5 +120,4 @@\n-            \/\/ mouse wheel doesn't work for the choice on X11 and Mac, so skip it\n-            if(!name.equals(\"sun.awt.X11.XToolkit\")\n-               && !name.equals(\"sun.lwawt.macosx.LWCToolkit\")) {\n-                robot.mouseWheel(1);\n-                Util.waitForIdle(robot);\n+        \/\/ mouse wheel doesn't work for the choice on X11 and Mac, so skip it\n+        if (!isXtoolkit && !isLWCToolkit) {\n+            robot.mouseWheel(1);\n+            robot.waitForIdle();\n@@ -109,3 +125,2 @@\n-                if(!wheelMoved || !itemChanged) {\n-                    throw new RuntimeException(\"Mouse Wheel over the choice failed!\");\n-                }\n+            if (!wheelMoved || !itemChanged) {\n+                throw new RuntimeException(\"Mouse Wheel over the choice failed!\");\n@@ -113,0 +128,1 @@\n+        }\n@@ -114,5 +130,5 @@\n-            \/\/ Test mouse wheel over the drop-down list\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            Util.waitForIdle(robot);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            Util.waitForIdle(robot);\n+        \/\/ Test mouse wheel over the drop-down list\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n@@ -120,5 +136,1 @@\n-            int y = getLocationOnScreen().y + getSize().height;\n-            while(!frameExited && y >= 0) { \/\/ move to the bottom of drop-down list\n-                robot.mouseMove(x, --y);\n-                Util.waitForIdle(robot);\n-            }\n+        frameExited = false;\n@@ -126,3 +138,1 @@\n-            if(x < 0) {\n-                throw new RuntimeException(\"Could not enter drop-down list!\");\n-            }\n+        Rectangle frameBounds = Util.invokeOnEDT(this::getBounds);\n@@ -130,3 +140,5 @@\n-            y -= choice.getHeight() \/ 2;\n-            robot.mouseMove(x, y); \/\/ move to the last visible item in the drop-down list\n-            Util.waitForIdle(robot);\n+        int y = frameBounds.y + frameBounds.height;\n+        while (!frameExited && y >= frameBounds.y) { \/\/ move to the bottom of drop-down list\n+            robot.mouseMove(x, --y);\n+            robot.waitForIdle();\n+        }\n@@ -134,2 +146,3 @@\n-            robot.mouseWheel(choice.getItemCount()); \/\/ wheel to the last item\n-            Util.waitForIdle(robot);\n+        if (y < frameBounds.y) {\n+            throw new RuntimeException(\"Could not enter drop-down list!\");\n+        }\n@@ -137,6 +150,3 @@\n-            \/\/ click the last item\n-            itemChanged = false;\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            Util.waitForIdle(robot);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            Util.waitForIdle(robot);\n+        y -= choiceBounds.height \/ 2;\n+        robot.mouseMove(x, y); \/\/ move to the last visible item in the drop-down list\n+        robot.waitForIdle();\n@@ -144,3 +154,4 @@\n-            if(!itemChanged || choice.getSelectedIndex() != choice.getItemCount() - 1) {\n-                throw new RuntimeException(\"Mouse Wheel scroll position error!\");\n-            }\n+        int scrollDirection = isLWCToolkit ? -1 : 1;\n+        \/\/ wheel to the last item\n+        robot.mouseWheel(scrollDirection * choice.getItemCount());\n+        robot.waitForIdle();\n@@ -148,3 +159,9 @@\n-            dispose();\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"AWTException occurred - problem creating robot!\");\n+        \/\/ click the last item\n+        itemChanged = false;\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+\n+        if (!itemChanged || choice.getSelectedIndex() != choice.getItemCount() - 1) {\n+            throw new RuntimeException(\"Mouse Wheel scroll position error!\");\n@@ -154,1 +171,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceMouseWheelTest\/ChoiceMouseWheelTest.java","additions":92,"deletions":76,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @key headful\n-  @bug 4041703 4096228 4025223 4260929\n-  @summary Ensures that appletviewer sets a reasonable default focus for an Applet on start\n-  @library ..\/..\/regtesthelpers\n-  @build   Util\n-  @run main AppletInitialFocusTest\n-*\/\n-\n-import java.awt.Button;\n-import java.awt.FlowLayout;\n-import java.awt.Frame;\n-import java.awt.Robot;\n-import test.java.awt.regtesthelpers.Util;\n-\n-public class AppletInitialFocusTest extends Frame {\n-\n-    Robot robot = Util.createRobot();\n-    Button button = new Button(\"Button\");\n-\n-    public static void main(final String[] args) throws Exception {\n-        AppletInitialFocusTest app = new AppletInitialFocusTest();\n-        app.init();\n-        app.start();\n-    }\n-\n-    public void init() {\n-        setSize(200, 200);\n-        setLocationRelativeTo(null);\n-        setLayout(new FlowLayout());\n-        add(button);\n-        setVisible(true);\n-    }\n-\n-    public void start() throws Exception {\n-        Thread thread = new Thread(new Runnable() {\n-                public void run() {\n-                    Util.waitTillShown(button);\n-                    robot.delay(1000); \/\/ delay the thread to let EDT to start dispatching focus events\n-                    Util.waitForIdle(robot);\n-                    if (!button.hasFocus()) {\n-                        throw new RuntimeException(\"Appletviewer doesn't set default focus correctly.\");\n-                    }\n-                }\n-            });\n-        thread.start();\n-        thread.join();\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Focus\/AppletInitialFocusTest\/AppletInitialFocusTest.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Button;\n-import java.awt.FlowLayout;\n-import java.awt.Frame;\n-import java.awt.event.FocusEvent;\n-import java.awt.event.FocusListener;\n-\n-\/**\n- * @test\n- * @key headful\n- * @bug 4411534 4517274\n- * @summary ensures that user's requestFocus() during applet initialization\n- *          is not ignored\n- *\/\n-public class AppletInitialFocusTest1 extends Frame implements FocusListener {\n-\n-    Button button1 = new Button(\"Button1\");\n-    Button button2 = new Button(\"Button2\");\n-    private static volatile Object focused;\n-\n-    public static void main(final String[] args) throws Exception {\n-        AppletInitialFocusTest1 app = new AppletInitialFocusTest1();\n-        try {\n-            app.setSize(200, 200);\n-            app.setLocationRelativeTo(null);\n-            app.setLayout(new FlowLayout());\n-\n-            app.button1.addFocusListener(app);\n-            app.button2.addFocusListener(app);\n-            app.add(app.button1);\n-            app.add(app.button2);\n-            app.setVisible(true);\n-            app.button2.requestFocus();\n-            \/\/ wait for the very very last focus event\n-            Thread.sleep(10000);\n-            if (app.button2 != focused) {\n-                throw new RuntimeException(\"Wrong focus owner: \" + focused);\n-            }\n-        } finally {\n-            app.dispose();\n-        }\n-    }\n-\n-    public void focusGained(FocusEvent e) {\n-        focused = e.getSource();\n-        System.out.println(\"focused = \" + focused);\n-    }\n-\n-    public void focusLost(FocusEvent e) {\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Focus\/AppletInitialFocusTest\/AppletInitialFocusTest1.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.awt.EventQueue;\n@@ -51,0 +52,1 @@\n+    private static Robot robot;\n@@ -54,0 +56,1 @@\n+            robot = new Robot();\n@@ -55,1 +58,5 @@\n-            test.init();\n+            EventQueue.invokeAndWait(() -> {\n+                test.init();\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n@@ -58,6 +65,8 @@\n-            if (activeFrame != null) {\n-                activeFrame.dispose();\n-            }\n-            if (inactiveFrame != null) {\n-                inactiveFrame.dispose();\n-            }\n+            EventQueue.invokeAndWait(() -> {\n+                if (activeFrame != null) {\n+                    activeFrame.dispose();\n+                }\n+                if (inactiveFrame != null) {\n+                    inactiveFrame.dispose();\n+                }\n+            });\n@@ -94,0 +103,6 @@\n+        inactiveFrame.addWindowListener(new WindowAdapter() {\n+            public void windowActivated(WindowEvent e) {\n+                System.err.println(\"inactive Window activated\");\n+                sema.raise();\n+            }\n+        });\n@@ -100,0 +115,1 @@\n+        inactiveFrame.setVisible(true);\n@@ -103,1 +119,3 @@\n-        Robot robot = null;\n+\n+\n+        \/\/ Wait for inactive frame to become active\n@@ -105,3 +123,6 @@\n-            robot = new Robot();\n-        } catch (Exception e) {\n-            throw new RuntimeException(\"Unable to create robot\");\n+            sema.doWait(TIMEOUT);\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(\"Wait was interrupted\");\n+        }\n+        if (!sema.getState()) {\n+            throw new RuntimeException(\"Frame doesn't become active on show\");\n@@ -109,0 +130,1 @@\n+        sema.setState(false);\n@@ -110,2 +132,5 @@\n-        inactiveFrame.setVisible(true);\n-        activeFrame.setVisible(true);\n+        try {\n+            EventQueue.invokeAndWait(() -> activeFrame.setVisible(true));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Interrupted active frame rendering\");\n+        }\n","filename":"test\/jdk\/java\/awt\/Focus\/InactiveFocusRace.java","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @key headful\n+  @bug 4041703 4096228 4025223 4260929\n+  @summary Ensures that reasonable default focus is set correctly on start\n+  @library ..\/..\/regtesthelpers\n+  @build   Util\n+  @run main InitialFocusTest\n+*\/\n+\n+import java.awt.Button;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import test.java.awt.regtesthelpers.Util;\n+\n+public class InitialFocusTest extends Frame {\n+\n+    Robot robot = Util.createRobot();\n+    Button button = new Button(\"Button\");\n+\n+    public static void main(final String[] args) throws Exception {\n+        InitialFocusTest app = new InitialFocusTest();\n+        app.init();\n+        app.start();\n+    }\n+\n+    public void init() {\n+        setSize(200, 200);\n+        setLocationRelativeTo(null);\n+        setLayout(new FlowLayout());\n+        add(button);\n+        setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        Thread thread = new Thread(new Runnable() {\n+                public void run() {\n+                    Util.waitTillShown(button);\n+                    robot.delay(1000); \/\/ delay the thread to let EDT to start dispatching focus events\n+                    Util.waitForIdle(robot);\n+                    if (!button.hasFocus()) {\n+                        throw new RuntimeException(\"default focus is not set correctly.\");\n+                    }\n+                }\n+            });\n+        thread.start();\n+        thread.join();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/InitialFocusTest\/InitialFocusTest.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 4411534 4517274\n+ * @summary ensures that user's requestFocus() during frame initialization\n+ *          is not ignored\n+ *\/\n+public class InitialFocusTest1 extends Frame implements FocusListener {\n+\n+    Button button1 = new Button(\"Button1\");\n+    Button button2 = new Button(\"Button2\");\n+    private static volatile Object focused;\n+\n+    public static void main(final String[] args) throws Exception {\n+        InitialFocusTest1 app = new InitialFocusTest1();\n+        try {\n+            app.setSize(200, 200);\n+            app.setLocationRelativeTo(null);\n+            app.setLayout(new FlowLayout());\n+\n+            app.button1.addFocusListener(app);\n+            app.button2.addFocusListener(app);\n+            app.add(app.button1);\n+            app.add(app.button2);\n+            app.setVisible(true);\n+            app.button2.requestFocus();\n+            \/\/ wait for the very very last focus event\n+            Thread.sleep(10000);\n+            if (app.button2 != focused) {\n+                throw new RuntimeException(\"Wrong focus owner: \" + focused);\n+            }\n+        } finally {\n+            app.dispose();\n+        }\n+    }\n+\n+    public void focusGained(FocusEvent e) {\n+        focused = e.getSource();\n+        System.out.println(\"focused = \" + focused);\n+    }\n+\n+    public void focusLost(FocusEvent e) {\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/InitialFocusTest\/InitialFocusTest1.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.awt.BorderLayout;\n@@ -35,0 +34,1 @@\n+import java.awt.EventQueue;\n@@ -42,0 +42,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -46,0 +48,2 @@\n+    static Robot robot;\n+    static final CountDownLatch latch = new CountDownLatch(1);\n@@ -48,0 +52,1 @@\n+        robot = new Robot();\n@@ -49,5 +54,22 @@\n-            KeyStrokeTest test = new KeyStrokeTest();\n-            test.doTest();\n-        } finally {\n-            if (frame != null) {\n-                frame.dispose();\n+            EventQueue.invokeAndWait(() -> {\n+                KeyStrokeTest test = new KeyStrokeTest();\n+                test.initTest();\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_TAB);\n+            robot.keyRelease(KeyEvent.VK_TAB);\n+\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_SPACE);\n+            robot.keyRelease(KeyEvent.VK_SPACE);\n+\n+            robot.delay(1000);\n+            robot.keyPress(KeyEvent.VK_A);\n+            robot.keyRelease(KeyEvent.VK_A);\n+            try {\n+                latch.await(3, TimeUnit.SECONDS);\n+            } catch (InterruptedException e) {}\n+            if (!keyTyped) {\n+                throw new\n+                RuntimeException(\"First keystroke after JDialog is closed is lost\");\n@@ -55,0 +77,7 @@\n+            System.out.println(\"Test passed\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -58,3 +87,2 @@\n-    private static void doTest() throws Exception {\n-        final Object monitor = new Object();\n-        frame = new Frame();\n+    private static void initTest() {\n+        frame = new Frame(\"KeyStrokeTest\");\n@@ -74,0 +102,1 @@\n+                    dialog.setLocationRelativeTo(null);\n@@ -84,4 +113,1 @@\n-\n-                    synchronized (monitor) {\n-                        monitor.notifyAll();\n-                    }\n+                    latch.countDown();\n@@ -92,0 +118,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -93,23 +120,0 @@\n-\n-        Robot robot = new Robot();\n-        robot.waitForIdle();\n-        robot.delay(1000);\n-        robot.keyPress(KeyEvent.VK_TAB);\n-        robot.keyRelease(KeyEvent.VK_TAB);\n-\n-        robot.delay(1000);\n-        robot.keyPress(KeyEvent.VK_SPACE);\n-        robot.keyRelease(KeyEvent.VK_SPACE);\n-\n-        robot.delay(1000);\n-        synchronized (monitor) {\n-            robot.keyPress(KeyEvent.VK_A);\n-            robot.keyRelease(KeyEvent.VK_A);\n-            monitor.wait(3000);\n-        }\n-\n-        if (!keyTyped) {\n-            throw new RuntimeException(\"TEST FAILED\");\n-        }\n-\n-        System.out.println(\"Test passed\");\n@@ -117,1 +121,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/Focus\/KeyStrokeTest.java","additions":41,"deletions":38,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * @summary To check proper WINDOW_EVENTS are triggered when Frame gains or losses the focus\n- * @library \/lib\/client\n- * @build ExtendedRobot\n+ * @summary To check proper WINDOW_EVENTS are triggered when Frame gains\n+ * or loses the focus\n@@ -33,0 +32,1 @@\n+import java.awt.AWTException;\n@@ -36,0 +36,2 @@\n+import java.awt.Component;\n+import java.awt.Dimension;\n@@ -39,0 +41,2 @@\n+import java.awt.Point;\n+import java.awt.Robot;\n@@ -46,0 +50,5 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.swing.JButton;\n+import javax.swing.JComponent;\n@@ -49,9 +58,3 @@\n-    private Frame frame, frame2;\n-    private Button button, button2;\n-    private TextField textField, textField2;\n-    private volatile int eventType;\n-    private final Object lock1 = new Object();\n-    private final Object lock2 = new Object();\n-    private final Object lock3 = new Object();\n-    private boolean passed = true;\n-    private final int delay = 150;\n+    private static Frame frame, frame2;\n+    private static Button button, button2;\n+    private static TextField textField, textField2;\n@@ -59,15 +62,3 @@\n-    public static void main(String[] args) throws Exception {\n-        ActiveAWTWindowTest test = new ActiveAWTWindowTest();\n-        try {\n-            test.doTest();\n-        } finally {\n-            EventQueue.invokeAndWait(() -> {\n-                if (test.frame != null) {\n-                    test.frame.dispose();\n-                }\n-                if (test.frame2 != null) {\n-                    test.frame2.dispose();\n-                }\n-            });\n-        }\n-    }\n+    private static CountDownLatch windowActivatedLatch = new CountDownLatch(1);\n+    private static CountDownLatch windowDeactivatedLatch = new CountDownLatch(1);\n+    private static CountDownLatch windowFocusGainedLatch = new CountDownLatch(1);\n@@ -75,9 +66,13 @@\n-    public ActiveAWTWindowTest() {\n-        try{\n-            EventQueue.invokeAndWait( () -> {\n-                    initializeGUI();\n-            });\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Interrupted or unexpected Exception occured\");\n-        }\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            initializeGUI();\n+        });\n+        doTest();\n+        EventQueue.invokeAndWait(() -> {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+            if (frame2 != null) {\n+                frame2.dispose();\n+            }\n+        });\n@@ -86,1 +81,1 @@\n-    private void initializeGUI() {\n+    private static void initializeGUI() {\n@@ -89,1 +84,0 @@\n-\n@@ -93,0 +87,1 @@\n+\n@@ -94,0 +89,1 @@\n+            @Override\n@@ -96,7 +92,1 @@\n-                synchronized (lock3) {\n-                    try {\n-                        lock3.notifyAll();\n-                    } catch (Exception ex) {\n-                        ex.printStackTrace();\n-                    }\n-                }\n+                windowFocusGainedLatch.countDown();\n@@ -105,0 +95,1 @@\n+            @Override\n@@ -106,1 +97,1 @@\n-                    System.out.println(\"Frame Focus lost\");\n+                System.out.println(\"Frame Focus lost\");\n@@ -109,0 +100,1 @@\n+\n@@ -110,0 +102,1 @@\n+            @Override\n@@ -111,9 +104,2 @@\n-                eventType = WindowEvent.WINDOW_ACTIVATED;\n-                System.out.println(\"Undecorated Frame is activated\\n\");\n-                synchronized (lock1) {\n-                    try {\n-                        lock1.notifyAll();\n-                    } catch (Exception ex) {\n-                        ex.printStackTrace();\n-                    }\n-                }\n+                System.out.println(\"Undecorated Frame is activated\");\n+                windowActivatedLatch.countDown();\n@@ -122,0 +108,1 @@\n+            @Override\n@@ -123,9 +110,2 @@\n-                eventType = WindowEvent.WINDOW_DEACTIVATED;\n-                System.out.println(\"Undecorated Frame got Deactivated\\n\");\n-                synchronized (lock2) {\n-                    try {\n-                        lock2.notifyAll();\n-                    } catch (Exception ex) {\n-                        ex.printStackTrace();\n-                    }\n-                }\n+                System.out.println(\"Undecorated Frame got Deactivated\");\n+                windowDeactivatedLatch.countDown();\n@@ -134,0 +114,1 @@\n+\n@@ -136,5 +117,1 @@\n-        button.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                textField.setText(\"Focus gained\");\n-            }\n-        });\n+        button.addActionListener(e -> textField.setText(\"Focus gained\"));\n@@ -152,0 +129,1 @@\n+\n@@ -154,5 +132,1 @@\n-        button2.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                textField2.setText(\"Got the focus\");\n-            }\n-        });\n+        button2.addActionListener(e -> textField2.setText(\"Got the focus\"));\n@@ -163,2 +137,0 @@\n-\n-        frame.toFront();\n@@ -167,10 +139,3 @@\n-    public void doTest() {\n-        ExtendedRobot robot;\n-        try {\n-            robot = new ExtendedRobot();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(\"Cannot create robot\");\n-        }\n-\n-        robot.setAutoDelay(delay);\n+    private static void doTest() throws AWTException, InterruptedException  {\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(150);\n@@ -178,20 +143,2 @@\n-\n-        robot.waitForIdle(5*delay);\n-        robot.mouseMove(button.getLocationOnScreen().x + button.getSize().width \/ 2,\n-                        button.getLocationOnScreen().y + button.getSize().height \/ 2);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-        if (eventType != WindowEvent.WINDOW_ACTIVATED) {\n-            synchronized (lock1) {\n-                try {\n-                    lock1.wait(delay * 10);\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-        if (eventType != WindowEvent.WINDOW_ACTIVATED) {\n-            passed = false;\n-            System.err.println(\"WINDOW_ACTIVATED event did not occur when the \" +\n-                    \"undecorated frame is activated!\");\n+        if (!windowFocusGainedLatch.await(1000, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"Frame did not gain focus\");\n@@ -199,0 +146,1 @@\n+        clickButtonCenter(robot, button);\n@@ -200,14 +148,2 @@\n-        eventType = -1;\n-\n-        robot.mouseMove(button2.getLocationOnScreen().x + button2.getSize().width \/ 2,\n-                        button2.getLocationOnScreen().y + button2.getSize().height \/ 2);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-        if (eventType != WindowEvent.WINDOW_DEACTIVATED) {\n-            synchronized (lock2) {\n-                try {\n-                    lock2.wait(delay * 10);\n-                } catch (Exception e) {\n-                }\n-            }\n+        if (!windowActivatedLatch.await(1000, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"Frame was not activated\");\n@@ -215,4 +151,4 @@\n-        if (eventType != WindowEvent.WINDOW_DEACTIVATED) {\n-            passed = false;\n-            System.err.println(\"FAIL: WINDOW_DEACTIVATED event did not occur for the \" +\n-                    \"undecorated frame when another frame gains focus!\");\n+        clickButtonCenter(robot, button2);\n+\n+        if (!windowDeactivatedLatch.await(2000, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"Frame was not deactivated\");\n@@ -221,3 +157,1 @@\n-            passed = false;\n-            System.err.println(\"FAIL: The undecorated frame has focus even when \" +\n-                        \"another frame is clicked!\");\n+            throw new RuntimeException(\"Frame did not lose focus\");\n@@ -225,0 +159,1 @@\n+    }\n@@ -226,7 +161,8 @@\n-        if (!passed) {\n-            \/\/captureScreenAndSave();\n-            System.err.println(\"Test failed!\");\n-            throw new RuntimeException(\"Test failed.\");\n-        } else {\n-            System.out.println(\"Test passed\");\n-        }\n+    private static void clickButtonCenter(Robot robot, Component button) {\n+        Point location = button.getLocationOnScreen();\n+        Dimension size = button.getSize();\n+        int x = location.x + size.width \/ 2;\n+        int y = location.y + size.height \/ 2;\n+        robot.mouseMove(x, y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -235,0 +171,1 @@\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/MiscUndecorated\/ActiveAWTWindowTest.java","additions":71,"deletions":134,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * test\n+ * @test\n@@ -27,3 +27,4 @@\n- * @summary Tests that AWT use correct toolkit to be wrapped into HeadlessToolkit\n- * @author artem.ananiev@sun.com: area=awt.headless\n- * @run shell WrappedToolkitTest.sh\n+ * @summary Tests that AWT uses correct toolkit wrapped into HeadlessToolkit\n+ * @modules java.desktop\/sun.awt:open\n+ * @library \/test\/lib\n+ * @run main\/othervm -Djava.awt.headless=true TestWrapped\n@@ -32,1 +33,3 @@\n-import java.awt.*;\n+import java.awt.Toolkit;\n+import java.lang.Class;\n+import java.lang.reflect.Field;\n@@ -34,1 +37,1 @@\n-import java.lang.reflect.*;\n+import jdk.test.lib.Platform;\n@@ -36,1 +39,1 @@\n-import sun.awt.*;\n+public final class TestWrapped {\n@@ -38,9 +41,13 @@\n-public class TestWrapped\n-{\n-    public static void main(String[] args)\n-    {\n-        try\n-        {\n-        if (args.length != 1) {\n-            System.err.println(\"No correct toolkit class name is specified, test is not run\");\n-            System.exit(0);\n+    private static final String HEADLESS_TOOLKIT = \"sun.awt.HeadlessToolkit\";\n+    private static final String MACOSX_TOOLKIT = \"sun.lwawt.macosx.LWCToolkit\";\n+    private static final String UNIX_TOOLKIT = \"sun.awt.X11.XToolkit\";\n+    private static final String WINDOWS_TOOLKIT = \"sun.awt.windows.WToolkit\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String expectedToolkitClassName;\n+        if (Platform.isWindows()) {\n+            expectedToolkitClassName = WINDOWS_TOOLKIT;\n+        } else if (Platform.isOSX()) {\n+            expectedToolkitClassName = MACOSX_TOOLKIT;\n+        } else {\n+            expectedToolkitClassName = UNIX_TOOLKIT;\n@@ -49,1 +56,0 @@\n-        String correctToolkitClassName = args[0];\n@@ -51,6 +57,5 @@\n-        Class tkClass = tk.getClass();\n-        if (!tkClass.getName().equals(\"sun.awt.HeadlessToolkit\"))\n-        {\n-            System.err.println(tkClass.getName());\n-            System.err.println(\"Error: default toolkit is not an instance of HeadlessToolkit\");\n-            System.exit(-1);\n+        Class<?> tkClass = tk.getClass();\n+        if (!tkClass.getName().equals(HEADLESS_TOOLKIT)) {\n+            System.err.println(\"Expected: \" + HEADLESS_TOOLKIT);\n+            System.err.println(\"Actual: \" + tkClass.getName());\n+            throw new RuntimeException(\"Wrong default toolkit\");\n@@ -61,6 +66,5 @@\n-        Class wrappedClass = f.get(tk).getClass();\n-        if (!wrappedClass.getName().equals(correctToolkitClassName)) {\n-            System.err.println(wrappedClass.getName());\n-            System.err.println(\"Error: wrapped toolkit is not an instance of \" + correctToolkitClassName);\n-            System.exit(-1);\n-        }\n+        Class<?> wrappedClass = f.get(tk).getClass();\n+        if (!wrappedClass.getName().equals(expectedToolkitClassName)) {\n+            System.err.println(\"Expected: \" + expectedToolkitClassName);\n+            System.err.println(\"Actual: \" + wrappedClass.getName());\n+            throw new RuntimeException(\"Wrong wrapped toolkit\");\n@@ -68,7 +72,0 @@\n-        catch (Exception z)\n-        {\n-            z.printStackTrace(System.err);\n-            System.exit(-1);\n-        }\n-\n-        System.exit(0);\n","filename":"test\/jdk\/java\/awt\/Toolkit\/Headless\/WrappedToolkitTest\/TestWrapped.java","additions":34,"deletions":37,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1,221 +0,0 @@\n-#!\/bin\/ksh -p\n-\n-#\n-# Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-#   @test\n-#   @bug 6282388 8030640\n-#   @summary Tests that AWT use correct toolkit to be wrapped into HeadlessToolkit\n-#   @author artem.ananiev@sun.com: area=awt.headless\n-#   compile TestWrapped.java\n-#   @run shell WrappedToolkitTest.sh\n-\n-# Beginning of subroutines:\n-status=1\n-\n-#Call this from anywhere to fail the test with an error message\n-# usage: fail \"reason why the test failed\"\n-fail() \n- { echo \"The test failed :-(\"\n-   echo \"$*\" 1>&2\n-   echo \"exit status was $status\"\n-   exit $status\n- } #end of fail()\n-\n-#Call this from anywhere to pass the test with a message\n-# usage: pass \"reason why the test passed if applicable\"\n-pass() \n- { echo \"The test passed!!!\"\n-   echo \"$*\" 1>&2\n-   exit 0\n- } #end of pass()\n-\n-# end of subroutines\n-\n-\n-# The beginning of the script proper\n-\n-# Checking for proper OS\n-OS=`uname -s`\n-case \"$OS\" in\n-   AIX | CYGWIN* | Darwin | Linux )\n-      FILESEP=\"\/\"\n-      ;;\n-    \n-   Windows* )\n-      FILESEP=\"\\\\\"\n-      ;;\n-\n-   # catch all other OSs\n-   * )\n-      echo \"Unrecognized system!  $OS\"\n-      fail \"Unrecognized system!  $OS\"\n-      ;;\n-esac\n-\n-# check that some executable or other file you need is available, abort if not\n-#  note that the name of the executable is in the fail string as well.\n-# this is how to check for presence of the compiler, etc.\n-#RESOURCE=`whence SomeProgramOrFileNeeded`\n-#if [ \"${RESOURCE}\" = \"\" ] ; \n-#   then fail \"Need SomeProgramOrFileNeeded to perform the test\" ; \n-#fi\n-\n-# Want this test to run standalone as well as in the harness, so do the \n-#  following to copy the test's directory into the harness's scratch directory \n-#  and set all appropriate variables:\n-\n-if [ -z \"${TESTJAVA}\" ] ; then\n-   # TESTJAVA is not set, so the test is running stand-alone.\n-   # TESTJAVA holds the path to the root directory of the build of the JDK\n-   # to be tested.  That is, any java files run explicitly in this shell\n-   # should use TESTJAVA in the path to the java interpreter.\n-   # So, we'll set this to the JDK spec'd on the command line.  If none\n-   # is given on the command line, tell the user that and use a cheesy\n-   # default.\n-   # THIS IS THE JDK BEING TESTED.\n-   if [ -n \"$1\" ] ;\n-      then TESTJAVA=$1\n-      else fail \"no JDK specified on command line!\"\n-   fi\n-   TESTSRC=.\n-   TESTCLASSES=.\n-   STANDALONE=1;\n-fi\n-echo \"JDK under test is: $TESTJAVA\"\n-\n-#if in test harness, then copy the entire directory that the test is in over \n-# to the scratch directory.  This catches any support files needed by the test.\n-if [ -z \"${STANDALONE}\" ] ; \n-   then cp ${TESTSRC}\/* . \n-fi\n-case \"$OS\" in\n-  Windows* | CYGWIN* )\n-    ${COMPILEJAVA}\/bin\/javac ${TESTJAVACOPTS} \\\n-                         --add-exports java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-exports java.desktop\/sun.awt.windows=ALL-UNNAMED ${CP} \\\n-                         *.java\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Compilation failed\";\n-    fi\n-    ;;\n-\n-  AIX | Linux )\n-    ${COMPILEJAVA}\/bin\/javac ${TESTJAVACOPTS} \\\n-                         --add-exports java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-exports java.desktop\/sun.awt.X11=ALL-UNNAMED ${CP} \\\n-                         *.java\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Compilation failed\";\n-    fi\n-    ;;\n-\n-  Darwin)\n-    ${COMPILEJAVA}\/bin\/javac ${TESTJAVACOPTS} \\\n-                         --add-exports java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-exports java.desktop\/sun.lwawt.macosx=ALL-UNNAMED ${CP} \\\n-                         *.java\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Compilation failed\";\n-    fi\n-    ;;\n-\n-esac\n-\n-#Just before executing anything, make sure it has executable permission!\n-chmod 777 .\/*\n-\n-###############  YOUR TEST CODE HERE!!!!!!!  #############\n-\n-case \"$OS\" in\n-  Windows* | CYGWIN* )\n-    ${TESTJAVA}\/bin\/java ${TESTVMOPTS} -Djava.awt.headless=true \\\n-                         --add-opens java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-opens java.desktop\/sun.awt.windows=ALL-UNNAMED ${CP} \\\n-                         TestWrapped sun.awt.windows.WToolkit\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Test FAILED: toolkit wrapped into HeadlessToolkit is not an instance of sun.awt.windows.WToolkit\";\n-    fi\n-    ${TESTJAVA}\/bin\/java ${TESTVMOPTS} -Djava.awt.headless=true \\\n-                         --add-opens java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-opens java.desktop\/sun.awt.windows=ALL-UNNAMED ${CP} \\\n-                         -Dawt.toolkit=sun.awt.windows.WToolkit \\\n-                         TestWrapped sun.awt.windows.WToolkit\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Test FAILED: toolkit wrapped into HeadlessToolkit is not an instance of sun.awt.windows.WToolkit\";\n-    fi\n-    ;;\n-\n-  AIX | Linux )\n-    ${TESTJAVA}\/bin\/java ${TESTVMOPTS} -Djava.awt.headless=true \\\n-                         --add-opens java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-opens java.desktop\/sun.awt.X11=ALL-UNNAMED ${CP} \\\n-                         -Dawt.toolkit=sun.awt.X11.XToolkit \\\n-                         TestWrapped sun.awt.X11.XToolkit\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Test FAILED: toolkit wrapped into HeadlessToolkit is not an instance of sun.awt.xawt.XToolkit\";\n-    fi\n-    AWT_TOOLKIT=XToolkit ${TESTJAVA}\/bin\/java ${TESTVMOPTS} \\\n-                         --add-opens java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-opens java.desktop\/sun.awt.X11=ALL-UNNAMED ${CP} \\\n-                                              -Djava.awt.headless=true \\\n-                                              TestWrapped sun.awt.X11.XToolkit\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Test FAILED: toolkit wrapped into HeadlessToolkit is not an instance of sun.awt.xawt.XToolkit\";\n-    fi\n-    ;;\n-\n-  Darwin)\n-    ${TESTJAVA}\/bin\/java ${TESTVMOPTS} -Djava.awt.headless=true \\\n-                         --add-opens java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-opens java.desktop\/sun.lwawt.macosx=ALL-UNNAMED ${CP} \\\n-                         TestWrapped sun.lwawt.macosx.LWCToolkit\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Test FAILED: toolkit wrapped into HeadlessToolkit is not an instance of sun.lwawt.macosx.LWCToolkit\";\n-    fi\n-    ${TESTJAVA}\/bin\/java ${TESTVMOPTS} -Djava.awt.headless=true \\\n-                         --add-opens java.desktop\/sun.awt=ALL-UNNAMED \\\n-                         --add-opens java.desktop\/sun.lwawt.macosx=ALL-UNNAMED ${CP} \\\n-                         -Dawt.toolkit=sun.lwawt.macosx.LWCToolkit \\\n-                         TestWrapped sun.lwawt.macosx.LWCToolkit\n-    status=$?\n-    if [ ! $status -eq \"0\" ]; then\n-      fail \"Test FAILED: toolkit wrapped into HeadlessToolkit is not an instance of sun.lwawt.macosx.LWCToolkit\";\n-    fi\n-    ;;\n-\n-esac\n-\n-pass \"All the tests are PASSED\";\n-\n-#For additional examples of how to write platform independent KSH scripts,\n-# see the jtreg file itself.  It is a KSH script for both Solaris and Win32\n","filename":"test\/jdk\/java\/awt\/Toolkit\/Headless\/WrappedToolkitTest\/WrappedToolkitTest.sh","additions":0,"deletions":221,"binary":false,"changes":221,"status":"deleted"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4138921\n+ * @summary Confirm constructor behavior for various edge cases.\n+ *\/\n+\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.Shape;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.TextAttribute;\n+import java.awt.font.TextHitInfo;\n+import java.awt.font.TextLayout;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.text.AttributedCharacterIterator;\n+import java.text.AttributedString;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+public class TextLayoutConstructorTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        testFontConstructor();\n+        testMapConstructor();\n+        testIteratorConstructor();\n+    }\n+\n+    private static void testFontConstructor() {\n+\n+        \/\/ new TextLayout(String, Font, FontRenderContext)\n+\n+        Font font = new Font(Font.DIALOG, Font.PLAIN, 20);\n+        FontRenderContext frc = new FontRenderContext(null, true, true);\n+\n+        assertThrows(() -> new TextLayout(null, font, frc),\n+            IllegalArgumentException.class,\n+            \"Null string passed to TextLayout constructor.\");\n+\n+        assertThrows(() -> new TextLayout(\"test\", (Font) null, frc),\n+            IllegalArgumentException.class,\n+            \"Null font passed to TextLayout constructor.\");\n+\n+        assertThrows(() -> new TextLayout(\"test\", font, null),\n+            IllegalArgumentException.class,\n+            \"Null font render context passed to TextLayout constructor.\");\n+\n+        Function< String, TextLayout > creator = (s) -> new TextLayout(s, font, frc);\n+        assertEmptyTextLayoutBehavior(creator);\n+    }\n+\n+    private static void testMapConstructor() {\n+\n+        \/\/ new TextLayout(String, Map, FontRenderContext)\n+\n+        Map< TextAttribute, Object > attributes = Map.of(TextAttribute.WEIGHT, TextAttribute.WEIGHT_BOLD);\n+        FontRenderContext frc = new FontRenderContext(null, true, true);\n+\n+        assertThrows(() -> new TextLayout(null, attributes, frc),\n+            IllegalArgumentException.class,\n+            \"Null string passed to TextLayout constructor.\");\n+\n+        assertThrows(() -> new TextLayout(\"test\", (Map) null, frc),\n+            IllegalArgumentException.class,\n+            \"Null map passed to TextLayout constructor.\");\n+\n+        assertThrows(() -> new TextLayout(\"test\", attributes, null),\n+            IllegalArgumentException.class,\n+            \"Null font render context passed to TextLayout constructor.\");\n+\n+        Function< String, TextLayout > creator = (s) -> new TextLayout(s, attributes, frc);\n+        assertEmptyTextLayoutBehavior(creator);\n+    }\n+\n+    private static void testIteratorConstructor() {\n+\n+        \/\/ new TextLayout(AttributedCharacterIterator, FontRenderContext)\n+\n+        Map< TextAttribute, Object > attributes = Map.of();\n+        FontRenderContext frc = new FontRenderContext(null, true, true);\n+\n+        assertThrows(() -> new TextLayout(null, frc),\n+            IllegalArgumentException.class,\n+            \"Null iterator passed to TextLayout constructor.\");\n+\n+        AttributedCharacterIterator it1 = new AttributedString(\"test\", attributes).getIterator();\n+        assertThrows(() -> new TextLayout(it1, null),\n+            IllegalArgumentException.class,\n+            \"Null font render context passed to TextLayout constructor.\");\n+\n+        Function< String, TextLayout > creator = (s) -> {\n+            AttributedCharacterIterator it2 = new AttributedString(s, attributes).getIterator();\n+            return new TextLayout(it2, frc);\n+        };\n+        assertEmptyTextLayoutBehavior(creator);\n+    }\n+\n+    private static void assertEmptyTextLayoutBehavior(Function< String, TextLayout > creator) {\n+\n+        TextLayout tl = creator.apply(\"\");\n+        TextLayout ref = creator.apply(\" \"); \/\/ space\n+        FontRenderContext frc = new FontRenderContext(null, true, true);\n+        Rectangle zero = new Rectangle(0, 0, 0, 0);\n+        Rectangle2D.Float zero2D = new Rectangle2D.Float(0, 0, 0, 0);\n+        Rectangle2D.Float oneTwo = new Rectangle2D.Float(1, 2, 0, 0);\n+        Rectangle2D.Float kilo = new Rectangle2D.Float(0, 0, 1000, 1000);\n+        AffineTransform identity = new AffineTransform();\n+        TextLayout.CaretPolicy policy = new TextLayout.CaretPolicy();\n+        TextHitInfo start = TextHitInfo.trailing(-1);\n+        TextHitInfo end = TextHitInfo.leading(0);\n+\n+        assertEqual(0, tl.getJustifiedLayout(100).getAdvance(), \"justified advance\");\n+        assertEqual(0, tl.getBaseline(), \"baseline\");\n+\n+        float[] offsets = tl.getBaselineOffsets();\n+        float[] refOffsets = ref.getBaselineOffsets();\n+        assertEqual(3, offsets.length, \"baseline offsets\");\n+        assertEqual(refOffsets[0], offsets[0], \"baseline offset 1\");\n+        assertEqual(refOffsets[1], offsets[1], \"baseline offset 2\");\n+        assertEqual(refOffsets[2], offsets[2], \"baseline offset 3\");\n+\n+        assertEqual(0, tl.getAdvance(), \"advance\");\n+        assertEqual(0, tl.getVisibleAdvance(), \"visible advance\");\n+        assertEqual(ref.getAscent(), tl.getAscent(), \"ascent\");\n+        assertEqual(ref.getDescent(), tl.getDescent(), \"descent\");\n+        assertEqual(ref.getLeading(), tl.getLeading(), \"leading\");\n+        assertEqual(zero2D, tl.getBounds(), \"bounds\");\n+        assertEqual(zero2D, tl.getPixelBounds(frc, 0, 0), \"pixel bounds 1\");\n+        assertEqual(oneTwo, tl.getPixelBounds(frc, 1, 2), \"pixel bounds 2\");\n+        assertEqual(true, tl.isLeftToRight(), \"left to right\");\n+        assertEqual(false, tl.isVertical(), \"is vertical\");\n+        assertEqual(0, tl.getCharacterCount(), \"character count\");\n+\n+        float[] caretInfo = tl.getCaretInfo(start, kilo);\n+        float[] refCaretInfo = ref.getCaretInfo(start, kilo);\n+        assertEqual(6, caretInfo.length, \"caret info length 1\");\n+        assertEqual(refCaretInfo[0], caretInfo[0], \"first caret info 1\");\n+        assertEqual(refCaretInfo[1], caretInfo[1], \"second caret info 1\");\n+        assertEqual(refCaretInfo[2], caretInfo[2], \"third caret info 1\");\n+        assertEqual(refCaretInfo[3], caretInfo[3], \"fourth caret info 1\");\n+        assertEqual(refCaretInfo[4], caretInfo[4], \"fifth caret info 1\");\n+        assertEqual(refCaretInfo[5], caretInfo[5], \"sixth caret info 1\");\n+\n+        float[] caretInfo2 = tl.getCaretInfo(start);\n+        float[] refCaretInfo2 = ref.getCaretInfo(start);\n+        assertEqual(6, caretInfo2.length, \"caret info length 2\");\n+        assertEqual(refCaretInfo2[0], caretInfo2[0], \"first caret info 2\");\n+        assertEqual(refCaretInfo2[1], caretInfo2[1], \"second caret info 2\");\n+        assertEqual(refCaretInfo2[2], caretInfo2[2], \"third caret info 2\");\n+        assertEqual(refCaretInfo2[3], caretInfo2[3], \"fourth caret info 2\");\n+        assertEqual(refCaretInfo2[4], caretInfo2[4], \"fifth caret info 2\");\n+        assertEqual(refCaretInfo2[5], caretInfo2[5], \"sixth caret info 2\");\n+\n+        assertEqual(null, tl.getNextRightHit(start), \"next right hit 1\");\n+        assertEqual(null, tl.getNextRightHit(end), \"next right hit 2\");\n+        assertEqual(null, tl.getNextRightHit(0, policy), \"next right hit 3\");\n+        assertEqual(null, tl.getNextRightHit(0), \"next right hit 4\");\n+        assertEqual(null, tl.getNextLeftHit(start), \"next left hit 1\");\n+        assertEqual(null, tl.getNextLeftHit(end), \"next left hit 2\");\n+        assertEqual(null, tl.getNextLeftHit(0, policy), \"next left hit 3\");\n+        assertEqual(null, tl.getNextLeftHit(0), \"next left hit 4\");\n+        assertEqual(end, tl.getVisualOtherHit(start), \"visual other hit\");\n+\n+        Shape caretShape = tl.getCaretShape(start, kilo);\n+        Shape refCaretShape = ref.getCaretShape(start, kilo);\n+        assertEqual(refCaretShape.getBounds(), caretShape.getBounds(), \"caret shape 1\");\n+\n+        Shape caretShape2 = tl.getCaretShape(start);\n+        Shape refCaretShape2 = ref.getCaretShape(start);\n+        assertEqual(refCaretShape2.getBounds(), caretShape2.getBounds(), \"caret shape 2\");\n+\n+        assertEqual(0, tl.getCharacterLevel(0), \"character level\");\n+\n+        Shape[] caretShapes = tl.getCaretShapes(0, kilo, policy);\n+        Shape[] refCaretShapes = ref.getCaretShapes(0, kilo, policy);\n+        assertEqual(2, caretShapes.length, \"caret shapes length 1\");\n+        assertEqual(refCaretShapes[0].getBounds(), caretShapes[0].getBounds(), \"caret shapes strong 1\");\n+        assertEqual(refCaretShapes[1], caretShapes[1], \"caret shapes weak 1\");\n+        assertEqual(null, caretShapes[1], \"caret shapes weak 1\");\n+\n+        Shape[] caretShapes2 = tl.getCaretShapes(0, kilo);\n+        Shape[] refCaretShapes2 = ref.getCaretShapes(0, kilo);\n+        assertEqual(2, caretShapes2.length, \"caret shapes length 2\");\n+        assertEqual(refCaretShapes2[0].getBounds(), caretShapes2[0].getBounds(), \"caret shapes strong 2\");\n+        assertEqual(refCaretShapes2[1], caretShapes2[1], \"caret shapes weak 2\");\n+        assertEqual(null, caretShapes2[1], \"caret shapes weak 2\");\n+\n+        Shape[] caretShapes3 = tl.getCaretShapes(0);\n+        Shape[] refCaretShapes3 = ref.getCaretShapes(0);\n+        assertEqual(2, caretShapes3.length, \"caret shapes length 3\");\n+        assertEqual(refCaretShapes3[0].getBounds(), caretShapes3[0].getBounds(), \"caret shapes strong 3\");\n+        assertEqual(refCaretShapes3[1], caretShapes3[1], \"caret shapes weak 3\");\n+        assertEqual(null, caretShapes3[1], \"caret shapes weak 3\");\n+\n+        assertEqual(0, tl.getLogicalRangesForVisualSelection(start, start).length, \"logical ranges for visual selection\");\n+        assertEqual(zero2D, tl.getVisualHighlightShape(start, start, kilo).getBounds(), \"visual highlight shape 1\");\n+        assertEqual(zero2D, tl.getVisualHighlightShape(start, start).getBounds(), \"visual highlight shape 2\");\n+        assertEqual(zero, tl.getLogicalHighlightShape(0, 0, kilo).getBounds(), \"logical highlight shape 1\");\n+        assertEqual(zero, tl.getLogicalHighlightShape(0, 0).getBounds(), \"logical highlight shape 2\");\n+        assertEqual(zero, tl.getBlackBoxBounds(0, 0).getBounds(), \"black box bounds\");\n+\n+        TextHitInfo hit = tl.hitTestChar(0, 0);\n+        assertEqual(-1, hit.getCharIndex(), \"hit test char index 1\");\n+        assertEqual(false, hit.isLeadingEdge(), \"hit test leading edge 1\");\n+\n+        TextHitInfo hit2 = tl.hitTestChar(0, 0, kilo);\n+        assertEqual(-1, hit2.getCharIndex(), \"hit test char index 2\");\n+        assertEqual(false, hit2.isLeadingEdge(), \"hit test leading edge 2\");\n+\n+        assertEqual(false, tl.equals(creator.apply(\"\")), \"equals\");\n+        assertEqual(false, tl.toString().isEmpty(), \"to string\");\n+        assertDoesNotDraw(tl);\n+        assertEqual(zero2D, tl.getOutline(identity).getBounds(), \"outline\");\n+        assertEqual(null, tl.getLayoutPath(), \"layout path\");\n+\n+        Point2D.Float point = new Point2D.Float(7, 7);\n+        tl.hitToPoint(start, point);\n+        assertEqual(0, point.x, \"hit to point x\");\n+        assertEqual(0, point.y, \"hit to point y\");\n+    }\n+\n+    private static void assertEqual(int expected, int actual, String name) {\n+        if (expected != actual) {\n+            throw new RuntimeException(\"Expected \" + name + \" = \" + expected + \", but got \" + actual);\n+        }\n+    }\n+\n+    private static void assertEqual(float expected, float actual, String name) {\n+        if (expected != actual) {\n+            throw new RuntimeException(\"Expected \" + name + \" = \" + expected + \", but got \" + actual);\n+        }\n+    }\n+\n+    private static void assertEqual(boolean expected, boolean actual, String name) {\n+        if (expected != actual) {\n+            throw new RuntimeException(\"Expected \" + name + \" = \" + expected + \", but got \" + actual);\n+        }\n+    }\n+\n+    private static void assertEqual(Object expected, Object actual, String name) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new RuntimeException(\"Expected \" + name + \" = \" + expected + \", but got \" + actual);\n+        }\n+    }\n+\n+    private static void assertThrows(Runnable r, Class< ? > type, String message) {\n+        Class< ? > actualType;\n+        String actualMessage;\n+        Exception actualException;\n+        try {\n+            r.run();\n+            actualType = null;\n+            actualMessage = null;\n+            actualException = null;\n+        } catch (Exception e) {\n+            actualType = e.getClass();\n+            actualMessage = e.getMessage();\n+            actualException = e;\n+        }\n+        if (!Objects.equals(type, actualType)) {\n+            throw new RuntimeException(type + \" != \" + actualType, actualException);\n+        }\n+        if (!Objects.equals(message, actualMessage)) {\n+            throw new RuntimeException(message + \" != \" + actualMessage, actualException);\n+        }\n+    }\n+\n+    private static void assertDoesNotDraw(TextLayout layout) {\n+\n+        int w = 200;\n+        int h = 200;\n+        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_BYTE_BINARY);\n+        Graphics2D g2d = image.createGraphics();\n+        int expected = image.getRGB(0, 0);\n+\n+        layout.draw(g2d, w \/ 2f, h \/ 2f); \/\/ should not actually draw anything\n+\n+        int[] rowPixels = new int[w];\n+        for (int y = 0; y < h; y++) {\n+            image.getRGB(0, y, w, 1, rowPixels, 0, w);\n+            for (int x = 0; x < w; x++) {\n+                if (rowPixels[x] != expected) {\n+                    throw new RuntimeException(\n+                        \"pixel (\" + x + \", \" + y +\"): \" + expected + \" != \" + rowPixels[x]);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/TextLayout\/TextLayoutConstructorTest.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8310242\n+ * @bug 8310242 8328874\n@@ -40,0 +40,10 @@\n+    \/\/Max length in Modified UTF-8 bytes for class names.\n+    private static final int JAVA_CLASSNAME_MAX_LEN = 65535;\n+\n+    private static final String ONE_BYTE = \"A\";                    \/\/ 1-byte UTF-8\n+    private static final String TWO_BYTE = \"\\u0100\";               \/\/ 2-byte UTF-8\n+    private static final String THREE_BYTE = \"\\u2600\";             \/\/ 3-byte UTF-8\n+\n+    private static final String ERR_MSG_IN_CORE = \"Class name length exceeds limit of\"; \/\/ check in corelib\n+    private static final String ERR_MSG_IN_JVM = \"Class name exceeds maximum length\";   \/\/ check in jvm\n+\n@@ -93,1 +103,75 @@\n-}\n+    static Stream<Arguments> validLen() {\n+        return Stream.of(\n+                \/\/ 1-byte character\n+                Arguments.of(ONE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN - 1)),\n+                Arguments.of(ONE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN)),\n+                Arguments.of(ONE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 3 - 1)),\n+                Arguments.of(ONE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 3)),\n+                Arguments.of(ONE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 3 + 1)),\n+                \/\/ 2-byte characters\n+                Arguments.of(TWO_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 2)),\n+                Arguments.of(TWO_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 6)),\n+                Arguments.of(TWO_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 6 + 1)),\n+                \/\/ 3-byte characters\n+                Arguments.of(THREE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 3 - 1)),\n+                Arguments.of(THREE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 3)),\n+                Arguments.of(THREE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 9)),\n+                Arguments.of(THREE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 9 + 1))\n+        );\n+    }\n+\n+    \/*\n+     * Test class name length handling in 1-arg and 3-arg Class::forName\n+     * with valid length.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validLen\")\n+    void testValidLen(String cn) {\n+        ClassLoader loader = ForNameNames.class.getClassLoader();\n+        \/\/ 3-arg Class.forName\n+        ClassNotFoundException ex = assertThrows(ClassNotFoundException.class,\n+                                                 () -> Class.forName(cn, false, loader));\n+        assertFalse(ex.getMessage().contains(ERR_MSG_IN_CORE)\n+                    || ex.getMessage().contains(ERR_MSG_IN_JVM),\n+                    \"Unexpected exception message\");\n+\n+        \/\/ 1-arg Class.forName\n+        ex = assertThrows(ClassNotFoundException.class,\n+                          () -> Class.forName(cn));\n+        assertFalse(ex.getMessage().contains(ERR_MSG_IN_CORE)\n+                    || ex.getMessage().contains(ERR_MSG_IN_JVM),\n+                    \"Unexpected exception message\");\n+    }\n+\n+    static Stream<Arguments> invalidLen() {\n+        return Stream.of(\n+                \/\/ 1-byte characters over the limit\n+                Arguments.of(ONE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN + 1)),\n+                \/\/ 2-byte characters over the limit\n+                Arguments.of(TWO_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 2 + 1)),\n+                \/\/ 3-byte characters over the limit\n+                Arguments.of(THREE_BYTE.repeat(JAVA_CLASSNAME_MAX_LEN \/ 3 + 1))\n+        );\n+    }\n+\n+    \/*\n+     * Test class name length handling in 1-arg and 3-arg Class::forName\n+     * with invalid (too long) length.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"invalidLen\")\n+    void testInvalidLen(String cn) {\n+        ClassLoader loader = ForNameNames.class.getClassLoader();\n+        \/\/ 3-arg Class.forName\n+        ClassNotFoundException ex = assertThrows(ClassNotFoundException.class,\n+                                                 () -> Class.forName(cn, false, loader));\n+        assertTrue(ex.getMessage().contains(ERR_MSG_IN_CORE),\n+                   \"Unexpected exception message\");\n+\n+        \/\/ 1-arg Class.forName\n+        ex = assertThrows(ClassNotFoundException.class,\n+                          () -> Class.forName(cn));\n+        assertTrue(ex.getMessage().contains(ERR_MSG_IN_CORE),\n+                   \"Unexpected exception message\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/Class\/forName\/ForNameNames.java","additions":87,"deletions":3,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -26,4 +26,2 @@\n- * @library \/test\/lib\n- * @build jdk.test.lib.RandomFactory\n- * @run main BigIntegerTest\n- * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027 8229845 8077587\n+ * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465\n+ *      8074460 8078672 8032027 8229845 8077587 8367365\n@@ -31,2 +29,0 @@\n- * @run main\/timeout=400 BigIntegerTest\n- * @author madbot\n@@ -34,0 +30,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main\/timeout=480 BigIntegerTest\n@@ -1400,2 +1399,2 @@\n-            String.valueOf(1 + random.nextInt(3))));\n-        if (subset < 0 || subset > 3) {\n+            String.valueOf(1 + random.nextInt(4))));\n+        if (subset < 0 || subset > 4) {\n@@ -1446,5 +1445,0 @@\n-            squareRoot();\n-            squareRootAndRemainder();\n-            nthRoot();\n-            nthRootAndRemainder();\n-\n@@ -1477,0 +1471,7 @@\n+        if (subset == 0 || subset == 4) {\n+            squareRoot();\n+            squareRootAndRemainder();\n+\n+            nthRoot();\n+            nthRootAndRemainder();\n+        }\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n- * @bug 8209137 8326233\n+ * @bug 8209137 8326233 8367112\n@@ -274,0 +274,14 @@\n+        SSLParameters d = new SSLParameters();\n+        d.setSignatureSchemes(new String[] { \"C\" });\n+        builder.sslParameters(d);\n+        d.setSignatureSchemes(new String[] { \"D\" });\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getSignatureSchemes()[0].equals(\"C\"));\n+        }\n+        SSLParameters e = new SSLParameters();\n+        e.setNamedGroups(new String[] { \"C\" });\n+        builder.sslParameters(e);\n+        e.setNamedGroups(new String[] { \"D\" });\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getNamedGroups()[0].equals(\"C\"));\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientBuilderTest.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,15 @@\n+\/* @test\n+ * @bug 7130915 8289689 8366911\n+ * @summary Tests file path names with standard encoding on macOS\n+ * @requires (os.family == \"mac\")\n+ * @library \/test\/lib ..\n+ * @build jdk.test.lib.Utils\n+ *        jdk.test.lib.Asserts\n+ *        jdk.test.lib.JDKToolFinder\n+ *        jdk.test.lib.JDKToolLauncher\n+ *        jdk.test.lib.Platform\n+ *        jdk.test.lib.process.*\n+ *        TestUtil MacPath\n+ * @run main MacPath\n+ *\/\n+\n@@ -29,2 +44,0 @@\n-import java.text.Normalizer;\n-import java.text.Normalizer.Form;\n@@ -35,3 +48,0 @@\n-    private static final String PROPERTY_NORMALIZE_FILE_PATHS =\n-        \"jdk.nio.path.useNormalizationFormD\";\n-\n@@ -86,5 +96,2 @@\n-        String fname = null;\n-        Normalizer.Form form = Boolean.getBoolean(PROPERTY_NORMALIZE_FILE_PATHS)\n-            ? Normalizer.Form.NFD : Normalizer.Form.NFC;\n-        String dname_nfd = Normalizer.normalize(dname, form);\n-        String fname_nfd = Normalizer.normalize(fname_nfc, form);\n+        String dname_nfd = dname;\n+        String fname_nfd = fname_nfc;\n@@ -103,1 +110,1 @@\n-        fname = dpath.toString();\n+        String fname = dpath.toString();\n@@ -145,1 +152,1 @@\n-        if (!found_dir || !found_file_nfc || !found_file_nfd) {\n+        if (!found_dir || !found_file_nfc || !found_file_nfd)\n@@ -147,1 +154,1 @@\n-        }\n+\n","filename":"test\/jdk\/java\/nio\/file\/Path\/MacPath.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 7130915 8289689\n- * @summary Tests file path with nfc\/nfd forms on MacOSX\n- * @requires (os.family == \"mac\")\n- * @library \/test\/lib ..\n- * @build jdk.test.lib.Utils\n- *        jdk.test.lib.Asserts\n- *        jdk.test.lib.JDKToolFinder\n- *        jdk.test.lib.JDKToolLauncher\n- *        jdk.test.lib.Platform\n- *        jdk.test.lib.process.*\n- *        TestUtil MacPath\n- * @run main MacPathTest\n- * @run main\/othervm -Djdk.nio.path.useNormalizationFormD=true MacPathTest\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class MacPathTest {\n-    private static final String PROPERTY_NORMALIZE_FILE_PATHS =\n-        \"jdk.nio.path.useNormalizationFormD\";\n-    private static final boolean NORMALIZE_FILE_PATHS =\n-        Boolean.getBoolean(PROPERTY_NORMALIZE_FILE_PATHS);\n-\n-    public static void main(String args[]) throws Exception {\n-        ProcessBuilder pb;\n-        if (NORMALIZE_FILE_PATHS) {\n-            String option = \"-D\" + PROPERTY_NORMALIZE_FILE_PATHS + \"=true\";\n-            pb = ProcessTools.createTestJavaProcessBuilder(option, MacPath.class.getName());\n-        } else {\n-            pb = ProcessTools.createTestJavaProcessBuilder(MacPath.class.getName());\n-        }\n-        pb.environment().put(\"LC_ALL\", \"en_US.UTF-8\");\n-        ProcessTools.executeProcess(pb)\n-                    .outputTo(System.out)\n-                    .errorTo(System.err)\n-                    .shouldHaveExitValue(0);\n-    }\n-}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/MacPathTest.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms KEYSTORE.JKs true\n+ * @run main\/othervm TestDisabledAlgorithms keySTORE.what false\n+ * @run main\/othervm TestDisabledAlgorithms kEYstoRe.jceKS false\n+ * @run main\/othervm -Djdk.crypto.disabledAlgorithms=\"keystore.jkS\" TestDisabledAlgorithms keySTORE.jceKs true\n+ * @run main\/othervm -Djdk.crypto.disabledAlgorithms=\"KEYstORE.what\" TestDisabledAlgorithms KeYStore.JKs false\n+ * @run main\/othervm -Djdk.crypto.disabledAlgorithms=\"keystOre.jceKS\" TestDisabledAlgorithms KEysTORE.JKS false\n+ *\/\n+import java.io.File;\n+import java.util.List;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.Provider;\n+import java.security.Security;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    \/\/ reuse existing JKS test keystore\n+    private final static String DIR = System.getProperty(\"test.src\", \".\");\n+    private static final char[] PASSWD = \"passphrase\".toCharArray();\n+    private static final String JKS_FN = \"keystore.jks\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> KeyStore.getInstance(a),\n+                            KeyStoreException.class);\n+                    Utils.runAndCheckException(\n+                            () -> KeyStore.getInstance(new File(DIR, JKS_FN),\n+                                PASSWD),\n+                            KeyStoreException.class);\n+                    Utils.runAndCheckException(\n+                            () -> KeyStore.getInstance(new File(DIR, JKS_FN),\n+                                () -> {\n+                                    return new KeyStore.PasswordProtection(PASSWD);\n+                                }),\n+                            KeyStoreException.class);\n+                } else {\n+                    \/\/ with a provider argument\n+                    Utils.runAndCheckException(() -> KeyStore.getInstance(a, p),\n+                            KeyStoreException.class);\n+                    Utils.runAndCheckException(() -> KeyStore.getInstance(a,\n+                            p.getName()), KeyStoreException.class);\n+                }\n+            } else {\n+                KeyStore k;\n+                if (p == null) {\n+                    k = KeyStore.getInstance(a);\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                    k = KeyStore.getInstance(new File(DIR, JKS_FN), PASSWD);\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                    k = KeyStore.getInstance(new File(DIR, JKS_FN),\n+                        () -> {\n+                            return new KeyStore.PasswordProtection(PASSWD);\n+                        });\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                } else {\n+                    \/\/ with a provider argument\n+                    k = KeyStore.getInstance(a, p);\n+                    k = KeyStore.getInstance(a, p.getName());\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"JKS\", \"jkS\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"KeyStore.JKS\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/KeyStore\/TestDisabledAlgorithms.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms MESSAGEdigest.Sha-512 true\n+ * @run main\/othervm TestDisabledAlgorithms messageDIGest.what false\n+ * @run main\/othervm TestDisabledAlgorithms meSSagedIgest.sHA-512\/224 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.MessageDigest;\n+import java.security.Provider;\n+import java.security.Security;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> MessageDigest.getInstance(a),\n+                            NoSuchAlgorithmException.class);\n+                } else {\n+                    Utils.runAndCheckException(() -> MessageDigest.getInstance(a, p),\n+                            NoSuchAlgorithmException.class);\n+                    Utils.runAndCheckException(() -> MessageDigest.getInstance(a,\n+                            p.getName()), NoSuchAlgorithmException.class);\n+                }\n+            } else {\n+                MessageDigest m;\n+                if (p == null) {\n+                    m = MessageDigest.getInstance(a);\n+                } else {\n+                    m = MessageDigest.getInstance(a, p);\n+                    m = MessageDigest.getInstance(a, p.getName());\n+                }\n+                System.out.println(\"Got MessageDigest w\/ algo \" +\n+                        m.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"sHA-512\", \"shA-512\",\n+                \"2.16.840.1.101.3.4.2.3\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"MessageDigest.SHA-512\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/MessageDigest\/TestDisabledAlgorithms.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms SIGNATURe.sha512withRSA true\n+ * @run main\/othervm TestDisabledAlgorithms signaturE.what false\n+ * @run main\/othervm TestDisabledAlgorithms SiGnAtUrE.SHa512\/224withRSA false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Signature;\n+import java.security.Provider;\n+import java.security.Security;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> Signature.getInstance(a),\n+                            NoSuchAlgorithmException.class);\n+                } else {\n+                    Utils.runAndCheckException(() -> Signature.getInstance(a, p),\n+                            NoSuchAlgorithmException.class);\n+                    Utils.runAndCheckException(() -> Signature.getInstance(a,\n+                            p.getName()), NoSuchAlgorithmException.class);\n+                }\n+            } else {\n+                Signature s;\n+                if (p == null) {\n+                    s = Signature.getInstance(a);\n+                } else {\n+                    s = Signature.getInstance(a, p);\n+                    s = Signature.getInstance(a, p.getName());\n+                }\n+                System.out.println(\"Got Signature w\/ algo \" + s.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"sha512withRsa\", \"1.2.840.113549.1.1.13\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"Signature.SHA512withRSA\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Signature\/TestDisabledAlgorithms.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms CIPHEr.Rsa\/ECB\/PKCS1Padding true\n+ * @run main\/othervm TestDisabledAlgorithms cipheR.rsA true\n+ * @run main\/othervm TestDisabledAlgorithms CIPher.what false\n+ * @run main\/othervm TestDisabledAlgorithms cipHER.RSA\/ECB\/PKCS1Padding2 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.Signature;\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static final String TARGET = \"Cipher.RSA\/ECB\/PKCS1Padding\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> Cipher.getInstance(a),\n+                            NoSuchAlgorithmException.class);\n+                } else {\n+                    Utils.runAndCheckException(() -> Cipher.getInstance(a, p),\n+                            NoSuchAlgorithmException.class);\n+                    Utils.runAndCheckException(() -> Cipher.getInstance(a,\n+                            p.getName()), NoSuchAlgorithmException.class);\n+\n+                }\n+            } else {\n+                Cipher c;\n+                if (p == null) {\n+                    c = Cipher.getInstance(a);\n+                } else {\n+                    c = Cipher.getInstance(a, p);\n+                    c = Cipher.getInstance(a, p.getName());\n+                }\n+                System.out.println(\"Got cipher w\/ algo \" + c.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"Rsa\/ECB\/PKCS1Padding\", \"rSA\");\n+\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders();\n+        for (Provider p : providers) {\n+            if (p.getService(\"Cipher\", \"RSA\/ECB\/PKCS1Padding\") != null) {\n+                test(algos, p, shouldThrow);\n+            }\n+        }\n+\n+        \/\/ make sure NONEwithRSA signature is still available from SunJCE and\n+        \/\/ SunMSCAPI (windows)\n+        if (shouldThrow) {\n+            System.out.println(\"Testing NONEwithRSA signature support\");\n+            for (String pn : List.of(\"SunJCE\", \"SunMSCAPI\")) {\n+                Provider p = Security.getProvider(pn);\n+                if (p != null) {\n+                    Signature s = Signature.getInstance(\"NONEwithRSA\", p);\n+                    System.out.println(pn + \"=> yes\");\n+                } else {\n+                    System.out.println(pn + \"=> skip; not found\");\n+                }\n+            }\n+        }\n+        System.out.println(\"Done\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestDisabledAlgorithms.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-    private static final int SOCKET_TIMEOUT = 10 * 1000; \/\/ in millis\n@@ -81,0 +80,1 @@\n+    private int socketTimeout = 10 * 1000; \/\/ in millis\n@@ -479,0 +479,4 @@\n+    public void setSocketTimeout(int socketTimeout) {\n+        this.socketTimeout = socketTimeout;\n+    }\n+\n@@ -532,2 +536,2 @@\n-            serverSocket.setSoTimeout(SOCKET_TIMEOUT);\n-            clientSocket.setSoTimeout(SOCKET_TIMEOUT);\n+            serverSocket.setSoTimeout(socketTimeout);\n+            clientSocket.setSoTimeout(socketTimeout);\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSOverDatagram.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @run main\/othervm PacketLossRetransmission client 0 hello_request\n@@ -37,8 +36,0 @@\n- * @run main\/othervm PacketLossRetransmission client 2 server_hello\n- * @run main\/othervm PacketLossRetransmission client 3 hello_verify_request\n- * @run main\/othervm -Djdk.tls.client.enableSessionTicketExtension=false PacketLossRetransmission client 4 new_session_ticket\n- * @run main\/othervm PacketLossRetransmission client 11 certificate\n- * @run main\/othervm PacketLossRetransmission client 12 server_key_exchange\n- * @run main\/othervm PacketLossRetransmission client 13 certificate_request\n- * @run main\/othervm PacketLossRetransmission client 14 server_hello_done\n- * @run main\/othervm PacketLossRetransmission client 15 certificate_verify\n@@ -47,3 +38,0 @@\n- * @run main\/othervm PacketLossRetransmission client 21 certificate_url\n- * @run main\/othervm PacketLossRetransmission client 22 certificate_status\n- * @run main\/othervm PacketLossRetransmission client 23 supplemental_data\n@@ -51,2 +39,0 @@\n- * @run main\/othervm PacketLossRetransmission server 0 hello_request\n- * @run main\/othervm PacketLossRetransmission server 1 client_hello\n@@ -55,1 +41,0 @@\n- * @run main\/othervm -Djdk.tls.client.enableSessionTicketExtension=false PacketLossRetransmission server 4 new_session_ticket\n@@ -58,1 +43,0 @@\n- * @run main\/othervm PacketLossRetransmission server 13 certificate_request\n@@ -60,2 +44,0 @@\n- * @run main\/othervm PacketLossRetransmission server 15 certificate_verify\n- * @run main\/othervm PacketLossRetransmission server 16 client_key_exchange\n@@ -63,3 +45,0 @@\n- * @run main\/othervm PacketLossRetransmission server 21 certificate_url\n- * @run main\/othervm PacketLossRetransmission server 22 certificate_status\n- * @run main\/othervm PacketLossRetransmission server 23 supplemental_data\n@@ -82,0 +61,1 @@\n+    private static final int TIMEOUT = 500;\n@@ -90,0 +70,1 @@\n+        testCase.setSocketTimeout(TIMEOUT);\n@@ -105,1 +86,1 @@\n-                System.out.println(\"Loss a packet of handshake messahe\");\n+                System.out.println(\"Loss a packet of handshake message\");\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/PacketLossRetransmission.java","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8314731\n+ * @key headful\n+ * @summary FormView doesn't support the alt attribute\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+\n+import javax.swing.JButton;\n+import javax.swing.JEditorPane;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollPane;\n+import javax.swing.SwingUtilities;\n+import javax.swing.text.Document;\n+import javax.swing.text.html.HTMLEditorKit;\n+import javax.swing.text.html.StyleSheet;\n+\n+public class bug8314731 {\n+\n+    private static JFrame frame;\n+    private static JEditorPane editorPane;\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            SwingUtilities.invokeAndWait(bug8314731::createAndSetVisibleUI);\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (!containsAlt(editorPane)) {\n+                    throw new RuntimeException(\"FormView doesn't support the alt attribute, see JDK-8314731.\");\n+                }\n+            });\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void createAndSetVisibleUI() {\n+        editorPane = new JEditorPane();\n+        editorPane.setEditable(false);\n+        frame = new JFrame(\"alt attribute test in HTML image type input\");\n+\n+        JScrollPane scrollPane = new JScrollPane(editorPane);\n+        HTMLEditorKit kit = new HTMLEditorKit();\n+        editorPane.setEditorKit(kit);\n+        StyleSheet styleSheet = kit.getStyleSheet();\n+        styleSheet.addRule(\"\"\"\n+                body {\n+                    color: #000;\n+                    font-family: times;\n+                    margin: 4px;\n+                }\n+                \"\"\");\n+        String htmlString = \"\"\"\n+                <html>\n+                    <body>\n+                        <input type=image\n+                               name=point\n+                               alt=\"Logo\">\n+                    <\/body>\n+                <\/html>\n+                \"\"\";\n+        Document doc = kit.createDefaultDocument();\n+        editorPane.setDocument(doc);\n+        editorPane.setText(htmlString);\n+\n+        frame.add(scrollPane, BorderLayout.CENTER);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setSize(new Dimension(400, 200));\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    private static boolean containsAlt(Container container) {\n+        for (Component c : container.getComponents()) {\n+            if (c instanceof JButton button) {\n+                return \"Logo\".equals(button.getText());\n+            } else if (c instanceof Container cont) {\n+                return containsAlt(cont);\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/html\/bug8314731.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestDisabledAlgorithms CiPhEr.RSA\/ECB\/PKCS1Padding true\n+ * @run main\/othervm TestDisabledAlgorithms cIpHeR.rsA true\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.what false\n+ * @run main\/othervm TestDisabledAlgorithms CiPhER.RSA\/ECB\/PKCS1Padding2 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms extends PKCS11Test {\n+\n+    boolean shouldThrow;\n+\n+    TestDisabledAlgorithms(boolean shouldThrow) {\n+        this.shouldThrow = shouldThrow;\n+    }\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(String alg, Provider p, boolean shouldThrow)\n+            throws Exception {\n+        System.out.println(\"Testing \" + p.getName() + \": \" + alg +\n+                \", shouldThrow=\" + shouldThrow);\n+        if (shouldThrow) {\n+            Utils.runAndCheckException(() -> Cipher.getInstance(alg, p),\n+                    NoSuchAlgorithmException.class);\n+        } else {\n+            Cipher c = Cipher.getInstance(alg, p);\n+            System.out.println(\"Got cipher w\/ algo \" + c.getAlgorithm());\n+        }\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        for (String a : List.of(\"RSA\/ECB\/PKCS1Padding\", \"RSA\")) {\n+            test(a, p, shouldThrow);\n+        }\n+        System.out.println(\"Done\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+        main(new TestDisabledAlgorithms(shouldThrow), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestDisabledAlgorithms.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-    static String nss_library = \"softokn3\";\n+    static String nss_library = System.getProperty(\"CUSTOM_P11_LIBRARY_NAME\", \"softokn3\");\n@@ -202,0 +202,11 @@\n+        String customBaseDir = System.getProperty(\"CUSTOM_P11_CONFIG_BASE_DIR\");\n+        if (customBaseDir != null) {\n+            File base = new File(customBaseDir);\n+            if (!base.exists()) {\n+                throw new RuntimeException(\n+                        \"Directory specified by CUSTOM_P11_CONFIG_BASE_DIR does not exist: \"\n+                                + base.getAbsolutePath());\n+            }\n+            PKCS11_BASE = base.getAbsolutePath();\n+            return PKCS11_BASE;\n+        }\n@@ -457,0 +468,34 @@\n+    \/**\n+     * Prepares the NSS configuration file hierarchy, then returns the\n+     * path of the configuration file that should be used to configure\n+     * the PKCS11 provider.\n+     *\n+     * By default, the contents of the directory\n+     * \"test\/jdk\/sun\/security\/pkcs11\/nss\" are copied to the jtreg\n+     * scratch directory (\".\"), and \".\/nss\/p11-nss.txt\" is returned.\n+     *\n+     * The following system properties modify the default behavior:\n+     *\n+     * CUSTOM_P11_CONFIG_BASE_DIR: The path of a custom configuration\n+     * file hierarchy; overrides the default,\n+     * \"test\/jdk\/sun\/security\/pkcs11\".\n+     *\n+     * CUSTOM_P11_CONFIG_NAME: The name of a custom configuration\n+     * file; overrides the default, \"p11-nss.txt\".  Note that some\n+     * test cases set CUSTOM_P11_CONFIG_NAME using -D in jtreg @run\n+     * tags; for those test cases, setting this property on the\n+     * top-level jtreg command line has no effect.\n+     *\n+     * CUSTOM_P11_CONFIG: The path of a custom configuration file;\n+     * overrides the default \".\/nss\/p11-nss.txt\".  This takes\n+     * precedence over CUSTOM_P11_CONFIG_NAME.  Tests that hard-code\n+     * CUSTOM_P11_CONFIG_NAME in jtreg @run tags may not work\n+     * correctly when CUSTOM_P11_CONFIG is set on the top-level jtreg\n+     * command line.\n+     *\n+     * CUSTOM_DB_DIR: The path of a custom database directory;\n+     * overrides the default, \".\/nss\/db\".\n+     *\n+     * CUSTOM_P11_LIBRARY_NAME: The name of a custom provider library\n+     * to load; overrides the default, \"softokn3\".\n+     *\/\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.*;\n+import java.util.stream.IntStream;\n+import jtreg.SkippedException;\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test the NONEwithRSA signature refactoring for JCE layer\n+ *     algorithm restriction\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ *\/\n+public class TestNONEwithRSA extends PKCS11Test {\n+\n+    private static final String SIGALG = \"NONEwithRSA\";\n+\n+    private static final int[] KEYSIZES = { 2048, 3072 };\n+    private static final byte[] DATA = generateData(100);\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestNONEwithRSA(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        try {\n+            Signature.getInstance(SIGALG, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new SkippedException(\"Skip due to no support for \" + SIGALG);\n+        }\n+\n+        for (int kSize : KEYSIZES) {\n+            System.out.println(\"[KEYSIZE = \" + kSize + \"]\");\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", p);\n+            kpg.initialize(kSize);\n+            KeyPair kp = kpg.generateKeyPair();\n+            PrivateKey privKey = kp.getPrivate();\n+            PublicKey pubKey = kp.getPublic();\n+            checkSignature(p, DATA, pubKey, privKey);\n+        }\n+    }\n+\n+    private static void checkSignature(Provider p, byte[] data, PublicKey pub,\n+            PrivateKey priv)\n+            throws NoSuchAlgorithmException, InvalidKeyException,\n+            SignatureException, NoSuchProviderException,\n+            InvalidAlgorithmParameterException {\n+\n+        Signature sig = Signature.getInstance(SIGALG, p);\n+        sig.initSign(priv);\n+\n+        sig.update(data);\n+        byte[] signedData = sig.sign();\n+\n+        \/\/ Make sure signature verifies with original data\n+        sig.initVerify(pub);\n+        sig.update(data);\n+        if (!sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to verify signature\");\n+        }\n+\n+        \/\/ Make sure signature does NOT verify when the original data\n+        \/\/ has changed\n+        sig.initVerify(pub);\n+        sig.update(data);\n+        sig.update(data);\n+        if (sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to detect bad signature\");\n+        }\n+        System.out.println(\"    => Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/TestNONEwithRSA.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -60,4 +60,4 @@\n- * @run main\/othervm AlgorithmConstraintsCheck false SunX509 SHA256withRSA\n- * @run main\/othervm AlgorithmConstraintsCheck true SunX509 SHA256withRSA\n- * @run main\/othervm AlgorithmConstraintsCheck false PKIX SHA256withRSA\n- * @run main\/othervm AlgorithmConstraintsCheck true PKIX SHA256withRSA\n+ * @run main\/othervm AlgorithmConstraintsCheck false SunX509\n+ * @run main\/othervm AlgorithmConstraintsCheck true SunX509\n+ * @run main\/othervm AlgorithmConstraintsCheck false PKIX\n+ * @run main\/othervm AlgorithmConstraintsCheck true PKIX\n@@ -68,2 +68,3 @@\n-    private static final String CERT_ALIAS = \"testalias\";\n-    private static final String KEY_TYPE = \"RSA\";\n+    protected static final String CERT_ALIAS = \"testalias\";\n+    protected static final String KEY_TYPE = \"EC\";\n+    protected static final String CERT_SIG_ALG = \"SHA256withECDSA\";\n@@ -72,1 +73,1 @@\n-        if (args.length != 3) {\n+        if (args.length != 2) {\n@@ -78,1 +79,0 @@\n-        String certSignatureAlg = args[2];\n@@ -81,1 +81,1 @@\n-        SecurityUtils.addToDisabledTlsAlgs(certSignatureAlg);\n+        SecurityUtils.addToDisabledTlsAlgs(CERT_SIG_ALG);\n@@ -84,1 +84,1 @@\n-                kmAlg, certSignatureAlg);\n+                kmAlg, KEY_TYPE, CERT_SIG_ALG);\n@@ -111,1 +111,1 @@\n-    private static String normalizeAlias(String alias) {\n+    protected static String normalizeAlias(String alias) {\n@@ -115,3 +115,3 @@\n-    private static X509KeyManager getKeyManager(String kmAlg,\n-            String certSignatureAlg) throws Exception {\n-        KeyPairGenerator kpg = KeyPairGenerator.getInstance(KEY_TYPE);\n+    protected static X509KeyManager getKeyManager(String kmAlg,\n+            String keyAlg, String certSignatureAlg) throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(keyAlg);\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/AlgorithmConstraintsCheck.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,405 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365953\n+ * @summary Key manager returns no certificates when handshakeSession is not\n+ *          an ExtendedSSLSession\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @run main\/othervm NonExtendedSSLSessionAlgorithmConstraints\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.Principal;\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSessionContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+\/*\n+ * Make sure Key Managers return the certificates when SSLSocket or SSLEngine\n+ * use an SSLSession which is not extending ExtendedSSLSession.\n+ *\/\n+public class NonExtendedSSLSessionAlgorithmConstraints extends\n+        AlgorithmConstraintsCheck {\n+\n+    public static void main(String[] args) throws Exception {\n+        new NonExtendedSSLSessionAlgorithmConstraints().runTest();\n+    }\n+\n+    private void runTest() throws Exception {\n+        for (String kmAlg : new String[]{\"SunX509\", \"PKIX\"}) {\n+\n+            X509ExtendedKeyManager km =\n+                    (X509ExtendedKeyManager) getKeyManager(\n+                            kmAlg, KEY_TYPE, CERT_SIG_ALG);\n+            var testSocket = new TestHandshakeSessionSSLSocket();\n+            var testEngine = new TestHandshakeSessionSSLEngine();\n+\n+            \/\/ Test SSLSocket\n+            assertEquals(CERT_ALIAS, normalizeAlias(km.chooseServerAlias(\n+                    KEY_TYPE, null, testSocket)));\n+            assertEquals(CERT_ALIAS, normalizeAlias(km.chooseClientAlias(\n+                    new String[]{KEY_TYPE}, null, testSocket)));\n+\n+            \/\/ Test SSLEngine\n+            assertEquals(CERT_ALIAS, normalizeAlias(km.chooseEngineServerAlias(\n+                    KEY_TYPE, null, testEngine)));\n+            assertEquals(CERT_ALIAS, normalizeAlias(km.chooseEngineClientAlias(\n+                    new String[]{KEY_TYPE}, null, testEngine)));\n+        }\n+    }\n+\n+    private static class TestHandshakeSessionSSLSocket extends SSLSocket {\n+\n+        TestHandshakeSessionSSLSocket() {\n+        }\n+\n+        @Override\n+        public SSLSession getHandshakeSession() {\n+            return new TestSSLSession();\n+        }\n+\n+        @Override\n+        public boolean isConnected() {\n+            return true;\n+        }\n+\n+        @Override\n+        public SSLSession getSession() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String[] getSupportedProtocols() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String[] getEnabledCipherSuites() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void setEnabledCipherSuites(String[] suites) {\n+        }\n+\n+        @Override\n+        public String[] getEnabledProtocols() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void setEnabledProtocols(String[] protocols) {\n+        }\n+\n+        @Override\n+        public void addHandshakeCompletedListener\n+                (HandshakeCompletedListener listener) {\n+        }\n+\n+        @Override\n+        public void removeHandshakeCompletedListener\n+                (HandshakeCompletedListener listener) {\n+        }\n+\n+        @Override\n+        public void startHandshake() throws IOException {\n+        }\n+\n+        @Override\n+        public void setUseClientMode(boolean mode) {\n+        }\n+\n+        @Override\n+        public boolean getUseClientMode() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setNeedClientAuth(boolean need) {\n+        }\n+\n+        @Override\n+        public boolean getNeedClientAuth() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setWantClientAuth(boolean want) {\n+        }\n+\n+        @Override\n+        public boolean getWantClientAuth() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setEnableSessionCreation(boolean flag) {\n+        }\n+\n+        @Override\n+        public boolean getEnableSessionCreation() {\n+            return true;\n+        }\n+    }\n+\n+    private static class TestHandshakeSessionSSLEngine extends SSLEngine {\n+\n+        @Override\n+        public SSLSession getHandshakeSession() {\n+            return new TestSSLSession();\n+        }\n+\n+        @Override\n+        public String[] getEnabledProtocols() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SSLEngineResult wrap(ByteBuffer[] src, int off, int len,\n+                ByteBuffer dst) throws SSLException {\n+            return null;\n+        }\n+\n+        @Override\n+        public SSLEngineResult unwrap(ByteBuffer src,\n+                ByteBuffer[] dst, int off, int len)\n+                throws SSLException {\n+            return null;\n+        }\n+\n+        @Override\n+        public Runnable getDelegatedTask() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void closeInbound() {\n+        }\n+\n+        @Override\n+        public boolean isInboundDone() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void closeOutbound() {\n+        }\n+\n+        @Override\n+        public boolean isOutboundDone() {\n+            return false;\n+        }\n+\n+        @Override\n+        public String[] getEnabledCipherSuites() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void setEnabledCipherSuites(String[] suites) {\n+        }\n+\n+        @Override\n+        public String[] getSupportedProtocols() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void setEnabledProtocols(String[] protocols) {\n+        }\n+\n+        @Override\n+        public SSLSession getSession() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void beginHandshake() {\n+        }\n+\n+        @Override\n+        public SSLEngineResult.HandshakeStatus getHandshakeStatus() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void setUseClientMode(boolean mode) {\n+        }\n+\n+        @Override\n+        public boolean getUseClientMode() {\n+            return false;\n+        }\n+\n+        public void setNeedClientAuth(boolean need) {\n+        }\n+\n+        @Override\n+        public boolean getNeedClientAuth() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setWantClientAuth(boolean need) {\n+        }\n+\n+        @Override\n+        public boolean getWantClientAuth() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void setEnableSessionCreation(boolean flag) {\n+        }\n+\n+        @Override\n+        public boolean getEnableSessionCreation() {\n+            return false;\n+        }\n+    }\n+\n+    public static class TestSSLSession implements SSLSession {\n+\n+        TestSSLSession() {\n+        }\n+\n+        @Override\n+        public String getProtocol() {\n+            return \"TLSv1.3\";\n+        }\n+\n+        @Override\n+        public byte[] getId() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SSLSessionContext getSessionContext() {\n+            return null;\n+        }\n+\n+        @Override\n+        public long getCreationTime() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public long getLastAccessedTime() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public void invalidate() {\n+        }\n+\n+        @Override\n+        public boolean isValid() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void putValue(String name, Object value) {\n+        }\n+\n+        @Override\n+        public Object getValue(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public void removeValue(String name) {\n+        }\n+\n+        @Override\n+        public String[] getValueNames() {\n+            return null;\n+        }\n+\n+        @Override\n+        public java.security.cert.Certificate[] getPeerCertificates() {\n+            return new java.security.cert.Certificate[0];\n+        }\n+\n+        @Override\n+        public java.security.cert.Certificate[] getLocalCertificates() {\n+            return new java.security.cert.Certificate[0];\n+        }\n+\n+        @Override\n+        public Principal getPeerPrincipal() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Principal getLocalPrincipal() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String getCipherSuite() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String getPeerHost() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int getPeerPort() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int getPacketBufferSize() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int getApplicationBufferSize() {\n+            return 0;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/NonExtendedSSLSessionAlgorithmConstraints.java","additions":405,"deletions":0,"binary":false,"changes":405,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8244336\n+ * @modules java.base\/sun.security.util\n+ * @summary Check that invalid property values for\n+ *         \"jdk.crypto.disabledAlgorithms\" are rejected\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"*\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \".\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \".AES\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"Cipher.\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"A.B\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,.\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,.AES\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,Cipher.\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,A.B\"\n+ *\/\n+import java.security.Security;\n+import sun.security.util.CryptoAlgorithmConstraints;\n+\n+public class InvalidCryptoDisabledAlgos {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Invalid Property Value = \" + args[0]);\n+        Security.setProperty(\"jdk.crypto.disabledAlgorithms\", args[0]);\n+        try {\n+            \/\/ Trigger the check to parse and validate property value\n+            CryptoAlgorithmConstraints.permits(\"x\", \"y\");\n+            throw new AssertionError(\n+                    \"CryptoAlgorithmConstraints.permits() did not generate expected exception\");\n+        } catch (Throwable t) {\n+            if (!(t instanceof ExceptionInInitializerError)\n+                    || !(t.getCause() instanceof IllegalArgumentException)) {\n+                \/\/ unexpected exception, propagate it\n+                throw t;\n+            }\n+            \/\/ got expected\n+            System.out.println(\"Received expected exception: \" + t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/util\/AlgorithmConstraints\/InvalidCryptoDisabledAlgos.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.List;\n+\n+public class UseShutdownHook {\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        trace(\"Started\");\n+\n+        var outputFile = Path.of(args[0]);\n+        trace(String.format(\"Write output in [%s] file\", outputFile));\n+\n+        var shutdownTimeoutSeconds = Integer.parseInt(args[1]);\n+        trace(String.format(\"Automatically shutdown the app in %ss\", shutdownTimeoutSeconds));\n+\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                output(outputFile, \"shutdown hook executed\");\n+            }\n+        });\n+\n+        var startTime = System.currentTimeMillis();\n+        var lock = new Object();\n+        do {\n+            synchronized (lock) {\n+                lock.wait(shutdownTimeoutSeconds * 1000);\n+            }\n+        } while ((System.currentTimeMillis() - startTime) < (shutdownTimeoutSeconds * 1000));\n+\n+        output(outputFile, \"exit\");\n+    }\n+\n+    private static void output(Path outputFilePath, String msg) {\n+\n+        trace(String.format(\"Writing [%s] into [%s]\", msg, outputFilePath));\n+\n+        try {\n+            Files.createDirectories(outputFilePath.getParent());\n+            Files.writeString(outputFilePath, msg, StandardOpenOption.APPEND, StandardOpenOption.CREATE);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static void trace(String msg) {\n+        Date time = new Date(System.currentTimeMillis());\n+        msg = String.format(\"UseShutdownHook [%s]: %s\", SDF.format(time), msg);\n+        System.out.println(msg);\n+        try {\n+            Files.write(traceFile, List.of(msg), StandardOpenOption.APPEND, StandardOpenOption.CREATE);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static final SimpleDateFormat SDF = new SimpleDateFormat(\"HH:mm:ss.SSS\");\n+\n+    private static final Path traceFile = Path.of(System.getProperty(\"jpackage.test.trace-file\"));\n+}\n","filename":"test\/jdk\/tools\/jpackage\/apps\/UseShutdownHook.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-    public void addValue(String sectionName, String key, String value) {\n+    public CfgFile addValue(String sectionName, String key, String value) {\n@@ -69,0 +69,5 @@\n+        return this;\n+    }\n+\n+    public CfgFile add(CfgFile other) {\n+        return combine(this, other);\n@@ -92,1 +97,1 @@\n-    public void save(Path path) {\n+    public CfgFile save(Path path) {\n@@ -101,0 +106,1 @@\n+        return this;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CfgFile.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import java.nio.file.WatchService;\n@@ -614,20 +613,22 @@\n-        WatchService ws = FileSystems.getDefault().newWatchService();\n-\n-        Path watchDirectory = fileToWaitFor.toAbsolutePath().getParent();\n-        watchDirectory.register(ws, ENTRY_CREATE, ENTRY_MODIFY);\n-\n-        var waitUntil = Instant.now().plus(timeout);\n-        for (;;) {\n-            var remainderTimeout = Instant.now().until(waitUntil);\n-            assertTrue(remainderTimeout.isPositive(), String.format(\n-                    \"Check timeout value %dms is positive\", remainderTimeout.toMillis()));\n-\n-            WatchKey key = ThrowingSupplier.toSupplier(() -> {\n-                return ws.poll(remainderTimeout.toMillis(), TimeUnit.MILLISECONDS);\n-            }).get();\n-            if (key == null) {\n-                if (Files.exists(fileToWaitFor)) {\n-                    trace(String.format(\n-                            \"File [%s] is available after poll timeout expired\",\n-                            fileToWaitFor));\n-                    return;\n+        try (var ws = FileSystems.getDefault().newWatchService()) {\n+\n+            Path watchDirectory = fileToWaitFor.toAbsolutePath().getParent();\n+            watchDirectory.register(ws, ENTRY_CREATE, ENTRY_MODIFY);\n+\n+            var waitUntil = Instant.now().plus(timeout);\n+            for (;;) {\n+                var remainderTimeout = Instant.now().until(waitUntil);\n+                assertTrue(remainderTimeout.isPositive(), String.format(\n+                        \"Check timeout value %dms is positive\", remainderTimeout.toMillis()));\n+\n+                WatchKey key = ThrowingSupplier.toSupplier(() -> {\n+                    return ws.poll(remainderTimeout.toMillis(), TimeUnit.MILLISECONDS);\n+                }).get();\n+                if (key == null) {\n+                    if (Files.exists(fileToWaitFor)) {\n+                        trace(String.format(\n+                                \"File [%s] is available after poll timeout expired\",\n+                                fileToWaitFor));\n+                        return;\n+                    }\n+                    assertUnexpected(String.format(\"Timeout %dms expired\", remainderTimeout.toMillis()));\n@@ -635,2 +636,0 @@\n-                assertUnexpected(String.format(\"Timeout %dms expired\", remainderTimeout.toMillis()));\n-            }\n@@ -638,9 +637,9 @@\n-            for (WatchEvent<?> event : key.pollEvents()) {\n-                if (event.kind() == StandardWatchEventKinds.OVERFLOW) {\n-                    continue;\n-                }\n-                Path contextPath = (Path) event.context();\n-                if (Files.isSameFile(watchDirectory.resolve(contextPath),\n-                        fileToWaitFor)) {\n-                    trace(String.format(\"File [%s] is available\", fileToWaitFor));\n-                    return;\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    if (event.kind() == StandardWatchEventKinds.OVERFLOW) {\n+                        continue;\n+                    }\n+                    Path contextPath = (Path) event.context();\n+                    if (Files.exists(fileToWaitFor) && Files.isSameFile(watchDirectory.resolve(contextPath), fileToWaitFor)) {\n+                        trace(String.format(\"File [%s] is available\", fileToWaitFor));\n+                        return;\n+                    }\n@@ -648,1 +647,0 @@\n-            }\n@@ -650,2 +648,3 @@\n-            if (!key.reset()) {\n-                assertUnexpected(\"Watch key invalidated\");\n+                if (!key.reset()) {\n+                    assertUnexpected(\"Watch key invalidated\");\n+                }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+#\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+param (\n+  # Path to executable to start.\n+  [Parameter(Mandatory=$true)]\n+  [string]$Executable,\n+\n+  # Timeout to wait after the executable has been started.\n+  [Parameter(Mandatory=$true)]\n+  [double]$TimeoutSeconds\n+)\n+\n+$type = @{\n+  TypeDefinition = @'\n+using System;\n+using System.Runtime.InteropServices;\n+\n+namespace Stuff {\n+\n+  internal struct Details {\n+    [DllImport(\"kernel32.dll\", SetLastError = true)]\n+    [return: MarshalAs(UnmanagedType.Bool)]\n+    internal static extern bool GenerateConsoleCtrlEvent(uint dwCtrlEvent, uint dwProcessGroupId);\n+  }\n+\n+  public struct Facade {\n+    public static void GenerateConsoleCtrlEvent() {\n+      if (!Details.GenerateConsoleCtrlEvent(0, 0)) {\n+        reportLastErrorAndExit(\"GenerateConsoleCtrlEvent\");\n+      }\n+    }\n+\n+    internal static void reportLastErrorAndExit(String func) {\n+      int errorCode = Marshal.GetLastWin32Error();\n+      Console.Error.WriteLine(func + \" function failed with error code: \" + errorCode);\n+      Environment.Exit(100);\n+    }\n+  }\n+}\n+'@\n+}\n+Add-Type @type\n+\n+Set-PSDebug -Trace 2\n+\n+# Launch the target executable.\n+# `-NoNewWindow` parameter will attach the started process to the existing console.\n+$childProc = Start-Process -PassThru -NoNewWindow $Executable\n+\n+# Wait a bit to let the started process complete initialization.\n+Start-Sleep -Seconds $TimeoutSeconds\n+\n+# Call GenerateConsoleCtrlEvent to send a CTRL+C event to the launched executable.\n+# CTRL+C event will be sent to all processes attached to the console of the current process,\n+# i.e., it will be sent to this PowerShell process and to the started $Executable process because\n+# it was configured to attach to the existing console (the console of this PowerShell process).\n+[Stuff.Facade]::GenerateConsoleCtrlEvent()\n+\n+# Wait for child process termination\n+Wait-Process -InputObject $childProc\n+\n+Exit 0\n","filename":"test\/jdk\/tools\/jpackage\/resources\/Win8365790Test.ps1","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.jpackage.test.HelloApp.configureAndExecute;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.CfgFile;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.LauncherVerifier;\n+import jdk.jpackage.test.TKit;\n+\n+\/**\n+ * Test the child process has a chance to handle Ctrl+C signal.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test case for JDK-8365790\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @build Win8365790Test\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm\/timeout=100 -Xmx512m  jdk.jpackage.test.Main\n+ *  --jpt-run=Win8365790Test\n+ *\/\n+public class Win8365790Test {\n+\n+    @Test\n+    public void test() throws InterruptedException, IOException {\n+\n+        var outputDir = TKit.createTempDirectory(\"response-dir\");\n+\n+        var mainOutputFile = outputDir.resolve(\"output.txt\");\n+        var mainTraceFile = outputDir.resolve(\"trace.txt\");\n+\n+        var probeOutputFile = outputDir.resolve(\"probe-output.txt\");\n+        var probeTraceFile = outputDir.resolve(\"probe-trace.txt\");\n+\n+        var cmd = JPackageCommand\n+                .helloAppImage(TEST_APP_JAVA + \"*UseShutdownHook\")\n+                .ignoreFakeRuntime()\n+                .addArguments(\"--java-options\", \"-Djpackage.test.trace-file=\" + mainTraceFile.toString())\n+                .addArguments(\"--arguments\", mainOutputFile.toString())\n+                .addArguments(\"--arguments\", Long.toString(Duration.ofSeconds(TETS_APP_AUTOCLOSE_TIMEOUT_SECONDS).getSeconds()));\n+\n+        new AdditionalLauncher(\"probe\")\n+                .withoutVerifyActions(LauncherVerifier.Action.values())\n+                .addJavaOptions(\"-Djpackage.test.trace-file=\" + probeTraceFile.toString())\n+                .addDefaultArguments(probeOutputFile.toString(), Long.toString(Duration.ofSeconds(TETS_APP_AUTOCLOSE_TIMEOUT_SECONDS).getSeconds()))\n+                .applyTo(cmd);\n+\n+        cmd.executeAndAssertImageCreated();\n+\n+        cmd.readLauncherCfgFile(\"probe\")\n+                .add(new CfgFile().addValue(\"Application\", \"win.norestart\", Boolean.TRUE.toString()))\n+                .save(cmd.appLauncherCfgPath(\"probe\"));\n+\n+        \/\/ Try Ctrl+C signal on a launcher with disabled restart functionality.\n+        \/\/ It will create a single launcher process instead of the parent and the child processes.\n+        \/\/ Ctrl+C always worked for launcher with disabled restart functionality.\n+        var probeOutput = runLauncher(cmd, \"probe\", probeTraceFile, probeOutputFile);\n+\n+        if (!probeOutput.equals(\"shutdown hook executed\")) {\n+            \/\/ Ctrl+C signal didn't make it. Test environment doesn't support Ctrl+C signal\n+            \/\/ delivery from the prowershell process to a child process, don't run the main\n+            \/\/ test.\n+            TKit.throwSkippedException(\n+                    \"The environment does NOT support Ctrl+C signal delivery from the prowershell process to a child process\");\n+        }\n+\n+        var mainOutput = runLauncher(cmd, null, mainTraceFile, mainOutputFile);\n+\n+        TKit.assertEquals(\"shutdown hook executed\", mainOutput, \"Check shutdown hook executed\");\n+    }\n+\n+    private static String runLauncher(JPackageCommand cmd, String launcherName, Path traceFile, Path outputFile) throws IOException {\n+        \/\/ Launch the specified launcher and send Ctrl+C signal to it.\n+        Thread.ofVirtual().start(() -> {\n+            configureAndExecute(0, Executor.of(\"powershell\", \"-NonInteractive\", \"-NoLogo\", \"-NoProfile\", \"-ExecutionPolicy\", \"Unrestricted\")\n+                    .addArgument(\"-File\").addArgument(TEST_PS1)\n+                    .addArguments(\"-TimeoutSeconds\", Long.toString(Duration.ofSeconds(5).getSeconds()))\n+                    .addArgument(\"-Executable\").addArgument(cmd.appLauncherPath(launcherName))\n+                    .dumpOutput());\n+        });\n+\n+        TKit.waitForFileCreated(traceFile, Duration.ofSeconds(20), Duration.ofSeconds(2));\n+\n+        try {\n+            TKit.waitForFileCreated(outputFile, Duration.ofSeconds(TETS_APP_AUTOCLOSE_TIMEOUT_SECONDS * 2), Duration.ofSeconds(2));\n+        } finally {\n+            TKit.traceFileContents(traceFile, \"Test app trace\");\n+        }\n+\n+        TKit.assertFileExists(outputFile);\n+        return Files.readString(outputFile);\n+    }\n+\n+    private static final long TETS_APP_AUTOCLOSE_TIMEOUT_SECONDS = 30;\n+\n+    private static final Path TEST_APP_JAVA = TKit.TEST_SRC_ROOT.resolve(\"apps\/UseShutdownHook.java\");\n+    private static final Path TEST_PS1 = TKit.TEST_SRC_ROOT.resolve(Path.of(\"resources\/Win8365790Test.ps1\")).normalize();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8365790Test.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -901,0 +901,43 @@\n+\n+    @Test\n+    public void testAnnotation() {\n+        assertCompletion(\"@Deprec|\", \"Deprecated\");\n+        assertCompletion(\"@Deprecated(|\", \"forRemoval = \", \"since = \");\n+        assertCompletion(\"@Deprecated(forRemoval = |\", true, \"false\", \"true\");\n+        assertCompletion(\"@Deprecated(forRemoval = true, |\", \"since = \");\n+        assertEval(\"import java.lang.constant.ConstantDescs;\");\n+        assertEval(\"import static java.lang.constant.ConstantDescs.*;\");\n+        assertEval(\"@interface Ann1 { public String test(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann1(test = |\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"CD_char\", \"byte\"));\n+        assertEval(\"@interface Ann2 { public String[] test(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann2(test = {|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"CD_char\", \"byte\"));\n+        assertCompletionIncludesExcludes(\"@Ann2(test = {|\", true, Set.of(\"INIT_NAME\"), Set.of(\"java.\", \"ConstantDescs\", \"CD_char\", \"byte\"));\n+        assertEval(\"@interface Ann3 { public String value(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann3(|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\", \"value = \"), Set.of(\"CD_char\", \"byte\"));\n+        assertCompletionIncludesExcludes(\"@Ann3(|\", true, Set.of(\"INIT_NAME\", \"value = \"), Set.of(\"java.\", \"ConstantDescs\", \"CD_char\", \"byte\"));\n+        assertSignature(\"@Deprecated(|\", \"boolean Deprecated.forRemoval()\", \"String Deprecated.since()\");\n+        assertEval(\"@interface Ann4 { public String[] value(); }\");\n+        assertCompletionIncludesExcludes(\"@Ann4({|\", Set.of(\"java.\", \"ConstantDescs\", \"INIT_NAME\"), Set.of(\"value = \"));\n+        assertEval(\"@interface Ann5 { public Ann4[] value(); }\");\n+        assertCompletion(\"@Ann5(|\", true, \"@Ann4(\", \"value = \");\n+        assertCompletion(\"@Ann5({|\", true, \"@Ann4(\");\n+        assertCompletion(\"@Ann5(|\", false);\n+        assertCompletion(\"@Ann5({|\", false);\n+        assertCompletion(\"@Ann5(@|\", true, \"@Ann4(\");\n+        assertCompletion(\"@Ann5(v|\", true, \"value = \");\n+        assertEval(\"@interface Ann6 { public java.lang.annotation.Retention[] value(); }\");\n+        assertCompletion(\"@Ann6(|\", true, \"@java.lang.annotation.Retention(\", \"value = \");\n+        assertEval(\"@interface Ann7 { }\"); \/\/no attributes\n+        assertEval(\"@interface Ann8 { public Ann7[] value(); }\");\n+        assertCompletion(\"@Ann8(|\", true, \"@Ann7\", \"value = \");\n+        assertEval(\"enum En { AA, BB, EE; }\");\n+        assertEval(\"@interface Ann9 { public En[] value(); }\");\n+        assertCompletion(\"@Ann9(|\", true, \"En\", \"En.AA\", \"En.BB\", \"En.EE\", \"value = \");\n+        assertCompletion(\"@Ann9(A|\", true, \"En.AA\");\n+        assertCompletion(\"@Ann9(E|\", true, \"En\", \"En.EE\");\n+        assertCompletionIncludesExcludes(\"@Ann9(En.|\", Set.of(\"AA\", \"BB\", \"EE\"), Set.of());\n+        assertEval(\"@interface AnnA { public java.lang.annotation.RetentionPolicy[] value(); }\");\n+        assertCompletion(\"@AnnA(C|\", true, \"java.lang.annotation.RetentionPolicy.CLASS\");\n+        assertEval(\"import static java.lang.annotation.RetentionPolicy.*;\");\n+        assertCompletion(\"@AnnA(C|\", true, \"CLASS\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -347,0 +347,20 @@\n+\n+    @Test\n+    public void testAnnotation() throws Exception {\n+        doRunTest((inputSink, out) -> {\n+            inputSink.write(\"@interface Ann1 { public java.lang.annotation.Retention[] value(); }\\n\");\n+            waitOutput(out, \"\\n\\\\u001B\\\\[\\\\?2004h\" + PROMPT);\n+\n+            \/\/-> <tab>\n+            inputSink.write(\"@Ann1(\" + TAB);\n+            waitOutput(out, \".*@java.lang.annotation.Retention\\\\(.*value =.*\" +\n+                            REDRAW_PROMPT + \"@Ann1\\\\(\");\n+            inputSink.write(\"@\" + TAB);\n+            waitOutput(out, \"^@java.lang.annotation.Retention\\\\(\");\n+            inputSink.write(TAB);\n+            waitOutput(out, \".*java.lang.annotation.RetentionPolicy.*java.lang.annotation.RetentionPolicy.CLASS.*\" +\n+                            REDRAW_PROMPT + \"@Ann1\\\\(@java.lang.annotation.Retention\\\\(\");\n+            inputSink.write(\"CL\" + TAB);\n+            waitOutput(out, \"CL\\\\u001B\\\\[2Djava.lang.annotation.RetentionPolicy.CLASS \\\\u0008\");\n+        });\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ToolTabSnippetTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.text;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.runner.Runner;\n-import org.openjdk.jmh.runner.options.Options;\n-import org.openjdk.jmh.runner.options.OptionsBuilder;\n-\n-import java.text.DateFormat;\n-import java.util.Date;\n-import java.util.Locale;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.Throughput)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@Warmup(iterations = 5, time = 1)\n-@Measurement(iterations = 5, time = 1)\n-@Fork(3)\n-@State(Scope.Benchmark)\n-public class DateFormatterBench {\n-\n-    private Date date;\n-\n-    private Object objDate;\n-\n-    @Setup\n-    public void setup() {\n-        date = new Date();\n-        objDate = new Date();\n-    }\n-\n-    private DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.FULL, Locale.ENGLISH);\n-\n-    @Benchmark\n-    public String testFormatDate() {\n-        return dateFormat.format(date);\n-    }\n-\n-    @Benchmark\n-    public String testFormatObject() {\n-        return dateFormat.format(objDate);\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        Options opts = new OptionsBuilder().include(DateFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n-        new Runner(opts).run();\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/DateFormatterBench.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.text;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Benchmark)\n+public class SimpleDateFormatterBench {\n+\n+    private Date date;\n+    private Object objDate;\n+    private String dateStr;\n+    private String timeStr;\n+\n+    private static final String DATE_PATTERN = \"EEEE, MMMM d, y\";\n+    private static final String TIME_PATTERN = \"h:mm:ss a zzzz\";\n+\n+    \/\/ Use non-factory methods w\/ pattern to ensure test data can be round\n+    \/\/ tripped and guarantee no re-use of the same instance\n+    private DateFormat dateFormat = new SimpleDateFormat(DATE_PATTERN);\n+    private DateFormat timeFormat = new SimpleDateFormat(TIME_PATTERN);\n+\n+    @Setup\n+    public void setup() {\n+        date = new Date();\n+        objDate = new Date();\n+        \/\/ Generate the strings for parsing using dedicated separate instances\n+        dateStr = new SimpleDateFormat(DATE_PATTERN).format(date);\n+        timeStr = new SimpleDateFormat(TIME_PATTERN).format(date);\n+    }\n+\n+    @Benchmark\n+    public String testTimeFormat() {\n+        return timeFormat.format(date);\n+    }\n+\n+    @Benchmark\n+    public String testTimeFormatObject() {\n+        return timeFormat.format(objDate);\n+    }\n+\n+    @Benchmark\n+    public String testDateFormat() {\n+        return dateFormat.format(date);\n+    }\n+\n+    @Benchmark\n+    public String testDateFormatObject() {\n+        return dateFormat.format(objDate);\n+    }\n+\n+    @Benchmark\n+    public Date testDateParse() throws ParseException {\n+        return dateFormat.parse(dateStr);\n+    }\n+\n+    @Benchmark\n+    public Date testTimeParse() throws ParseException {\n+        return timeFormat.parse(timeStr);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        Options opts = new OptionsBuilder().include(org.openjdk.bench.java.text.SimpleDateFormatterBench.class.getSimpleName()).shouldDoGC(true).build();\n+        new Runner(opts).run();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/text\/SimpleDateFormatterBench.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import jdk.incubator.vector.*;\n+import java.lang.invoke.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 2, jvmArgs = { \"--add-modules=jdk.incubator.vector\" })\n+public abstract class MaskCompareNotBenchmark {\n+    @Param({\"4096\"})\n+    protected int ARRAYLEN;\n+\n+    \/\/ Abstract method to get comparison operator from subclasses\n+    protected abstract String getComparisonOperatorName();\n+\n+    \/\/ To get compile-time constants for comparison operation\n+    static final MutableCallSite MUTABLE_COMPARISON_CONSTANT = new MutableCallSite(MethodType.methodType(VectorOperators.Comparison.class));\n+    static final MethodHandle MUTABLE_COMPARISON_CONSTANT_HANDLE = MUTABLE_COMPARISON_CONSTANT.dynamicInvoker();\n+\n+    private static Random r = new Random();\n+\n+    protected static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    protected static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    protected static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    protected static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+    protected static final VectorSpecies<Float> F_SPECIES = FloatVector.SPECIES_MAX;\n+    protected static final VectorSpecies<Double> D_SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    protected boolean[] mr;\n+    protected byte[] ba;\n+    protected byte[] bb;\n+    protected short[] sa;\n+    protected short[] sb;\n+    protected int[] ia;\n+    protected int[] ib;\n+    protected long[] la;\n+    protected long[] lb;\n+    protected float[] fa;\n+    protected float[] fb;\n+    protected double[] da;\n+    protected double[] db;\n+\n+    @Setup\n+    public void init() throws Throwable {\n+        mr = new boolean[ARRAYLEN];\n+        ba = new byte[ARRAYLEN];\n+        bb = new byte[ARRAYLEN];\n+        sa = new short[ARRAYLEN];\n+        sb = new short[ARRAYLEN];\n+        ia = new int[ARRAYLEN];\n+        ib = new int[ARRAYLEN];\n+        la = new long[ARRAYLEN];\n+        lb = new long[ARRAYLEN];\n+        fa = new float[ARRAYLEN];\n+        fb = new float[ARRAYLEN];\n+        da = new double[ARRAYLEN];\n+        db = new double[ARRAYLEN];\n+\n+        for (int i = 0; i < ARRAYLEN; i++) {\n+            mr[i] = r.nextBoolean();\n+            ba[i] = (byte) r.nextInt();\n+            bb[i] = (byte) r.nextInt();\n+            sa[i] = (short) r.nextInt();\n+            sb[i] = (short) r.nextInt();\n+            ia[i] = r.nextInt();\n+            ib[i] = r.nextInt();\n+            la[i] = r.nextLong();\n+            lb[i] = r.nextLong();\n+            fa[i] = r.nextFloat();\n+            fb[i] = r.nextFloat();\n+            da[i] = r.nextDouble();\n+            db[i] = r.nextDouble();\n+        }\n+\n+        VectorOperators.Comparison comparisonOp = getComparisonOperator(getComparisonOperatorName());\n+        MethodHandle constant = MethodHandles.constant(VectorOperators.Comparison.class, comparisonOp);\n+        MUTABLE_COMPARISON_CONSTANT.setTarget(constant);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    private static VectorOperators.Comparison getComparisonOperator(String op) {\n+        switch (op) {\n+            case \"EQ\": return VectorOperators.EQ;\n+            case \"NE\": return VectorOperators.NE;\n+            case \"LT\": return VectorOperators.LT;\n+            case \"LE\": return VectorOperators.LE;\n+            case \"GT\": return VectorOperators.GT;\n+            case \"GE\": return VectorOperators.GE;\n+            case \"ULT\": return VectorOperators.ULT;\n+            case \"ULE\": return VectorOperators.ULE;\n+            case \"UGT\": return VectorOperators.UGT;\n+            case \"UGE\": return VectorOperators.UGE;\n+            default: throw new IllegalArgumentException(\"Unknown comparison operator: \" + op);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    protected VectorOperators.Comparison comparison_con() throws Throwable {\n+        return (VectorOperators.Comparison) MUTABLE_COMPARISON_CONSTANT_HANDLE.invokeExact();\n+    }\n+\n+    \/\/ Subclasses with different comparison operators\n+    public static class IntegerComparisons extends MaskCompareNotBenchmark {\n+        @Param({\"EQ\", \"NE\", \"LT\", \"LE\", \"GT\", \"GE\", \"ULT\", \"ULE\", \"UGT\", \"UGE\"})\n+        public String COMPARISON_OP;\n+\n+        @Override\n+        protected String getComparisonOperatorName() {\n+            return COMPARISON_OP;\n+        }\n+\n+        @Benchmark\n+        public void testCompareMaskNotByte() throws Throwable {\n+            VectorOperators.Comparison op = comparison_con();\n+            ByteVector bv = ByteVector.fromArray(B_SPECIES, bb, 0);\n+            for (int j = 0; j < ARRAYLEN; j += B_SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(B_SPECIES, ba, j);\n+                VectorMask<Byte> m = av.compare(op, bv).not();\n+                m.intoArray(mr, j);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testCompareMaskNotShort() throws Throwable {\n+            VectorOperators.Comparison op = comparison_con();\n+            ShortVector bv = ShortVector.fromArray(S_SPECIES, sb, 0);\n+            for (int j = 0; j < ARRAYLEN; j += S_SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(S_SPECIES, sa, j);\n+                VectorMask<Short> m = av.compare(op, bv).not();\n+                m.intoArray(mr, j);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testCompareMaskNotInt() throws Throwable {\n+            VectorOperators.Comparison op = comparison_con();\n+            IntVector bv = IntVector.fromArray(I_SPECIES, ib, 0);\n+            for (int j = 0; j < ARRAYLEN; j += I_SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(I_SPECIES, ia, j);\n+                VectorMask<Integer> m = av.compare(op, bv).not();\n+                m.intoArray(mr, j);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testCompareMaskNotLong() throws Throwable {\n+            VectorOperators.Comparison op = comparison_con();\n+            LongVector bv = LongVector.fromArray(L_SPECIES, lb, 0);\n+            for (int j = 0; j < ARRAYLEN; j += L_SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(L_SPECIES, la, j);\n+                VectorMask<Long> m = av.compare(op, bv).not();\n+                m.intoArray(mr, j);\n+            }\n+        }\n+    }\n+\n+    public static class FloatingPointComparisons extends MaskCompareNotBenchmark {\n+        \/\/ \"ULT\", \"ULE\", \"UGT\", \"UGE\" are not supported for floating point types\n+        @Param({\"EQ\", \"NE\", \"LT\", \"LE\", \"GT\", \"GE\"})\n+        public String COMPARISON_OP;\n+\n+        @Override\n+        protected String getComparisonOperatorName() {\n+            return COMPARISON_OP;\n+        }\n+\n+        @Benchmark\n+        public void testCompareMaskNotFloat() throws Throwable {\n+            VectorOperators.Comparison op = comparison_con();\n+            FloatVector bv = FloatVector.fromArray(F_SPECIES, fb, 0);\n+            for (int j = 0; j < ARRAYLEN; j += F_SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(F_SPECIES, fa, j);\n+                VectorMask<Float> m = av.compare(op, bv).not();\n+                m.intoArray(mr, j);\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testCompareMaskNotDouble() throws Throwable {\n+            VectorOperators.Comparison op = comparison_con();\n+            DoubleVector bv = DoubleVector.fromArray(D_SPECIES, db, 0);\n+            for (int j = 0; j < ARRAYLEN; j += D_SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(D_SPECIES, da, j);\n+                VectorMask<Double> m = av.compare(op, bv).not();\n+                m.intoArray(mr, j);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskCompareNotBenchmark.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"}]}