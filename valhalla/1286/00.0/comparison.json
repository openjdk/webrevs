{"files":[{"patch":"@@ -571,0 +571,4 @@\n+$(eval $(call SetupTarget, update-sleef-source, \\\n+    MAKEFILE := UpdateSleefSource, \\\n+))\n+\n","filename":"make\/Main.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-JAVA_FLAGS_BIG := -Xms64M -Xmx1600M\n+JAVA_FLAGS_BIG := -Xms64M -Xmx3200M\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-  JVM_HEAP_LIMIT_64=\"1600\"\n+  JVM_HEAP_LIMIT_64=\"3200\"\n","filename":"make\/autoconf\/boot-jdk.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c exeGetCreatedJavaVMs.c libTestUnloadedClass.cpp\n@@ -1531,0 +1531,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libTestUnloadedClass += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::counter_overflow_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n@@ -69,1 +69,1 @@\n-    address a = Runtime1::entry_for(Runtime1::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n@@ -82,1 +82,1 @@\n-  Runtime1::StubID stub_id;\n+  C1StubId stub_id;\n@@ -84,1 +84,1 @@\n-    stub_id = Runtime1::throw_index_exception_id;\n+    stub_id = C1StubId::throw_index_exception_id;\n@@ -88,1 +88,1 @@\n-    stub_id = Runtime1::throw_range_check_failed_id;\n+    stub_id = C1StubId::throw_range_check_failed_id;\n@@ -103,1 +103,1 @@\n-  address a = Runtime1::entry_for(Runtime1::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n@@ -115,1 +115,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::throw_div0_exception_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n@@ -138,1 +138,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_flat_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::load_flat_array_id)));\n@@ -165,1 +165,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::store_flat_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::store_flat_array_id)));\n@@ -184,1 +184,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::substitutability_check_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::substitutability_check_id)));\n@@ -193,1 +193,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, Runtime1::StubID stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n@@ -198,3 +198,3 @@\n-  assert(stub_id == Runtime1::new_instance_id                 ||\n-         stub_id == Runtime1::fast_new_instance_id            ||\n-         stub_id == Runtime1::fast_new_instance_init_check_id,\n+  assert(stub_id == C1StubId::new_instance_id                 ||\n+         stub_id == C1StubId::fast_new_instance_id            ||\n+         stub_id == C1StubId::fast_new_instance_init_check_id,\n@@ -234,1 +234,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_type_array_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n@@ -261,1 +261,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_null_free_array_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_null_free_array_id)));\n@@ -263,1 +263,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_object_array_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n@@ -287,1 +287,1 @@\n-  Runtime1::StubID enter_id;\n+  C1StubId enter_id;\n@@ -289,1 +289,1 @@\n-    enter_id = Runtime1::monitorenter_id;\n+    enter_id = C1StubId::monitorenter_id;\n@@ -291,1 +291,1 @@\n-    enter_id = Runtime1::monitorenter_nofpu_id;\n+    enter_id = C1StubId::monitorenter_nofpu_id;\n@@ -308,1 +308,1 @@\n-  Runtime1::StubID exit_id;\n+  C1StubId exit_id;\n@@ -310,1 +310,1 @@\n-    exit_id = Runtime1::monitorexit_id;\n+    exit_id = C1StubId::monitorexit_id;\n@@ -312,1 +312,1 @@\n-    exit_id = Runtime1::monitorexit_nofpu_id;\n+    exit_id = C1StubId::monitorexit_nofpu_id;\n@@ -340,1 +340,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::deoptimize_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n@@ -350,1 +350,1 @@\n-    a = Runtime1::entry_for(Runtime1::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n@@ -352,1 +352,1 @@\n-    a = Runtime1::entry_for(Runtime1::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-    target = Runtime1::entry_for(Runtime1::access_field_patching_id);\n+    target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n@@ -330,1 +330,1 @@\n-    target = Runtime1::entry_for(Runtime1::load_klass_patching_id);\n+    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n@@ -334,1 +334,1 @@\n-    target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);\n+    target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n@@ -338,1 +338,1 @@\n-    target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);\n+    target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n@@ -380,1 +380,1 @@\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n@@ -437,1 +437,1 @@\n-  __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));\n+  __ far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n@@ -914,1 +914,1 @@\n-    target = Runtime1::entry_for(Runtime1::access_field_patching_id);\n+    target = Runtime1::entry_for(C1StubId::access_field_patching_id);\n@@ -918,1 +918,1 @@\n-    target = Runtime1::entry_for(Runtime1::load_klass_patching_id);\n+    target = Runtime1::entry_for(C1StubId::load_klass_patching_id);\n@@ -922,1 +922,1 @@\n-    target = Runtime1::entry_for(Runtime1::load_mirror_patching_id);\n+    target = Runtime1::entry_for(C1StubId::load_mirror_patching_id);\n@@ -926,1 +926,1 @@\n-    target = Runtime1::entry_for(Runtime1::load_appendix_patching_id);\n+    target = Runtime1::entry_for(C1StubId::load_appendix_patching_id);\n@@ -1411,1 +1411,1 @@\n-        __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+        __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n@@ -1422,1 +1422,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n@@ -1501,1 +1501,1 @@\n-    __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+    __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n@@ -2196,1 +2196,1 @@\n-  Runtime1::StubID unwind_id;\n+  C1StubId unwind_id;\n@@ -2215,1 +2215,1 @@\n-    unwind_id = Runtime1::handle_exception_id;\n+    unwind_id = C1StubId::handle_exception_id;\n@@ -2217,1 +2217,1 @@\n-    unwind_id = Runtime1::handle_exception_nofpu_id;\n+    unwind_id = C1StubId::handle_exception_nofpu_id;\n@@ -2523,1 +2523,1 @@\n-      __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+      __ far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-      new SimpleExceptionStub(Runtime1::throw_identity_exception_id, obj.result(), state_for(x)) :\n+      new SimpleExceptionStub(C1StubId::throw_identity_exception_id, obj.result(), state_for(x)) :\n@@ -1264,1 +1264,1 @@\n-  __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n@@ -1298,1 +1298,1 @@\n-    stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -1305,1 +1305,1 @@\n-    stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n@@ -325,1 +325,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n@@ -399,1 +399,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::buffer_inline_args_no_receiver_id)));\n@@ -401,1 +401,1 @@\n-    far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_id)));\n+    far_call(RuntimeAddress(Runtime1::entry_for(C1StubId::buffer_inline_args_id)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    } else if (_stub_id == Runtime1::forward_exception_id) {\n+    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n@@ -106,1 +106,1 @@\n-      far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));\n+      far_jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n@@ -361,1 +361,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(StubID id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n@@ -373,1 +373,1 @@\n-  case forward_exception_id:\n+  case C1StubId::forward_exception_id:\n@@ -393,2 +393,2 @@\n-  case handle_exception_nofpu_id:\n-  case handle_exception_id:\n+  case C1StubId::handle_exception_nofpu_id:\n+  case C1StubId::handle_exception_id:\n@@ -396,1 +396,1 @@\n-    oop_map = save_live_registers(sasm, id != handle_exception_nofpu_id);\n+    oop_map = save_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n@@ -398,1 +398,1 @@\n-  case handle_exception_from_callee_id: {\n+  case C1StubId::handle_exception_from_callee_id: {\n@@ -456,3 +456,3 @@\n-  case forward_exception_id:\n-  case handle_exception_nofpu_id:\n-  case handle_exception_id:\n+  case C1StubId::forward_exception_id:\n+  case C1StubId::handle_exception_nofpu_id:\n+  case C1StubId::handle_exception_id:\n@@ -460,1 +460,1 @@\n-    restore_live_registers(sasm, id != handle_exception_nofpu_id);\n+    restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n@@ -462,1 +462,1 @@\n-  case handle_exception_from_callee_id:\n+  case C1StubId::handle_exception_from_callee_id:\n@@ -614,1 +614,1 @@\n-OopMapSet* Runtime1::generate_code_for(StubID id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n@@ -631,1 +631,1 @@\n-    case forward_exception_id:\n+    case C1StubId::forward_exception_id:\n@@ -639,1 +639,1 @@\n-    case throw_div0_exception_id:\n+    case C1StubId::throw_div0_exception_id:\n@@ -645,1 +645,1 @@\n-    case throw_null_pointer_exception_id:\n+    case C1StubId::throw_null_pointer_exception_id:\n@@ -651,3 +651,3 @@\n-    case new_instance_id:\n-    case fast_new_instance_id:\n-    case fast_new_instance_init_check_id:\n+    case C1StubId::new_instance_id:\n+    case C1StubId::fast_new_instance_id:\n+    case C1StubId::fast_new_instance_init_check_id:\n@@ -658,1 +658,1 @@\n-        if (id == new_instance_id) {\n+        if (id == C1StubId::new_instance_id) {\n@@ -660,1 +660,1 @@\n-        } else if (id == fast_new_instance_id) {\n+        } else if (id == C1StubId::fast_new_instance_id) {\n@@ -663,1 +663,1 @@\n-          assert(id == fast_new_instance_init_check_id, \"bad StubID\");\n+          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n@@ -683,1 +683,1 @@\n-    case counter_overflow_id:\n+    case C1StubId::counter_overflow_id:\n@@ -701,3 +701,3 @@\n-    case new_type_array_id:\n-    case new_object_array_id:\n-    case new_null_free_array_id:\n+    case C1StubId::new_type_array_id:\n+    case C1StubId::new_object_array_id:\n+    case C1StubId::new_null_free_array_id:\n@@ -709,1 +709,1 @@\n-        if (id == new_type_array_id) {\n+        if (id == C1StubId::new_type_array_id) {\n@@ -711,1 +711,1 @@\n-        } else if (id == new_object_array_id) {\n+        } else if (id == C1StubId::new_object_array_id) {\n@@ -725,1 +725,1 @@\n-          case new_type_array_id:\n+          case C1StubId::new_type_array_id:\n@@ -730,1 +730,1 @@\n-          case new_object_array_id:\n+          case C1StubId::new_object_array_id:\n@@ -737,1 +737,1 @@\n-          case new_null_free_array_id:\n+          case C1StubId::new_null_free_array_id:\n@@ -754,1 +754,1 @@\n-        if (id == new_type_array_id) {\n+        if (id == C1StubId::new_type_array_id) {\n@@ -756,1 +756,1 @@\n-        } else if (id == new_object_array_id) {\n+        } else if (id == C1StubId::new_object_array_id) {\n@@ -759,1 +759,1 @@\n-          assert(id == new_null_free_array_id, \"must be\");\n+          assert(id == C1StubId::new_null_free_array_id, \"must be\");\n@@ -775,1 +775,1 @@\n-    case new_multi_array_id:\n+    case C1StubId::new_multi_array_id:\n@@ -795,2 +795,2 @@\n-    case buffer_inline_args_id:\n-    case buffer_inline_args_no_receiver_id:\n+    case C1StubId::buffer_inline_args_id:\n+    case C1StubId::buffer_inline_args_no_receiver_id:\n@@ -798,1 +798,1 @@\n-        const char* name = (id == buffer_inline_args_id) ?\n+        const char* name = (id == C1StubId::buffer_inline_args_id) ?\n@@ -803,1 +803,1 @@\n-        address entry = (id == buffer_inline_args_id) ?\n+        address entry = (id == C1StubId::buffer_inline_args_id) ?\n@@ -820,1 +820,1 @@\n-    case load_flat_array_id:\n+    case C1StubId::load_flat_array_id:\n@@ -844,1 +844,1 @@\n-    case store_flat_array_id:\n+    case C1StubId::store_flat_array_id:\n@@ -862,1 +862,1 @@\n-    case substitutability_check_id:\n+    case C1StubId::substitutability_check_id:\n@@ -881,1 +881,1 @@\n-    case register_finalizer_id:\n+    case C1StubId::register_finalizer_id:\n@@ -913,1 +913,1 @@\n-    case throw_class_cast_exception_id:\n+    case C1StubId::throw_class_cast_exception_id:\n@@ -919,1 +919,1 @@\n-    case throw_incompatible_class_change_error_id:\n+    case C1StubId::throw_incompatible_class_change_error_id:\n@@ -925,1 +925,1 @@\n-    case throw_illegal_monitor_state_exception_id:\n+    case C1StubId::throw_illegal_monitor_state_exception_id:\n@@ -931,1 +931,1 @@\n-    case throw_identity_exception_id:\n+    case C1StubId::throw_identity_exception_id:\n@@ -937,1 +937,1 @@\n-    case slow_subtype_check_id:\n+    case C1StubId::slow_subtype_check_id:\n@@ -980,1 +980,1 @@\n-    case monitorenter_nofpu_id:\n+    case C1StubId::monitorenter_nofpu_id:\n@@ -983,1 +983,1 @@\n-    case monitorenter_id:\n+    case C1StubId::monitorenter_id:\n@@ -1001,1 +1001,1 @@\n-    case monitorexit_nofpu_id:\n+    case C1StubId::monitorexit_nofpu_id:\n@@ -1004,1 +1004,1 @@\n-    case monitorexit_id:\n+    case C1StubId::monitorexit_id:\n@@ -1024,1 +1024,1 @@\n-    case deoptimize_id:\n+    case C1StubId::deoptimize_id:\n@@ -1041,1 +1041,1 @@\n-    case throw_range_check_failed_id:\n+    case C1StubId::throw_range_check_failed_id:\n@@ -1047,1 +1047,1 @@\n-    case unwind_exception_id:\n+    case C1StubId::unwind_exception_id:\n@@ -1055,1 +1055,1 @@\n-    case access_field_patching_id:\n+    case C1StubId::access_field_patching_id:\n@@ -1062,1 +1062,1 @@\n-    case load_klass_patching_id:\n+    case C1StubId::load_klass_patching_id:\n@@ -1069,1 +1069,1 @@\n-    case load_mirror_patching_id:\n+    case C1StubId::load_mirror_patching_id:\n@@ -1076,1 +1076,1 @@\n-    case load_appendix_patching_id:\n+    case C1StubId::load_appendix_patching_id:\n@@ -1083,2 +1083,2 @@\n-    case handle_exception_nofpu_id:\n-    case handle_exception_id:\n+    case C1StubId::handle_exception_nofpu_id:\n+    case C1StubId::handle_exception_id:\n@@ -1090,1 +1090,1 @@\n-    case handle_exception_from_callee_id:\n+    case C1StubId::handle_exception_from_callee_id:\n@@ -1096,1 +1096,1 @@\n-    case throw_index_exception_id:\n+    case C1StubId::throw_index_exception_id:\n@@ -1102,1 +1102,1 @@\n-    case throw_array_store_exception_id:\n+    case C1StubId::throw_array_store_exception_id:\n@@ -1110,1 +1110,1 @@\n-    case predicate_failed_trap_id:\n+    case C1StubId::predicate_failed_trap_id:\n@@ -1128,1 +1128,1 @@\n-    case dtrace_object_alloc_id:\n+    case C1StubId::dtrace_object_alloc_id:\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -5255,2 +5255,2 @@\n-    const uint64_t range_mask =\n-      (1ULL << log2i(CompressedKlassPointers::range())) - 1;\n+    const size_t range = CompressedKlassPointers::klass_range_end() - CompressedKlassPointers::base();\n+    const uint64_t range_mask = (1ULL << log2i(range)) - 1;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  __ call(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id), relocInfo::runtime_call_type);\n+  __ call(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id), relocInfo::runtime_call_type);\n@@ -256,1 +256,1 @@\n-  __ jump(Runtime1::entry_for(Runtime1::unwind_exception_id), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(Runtime1::entry_for(C1StubId::unwind_exception_id), relocInfo::runtime_call_type, Rtemp);\n@@ -1139,1 +1139,1 @@\n-      __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);\n+      __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1213,1 +1213,1 @@\n-          __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);\n+          __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1230,1 +1230,1 @@\n-        __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);\n+        __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1306,1 +1306,1 @@\n-          __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);\n+          __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1337,1 +1337,1 @@\n-        __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);\n+        __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type);\n@@ -1984,3 +1984,3 @@\n-  Runtime1::StubID handle_id = compilation()->has_fpu_code() ?\n-                               Runtime1::handle_exception_id :\n-                               Runtime1::handle_exception_nofpu_id;\n+  C1StubId handle_id = compilation()->has_fpu_code() ?\n+                               C1StubId::handle_exception_id :\n+                               C1StubId::handle_exception_nofpu_id;\n@@ -2263,1 +2263,1 @@\n-      __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type); \/\/ does not blow any registers except R0, LR and Rtemp\n+      __ call(Runtime1::entry_for(C1StubId::slow_subtype_check_id), relocInfo::runtime_call_type); \/\/ does not blow any registers except R0, LR and Rtemp\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::handle_exception_from_callee_id));\n+  address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::handle_exception_from_callee_id));\n@@ -225,1 +225,1 @@\n-  address unwind_stub = Runtime1::entry_for(Runtime1::unwind_exception_id);\n+  address unwind_stub = Runtime1::entry_for(C1StubId::unwind_exception_id);\n@@ -1803,2 +1803,2 @@\n-  address stub = Runtime1::entry_for(compilation()->has_fpu_code() ? Runtime1::handle_exception_id\n-                                                                   : Runtime1::handle_exception_nofpu_id);\n+  address stub = Runtime1::entry_for(compilation()->has_fpu_code() ? C1StubId::handle_exception_id\n+                                                                   : C1StubId::handle_exception_nofpu_id);\n@@ -2004,1 +2004,1 @@\n-      address slow_stc = Runtime1::entry_for(Runtime1::slow_subtype_check_id);\n+      address slow_stc = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n@@ -2455,1 +2455,1 @@\n-      address entry = Runtime1::entry_for(Runtime1::slow_subtype_check_id);\n+      address entry = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n@@ -2546,1 +2546,1 @@\n-    const address slow_path = Runtime1::entry_for(Runtime1::slow_subtype_check_id);\n+    const address slow_path = Runtime1::entry_for(C1StubId::slow_subtype_check_id);\n@@ -2853,2 +2853,2 @@\n-  if (dest == Runtime1::entry_for(Runtime1::register_finalizer_id) ||\n-      dest == Runtime1::entry_for(Runtime1::new_multi_array_id   )) {\n+  if (dest == Runtime1::entry_for(C1StubId::register_finalizer_id) ||\n+      dest == Runtime1::entry_for(C1StubId::new_multi_array_id   )) {\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  address a = Runtime1::entry_for (Runtime1::handle_exception_from_callee_id);\n+  address a = Runtime1::entry_for (C1StubId::handle_exception_from_callee_id);\n@@ -215,1 +215,1 @@\n-    \/\/ Runtime1::monitorexit_id expects lock address in Z_R1_scratch.\n+    \/\/ C1StubId::monitorexit_id expects lock address in Z_R1_scratch.\n@@ -244,1 +244,1 @@\n-  __ load_const_optimized(Z_R5, Runtime1::entry_for (Runtime1::unwind_exception_id));\n+  __ load_const_optimized(Z_R5, Runtime1::entry_for (C1StubId::unwind_exception_id));\n@@ -1913,2 +1913,2 @@\n-  address stub = Runtime1::entry_for (compilation()->has_fpu_code() ? Runtime1::handle_exception_id\n-                                                                    : Runtime1::handle_exception_nofpu_id);\n+  address stub = Runtime1::entry_for (compilation()->has_fpu_code() ? C1StubId::handle_exception_id\n+                                                                    : C1StubId::handle_exception_nofpu_id);\n@@ -2119,1 +2119,1 @@\n-      emit_call_c(Runtime1::entry_for (Runtime1::slow_subtype_check_id));\n+      emit_call_c(Runtime1::entry_for (C1StubId::slow_subtype_check_id));\n@@ -2542,1 +2542,1 @@\n-      address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);\n+      address a = Runtime1::entry_for (C1StubId::slow_subtype_check_id);\n@@ -2617,1 +2617,1 @@\n-    address a = Runtime1::entry_for (Runtime1::slow_subtype_check_id);\n+    address a = Runtime1::entry_for (C1StubId::slow_subtype_check_id);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::counter_overflow_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::counter_overflow_id)));\n@@ -123,1 +123,1 @@\n-    address a = Runtime1::entry_for(Runtime1::predicate_failed_trap_id);\n+    address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n@@ -137,1 +137,1 @@\n-  Runtime1::StubID stub_id;\n+  C1StubId stub_id;\n@@ -139,1 +139,1 @@\n-    stub_id = Runtime1::throw_index_exception_id;\n+    stub_id = C1StubId::throw_index_exception_id;\n@@ -141,1 +141,1 @@\n-    stub_id = Runtime1::throw_range_check_failed_id;\n+    stub_id = C1StubId::throw_range_check_failed_id;\n@@ -156,1 +156,1 @@\n-  address a = Runtime1::entry_for(Runtime1::predicate_failed_trap_id);\n+  address a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n@@ -168,1 +168,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::throw_div0_exception_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::throw_div0_exception_id)));\n@@ -190,1 +190,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_flat_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::load_flat_array_id)));\n@@ -218,1 +218,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::store_flat_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::store_flat_array_id)));\n@@ -240,1 +240,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::substitutability_check_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::substitutability_check_id)));\n@@ -249,1 +249,1 @@\n-NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, Runtime1::StubID stub_id) {\n+NewInstanceStub::NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id) {\n@@ -254,3 +254,3 @@\n-  assert(stub_id == Runtime1::new_instance_id                 ||\n-         stub_id == Runtime1::fast_new_instance_id            ||\n-         stub_id == Runtime1::fast_new_instance_init_check_id,\n+  assert(stub_id == C1StubId::new_instance_id                 ||\n+         stub_id == C1StubId::fast_new_instance_id            ||\n+         stub_id == C1StubId::fast_new_instance_init_check_id,\n@@ -289,1 +289,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_type_array_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_type_array_id)));\n@@ -315,1 +315,1 @@\n-    __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_null_free_array_id)));\n+    __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_null_free_array_id)));\n@@ -317,1 +317,1 @@\n-    __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::new_object_array_id)));\n+    __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::new_object_array_id)));\n@@ -339,1 +339,1 @@\n-  Runtime1::StubID enter_id;\n+  C1StubId enter_id;\n@@ -341,1 +341,1 @@\n-    enter_id = Runtime1::monitorenter_id;\n+    enter_id = C1StubId::monitorenter_id;\n@@ -343,1 +343,1 @@\n-    enter_id = Runtime1::monitorenter_nofpu_id;\n+    enter_id = C1StubId::monitorenter_nofpu_id;\n@@ -360,1 +360,1 @@\n-  Runtime1::StubID exit_id;\n+  C1StubId exit_id;\n@@ -362,1 +362,1 @@\n-    exit_id = Runtime1::monitorexit_id;\n+    exit_id = C1StubId::monitorexit_id;\n@@ -364,1 +364,1 @@\n-    exit_id = Runtime1::monitorexit_nofpu_id;\n+    exit_id = C1StubId::monitorexit_nofpu_id;\n@@ -499,4 +499,4 @@\n-    case access_field_id:  target = Runtime1::entry_for(Runtime1::access_field_patching_id); break;\n-    case load_klass_id:    target = Runtime1::entry_for(Runtime1::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n-    case load_mirror_id:   target = Runtime1::entry_for(Runtime1::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n-    case load_appendix_id:      target = Runtime1::entry_for(Runtime1::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case access_field_id:  target = Runtime1::entry_for(C1StubId::access_field_patching_id); break;\n+    case load_klass_id:    target = Runtime1::entry_for(C1StubId::load_klass_patching_id); reloc_type = relocInfo::metadata_type; break;\n+    case load_mirror_id:   target = Runtime1::entry_for(C1StubId::load_mirror_patching_id); reloc_type = relocInfo::oop_type; break;\n+    case load_appendix_id:      target = Runtime1::entry_for(C1StubId::load_appendix_patching_id); reloc_type = relocInfo::oop_type; break;\n@@ -532,1 +532,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::deoptimize_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::deoptimize_id)));\n@@ -542,1 +542,1 @@\n-    a = Runtime1::entry_for(Runtime1::predicate_failed_trap_id);\n+    a = Runtime1::entry_for(C1StubId::predicate_failed_trap_id);\n@@ -544,1 +544,1 @@\n-    a = Runtime1::entry_for(Runtime1::throw_null_pointer_exception_id);\n+    a = Runtime1::entry_for(C1StubId::throw_null_pointer_exception_id);\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));\n+  __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::handle_exception_from_callee_id)));\n@@ -468,1 +468,1 @@\n-  __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));\n+  __ jump(RuntimeAddress(Runtime1::entry_for(C1StubId::unwind_exception_id)));\n@@ -1606,1 +1606,1 @@\n-        __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));\n+        __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::fpu2long_stub_id)));\n@@ -1823,1 +1823,1 @@\n-        __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+        __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n@@ -1837,1 +1837,1 @@\n-      __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+      __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n@@ -1916,1 +1916,1 @@\n-    __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+    __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n@@ -3052,1 +3052,1 @@\n-  Runtime1::StubID unwind_id;\n+  C1StubId unwind_id;\n@@ -3064,1 +3064,1 @@\n-    unwind_id = Runtime1::handle_exception_id;\n+    unwind_id = C1StubId::handle_exception_id;\n@@ -3066,1 +3066,1 @@\n-    unwind_id = Runtime1::handle_exception_nofpu_id;\n+    unwind_id = C1StubId::handle_exception_nofpu_id;\n@@ -3448,1 +3448,1 @@\n-      __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));\n+      __ call(RuntimeAddress(Runtime1::entry_for(C1StubId::slow_subtype_check_id)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-      new SimpleExceptionStub(Runtime1::throw_identity_exception_id,\n+      new SimpleExceptionStub(C1StubId::throw_identity_exception_id,\n@@ -1458,1 +1458,1 @@\n-  __ call_runtime(Runtime1::entry_for(Runtime1::new_multi_array_id),\n+  __ call_runtime(Runtime1::entry_for(C1StubId::new_multi_array_id),\n@@ -1495,1 +1495,1 @@\n-    stub = new SimpleExceptionStub(Runtime1::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n+    stub = new SimpleExceptionStub(C1StubId::throw_incompatible_class_change_error_id, LIR_OprFact::illegalOpr, info_for_exception);\n@@ -1500,1 +1500,1 @@\n-    stub = new SimpleExceptionStub(Runtime1::throw_class_cast_exception_id, obj.result(), info_for_exception);\n+    stub = new SimpleExceptionStub(C1StubId::throw_class_cast_exception_id, obj.result(), info_for_exception);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n@@ -325,1 +325,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(Runtime1::dtrace_object_alloc_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(C1StubId::dtrace_object_alloc_id)));\n@@ -422,1 +422,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(C1StubId::buffer_inline_args_no_receiver_id)));\n@@ -424,1 +424,1 @@\n-    call(RuntimeAddress(Runtime1::entry_for(Runtime1::buffer_inline_args_id)));\n+    call(RuntimeAddress(Runtime1::entry_for(C1StubId::buffer_inline_args_id)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  align_stack = (stub_id() == Runtime1::handle_exception_from_callee_id);\n+  align_stack = (stub_id() == (int)C1StubId::handle_exception_from_callee_id);\n@@ -127,1 +127,1 @@\n-    } else if (_stub_id == Runtime1::forward_exception_id) {\n+    } else if (_stub_id == (int)C1StubId::forward_exception_id) {\n@@ -130,1 +130,1 @@\n-      jump(RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));\n+      jump(RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n@@ -674,1 +674,1 @@\n-OopMapSet* Runtime1::generate_handle_exception(StubID id, StubAssembler *sasm) {\n+OopMapSet* Runtime1::generate_handle_exception(C1StubId id, StubAssembler *sasm) {\n@@ -687,1 +687,1 @@\n-  case forward_exception_id:\n+  case C1StubId::forward_exception_id:\n@@ -706,2 +706,2 @@\n-  case handle_exception_nofpu_id:\n-  case handle_exception_id:\n+  case C1StubId::handle_exception_nofpu_id:\n+  case C1StubId::handle_exception_id:\n@@ -709,1 +709,1 @@\n-    oop_map = save_live_registers(sasm, 1 \/*thread*\/, id != handle_exception_nofpu_id);\n+    oop_map = save_live_registers(sasm, 1 \/*thread*\/, id != C1StubId::handle_exception_nofpu_id);\n@@ -711,1 +711,1 @@\n-  case handle_exception_from_callee_id: {\n+  case C1StubId::handle_exception_from_callee_id: {\n@@ -778,3 +778,3 @@\n-  case forward_exception_id:\n-  case handle_exception_nofpu_id:\n-  case handle_exception_id:\n+  case C1StubId::forward_exception_id:\n+  case C1StubId::handle_exception_nofpu_id:\n+  case C1StubId::handle_exception_id:\n@@ -782,1 +782,1 @@\n-    restore_live_registers(sasm, id != handle_exception_nofpu_id);\n+    restore_live_registers(sasm, id != C1StubId::handle_exception_nofpu_id);\n@@ -784,1 +784,1 @@\n-  case handle_exception_from_callee_id:\n+  case C1StubId::handle_exception_from_callee_id:\n@@ -938,1 +938,1 @@\n-               RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));\n+               RuntimeAddress(Runtime1::entry_for(C1StubId::forward_exception_id)));\n@@ -1010,1 +1010,1 @@\n-OopMapSet* Runtime1::generate_code_for(StubID id, StubAssembler* sasm) {\n+OopMapSet* Runtime1::generate_code_for(C1StubId id, StubAssembler* sasm) {\n@@ -1022,1 +1022,1 @@\n-    case forward_exception_id:\n+    case C1StubId::forward_exception_id:\n@@ -1030,3 +1030,3 @@\n-    case new_instance_id:\n-    case fast_new_instance_id:\n-    case fast_new_instance_init_check_id:\n+    case C1StubId::new_instance_id:\n+    case C1StubId::fast_new_instance_id:\n+    case C1StubId::fast_new_instance_init_check_id:\n@@ -1037,1 +1037,1 @@\n-        if (id == new_instance_id) {\n+        if (id == C1StubId::new_instance_id) {\n@@ -1039,1 +1039,1 @@\n-        } else if (id == fast_new_instance_id) {\n+        } else if (id == C1StubId::fast_new_instance_id) {\n@@ -1042,1 +1042,1 @@\n-          assert(id == fast_new_instance_init_check_id, \"bad StubID\");\n+          assert(id == C1StubId::fast_new_instance_init_check_id, \"bad C1StubId\");\n@@ -1062,1 +1062,1 @@\n-    case counter_overflow_id:\n+    case C1StubId::counter_overflow_id:\n@@ -1080,3 +1080,3 @@\n-    case new_type_array_id:\n-    case new_object_array_id:\n-    case new_null_free_array_id:\n+    case C1StubId::new_type_array_id:\n+    case C1StubId::new_object_array_id:\n+    case C1StubId::new_null_free_array_id:\n@@ -1088,1 +1088,1 @@\n-        if (id == new_type_array_id) {\n+        if (id == C1StubId::new_type_array_id) {\n@@ -1090,1 +1090,1 @@\n-        } else if (id == new_object_array_id) {\n+        } else if (id == C1StubId::new_object_array_id) {\n@@ -1104,1 +1104,1 @@\n-          case new_type_array_id:\n+          case C1StubId::new_type_array_id:\n@@ -1109,1 +1109,1 @@\n-          case new_object_array_id:\n+          case C1StubId::new_object_array_id:\n@@ -1116,1 +1116,1 @@\n-          case new_null_free_array_id:\n+          case C1StubId::new_null_free_array_id:\n@@ -1133,1 +1133,1 @@\n-        if (id == new_type_array_id) {\n+        if (id == C1StubId::new_type_array_id) {\n@@ -1135,1 +1135,1 @@\n-        } else if (id == new_object_array_id) {\n+        } else if (id == C1StubId::new_object_array_id) {\n@@ -1138,1 +1138,1 @@\n-          assert(id == new_null_free_array_id, \"must be\");\n+          assert(id == C1StubId::new_null_free_array_id, \"must be\");\n@@ -1154,1 +1154,1 @@\n-    case new_multi_array_id:\n+    case C1StubId::new_multi_array_id:\n@@ -1171,1 +1171,1 @@\n-    case load_flat_array_id:\n+    case C1StubId::load_flat_array_id:\n@@ -1191,1 +1191,1 @@\n-    case store_flat_array_id:\n+    case C1StubId::store_flat_array_id:\n@@ -1209,1 +1209,1 @@\n-    case substitutability_check_id:\n+    case C1StubId::substitutability_check_id:\n@@ -1229,2 +1229,2 @@\n-    case buffer_inline_args_id:\n-    case buffer_inline_args_no_receiver_id:\n+    case C1StubId::buffer_inline_args_id:\n+    case C1StubId::buffer_inline_args_no_receiver_id:\n@@ -1232,1 +1232,1 @@\n-        const char* name = (id == buffer_inline_args_id) ?\n+        const char* name = (id == C1StubId::buffer_inline_args_id) ?\n@@ -1237,1 +1237,1 @@\n-        address entry = (id == buffer_inline_args_id) ?\n+        address entry = (id == C1StubId::buffer_inline_args_id) ?\n@@ -1248,1 +1248,1 @@\n-    case register_finalizer_id:\n+    case C1StubId::register_finalizer_id:\n@@ -1288,1 +1288,1 @@\n-    case throw_range_check_failed_id:\n+    case C1StubId::throw_range_check_failed_id:\n@@ -1294,1 +1294,1 @@\n-    case throw_index_exception_id:\n+    case C1StubId::throw_index_exception_id:\n@@ -1300,1 +1300,1 @@\n-    case throw_div0_exception_id:\n+    case C1StubId::throw_div0_exception_id:\n@@ -1306,1 +1306,1 @@\n-    case throw_null_pointer_exception_id:\n+    case C1StubId::throw_null_pointer_exception_id:\n@@ -1312,2 +1312,2 @@\n-    case handle_exception_nofpu_id:\n-    case handle_exception_id:\n+    case C1StubId::handle_exception_nofpu_id:\n+    case C1StubId::handle_exception_id:\n@@ -1319,1 +1319,1 @@\n-    case handle_exception_from_callee_id:\n+    case C1StubId::handle_exception_from_callee_id:\n@@ -1325,1 +1325,1 @@\n-    case unwind_exception_id:\n+    case C1StubId::unwind_exception_id:\n@@ -1333,1 +1333,1 @@\n-    case throw_array_store_exception_id:\n+    case C1StubId::throw_array_store_exception_id:\n@@ -1341,1 +1341,1 @@\n-    case throw_class_cast_exception_id:\n+    case C1StubId::throw_class_cast_exception_id:\n@@ -1347,1 +1347,1 @@\n-    case throw_incompatible_class_change_error_id:\n+    case C1StubId::throw_incompatible_class_change_error_id:\n@@ -1353,1 +1353,1 @@\n-    case throw_illegal_monitor_state_exception_id:\n+    case C1StubId::throw_illegal_monitor_state_exception_id:\n@@ -1359,1 +1359,1 @@\n-    case throw_identity_exception_id:\n+    case C1StubId::throw_identity_exception_id:\n@@ -1365,1 +1365,1 @@\n-    case slow_subtype_check_id:\n+    case C1StubId::slow_subtype_check_id:\n@@ -1418,1 +1418,1 @@\n-    case monitorenter_nofpu_id:\n+    case C1StubId::monitorenter_nofpu_id:\n@@ -1421,1 +1421,1 @@\n-    case monitorenter_id:\n+    case C1StubId::monitorenter_id:\n@@ -1439,1 +1439,1 @@\n-    case monitorexit_nofpu_id:\n+    case C1StubId::monitorexit_nofpu_id:\n@@ -1442,1 +1442,1 @@\n-    case monitorexit_id:\n+    case C1StubId::monitorexit_id:\n@@ -1462,1 +1462,1 @@\n-    case deoptimize_id:\n+    case C1StubId::deoptimize_id:\n@@ -1479,1 +1479,1 @@\n-    case access_field_patching_id:\n+    case C1StubId::access_field_patching_id:\n@@ -1486,1 +1486,1 @@\n-    case load_klass_patching_id:\n+    case C1StubId::load_klass_patching_id:\n@@ -1493,1 +1493,1 @@\n-    case load_mirror_patching_id:\n+    case C1StubId::load_mirror_patching_id:\n@@ -1500,1 +1500,1 @@\n-    case load_appendix_patching_id:\n+    case C1StubId::load_appendix_patching_id:\n@@ -1507,1 +1507,1 @@\n-    case dtrace_object_alloc_id:\n+    case C1StubId::dtrace_object_alloc_id:\n@@ -1522,1 +1522,1 @@\n-    case fpu2long_stub_id:\n+    case C1StubId::fpu2long_stub_id:\n@@ -1611,1 +1611,1 @@\n-    case predicate_failed_trap_id:\n+    case C1StubId::predicate_failed_trap_id:\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":70,"deletions":70,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -432,2 +432,2 @@\n-      assert(dest == Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id) ||\n-             dest == Runtime1::entry_for(Runtime1::buffer_inline_args_id), \"unexpected safepoint in entry point\");\n+      assert(dest == Runtime1::entry_for(C1StubId::buffer_inline_args_no_receiver_id) ||\n+             dest == Runtime1::entry_for(C1StubId::buffer_inline_args_id), \"unexpected safepoint in entry point\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -11208,0 +11208,9 @@\n+\n+void MacroAssembler::setcc(Assembler::Condition comparison, Register dst) {\n+  if (VM_Version::supports_apx_f()) {\n+    esetzucc(comparison, dst);\n+  } else {\n+    setb(comparison, dst);\n+    movzbl(dst, dst);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2235,0 +2235,1 @@\n+  void setcc(Assembler::Condition comparison, Register dst);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2630,1 +2630,0 @@\n-      Label L_wordsTail, L_wordsLoop, L_wordsTailLoop;\n@@ -2644,1 +2643,0 @@\n-      Label L_qwordLoop, L_qwordsTail, L_qwordsTailLoop;\n@@ -2661,1 +2659,0 @@\n-      Label L_dwordLoop, L_dwordsTail, L_dwordsTailLoop;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1048,0 +1048,4 @@\n+  if (!UseAPX) {\n+    _features &= ~CPU_APX_F;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -665,2 +665,1 @@\n-  __ setb(Assembler::notEqual, dst);\n-  __ movzbl(dst, dst);\n+  __ setcc(Assembler::notEqual, dst);\n@@ -7111,2 +7110,1 @@\n-            \"sete    $res\\n\\t\"\n-            \"movzbl  $res, $res\" %}\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n@@ -7116,2 +7114,1 @@\n-    __ setb(Assembler::equal, $res$$Register);\n-    __ movzbl($res$$Register, $res$$Register);\n+    __ setcc(Assembler::equal, $res$$Register);\n@@ -7133,2 +7130,1 @@\n-            \"sete    $res\\n\\t\"\n-            \"movzbl  $res, $res\" %}\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n@@ -7138,2 +7134,1 @@\n-    __ setb(Assembler::equal, $res$$Register);\n-    __ movzbl($res$$Register, $res$$Register);\n+    __ setcc(Assembler::equal, $res$$Register);\n@@ -7155,2 +7150,1 @@\n-            \"sete    $res\\n\\t\"\n-            \"movzbl  $res, $res\" %}\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n@@ -7160,2 +7154,1 @@\n-    __ setb(Assembler::equal, $res$$Register);\n-    __ movzbl($res$$Register, $res$$Register);\n+    __ setcc(Assembler::equal, $res$$Register);\n@@ -7177,2 +7170,1 @@\n-            \"sete    $res\\n\\t\"\n-            \"movzbl  $res, $res\" %}\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n@@ -7182,2 +7174,1 @@\n-    __ setb(Assembler::equal, $res$$Register);\n-    __ movzbl($res$$Register, $res$$Register);\n+    __ setcc(Assembler::equal, $res$$Register);\n@@ -7199,2 +7190,1 @@\n-            \"sete    $res\\n\\t\"\n-            \"movzbl  $res, $res\" %}\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n@@ -7204,2 +7194,1 @@\n-    __ setb(Assembler::equal, $res$$Register);\n-    __ movzbl($res$$Register, $res$$Register);\n+    __ setcc(Assembler::equal, $res$$Register);\n@@ -7220,2 +7209,1 @@\n-            \"sete    $res\\n\\t\"\n-            \"movzbl  $res, $res\" %}\n+            \"setcc $res \\t# emits sete + movzbl or setzue for APX\" %}\n@@ -7225,2 +7213,1 @@\n-    __ setb(Assembler::equal, $res$$Register);\n-    __ movzbl($res$$Register, $res$$Register);\n+    __ setcc(Assembler::equal, $res$$Register);\n@@ -9770,2 +9757,1 @@\n-            \"setlt   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\\t\"\n+            \"setcc   $dst \\t# emits setlt + movzbl or setzul for APX\"\n@@ -9775,2 +9761,1 @@\n-    __ setb(Assembler::less, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ setcc(Assembler::less, $dst$$Register);\n@@ -12114,2 +12099,1 @@\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\\t\"\n+            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n@@ -12122,2 +12106,1 @@\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ setcc(Assembler::notZero, $dst$$Register);\n@@ -12140,2 +12123,1 @@\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\\t\"\n+            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n@@ -12148,2 +12130,1 @@\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ setcc(Assembler::notZero, $dst$$Register);\n@@ -12166,2 +12147,1 @@\n-            \"setne   $dst\\n\\t\"\n-            \"movzbl  $dst, $dst\\n\\t\"\n+            \"setcc   $dst \\t# emits setne + movzbl or setzune for APX\"\n@@ -12174,2 +12154,1 @@\n-    __ setb(Assembler::notZero, $dst$$Register);\n-    __ movzbl($dst$$Register, $dst$$Register);\n+    __ setcc(Assembler::notZero, $dst$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":21,"deletions":42,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,1 +344,1 @@\n-  Runtime1::StubID _stub_id;\n+  C1StubId         _stub_id;\n@@ -347,1 +347,1 @@\n-  NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, Runtime1::StubID stub_id);\n+  NewInstanceStub(LIR_Opr klass_reg, LIR_Opr result, ciInstanceKlass* klass, CodeEmitInfo* info, C1StubId stub_id);\n@@ -606,1 +606,1 @@\n-  Runtime1::StubID _stub;\n+  C1StubId         _stub;\n@@ -610,1 +610,1 @@\n-  SimpleExceptionStub(Runtime1::StubID stub, LIR_Opr obj, CodeEmitInfo* info):\n+  SimpleExceptionStub(C1StubId stub, LIR_Opr obj, CodeEmitInfo* info):\n@@ -637,1 +637,1 @@\n-  ArrayStoreExceptionStub(LIR_Opr obj, CodeEmitInfo* info): SimpleExceptionStub(Runtime1::throw_array_store_exception_id, obj, info) {}\n+  ArrayStoreExceptionStub(LIR_Opr obj, CodeEmitInfo* info): SimpleExceptionStub(C1StubId::throw_array_store_exception_id, obj, info) {}\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,2 +277,0 @@\n-\n-    _max_spills = allocator->max_spills();\n@@ -571,1 +569,0 @@\n-, _max_spills(-1)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,0 @@\n-  int                _max_spills;\n@@ -156,1 +155,0 @@\n-  int max_spills() const                         { return _max_spills; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-    Runtime1::StubID stub_id = klass->is_initialized() ? Runtime1::fast_new_instance_id : Runtime1::fast_new_instance_init_check_id;\n+    C1StubId stub_id = klass->is_initialized() ? C1StubId::fast_new_instance_id : C1StubId::fast_new_instance_init_check_id;\n@@ -683,1 +683,1 @@\n-    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, Runtime1::new_instance_id);\n+    CodeStub* slow_path = new NewInstanceStub(klass_reg, dst, klass, info, C1StubId::new_instance_id);\n@@ -1517,1 +1517,1 @@\n-               CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::register_finalizer_id)),\n+               CAST_FROM_FN_PTR(address, Runtime1::entry_for(C1StubId::register_finalizer_id)),\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,3 @@\n-CodeBlob* Runtime1::_blobs[Runtime1::number_of_ids];\n+CodeBlob* Runtime1::_blobs[(int)C1StubId::NUM_STUBIDS];\n+\n+#define C1_BLOB_NAME_DEFINE(name)  \"C1 Runtime \" # name \"_blob\",\n@@ -116,1 +118,1 @@\n-  RUNTIME1_STUBS(STUB_NAME, LAST_STUB_NAME)\n+  C1_STUBS_DO(C1_BLOB_NAME_DEFINE)\n@@ -118,0 +120,1 @@\n+#undef C1_STUB_NAME_DEFINE\n@@ -203,1 +206,1 @@\n-class StubIDStubAssemblerCodeGenClosure: public StubAssemblerCodeGenClosure {\n+class C1StubIdStubAssemblerCodeGenClosure: public StubAssemblerCodeGenClosure {\n@@ -205,1 +208,1 @@\n-  Runtime1::StubID _id;\n+  C1StubId _id;\n@@ -207,1 +210,1 @@\n-  StubIDStubAssemblerCodeGenClosure(Runtime1::StubID id) : _id(id) {}\n+  C1StubIdStubAssemblerCodeGenClosure(C1StubId id) : _id(id) {}\n@@ -213,1 +216,1 @@\n-CodeBlob* Runtime1::generate_blob(BufferBlob* buffer_blob, int stub_id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure* cl) {\n+CodeBlob* Runtime1::generate_blob(BufferBlob* buffer_blob, C1StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure* cl) {\n@@ -225,1 +228,1 @@\n-  StubAssembler* sasm = new StubAssembler(&code, name, stub_id);\n+  StubAssembler* sasm = new StubAssembler(&code, name, (int)id);\n@@ -250,2 +253,2 @@\n-void Runtime1::generate_blob_for(BufferBlob* buffer_blob, StubID id) {\n-  assert(0 <= id && id < number_of_ids, \"illegal stub id\");\n+void Runtime1::generate_blob_for(BufferBlob* buffer_blob, C1StubId id) {\n+  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n@@ -257,5 +260,5 @@\n-  case dtrace_object_alloc_id:\n-  case slow_subtype_check_id:\n-  case fpu2long_stub_id:\n-  case unwind_exception_id:\n-  case counter_overflow_id:\n+  case C1StubId::dtrace_object_alloc_id:\n+  case C1StubId::slow_subtype_check_id:\n+  case C1StubId::fpu2long_stub_id:\n+  case C1StubId::unwind_exception_id:\n+  case C1StubId::counter_overflow_id:\n@@ -268,1 +271,1 @@\n-  StubIDStubAssemblerCodeGenClosure cl(id);\n+  C1StubIdStubAssemblerCodeGenClosure cl(id);\n@@ -271,1 +274,1 @@\n-  _blobs[id] = blob;\n+  _blobs[(int)id] = blob;\n@@ -278,1 +281,2 @@\n-  for (int id = 0; id < number_of_ids; id++) generate_blob_for(blob, (StubID)id);\n+  int limit = (int)C1StubId::NUM_STUBIDS;\n+  for (int id = 0; id < limit; id++) generate_blob_for(blob, (C1StubId)id);\n@@ -283,1 +287,1 @@\n-    for (int id = 0; id < number_of_ids; id++) {\n+    for (int id = 0; id < limit; id++) {\n@@ -295,3 +299,3 @@\n-CodeBlob* Runtime1::blob_for(StubID id) {\n-  assert(0 <= id && id < number_of_ids, \"illegal stub id\");\n-  return _blobs[id];\n+CodeBlob* Runtime1::blob_for(C1StubId id) {\n+  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n+  return _blobs[(int)id];\n@@ -301,3 +305,3 @@\n-const char* Runtime1::name_for(StubID id) {\n-  assert(0 <= id && id < number_of_ids, \"illegal stub id\");\n-  return _blob_names[id];\n+const char* Runtime1::name_for(C1StubId id) {\n+  assert(C1StubId::NO_STUBID < id && id < C1StubId::NUM_STUBIDS, \"illegal stub id\");\n+  return _blob_names[(int)id];\n@@ -307,2 +311,4 @@\n-  for (int id = 0; id < number_of_ids; id++) {\n-    if (entry == entry_for((StubID)id)) return name_for((StubID)id);\n+  int limit = (int)C1StubId::NUM_STUBIDS;\n+  for (int i = 0; i < limit; i++) {\n+    C1StubId id = (C1StubId)i;\n+    if (entry == entry_for(id)) return name_for(id);\n@@ -560,2 +566,2 @@\n-JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, StubID id))\n-  tty->print_cr(\"Runtime1::entry_for(%d) returned unimplemented entry point\", id);\n+JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* current, C1StubId id))\n+  tty->print_cr(\"Runtime1::entry_for(%d) returned unimplemented entry point\", (int)id);\n@@ -660,2 +666,2 @@\n-  if (current->last_frame().cb() == Runtime1::blob_for(Runtime1::handle_exception_from_callee_id)) {\n-    \/\/ The Runtime1::handle_exception_from_callee_id handler is invoked after the\n+  if (current->last_frame().cb() == Runtime1::blob_for(C1StubId::handle_exception_from_callee_id)) {\n+    \/\/ The C1StubId::handle_exception_from_callee_id handler is invoked after the\n@@ -1070,1 +1076,1 @@\n-JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, Runtime1::StubID stub_id ))\n+JRT_ENTRY(void, Runtime1::patch_code(JavaThread* current, C1StubId stub_id ))\n@@ -1109,1 +1115,1 @@\n-    (stub_id == Runtime1::load_klass_patching_id || stub_id == Runtime1::load_mirror_patching_id);\n+    (stub_id == C1StubId::load_klass_patching_id || stub_id == C1StubId::load_mirror_patching_id);\n@@ -1111,1 +1117,1 @@\n-  if (stub_id == Runtime1::access_field_patching_id) {\n+  if (stub_id == C1StubId::access_field_patching_id) {\n@@ -1204,1 +1210,1 @@\n-  } else if (stub_id == load_appendix_patching_id) {\n+  } else if (stub_id == C1StubId::load_appendix_patching_id) {\n@@ -1294,1 +1300,1 @@\n-                        p2i(instr_pc), (stub_id == Runtime1::access_field_patching_id) ? \"field\" : \"klass\");\n+                        p2i(instr_pc), (stub_id == C1StubId::access_field_patching_id) ? \"field\" : \"klass\");\n@@ -1310,1 +1316,1 @@\n-        if (stub_id == Runtime1::access_field_patching_id) {\n+        if (stub_id == C1StubId::access_field_patching_id) {\n@@ -1336,1 +1342,1 @@\n-            if (stub_id == Runtime1::load_klass_patching_id) {\n+            if (stub_id == C1StubId::load_klass_patching_id) {\n@@ -1348,1 +1354,1 @@\n-        } else if (stub_id == Runtime1::load_appendix_patching_id) {\n+        } else if (stub_id == C1StubId::load_appendix_patching_id) {\n@@ -1367,1 +1373,1 @@\n-              stub_id == Runtime1::load_appendix_patching_id) &&\n+              stub_id == C1StubId::load_appendix_patching_id) &&\n@@ -1375,2 +1381,2 @@\n-                assert(stub_id == Runtime1::load_mirror_patching_id ||\n-                       stub_id == Runtime1::load_appendix_patching_id, \"wrong stub id\");\n+                assert(stub_id == C1StubId::load_mirror_patching_id ||\n+                       stub_id == C1StubId::load_appendix_patching_id, \"wrong stub id\");\n@@ -1381,1 +1387,1 @@\n-                assert(stub_id == Runtime1::load_klass_patching_id, \"wrong stub id\");\n+                assert(stub_id == C1StubId::load_klass_patching_id, \"wrong stub id\");\n@@ -1404,1 +1410,1 @@\n-              stub_id == Runtime1::load_appendix_patching_id) {\n+              stub_id == C1StubId::load_appendix_patching_id) {\n@@ -1406,1 +1412,1 @@\n-              (stub_id == Runtime1::load_klass_patching_id) ?\n+              (stub_id == C1StubId::load_klass_patching_id) ?\n@@ -1444,3 +1450,3 @@\n-static bool is_patching_needed(JavaThread* current, Runtime1::StubID stub_id) {\n-  if (stub_id == Runtime1::load_klass_patching_id ||\n-      stub_id == Runtime1::load_mirror_patching_id) {\n+static bool is_patching_needed(JavaThread* current, C1StubId stub_id) {\n+  if (stub_id == C1StubId::load_klass_patching_id ||\n+      stub_id == C1StubId::load_mirror_patching_id) {\n@@ -1475,1 +1481,1 @@\n-void Runtime1::patch_code(JavaThread* current, Runtime1::StubID stub_id) {\n+void Runtime1::patch_code(JavaThread* current, C1StubId stub_id) {\n@@ -1530,1 +1536,1 @@\n-    patch_code(current, load_klass_patching_id);\n+    patch_code(current, C1StubId::load_klass_patching_id);\n@@ -1547,1 +1553,1 @@\n-    patch_code(current, load_mirror_patching_id);\n+    patch_code(current, C1StubId::load_mirror_patching_id);\n@@ -1564,1 +1570,1 @@\n-    patch_code(current, load_appendix_patching_id);\n+    patch_code(current, C1StubId::load_appendix_patching_id);\n@@ -1591,1 +1597,1 @@\n-    patch_code(current, access_field_patching_id);\n+    patch_code(current, C1StubId::access_field_patching_id);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":59,"deletions":53,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"runtime\/stubDeclarations.hpp\"\n@@ -40,49 +41,0 @@\n-#define RUNTIME1_STUBS(stub, last_entry) \\\n-  stub(dtrace_object_alloc)          \\\n-  stub(unwind_exception)             \\\n-  stub(forward_exception)            \\\n-  stub(throw_range_check_failed)       \/* throws ArrayIndexOutOfBoundsException *\/ \\\n-  stub(throw_index_exception)          \/* throws IndexOutOfBoundsException *\/ \\\n-  stub(throw_div0_exception)         \\\n-  stub(throw_null_pointer_exception) \\\n-  stub(register_finalizer)           \\\n-  stub(new_instance)                 \\\n-  stub(fast_new_instance)            \\\n-  stub(fast_new_instance_init_check) \\\n-  stub(new_type_array)               \\\n-  stub(new_object_array)             \\\n-  stub(new_null_free_array)          \\\n-  stub(new_multi_array)              \\\n-  stub(load_flat_array)              \\\n-  stub(store_flat_array)             \\\n-  stub(substitutability_check)       \\\n-  stub(buffer_inline_args)           \\\n-  stub(buffer_inline_args_no_receiver)\\\n-  stub(handle_exception_nofpu)         \/* optimized version that does not preserve fpu registers *\/ \\\n-  stub(handle_exception)             \\\n-  stub(handle_exception_from_callee) \\\n-  stub(throw_array_store_exception)  \\\n-  stub(throw_class_cast_exception)   \\\n-  stub(throw_incompatible_class_change_error)   \\\n-  stub(throw_illegal_monitor_state_exception)   \\\n-  stub(throw_identity_exception)     \\\n-  stub(slow_subtype_check)           \\\n-  stub(monitorenter)                 \\\n-  stub(monitorenter_nofpu)             \/* optimized version that does not preserve fpu registers *\/ \\\n-  stub(monitorexit)                  \\\n-  stub(monitorexit_nofpu)              \/* optimized version that does not preserve fpu registers *\/ \\\n-  stub(deoptimize)                   \\\n-  stub(access_field_patching)        \\\n-  stub(load_klass_patching)          \\\n-  stub(load_mirror_patching)         \\\n-  stub(load_appendix_patching)       \\\n-  stub(fpu2long_stub)                \\\n-  stub(counter_overflow)             \\\n-  stub(predicate_failed_trap)        \\\n-  last_entry(number_of_ids)\n-\n-#define DECLARE_STUB_ID(x)       x ## _id ,\n-#define DECLARE_LAST_STUB_ID(x)  x\n-#define STUB_NAME(x)             #x \" Runtime1 stub\",\n-#define LAST_STUB_NAME(x)        #x \" Runtime1 stub\"\n-\n@@ -94,0 +46,10 @@\n+\/\/ define C1StubId enum tags: unwind_exception_id etc\n+\n+#define C1_STUB_ID_ENUM_DECLARE(name) STUB_ID_NAME(name),\n+enum class C1StubId :int {\n+  NO_STUBID = -1,\n+  C1_STUBS_DO(C1_STUB_ID_ENUM_DECLARE)\n+  NUM_STUBIDS\n+};\n+#undef C1_STUB_ID_ENUM_DECLARE\n+\n@@ -98,5 +60,1 @@\n- public:\n-  enum StubID {\n-    RUNTIME1_STUBS(DECLARE_STUB_ID, DECLARE_LAST_STUB_ID)\n-  };\n-\n+public:\n@@ -134,1 +92,1 @@\n-  static CodeBlob* _blobs[number_of_ids];\n+  static CodeBlob* _blobs[(int)C1StubId::NUM_STUBIDS];\n@@ -140,3 +98,3 @@\n-  static CodeBlob*  generate_blob(BufferBlob* buffer_blob, int stub_id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure *cl);\n-  static void       generate_blob_for(BufferBlob* blob, StubID id);\n-  static OopMapSet* generate_code_for(StubID id, StubAssembler* sasm);\n+  static CodeBlob*  generate_blob(BufferBlob* buffer_blob, C1StubId id, const char* name, bool expect_oop_map, StubAssemblerCodeGenClosure *cl);\n+  static void       generate_blob_for(BufferBlob* blob, C1StubId id);\n+  static OopMapSet* generate_code_for(C1StubId id, StubAssembler* sasm);\n@@ -145,1 +103,1 @@\n-  static OopMapSet* generate_handle_exception(StubID id, StubAssembler* sasm);\n+  static OopMapSet* generate_handle_exception(C1StubId id, StubAssembler* sasm);\n@@ -167,1 +125,1 @@\n-  static void unimplemented_entry(JavaThread* current, StubID id);\n+  static void unimplemented_entry(JavaThread* current, C1StubId id);\n@@ -191,1 +149,1 @@\n-  static void patch_code(JavaThread* current, StubID stub_id);\n+  static void patch_code(JavaThread* current, C1StubId stub_id);\n@@ -199,3 +157,3 @@\n-  static CodeBlob* blob_for (StubID id);\n-  static address   entry_for(StubID id)          { return blob_for(id)->code_begin(); }\n-  static const char* name_for (StubID id);\n+  static CodeBlob* blob_for (C1StubId id);\n+  static address   entry_for(C1StubId id)          { return blob_for(id)->code_begin(); }\n+  static const char* name_for (C1StubId id);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":23,"deletions":65,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-size_t ArchiveHeapWriter::_heap_roots_offset;\n-size_t ArchiveHeapWriter::_heap_roots_word_size;\n+\/\/ Heap root segments\n+HeapRootSegments ArchiveHeapWriter::_heap_root_segments;\n@@ -167,4 +167,0 @@\n-oop ArchiveHeapWriter::heap_roots_requested_address() {\n-  return cast_to_oop(_requested_bottom + _heap_roots_offset);\n-}\n-\n@@ -189,9 +185,3 @@\n-void ArchiveHeapWriter::copy_roots_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n-  Klass* k = Universe::objectArrayKlass(); \/\/ already relocated to point to archived klass\n-  int length = roots->length();\n-  _heap_roots_word_size = objArrayOopDesc::object_size(length);\n-  size_t byte_size = _heap_roots_word_size * HeapWordSize;\n-  if (byte_size >= MIN_GC_REGION_ALIGNMENT) {\n-    log_error(cds, heap)(\"roots array is too large. Please reduce the number of classes\");\n-    vm_exit(1);\n-  }\n+objArrayOop ArchiveHeapWriter::allocate_root_segment(size_t offset, int element_count) {\n+  HeapWord* mem = offset_to_buffered_address<HeapWord *>(offset);\n+  memset(mem, 0, objArrayOopDesc::object_size(element_count));\n@@ -199,4 +189,6 @@\n-  maybe_fill_gc_region_gap(byte_size);\n-\n-  size_t new_used = _buffer_used + byte_size;\n-  ensure_buffer_space(new_used);\n+  \/\/ The initialization code is copied from MemAllocator::finish and ObjArrayAllocator::initialize.\n+  oopDesc::set_mark(mem, markWord::prototype());\n+  oopDesc::release_set_klass(mem, Universe::objectArrayKlass());\n+  arrayOopDesc::set_length(mem, element_count);\n+  return objArrayOop(cast_to_oop(mem));\n+}\n@@ -204,10 +196,6 @@\n-  HeapWord* mem = offset_to_buffered_address<HeapWord*>(_buffer_used);\n-  memset(mem, 0, byte_size);\n-  {\n-    \/\/ This is copied from MemAllocator::finish\n-    oopDesc::set_mark(mem, markWord::prototype());\n-    oopDesc::release_set_klass(mem, k);\n-  }\n-  {\n-    \/\/ This is copied from ObjArrayAllocator::initialize\n-    arrayOopDesc::set_length(mem, length);\n+void ArchiveHeapWriter::root_segment_at_put(objArrayOop segment, int index, oop root) {\n+  \/\/ Do not use arrayOop->obj_at_put(i, o) as arrayOop is outside the real heap!\n+  if (UseCompressedOops) {\n+    *segment->obj_at_addr<narrowOop>(index) = CompressedOops::encode(root);\n+  } else {\n+    *segment->obj_at_addr<oop>(index) = root;\n@@ -215,0 +203,1 @@\n+}\n@@ -216,8 +205,38 @@\n-  objArrayOop arrayOop = objArrayOop(cast_to_oop(mem));\n-  for (int i = 0; i < length; i++) {\n-    \/\/ Do not use arrayOop->obj_at_put(i, o) as arrayOop is outside of the real heap!\n-    oop o = roots->at(i);\n-    if (UseCompressedOops) {\n-      * arrayOop->obj_at_addr<narrowOop>(i) = CompressedOops::encode(o);\n-    } else {\n-      * arrayOop->obj_at_addr<oop>(i) = o;\n+void ArchiveHeapWriter::copy_roots_to_buffer(GrowableArrayCHeap<oop, mtClassShared>* roots) {\n+  \/\/ Depending on the number of classes we are archiving, a single roots array may be\n+  \/\/ larger than MIN_GC_REGION_ALIGNMENT. Roots are allocated first in the buffer, which\n+  \/\/ allows us to chop the large array into a series of \"segments\". Current layout\n+  \/\/ starts with zero or more segments exactly fitting MIN_GC_REGION_ALIGNMENT, and end\n+  \/\/ with a single segment that may be smaller than MIN_GC_REGION_ALIGNMENT.\n+  \/\/ This is simple and efficient. We do not need filler objects anywhere between the segments,\n+  \/\/ or immediately after the last segment. This allows starting the object dump immediately\n+  \/\/ after the roots.\n+\n+  assert((_buffer_used % MIN_GC_REGION_ALIGNMENT) == 0,\n+         \"Pre-condition: Roots start at aligned boundary: \" SIZE_FORMAT, _buffer_used);\n+\n+  int max_elem_count = ((MIN_GC_REGION_ALIGNMENT - arrayOopDesc::header_size_in_bytes()) \/ heapOopSize);\n+  assert(objArrayOopDesc::object_size(max_elem_count)*HeapWordSize == MIN_GC_REGION_ALIGNMENT,\n+         \"Should match exactly\");\n+\n+  HeapRootSegments segments(_buffer_used,\n+                            roots->length(),\n+                            MIN_GC_REGION_ALIGNMENT,\n+                            max_elem_count);\n+\n+  for (size_t seg_idx = 0; seg_idx < segments.count(); seg_idx++) {\n+    int size_elems = segments.size_in_elems(seg_idx);\n+    size_t size_bytes = segments.size_in_bytes(seg_idx);\n+\n+    size_t oop_offset = _buffer_used;\n+    _buffer_used = oop_offset + size_bytes;\n+    ensure_buffer_space(_buffer_used);\n+\n+    assert((oop_offset % MIN_GC_REGION_ALIGNMENT) == 0,\n+           \"Roots segment \" SIZE_FORMAT \" start is not aligned: \" SIZE_FORMAT,\n+           segments.count(), oop_offset);\n+\n+    int root_index = 0;\n+    objArrayOop seg_oop = allocate_root_segment(oop_offset, size_elems);\n+    for (int i = 0; i < size_elems; i++) {\n+      root_segment_at_put(seg_oop, i, roots->at(root_index++));\n@@ -225,0 +244,3 @@\n+\n+    log_info(cds, heap)(\"archived obj root segment [%d] = \" SIZE_FORMAT \" bytes, obj = \" PTR_FORMAT,\n+                        size_elems, size_bytes, p2i(seg_oop));\n@@ -226,3 +248,1 @@\n-  log_info(cds, heap)(\"archived obj roots[%d] = \" SIZE_FORMAT \" bytes, klass = %p, obj = %p\", length, byte_size, k, mem);\n-  _heap_roots_offset = _buffer_used;\n-  _buffer_used = new_used;\n+  _heap_root_segments = segments;\n@@ -285,0 +305,4 @@\n+  \/\/ There could be multiple root segments, which we want to be aligned by region.\n+  \/\/ Putting them ahead of objects makes sure we waste no space.\n+  copy_roots_to_buffer(roots);\n+\n@@ -298,2 +322,0 @@\n-  copy_roots_to_buffer(roots);\n-\n@@ -458,1 +480,1 @@\n-  info->set_heap_roots_offset(_heap_roots_offset);\n+  info->set_heap_root_segments(_heap_root_segments);\n@@ -546,6 +568,0 @@\n-\/\/ Relocate an element in the buffered copy of HeapShared::roots()\n-template <typename T> void ArchiveHeapWriter::relocate_root_at(oop requested_roots, int index, CHeapBitMap* oopmap) {\n-  size_t offset = (size_t)((objArrayOop)requested_roots)->obj_at_offset<T>(index);\n-  relocate_field_in_buffer<T>((T*)(buffered_heap_roots_addr() + offset), oopmap);\n-}\n-\n@@ -603,4 +619,8 @@\n-  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_offset);\n-  update_header_for_requested_obj(requested_roots, nullptr, Universe::objectArrayKlass());\n-  int length = roots != nullptr ? roots->length() : 0;\n-  for (int i = 0; i < length; i++) {\n+  for (size_t seg_idx = 0; seg_idx < _heap_root_segments.count(); seg_idx++) {\n+    size_t seg_offset = _heap_root_segments.segment_offset(seg_idx);\n+\n+    objArrayOop requested_obj = (objArrayOop)requested_obj_from_buffer_offset(seg_offset);\n+    update_header_for_requested_obj(requested_obj, nullptr, Universe::objectArrayKlass());\n+    address buffered_obj = offset_to_buffered_address<address>(seg_offset);\n+    int length = _heap_root_segments.size_in_elems(seg_idx);\n+\n@@ -608,1 +628,4 @@\n-      relocate_root_at<narrowOop>(requested_roots, i, heap_info->oopmap());\n+      for (int i = 0; i < length; i++) {\n+        narrowOop* addr = (narrowOop*)(buffered_obj + objArrayOopDesc::obj_at_offset<narrowOop>(i));\n+        relocate_field_in_buffer<narrowOop>(addr, heap_info->oopmap());\n+      }\n@@ -610,1 +633,4 @@\n-      relocate_root_at<oop>(requested_roots, i, heap_info->oopmap());\n+      for (int i = 0; i < length; i++) {\n+        oop* addr = (oop*)(buffered_obj + objArrayOopDesc::obj_at_offset<oop>(i));\n+        relocate_field_in_buffer<oop>(addr, heap_info->oopmap());\n+      }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":81,"deletions":55,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -358,1 +358,5 @@\n-  st->print_cr(\"- heap_roots_offset:              \" SIZE_FORMAT, _heap_roots_offset);\n+  st->print_cr(\"- heap_root_segments.roots_count: %d\" , _heap_root_segments.roots_count());\n+  st->print_cr(\"- heap_root_segments.base_offset: \" SIZE_FORMAT_X, _heap_root_segments.base_offset());\n+  st->print_cr(\"- heap_root_segments.count:       \" SIZE_FORMAT, _heap_root_segments.count());\n+  st->print_cr(\"- heap_root_segments.max_size_elems: %d\", _heap_root_segments.max_size_in_elems());\n+  st->print_cr(\"- heap_root_segments.max_size_bytes: %d\", _heap_root_segments.max_size_in_bytes());\n@@ -1722,1 +1726,1 @@\n-  header()->set_heap_roots_offset(heap_info->heap_roots_offset());\n+  header()->set_heap_root_segments(heap_info->heap_root_segments());\n@@ -1787,1 +1791,1 @@\n-                        bool allow_exec, MEMFLAGS flags = mtNone) {\n+                        bool allow_exec, MemTag mem_tag = mtNone) {\n@@ -1790,1 +1794,1 @@\n-                             allow_exec, flags);\n+                             allow_exec, mem_tag);\n@@ -2249,1 +2253,1 @@\n-  \/\/ Map the archived heap data. No need to call MemTracker::record_virtual_memory_type()\n+  \/\/ Map the archived heap data. No need to call MemTracker::record_virtual_memory_tag()\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/archiveUtils.hpp\"\n@@ -261,2 +262,1 @@\n-  size_t _heap_roots_offset;            \/\/ Offset of the HeapShared::roots() object, from the bottom\n-                                        \/\/ of the archived heap objects, in bytes.\n+  HeapRootSegments _heap_root_segments; \/\/ Heap root segments info\n@@ -306,1 +306,1 @@\n-  size_t heap_roots_offset()               const { return _heap_roots_offset; }\n+  HeapRootSegments heap_root_segments()    const { return _heap_root_segments; }\n@@ -321,1 +321,1 @@\n-  void set_heap_roots_offset(size_t n)           { _heap_roots_offset = n; }\n+  void set_heap_root_segments(HeapRootSegments segments) { _heap_root_segments = segments; }\n@@ -425,1 +425,1 @@\n-  size_t  heap_roots_offset()  const { return header()->heap_roots_offset(); }\n+  HeapRootSegments heap_root_segments() const { return header()->heap_root_segments(); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -136,1 +136,3 @@\n-OopHandle HeapShared::_roots;\n+GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments;\n+int HeapShared::_root_segment_max_size_shift;\n+int HeapShared::_root_segment_max_size_mask;\n@@ -228,1 +230,1 @@\n-objArrayOop HeapShared::roots() {\n+objArrayOop HeapShared::root_segment(int segment_idx) {\n@@ -238,3 +240,3 @@\n-  objArrayOop roots = (objArrayOop)_roots.resolve();\n-  assert(roots != nullptr, \"should have been initialized\");\n-  return roots;\n+  objArrayOop segment = (objArrayOop)_root_segments->at(segment_idx).resolve();\n+  assert(segment != nullptr, \"should have been initialized\");\n+  return segment;\n@@ -245,0 +247,2 @@\n+  assert(_root_segment_max_size_shift > 0, \"sanity\");\n+  assert(_root_segment_max_size_mask  > 0, \"sanity\");\n@@ -247,2 +251,4 @@\n-  assert(!_roots.is_empty(), \"must have loaded shared heap\");\n-  oop result = roots()->obj_at(index);\n+  assert(!_root_segments->is_empty(), \"must have loaded shared heap\");\n+  int seg_idx = index >> _root_segment_max_size_shift;\n+  int int_idx = index &  _root_segment_max_size_mask;\n+  oop result = root_segment(seg_idx)->obj_at(int_idx);\n@@ -259,0 +265,4 @@\n+    assert(_root_segment_max_size_shift > 0, \"sanity\");\n+    assert(_root_segment_max_size_mask  > 0, \"sanity\");\n+    int seg_idx = index >> _root_segment_max_size_shift;\n+    int int_idx = index &  _root_segment_max_size_mask;\n@@ -260,1 +270,1 @@\n-      oop old = roots()->obj_at(index);\n+      oop old = root_segment(seg_idx)->obj_at(int_idx);\n@@ -263,1 +273,1 @@\n-    roots()->obj_at_put(index, nullptr);\n+    root_segment(seg_idx)->obj_at_put(int_idx, nullptr);\n@@ -767,4 +777,5 @@\n-void HeapShared::init_roots(oop roots_oop) {\n-  if (roots_oop != nullptr) {\n-    assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n-    _roots = OopHandle(Universe::vm_global(), roots_oop);\n+void HeapShared::add_root_segment(objArrayOop segment_oop) {\n+  assert(segment_oop != nullptr, \"must be\");\n+  assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n+  if (_root_segments == nullptr) {\n+    _root_segments = new GrowableArrayCHeap<OopHandle, mtClassShared>(10);\n@@ -772,0 +783,7 @@\n+  _root_segments->push(OopHandle(Universe::vm_global(), segment_oop));\n+}\n+\n+void HeapShared::init_root_segment_sizes(int max_size) {\n+  assert(is_power_of_2(max_size), \"must be\");\n+  _root_segment_max_size_shift = log2i_exact(max_size);\n+  _root_segment_max_size_mask = max_size - 1;\n@@ -1307,0 +1325,3 @@\n+              name == vmSymbols::java_lang_ArrayIndexOutOfBoundsException() ||\n+              name == vmSymbols::java_lang_ArrayStoreException() ||\n+              name == vmSymbols::java_lang_ClassCastException() ||\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1308,1 +1308,1 @@\n-      MemTracker::record_virtual_memory_type(archive_space_rs.base(), mtClassShared);\n+      MemTracker::record_virtual_memory_tag(archive_space_rs.base(), mtClassShared);\n@@ -1370,2 +1370,2 @@\n-    MemTracker::record_virtual_memory_type(archive_space_rs.base(), mtClassShared);\n-    MemTracker::record_virtual_memory_type(class_space_rs.base(), mtClass);\n+    MemTracker::record_virtual_memory_tag(archive_space_rs.base(), mtClassShared);\n+    MemTracker::record_virtual_memory_tag(class_space_rs.base(), mtClass);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,4 +104,0 @@\n-jobject ciEnv::_ArrayIndexOutOfBoundsException_handle = nullptr;\n-jobject ciEnv::_ArrayStoreException_handle = nullptr;\n-jobject ciEnv::_ClassCastException_handle = nullptr;\n-\n@@ -162,0 +158,9 @@\n+  o = Universe::array_index_out_of_bounds_exception_instance();\n+  assert(o != nullptr, \"should have been initialized\");\n+  _ArrayIndexOutOfBoundsException_instance = get_object(o)->as_instance();\n+  o = Universe::array_store_exception_instance();\n+  assert(o != nullptr, \"should have been initialized\");\n+  _ArrayStoreException_instance = get_object(o)->as_instance();\n+  o = Universe::class_cast_exception_instance();\n+  assert(o != nullptr, \"should have been initialized\");\n+  _ClassCastException_instance = get_object(o)->as_instance();\n@@ -163,3 +168,0 @@\n-  _ArrayIndexOutOfBoundsException_instance = nullptr;\n-  _ArrayStoreException_instance = nullptr;\n-  _ClassCastException_instance = nullptr;\n@@ -367,23 +369,0 @@\n-\/\/ ------------------------------------------------------------------\n-\/\/ helper for lazy exception creation\n-ciInstance* ciEnv::get_or_create_exception(jobject& handle, Symbol* name) {\n-  VM_ENTRY_MARK;\n-  if (handle == nullptr) {\n-    \/\/ Cf. universe.cpp, creation of Universe::_null_ptr_exception_instance.\n-    InstanceKlass* ik = SystemDictionary::find_instance_klass(THREAD, name, Handle(), Handle());\n-    jobject objh = nullptr;\n-    if (ik != nullptr) {\n-      oop obj = ik->allocate_instance(THREAD);\n-      if (!HAS_PENDING_EXCEPTION)\n-        objh = JNIHandles::make_global(Handle(THREAD, obj));\n-    }\n-    if (HAS_PENDING_EXCEPTION) {\n-      CLEAR_PENDING_EXCEPTION;\n-    } else {\n-      handle = objh;\n-    }\n-  }\n-  oop obj = JNIHandles::resolve(handle);\n-  return obj == nullptr? nullptr: get_object(obj)->as_instance();\n-}\n-\n@@ -407,25 +386,0 @@\n-ciInstance* ciEnv::ArrayIndexOutOfBoundsException_instance() {\n-  if (_ArrayIndexOutOfBoundsException_instance == nullptr) {\n-    _ArrayIndexOutOfBoundsException_instance\n-          = get_or_create_exception(_ArrayIndexOutOfBoundsException_handle,\n-          vmSymbols::java_lang_ArrayIndexOutOfBoundsException());\n-  }\n-  return _ArrayIndexOutOfBoundsException_instance;\n-}\n-ciInstance* ciEnv::ArrayStoreException_instance() {\n-  if (_ArrayStoreException_instance == nullptr) {\n-    _ArrayStoreException_instance\n-          = get_or_create_exception(_ArrayStoreException_handle,\n-          vmSymbols::java_lang_ArrayStoreException());\n-  }\n-  return _ArrayStoreException_instance;\n-}\n-ciInstance* ciEnv::ClassCastException_instance() {\n-  if (_ClassCastException_instance == nullptr) {\n-    _ClassCastException_instance\n-          = get_or_create_exception(_ClassCastException_handle,\n-          vmSymbols::java_lang_ClassCastException());\n-  }\n-  return _ClassCastException_instance;\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":55,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -97,4 +97,0 @@\n-  static jobject _ArrayIndexOutOfBoundsException_handle;\n-  static jobject _ArrayStoreException_handle;\n-  static jobject _ClassCastException_handle;\n-\n@@ -237,2 +233,0 @@\n-  ciInstance* get_or_create_exception(jobject& handle, Symbol* name);\n-\n@@ -409,5 +403,12 @@\n-\n-  \/\/ Lazy constructors:\n-  ciInstance* ArrayIndexOutOfBoundsException_instance();\n-  ciInstance* ArrayStoreException_instance();\n-  ciInstance* ClassCastException_instance();\n+  ciInstance* ArrayIndexOutOfBoundsException_instance() {\n+    assert(_ArrayIndexOutOfBoundsException_instance != nullptr, \"initialization problem\");\n+    return _ArrayIndexOutOfBoundsException_instance;\n+  }\n+  ciInstance* ArrayStoreException_instance() {\n+    assert(_ArrayStoreException_instance != nullptr, \"initialization problem\");\n+    return _ArrayStoreException_instance;\n+  }\n+  ciInstance* ClassCastException_instance() {\n+    assert(_ClassCastException_instance != nullptr, \"initialization problem\");\n+    return _ClassCastException_instance;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -120,0 +120,7 @@\n+  bool is_in_encoding_range() {\n+    Klass* k = get_Klass();\n+    bool is_in_encoding_range = CompressedKlassPointers::is_encodable(k);\n+    assert(is_in_encoding_range || k->is_interface() || k->is_abstract(), \"sanity\");\n+    return is_in_encoding_range;\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -837,1 +837,2 @@\n-      if (strcmp(e->name(), entry->name()) == 0) {\n+      if (strcmp(e->name(), entry->name()) == 0 &&\n+          e->from_class_path_attr() == entry->from_class_path_attr()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+#ifdef ASSERT\n@@ -252,1 +253,2 @@\n-    assert(omv.type() == OopMapValue::oop_value || omv.type() == OopMapValue::narrowoop_value || omv.type() == OopMapValue::derived_oop_value || omv.type() == OopMapValue::callee_saved_value, \"\");\n+    assert(omv.type() == OopMapValue::oop_value || omv.type() == OopMapValue::narrowoop_value ||\n+           omv.type() == OopMapValue::derived_oop_value || omv.type() == OopMapValue::callee_saved_value, \"\");\n@@ -254,0 +256,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-  MemTracker::record_virtual_memory_type((address)rs.base(), mtGC);\n+  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,1 +284,2 @@\n-         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom));\n+         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom)) ||\n+         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom_narrow));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"nmt\/memflags.hpp\"\n+#include \"nmt\/memTag.hpp\"\n@@ -97,3 +97,3 @@\n-\/\/ char* AllocateHeap(size_t size, MEMFLAGS flags, const NativeCallStack& stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-\/\/ char* AllocateHeap(size_t size, MEMFLAGS flags, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-\/\/ char* ReallocateHeap(char *old, size_t size, MEMFLAGS flag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+\/\/ char* AllocateHeap(size_t size, MemTag mem_tag, const NativeCallStack& stack, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+\/\/ char* AllocateHeap(size_t size, MemTag mem_tag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+\/\/ char* ReallocateHeap(char *old, size_t size, MemTag mem_tag, AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n@@ -109,1 +109,1 @@\n-                   MEMFLAGS flags,\n+                   MemTag mem_tag,\n@@ -113,1 +113,1 @@\n-                   MEMFLAGS flags,\n+                   MemTag mem_tag,\n@@ -118,1 +118,1 @@\n-                     MEMFLAGS flag,\n+                     MemTag mem_tag,\n@@ -126,2 +126,2 @@\n-  ALWAYSINLINE void* operator new(size_t size, MEMFLAGS f) {\n-    return AllocateHeap(size, f);\n+  ALWAYSINLINE void* operator new(size_t size, MemTag mem_tag) {\n+    return AllocateHeap(size, mem_tag);\n@@ -131,1 +131,1 @@\n-                                  MEMFLAGS f,\n+                                  MemTag mem_tag,\n@@ -133,1 +133,1 @@\n-    return AllocateHeap(size, f, stack);\n+    return AllocateHeap(size, mem_tag, stack);\n@@ -137,1 +137,1 @@\n-                                  MEMFLAGS f,\n+                                  MemTag mem_tag,\n@@ -140,1 +140,1 @@\n-    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, stack, AllocFailStrategy::RETURN_NULL);\n@@ -144,1 +144,1 @@\n-                                  MEMFLAGS f,\n+                                  MemTag mem_tag,\n@@ -146,1 +146,1 @@\n-    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, AllocFailStrategy::RETURN_NULL);\n@@ -149,2 +149,2 @@\n-  ALWAYSINLINE void* operator new[](size_t size, MEMFLAGS f) {\n-    return AllocateHeap(size, f);\n+  ALWAYSINLINE void* operator new[](size_t size, MemTag mem_tag) {\n+    return AllocateHeap(size, mem_tag);\n@@ -154,1 +154,1 @@\n-                                    MEMFLAGS f,\n+                                    MemTag mem_tag,\n@@ -156,1 +156,1 @@\n-    return AllocateHeap(size, f, stack);\n+    return AllocateHeap(size, mem_tag, stack);\n@@ -160,1 +160,1 @@\n-                                    MEMFLAGS f,\n+                                    MemTag mem_tag,\n@@ -163,1 +163,1 @@\n-    return AllocateHeap(size, f, stack, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, stack, AllocFailStrategy::RETURN_NULL);\n@@ -167,1 +167,1 @@\n-                                    MEMFLAGS f,\n+                                    MemTag mem_tag,\n@@ -169,1 +169,1 @@\n-    return AllocateHeap(size, f, AllocFailStrategy::RETURN_NULL);\n+    return AllocateHeap(size, mem_tag, AllocFailStrategy::RETURN_NULL);\n@@ -177,1 +177,1 @@\n-template<MEMFLAGS F>\n+template<MemTag MT>\n@@ -181,1 +181,1 @@\n-    return CHeapObjBase::operator new(size, F);\n+    return CHeapObjBase::operator new(size, MT);\n@@ -186,1 +186,1 @@\n-    return CHeapObjBase::operator new(size, F, stack);\n+    return CHeapObjBase::operator new(size, MT, stack);\n@@ -191,1 +191,1 @@\n-    return CHeapObjBase::operator new(size, F, nt, stack);\n+    return CHeapObjBase::operator new(size, MT, nt, stack);\n@@ -195,1 +195,1 @@\n-    return CHeapObjBase::operator new(size, F, nt);\n+    return CHeapObjBase::operator new(size, MT, nt);\n@@ -199,1 +199,1 @@\n-    return CHeapObjBase::operator new[](size, F);\n+    return CHeapObjBase::operator new[](size, MT);\n@@ -204,1 +204,1 @@\n-    return CHeapObjBase::operator new[](size, F, stack);\n+    return CHeapObjBase::operator new[](size, MT, stack);\n@@ -209,1 +209,1 @@\n-    return CHeapObjBase::operator new[](size, F, nt, stack);\n+    return CHeapObjBase::operator new[](size, MT, nt, stack);\n@@ -213,1 +213,1 @@\n-    return CHeapObjBase::operator new[](size, F, nt);\n+    return CHeapObjBase::operator new[](size, MT, nt);\n@@ -443,4 +443,4 @@\n-  void* operator new(size_t size, MEMFLAGS flags) throw();\n-  void* operator new [](size_t size, MEMFLAGS flags) throw() = delete;\n-  void* operator new(size_t size, const std::nothrow_t&  nothrow_constant, MEMFLAGS flags) throw();\n-  void* operator new [](size_t size, const std::nothrow_t&  nothrow_constant, MEMFLAGS flags) throw() = delete;\n+  void* operator new(size_t size, MemTag mem_tag) throw();\n+  void* operator new [](size_t size, MemTag mem_tag) throw() = delete;\n+  void* operator new(size_t size, const std::nothrow_t&  nothrow_constant, MemTag mem_tag) throw();\n+  void* operator new [](size_t size, const std::nothrow_t&  nothrow_constant, MemTag mem_tag) throw() = delete;\n@@ -514,2 +514,2 @@\n-#define NEW_C_HEAP_ARRAY3(type, size, memflags, pc, allocfail)\\\n-  (type*) AllocateHeap((size) * sizeof(type), memflags, pc, allocfail)\n+#define NEW_C_HEAP_ARRAY3(type, size, mem_tag, pc, allocfail)\\\n+  (type*) AllocateHeap((size) * sizeof(type), mem_tag, pc, allocfail)\n@@ -517,2 +517,2 @@\n-#define NEW_C_HEAP_ARRAY2(type, size, memflags, pc)\\\n-  (type*) (AllocateHeap((size) * sizeof(type), memflags, pc))\n+#define NEW_C_HEAP_ARRAY2(type, size, mem_tag, pc)\\\n+  (type*) (AllocateHeap((size) * sizeof(type), mem_tag, pc))\n@@ -520,2 +520,2 @@\n-#define NEW_C_HEAP_ARRAY(type, size, memflags)\\\n-  (type*) (AllocateHeap((size) * sizeof(type), memflags))\n+#define NEW_C_HEAP_ARRAY(type, size, mem_tag)\\\n+  (type*) (AllocateHeap((size) * sizeof(type), mem_tag))\n@@ -523,2 +523,2 @@\n-#define NEW_C_HEAP_ARRAY2_RETURN_NULL(type, size, memflags, pc)\\\n-  NEW_C_HEAP_ARRAY3(type, (size), memflags, pc, AllocFailStrategy::RETURN_NULL)\n+#define NEW_C_HEAP_ARRAY2_RETURN_NULL(type, size, mem_tag, pc)\\\n+  NEW_C_HEAP_ARRAY3(type, (size), mem_tag, pc, AllocFailStrategy::RETURN_NULL)\n@@ -526,2 +526,2 @@\n-#define NEW_C_HEAP_ARRAY_RETURN_NULL(type, size, memflags)\\\n-  NEW_C_HEAP_ARRAY2(type, (size), memflags, AllocFailStrategy::RETURN_NULL)\n+#define NEW_C_HEAP_ARRAY_RETURN_NULL(type, size, mem_tag)\\\n+  NEW_C_HEAP_ARRAY2(type, (size), mem_tag, AllocFailStrategy::RETURN_NULL)\n@@ -529,2 +529,2 @@\n-#define REALLOC_C_HEAP_ARRAY(type, old, size, memflags)\\\n-  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags))\n+#define REALLOC_C_HEAP_ARRAY(type, old, size, mem_tag)\\\n+  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), mem_tag))\n@@ -532,2 +532,2 @@\n-#define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, memflags)\\\n-  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), memflags, AllocFailStrategy::RETURN_NULL))\n+#define REALLOC_C_HEAP_ARRAY_RETURN_NULL(type, old, size, mem_tag)\\\n+  (type*) (ReallocateHeap((char*)(old), (size) * sizeof(type), mem_tag, AllocFailStrategy::RETURN_NULL))\n@@ -539,2 +539,2 @@\n-#define NEW_C_HEAP_OBJ(type, memflags)\\\n-  NEW_C_HEAP_ARRAY(type, 1, memflags)\n+#define NEW_C_HEAP_OBJ(type, mem_tag)\\\n+  NEW_C_HEAP_ARRAY(type, 1, mem_tag)\n@@ -542,2 +542,2 @@\n-#define NEW_C_HEAP_OBJ_RETURN_NULL(type, memflags)\\\n-  NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, memflags)\n+#define NEW_C_HEAP_OBJ_RETURN_NULL(type, mem_tag)\\\n+  NEW_C_HEAP_ARRAY_RETURN_NULL(type, 1, mem_tag)\n@@ -572,2 +572,2 @@\n-  static E* allocate_or_null(size_t length, MEMFLAGS flags);\n-  static E* allocate(size_t length, MEMFLAGS flags);\n+  static E* allocate_or_null(size_t length, MemTag mem_tag);\n+  static E* allocate(size_t length, MemTag mem_tag);\n@@ -583,2 +583,2 @@\n-  static E* allocate(size_t length, MEMFLAGS flags);\n-  static E* reallocate(E* addr, size_t new_length, MEMFLAGS flags);\n+  static E* allocate(size_t length, MemTag mem_tag);\n+  static E* reallocate(E* addr, size_t new_length, MemTag mem_tag);\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -234,0 +234,3 @@\n+static BuiltinException _array_index_out_of_bounds_exception;\n+static BuiltinException _array_store_exception;\n+static BuiltinException _class_cast_exception;\n@@ -251,0 +254,3 @@\n+oop Universe::array_index_out_of_bounds_exception_instance() { return _array_index_out_of_bounds_exception.instance(); }\n+oop Universe::array_store_exception_instance()    { return _array_store_exception.instance(); }\n+oop Universe::class_cast_exception_instance()     { return _class_cast_exception.instance(); }\n@@ -307,0 +313,3 @@\n+  _array_index_out_of_bounds_exception.store_in_cds();\n+  _array_store_exception.store_in_cds();\n+  _class_cast_exception.store_in_cds();\n@@ -323,0 +332,3 @@\n+    _array_index_out_of_bounds_exception.load_from_cds();\n+    _array_store_exception.load_from_cds();\n+    _class_cast_exception.load_from_cds();\n@@ -339,0 +351,3 @@\n+  _array_index_out_of_bounds_exception.serialize(f);\n+  _array_store_exception.serialize(f);\n+  _class_cast_exception.serialize(f);\n@@ -1101,2 +1116,1 @@\n-  \/\/ Setup preallocated NullPointerException\/ArithmeticException\n-  \/\/ (used for a cheap & dirty solution in compiler exception handling)\n+  \/\/ Setup preallocated exceptions used for a cheap & dirty solution in compiler exception handling\n@@ -1105,0 +1119,3 @@\n+  _array_index_out_of_bounds_exception.init_if_empty(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), CHECK_false);\n+  _array_store_exception.init_if_empty(vmSymbols::java_lang_ArrayStoreException(), CHECK_false);\n+  _class_cast_exception.init_if_empty(vmSymbols::java_lang_ClassCastException(), CHECK_false);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -234,0 +234,3 @@\n+  static oop          array_index_out_of_bounds_exception_instance();\n+  static oop          array_store_exception_instance();\n+  static oop          class_cast_exception_instance();\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -223,11 +223,0 @@\n-\n-#ifdef ASSERT\n-bool oopDesc::size_might_change() {\n-  \/\/ UseParallelGC and UseG1GC can change the length field\n-  \/\/ of an \"old copy\" of an object array in the young gen so it indicates\n-  \/\/ the grey portion of an already copied array. This will cause the first\n-  \/\/ disjunct below to fail if the two comparands are computed across such\n-  \/\/ a concurrent change.\n-  return Universe::heap()->is_stw_gc_active() && is_objArray() && is_forwarded() && (UseParallelGC || UseG1GC);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -337,2 +337,0 @@\n-\n-  DEBUG_ONLY(bool size_might_change();)\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-      assert(s == klass->oop_size(this) || size_might_change(), \"wrong array object size\");\n+      assert(s == klass->oop_size(this), \"wrong array object size\");\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3662,0 +3662,24 @@\n+void Compile::handle_div_mod_op(Node* n, BasicType bt, bool is_unsigned) {\n+  if (!UseDivMod) {\n+    return;\n+  }\n+\n+  \/\/ Check if \"a % b\" and \"a \/ b\" both exist\n+  Node* d = n->find_similar(Op_DivIL(bt, is_unsigned));\n+  if (d == nullptr) {\n+    return;\n+  }\n+\n+  \/\/ Replace them with a fused divmod if supported\n+  if (Matcher::has_match_rule(Op_DivModIL(bt, is_unsigned))) {\n+    DivModNode* divmod = DivModNode::make(n, bt, is_unsigned);\n+    d->subsume_by(divmod->div_proj(), this);\n+    n->subsume_by(divmod->mod_proj(), this);\n+  } else {\n+    \/\/ Replace \"a % b\" with \"a - ((a \/ b) * b)\"\n+    Node* mult = MulNode::make(d, d->in(2), bt);\n+    Node* sub = SubNode::make(d->in(1), mult, bt);\n+    n->subsume_by(sub, this);\n+  }\n+}\n+\n@@ -3839,2 +3863,3 @@\n-      if ((is_oop   && Matcher::const_oop_prefer_decode()  ) ||\n-          (is_klass && Matcher::const_klass_prefer_decode())) {\n+      if ((is_oop   && UseCompressedOops          && Matcher::const_oop_prefer_decode()  ) ||\n+          (is_klass && UseCompressedClassPointers && Matcher::const_klass_prefer_decode() &&\n+           t->isa_klassptr()->exact_klass()->is_in_encoding_range())) {\n@@ -4125,17 +4150,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_DivI);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_DivModI)) {\n-          DivModINode* divmod = DivModINode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulINode(d, d->in(2));\n-          Node* sub  = new SubINode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_INT, false);\n@@ -4145,17 +4154,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_DivL);\n-      if (d) {\n-        \/\/ Replace them with a fused divmod if supported\n-        if (Matcher::has_match_rule(Op_DivModL)) {\n-          DivModLNode* divmod = DivModLNode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulLNode(d, d->in(2));\n-          Node* sub  = new SubLNode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_LONG, false);\n@@ -4165,17 +4158,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_UDivI);\n-      if (d) {\n-        \/\/ Replace them with a fused unsigned divmod if supported\n-        if (Matcher::has_match_rule(Op_UDivModI)) {\n-          UDivModINode* divmod = UDivModINode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulINode(d, d->in(2));\n-          Node* sub  = new SubINode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_INT, true);\n@@ -4185,17 +4162,1 @@\n-    if (UseDivMod) {\n-      \/\/ Check if a%b and a\/b both exist\n-      Node* d = n->find_similar(Op_UDivL);\n-      if (d) {\n-        \/\/ Replace them with a fused unsigned divmod if supported\n-        if (Matcher::has_match_rule(Op_UDivModL)) {\n-          UDivModLNode* divmod = UDivModLNode::make(n);\n-          d->subsume_by(divmod->div_proj(), this);\n-          n->subsume_by(divmod->mod_proj(), this);\n-        } else {\n-          \/\/ replace a%b with a-((a\/b)*b)\n-          Node* mult = new MulLNode(d, d->in(2));\n-          Node* sub  = new SubLNode(d->in(1), mult);\n-          n->subsume_by(sub, this);\n-        }\n-      }\n-    }\n+    handle_div_mod_op(n, T_LONG, true);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":31,"deletions":70,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1245,0 +1245,1 @@\n+  void handle_div_mod_op(Node* n, BasicType bt, bool is_unsigned);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1363,0 +1363,18 @@\n+DivModNode* DivModNode::make(Node* div_or_mod, BasicType bt, bool is_unsigned) {\n+  assert(bt == T_INT || bt == T_LONG, \"only int or long input pattern accepted\");\n+\n+  if (bt == T_INT) {\n+    if (is_unsigned) {\n+      return UDivModINode::make(div_or_mod);\n+    } else {\n+      return DivModINode::make(div_or_mod);\n+    }\n+  } else {\n+    if (is_unsigned) {\n+      return UDivModLNode::make(div_or_mod);\n+    } else {\n+      return DivModLNode::make(div_or_mod);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -205,0 +205,2 @@\n+  static DivModNode* make(Node* div_or_mod, BasicType bt, bool is_unsigned);\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2091,2 +2091,2 @@\n-      assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n-             strncmp(name, \"_load_unknown_inline\", 20) == 0, \"TODO: add failed case check\");\n+      assert(strncmp(name, \"C2 Runtime multianewarray\", 25) == 0 ||\n+             strncmp(name, \"C2 Runtime load_unknown_inline\", 30) == 0, \"TODO: add failed case check\");\n@@ -2802,2 +2802,2 @@\n-    assert(strncmp(name, \"_multianewarray\", 15) == 0 ||\n-           strncmp(name, \"_load_unknown_inline\", 20) == 0, \"sanity\");\n+    assert(strncmp(name, \"C2 Runtime multianewarray\", 25) == 0 ||\n+           strncmp(name, \"C2 Runtime load_unknown_inline\", 30) == 0, \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -565,0 +565,97 @@\n+class DefUseMemStatesQueue : public StackObj {\n+private:\n+  class DefUsePair : public StackObj {\n+  private:\n+    Node* _def; \/\/ memory state\n+    Node* _use; \/\/ use of the memory state that also modifies the memory state\n+\n+  public:\n+    DefUsePair(Node* def, Node* use) :\n+      _def(def), _use(use) {\n+    }\n+\n+    DefUsePair() :\n+      _def(nullptr), _use(nullptr) {\n+    }\n+\n+    Node* def() const {\n+      return _def;\n+    }\n+\n+    Node* use() const {\n+      return _use;\n+    }\n+  };\n+\n+  GrowableArray<DefUsePair> _queue;\n+  GrowableArray<MergeMemNode*> _worklist_visited; \/\/ visited mergemem nodes\n+\n+  bool already_enqueued(Node* def_mem, PhiNode* use_phi) const {\n+    \/\/ def_mem is one of the inputs of use_phi and at least one input of use_phi is\n+    \/\/ not def_mem. It's however possible that use_phi has def_mem as input multiple\n+    \/\/ times. If that happens, use_phi is recorded as a use of def_mem multiple\n+    \/\/ times as well. When PhaseCFG::insert_anti_dependences() goes over\n+    \/\/ uses of def_mem and enqueues them for processing, use_phi would then be\n+    \/\/ enqueued for processing multiple times when it only needs to be\n+    \/\/ processed once. The code below checks if use_phi as a use of def_mem was\n+    \/\/ already enqueued to avoid redundant processing of use_phi.\n+    int j = _queue.length()-1;\n+    \/\/ If there are any use of def_mem already enqueued, they were enqueued\n+    \/\/ last (all use of def_mem are processed in one go).\n+    for (; j >= 0; j--) {\n+      const DefUsePair& def_use_pair = _queue.at(j);\n+      if (def_use_pair.def() != def_mem) {\n+        \/\/ We're done with the uses of def_mem\n+        break;\n+      }\n+      if (def_use_pair.use() == use_phi) {\n+        return true;\n+      }\n+    }\n+#ifdef ASSERT\n+    for (; j >= 0; j--) {\n+      const DefUsePair& def_use_pair = _queue.at(j);\n+      assert(def_use_pair.def() != def_mem, \"Should be done with the uses of def_mem\");\n+    }\n+#endif\n+    return false;\n+  }\n+\n+public:\n+  DefUseMemStatesQueue(ResourceArea* area) {\n+  }\n+\n+  void push(Node* def_mem_state, Node* use_mem_state) {\n+    if (use_mem_state->is_MergeMem()) {\n+      \/\/ Be sure we don't get into combinatorial problems.\n+      if (!_worklist_visited.append_if_missing(use_mem_state->as_MergeMem())) {\n+        return; \/\/ already on work list; do not repeat\n+      }\n+    } else if (use_mem_state->is_Phi()) {\n+      \/\/ A Phi could have the same mem as input multiple times. If that's the case, we don't need to enqueue it\n+      \/\/ more than once. We otherwise allow phis to be repeated; they can merge two relevant states.\n+      if (already_enqueued(def_mem_state, use_mem_state->as_Phi())) {\n+        return;\n+      }\n+    }\n+\n+    _queue.push(DefUsePair(def_mem_state, use_mem_state));\n+  }\n+\n+  bool is_nonempty() const {\n+    return _queue.is_nonempty();\n+  }\n+\n+  Node* top_def() const {\n+    return _queue.top().def();\n+  }\n+\n+  Node* top_use() const {\n+    return _queue.top().use();\n+  }\n+\n+  void pop() {\n+    _queue.pop();\n+  }\n+};\n+\n@@ -582,0 +679,1 @@\n+  ResourceMark rm;\n@@ -628,4 +726,2 @@\n-  ResourceArea *area = Thread::current()->resource_area();\n-  Node_List worklist_mem(area);     \/\/ prior memory state to store\n-  Node_List worklist_store(area);   \/\/ possible-def to explore\n-  Node_List worklist_visited(area); \/\/ visited mergemem nodes\n+  ResourceArea* area = Thread::current()->resource_area();\n+  DefUseMemStatesQueue worklist_def_use_mem_states(area); \/\/ prior memory state to store and possible-def to explore\n@@ -647,1 +743,3 @@\n-  \/\/    initial_mem -> (MergeMem ->)* store\n+  \/\/    initial_mem -> (MergeMem ->)* Memory state modifying node\n+  \/\/ Memory state modifying nodes include Store and Phi nodes and any node for which needs_anti_dependence_check()\n+  \/\/ returns false.\n@@ -651,4 +749,2 @@\n-  worklist_store.push(initial_mem);\n-  worklist_visited.push(initial_mem);\n-  worklist_mem.push(nullptr);\n-  while (worklist_store.size() > 0) {\n+  worklist_def_use_mem_states.push(nullptr, initial_mem);\n+  while (worklist_def_use_mem_states.is_nonempty()) {\n@@ -656,3 +752,6 @@\n-    Node* mem   = worklist_mem.pop();\n-    Node* store = worklist_store.pop();\n-    uint op = store->Opcode();\n+    Node* def_mem_state = worklist_def_use_mem_states.top_def();\n+    Node* use_mem_state = worklist_def_use_mem_states.top_use();\n+    worklist_def_use_mem_states.pop();\n+\n+    uint op = use_mem_state->Opcode();\n+    assert(!use_mem_state->needs_anti_dependence_check(), \"no loads\");\n@@ -663,1 +762,1 @@\n-    if (store == initial_mem    \/\/ root (exclusive) of tree we are searching\n+    if (use_mem_state == initial_mem    \/\/ root (exclusive) of tree we are searching\n@@ -666,2 +765,2 @@\n-      mem = store;   \/\/ It's not a possibly interfering store.\n-      if (store == initial_mem)\n+      def_mem_state = use_mem_state;   \/\/ It's not a possibly interfering store.\n+      if (use_mem_state == initial_mem)\n@@ -670,11 +769,6 @@\n-      for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n-        store = mem->fast_out(i);\n-        if (store->is_MergeMem()) {\n-          \/\/ Be sure we don't get into combinatorial problems.\n-          \/\/ (Allow phis to be repeated; they can merge two relevant states.)\n-          uint j = worklist_visited.size();\n-          for (; j > 0; j--) {\n-            if (worklist_visited.at(j-1) == store)  break;\n-          }\n-          if (j > 0)  continue; \/\/ already on work list; do not repeat\n-          worklist_visited.push(store);\n+      for (DUIterator_Fast imax, i = def_mem_state->fast_outs(imax); i < imax; i++) {\n+        use_mem_state = def_mem_state->fast_out(i);\n+        if (use_mem_state->needs_anti_dependence_check()) {\n+          \/\/ use_mem_state is also a kind of load (i.e. needs_anti_dependence_check), and it is not a memory state\n+          \/\/ modifying node (store, Phi or MergeMem). Hence, load can't be anti dependent on this node.\n+          continue;\n@@ -682,2 +776,1 @@\n-        worklist_mem.push(mem);\n-        worklist_store.push(store);\n+        worklist_def_use_mem_states.push(def_mem_state, use_mem_state);\n@@ -689,1 +782,0 @@\n-    if (store->needs_anti_dependence_check())  continue;  \/\/ not really a store\n@@ -694,1 +786,1 @@\n-    const TypePtr* adr_type = store->adr_type();\n+    const TypePtr* adr_type = use_mem_state->adr_type();\n@@ -699,2 +791,2 @@\n-    if (store->is_Mach()) {\n-      MachNode* mstore = store->as_Mach();\n+    if (use_mem_state->is_Mach()) {\n+      MachNode* mstore = use_mem_state->as_Mach();\n@@ -739,1 +831,1 @@\n-    Block* store_block = get_block_for_node(store);\n+    Block* store_block = get_block_for_node(use_mem_state);\n@@ -742,1 +834,1 @@\n-    if (store->is_Phi()) {\n+    if (use_mem_state->is_Phi()) {\n@@ -757,2 +849,2 @@\n-      for (uint j = PhiNode::Input, jmax = store->req(); j < jmax; j++) {\n-        if (store->in(j) == mem) {   \/\/ Found matching input?\n+      for (uint j = PhiNode::Input, jmax = use_mem_state->req(); j < jmax; j++) {\n+        if (use_mem_state->in(j) == def_mem_state) {   \/\/ Found matching input?\n@@ -784,1 +876,1 @@\n-      if (LCA != early && !unrelated_load_in_store_null_block(store, load)) {\n+      if (LCA != early && !unrelated_load_in_store_null_block(use_mem_state, load)) {\n@@ -787,1 +879,1 @@\n-        non_early_stores.push(store);\n+        non_early_stores.push(use_mem_state);\n@@ -793,1 +885,1 @@\n-      assert(store != load->find_exact_control(load->in(0)), \"dependence cycle found\");\n+      assert(use_mem_state != load->find_exact_control(load->in(0)), \"dependence cycle found\");\n@@ -795,1 +887,1 @@\n-        assert(store->find_edge(load) != -1 || unrelated_load_in_store_null_block(store, load),\n+        assert(use_mem_state->find_edge(load) != -1 || unrelated_load_in_store_null_block(use_mem_state, load),\n@@ -798,1 +890,1 @@\n-        store->add_prec(load);\n+        use_mem_state->add_prec(load);\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":133,"deletions":41,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2083,0 +2083,32 @@\n+inline int Op_DivIL(BasicType bt, bool is_unsigned) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    if (is_unsigned) {\n+      return Op_UDivI;\n+    } else {\n+      return Op_DivI;\n+    }\n+  }\n+  if (is_unsigned) {\n+    return Op_UDivL;\n+  } else {\n+    return Op_DivL;\n+  }\n+}\n+\n+inline int Op_DivModIL(BasicType bt, bool is_unsigned) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for int or longs\");\n+  if (bt == T_INT) {\n+    if (is_unsigned) {\n+      return Op_UDivModI;\n+    } else {\n+      return Op_DivModI;\n+    }\n+  }\n+  if (is_unsigned) {\n+    return Op_UDivModL;\n+  } else {\n+    return Op_DivModL;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-                                   OptoRuntime::load_unknown_inline_type(),\n+                                   OptoRuntime::load_unknown_inline_Type(),\n@@ -309,2 +309,2 @@\n-                            OptoRuntime::store_unknown_inline_type(),\n-                            CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline),\n+                            OptoRuntime::store_unknown_inline_Type(),\n+                            CAST_FROM_FN_PTR(address, OptoRuntime::store_unknown_inline_C),\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,28 +93,21 @@\n-\n-\n-\/\/ Compiled code entry points\n-address OptoRuntime::_new_instance_Java                           = nullptr;\n-address OptoRuntime::_new_array_Java                              = nullptr;\n-address OptoRuntime::_new_array_nozero_Java                       = nullptr;\n-address OptoRuntime::_multianewarray2_Java                        = nullptr;\n-address OptoRuntime::_multianewarray3_Java                        = nullptr;\n-address OptoRuntime::_multianewarray4_Java                        = nullptr;\n-address OptoRuntime::_multianewarray5_Java                        = nullptr;\n-address OptoRuntime::_multianewarrayN_Java                        = nullptr;\n-address OptoRuntime::_vtable_must_compile_Java                    = nullptr;\n-address OptoRuntime::_complete_monitor_locking_Java               = nullptr;\n-address OptoRuntime::_monitor_notify_Java                         = nullptr;\n-address OptoRuntime::_monitor_notifyAll_Java                      = nullptr;\n-address OptoRuntime::_rethrow_Java                                = nullptr;\n-address OptoRuntime::_slow_arraycopy_Java                         = nullptr;\n-address OptoRuntime::_register_finalizer_Java                     = nullptr;\n-address OptoRuntime::_load_unknown_inline                         = nullptr;\n-#if INCLUDE_JVMTI\n-address OptoRuntime::_notify_jvmti_vthread_start                  = nullptr;\n-address OptoRuntime::_notify_jvmti_vthread_end                    = nullptr;\n-address OptoRuntime::_notify_jvmti_vthread_mount                  = nullptr;\n-address OptoRuntime::_notify_jvmti_vthread_unmount                = nullptr;\n-#endif\n-\n-UncommonTrapBlob*   OptoRuntime::_uncommon_trap_blob;\n-ExceptionBlob*      OptoRuntime::_exception_blob;\n+#define C2_BLOB_FIELD_DEFINE(name, type) \\\n+  type OptoRuntime:: BLOB_FIELD_NAME(name)  = nullptr;\n+#define C2_STUB_FIELD_NAME(name) _ ## name ## _Java\n+#define C2_STUB_FIELD_DEFINE(name, f, t, r) \\\n+  address OptoRuntime:: C2_STUB_FIELD_NAME(name) = nullptr;\n+#define C2_JVMTI_STUB_FIELD_DEFINE(name) \\\n+  address OptoRuntime:: STUB_FIELD_NAME(name) = nullptr;\n+C2_STUBS_DO(C2_BLOB_FIELD_DEFINE, C2_STUB_FIELD_DEFINE, C2_JVMTI_STUB_FIELD_DEFINE)\n+#undef C2_BLOB_FIELD_DEFINE\n+#undef C2_STUB_FIELD_DEFINE\n+#undef C2_JVMTI_STUB_FIELD_DEFINE\n+\n+#define C2_BLOB_NAME_DEFINE(name, type)  \"C2 Runtime \" # name \"_blob\",\n+#define C2_STUB_NAME_DEFINE(name, f, t, r)  \"C2 Runtime \" # name,\n+#define C2_JVMTI_STUB_NAME_DEFINE(name)  \"C2 Runtime \" # name,\n+const char* OptoRuntime::_stub_names[] = {\n+  C2_STUBS_DO(C2_BLOB_NAME_DEFINE, C2_STUB_NAME_DEFINE, C2_JVMTI_STUB_NAME_DEFINE)\n+};\n+#undef C2_BLOB_NAME_DEFINE\n+#undef C2_STUB_NAME_DEFINE\n+#undef C2_JVMTI_STUB_NAME_DEFINE\n@@ -137,1 +130,1 @@\n-\n+\/*\n@@ -141,0 +134,43 @@\n+*\/\n+\n+#define GEN_C2_BLOB(name, type)                    \\\n+  generate_ ## name ## _blob();\n+\n+\/\/ a few helper macros to conjure up generate_stub call arguments\n+#define C2_STUB_FIELD_NAME(name) _ ## name ## _Java\n+#define C2_STUB_TYPEFUNC(name) name ## _Type\n+#define C2_STUB_C_FUNC(name) CAST_FROM_FN_PTR(address, name ## _C)\n+#define C2_STUB_NAME(name) stub_name(OptoStubId::name ## _id)\n+\n+\/\/ Almost all the C functions targeted from the generated stubs are\n+\/\/ implemented locally to OptoRuntime with names that can be generated\n+\/\/ from the stub name by appending suffix '_C'. However, in two cases\n+\/\/ a common target method also needs to be called from shared runtime\n+\/\/ stubs. In these two cases the opto stubs rely on method\n+\/\/ imlementations defined in class SharedRuntime. The following\n+\/\/ defines temporarily rebind the generated names to reference the\n+\/\/ relevant implementations.\n+\n+#define GEN_C2_STUB(name, fancy_jump, pass_tls, pass_retpc  )         \\\n+  C2_STUB_FIELD_NAME(name) =                                          \\\n+    generate_stub(env,                                                  \\\n+                  C2_STUB_TYPEFUNC(name),                             \\\n+                  C2_STUB_C_FUNC(name),                               \\\n+                  C2_STUB_NAME(name),                                 \\\n+                  fancy_jump,                                           \\\n+                  pass_tls,                                             \\\n+                  pass_retpc);                                          \\\n+  if (C2_STUB_FIELD_NAME(name) == nullptr) { return false; }          \\\n+\n+#define C2_JVMTI_STUB_C_FUNC(name) CAST_FROM_FN_PTR(address, SharedRuntime::name)\n+\n+#define GEN_C2_JVMTI_STUB(name)                                       \\\n+  STUB_FIELD_NAME(name) =                                               \\\n+    generate_stub(env,                                                  \\\n+                  notify_jvmti_vthread_Type,                            \\\n+                  C2_JVMTI_STUB_C_FUNC(name),                         \\\n+                  C2_STUB_NAME(name),                                 \\\n+                  0,                                                    \\\n+                  true,                                                 \\\n+                  false);                                               \\\n+  if (STUB_FIELD_NAME(name) == nullptr) { return false; }               \\\n@@ -144,28 +180,1 @@\n-  generate_uncommon_trap_blob();\n-  generate_exception_blob();\n-\n-  \/\/ Note: tls: Means fetching the return oop out of the thread-local storage\n-  \/\/\n-  \/\/   variable\/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,retpc\n-  \/\/ -------------------------------------------------------------------------------------------------------------------------------\n-  gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true, false);\n-  gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true, false);\n-  gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true, false);\n-  gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true, false);\n-  gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true, false);\n-  gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true, false);\n-  gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true, false);\n-  gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true, false);\n-#if INCLUDE_JVMTI\n-  gen(env, _notify_jvmti_vthread_start     , notify_jvmti_vthread_Type    , SharedRuntime::notify_jvmti_vthread_start, 0, true, false);\n-  gen(env, _notify_jvmti_vthread_end       , notify_jvmti_vthread_Type    , SharedRuntime::notify_jvmti_vthread_end,   0, true, false);\n-  gen(env, _notify_jvmti_vthread_mount     , notify_jvmti_vthread_Type    , SharedRuntime::notify_jvmti_vthread_mount, 0, true, false);\n-  gen(env, _notify_jvmti_vthread_unmount   , notify_jvmti_vthread_Type    , SharedRuntime::notify_jvmti_vthread_unmount, 0, true, false);\n-#endif\n-  gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false);\n-  gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false);\n-  gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false);\n-  gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , true );\n-  gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false);\n-  gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false);\n-  gen(env, _load_unknown_inline            , load_unknown_inline_type     , load_unknown_inline             ,    0 , true,  false);\n+  C2_STUBS_DO(GEN_C2_BLOB, GEN_C2_STUB, GEN_C2_JVMTI_STUB)\n@@ -176,1 +185,11 @@\n-#undef gen\n+#undef GEN_C2_BLOB\n+\n+#undef C2_STUB_FIELD_NAME\n+#undef C2_STUB_TYPEFUNC\n+#undef C2_STUB_C_FUNC\n+#undef C2_STUB_NAME\n+#undef GEN_C2_STUB\n+\n+#undef C2_JVMTI_STUB_C_FUNC\n+#undef GEN_C2_JVMTI_STUB\n+\/\/ #undef gen\n@@ -206,0 +225,13 @@\n+\/\/ local methods passed as arguments to stub generator that forward\n+\/\/ control to corresponding JRT methods of SharedRuntime\n+\n+void OptoRuntime::slow_arraycopy_C(oopDesc* src,  jint src_pos,\n+                                   oopDesc* dest, jint dest_pos,\n+                                   jint length, JavaThread* thread) {\n+  SharedRuntime::slow_arraycopy_C(src,  src_pos, dest, dest_pos, length, thread);\n+}\n+\n+void OptoRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* current) {\n+  SharedRuntime::complete_monitor_locking_C(obj, lock, current);\n+}\n+\n@@ -538,0 +570,4 @@\n+const TypeFunc *OptoRuntime::new_array_nozero_Type() {\n+  return new_array_Type();\n+}\n+\n@@ -616,0 +652,3 @@\n+const TypeFunc *OptoRuntime::complete_monitor_locking_Type() {\n+  return complete_monitor_enter_Type();\n+}\n@@ -646,0 +685,4 @@\n+const TypeFunc *OptoRuntime::monitor_notifyAll_Type() {\n+  return monitor_notify_Type();\n+}\n+\n@@ -1769,1 +1812,0 @@\n-\n@@ -1836,1 +1878,1 @@\n-JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* current))\n+JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer_C(oopDesc* obj, JavaThread* current))\n@@ -1998,1 +2040,1 @@\n-JRT_BLOCK_ENTRY(void, OptoRuntime::load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current))\n+JRT_BLOCK_ENTRY(void, OptoRuntime::load_unknown_inline_C(flatArrayOopDesc* array, int index, JavaThread* current))\n@@ -2007,1 +2049,1 @@\n-const TypeFunc* OptoRuntime::load_unknown_inline_type() {\n+const TypeFunc* OptoRuntime::load_unknown_inline_Type() {\n@@ -2024,1 +2066,1 @@\n-JRT_LEAF(void, OptoRuntime::store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index))\n+JRT_LEAF(void, OptoRuntime::store_unknown_inline_C(instanceOopDesc* buffer, flatArrayOopDesc* array, int index))\n@@ -2031,1 +2073,1 @@\n-const TypeFunc* OptoRuntime::store_unknown_inline_type() {\n+const TypeFunc* OptoRuntime::store_unknown_inline_Type() {\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":106,"deletions":64,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/stubDeclarations.hpp\"\n@@ -101,0 +102,14 @@\n+\/\/ define OptoStubId enum tags: uncommon_trap_id etc\n+\n+#define C2_BLOB_ID_ENUM_DECLARE(name, type) STUB_ID_NAME(name),\n+#define C2_STUB_ID_ENUM_DECLARE(name, f, t, r) STUB_ID_NAME(name),\n+#define C2_JVMTI_STUB_ID_ENUM_DECLARE(name) STUB_ID_NAME(name),\n+enum class OptoStubId :int {\n+  NO_STUBID = -1,\n+  C2_STUBS_DO(C2_BLOB_ID_ENUM_DECLARE, C2_STUB_ID_ENUM_DECLARE, C2_JVMTI_STUB_ID_ENUM_DECLARE)\n+  NUM_STUBIDS\n+};\n+#undef C2_BLOB_ID_ENUM_DECLARE\n+#undef C2_STUB_ID_ENUM_DECLARE\n+#undef C2_JVMTI_STUB_ID_ENUM_DECLARE\n+\n@@ -105,0 +120,19 @@\n+  \/\/ declare opto stub address\/blob holder static fields\n+#define C2_BLOB_FIELD_DECLARE(name, type) \\\n+  static type        BLOB_FIELD_NAME(name);\n+#define C2_STUB_FIELD_NAME(name) _ ## name ## _Java\n+#define C2_STUB_FIELD_DECLARE(name, f, t, r) \\\n+  static address     C2_STUB_FIELD_NAME(name) ;\n+#define C2_JVMTI_STUB_FIELD_DECLARE(name) \\\n+  static address     STUB_FIELD_NAME(name);\n+\n+  C2_STUBS_DO(C2_BLOB_FIELD_DECLARE, C2_STUB_FIELD_DECLARE, C2_JVMTI_STUB_FIELD_DECLARE)\n+\n+#undef C2_BLOB_FIELD_DECLARE\n+#undef C2_STUB_FIELD_NAME\n+#undef C2_STUB_FIELD_DECLARE\n+#undef C2_JVMTI_STUB_FIELD_DECLARE\n+\n+  \/\/ Stub names indexed by sharedStubId\n+  static const char *_stub_names[];\n+\n@@ -108,25 +142,0 @@\n-  \/\/ References to generated stubs\n-  static address _new_instance_Java;\n-  static address _new_array_Java;\n-  static address _new_array_nozero_Java;\n-  static address _multianewarray2_Java;\n-  static address _multianewarray3_Java;\n-  static address _multianewarray4_Java;\n-  static address _multianewarray5_Java;\n-  static address _multianewarrayN_Java;\n-  static address _vtable_must_compile_Java;\n-  static address _complete_monitor_locking_Java;\n-  static address _rethrow_Java;\n-  static address _monitor_notify_Java;\n-  static address _monitor_notifyAll_Java;\n-\n-  static address _slow_arraycopy_Java;\n-  static address _register_finalizer_Java;\n-  static address _load_unknown_inline;\n-#if INCLUDE_JVMTI\n-  static address _notify_jvmti_vthread_start;\n-  static address _notify_jvmti_vthread_end;\n-  static address _notify_jvmti_vthread_mount;\n-  static address _notify_jvmti_vthread_unmount;\n-#endif\n-\n@@ -152,0 +161,7 @@\n+  \/\/ local methods passed as arguments to stub generator that forward\n+  \/\/ control to corresponding JRT methods of SharedRuntime\n+  static void slow_arraycopy_C(oopDesc* src,  jint src_pos,\n+                               oopDesc* dest, jint dest_pos,\n+                               jint length, JavaThread* thread);\n+  static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* current);\n+\n@@ -172,3 +188,0 @@\n-  static UncommonTrapBlob*   _uncommon_trap_blob;\n-  static ExceptionBlob*       _exception_blob;\n-\n@@ -178,1 +191,1 @@\n-  static void register_finalizer(oopDesc* obj, JavaThread* current);\n+  static void register_finalizer_C(oopDesc* obj, JavaThread* current);\n@@ -181,0 +194,2 @@\n+  static void load_unknown_inline_C(flatArrayOopDesc* array, int index, JavaThread* current);\n+  static void store_unknown_inline_C(instanceOopDesc* buffer, flatArrayOopDesc* array, int index);\n@@ -192,0 +207,6 @@\n+  \/\/ Returns the name associated with a given stub id\n+  static const char* stub_name(OptoStubId id) {\n+    assert(id > OptoStubId::NO_STUBID && id < OptoStubId::NUM_STUBIDS, \"stub id out of range\");\n+    return _stub_names[(int)id];\n+  }\n+\n@@ -201,1 +222,0 @@\n-  static address vtable_must_compile_stub()              { return _vtable_must_compile_Java; }\n@@ -208,1 +228,1 @@\n-  static address load_unknown_inline_Java()              { return _load_unknown_inline; }\n+  static address load_unknown_inline_Java()              { return _load_unknown_inline_Java; }\n@@ -232,0 +252,1 @@\n+  static const TypeFunc* new_array_nozero_Type ();   \/\/ [a]newarray (slow case)\n@@ -239,0 +260,1 @@\n+  static const TypeFunc* complete_monitor_locking_Type();\n@@ -241,0 +263,1 @@\n+  static const TypeFunc* monitor_notifyAll_Type();\n@@ -308,0 +331,6 @@\n+  static const TypeFunc* load_unknown_inline_Type();\n+  static const TypeFunc* store_unknown_inline_Type();\n+\n+  static const TypeFunc* store_inline_type_fields_Type();\n+  static const TypeFunc* pack_inline_type_Type();\n+\n@@ -317,8 +346,0 @@\n-  static const TypeFunc* store_inline_type_fields_Type();\n-  static const TypeFunc* pack_inline_type_Type();\n-\n-  static void load_unknown_inline(flatArrayOopDesc* array, int index, JavaThread* current);\n-  static const TypeFunc* load_unknown_inline_type();\n-  static void store_unknown_inline(instanceOopDesc* buffer, flatArrayOopDesc* array, int index);\n-  static const TypeFunc* store_unknown_inline_type();\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":60,"deletions":39,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2508,1 +2508,1 @@\n-      MemTracker::record_virtual_memory_type((void*)bad_address, mtInternal);\n+      MemTracker::record_virtual_memory_tag((void*)bad_address, mtInternal);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3137,1 +3137,3 @@\n-\n+  \/\/ As for the GetFieldDeclaringClass method, the XSL generated C++ code that calls it has\n+  \/\/ a jclass of the relevant class or a subclass of it, which is fine in terms of ensuring\n+  \/\/ the holder is kept alive.\n@@ -3215,1 +3217,3 @@\n-  (*declaring_class_ptr) = get_jni_class_non_null(method->method_holder());\n+  Klass* k = method->method_holder();\n+  Handle holder(Thread::current(), k->klass_holder()); \/\/ keep the klass alive\n+  (*declaring_class_ptr) = get_jni_class_non_null(k);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-\/\/ Alloc memory using the test memory type so that we can use that to see if\n+\/\/ Alloc memory using the test memory tag so that we can use that to see if\n@@ -698,2 +698,2 @@\n-\/\/ Alloc memory with pseudo call stack and specific memory type.\n-WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))\n+\/\/ Alloc memory with pseudo call stack and specific memory tag.\n+WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint mem_tag))\n@@ -702,1 +702,1 @@\n-  return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);\n+  return (jlong)(uintptr_t)os::malloc(size, (MemTag)mem_tag, stack);\n@@ -714,1 +714,1 @@\n-  MemTracker::record_virtual_memory_type((address)addr, mtTest);\n+  MemTracker::record_virtual_memory_tag((address)addr, mtTest);\n@@ -721,1 +721,1 @@\n-  MemTracker::record_virtual_memory_type((address)addr, mtTest);\n+  MemTracker::record_virtual_memory_tag((address)addr, mtTest);\n@@ -728,1 +728,1 @@\n-  MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);\n+  MemTracker::record_virtual_memory_tag((address)(uintptr_t)addr, mtTest);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -378,2 +378,2 @@\n-    assert(dest == Runtime1::entry_for(Runtime1::buffer_inline_args_no_receiver_id) ||\n-           dest == Runtime1::entry_for(Runtime1::buffer_inline_args_id), \"unexpected safepoint in entry point\");\n+    assert(dest == Runtime1::entry_for(C1StubId::buffer_inline_args_no_receiver_id) ||\n+           dest == Runtime1::entry_for(C1StubId::buffer_inline_args_id), \"unexpected safepoint in entry point\");\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1227,3 +1227,0 @@\n-                                                                            \\\n-  develop(intx, CounterHalfLifeTime,    30,                                 \\\n-          \"Half-life time of invocation counters (in seconds)\")             \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  HandleArea(MEMFLAGS flags, HandleArea* prev) : Arena(flags, Tag::tag_ha, Chunk::tiny_size) {\n+  HandleArea(MemTag mem_tag, HandleArea* prev) : Arena(mem_tag, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -413,2 +413,2 @@\n-JavaThread::JavaThread(MEMFLAGS flags) :\n-  Thread(flags),\n+JavaThread::JavaThread(MemTag mem_tag) :\n+  Thread(mem_tag),\n@@ -638,1 +638,1 @@\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MEMFLAGS flags) : JavaThread(flags) {\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz, MemTag mem_tag) : JavaThread(mem_tag) {\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -483,2 +483,2 @@\n-  JavaThread(MEMFLAGS flags = mtThread);   \/\/ delegating constructor\n-  JavaThread(ThreadFunction entry_point, size_t stack_size = 0, MEMFLAGS flags = mtThread);\n+  JavaThread(MemTag mem_tag = mtThread);   \/\/ delegating constructor\n+  JavaThread(ThreadFunction entry_point, size_t stack_size = 0, MemTag mem_tag = mtThread);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,105 @@\n-\/\/ generate a stub id enum tag from a name\n+\/\/ C1 stubs are always generated in a generic CodeBlob\n+\n+#ifdef COMPILER1\n+\/\/ do_blob(name)\n+#define C1_STUBS_DO(do_blob)                                           \\\n+  do_blob(dtrace_object_alloc)                                         \\\n+  do_blob(unwind_exception)                                            \\\n+  do_blob(forward_exception)                                           \\\n+  do_blob(throw_range_check_failed)       \/* throws ArrayIndexOutOfBoundsException *\/ \\\n+  do_blob(throw_index_exception)          \/* throws IndexOutOfBoundsException *\/ \\\n+  do_blob(throw_div0_exception)                                        \\\n+  do_blob(throw_null_pointer_exception)                                \\\n+  do_blob(register_finalizer)                                          \\\n+  do_blob(new_instance)                                                \\\n+  do_blob(fast_new_instance)                                           \\\n+  do_blob(fast_new_instance_init_check)                                \\\n+  do_blob(new_type_array)                                              \\\n+  do_blob(new_object_array)                                            \\\n+  do_blob(new_null_free_array)                                         \\\n+  do_blob(new_multi_array)                                             \\\n+  do_blob(load_flat_array)                                             \\\n+  do_blob(store_flat_array)                                            \\\n+  do_blob(substitutability_check)                                      \\\n+  do_blob(buffer_inline_args)                                          \\\n+  do_blob(buffer_inline_args_no_receiver)                              \\\n+  do_blob(handle_exception_nofpu)         \/* optimized version that does not preserve fpu registers *\/ \\\n+  do_blob(handle_exception)                                            \\\n+  do_blob(handle_exception_from_callee)                                \\\n+  do_blob(throw_array_store_exception)                                 \\\n+  do_blob(throw_class_cast_exception)                                  \\\n+  do_blob(throw_incompatible_class_change_error)                       \\\n+  do_blob(throw_illegal_monitor_state_exception)                       \\\n+  do_blob(throw_identity_exception)                                    \\\n+  do_blob(slow_subtype_check)                                          \\\n+  do_blob(monitorenter)                                                \\\n+  do_blob(monitorenter_nofpu)             \/* optimized version that does not preserve fpu registers *\/ \\\n+  do_blob(monitorexit)                                                 \\\n+  do_blob(monitorexit_nofpu)              \/* optimized version that does not preserve fpu registers *\/ \\\n+  do_blob(deoptimize)                                                  \\\n+  do_blob(access_field_patching)                                       \\\n+  do_blob(load_klass_patching)                                         \\\n+  do_blob(load_mirror_patching)                                        \\\n+  do_blob(load_appendix_patching)                                      \\\n+  do_blob(fpu2long_stub)                                               \\\n+  do_blob(counter_overflow)                                            \\\n+  do_blob(predicate_failed_trap)                                       \\\n+\n+#else\n+#define C1_STUBS_DO(do_blob)\n+#endif\n+\n+\/\/ Opto stubs can be stored as entries with just an address or as\n+\/\/ blobs of different types. The former may include some JVMTI stubs.\n+\/\/\n+\/\/ n.b. blobs and stub defines are generated in the order defined by\n+\/\/ C2_STUBS_DO, allowing dependencies from any givem stub on its\n+\/\/ predecessors to be guaranteed. That explains the initial placement\n+\/\/ of the blob declarations and intermediate placement of the jvmti\n+\/\/ stubs.\n+\n+#ifdef COMPILER2\n+\/\/ do_jvmti_stub(name)\n+#if INCLUDE_JVMTI\n+#define C2_JVMTI_STUBS_DO(do_jvmti_stub)                               \\\n+  do_jvmti_stub(notify_jvmti_vthread_start)                            \\\n+  do_jvmti_stub(notify_jvmti_vthread_end)                              \\\n+  do_jvmti_stub(notify_jvmti_vthread_mount)                            \\\n+  do_jvmti_stub(notify_jvmti_vthread_unmount)                          \\\n+\n+#else\n+#define C2_JVMTI_STUBS_DO(do_jvmti_stub)\n+#endif \/\/ INCLUDE_JVMTI\n+\n+\/\/ do_blob(name, type)\n+\/\/ do_stub(name, fancy_jump, pass_tls, return_pc)\n+\/\/ do_jvmti_stub(name)\n+\/\/\n+\/\/ n.b. non-jvmti stubs may employ a special type of jump (0, 1 or 2)\n+\/\/ and require access to TLS and the return pc. jvmti stubs always\n+\/\/ employ jump 0, and require no special access\n+#define C2_STUBS_DO(do_blob, do_stub, do_jvmti_stub)                   \\\n+  do_blob(uncommon_trap, UncommonTrapBlob*)                            \\\n+  do_blob(exception, ExceptionBlob*)                                   \\\n+  do_stub(new_instance, 0, true, false)                                \\\n+  do_stub(new_array, 0, true, false)                                   \\\n+  do_stub(new_array_nozero, 0, true, false)                            \\\n+  do_stub(multianewarray2, 0, true, false)                             \\\n+  do_stub(multianewarray3, 0, true, false)                             \\\n+  do_stub(multianewarray4, 0, true, false)                             \\\n+  do_stub(multianewarray5, 0, true, false)                             \\\n+  do_stub(multianewarrayN, 0, true, false)                             \\\n+  C2_JVMTI_STUBS_DO(do_jvmti_stub)                                     \\\n+  do_stub(complete_monitor_locking, 0, false, false)                   \\\n+  do_stub(monitor_notify, 0, false, false)                             \\\n+  do_stub(monitor_notifyAll, 0, false, false)                          \\\n+  do_stub(rethrow, 2, true, true)                                      \\\n+  do_stub(slow_arraycopy, 0, false, false)                             \\\n+  do_stub(register_finalizer, 0, false, false)                         \\\n+  do_stub(load_unknown_inline, 0, true, false)                         \\\n+\n+#else\n+#define C2_STUBS_DO(do_blob, do_stub, do_jvmti_stub)\n+#endif\n+\n+\/\/ generate a stub or blob id enum tag from a name\n@@ -77,1 +181,1 @@\n-\/\/ generate a blob id enum tag from a name\n+\/\/ generate a stub field name\n@@ -79,1 +183,1 @@\n-#define BLOB_ID_NAME(base) base##_id\n+#define STUB_FIELD_NAME(base) _##base\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":107,"deletions":3,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -410,1 +410,1 @@\n-  typedef void (*UnsafeSetMemoryStub)(const void* src, size_t count, char byte);\n+  typedef void (*UnsafeSetMemoryStub)(void* dst, size_t count, char byte);\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+  initialize_class(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), CHECK);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+#endif \/\/ LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -144,1 +146,1 @@\n-#endif \/\/ LINUX\n+#endif \/\/ LINUX or WINDOWS\n@@ -902,1 +904,0 @@\n-    int max;\n@@ -1200,1 +1201,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -1218,0 +1219,4 @@\n+  if (name == nullptr || name[0] == 0) {\n+    output()->print_cr(\"filename is empty or not specified.  No file written\");\n+    return;\n+  }\n@@ -1224,0 +1229,1 @@\n+#ifndef _WIN64\n@@ -1228,0 +1234,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1009,1 +1009,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -1016,1 +1016,1 @@\n-    return \"Prints an annotated process memory map of the VM process (linux only).\";\n+    return \"Prints an annotated process memory map of the VM process (linux and Windows only).\";\n@@ -1034,1 +1034,1 @@\n-    return \"Dumps an annotated process memory map to an output file (linux only).\";\n+    return \"Dumps an annotated process memory map to an output file (linux and Windows only).\";\n@@ -1045,1 +1045,1 @@\n-#endif \/\/ LINUX\n+#endif \/\/ LINUX or WINDOWS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -387,0 +387,1 @@\n+\/\/ Printing a range, with start and bytes given\n@@ -390,0 +391,4 @@\n+\/\/ Printing a range, with start and end given\n+#define RANGE2FMT             \"[\" PTR_FORMAT \" - \" PTR_FORMAT \"), (\" SIZE_FORMAT \" bytes)\"\n+#define RANGE2FMTARGS(p1, p2) p2i(p1), p2i(p2), ((uintptr_t)p2 - (uintptr_t)p1)\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -607,1 +607,1 @@\n-  static void* allocate(int max, int element_size, MEMFLAGS memflags);\n+  static void* allocate(int max, int element_size, MemTag mem_tag);\n@@ -640,3 +640,3 @@\n-  static uintptr_t bits(MEMFLAGS memflags) {\n-    assert(memflags != mtNone, \"Must provide a proper MEMFLAGS\");\n-    return (uintptr_t(memflags) << 1) | 1;\n+  static uintptr_t bits(MemTag mem_tag) {\n+    assert(mem_tag != mtNone, \"Must provide a proper MemTag\");\n+    return (uintptr_t(mem_tag) << 1) | 1;\n@@ -665,2 +665,2 @@\n-  GrowableArrayMetadata(MEMFLAGS memflags) :\n-      _bits(bits(memflags))\n+  GrowableArrayMetadata(MemTag mem_tag) :\n+      _bits(bits(mem_tag))\n@@ -695,1 +695,1 @@\n-  MEMFLAGS memflags() const { return MEMFLAGS(_bits >> 1); }\n+  MemTag mem_tag() const { return MemTag(_bits >> 1); }\n@@ -702,1 +702,1 @@\n-\/\/  - CHeap allocation: if memflags is provided\n+\/\/  - CHeap allocation: if mem_tag is provided\n@@ -724,2 +724,2 @@\n-  static E* allocate(int max, MEMFLAGS memflags) {\n-    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);\n+  static E* allocate(int max, MemTag mem_tag) {\n+    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n@@ -748,1 +748,1 @@\n-      return allocate(this->_capacity, _metadata.memflags());\n+      return allocate(this->_capacity, _metadata.mem_tag());\n@@ -772,1 +772,1 @@\n-  GrowableArray(int initial_capacity, MEMFLAGS memflags) :\n+  GrowableArray(int initial_capacity, MemTag mem_tag) :\n@@ -774,1 +774,1 @@\n-          allocate(initial_capacity, memflags),\n+          allocate(initial_capacity, mem_tag),\n@@ -776,1 +776,1 @@\n-      _metadata(memflags) {\n+      _metadata(mem_tag) {\n@@ -788,1 +788,1 @@\n-  GrowableArray(int initial_capacity, int initial_len, const E& filler, MEMFLAGS memflags) :\n+  GrowableArray(int initial_capacity, int initial_len, const E& filler, MemTag mem_tag) :\n@@ -790,1 +790,1 @@\n-          allocate(initial_capacity, memflags),\n+          allocate(initial_capacity, mem_tag),\n@@ -792,1 +792,1 @@\n-      _metadata(memflags) {\n+      _metadata(mem_tag) {\n@@ -811,4 +811,4 @@\n-\/\/ Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MEMFLAGS.\n-template <typename E, MEMFLAGS F>\n-class GrowableArrayCHeap : public GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, F> > {\n-  friend class GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, F> >;\n+\/\/ Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MemTag.\n+template <typename E, MemTag MT>\n+class GrowableArrayCHeap : public GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, MT> > {\n+  friend class GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, MT> >;\n@@ -816,1 +816,1 @@\n-  STATIC_ASSERT(F != mtNone);\n+  STATIC_ASSERT(MT != mtNone);\n@@ -818,1 +818,1 @@\n-  static E* allocate(int max, MEMFLAGS flags) {\n+  static E* allocate(int max, MemTag mem_tag) {\n@@ -823,1 +823,1 @@\n-    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), flags);\n+    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n@@ -829,1 +829,1 @@\n-    return allocate(this->_capacity, F);\n+    return allocate(this->_capacity, MT);\n@@ -838,2 +838,2 @@\n-      GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, F> >(\n-          allocate(initial_capacity, F),\n+      GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, MT> >(\n+          allocate(initial_capacity, MT),\n@@ -843,2 +843,2 @@\n-      GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, F> >(\n-          allocate(initial_capacity, F),\n+      GrowableArrayWithAllocator<E, GrowableArrayCHeap<E, MT> >(\n+          allocate(initial_capacity, MT),\n@@ -852,1 +852,1 @@\n-    return AnyObj::operator new(size, F);\n+    return AnyObj::operator new(size, MT);\n@@ -856,1 +856,1 @@\n-    return AnyObj::operator new(size, nothrow_constant, F);\n+    return AnyObj::operator new(size, nothrow_constant, MT);\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -4060,2 +4060,1 @@\n-         * Returns the number of bytes read from the input stream.\n-         * @return the number of bytes read from the input stream\n+         * {@return the number of bytes read from the input stream}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-        DROP_UNSTABLE_ATRIBUTES;\n+        DROP_UNSTABLE_ATTRIBUTES\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -253,5 +253,11 @@\n-        MethodType mtypeWithArg = mtype.appendParameterTypes(MemberName.class);\n-        if (doesAlloc)\n-            mtypeWithArg = mtypeWithArg\n-                    .insertParameterTypes(0, Object.class)  \/\/ insert newly allocated obj\n-                    .changeReturnType(void.class);          \/\/ <init> returns void\n+        MethodType mtypeWithArg;\n+        if (doesAlloc) {\n+            var ptypes = mtype.ptypes();\n+            var newPtypes = new Class<?>[ptypes.length + 2];\n+            newPtypes[0] = Object.class; \/\/ insert newly allocated obj\n+            System.arraycopy(ptypes, 0, newPtypes, 1, ptypes.length);\n+            newPtypes[newPtypes.length - 1] = MemberName.class;\n+            mtypeWithArg = MethodType.methodType(void.class, newPtypes, true);\n+        } else {\n+            mtypeWithArg = mtype.appendParameterTypes(MemberName.class);\n+        }\n@@ -273,1 +279,1 @@\n-        Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, mtype);\n@@ -823,1 +829,1 @@\n-        Name[] names = arguments(nameCursor - ARG_LIMIT, mtype.invokerType());\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, mtype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+import static java.lang.invoke.MethodHandleNatives.Constants.NESTMATE_CLASS;\n+import static java.lang.invoke.MethodHandleNatives.Constants.STRONG_LOADER_LINK;\n@@ -367,1 +369,1 @@\n-            return caller.makeHiddenClassDefiner(lambdaClassName, classBytes, Set.of(NESTMATE, STRONG), lambdaProxyClassFileDumper)\n+            return caller.makeHiddenClassDefiner(lambdaClassName, classBytes, lambdaProxyClassFileDumper, NESTMATE_CLASS | STRONG_LOADER_LINK)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1643,0 +1643,10 @@\n+\n+    static Name[] invokeArguments(int extra, MethodType types) {\n+        int length = types.parameterCount();\n+        Name[] names = new Name[length + extra + 1];\n+        names[0] = argument(0, L_TYPE);\n+        for (int i = 0; i < length; i++)\n+            names[i + 1] = argument(i + 1, basicType(types.parameterType(i)));\n+        return names;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import static java.lang.invoke.MethodHandleNatives.Constants.NESTMATE_CLASS;\n@@ -812,2 +813,1 @@\n-        MethodType lambdaType = basicType.invokerType();\n-        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n@@ -845,1 +845,1 @@\n-        lform = LambdaForm.create(lambdaType.parameterCount(), names, \/*forceInline=*\/true, Kind.GUARD);\n+        lform = LambdaForm.create(basicType.parameterCount() + 1, names, \/*forceInline=*\/true, Kind.GUARD);\n@@ -872,2 +872,0 @@\n-        MethodType lambdaType = basicType.invokerType();\n-\n@@ -892,1 +890,1 @@\n-        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n@@ -921,1 +919,1 @@\n-        lform = LambdaForm.create(lambdaType.parameterCount(), names, Kind.GUARD_WITH_CATCH);\n+        lform = LambdaForm.create(basicType.parameterCount() + 1, names, Kind.GUARD_WITH_CATCH);\n@@ -1114,1 +1112,1 @@\n-                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE), dumper())\n+                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, dumper(), NESTMATE_CLASS)\n@@ -1741,2 +1739,0 @@\n-        MethodType lambdaType = basicType.invokerType();\n-\n@@ -1757,1 +1753,1 @@\n-            Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+            Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n@@ -1785,1 +1781,1 @@\n-                    LambdaForm.create(lambdaType.parameterCount(), names, Kind.LOOP));\n+                    LambdaForm.create(basicType.parameterCount() + 1, names, Kind.LOOP));\n@@ -1974,2 +1970,0 @@\n-        MethodType lambdaType = basicType.invokerType();\n-\n@@ -1993,1 +1987,1 @@\n-        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n@@ -2019,1 +2013,1 @@\n-        lform = LambdaForm.create(lambdaType.parameterCount(), names, Kind.TRY_FINALLY);\n+        lform = LambdaForm.create(basicType.parameterCount() + 1, names, Kind.TRY_FINALLY);\n@@ -2063,1 +2057,0 @@\n-        MethodType lambdaType = basicType.invokerType();\n@@ -2096,1 +2089,1 @@\n-        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n@@ -2114,1 +2107,1 @@\n-        LambdaForm lform = LambdaForm.create(lambdaType.parameterCount(), names, CALL_NEW_ARRAY, Kind.COLLECTOR);\n+        LambdaForm lform = LambdaForm.create(basicType.parameterCount() + 1, names, CALL_NEW_ARRAY, Kind.COLLECTOR);\n@@ -2177,2 +2170,0 @@\n-        MethodType lambdaType = basicType.invokerType();\n-\n@@ -2210,1 +2201,1 @@\n-        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n@@ -2239,1 +2230,1 @@\n-        lform = LambdaForm.create(lambdaType.parameterCount(), names, Kind.TABLE_SWITCH);\n+        lform = LambdaForm.create(basicType.parameterCount() + 1, names, Kind.TABLE_SWITCH);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-        var definer = new Lookup(intfc).makeHiddenClassDefiner(className, template, Set.of(), DUMPER);\n+        var definer = new Lookup(intfc).makeHiddenClassDefiner(className, template, DUMPER);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1909,1 +1909,1 @@\n-            static int optionsToFlag(Set<ClassOption> options) {\n+            static int optionsToFlag(ClassOption[] options) {\n@@ -1912,0 +1912,3 @@\n+                    if ((flags & cp.flag) != 0) {\n+                        throw new IllegalArgumentException(\"Duplicate ClassOption \" + cp);\n+                    }\n@@ -2129,2 +2132,1 @@\n-            Objects.requireNonNull(options);\n-\n+            int flags = ClassOption.optionsToFlag(options);\n@@ -2136,1 +2138,1 @@\n-            return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false).defineClassAsLookup(initialize);\n+            return makeHiddenClassDefiner(bytes.clone(), false, flags).defineClassAsLookup(initialize);\n@@ -2216,1 +2218,2 @@\n-            Objects.requireNonNull(options);\n+\n+            int flags = ClassOption.optionsToFlag(options);\n@@ -2223,1 +2226,1 @@\n-            return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false)\n+            return makeHiddenClassDefiner(bytes.clone(), false, flags)\n@@ -2369,1 +2372,1 @@\n-            return makeHiddenClassDefiner(cf, Set.of(), false, dumper);\n+            return makeHiddenClassDefiner(cf, false, dumper, 0);\n@@ -2381,1 +2384,1 @@\n-         * @param options class options\n+         * @param flags   class option flag mask\n@@ -2389,2 +2392,2 @@\n-                                                    Set<ClassOption> options,\n-                                                    boolean accessVmAnnotations) {\n+                                                    boolean accessVmAnnotations,\n+                                                    int flags) {\n@@ -2392,1 +2395,16 @@\n-            return makeHiddenClassDefiner(cf, options, accessVmAnnotations, defaultDumper());\n+            return makeHiddenClassDefiner(cf, accessVmAnnotations, defaultDumper(), flags);\n+        }\n+\n+        \/**\n+         * Returns a ClassDefiner that creates a {@code Class} object of a hidden class\n+         * from the given bytes and the given options.  No package name check on the given bytes.\n+         *\n+         * @param name    internal name that specifies the prefix of the hidden class\n+         * @param bytes   class bytes\n+         * @param dumper  dumper to write the given bytes to the dumper's output directory\n+         * @return ClassDefiner that defines a hidden class of the given bytes and options.\n+         *\/\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper) {\n+            Objects.requireNonNull(dumper);\n+            \/\/ skip name and access flags validation\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, 0);\n@@ -2401,1 +2419,1 @@\n-         * @param options class options\n+         * @param flags   class options flag mask\n@@ -2405,1 +2423,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options, ClassFileDumper dumper) {\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, ClassFileDumper dumper, int flags) {\n@@ -2408,1 +2426,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false, dumper);\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), false, dumper, flags);\n@@ -2416,1 +2434,1 @@\n-         * @param options class options\n+         * @param flags class option flag mask\n@@ -2421,3 +2439,3 @@\n-                                                    Set<ClassOption> options,\n-                                                    ClassFileDumper dumper) {\n-            int flags = HIDDEN_CLASS | ClassOption.optionsToFlag(options);\n+                                                    ClassFileDumper dumper,\n+                                                    int flags) {\n+            flags |= HIDDEN_CLASS;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":36,"deletions":18,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -299,1 +299,6 @@\n-    public static final long LAMBDA_METHOD = 1L<<49;\n+    public static final long LAMBDA_METHOD = 1L<<49; \/\/MethodSymbols only\n+\n+    \/**\n+     * Flag that marks a synthetic local capture field in a local\/anon class\n+     *\/\n+    public static final long LOCAL_CAPTURE_FIELD = 1L<<49; \/\/VarSymbols only\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+        initBlockType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);\n@@ -641,0 +642,1 @@\n+    final MethodType initBlockType;\n@@ -1447,1 +1449,1 @@\n-                    env.info.scope.owner.flags() & STRICTFP, names.empty, null,\n+                    env.info.scope.owner.flags() & STRICTFP, names.empty, initBlockType,\n@@ -3555,14 +3557,0 @@\n-        \/* Map to hold 'fake' clinit methods. If a lambda is used to initialize a\n-         * static field and that lambda has type annotations, these annotations will\n-         * also be stored at these fake clinit methods.\n-         *\n-         * LambdaToMethod also use fake clinit methods so they can be reused.\n-         * Also as LTM is a phase subsequent to attribution, the methods from\n-         * clinits can be safely removed by LTM to save memory.\n-         *\/\n-        private Map<ClassSymbol, MethodSymbol> clinits = new HashMap<>();\n-\n-        public MethodSymbol removeClinit(ClassSymbol sym) {\n-            return clinits.remove(sym);\n-        }\n-\n@@ -3573,5 +3561,2 @@\n-         * is not a method, for example if the lambda is used to initialize\n-         * a field, then if the field is:\n-         *\n-         * - an instance field, we use the first constructor.\n-         * - a static field, we create a fake clinit method.\n+         * is not a method (e.g. if the lambda occurs in a field initializer), then\n+         * a synthetic method symbol owner is created.\n@@ -3583,1 +3568,3 @@\n-                \/\/field initializer\n+                \/\/ If the lambda is nested in a field initializer, we need to create a fake init method.\n+                \/\/ Uniqueness of this symbol is not important (as e.g. annotations will be added on the\n+                \/\/ init symbol's owner).\n@@ -3585,26 +3572,5 @@\n-                Symbol newScopeOwner = env.info.scope.owner;\n-                \/* if the field isn't static, then we can get the first constructor\n-                 * and use it as the owner of the environment. This is what\n-                 * LTM code is doing to look for type annotations so we are fine.\n-                 *\/\n-                if ((owner.flags() & STATIC) == 0) {\n-                    for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {\n-                        newScopeOwner = s;\n-                        break;\n-                    }\n-                } else {\n-                    \/* if the field is static then we need to create a fake clinit\n-                     * method, this method can later be reused by LTM.\n-                     *\/\n-                    MethodSymbol clinit = clinits.get(enclClass);\n-                    if (clinit == null) {\n-                        Type clinitType = new MethodType(List.nil(),\n-                                syms.voidType, List.nil(), syms.methodClass);\n-                        clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,\n-                                names.clinit, clinitType, enclClass);\n-                        clinit.params = List.nil();\n-                        clinits.put(enclClass, clinit);\n-                    }\n-                    newScopeOwner = clinit;\n-                }\n-                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));\n+                Name initName = owner.isStatic() ? names.clinit : names.init;\n+                MethodSymbol initSym = new MethodSymbol(BLOCK | (owner.isStatic() ? STATIC : 0) | SYNTHETIC | PRIVATE,\n+                        initName, initBlockType, enclClass);\n+                initSym.params = List.nil();\n+                lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(initSym)));\n@@ -3967,0 +3933,1 @@\n+            fExpr.owner = env.info.scope.owner;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":14,"deletions":47,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -277,4 +277,1 @@\n-     *  from a local class. There is only one case; all other cases simply\n-     *  traverse down the tree. This class doesn't deal with the specific\n-     *  of Lower - it's an abstract visitor that is meant to be reused in\n-     *  order to share the local variable capture logic.\n+     *  from a local class.\n@@ -282,1 +279,1 @@\n-    abstract class BasicFreeVarCollector extends TreeScanner {\n+    class FreeVarCollector extends CaptureScanner {\n@@ -284,4 +281,3 @@\n-        \/** Add all free variables of class c to fvs list\n-         *  unless they are already there.\n-         *\/\n-        abstract void addFreeVars(ClassSymbol c);\n+        FreeVarCollector(JCTree ownerTree) {\n+            super(ownerTree);\n+        }\n@@ -289,5 +285,7 @@\n-        \/** If tree refers to a variable in owner of local class, add it to\n-         *  free variables list.\n-         *\/\n-        public void visitIdent(JCIdent tree) {\n-            visitSymbol(tree.sym);\n+        void addFreeVars(ClassSymbol c) {\n+            List<VarSymbol> fvs = freevarCache.get(c);\n+            if (fvs != null) {\n+                for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {\n+                    addFreeVar(l.head);\n+                }\n+            }\n@@ -295,2 +293,0 @@\n-        \/\/ where\n-        abstract void visitSymbol(Symbol _sym);\n@@ -316,78 +312,0 @@\n-\n-        @Override\n-        public void visitYield(JCYield tree) {\n-            scan(tree.value);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Lower-specific subclass of {@code BasicFreeVarCollector}.\n-     *\/\n-    class FreeVarCollector extends BasicFreeVarCollector {\n-\n-        \/** The owner of the local class.\n-         *\/\n-        Symbol owner;\n-\n-        \/** The local class.\n-         *\/\n-        ClassSymbol clazz;\n-\n-        \/** The list of owner's variables accessed from within the local class,\n-         *  without any duplicates.\n-         *\/\n-        List<VarSymbol> fvs;\n-\n-        FreeVarCollector(ClassSymbol clazz) {\n-            this.clazz = clazz;\n-            this.owner = clazz.owner;\n-            this.fvs = List.nil();\n-        }\n-\n-        \/** Add free variable to fvs list unless it is already there.\n-         *\/\n-        private void addFreeVar(VarSymbol v) {\n-            for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail)\n-                if (l.head == v) return;\n-            fvs = fvs.prepend(v);\n-        }\n-\n-        @Override\n-        void addFreeVars(ClassSymbol c) {\n-            List<VarSymbol> fvs = freevarCache.get(c);\n-            if (fvs != null) {\n-                for (List<VarSymbol> l = fvs; l.nonEmpty(); l = l.tail) {\n-                    addFreeVar(l.head);\n-                }\n-            }\n-        }\n-\n-        @Override\n-        void visitSymbol(Symbol _sym) {\n-            Symbol sym = _sym;\n-            if (sym.kind == VAR || sym.kind == MTH) {\n-                if (sym != null && sym.owner != owner)\n-                    sym = proxies.get(sym);\n-                if (sym != null && sym.owner == owner) {\n-                    VarSymbol v = (VarSymbol)sym;\n-                    if (v.getConstValue() == null) {\n-                        addFreeVar(v);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    ClassSymbol ownerToCopyFreeVarsFrom(ClassSymbol c) {\n-        if (!c.isDirectlyOrIndirectlyLocal()) {\n-            return null;\n-        }\n-        Symbol currentOwner = c.owner;\n-        while (currentOwner.owner.kind.matches(KindSelector.TYP) && currentOwner.isDirectlyOrIndirectlyLocal()) {\n-            currentOwner = currentOwner.owner;\n-        }\n-        if (currentOwner.owner.kind.matches(KindSelector.VAL_MTH) && c.isSubClass(currentOwner, types)) {\n-            return (ClassSymbol)currentOwner;\n-        }\n-        return null;\n@@ -405,16 +323,4 @@\n-        if (c.owner.kind.matches(KindSelector.VAL_MTH) && !c.isStatic()) {\n-            FreeVarCollector collector = new FreeVarCollector(c);\n-            collector.scan(classDef(c));\n-            fvs = collector.fvs;\n-            freevarCache.put(c, fvs);\n-            return fvs;\n-        } else {\n-            ClassSymbol owner = ownerToCopyFreeVarsFrom(c);\n-            if (owner != null) {\n-                fvs = freevarCache.get(owner);\n-                freevarCache.put(c, fvs);\n-                return fvs;\n-            } else {\n-                return List.nil();\n-            }\n-        }\n+        FreeVarCollector collector = new FreeVarCollector(classDef(c));\n+        fvs = collector.analyzeCaptures().reverse();\n+        freevarCache.put(c, fvs);\n+        return fvs;\n@@ -1513,0 +1419,4 @@\n+    List<JCVariableDecl> freevarDefs(int pos, List<VarSymbol> freevars, Symbol owner) {\n+        return freevarDefs(pos, freevars, owner, LOCAL_CAPTURE_FIELD);\n+    }\n+\n@@ -1526,1 +1436,6 @@\n-                flags, proxyName, v.erasure(types), owner);\n+                flags, proxyName, v.erasure(types), owner) {\n+                @Override\n+                public Symbol baseSymbol() {\n+                    return v;\n+                }\n+            };\n@@ -2266,1 +2181,1 @@\n-            tree.pos, freevars(currentClass), currentClass, allowValueClasses && currentClass.isValueClass() ? STRICT : 0);\n+            tree.pos, freevars(currentClass), currentClass, allowValueClasses && currentClass.isValueClass() ? STRICT : LOCAL_CAPTURE_FIELD);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":27,"deletions":112,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-            (c.owner.type == null \/\/ local to init block\n+            ((c.owner.flags() & BLOCK) != 0 \/\/ local to init block\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,5 @@\n+compiler\/valhalla\/inlinetypes\/TestArrays.java              8343346 generic-all\n+compiler\/valhalla\/inlinetypes\/TestBasicFunctionality.java  8343346 generic-all\n+compiler\/valhalla\/inlinetypes\/TestLWorld.java              8343346 generic-all\n+compiler\/valhalla\/inlinetypes\/TestLWorldProfiling.java     8343346 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-        String optoRegex = \"(.*precise .*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        String optoRegex = \"(.*precise .*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_instance\" + END;\n@@ -285,1 +285,1 @@\n-        String regex = \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: _new_instance_Java\" + END;\n+        String regex = \"(.*precise .*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_instance\" + END;\n@@ -291,1 +291,1 @@\n-        String optoRegex = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|mv|xor|nop|spill|pushq|popq).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        String optoRegex = \"(.*precise \\\\[.*\\\\R((.*(?i:mov|mv|xor|nop|spill|pushq|popq).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_array\" + END;\n@@ -297,1 +297,1 @@\n-        String regex = \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: _new_array_Java\" + END;\n+        String regex = \"(.*precise \\\\[.*\" + IS_REPLACED + \":.*\\\\R((.*(?i:mov|mv|xorl|nop|spill|pushq|popq).*|\\\\s*|.*(LGHI|LI).*)\\\\R)*.*(?i:call,static).*wrapper for: C2 Runtime new_array\" + END;\n@@ -517,0 +517,5 @@\n+    public static final String DIV_I = PREFIX + \"DIV_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_I, \"DivI\");\n+    }\n+\n@@ -522,0 +527,10 @@\n+    public static final String DIV_MOD_I = PREFIX + \"DIV_MOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_MOD_I, \"DivModI\");\n+    }\n+\n+    public static final String DIV_MOD_L = PREFIX + \"DIV_MOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(DIV_MOD_L, \"DivModL\");\n+    }\n+\n@@ -1005,0 +1020,10 @@\n+    public static final String MOD_I = PREFIX + \"MOD_I\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOD_I, \"ModI\");\n+    }\n+\n+    public static final String MOD_L = PREFIX + \"MOD_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MOD_L, \"ModL\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -136,0 +136,3 @@\n+java\/awt\/Focus\/TestDisabledAutoTransfer.java 8159871 macosx-all,windows-all\n+java\/awt\/Focus\/TestDisabledAutoTransferSwing.java 6962362 windows-all\n+java\/awt\/Focus\/ActivateOnProperAppContextTest.java 8136516 macosx-all\n@@ -572,2 +575,0 @@\n-java\/nio\/file\/Path\/ToRealPath.java                              8315273 windows-all\n-\n@@ -723,0 +724,1 @@\n+java\/util\/zip\/CloseInflaterDeflaterTest.java  8339216 linux-s390x\n@@ -800,0 +802,2 @@\n+java\/awt\/PopupMenu\/PopupHangTest.java 8340022 windows-all\n+java\/awt\/Focus\/MinimizeNonfocusableWindowTest.java 8024487 windows-all\n","filename":"test\/jdk\/ProblemList.txt","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}