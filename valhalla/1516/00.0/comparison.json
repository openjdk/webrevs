{"files":[{"patch":"@@ -103,1 +103,1 @@\n-    --override-methods=summary\n+    --override-methods=summary --syntax-highlight\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -523,1 +523,4 @@\n-  UBSAN_CFLAGS=\"$UBSAN_CHECKS -Wno-stringop-truncation -Wno-format-overflow -Wno-array-bounds -Wno-stringop-overflow -fno-omit-frame-pointer -DUNDEFINED_BEHAVIOR_SANITIZER\"\n+  UBSAN_CFLAGS=\"$UBSAN_CHECKS -Wno-array-bounds -fno-omit-frame-pointer -DUNDEFINED_BEHAVIOR_SANITIZER\"\n+  if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\"; then\n+    UBSAN_CFLAGS=\"$UBSAN_CFLAGS -Wno-format-overflow -Wno-stringop-overflow -Wno-stringop-truncation\"\n+  fi\n@@ -525,0 +528,10 @@\n+  # On AIX, the llvm_symbolizer is not found out of the box, so we have to provide the\n+  # full qualified llvm_symbolizer path in the __ubsan_default_options() function in\n+  # make\/data\/ubsan\/ubsan_default_options.c. To get it there we compile our sources\n+  # with an additional define LLVM_SYMBOLIZER, which we set here.\n+  # To calculate the correct llvm_symbolizer path we can use the location of the compiler, because\n+  # their relation is fixed.\n+  if test \"x$TOOLCHAIN_TYPE\" = \"xclang\" && test \"x$OPENJDK_TARGET_OS\" = \"xaix\"; then\n+      UBSAN_CFLAGS=\"$UBSAN_CFLAGS -fno-sanitize=function,vptr -DLLVM_SYMBOLIZER=$(dirname $(dirname $CC))\/tools\/ibm-llvm-symbolizer\"\n+      UBSAN_LDFLAGS=\"$UBSAN_LDFLAGS -fno-sanitize=function,vptr -Wl,-bbigtoc\"\n+  fi\n","filename":"make\/autoconf\/jdk-options.m4","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1093,1 +1093,1 @@\n-        windows_x64: \"VS2022-17.6.5+1.0\",\n+        windows_x64: \"VS2022-17.13.2+1.0\",\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2293,0 +2293,20 @@\n+    case Op_FmaHF:\n+      \/\/ UseFMA flag also needs to be checked along with FEAT_FP16\n+      if (!UseFMA || !is_feat_fp16_supported()) {\n+        return false;\n+      }\n+      break;\n+    case Op_AddHF:\n+    case Op_SubHF:\n+    case Op_MulHF:\n+    case Op_DivHF:\n+    case Op_MinHF:\n+    case Op_MaxHF:\n+    case Op_SqrtHF:\n+      \/\/ Half-precision floating point scalar operations require FEAT_FP16\n+      \/\/ to be available. FEAT_FP16 is enabled if both \"fphp\" and \"asimdhp\"\n+      \/\/ features are supported.\n+      if (!is_feat_fp16_supported()) {\n+        return false;\n+      }\n+      break;\n@@ -2303,1 +2323,1 @@\n-  return EnableVectorSupport && UseVectorStubs;\n+  return EnableVectorSupport;\n@@ -2307,1 +2327,1 @@\n-  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(EnableVectorSupport, \"sanity\");\n@@ -4627,0 +4647,9 @@\n+\/\/ Half Float (FP16) Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -6970,0 +6999,15 @@\n+\/\/ Load Half Float Constant\n+\/\/ The \"ldr\" instruction loads a 32-bit word from the constant pool into a\n+\/\/ 32-bit register but only the bottom half will be populated and the top\n+\/\/ 16 bits are zero.\n+instruct loadConH(vRegF dst, immH con) %{\n+  match(Set dst con);\n+  format %{\n+    \"ldrs $dst, [$constantaddress]\\t# load from constant table: half float=$con\\n\\t\"\n+  %}\n+  ins_encode %{\n+    __ ldrs(as_FloatRegister($dst$$reg), $constantaddress($con));\n+  %}\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n@@ -8202,0 +8246,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8211,0 +8256,13 @@\n+instruct castII_checked(iRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castII_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -8213,0 +8271,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -8222,0 +8281,13 @@\n+instruct castLL_checked(iRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastLL dst));\n+  effect(KILL cr);\n+\n+  format %{ \"# castLL_checked of $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -13664,0 +13736,11 @@\n+instruct addHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (AddHF src1 src2));\n+  format %{ \"faddh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ faddh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13694,0 +13777,11 @@\n+instruct subHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (SubHF src1 src2));\n+  format %{ \"fsubh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fsubh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13724,0 +13818,11 @@\n+instruct mulHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MulHF src1 src2));\n+  format %{ \"fmulh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fmulh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n@@ -13754,0 +13859,14 @@\n+\/\/ src1 * src2 + src3 (half-precision float)\n+instruct maddHF_reg_reg(vRegF dst, vRegF src1, vRegF src2, vRegF src3) %{\n+  match(Set dst (FmaHF src3 (Binary src1 src2)));\n+  format %{ \"fmaddh $dst, $src1, $src2, $src3\" %}\n+  ins_encode %{\n+    assert(UseFMA, \"Needs FMA instructions support.\");\n+    __ fmaddh($dst$$FloatRegister,\n+              $src1$$FloatRegister,\n+              $src2$$FloatRegister,\n+              $src3$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -13895,0 +14014,23 @@\n+\/\/ Math.max(HH)H (half-precision float)\n+instruct maxHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MaxHF src1 src2));\n+  format %{ \"fmaxh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fmaxh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+\/\/ Math.min(HH)H (half-precision float)\n+instruct minHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (MinHF src1 src2));\n+  format %{ \"fminh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fminh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n@@ -13952,0 +14094,10 @@\n+instruct divHF_reg_reg(vRegF dst, vRegF src1, vRegF src2) %{\n+  match(Set dst (DivHF src1  src2));\n+  format %{ \"fdivh $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ fdivh($dst$$FloatRegister,\n+             $src1$$FloatRegister,\n+             $src2$$FloatRegister);\n+  %}\n+  ins_pipe(fp_div_s);\n+%}\n@@ -14125,0 +14277,10 @@\n+instruct sqrtHF_reg(vRegF dst, vRegF src) %{\n+  match(Set dst (SqrtHF src));\n+  format %{ \"fsqrth $dst, $src\" %}\n+  ins_encode %{\n+    __ fsqrth($dst$$FloatRegister,\n+              $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_div_s);\n+%}\n+\n@@ -17211,0 +17373,58 @@\n+\/\/----------------------------- Reinterpret ----------------------------------\n+\/\/ Reinterpret a half-precision float value in a floating point register to a general purpose register\n+instruct reinterpretHF2S(iRegINoSp dst, vRegF src) %{\n+  match(Set dst (ReinterpretHF2S src));\n+  format %{ \"reinterpretHF2S $dst, $src\" %}\n+  ins_encode %{\n+    __ smov($dst$$Register, $src$$FloatRegister, __ H, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Reinterpret a half-precision float value in a general purpose register to a floating point register\n+instruct reinterpretS2HF(vRegF dst, iRegINoSp src) %{\n+  match(Set dst (ReinterpretS2HF src));\n+  format %{ \"reinterpretS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ mov($dst$$FloatRegister, __ H, 0, $src$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Without this optimization, ReinterpretS2HF (ConvF2HF src) would result in the following\n+\/\/ instructions (the first two are for ConvF2HF and the last instruction is for ReinterpretS2HF) -\n+\/\/ fcvt $tmp1_fpr, $src_fpr    \/\/ Convert float to half-precision float\n+\/\/ mov  $tmp2_gpr, $tmp1_fpr   \/\/ Move half-precision float in FPR to a GPR\n+\/\/ mov  $dst_fpr,  $tmp2_gpr   \/\/ Move the result from a GPR to an FPR\n+\/\/ The move from FPR to GPR in ConvF2HF and the move from GPR to FPR in ReinterpretS2HF\n+\/\/ can be omitted in this pattern, resulting in -\n+\/\/ fcvt $dst, $src  \/\/ Convert float to half-precision float\n+instruct convF2HFAndS2HF(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvtsh($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Without this optimization, ConvHF2F (ReinterpretHF2S src) would result in the following\n+\/\/ instructions (the first one is for ReinterpretHF2S and the last two are for ConvHF2F) -\n+\/\/ mov  $tmp1_gpr, $src_fpr  \/\/ Move the half-precision float from an FPR to a GPR\n+\/\/ mov  $tmp2_fpr, $tmp1_gpr \/\/ Move the same value from GPR to an FPR\n+\/\/ fcvt $dst_fpr,  $tmp2_fpr \/\/ Convert the half-precision float to 32-bit float\n+\/\/ The move from FPR to GPR in ReinterpretHF2S and the move from GPR to FPR in ConvHF2F\n+\/\/ can be omitted as the input (src) is already in an FPR required for the fcvths instruction\n+\/\/ resulting in -\n+\/\/ fcvt $dst, $src  \/\/ Convert half-precision float to a 32-bit float\n+instruct convHF2SAndHF2F(vRegF dst, vRegF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvths($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":223,"deletions":3,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    debug_only(__ should_not_reach_here());\n+    DEBUG_ONLY(__ should_not_reach_here());\n@@ -93,1 +93,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -106,1 +106,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -359,1 +359,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -374,1 +374,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2772,0 +2772,104 @@\n+\n+static void abort_verify_int_in_range(uint idx, jint val, jint lo, jint hi) {\n+  fatal(\"Invalid CastII, idx: %u, val: %d, lo: %d, hi: %d\", idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_int_in_range(uint idx, const TypeInt* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeInt::INT) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_int_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jint lo = t->_lo;\n+  jint hi = t->_hi;\n+\n+  if (lo != min_jint && hi != max_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jint) {\n+    subsw(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jint) {\n+    subsw(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  movw(c_rarg2, lo);\n+  movw(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_int_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_int_in_range\");\n+}\n+\n+static void abort_verify_long_in_range(uint idx, jlong val, jlong lo, jlong hi) {\n+  fatal(\"Invalid CastLL, idx: %u, val: \" JLONG_FORMAT \", lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_long_in_range(uint idx, const TypeLong* t, Register rval, Register rtmp) {\n+  assert(!t->empty() && !t->singleton(), \"%s\", Type::str(t));\n+  if (t == TypeLong::LONG) {\n+    return;\n+  }\n+  BLOCK_COMMENT(\"verify_long_in_range {\");\n+  Label L_success, L_failure;\n+\n+  jlong lo = t->_lo;\n+  jlong hi = t->_hi;\n+\n+  if (lo != min_jlong && hi != max_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::LT, L_failure);\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else if (lo != min_jlong) {\n+    subs(rtmp, rval, lo);\n+    br(Assembler::GE, L_success);\n+  } else if (hi != max_jlong) {\n+    subs(rtmp, rval, hi);\n+    br(Assembler::LE, L_success);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  bind(L_failure);\n+  movw(c_rarg0, idx);\n+  mov(c_rarg1, rval);\n+  mov(c_rarg2, lo);\n+  mov(c_rarg3, hi);\n+  reconstruct_frame_pointer(rtmp);\n+  rt_call(CAST_FROM_FN_PTR(address, abort_verify_long_in_range), rtmp);\n+  hlt(0);\n+\n+  bind(L_success);\n+  BLOCK_COMMENT(\"} verify_long_in_range\");\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rfp.\n+    add(rtmp, sp, framesize - 2 * wordSize);\n+    Label L_success;\n+    cmp(rfp, rtmp);\n+    br(Assembler::EQ, L_success);\n+    stop(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    add(rfp, sp, framesize - 2 * wordSize);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -193,0 +193,5 @@\n+  void verify_int_in_range(uint idx, const TypeInt* t, Register val, Register tmp);\n+  void verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp);\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-    debug_only(cmp2.verify());\n+    DEBUG_ONLY(cmp2.verify());\n@@ -205,1 +205,1 @@\n-      debug_only(cmp3.verify());\n+      DEBUG_ONLY(cmp3.verify());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1011,3 +1011,0 @@\n-  \/\/ address const_ptr = long_constant((jlong)Universe::non_oop_word());\n-  \/\/ uintptr_t offset;\n-  \/\/ ldr_constant(rscratch2, const_ptr);\n@@ -5687,1 +5684,1 @@\n-    ldr_constant(dst, Address(dummy, rspec));\n+    ldr(dst, Address(dummy, rspec));\n@@ -5689,1 +5686,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1548,10 +1548,0 @@\n-  void ldr_constant(Register dest, const Address &const_addr) {\n-    if (NearCpool) {\n-      ldr(dest, const_addr);\n-    } else {\n-      uint64_t offset;\n-      adrp(dest, InternalAddress(const_addr.target()), offset);\n-      ldr(dest, Address(dest, offset));\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -11191,73 +11191,0 @@\n-  void generate_vector_math_stubs() {\n-    \/\/ Get native vector math stub routine addresses\n-    void* libsleef = nullptr;\n-    char ebuf[1024];\n-    char dll_name[JVM_MAXPATHLEN];\n-    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n-      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-    }\n-    if (libsleef == nullptr) {\n-      log_info(library)(\"Failed to load native vector math library, %s!\", ebuf);\n-      return;\n-    }\n-    \/\/ Method naming convention\n-    \/\/   All the methods are named as <OP><T><N>_<U><suffix>\n-    \/\/   Where:\n-    \/\/     <OP>     is the operation name, e.g. sin\n-    \/\/     <T>      is optional to indicate float\/double\n-    \/\/              \"f\/d\" for vector float\/double operation\n-    \/\/     <N>      is the number of elements in the vector\n-    \/\/              \"2\/4\" for neon, and \"x\" for sve\n-    \/\/     <U>      is the precision level\n-    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n-    \/\/               We use \"u10\" for all operations by default\n-    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n-    \/\/     <suffix> indicates neon\/sve\n-    \/\/              \"sve\/advsimd\" for sve\/neon implementations\n-    \/\/     e.g. sinfx_u10sve is the method for computing vector float sin using SVE instructions\n-    \/\/          cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n-    \/\/\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n-\n-    \/\/ Math vector stubs implemented with SVE for scalable vector size.\n-    if (UseSVE > 0) {\n-      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-        \/\/ Skip \"tanh\" because there is performance regression\n-        if (vop == VectorSupport::VECTOR_OP_TANH) {\n-          continue;\n-        }\n-\n-        \/\/ The native library does not support u10 level of \"hypot\".\n-        const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-        snprintf(ebuf, sizeof(ebuf), \"%sfx_%ssve\", VectorSupport::mathname[op], ulf);\n-        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-        snprintf(ebuf, sizeof(ebuf), \"%sdx_%ssve\", VectorSupport::mathname[op], ulf);\n-        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-      }\n-    }\n-\n-    \/\/ Math vector stubs implemented with NEON for 64\/128 bits vector size.\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      \/\/ Skip \"tanh\" because there is performance regression\n-      if (vop == VectorSupport::VECTOR_OP_TANH) {\n-        continue;\n-      }\n-\n-      \/\/ The native library does not support u10 level of \"hypot\".\n-      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"%sd2_%sadvsimd\", VectorSupport::mathname[op], ulf);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libsleef, ebuf);\n-    }\n-  }\n-\n@@ -11553,2 +11480,0 @@\n-    generate_vector_math_stubs();\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -461,1 +461,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -468,1 +468,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -475,1 +475,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -481,1 +481,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -487,1 +487,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -492,1 +492,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -504,1 +504,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -512,1 +512,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n@@ -518,1 +518,1 @@\n-  debug_only(verify_esp(Z_esp, Z_R1_scratch));\n+  DEBUG_ONLY(verify_esp(Z_esp, Z_R1_scratch));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    debug_only(__ should_not_reach_here());\n+    DEBUG_ONLY(__ should_not_reach_here());\n@@ -92,1 +92,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -105,1 +105,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -115,1 +115,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -491,1 +491,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n@@ -505,1 +505,1 @@\n-  debug_only(__ should_not_reach_here());\n+  DEBUG_ONLY(__ should_not_reach_here());\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -819,0 +819,113 @@\n+static void abort_verify_int_in_range(uint idx, jint val, jint lo, jint hi) {\n+  fatal(\"Invalid CastII, idx: %u, val: %d, lo: %d, hi: %d\", idx, val, lo, hi);\n+}\n+\n+static void reconstruct_frame_pointer_helper(MacroAssembler* masm, Register dst) {\n+  const int framesize = Compile::current()->output()->frame_size_in_bytes();\n+  masm->movptr(dst, rsp);\n+  if (framesize > 2 * wordSize) {\n+    masm->addptr(dst, framesize - 2 * wordSize);\n+  }\n+}\n+\n+void C2_MacroAssembler::reconstruct_frame_pointer(Register rtmp) {\n+  if (PreserveFramePointer) {\n+    \/\/ frame pointer is valid\n+#ifdef ASSERT\n+    \/\/ Verify frame pointer value in rbp.\n+    reconstruct_frame_pointer_helper(this, rtmp);\n+    Label L_success;\n+    cmpq(rbp, rtmp);\n+    jccb(Assembler::equal, L_success);\n+    STOP(\"frame pointer mismatch\");\n+    bind(L_success);\n+#endif \/\/ ASSERT\n+  } else {\n+    reconstruct_frame_pointer_helper(this, rbp);\n+  }\n+}\n+\n+void C2_MacroAssembler::verify_int_in_range(uint idx, const TypeInt* t, Register val) {\n+  jint lo = t->_lo;\n+  jint hi = t->_hi;\n+  assert(lo < hi, \"type should not be empty or constant, idx: %u, lo: %d, hi: %d\", idx, lo, hi);\n+  if (t == TypeInt::INT) {\n+    return;\n+  }\n+\n+  BLOCK_COMMENT(\"CastII {\");\n+  Label fail;\n+  Label succeed;\n+  if (hi == max_jint) {\n+    cmpl(val, lo);\n+    jccb(Assembler::greaterEqual, succeed);\n+  } else {\n+    if (lo != min_jint) {\n+      cmpl(val, lo);\n+      jccb(Assembler::less, fail);\n+    }\n+    cmpl(val, hi);\n+    jccb(Assembler::lessEqual, succeed);\n+  }\n+\n+  bind(fail);\n+  movl(c_rarg0, idx);\n+  movl(c_rarg1, val);\n+  movl(c_rarg2, lo);\n+  movl(c_rarg3, hi);\n+  reconstruct_frame_pointer(rscratch1);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, abort_verify_int_in_range)));\n+  hlt();\n+  bind(succeed);\n+  BLOCK_COMMENT(\"} \/\/ CastII\");\n+}\n+\n+static void abort_verify_long_in_range(uint idx, jlong val, jlong lo, jlong hi) {\n+  fatal(\"Invalid CastLL, idx: %u, val: \" JLONG_FORMAT \", lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, val, lo, hi);\n+}\n+\n+void C2_MacroAssembler::verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp) {\n+  jlong lo = t->_lo;\n+  jlong hi = t->_hi;\n+  assert(lo < hi, \"type should not be empty or constant, idx: %u, lo: \" JLONG_FORMAT \", hi: \" JLONG_FORMAT, idx, lo, hi);\n+  if (t == TypeLong::LONG) {\n+    return;\n+  }\n+\n+  BLOCK_COMMENT(\"CastLL {\");\n+  Label fail;\n+  Label succeed;\n+\n+  auto cmp_val = [&](jlong bound) {\n+    if (is_simm32(bound)) {\n+      cmpq(val, checked_cast<int>(bound));\n+    } else {\n+      mov64(tmp, bound);\n+      cmpq(val, tmp);\n+    }\n+  };\n+\n+  if (hi == max_jlong) {\n+    cmp_val(lo);\n+    jccb(Assembler::greaterEqual, succeed);\n+  } else {\n+    if (lo != min_jlong) {\n+      cmp_val(lo);\n+      jccb(Assembler::less, fail);\n+    }\n+    cmp_val(hi);\n+    jccb(Assembler::lessEqual, succeed);\n+  }\n+\n+  bind(fail);\n+  movl(c_rarg0, idx);\n+  movq(c_rarg1, val);\n+  mov64(c_rarg2, lo);\n+  mov64(c_rarg3, hi);\n+  reconstruct_frame_pointer(rscratch1);\n+  call(RuntimeAddress(CAST_FROM_FN_PTR(address, abort_verify_long_in_range)));\n+  hlt();\n+  bind(succeed);\n+  BLOCK_COMMENT(\"} \/\/ CastLL\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+  void verify_int_in_range(uint idx, const TypeInt* t, Register val);\n+  void verify_long_in_range(uint idx, const TypeLong* t, Register val, Register tmp);\n+\n@@ -578,0 +581,3 @@\n+\n+  void reconstruct_frame_pointer(Register rtmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-    debug_only(cmp2->verify());\n+    DEBUG_ONLY(cmp2->verify());\n@@ -181,1 +181,1 @@\n-      debug_only(cmp3->verify());\n+      DEBUG_ONLY(cmp3->verify());\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,3 +64,1 @@\n-#ifdef _LP64\n-\/\/ stack if compiled for unix and LP64. To pass stack overflow tests we need\n-\/\/ 20 shadow pages.\n+\/\/ stack if compiled for unix. To pass stack overflow tests we need 20 shadow pages.\n@@ -72,4 +70,0 @@\n-#else\n-#define DEFAULT_STACK_SHADOW_PAGES (4 DEBUG_ONLY(+5))\n-#define MIN_STACK_SHADOW_PAGES DEFAULT_STACK_SHADOW_PAGES\n-#endif \/\/ _LP64\n@@ -82,4 +76,0 @@\n-#ifdef _LP64\n-#else\n-define_pd_global(bool, VMContinuations, false);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4506,64 +4506,0 @@\n-  \/\/ Get svml stub routine addresses\n-  void *libjsvml = nullptr;\n-  char ebuf[1024];\n-  char dll_name[JVM_MAXPATHLEN];\n-  if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"jsvml\")) {\n-    libjsvml = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-  }\n-  if (libjsvml != nullptr) {\n-    \/\/ SVML method naming convention\n-    \/\/   All the methods are named as __jsvml_op<T><N>_ha_<VV>\n-    \/\/   Where:\n-    \/\/      ha stands for high accuracy\n-    \/\/      <T> is optional to indicate float\/double\n-    \/\/              Set to f for vector float operation\n-    \/\/              Omitted for vector double operation\n-    \/\/      <N> is the number of elements in the vector\n-    \/\/              1, 2, 4, 8, 16\n-    \/\/              e.g. 128 bit float vector has 4 float elements\n-    \/\/      <VV> indicates the avx\/sse level:\n-    \/\/              z0 is AVX512, l9 is AVX2, e9 is AVX1 and ex is for SSE2\n-    \/\/      e.g. __jsvml_expf16_ha_z0 is the method for computing 16 element vector float exp using AVX 512 insns\n-    \/\/           __jsvml_exp8_ha_z0 is the method for computing 8 element vector double exp using AVX 512 insns\n-\n-    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"jsvml\" JNI_LIB_SUFFIX, p2i(libjsvml));\n-    if (UseAVX > 2) {\n-      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-        if ((!VM_Version::supports_avx512dq()) &&\n-            (vop == VectorSupport::VECTOR_OP_LOG || vop == VectorSupport::VECTOR_OP_LOG10 || vop == VectorSupport::VECTOR_OP_POW)) {\n-          continue;\n-        }\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n-        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n-        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_512][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-      }\n-    }\n-    const char* avx_sse_str = (UseAVX >= 2) ? \"l9\" : ((UseAVX == 1) ? \"e9\" : \"ex\");\n-    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-      if (vop == VectorSupport::VECTOR_OP_POW) {\n-        continue;\n-      }\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n-      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_256][op] = (address)os::dll_lookup(libjsvml, ebuf);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":64,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-#ifdef _LP64\n-\n@@ -90,1 +88,0 @@\n-#endif\n@@ -110,1 +107,0 @@\n-#if defined(_LP64)\n@@ -129,1 +125,0 @@\n-#endif\n@@ -154,1 +149,1 @@\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+    \/\/ rcx and rdx are first and second argument registers on windows\n@@ -157,4 +152,0 @@\n-#ifdef _LP64\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n@@ -421,1 +412,0 @@\n-#if defined(_LP64)\n@@ -456,1 +446,0 @@\n-#endif\n@@ -530,1 +519,0 @@\n-#ifdef _LP64\n@@ -533,1 +521,0 @@\n-#endif\n@@ -559,1 +546,0 @@\n-#ifdef _LP64\n@@ -562,1 +548,0 @@\n-#endif\n@@ -603,1 +588,0 @@\n-#ifdef _LP64\n@@ -606,1 +590,0 @@\n-#endif\n@@ -631,1 +614,0 @@\n-#ifdef _LP64\n@@ -634,1 +616,0 @@\n-#endif\n@@ -690,1 +671,0 @@\n-#ifdef _LP64\n@@ -693,4 +673,0 @@\n-#else\n-    __ movptr(rax, Address(rsp, 16)); \/\/ CPUID leaf\n-    __ movptr(rsi, Address(rsp, 20)); \/\/ register array address\n-#endif\n@@ -737,1 +713,1 @@\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+    \/\/ rcx and rdx are first and second argument registers on windows\n@@ -740,4 +716,0 @@\n-#ifdef _LP64\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n@@ -892,2 +864,2 @@\n-  LP64_ONLY(_supports_atomic_getset8 = true);\n-  LP64_ONLY(_supports_atomic_getadd8 = true);\n+  _supports_atomic_getset8 = true;\n+  _supports_atomic_getadd8 = true;\n@@ -895,1 +867,0 @@\n-#ifdef _LP64\n@@ -902,2 +873,0 @@\n-#endif\n-#ifdef AMD64\n@@ -916,2 +885,0 @@\n-#endif\n-#ifdef _LP64\n@@ -927,1 +894,0 @@\n-#endif\n@@ -1117,1 +1083,1 @@\n-  int res = jio_snprintf(\n+  int cpu_info_size = jio_snprintf(\n@@ -1122,2 +1088,2 @@\n-  assert(res > 0, \"not enough temporary space allocated\");\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  assert(cpu_info_size > 0, \"not enough temporary space allocated\");\n+  insert_features_names(buf + cpu_info_size, sizeof(buf) - cpu_info_size, _features_names);\n@@ -1125,1 +1091,5 @@\n-  _features_string = os::strdup(buf);\n+  _cpu_info_string = os::strdup(buf);\n+\n+  _features_string = extract_features_string(_cpu_info_string,\n+                                             strnlen(_cpu_info_string, sizeof(buf)),\n+                                             cpu_info_size);\n@@ -1209,1 +1179,0 @@\n-#ifdef _LP64\n@@ -1220,6 +1189,0 @@\n-#else\n-  if (UseAdler32Intrinsics) {\n-    warning(\"Adler32Intrinsics not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);\n-  }\n-#endif\n@@ -1249,1 +1212,0 @@\n-#ifdef _LP64\n@@ -1265,7 +1227,0 @@\n-#else\n-  \/\/ No support currently for ChaCha20 intrinsics on 32-bit platforms\n-  if (UseChaCha20Intrinsics) {\n-      warning(\"ChaCha20 intrinsics are not available on this CPU.\");\n-      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1275,1 +1230,0 @@\n-#ifdef _LP64\n@@ -1280,3 +1234,1 @@\n-  } else\n-#endif\n-   if (UseDilithiumIntrinsics) {\n+  } else if (UseDilithiumIntrinsics) {\n@@ -1311,1 +1263,1 @@\n-  if (supports_sha() LP64_ONLY(|| (supports_avx2() && supports_bmi2()))) {\n+  if (supports_sha() || (supports_avx2() && supports_bmi2())) {\n@@ -1338,2 +1290,0 @@\n-#ifdef _LP64\n-  \/\/ These are only supported on 64-bit\n@@ -1344,3 +1294,1 @@\n-  } else\n-#endif\n-  if (UseSHA512Intrinsics) {\n+  } else if (UseSHA512Intrinsics) {\n@@ -1351,1 +1299,0 @@\n-#ifdef _LP64\n@@ -1356,3 +1303,1 @@\n-  } else\n-#endif\n-   if (UseSHA3Intrinsics) {\n+  } else if (UseSHA3Intrinsics) {\n@@ -1380,4 +1325,0 @@\n-#ifdef _LP64\n-#else\n-  int min_vector_size = 0;\n-#endif\n@@ -1408,1 +1349,1 @@\n-      int nreg = 2 LP64_ONLY(+2);\n+      int nreg = 4;\n@@ -1421,1 +1362,0 @@\n-#ifdef _LP64\n@@ -1426,3 +1366,1 @@\n-  } else\n-#endif\n-  if (UsePoly1305Intrinsics) {\n+  } else if (UsePoly1305Intrinsics) {\n@@ -1433,1 +1371,0 @@\n-#ifdef _LP64\n@@ -1438,3 +1375,1 @@\n-  } else\n-#endif\n-  if (UseIntPolyIntrinsics) {\n+  } else if (UseIntPolyIntrinsics) {\n@@ -1445,1 +1380,0 @@\n-#ifdef _LP64\n@@ -1461,32 +1395,0 @@\n-#else\n-  if (UseMultiplyToLenIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n-      warning(\"multiplyToLen intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, false);\n-  }\n-  if (UseMontgomeryMultiplyIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n-      warning(\"montgomeryMultiply intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, false);\n-  }\n-  if (UseMontgomerySquareIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n-      warning(\"montgomerySquare intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, false);\n-  }\n-  if (UseSquareToLenIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n-      warning(\"squareToLen intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, false);\n-  }\n-  if (UseMulAddIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseMulAddIntrinsic)) {\n-      warning(\"mulAdd intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseMulAddIntrinsic, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1769,1 +1671,0 @@\n-#ifdef _LP64\n@@ -1786,14 +1687,0 @@\n-#else\n-  if (UseVectorizedMismatchIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseVectorizedMismatchIntrinsic)) {\n-      warning(\"vectorizedMismatch intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorizedMismatchIntrinsic, false);\n-  }\n-  if (UseVectorizedHashCodeIntrinsic) {\n-    if (!FLAG_IS_DEFAULT(UseVectorizedHashCodeIntrinsic)) {\n-      warning(\"vectorizedHashCode intrinsic is not available in 32-bit VM\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorizedHashCodeIntrinsic, false);\n-  }\n-#endif \/\/ _LP64\n@@ -1948,1 +1835,0 @@\n-#ifdef _LP64\n@@ -1967,1 +1853,0 @@\n-#endif\n@@ -2198,1 +2083,0 @@\n-#if defined(_LP64)\n@@ -2202,1 +2086,0 @@\n-#endif\n@@ -2220,2 +2103,0 @@\n-\n-#if defined(_LP64)\n@@ -2224,1 +2105,0 @@\n-#endif\n@@ -2227,1 +2107,1 @@\n-  LP64_ONLY(Assembler::precompute_instructions();)\n+  Assembler::precompute_instructions();\n@@ -2994,1 +2874,0 @@\n-#ifdef _LP64\n@@ -2999,1 +2878,0 @@\n-#endif\n@@ -3171,1 +3049,1 @@\n-  int nreg = 2 LP64_ONLY(+2);\n+  int nreg = 4;\n@@ -3327,4 +3205,0 @@\n-#ifdef _LP64\n-#else\n-        return 320;\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":21,"deletions":147,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -425,0 +425,12 @@\n+bool castLL_is_imm32(const Node* n);\n+\n+%}\n+\n+source %{\n+\n+bool castLL_is_imm32(const Node* n) {\n+  assert(n->is_CastLL(), \"must be a CastLL\");\n+  const TypeLong* t = n->bottom_type()->is_long();\n+  return (t->_lo == min_jlong || Assembler::is_simm32(t->_lo)) && (t->_hi == max_jlong || Assembler::is_simm32(t->_hi));\n+}\n+\n@@ -1596,4 +1608,1 @@\n-  if (EnableVectorSupport && UseVectorStubs) {\n-    return true;\n-  }\n-  return false;\n+  return EnableVectorSupport;\n@@ -1603,1 +1612,1 @@\n-  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(EnableVectorSupport, \"sanity\");\n@@ -1850,1 +1859,1 @@\n-    debug_only(int off0 = __ offset());\n+    DEBUG_ONLY(int off0 = __ offset());\n@@ -1857,1 +1866,1 @@\n-    debug_only(int off1 = __ offset());\n+    DEBUG_ONLY(int off1 = __ offset());\n@@ -7659,0 +7668,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -7668,0 +7678,13 @@\n+instruct castII_checked(rRegI dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0);\n+  match(Set dst (CastII dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_II $dst\" %}\n+  ins_encode %{\n+    __ verify_int_in_range(_idx, bottom_type()->is_int(), $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -7670,0 +7693,1 @@\n+  predicate(VerifyConstraintCasts == 0);\n@@ -7679,0 +7703,26 @@\n+instruct castLL_checked_L32(rRegL dst, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr);\n+  format %{ \"# cast_checked_LL $dst\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, noreg);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct castLL_checked(rRegL dst, rRegL tmp, rFlagsReg cr)\n+%{\n+  predicate(VerifyConstraintCasts > 0 && !castLL_is_imm32(n));\n+  match(Set dst (CastLL dst));\n+\n+  effect(KILL cr, TEMP tmp);\n+  format %{ \"# cast_checked_LL $dst\\tusing $tmp as TEMP\" %}\n+  ins_encode %{\n+    __ verify_long_in_range(_idx, bottom_type()->is_long(), $dst$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":57,"deletions":7,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -131,2 +131,2 @@\n-    debug_only(_index = -1);\n-    debug_only(_outer = (CodeBuffer*)badAddress);\n+    DEBUG_ONLY(_index = -1);\n+    DEBUG_ONLY(_outer = (CodeBuffer*)badAddress);\n@@ -545,1 +545,1 @@\n-    debug_only(verify_section_allocation();)\n+    DEBUG_ONLY(verify_section_allocation();)\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-    debug_only(cpu_range_check(rnr);)\n+    DEBUG_ONLY(cpu_range_check(rnr);)\n@@ -118,1 +118,1 @@\n-    debug_only(cpu_range_check(reg->encoding());)\n+    DEBUG_ONLY(cpu_range_check(reg->encoding());)\n@@ -123,2 +123,2 @@\n-    debug_only(cpu_range_check(rnr);)\n-    debug_only(cpu_range_check(reg->encoding());)\n+    DEBUG_ONLY(cpu_range_check(rnr);)\n+    DEBUG_ONLY(cpu_range_check(reg->encoding());)\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1545,1 +1545,1 @@\n-  debug_only(NoHandleMark nhm;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n@@ -1562,1 +1562,1 @@\n-  debug_only(NoHandleMark nhm;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n@@ -1579,1 +1579,1 @@\n-  debug_only(NoHandleMark nhm;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -612,1 +613,1 @@\n-\n+  bool _is_java_lang_ref;\n@@ -615,1 +616,4 @@\n-    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap) {}\n+    _src_obj(src_obj), _buffered_obj(buffered_obj), _oopmap(oopmap)\n+  {\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(src_obj);\n+  }\n@@ -622,2 +626,8 @@\n-    size_t field_offset = pointer_delta(p, _src_obj, sizeof(char));\n-    ArchiveHeapWriter::relocate_field_in_buffer<T>((T*)(_buffered_obj + field_offset), _oopmap);\n+    int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_src_obj));\n+    T* field_addr = (T*)(_buffered_obj + field_offset);\n+    if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+      \/\/ Do not copy these fields. Set them to null\n+      *field_addr = (T)0x0;\n+    } else {\n+      ArchiveHeapWriter::relocate_field_in_buffer<T>(field_addr, _oopmap);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -560,3 +560,0 @@\n-\n-    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n-    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1142,1 +1142,1 @@\n-                        bool allow_exec, MemTag mem_tag = mtNone) {\n+                        bool allow_exec, MemTag mem_tag) {\n@@ -1144,2 +1144,2 @@\n-                             AlwaysPreTouch ? false : read_only,\n-                             allow_exec, mem_tag);\n+                             mem_tag, AlwaysPreTouch ? false : read_only,\n+                             allow_exec);\n@@ -1170,1 +1170,1 @@\n-                              addr, size, false \/* !read_only *\/,\n+                              addr, size, mtNone, false \/* !read_only *\/,\n@@ -1696,1 +1696,1 @@\n-                      r->allow_exec());\n+                      r->allow_exec(), mtJavaHeap);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -1366,2 +1367,3 @@\n-\/\/ Push all oops that are referenced by _referencing_obj onto the _stack.\n-class HeapShared::ReferentPusher: public BasicOopIterateClosure {\n+\/\/ Push all oop fields (or oop array elemenets in case of an objArray) in\n+\/\/ _referencing_obj onto the _stack.\n+class HeapShared::OopFieldPusher: public BasicOopIterateClosure {\n@@ -1374,0 +1376,1 @@\n+  bool _is_java_lang_ref;\n@@ -1375,5 +1378,5 @@\n-  ReferentPusher(PendingOopStack* stack,\n-                           int level,\n-                           bool record_klasses_only,\n-                           KlassSubGraphInfo* subgraph_info,\n-                           oop orig) :\n+  OopFieldPusher(PendingOopStack* stack,\n+                 int level,\n+                 bool record_klasses_only,\n+                 KlassSubGraphInfo* subgraph_info,\n+                 oop orig) :\n@@ -1386,0 +1389,1 @@\n+    _is_java_lang_ref = AOTReferenceObjSupport::check_if_ref_obj(orig);\n@@ -1387,2 +1391,2 @@\n-  void do_oop(narrowOop *p) { ReferentPusher::do_oop_work(p); }\n-  void do_oop(      oop *p) { ReferentPusher::do_oop_work(p); }\n+  void do_oop(narrowOop *p) { OopFieldPusher::do_oop_work(p); }\n+  void do_oop(      oop *p) { OopFieldPusher::do_oop_work(p); }\n@@ -1390,1 +1394,1 @@\n-  ~ReferentPusher() {\n+  ~OopFieldPusher() {\n@@ -1393,1 +1397,1 @@\n-      \/\/ of ReferentPusher that recurses on the C stack -- a depth-first search,\n+      \/\/ of OopFieldPusher that recurses on the C stack -- a depth-first search,\n@@ -1402,1 +1406,2 @@\n-    oop obj = RawAccess<>::oop_load(p);\n+    int field_offset = pointer_delta_as_int((char*)p, cast_from_oop<char*>(_referencing_obj));\n+    oop obj = HeapAccess<ON_UNKNOWN_OOP_REF>::oop_load_at(_referencing_obj, field_offset);\n@@ -1404,1 +1409,4 @@\n-      size_t field_delta = pointer_delta(p, _referencing_obj, sizeof(char));\n+      if (_is_java_lang_ref && AOTReferenceObjSupport::skip_field(field_offset)) {\n+        \/\/ Do not follow these fields. They will be cleared to null.\n+        return;\n+      }\n@@ -1408,2 +1416,2 @@\n-        log_debug(cds, heap)(\"(%d) %s[%zu] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n-                             _referencing_obj->klass()->external_name(), field_delta,\n+        log_debug(cds, heap)(\"(%d) %s[%d] ==> \" PTR_FORMAT \" size %zu %s\", _level,\n+                             _referencing_obj->klass()->external_name(), field_offset,\n@@ -1589,1 +1597,1 @@\n-    ReferentPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n+    OopFieldPusher pusher(stack, level, record_klasses_only, subgraph_info, orig_obj);\n@@ -1616,1 +1624,1 @@\n-\/\/ The Java heap object sub-graph archiving process (see ReferentPusher):\n+\/\/ The Java heap object sub-graph archiving process (see OopFieldPusher):\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -967,0 +968,1 @@\n+\n@@ -972,11 +974,2 @@\n-    if (CDSConfig::is_dumping_method_handles()) {\n-      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n-      \/\/ updated concurrently when we are saving their contents into a side table.\n-      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n-\n-      JavaValue result(T_VOID);\n-      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n-                             vmSymbols::createArchivedObjects(),\n-                             vmSymbols::void_method_signature(),\n-                             CHECK);\n-    }\n+    AOTReferenceObjSupport::initialize(CHECK);\n+    AOTReferenceObjSupport::stabilize_cached_reference_objects(CHECK);\n@@ -1355,1 +1348,1 @@\n-                                                  false, MemTag::mtClassShared);\n+                                                  mtClassShared);\n@@ -1547,1 +1540,2 @@\n-                                               os::vm_page_size());\n+                                               os::vm_page_size(),\n+                                               mtNone);\n@@ -1615,1 +1609,2 @@\n-                                                 os::vm_page_size());\n+                                                 os::vm_page_size(),\n+                                                 mtNone);\n@@ -1619,1 +1614,2 @@\n-                                                 os::vm_page_size());\n+                                                 os::vm_page_size(),\n+                                                 mtNone);\n@@ -1632,1 +1628,2 @@\n-                                               os::vm_page_size());\n+                                               os::vm_page_size(),\n+                                               mtNone);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -146,0 +146,6 @@\n+\n+char* ciInstance::java_lang_String_str(char* buf, size_t buflen) {\n+  VM_ENTRY_MARK;\n+  assert(get_oop()->is_a(vmClasses::String_klass()), \"not a String\");\n+  return java_lang_String::as_utf8_string(get_oop(), buf, buflen);\n+}\n","filename":"src\/hotspot\/share\/ci\/ciInstance.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  char* java_lang_String_str(char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/ci\/ciInstance.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -972,2 +972,8 @@\n-      count = (int)((double)count * prof_factor * method_life \/ counter_life + 0.5);\n-      count = (count > 0) ? count : 1;\n+      double count_d = (double)count * prof_factor * method_life \/ counter_life + 0.5;\n+      if (count_d >= static_cast<double>(INT_MAX)) {\n+        \/\/ Clamp in case of overflowing int range.\n+        count = INT_MAX;\n+      } else {\n+        count = int(count_d);\n+        count = (count > 0) ? count : 1;\n+      }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2986,1 +2986,1 @@\n-  debug_only(int max_block = _next_pre_order;)\n+  DEBUG_ONLY(int max_block = _next_pre_order;)\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,1 +256,1 @@\n-      debug_only(set_type_at_tos(bottom_type()));\n+      DEBUG_ONLY(set_type_at_tos(bottom_type()));\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  debug_only(const u1* const old_current = stream->current();)\n+  DEBUG_ONLY(const u1* const old_current = stream->current();)\n@@ -5529,1 +5529,1 @@\n-  debug_only(ik->verify();)\n+  DEBUG_ONLY(ik->verify();)\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotReferenceObjSupport.hpp\"\n@@ -4850,1 +4851,1 @@\n-  debug_only(jint loop_count = 0);\n+  DEBUG_ONLY(jint loop_count = 0);\n@@ -5489,3 +5490,1 @@\n-  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n-    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n+  if (!AOTReferenceObjSupport::is_enabled() && klass->is_subclass_of(vmClasses::Reference_klass())) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1024,1 +1024,2 @@\n-                                      \"Ljava\/lang\/Class;Ljava\/lang\/Class;\"                                                                     \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n@@ -1045,0 +1046,23 @@\n+  do_intrinsic(_VectorUnaryLibOp, jdk_internal_vm_vector_VectorSupport, vector_unary_lib_op_name, vector_unary_lib_op_sig, F_S)                \\\n+   do_signature(vector_unary_lib_op_sig,\"(J\"                                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"Ljava\/lang\/Class;\"                                                                                   \\\n+                                         \"I\"                                                                                                   \\\n+                                         \"Ljava\/lang\/String;\"                                                                                  \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                       \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$UnaryOperation;)\"                                              \\\n+                                         \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                      \\\n+   do_name(vector_unary_lib_op_name, \"libraryUnaryOp\")                                                                                         \\\n+                                                                                                                                               \\\n+  do_intrinsic(_VectorBinaryLibOp, jdk_internal_vm_vector_VectorSupport, vector_binary_lib_op_name, vector_binary_lib_op_sig, F_S)             \\\n+   do_signature(vector_binary_lib_op_sig,\"(J\"                                                                                                  \\\n+                                          \"Ljava\/lang\/Class;\"                                                                                  \\\n+                                          \"Ljava\/lang\/Class;\"                                                                                  \\\n+                                          \"I\"                                                                                                  \\\n+                                          \"Ljava\/lang\/String;\"                                                                                 \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                               \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                               \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$BinaryOperation;)\"                                            \\\n+                                          \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\")                                              \\\n+   do_name(vector_binary_lib_op_name, \"libraryBinaryOp\")                                                                                       \\\n+                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -731,1 +731,0 @@\n-  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  debug_only(_recording_state = rs_null);\n+  DEBUG_ONLY(_recording_state = rs_null);\n@@ -162,1 +162,1 @@\n-  debug_only(_recording_state = rs_safepoint);\n+  DEBUG_ONLY(_recording_state = rs_safepoint);\n@@ -172,1 +172,1 @@\n-  debug_only(_recording_state = rs_non_safepoint);\n+  DEBUG_ONLY(_recording_state = rs_non_safepoint);\n@@ -365,1 +365,1 @@\n-  debug_only(_recording_state = rs_null);\n+  DEBUG_ONLY(_recording_state = rs_null);\n@@ -418,1 +418,1 @@\n-  debug_only(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n+  DEBUG_ONLY(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n@@ -424,1 +424,1 @@\n-  debug_only(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n+  DEBUG_ONLY(mark_recorders_frozen());  \/\/ mark it \"frozen\" for asserts\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1136,1 +1136,1 @@\n-    debug_only(nm->verify();) \/\/ might block\n+    DEBUG_ONLY(nm->verify();) \/\/ might block\n@@ -1287,1 +1287,1 @@\n-  debug_only(Universe::heap()->verify_nmethod(this));\n+  DEBUG_ONLY(Universe::heap()->verify_nmethod(this));\n@@ -1314,1 +1314,1 @@\n-    debug_only(NoSafepointVerifier nsv;)\n+    DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -1455,1 +1455,1 @@\n-    debug_only(NoSafepointVerifier nsv;)\n+    DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -2823,1 +2823,1 @@\n-  const int LOG2_RADIX = 4 \/*smaller steps in debug mode:*\/ debug_only(-1);\n+  const int LOG2_RADIX = 4 \/*smaller steps in debug mode:*\/ DEBUG_ONLY(-1);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  PcDescCache() { debug_only(_pc_descs[0] = nullptr); }\n+  PcDescCache() { DEBUG_ONLY(_pc_descs[0] = nullptr); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-  debug_only( _locs_used[reg->value()] = x; )\n+  DEBUG_ONLY( _locs_used[reg->value()] = x; )\n@@ -515,1 +515,1 @@\n-  debug_only(reg_map->_update_for_id = fr->id());\n+  DEBUG_ONLY(reg_map->_update_for_id = fr->id());\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,2 +214,2 @@\n-void PSParallelCompact::print_on_error(outputStream* st) {\n-  _mark_bitmap.print_on_error(st);\n+void PSParallelCompact::print_on(outputStream* st) {\n+  _mark_bitmap.print_on(st);\n@@ -250,1 +250,2 @@\n-                                             page_sz);\n+                                             page_sz,\n+                                             mtGC);\n@@ -1633,1 +1634,1 @@\n-  debug_only(verify_forward();)\n+  DEBUG_ONLY(verify_forward();)\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  debug_only(static void check_for_valid_allocation_state();)\n+  DEBUG_ONLY(static void check_for_valid_allocation_state();)\n@@ -439,4 +439,5 @@\n-  \/\/ Print heap information on the given outputStream.\n-  virtual void print_on(outputStream* st) const = 0;\n-  \/\/ The default behavior is to call print_on() on tty.\n-  virtual void print() const;\n+  \/\/ Print heap information.\n+  virtual void print_heap_on(outputStream* st) const = 0;\n+\n+  \/\/ Print additional information about the GC that is not included in print_heap_on().\n+  virtual void print_gc_on(outputStream* st) const = 0;\n@@ -444,1 +445,2 @@\n-  virtual void print_on_error(outputStream* st) const = 0;\n+  \/\/ The default behavior is to call print_heap_on() and print_gc_on() on tty.\n+  virtual void print() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -129,0 +129,4 @@\n+#ifdef CHECK_UNHANDLED_OOPS\n+      \/\/ obj is null, no need to handle, but CheckUnhandledOops is not aware about null\n+      THREAD->allow_unhandled_oop(_obj_ptr);\n+#endif \/\/ CHECK_UNHANDLED_OOPS\n@@ -148,1 +152,1 @@\n-  debug_only(check_for_valid_allocation_state());\n+  DEBUG_ONLY(check_for_valid_allocation_state());\n@@ -330,1 +334,1 @@\n-  debug_only(allocation._thread->check_for_valid_safepoint_state());\n+  DEBUG_ONLY(allocation._thread->check_for_valid_safepoint_state());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -899,1 +899,1 @@\n-    debug_only(gc_state_adr_type = phase->C->get_adr_type(gc_state_idx));\n+    DEBUG_ONLY(gc_state_adr_type = phase->C->get_adr_type(gc_state_idx));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,1 +314,1 @@\n-    debug_only(_bit_mask[0] = 0;)\n+    DEBUG_ONLY(_bit_mask[0] = 0;)\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  debug_only(VMNativeEntryWrapper __vew;)\n+  DEBUG_ONLY(VMNativeEntryWrapper __vew;)\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,2 +170,2 @@\n-debug_only(OopHandle Universe::_fullgc_alot_dummy_array;)\n-debug_only(int Universe::_fullgc_alot_dummy_next = 0;)\n+DEBUG_ONLY(OopHandle Universe::_fullgc_alot_dummy_array;)\n+DEBUG_ONLY(int Universe::_fullgc_alot_dummy_next = 0;)\n@@ -1177,1 +1177,4 @@\n-  heap()->print_on(st);\n+\n+  StreamAutoIndentor indentor(st, 1);\n+  heap()->print_heap_on(st);\n+  MetaspaceUtils::print_on(st);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -121,2 +121,2 @@\n-  debug_only(static OopHandle   _fullgc_alot_dummy_array;)\n-  debug_only(static int         _fullgc_alot_dummy_next;)\n+  DEBUG_ONLY(static OopHandle   _fullgc_alot_dummy_array;)\n+  DEBUG_ONLY(static int         _fullgc_alot_dummy_next;)\n@@ -364,1 +364,1 @@\n-  debug_only(static bool release_fullgc_alot_dummy();)\n+  DEBUG_ONLY(static bool release_fullgc_alot_dummy();)\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2034,1 +2034,1 @@\n-    debug_only(BasicBlock* target_bb = &jsr_bb[1];)\n+    DEBUG_ONLY(BasicBlock* target_bb = &jsr_bb[1];)\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1546,1 +1546,1 @@\n-    debug_only(vtable().verify(tty, true);)\n+    DEBUG_ONLY(vtable().verify(tty, true);)\n@@ -4544,1 +4544,1 @@\n-  debug_only(_is_static_field_id = false;)\n+  DEBUG_ONLY(_is_static_field_id = false;)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  debug_only(static bool first_time = true);\n+  DEBUG_ONLY(static bool first_time = true);\n@@ -77,1 +77,1 @@\n-  debug_only(first_time = false);\n+  DEBUG_ONLY(first_time = false);\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -664,1 +664,1 @@\n-  debug_only(verify();)\n+  DEBUG_ONLY(verify();)\n@@ -689,1 +689,1 @@\n-  debug_only(verify();)\n+  DEBUG_ONLY(verify();)\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1308,1 +1308,1 @@\n-  debug_only(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -1314,1 +1314,1 @@\n-  debug_only(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n@@ -1320,1 +1320,1 @@\n-  debug_only(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-  debug_only( memset(defs,0,(max_size+1)*sizeof(Node*)) );\n+  DEBUG_ONLY( memset(defs,0,(max_size+1)*sizeof(Node*)) );\n@@ -212,1 +212,1 @@\n-  debug_only( char *dup_check = NEW_RESOURCE_ARRAY(char,OptoReg::stack0());\n+  DEBUG_ONLY( char *dup_check = NEW_RESOURCE_ARRAY(char,OptoReg::stack0());\n@@ -354,1 +354,1 @@\n-      debug_only( dup_check[_callees[reg]]=1; )\n+      DEBUG_ONLY( dup_check[_callees[reg]]=1; )\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -672,0 +672,10 @@\n+  product(uint, VerifyConstraintCasts, 0, DIAGNOSTIC,                       \\\n+          \"Perform runtime checks to verify the value of a \"                \\\n+          \"ConstraintCast lies inside its type\"                             \\\n+          \"0 = does not perform any verification, \"                         \\\n+          \"1 = perform verification on ConstraintCastNodes that are \"       \\\n+              \"present during code emission, \"                              \\\n+          \"2 = Do not do widening of ConstraintCastNodes so that we can \"   \\\n+              \"have more verification coverage\")                            \\\n+          range(0, 2)                                                       \\\n+                                                                            \\\n@@ -753,3 +763,0 @@\n-  product(bool, UseVectorStubs, false, EXPERIMENTAL,                        \\\n-          \"Use stubs for vector transcendental operations\")                 \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -860,0 +860,3 @@\n+  case vmIntrinsics::_VectorUnaryLibOp:\n+  case vmIntrinsics::_VectorBinaryLibOp:\n+    return EnableVectorSupport && Matcher::supports_vector_calling_convention();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -261,2 +261,2 @@\n-  debug_only(_bci = -99);  \/\/ random garbage value\n-  debug_only(_map = (SafePointNode*)-1);\n+  DEBUG_ONLY(_bci = -99);  \/\/ random garbage value\n+  DEBUG_ONLY(_map = (SafePointNode*)-1);\n@@ -276,1 +276,1 @@\n-  debug_only(_map = (SafePointNode*)-1);\n+  DEBUG_ONLY(_map = (SafePointNode*)-1);\n@@ -318,1 +318,1 @@\n-  debug_only(JVMState* jvmroot = of_depth(1));\n+  DEBUG_ONLY(JVMState* jvmroot = of_depth(1));\n@@ -325,1 +325,1 @@\n-  debug_only(JVMState* jvmroot = of_depth(1));\n+  DEBUG_ONLY(JVMState* jvmroot = of_depth(1));\n@@ -1669,1 +1669,1 @@\n-  debug_only(int num_before_pop = jvms()->nof_monitors());\n+  DEBUG_ONLY(int num_before_pop = jvms()->nof_monitors());\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -588,0 +588,12 @@\n+\n+  \/\/ At VerifyConstraintCasts == 1, we verify the ConstraintCastNodes that are present during code\n+  \/\/ emission. This allows us detecting possible mis-scheduling due to these nodes being pinned at\n+  \/\/ the wrong control nodes.\n+  \/\/ At VerifyConstraintCasts == 2, we do not perform widening so that we can verify the\n+  \/\/ correctness of more ConstraintCastNodes. This further helps us detect possible\n+  \/\/ mis-transformations that may happen due to these nodes being pinned at the wrong control\n+  \/\/ nodes.\n+  if (VerifyConstraintCasts > 1) {\n+    return res;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2331,1 +2331,1 @@\n-    debug_only(Node* ident = Identity(phase));\n+    DEBUG_ONLY(Node* ident = Identity(phase));\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1326,1 +1326,1 @@\n-    debug_only( int lo_no_simplify=0; );\n+    DEBUG_ONLY( int lo_no_simplify=0; );\n@@ -1338,1 +1338,1 @@\n-      debug_only( if( lrgs(i)._was_lo ) lo_no_simplify=i; );\n+      DEBUG_ONLY( if( lrgs(i)._was_lo ) lo_no_simplify=i; );\n@@ -1580,1 +1580,1 @@\n-    debug_only(RegMask orig_mask = lrg->mask();)\n+    DEBUG_ONLY(RegMask orig_mask = lrg->mask();)\n@@ -1709,2 +1709,2 @@\n-        debug_only(tty->print(\" original mask: \"));\n-        debug_only(orig_mask.dump());\n+        DEBUG_ONLY(tty->print(\" original mask: \"));\n+        DEBUG_ONLY(orig_mask.dump());\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-  debug_only(verify_graph_edges(true \/*check for no_dead_code*\/, root_and_safepoints);)\n+  DEBUG_ONLY(verify_graph_edges(true \/*check for no_dead_code*\/, root_and_safepoints);)\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2891,1 +2891,1 @@\n-          \/\/ StoreP::memory_type() == T_ADDRESS\n+          \/\/ StoreP::value_basic_type() == T_ADDRESS\n@@ -2898,1 +2898,1 @@\n-              store->as_Store()->memory_type() == ft) {\n+              store->as_Store()->value_basic_type() == ft) {\n@@ -4674,1 +4674,1 @@\n-      debug_only(n->dump();)\n+      DEBUG_ONLY(n->dump();)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-  debug_only(_sp = -99);\n-  debug_only(set_bci(-99));\n+  DEBUG_ONLY(_sp = -99);\n+  DEBUG_ONLY(set_bci(-99));\n@@ -212,1 +212,1 @@\n-  debug_only(verify_exception_state(ex_map));\n+  DEBUG_ONLY(verify_exception_state(ex_map));\n@@ -312,1 +312,1 @@\n-      debug_only(verify_map());\n+      DEBUG_ONLY(verify_map());\n@@ -689,1 +689,1 @@\n-  debug_only(kit->verify_map());\n+  DEBUG_ONLY(kit->verify_map());\n@@ -797,1 +797,1 @@\n-  debug_only(verify_map());\n+  DEBUG_ONLY(verify_map());\n@@ -1602,1 +1602,1 @@\n-  debug_only( map()->set_memory((Node*)nullptr) );\n+  DEBUG_ONLY( map()->set_memory((Node*)nullptr) );\n@@ -1639,1 +1639,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n@@ -1668,1 +1668,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  void set_map(SafePointNode* m)      { _map = m; debug_only(verify_map()); }\n+  void set_map(SafePointNode* m)      { _map = m; DEBUG_ONLY(verify_map()); }\n@@ -240,1 +240,1 @@\n-      debug_only(verify_exception_state(ex_map));\n+      DEBUG_ONLY(verify_exception_state(ex_map));\n@@ -247,1 +247,1 @@\n-    debug_only(verify_exception_state(ex_map));\n+    DEBUG_ONLY(verify_exception_state(ex_map));\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n@@ -371,1 +371,1 @@\n-  debug_only(adr_type = C->get_adr_type(adr_idx));\n+  DEBUG_ONLY(adr_type = C->get_adr_type(adr_idx));\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2239,1 +2239,1 @@\n-      st->print(\"Profiled Loop \");\n+      st->print(\"Profiled_Loop \");\n@@ -2245,1 +2245,1 @@\n-      st->print(\"Loop Limit Check \");\n+      st->print(\"Loop_Limit_Check \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -734,0 +734,4 @@\n+  case vmIntrinsics::_VectorUnaryLibOp:\n+    return inline_vector_call(1);\n+  case vmIntrinsics::_VectorBinaryLibOp:\n+    return inline_vector_call(2);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -397,0 +397,1 @@\n+  bool inline_vector_call(int arity);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -371,0 +371,2 @@\n+  Node* uncasted_init_trip(bool uncasted);\n+\n@@ -980,0 +982,2 @@\n+  void cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop);\n+\n@@ -1005,1 +1009,1 @@\n-  void rewire_old_target_loop_entry_dependency_to_new_entry(LoopNode* target_loop_head,\n+  void rewire_old_target_loop_entry_dependency_to_new_entry(CountedLoopNode* target_loop_head,\n@@ -1359,1 +1363,1 @@\n-                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n+                         Node* incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1589,2 +1593,0 @@\n-  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1151,19 +1151,0 @@\n-\/\/ Split some nodes that take a counted loop phi as input at a counted\n-\/\/ loop can cause vectorization of some expressions to fail\n-bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n-  if (!n_blk->is_CountedLoop()) {\n-    return false;\n-  }\n-\n-  int opcode = n->Opcode();\n-\n-  if (opcode != Op_AndI &&\n-      opcode != Op_MulI &&\n-      opcode != Op_RotateRight &&\n-      opcode != Op_RShiftI) {\n-    return false;\n-  }\n-\n-  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n-}\n-\n@@ -1262,4 +1243,0 @@\n-  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n-    return n;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-        debug_only(intptr_t offset;)\n+        DEBUG_ONLY(intptr_t offset;)\n@@ -1599,1 +1599,1 @@\n-    debug_only(slow_region = NodeSentinel);\n+    DEBUG_ONLY(slow_region = NodeSentinel);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  debug_only(_mem_node = nullptr;)   \/\/ Ideal memory node consumed by mach node\n+  DEBUG_ONLY(_mem_node = nullptr;)   \/\/ Ideal memory node consumed by mach node\n@@ -1223,1 +1223,1 @@\n-          debug_only(match_alias_type(C, n, m));\n+          DEBUG_ONLY(match_alias_type(C, n, m));\n@@ -1635,1 +1635,1 @@\n-  debug_only( _mem_node = save_mem_node; )\n+  DEBUG_ONLY( _mem_node = save_mem_node; )\n@@ -2009,1 +2009,1 @@\n-    debug_only(Node *save_mem_node = _mem_node;)\n+    DEBUG_ONLY(Node *save_mem_node = _mem_node;)\n@@ -2011,1 +2011,1 @@\n-    debug_only(_mem_node = save_mem_node;)\n+    DEBUG_ONLY(_mem_node = save_mem_node;)\n@@ -2023,1 +2023,1 @@\n-    debug_only( if( mem == (Node*)1 ) _mem_node = s->_leaf;)\n+    DEBUG_ONLY( if( mem == (Node*)1 ) _mem_node = s->_leaf;)\n@@ -2067,1 +2067,1 @@\n-        debug_only(Node *save_mem_node = _mem_node;)\n+        DEBUG_ONLY(Node *save_mem_node = _mem_node;)\n@@ -2069,1 +2069,1 @@\n-        debug_only(_mem_node = save_mem_node;)\n+        DEBUG_ONLY(_mem_node = save_mem_node;)\n@@ -2100,1 +2100,1 @@\n-    debug_only(_mem_node = s->_leaf;)\n+    DEBUG_ONLY(_mem_node = s->_leaf;)\n@@ -2129,1 +2129,1 @@\n-      debug_only(Node *save_mem_node = _mem_node;)\n+      DEBUG_ONLY(Node *save_mem_node = _mem_node;)\n@@ -2131,1 +2131,1 @@\n-      debug_only(_mem_node = save_mem_node;)\n+      DEBUG_ONLY(_mem_node = save_mem_node;)\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1357,1 +1357,1 @@\n-      if (memory_type() != T_VOID) {\n+      if (value_basic_type() != T_VOID) {\n@@ -1362,1 +1362,1 @@\n-          return phase->zerocon(memory_type());\n+          return phase->zerocon(value_basic_type());\n@@ -2199,1 +2199,1 @@\n-                                                                      memory_type(), is_unsigned());\n+                                                                      value_basic_type(), is_unsigned());\n@@ -2266,1 +2266,1 @@\n-    BasicType bt = memory_type();\n+    BasicType bt = value_basic_type();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    debug_only(_adr_type=at; adr_type();)\n+    DEBUG_ONLY(_adr_type=at; adr_type();)\n@@ -83,1 +83,1 @@\n-    debug_only(_adr_type=at; adr_type();)\n+    DEBUG_ONLY(_adr_type=at; adr_type();)\n@@ -92,1 +92,1 @@\n-    debug_only(_adr_type=at; adr_type();)\n+    DEBUG_ONLY(_adr_type=at; adr_type();)\n@@ -141,1 +141,5 @@\n-  virtual BasicType memory_type() const = 0;\n+  \/\/ The returned type is a property of the value that is loaded\/stored and\n+  \/\/ not the memory that is accessed. For mismatched memory accesses\n+  \/\/ they might differ. For instance, a value of type 'short' may be stored\n+  \/\/ into an array of elements of type 'long'.\n+  virtual BasicType value_basic_type() const = 0;\n@@ -144,1 +148,1 @@\n-    return type2aelembytes(memory_type(), true);\n+    return type2aelembytes(value_basic_type(), true);\n@@ -146,1 +150,1 @@\n-    return type2aelembytes(memory_type());\n+    return type2aelembytes(value_basic_type());\n@@ -276,1 +280,1 @@\n-    debug_only(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n+    DEBUG_ONLY(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n@@ -344,1 +348,1 @@\n-  virtual BasicType memory_type() const { return T_BYTE; }\n+  virtual BasicType value_basic_type() const { return T_BYTE; }\n@@ -358,1 +362,1 @@\n-  virtual BasicType memory_type() const { return T_BYTE; }\n+  virtual BasicType value_basic_type() const { return T_BYTE; }\n@@ -372,1 +376,1 @@\n-  virtual BasicType memory_type() const { return T_CHAR; }\n+  virtual BasicType value_basic_type() const { return T_CHAR; }\n@@ -386,1 +390,1 @@\n-  virtual BasicType memory_type() const { return T_SHORT; }\n+  virtual BasicType value_basic_type() const { return T_SHORT; }\n@@ -398,1 +402,1 @@\n-  virtual BasicType memory_type() const { return T_INT; }\n+  virtual BasicType value_basic_type() const { return T_INT; }\n@@ -431,1 +435,1 @@\n-  virtual BasicType memory_type() const { return T_LONG; }\n+  virtual BasicType value_basic_type() const { return T_LONG; }\n@@ -460,1 +464,1 @@\n-  virtual BasicType memory_type() const { return T_FLOAT; }\n+  virtual BasicType value_basic_type() const { return T_FLOAT; }\n@@ -481,1 +485,1 @@\n-  virtual BasicType memory_type() const { return T_DOUBLE; }\n+  virtual BasicType value_basic_type() const { return T_DOUBLE; }\n@@ -510,1 +514,1 @@\n-  virtual BasicType memory_type() const { return T_ADDRESS; }\n+  virtual BasicType value_basic_type() const { return T_ADDRESS; }\n@@ -524,1 +528,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWOOP; }\n+  virtual BasicType value_basic_type() const { return T_NARROWOOP; }\n@@ -579,1 +583,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWKLASS; }\n+  virtual BasicType value_basic_type() const { return T_NARROWKLASS; }\n@@ -689,1 +693,1 @@\n-  virtual BasicType memory_type() const { return T_BYTE; }\n+  virtual BasicType value_basic_type() const { return T_BYTE; }\n@@ -700,1 +704,1 @@\n-  virtual BasicType memory_type() const { return T_CHAR; }\n+  virtual BasicType value_basic_type() const { return T_CHAR; }\n@@ -710,1 +714,1 @@\n-  virtual BasicType memory_type() const { return T_INT; }\n+  virtual BasicType value_basic_type() const { return T_INT; }\n@@ -728,1 +732,1 @@\n-  virtual BasicType memory_type() const { return T_LONG; }\n+  virtual BasicType value_basic_type() const { return T_LONG; }\n@@ -751,1 +755,1 @@\n-  virtual BasicType memory_type() const { return T_LONG; }\n+  virtual BasicType value_basic_type() const { return T_LONG; }\n@@ -765,1 +769,1 @@\n-  virtual BasicType memory_type() const { return T_FLOAT; }\n+  virtual BasicType value_basic_type() const { return T_FLOAT; }\n@@ -783,1 +787,1 @@\n-  virtual BasicType memory_type() const { return T_DOUBLE; }\n+  virtual BasicType value_basic_type() const { return T_DOUBLE; }\n@@ -802,1 +806,1 @@\n-  virtual BasicType memory_type() const { return T_ADDRESS; }\n+  virtual BasicType value_basic_type() const { return T_ADDRESS; }\n@@ -812,1 +816,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWOOP; }\n+  virtual BasicType value_basic_type() const { return T_NARROWOOP; }\n@@ -822,1 +826,1 @@\n-  virtual BasicType memory_type() const { return T_NARROWKLASS; }\n+  virtual BasicType value_basic_type() const { return T_NARROWKLASS; }\n@@ -1543,1 +1547,1 @@\n-    debug_only(_cnt2 = 999);\n+    DEBUG_ONLY(_cnt2 = 999);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -939,7 +939,9 @@\n-      const julong sign_bits_mask = ~(((julong)CONST64(1) << (julong)(BitsPerJavaLong - shift)) -1);\n-      \/\/ If the AND'ing of the 2 masks has no bits, then only original shifted\n-      \/\/ bits survive.  NO sign-extension bits survive the maskings.\n-      if( (sign_bits_mask & mask) == 0 ) {\n-        \/\/ Use zero-fill shift instead\n-        Node *zshift = phase->transform(new URShiftLNode(in1->in(1), in1->in(2)));\n-        return new AndLNode(zshift, in(2));\n+      if (shift != 0) {\n+        const julong sign_bits_mask = ~(((julong)CONST64(1) << (julong)(BitsPerJavaLong - shift)) -1);\n+        \/\/ If the AND'ing of the 2 masks has no bits, then only original shifted\n+        \/\/ bits survive.  NO sign-extension bits survive the maskings.\n+        if( (sign_bits_mask & mask) == 0 ) {\n+          \/\/ Use zero-fill shift instead\n+          Node *zshift = phase->transform(new URShiftLNode(in1->in(1), in1->in(2)));\n+          return new AndLNode(zshift, in(2));\n+        }\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    debug_only(check_con());\n+    DEBUG_ONLY(check_con());\n","filename":"src\/hotspot\/share\/opto\/multnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -345,1 +345,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -358,1 +358,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -373,1 +373,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -390,1 +390,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -409,1 +409,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -431,1 +431,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -455,1 +455,1 @@\n-  debug_only( verify_construction() );\n+  DEBUG_ONLY( verify_construction() );\n@@ -493,1 +493,1 @@\n-  debug_only(n->_hash_lock = 0);\n+  DEBUG_ONLY(n->_hash_lock = 0);\n@@ -529,1 +529,1 @@\n-  debug_only( n->verify_construction() );\n+  DEBUG_ONLY( n->verify_construction() );\n@@ -533,1 +533,1 @@\n-  \/\/debug_only( n->set_debug_idx( debug_idx() ) );\n+  \/\/DEBUG_ONLY( n->set_debug_idx( debug_idx() ) );\n@@ -952,1 +952,1 @@\n-  \/\/ debug_only(destruct();)   \/\/ no reuse benefit expected\n+  \/\/ DEBUG_ONLY(destruct();)   \/\/ no reuse benefit expected\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-    debug_only(_last_del = _out[i]; ++_del_tick);\n+    DEBUG_ONLY(_last_del = _out[i]; ++_del_tick);\n@@ -438,1 +438,1 @@\n-    debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n+    DEBUG_ONLY(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n@@ -540,1 +540,1 @@\n-    debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n+    DEBUG_ONLY(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);\n@@ -543,1 +543,1 @@\n-    debug_only(_last_del = n; ++_del_tick);\n+    DEBUG_ONLY(_last_del = n; ++_del_tick);\n@@ -600,1 +600,1 @@\n-    debug_only(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n+    DEBUG_ONLY(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n@@ -1448,1 +1448,1 @@\n-    { _idx = 0;                         debug_only(sample(node)); }\n+    { _idx = 0;                         DEBUG_ONLY(sample(node)); }\n@@ -1453,1 +1453,1 @@\n-    { \/*initialize to garbage*\/         debug_only(_vdui = false); }\n+    { \/*initialize to garbage*\/         DEBUG_ONLY(_vdui = false); }\n@@ -1456,1 +1456,1 @@\n-    { _idx = that._idx;                 debug_only(_vdui = false; reset(that)); }\n+    { _idx = that._idx;                 DEBUG_ONLY(_vdui = false; reset(that)); }\n@@ -1468,1 +1468,1 @@\n-    { _idx = that._idx;                 debug_only(reset(that)); }\n+    { _idx = that._idx;                 DEBUG_ONLY(reset(that)); }\n@@ -1478,1 +1478,1 @@\n-  { I_VDUI_ONLY(i, i.verify(this));     return debug_only(i._last=) _out[i._idx]; }\n+  { I_VDUI_ONLY(i, i.verify(this));     return DEBUG_ONLY(i._last=) _out[i._idx]; }\n@@ -1513,1 +1513,1 @@\n-    { _outp = node->_out + offset;      debug_only(sample(node)); }\n+    { _outp = node->_out + offset;      DEBUG_ONLY(sample(node)); }\n@@ -1518,1 +1518,1 @@\n-    { \/*initialize to garbage*\/         debug_only(_vdui = false); }\n+    { \/*initialize to garbage*\/         DEBUG_ONLY(_vdui = false); }\n@@ -1521,1 +1521,1 @@\n-    { _outp = that._outp;               debug_only(_vdui = false; reset(that)); }\n+    { _outp = that._outp;               DEBUG_ONLY(_vdui = false; reset(that)); }\n@@ -1539,1 +1539,1 @@\n-    { _outp = that._outp;               debug_only(reset(that)); }\n+    { _outp = that._outp;               DEBUG_ONLY(reset(that)); }\n@@ -1550,1 +1550,1 @@\n-  return debug_only(i._last=) *i._outp;\n+  return DEBUG_ONLY(i._last=) *i._outp;\n@@ -1608,1 +1608,1 @@\n-  return debug_only(i._last=) *i._outp;\n+  return DEBUG_ONLY(i._last=) *i._outp;\n@@ -2052,1 +2052,1 @@\n-    debug_only(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n+    DEBUG_ONLY(uint check_hash = (VerifyHashTableKeys && _hash_lock) ? hash() : NO_HASH);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -3042,1 +3042,1 @@\n-  debug_only( def = (Node*)((intptr_t)0xdeadbeef); )\n+  DEBUG_ONLY( def = (Node*)((intptr_t)0xdeadbeef); )\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2019,1 +2019,1 @@\n-          debug_only(const Type* bt1 = phi->bottom_type());\n+          DEBUG_ONLY(const Type* bt1 = phi->bottom_type());\n@@ -2022,1 +2022,1 @@\n-          debug_only(const Type* bt2 = phi->bottom_type());\n+          DEBUG_ONLY(const Type* bt2 = phi->bottom_type());\n@@ -2119,1 +2119,1 @@\n-    debug_only(mms.set_memory());  \/\/ keep the iterator happy\n+    DEBUG_ONLY(mms.set_memory());  \/\/ keep the iterator happy\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    debug_only(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n+    DEBUG_ONLY(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n@@ -155,1 +155,1 @@\n-      debug_only(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n+      DEBUG_ONLY(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n@@ -191,1 +191,1 @@\n-  debug_only(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n+  DEBUG_ONLY(n->enter_hash_lock()); \/\/ Lock down the node while in the table.\n@@ -206,1 +206,1 @@\n-  debug_only( uint counter = 0; );\n+  DEBUG_ONLY( uint counter = 0; );\n@@ -208,1 +208,1 @@\n-    debug_only( counter++ );\n+    DEBUG_ONLY( counter++ );\n@@ -218,1 +218,1 @@\n-      debug_only(((Node*)n)->exit_hash_lock()); \/\/ Unlock the node upon removal from table.\n+      DEBUG_ONLY(((Node*)n)->exit_hash_lock()); \/\/ Unlock the node upon removal from table.\n@@ -260,1 +260,1 @@\n-    debug_only(m->exit_hash_lock()); \/\/ Unlock the node upon removal from old table.\n+    DEBUG_ONLY(m->exit_hash_lock()); \/\/ Unlock the node upon removal from old table.\n@@ -292,1 +292,1 @@\n-      debug_only(n->exit_hash_lock()); \/\/ Unlock the node when removed\n+      DEBUG_ONLY(n->exit_hash_lock()); \/\/ Unlock the node when removed\n@@ -1781,0 +1781,28 @@\n+\n+  \/* AndNode has a special handling when one of the operands is a LShiftNode:\n+   * (LHS << s) & RHS\n+   * if RHS fits in less than s bits, the value of this expression is 0.\n+   * The difficulty is that there might be a conversion node (ConvI2L) between\n+   * the LShiftINode and the AndLNode, like so:\n+   * AndLNode(ConvI2L(LShiftI(LHS, s)), RHS)\n+   * This case is handled by And[IL]Node::Value(PhaseGVN*)\n+   * (see `AndIL_min_trailing_zeros`).\n+   *\n+   * But, when the shift is updated during IGVN, pushing the user (ConvI2L)\n+   * is not enough: there might be no update happening there. We need to\n+   * directly push the And[IL]Node on the worklist, jumping over ConvI2L.\n+   *\n+   * Moreover we can have ConstraintCasts in between. It may look like\n+   * ConstraintCast+ -> ConvI2L -> ConstraintCast+ -> And\n+   * and And[IL]Node::Value(PhaseGVN*) still handles that by looking through casts.\n+   * So we must deal with that as well.\n+   *\/\n+  if (use->is_ConstraintCast() || use_op == Op_ConvI2L) {\n+    auto is_boundary = [](Node* n){ return !n->is_ConstraintCast() && n->Opcode() != Op_ConvI2L; };\n+    auto push_and_to_worklist = [&worklist](Node* n){\n+      if (n->Opcode() == Op_AndL || n->Opcode() == Op_AndI) {\n+        worklist.push(n);\n+      }\n+    };\n+    use->visit_uses(push_and_to_worklist, is_boundary);\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":36,"deletions":8,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1987,1 +1987,1 @@\n-  debug_only(NoHandleMark __hm;)\n+  DEBUG_ONLY(NoHandleMark __hm;)\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -815,1 +815,1 @@\n-  debug_only(base());           \/\/ Check the assertion in Type::base().\n+  DEBUG_ONLY(base());           \/\/ Check the assertion in Type::base().\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    debug_only(NoSafepointVerifier nosafepoint;)\n+    DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -240,1 +240,1 @@\n-    debug_only(NoSafepointVerifier nosafepoint;)\n+    DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -415,1 +415,1 @@\n-    debug_only(id->set_is_static_field_id();)\n+    DEBUG_ONLY(id->set_is_static_field_id();)\n@@ -478,1 +478,1 @@\n-  debug_only(Klass* super2 = ( k->is_array_klass()\n+  DEBUG_ONLY(Klass* super2 = ( k->is_array_klass()\n@@ -913,1 +913,1 @@\n-      debug_only(NoSafepointVerifier nosafepoint;)\n+      DEBUG_ONLY(NoSafepointVerifier nosafepoint;)\n@@ -2065,1 +2065,1 @@\n-  debug_only(id->set_is_static_field_id();)\n+  DEBUG_ONLY(id->set_is_static_field_id();)\n@@ -2067,1 +2067,1 @@\n-  debug_only(id->verify(fd.field_holder()));\n+  DEBUG_ONLY(id->verify(fd.field_holder()));\n@@ -2496,1 +2496,1 @@\n-    bad_address = os::reserve_memory(size, false, mtInternal);\n+    bad_address = os::reserve_memory(size, mtInternal);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2323,1 +2323,1 @@\n-  debug_only(intptr_t *lastPtr = (intptr_t *)((char *)&checked_jni_NativeInterface + \\\n+  DEBUG_ONLY(intptr_t *lastPtr = (intptr_t *)((char *)&checked_jni_NativeInterface + \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-    debug_only(VMNativeEntryWrapper __vew;)\n+    DEBUG_ONLY(VMNativeEntryWrapper __vew;)\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-  return (jlong)(uintptr_t)os::reserve_memory(size, false, mtTest);\n+  return (jlong)(uintptr_t)os::reserve_memory(size, mtTest);\n@@ -740,1 +740,1 @@\n-  return (jlong)(uintptr_t)os::attempt_reserve_memory_at((char*)(uintptr_t)addr, (size_t)size, false, mtTest);\n+  return (jlong)(uintptr_t)os::attempt_reserve_memory_at((char*)(uintptr_t)addr, (size_t)size, mtTest);\n@@ -1532,1 +1532,1 @@\n-  p = os::reserve_memory(os::vm_allocation_granularity());\n+  p = os::reserve_memory(os::vm_allocation_granularity(), mtTest);\n@@ -1541,1 +1541,1 @@\n-  const char* features = VM_Version::features_string();\n+  const char* features = VM_Version::cpu_info_string();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -336,1 +336,0 @@\n-        matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||\n@@ -347,0 +346,1 @@\n+          matches_property_suffix(property_suffix, ADDOPENS, ADDOPENS_LEN) ||\n@@ -3882,5 +3882,0 @@\n-\n-    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n-      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n-    }\n-    FLAG_SET_DEFAULT(UseVectorStubs, false);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  debug_only(_area->_handle_mark_nesting++);\n+  DEBUG_ONLY(_area->_handle_mark_nesting++);\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,2 +193,2 @@\n-    debug_only(_handle_mark_nesting    = 0);\n-    debug_only(_no_handle_mark_nesting = 0);\n+    DEBUG_ONLY(_handle_mark_nesting    = 0);\n+    DEBUG_ONLY(_no_handle_mark_nesting = 0);\n@@ -217,1 +217,1 @@\n-  debug_only(bool no_handle_mark_active() { return _no_handle_mark_nesting > 0; })\n+  DEBUG_ONLY(bool no_handle_mark_active() { return _no_handle_mark_nesting > 0; })\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  debug_only(_area->_handle_mark_nesting++);\n+  DEBUG_ONLY(_area->_handle_mark_nesting++);\n@@ -99,1 +99,1 @@\n-  debug_only(_area->_handle_mark_nesting--);\n+  DEBUG_ONLY(_area->_handle_mark_nesting--);\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  debug_only(_thread->inc_java_call_counter());\n+  DEBUG_ONLY(_thread->inc_java_call_counter());\n@@ -113,1 +113,1 @@\n-  debug_only(_thread->dec_java_call_counter());\n+  DEBUG_ONLY(_thread->dec_java_call_counter());\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -557,1 +557,1 @@\n-  debug_only(check_for_dangling_thread_pointer(this);)\n+  DEBUG_ONLY(check_for_dangling_thread_pointer(this);)\n@@ -573,1 +573,1 @@\n-  debug_only(check_for_dangling_thread_pointer(this);)\n+  DEBUG_ONLY(check_for_dangling_thread_pointer(this);)\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-      debug_only(id->set_is_static_field_id());\n+      DEBUG_ONLY(id->set_is_static_field_id());\n","filename":"src\/hotspot\/share\/runtime\/jfieldIDWorkaround.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -385,3 +385,3 @@\n-  debug_only(block->_last = nullptr);\n-  debug_only(block->_free_list = nullptr);\n-  debug_only(block->_allocate_before_rebuild = -1);\n+  DEBUG_ONLY(block->_last = nullptr);\n+  DEBUG_ONLY(block->_free_list = nullptr);\n+  DEBUG_ONLY(block->_allocate_before_rebuild = -1);\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2845,1 +2845,1 @@\n-                if (super_method->is_scalarized_arg(arg_num) debug_only(|| (stress && (os::random() & 1) == 1))) {\n+                if (super_method->is_scalarized_arg(arg_num) DEBUG_ONLY(|| (stress && (os::random() & 1) == 1))) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,2 +104,0 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,4 +311,0 @@\n-  \/\/ Vector Math Routines\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -707,0 +707,1 @@\n+     static_field(Abstract_VM_Version,         _cpu_info_string,                              const char*)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n@@ -415,1 +416,2 @@\n-  Universe::heap()->print_on(output());\n+  Universe::heap()->print_heap_on(output());\n+  MetaspaceUtils::print_on(output());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-  debug_only(_sub_record_left -= len);\n+  DEBUG_ONLY(_sub_record_left -= len);\n@@ -567,1 +567,1 @@\n-  debug_only(_sub_record_left -= len);\n+  DEBUG_ONLY(_sub_record_left -= len);\n@@ -691,2 +691,2 @@\n-  debug_only(_sub_record_left = len);\n-  debug_only(_sub_record_ended = false);\n+  DEBUG_ONLY(_sub_record_left = len);\n+  DEBUG_ONLY(_sub_record_ended = false);\n@@ -701,1 +701,1 @@\n-  debug_only(_sub_record_ended = true);\n+  DEBUG_ONLY(_sub_record_ended = true);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/forbiddenFunctions.hpp\"\n@@ -176,29 +177,0 @@\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ Forbid the use of various C library functions.\n-\/\/ Some of these have os:: replacements that should normally be used instead.\n-\/\/ Others are considered security concerns, with preferred alternatives.\n-\n-FORBID_C_FUNCTION(void exit(int), \"use os::exit\");\n-FORBID_C_FUNCTION(void _exit(int), \"use os::exit\");\n-FORBID_C_FUNCTION(char* strerror(int), \"use os::strerror\");\n-FORBID_C_FUNCTION(char* strtok(char*, const char*), \"use strtok_r\");\n-FORBID_C_FUNCTION(int sprintf(char*, const char*, ...), \"use os::snprintf\");\n-FORBID_C_FUNCTION(int vsprintf(char*, const char*, va_list), \"use os::vsnprintf\");\n-FORBID_C_FUNCTION(int vsnprintf(char*, size_t, const char*, va_list), \"use os::vsnprintf\");\n-\n-\/\/ All of the following functions return raw C-heap pointers (sometimes as an option, e.g. realpath or getwd)\n-\/\/ or, in case of free(), take raw C-heap pointers. Don't use them unless you are really sure you must.\n-FORBID_C_FUNCTION(void* malloc(size_t size), \"use os::malloc\");\n-FORBID_C_FUNCTION(void* calloc(size_t nmemb, size_t size), \"use os::malloc and zero out manually\");\n-FORBID_C_FUNCTION(void free(void *ptr), \"use os::free\");\n-FORBID_C_FUNCTION(void* realloc(void *ptr, size_t size), \"use os::realloc\");\n-FORBID_C_FUNCTION(char* strdup(const char *s), \"use os::strdup\");\n-FORBID_C_FUNCTION(char* strndup(const char *s, size_t n), \"don't use\");\n-FORBID_C_FUNCTION(int posix_memalign(void **memptr, size_t alignment, size_t size), \"don't use\");\n-FORBID_C_FUNCTION(void* aligned_alloc(size_t alignment, size_t size), \"don't use\");\n-FORBID_C_FUNCTION(char* realpath(const char* path, char* resolved_path), \"use os::realpath\");\n-FORBID_C_FUNCTION(char* get_current_dir_name(void), \"use os::get_current_directory()\");\n-FORBID_C_FUNCTION(char* getwd(char *buf), \"use os::get_current_directory()\");\n-FORBID_C_FUNCTION(wchar_t* wcsdup(const wchar_t *s), \"don't use\");\n-FORBID_C_FUNCTION(void* reallocf(void *ptr, size_t size), \"don't use\");\n-\n@@ -300,0 +272,3 @@\n+\/\/ for timer info max values which include all bits, 0xffffffffffffffff\n+const jlong all_bits_jlong = ~jlong(0);\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":29,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-  debug_only(GrowableArrayNestingCheck _nesting_check;)\n+  DEBUG_ONLY(GrowableArrayNestingCheck _nesting_check;)\n@@ -657,1 +657,1 @@\n-      debug_only(COMMA _nesting_check(true)) {\n+      DEBUG_ONLY(COMMA _nesting_check(true)) {\n@@ -663,1 +663,1 @@\n-      debug_only(COMMA _nesting_check(arena)) {\n+      DEBUG_ONLY(COMMA _nesting_check(arena)) {\n@@ -669,1 +669,1 @@\n-      debug_only(COMMA _nesting_check(false)) {\n+      DEBUG_ONLY(COMMA _nesting_check(false)) {\n@@ -737,1 +737,1 @@\n-  void init_checks() const { debug_only(_metadata.init_checks(this);) }\n+  void init_checks() const { DEBUG_ONLY(_metadata.init_checks(this);) }\n@@ -746,1 +746,1 @@\n-      debug_only(_metadata.on_resource_area_alloc_check());\n+      DEBUG_ONLY(_metadata.on_resource_area_alloc_check());\n@@ -755,1 +755,1 @@\n-    debug_only(_metadata.on_arena_alloc_check());\n+    DEBUG_ONLY(_metadata.on_arena_alloc_check());\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -133,1 +133,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Boolean.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,1 +359,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -382,1 +382,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Byte.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9244,1 +9244,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Character.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1055,1 +1055,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -1076,1 +1076,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -682,1 +682,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -698,1 +698,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -719,1 +719,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Float.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1038,1 +1038,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -1060,1 +1060,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1124,1 +1124,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -1147,1 +1147,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -365,1 +365,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n@@ -388,1 +388,1 @@\n-    @Deprecated(since=\"9\", forRemoval = true)\n+    @Deprecated(since=\"9\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Short.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-     * open and ready to supply input data. Typically this stream\n+     * open and ready to supply input data. This stream\n@@ -122,4 +122,3 @@\n-     * the host environment or user. In case this stream is wrapped\n-     * in a {@link java.io.InputStreamReader}, {@link Console#charset()}\n-     * should be used for the charset, or consider using\n-     * {@link Console#reader()}.\n+     * the host environment or user. Applications should use the encoding\n+     * specified by the {@link ##stdin.encoding stdin.encoding} property\n+     * to convert input bytes to character data.\n@@ -127,2 +126,11 @@\n-     * @see Console#charset()\n-     * @see Console#reader()\n+     * @apiNote\n+     * The typical approach to read character data is to wrap {@code System.in}\n+     * within an {@link java.io.InputStreamReader InputStreamReader} or other object\n+     * that handles character encoding. After this is done, subsequent reading should\n+     * use only the wrapper object; operating directly on {@code System.in} results\n+     * in unspecified behavior.\n+     * <p>\n+     * For handling interactive input, consider using {@link Console}.\n+     *\n+     * @see Console\n+     * @see ##stdin.encoding stdin.encoding\n@@ -579,2 +587,7 @@\n-     *     <td>Character encoding name derived from the host environment and\/or\n-     *     the user's settings. Setting this system property has no effect.<\/td><\/tr>\n+     *     <td>Character encoding name derived from the host environment and\n+     *     the user's settings. Setting this system property on the command line\n+     *     has no effect.<\/td><\/tr>\n+     * <tr><th scope=\"row\">{@systemProperty stdin.encoding}<\/th>\n+     *     <td>Character encoding name for {@link System#in System.in}.\n+     *     The Java runtime can be started with the system property set to {@code UTF-8}.\n+     *     Starting it with the property set to another value results in unspecified behavior.\n@@ -584,2 +597,2 @@\n-     *     The Java runtime can be started with the system property set to {@code UTF-8},\n-     *     starting it with the property set to another value leads to undefined behavior.\n+     *     The Java runtime can be started with the system property set to {@code UTF-8}.\n+     *     Starting it with the property set to another value results in unspecified behavior.\n@@ -588,2 +601,2 @@\n-     *     The Java runtime can be started with the system property set to {@code UTF-8},\n-     *     starting it with the property set to another value leads to undefined behavior.\n+     *     The Java runtime can be started with the system property set to {@code UTF-8}.\n+     *     Starting it with the property set to another value results in unspecified behavior.\n@@ -643,1 +656,1 @@\n-     *     {@code COMPAT} leads to unspecified behavior.\n+     *     {@code COMPAT} results in unspecified behavior.\n@@ -2063,3 +2076,0 @@\n-            public void addOpensToAllUnnamed(Module m, Set<String> concealedPackages, Set<String> exportedPackages) {\n-                m.implAddOpensToAllUnnamed(concealedPackages, exportedPackages);\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.value.ValueClass;\n@@ -217,1 +218,0 @@\n-        maybeCompile(lform, m);\n@@ -323,6 +323,0 @@\n-    private static void maybeCompile(LambdaForm lform, MemberName m) {\n-        if (lform.vmentry == null && VerifyAccess.isSamePackage(m.getDeclaringClass(), MethodHandle.class))\n-            \/\/ Help along bootstrapping...\n-            lform.compileToBytecode();\n-    }\n-\n@@ -646,6 +640,21 @@\n-            FT_LAST_WRAPPER     = Wrapper.COUNT-1,\n-            FT_UNCHECKED_REF    = Wrapper.OBJECT.ordinal(),\n-            FT_CHECKED_REF      = FT_LAST_WRAPPER+1,\n-            FT_CHECKED_VALUE    = FT_LAST_WRAPPER+2,  \/\/ flat vs non-flat x null value vs null-restricted value\n-            FT_LIMIT            = FT_LAST_WRAPPER+6;\n-    private static int afIndex(byte formOp, boolean isVolatile, boolean isFlat, boolean isNullRestricted, int ftypeKind) {\n+            FT_FIRST_REFERENCE = 8,\n+            \/\/ Any oop, same sig (Runnable?)\n+            FT_UNCHECKED_REF    = FT_FIRST_REFERENCE,\n+            \/\/ Oop with type checks (Number?)\n+            FT_CHECKED_REF      = FT_FIRST_REFERENCE + 1,\n+            \/\/ Oop with null checks, (Runnable!)\n+            FT_UNCHECKED_NR_REF = FT_FIRST_REFERENCE + 2,\n+            \/\/ Oop with null and type checks, (Number!)\n+            FT_CHECKED_NR_REF   = FT_FIRST_REFERENCE + 3,\n+            FT_FIRST_FLAT = FT_FIRST_REFERENCE + 4,\n+            \/\/ nullable flat (must check type), (Integer?)\n+            FT_NULLABLE_FLAT    = FT_FIRST_FLAT,\n+            \/\/ Null restricted flat (must check type), (Integer!)\n+            FT_NR_FLAT          = FT_FIRST_FLAT + 1,\n+            FT_LIMIT            = FT_FIRST_FLAT + 2;\n+\n+    static {\n+        assert FT_FIRST_REFERENCE == Wrapper.OBJECT.ordinal();\n+    }\n+\n+    private static int afIndex(byte formOp, boolean isVolatile, int ftypeKind) {\n@@ -654,2 +663,0 @@\n-                + (isFlat ? 1 : 0)\n-                + (isNullRestricted ? 1 : 0)\n@@ -660,2 +667,2 @@\n-            = new LambdaForm[afIndex(AF_LIMIT, false, false, false, 0)];\n-    static int ftypeKind(Class<?> ftype) {\n+            = new LambdaForm[afIndex(AF_LIMIT, false, 0)];\n+    static int ftypeKind(Class<?> ftype, boolean isFlat, boolean isNullRestricted) {\n@@ -663,0 +670,1 @@\n+            assert !isFlat && !isNullRestricted : ftype;\n@@ -665,0 +673,1 @@\n+            assert !isFlat : ftype;\n@@ -666,3 +675,1 @@\n-            return FT_UNCHECKED_REF;\n-        } else {\n-            return ftype.isValue() ? FT_CHECKED_VALUE : FT_CHECKED_REF;\n+            return isNullRestricted ? FT_UNCHECKED_NR_REF : FT_UNCHECKED_REF;\n@@ -670,0 +677,5 @@\n+        if (isFlat) {\n+            assert ValueClass.isConcreteValueClass(ftype) : ftype;\n+            return isNullRestricted ? FT_NR_FLAT : FT_NULLABLE_FLAT;\n+        }\n+        return isNullRestricted ? FT_CHECKED_NR_REF : FT_CHECKED_REF;\n@@ -694,1 +706,0 @@\n-        maybeCompile(lform, m);\n@@ -703,2 +714,6 @@\n-        int ftypeKind = ftypeKind(ftype);\n-        int afIndex = afIndex(formOp, isVolatile, isFlat, isNullRestricted, ftypeKind);\n+        int ftypeKind = ftypeKind(ftype, isFlat, isNullRestricted);\n+        return preparedFieldLambdaForm(formOp, isVolatile, ftypeKind);\n+    }\n+\n+    private static LambdaForm preparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {\n+        int afIndex = afIndex(formOp, isVolatile, ftypeKind);\n@@ -707,1 +722,1 @@\n-        lform = makePreparedFieldLambdaForm(formOp, isVolatile,isFlat, isNullRestricted, ftypeKind);\n+        lform = makePreparedFieldLambdaForm(formOp, isVolatile, ftypeKind);\n@@ -712,1 +727,32 @@\n-    private static final Wrapper[] ALL_WRAPPERS = Wrapper.values();\n+    private static final @Stable Wrapper[] ALL_WRAPPERS = Wrapper.values();\n+\n+    \/\/ Names in kind may overload but differ from their basic type\n+    private static Kind getFieldKind(boolean isGetter,\n+                                     boolean isVolatile,\n+                                     boolean needsInit,\n+                                     boolean needsCast,\n+                                     boolean isFlat,\n+                                     boolean isNullRestricted,\n+                                     Wrapper wrapper) {\n+        if (!wrapper.isOther()) {\n+            \/\/ primitives\n+            assert !isFlat && !isNullRestricted && !needsCast;\n+            return switch (wrapper) {\n+                case BYTE -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_B : VOLATILE_FIELD_ACCESS_B)\n+                        : (needsInit ? FIELD_ACCESS_INIT_B : FIELD_ACCESS_B);\n+                case CHAR -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_C : VOLATILE_FIELD_ACCESS_C)\n+                        : (needsInit ? FIELD_ACCESS_INIT_C : FIELD_ACCESS_C);\n+                case SHORT -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_S : VOLATILE_FIELD_ACCESS_S)\n+                        : (needsInit ? FIELD_ACCESS_INIT_S : FIELD_ACCESS_S);\n+                case BOOLEAN -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT_Z : VOLATILE_FIELD_ACCESS_Z)\n+                        : (needsInit ? FIELD_ACCESS_INIT_Z : FIELD_ACCESS_Z);\n+                \/\/ basic types\n+                default -> isVolatile\n+                        ? (needsInit ? VOLATILE_FIELD_ACCESS_INIT : VOLATILE_FIELD_ACCESS)\n+                        : (needsInit ? FIELD_ACCESS_INIT : FIELD_ACCESS);\n+            };\n+        }\n@@ -714,13 +760,10 @@\n-    private static Kind getFieldKind(boolean isGetter, boolean isVolatile, boolean isFlat, Wrapper wrapper) {\n-        if (isGetter) {\n-            if (isVolatile) {\n-                switch (wrapper) {\n-                    case BOOLEAN: return GET_BOOLEAN_VOLATILE;\n-                    case BYTE:    return GET_BYTE_VOLATILE;\n-                    case SHORT:   return GET_SHORT_VOLATILE;\n-                    case CHAR:    return GET_CHAR_VOLATILE;\n-                    case INT:     return GET_INT_VOLATILE;\n-                    case LONG:    return GET_LONG_VOLATILE;\n-                    case FLOAT:   return GET_FLOAT_VOLATILE;\n-                    case DOUBLE:  return GET_DOUBLE_VOLATILE;\n-                    case OBJECT:  return isFlat ? GET_FLAT_VALUE_VOLATILE : GET_REFERENCE_VOLATILE;\n+        assert !(isGetter && isNullRestricted);\n+        if (isVolatile) {\n+            if (isFlat) {\n+                assert !needsInit && needsCast;\n+                return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_FLAT_VALUE : VOLATILE_FIELD_ACCESS_FLAT;\n+            } else if (needsCast) {\n+                if (needsInit) {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT : VOLATILE_FIELD_ACCESS_INIT_CAST;\n+                } else {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST : VOLATILE_FIELD_ACCESS_CAST;\n@@ -729,10 +772,4 @@\n-                switch (wrapper) {\n-                    case BOOLEAN: return GET_BOOLEAN;\n-                    case BYTE:    return GET_BYTE;\n-                    case SHORT:   return GET_SHORT;\n-                    case CHAR:    return GET_CHAR;\n-                    case INT:     return GET_INT;\n-                    case LONG:    return GET_LONG;\n-                    case FLOAT:   return GET_FLOAT;\n-                    case DOUBLE:  return GET_DOUBLE;\n-                    case OBJECT:  return isFlat ? GET_FLAT_VALUE : GET_REFERENCE;\n+                if (needsInit) {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_INIT : VOLATILE_FIELD_ACCESS_INIT;\n+                } else {\n+                    return isNullRestricted ? VOLATILE_PUT_NULL_RESTRICTED_REFERENCE : VOLATILE_FIELD_ACCESS;\n@@ -742,11 +779,8 @@\n-            if (isVolatile) {\n-                switch (wrapper) {\n-                    case BOOLEAN: return PUT_BOOLEAN_VOLATILE;\n-                    case BYTE:    return PUT_BYTE_VOLATILE;\n-                    case SHORT:   return PUT_SHORT_VOLATILE;\n-                    case CHAR:    return PUT_CHAR_VOLATILE;\n-                    case INT:     return PUT_INT_VOLATILE;\n-                    case LONG:    return PUT_LONG_VOLATILE;\n-                    case FLOAT:   return PUT_FLOAT_VOLATILE;\n-                    case DOUBLE:  return PUT_DOUBLE_VOLATILE;\n-                    case OBJECT:  return isFlat ? PUT_FLAT_VALUE_VOLATILE : PUT_REFERENCE_VOLATILE;\n+            if (isFlat) {\n+                assert !needsInit && needsCast;\n+                return isNullRestricted ? PUT_NULL_RESTRICTED_FLAT_VALUE : FIELD_ACCESS_FLAT;\n+            } else if (needsCast) {\n+                if (needsInit) {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT : FIELD_ACCESS_INIT_CAST;\n+                } else {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE_CAST : FIELD_ACCESS_CAST;\n@@ -755,10 +789,4 @@\n-                switch (wrapper) {\n-                    case BOOLEAN: return PUT_BOOLEAN;\n-                    case BYTE:    return PUT_BYTE;\n-                    case SHORT:   return PUT_SHORT;\n-                    case CHAR:    return PUT_CHAR;\n-                    case INT:     return PUT_INT;\n-                    case LONG:    return PUT_LONG;\n-                    case FLOAT:   return PUT_FLOAT;\n-                    case DOUBLE:  return PUT_DOUBLE;\n-                    case OBJECT:  return isFlat ? PUT_FLAT_VALUE : PUT_REFERENCE;\n+                if (needsInit) {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE_INIT : FIELD_ACCESS_INIT;\n+                } else {\n+                    return isNullRestricted ? PUT_NULL_RESTRICTED_REFERENCE : FIELD_ACCESS;\n@@ -768,1 +796,0 @@\n-        throw new AssertionError(\"Invalid arguments\");\n@@ -771,3 +798,22 @@\n-    \/** invoked by GenerateJLIClassesHelper *\/\n-    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftype) {\n-        return makePreparedFieldLambdaForm(formOp, isVolatile, false, false, ftype);\n+    private static String unsafeMethodName(boolean isGetter,\n+                                           boolean isVolatile,\n+                                           Wrapper wrapper) {\n+        var name = switch (wrapper) {\n+            case BOOLEAN -> \"Boolean\";\n+            case BYTE -> \"Byte\";\n+            case CHAR -> \"Char\";\n+            case SHORT -> \"Short\";\n+            case INT -> \"Int\";\n+            case FLOAT -> \"Float\";\n+            case LONG -> \"Long\";\n+            case DOUBLE -> \"Double\";\n+            case OBJECT -> \"Reference\";\n+            case VOID -> \"FlatValue\";\n+        };\n+        var sb = new StringBuilder(3 + name.length() + (isVolatile ? 8 : 0))\n+                .append(isGetter ? \"get\" : \"put\")\n+                .append(name);\n+        if (isVolatile) {\n+            sb.append(\"Volatile\");\n+        }\n+        return sb.toString();\n@@ -776,2 +822,1 @@\n-    private static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile,\n-                                                          boolean isFlat, boolean isNullRestricted, int ftypeKind) {\n+    static LambdaForm makePreparedFieldLambdaForm(byte formOp, boolean isVolatile, int ftypeKind) {\n@@ -781,4 +826,20 @@\n-        boolean needsCast = (ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_VALUE);\n-        Wrapper fw = (needsCast ? Wrapper.OBJECT : ALL_WRAPPERS[ftypeKind]);\n-        Class<?> ft = fw.primitiveType();\n-        assert(needsCast ? true : ftypeKind(ft) == ftypeKind);\n+        boolean isFlat = (ftypeKind >= FT_FIRST_FLAT);\n+        boolean isNullRestricted = (ftypeKind == FT_NR_FLAT || ftypeKind == FT_CHECKED_NR_REF || ftypeKind == FT_UNCHECKED_NR_REF);\n+        boolean needsCast = (isFlat || ftypeKind == FT_CHECKED_REF || ftypeKind == FT_CHECKED_NR_REF);\n+\n+        if (isGetter && isNullRestricted) {\n+            int newKind = switch (ftypeKind) {\n+                case FT_NR_FLAT -> FT_NULLABLE_FLAT;\n+                case FT_CHECKED_NR_REF -> FT_CHECKED_REF;\n+                case FT_UNCHECKED_NR_REF -> FT_UNCHECKED_REF;\n+                default -> throw new InternalError();\n+            };\n+            return preparedFieldLambdaForm(formOp, isVolatile, newKind);\n+        }\n+\n+        if (isFlat && isStatic)\n+            throw new InternalError(\"Static flat not supported yet\");\n+\n+        \/\/ primitives, reference, and void for flat\n+        Wrapper fw = ftypeKind < FT_FIRST_REFERENCE ? ALL_WRAPPERS[ftypeKind] :\n+                isFlat ? Wrapper.VOID : Wrapper.OBJECT;\n@@ -787,1 +848,5 @@\n-        Kind kind = getFieldKind(isGetter, isVolatile, isFlat, fw);\n+        String unsafeMethodName = unsafeMethodName(isGetter, isVolatile, fw);\n+        \/\/ isGetter and isStatic is reflected in field type;\n+        \/\/ flat, NR distinguished\n+        \/\/ basic type clash for subwords\n+        Kind kind = getFieldKind(isGetter, isVolatile, needsInit, needsCast, isFlat, isNullRestricted, fw);\n@@ -789,0 +854,1 @@\n+        Class<?> ft = ftypeKind < FT_FIRST_REFERENCE ? fw.primitiveType() : Object.class;\n@@ -799,1 +865,1 @@\n-        MemberName linker = new MemberName(Unsafe.class, kind.methodName, linkerType, REF_invokeVirtual);\n+        MemberName linker = new MemberName(Unsafe.class, unsafeMethodName, linkerType, REF_invokeVirtual);\n@@ -857,1 +923,0 @@\n-            assert !isStatic : \"static field is flat form requested\";\n@@ -871,7 +936,1 @@\n-        LambdaForm form;\n-        if (needsCast || needsInit) {\n-            \/\/ can't use the pre-generated form when casting and\/or initializing\n-            form = LambdaForm.create(ARG_LIMIT, names, RESULT);\n-        } else {\n-            form = LambdaForm.create(ARG_LIMIT, names, RESULT, kind);\n-        }\n+        LambdaForm form = LambdaForm.create(ARG_LIMIT, names, RESULT, kind);\n@@ -882,1 +941,1 @@\n-            StringBuilder nameBuilder = new StringBuilder(kind.methodName);\n+            StringBuilder nameBuilder = new StringBuilder(unsafeMethodName);\n@@ -888,0 +947,3 @@\n+            if (isNullRestricted) {\n+                nameBuilder.append(\"NullRestricted\");\n+            }\n@@ -896,0 +958,3 @@\n+\n+        \/\/ NF_UNSAFE uses field form, avoid circular dependency in interpreter\n+        form.compileToBytecode();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":155,"deletions":90,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.List;\n@@ -432,3 +433,5 @@\n-        for (Wrapper wrapper : Wrapper.values()) {\n-            if (wrapper == Wrapper.VOID) {\n-                continue;\n+        record FieldLfToken(byte formOp, int ftypeKind) {}\n+        List<FieldLfToken> tokens = new ArrayList<>();\n+        for (int i = 0; i <= DirectMethodHandle.FT_CHECKED_REF; i++) {\n+            for (byte formOp = DirectMethodHandle.AF_GETFIELD; formOp < DirectMethodHandle.AF_LIMIT; formOp++) {\n+                tokens.add(new FieldLfToken(formOp, i));\n@@ -436,14 +439,6 @@\n-            for (byte b = DirectMethodHandle.AF_GETFIELD; b < DirectMethodHandle.AF_LIMIT; b++) {\n-                int ftype = DirectMethodHandle.ftypeKind(wrapper.primitiveType());\n-                LambdaForm form = DirectMethodHandle\n-                        .makePreparedFieldLambdaForm(b, \/*isVolatile*\/false, ftype);\n-                if (form.kind != LambdaForm.Kind.GENERIC) {\n-                    forms.add(form);\n-                    names.add(form.kind.defaultLambdaName);\n-                }\n-                \/\/ volatile\n-                form = DirectMethodHandle\n-                        .makePreparedFieldLambdaForm(b, \/*isVolatile*\/true, ftype);\n-                if (form.kind != LambdaForm.Kind.GENERIC) {\n-                    forms.add(form);\n-                    names.add(form.kind.defaultLambdaName);\n+        }\n+        for (int i : new int[] {DirectMethodHandle.FT_UNCHECKED_NR_REF, DirectMethodHandle.FT_CHECKED_NR_REF}) {\n+            for (byte formOp = DirectMethodHandle.AF_GETFIELD; formOp < DirectMethodHandle.AF_LIMIT; formOp++) {\n+                boolean isGetter = (formOp & 1) == (DirectMethodHandle.AF_GETFIELD & 1);\n+                if (!isGetter) {\n+                    tokens.add(new FieldLfToken(formOp, i));\n@@ -453,0 +448,22 @@\n+        \/\/ Only legal flat combinations; no static\n+        tokens.add(new FieldLfToken(DirectMethodHandle.AF_GETFIELD, DirectMethodHandle.FT_NULLABLE_FLAT));\n+        tokens.add(new FieldLfToken(DirectMethodHandle.AF_PUTFIELD, DirectMethodHandle.FT_NULLABLE_FLAT));\n+        tokens.add(new FieldLfToken(DirectMethodHandle.AF_PUTFIELD, DirectMethodHandle.FT_NR_FLAT));\n+        \/\/ Compile\n+        for (var token : tokens) {\n+            byte b = token.formOp;\n+            int ftype = token.ftypeKind;\n+            LambdaForm form = DirectMethodHandle\n+                    .makePreparedFieldLambdaForm(b, \/*isVolatile*\/false, ftype);\n+            if (form.kind == GENERIC)\n+                throw new InternalError(b + \" non-volatile \" + ftype);\n+            forms.add(form);\n+            names.add(form.kind.defaultLambdaName);\n+            \/\/ volatile\n+            form = DirectMethodHandle\n+                    .makePreparedFieldLambdaForm(b, \/*isVolatile*\/true, ftype);\n+            if (form.kind == GENERIC)\n+                throw new InternalError(b + \" volatile \" + ftype);\n+            forms.add(form);\n+            names.add(form.kind.defaultLambdaName);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -266,40 +266,48 @@\n-        GET_REFERENCE(\"getReference\"),\n-        PUT_REFERENCE(\"putReference\"),\n-        GET_REFERENCE_VOLATILE(\"getReferenceVolatile\"),\n-        PUT_REFERENCE_VOLATILE(\"putReferenceVolatile\"),\n-        GET_FLAT_VALUE(\"getFlatValue\"),\n-        PUT_FLAT_VALUE(\"putFlatValue\"),\n-        GET_FLAT_VALUE_VOLATILE(\"getFlatValueVolatile\"),\n-        PUT_FLAT_VALUE_VOLATILE(\"putFlatValueVolatile\"),\n-        GET_INT(\"getInt\"),\n-        PUT_INT(\"putInt\"),\n-        GET_INT_VOLATILE(\"getIntVolatile\"),\n-        PUT_INT_VOLATILE(\"putIntVolatile\"),\n-        GET_BOOLEAN(\"getBoolean\"),\n-        PUT_BOOLEAN(\"putBoolean\"),\n-        GET_BOOLEAN_VOLATILE(\"getBooleanVolatile\"),\n-        PUT_BOOLEAN_VOLATILE(\"putBooleanVolatile\"),\n-        GET_BYTE(\"getByte\"),\n-        PUT_BYTE(\"putByte\"),\n-        GET_BYTE_VOLATILE(\"getByteVolatile\"),\n-        PUT_BYTE_VOLATILE(\"putByteVolatile\"),\n-        GET_CHAR(\"getChar\"),\n-        PUT_CHAR(\"putChar\"),\n-        GET_CHAR_VOLATILE(\"getCharVolatile\"),\n-        PUT_CHAR_VOLATILE(\"putCharVolatile\"),\n-        GET_SHORT(\"getShort\"),\n-        PUT_SHORT(\"putShort\"),\n-        GET_SHORT_VOLATILE(\"getShortVolatile\"),\n-        PUT_SHORT_VOLATILE(\"putShortVolatile\"),\n-        GET_LONG(\"getLong\"),\n-        PUT_LONG(\"putLong\"),\n-        GET_LONG_VOLATILE(\"getLongVolatile\"),\n-        PUT_LONG_VOLATILE(\"putLongVolatile\"),\n-        GET_FLOAT(\"getFloat\"),\n-        PUT_FLOAT(\"putFloat\"),\n-        GET_FLOAT_VOLATILE(\"getFloatVolatile\"),\n-        PUT_FLOAT_VOLATILE(\"putFloatVolatile\"),\n-        GET_DOUBLE(\"getDouble\"),\n-        PUT_DOUBLE(\"putDouble\"),\n-        GET_DOUBLE_VOLATILE(\"getDoubleVolatile\"),\n-        PUT_DOUBLE_VOLATILE(\"putDoubleVolatile\"),\n+        \/\/ Start field forms\n+        \/\/ IJFDL, instance\/static differ in method type, can share form\n+        \/\/ init form only applicable to static\n+        FIELD_ACCESS(\"fieldAccess\"),\n+        FIELD_ACCESS_INIT(\"fieldAccessInit\"),\n+        VOLATILE_FIELD_ACCESS(\"volatileFieldAccess\"),\n+        VOLATILE_FIELD_ACCESS_INIT(\"volatileFieldAccessInit\"),\n+        \/\/ BCSZ need own forms to avoid clashing with basic type I, +-init\/volatile\n+        FIELD_ACCESS_B(\"fieldAccessB\"),\n+        FIELD_ACCESS_INIT_B(\"fieldAccessInitB\"),\n+        VOLATILE_FIELD_ACCESS_B(\"volatileFieldAccessB\"),\n+        VOLATILE_FIELD_ACCESS_INIT_B(\"volatileFieldAccessInitB\"),\n+        FIELD_ACCESS_C(\"fieldAccessC\"),\n+        FIELD_ACCESS_INIT_C(\"fieldAccessInitC\"),\n+        VOLATILE_FIELD_ACCESS_C(\"volatileFieldAccessC\"),\n+        VOLATILE_FIELD_ACCESS_INIT_C(\"volatileFieldAccessInitC\"),\n+        FIELD_ACCESS_S(\"fieldAccessS\"),\n+        FIELD_ACCESS_INIT_S(\"fieldAccessInitS\"),\n+        VOLATILE_FIELD_ACCESS_S(\"volatileFieldAccessS\"),\n+        VOLATILE_FIELD_ACCESS_INIT_S(\"volatileFieldAccessInitS\"),\n+        FIELD_ACCESS_Z(\"fieldAccessZ\"),\n+        FIELD_ACCESS_INIT_Z(\"fieldAccessInitZ\"),\n+        VOLATILE_FIELD_ACCESS_Z(\"volatileFieldAccessZ\"),\n+        VOLATILE_FIELD_ACCESS_INIT_Z(\"volatileFieldAccessInitZ\"),\n+        \/\/ cast, nr, flat need their own forms to avoid clashing with L\n+        FIELD_ACCESS_CAST(\"fieldAccessCast\"),\n+        FIELD_ACCESS_INIT_CAST(\"fieldAccessInitCast\"),\n+        VOLATILE_FIELD_ACCESS_CAST(\"volatileFieldAccessCast\"),\n+        VOLATILE_FIELD_ACCESS_INIT_CAST(\"volatileFieldAccessInitCast\"),\n+        \/\/ null-check and put reference, +-cast, +-init\/volatile\n+        \/\/ non-cast forms serve bytecode emulation purpose, which always enforces null checks\n+        PUT_NULL_RESTRICTED_REFERENCE(\"putNullRestrictedReference\"),\n+        PUT_NULL_RESTRICTED_REFERENCE_INIT(\"putNullRestrictedReferenceInit\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE(\"volatilePutNullRestrictedReference\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_INIT(\"volatilePutNullRestrictedReferenceInit\"),\n+        PUT_NULL_RESTRICTED_REFERENCE_CAST(\"putNullRestrictedReferenceCast\"),\n+        PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT(\"putNullRestrictedReferenceInitCast\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST(\"volatilePutNullRestrictedReferenceCast\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_REFERENCE_CAST_INIT(\"volatilePutNullRestrictedReferenceCastInit\"),\n+        \/\/ flat implies cast, +-init\/volatile\n+        FIELD_ACCESS_FLAT(\"fieldAccessFlat\"),\n+        FIELD_ACCESS_INIT_FLAT(\"fieldAccessInitFlat\"),\n+        VOLATILE_FIELD_ACCESS_FLAT(\"volatileFieldAccessFlat\"),\n+        VOLATILE_FIELD_ACCESS_INIT_FLAT(\"volatileFieldAccessInitFlat\"),\n+        \/\/ write guard NR flat, implies cast; +-volatile; no init forms - no flat in static fields yet\n+        PUT_NULL_RESTRICTED_FLAT_VALUE(\"putNullRestrictedFlatValue\"),\n+        VOLATILE_PUT_NULL_RESTRICTED_FLAT_VALUE(\"volatilePutNullRestrictedFlatValue\"),\n+        \/\/ End fields\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":48,"deletions":40,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -730,1 +730,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings(\"deprecation\")\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -671,18 +671,0 @@\n-\n-    \/\/--- AOTCache support\n-\n-    \/**\n-     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n-     * use soft references to allow class unloading.\n-     *\n-     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n-     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n-     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n-     * Such classes will never be unloaded, so it's OK to use hard references.\n-     *\/\n-    static final boolean USE_SOFT_CACHE;\n-\n-    static {\n-        USE_SOFT_CACHE = Boolean.parseBoolean(\n-                System.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-     *   queue = ReferenceQueue.NULL; next = this.\n+     *   queue = ReferenceQueue.NULL_QUEUE; next = this.\n@@ -92,1 +92,1 @@\n-     *   queue = ReferenceQueue.NULL.\n+     *   queue = ReferenceQueue.NULL_QUEUE.\n@@ -174,2 +174,2 @@\n-     *        dequeued: ReferenceQueue.NULL\n-     *    unregistered: ReferenceQueue.NULL\n+     *        dequeued: ReferenceQueue.NULL_QUEUE\n+     *    unregistered: ReferenceQueue.NULL_QUEUE\n@@ -245,1 +245,1 @@\n-        if (q != ReferenceQueue.NULL) q.enqueue(this);\n+        if (q != ReferenceQueue.NULL_QUEUE) q.enqueue(this);\n@@ -319,0 +319,1 @@\n+    \/\/ Called from JVM when loading an AOT cache\n@@ -320,0 +321,4 @@\n+        runtimeSetup();\n+    }\n+\n+    private static void runtimeSetup() {\n@@ -556,1 +561,1 @@\n-        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;\n+        this.queue = (queue == null) ? ReferenceQueue.NULL_QUEUE : queue;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,14 @@\n-import java.util.Collections;\n-import java.util.Objects;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.module.ModuleDescriptor;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n@@ -34,0 +46,2 @@\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n@@ -35,2 +49,7 @@\n-import java.util.function.Function;\n-import static java.util.Map.entry;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.reflect.ClassFileFormatVersion.*;\n@@ -99,5 +118,0 @@\n-    \/\/ Note to maintainers: anonymous class instances are used rather\n-    \/\/ than lambdas to initialize the functions used for the\n-    \/\/ cffvToLocations field to avoid using lambdas too early in JDK\n-    \/\/ initialization.\n-\n@@ -110,9 +124,2 @@\n-           Location.SET_PUBLIC_1,\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_CLASS_FIELD_METHOD:\n-                       Location.SET_PUBLIC_1;\n-               }\n-           }),\n+           Location.SET_CLASS_FIELD_METHOD_INNER_CLASS,\n+           List.of(Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -126,8 +133,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                    public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                        Location.SET_FIELD_METHOD:\n-                        Location.SET_FIELD_METHOD_INNER_CLASS;\n-                }\n-            }),\n+            List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -141,8 +141,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                      Location.SET_FIELD_METHOD:\n-                      Location.SET_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -156,7 +149,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                       Location.SET_FIELD_METHOD:\n-                       Location.SET_FIELD_METHOD_INNER_CLASS;}\n-           }),\n+           List.of(Map.entry(RELEASE_0, Location.SET_FIELD_METHOD))),\n@@ -171,12 +158,2 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-              @Override\n-              public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                  if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n-                      return Location.SET_FINAL_8;\n-                  } else {\n-                      return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n-                          Location.SET_CLASS_FIELD_METHOD :\n-                          Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n-                  }\n-              }\n-          }),\n+          List.of(Map.entry(RELEASE_7, Location.SET_CLASS_FIELD_METHOD_INNER_CLASS),\n+                  Map.entry(RELEASE_0, Location.SET_CLASS_FIELD_METHOD))),\n@@ -195,8 +172,2 @@\n-            PreviewFeatures.isEnabled() ? Location.EMPTY_SET : Location.SET_CLASS,\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-            @Override\n-            public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                return (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0) &&\n-                        PreviewFeatures.isEnabled() ? Location.EMPTY_SET : Location.SET_CLASS;\n-            }\n-        }),\n+          PreviewFeatures.isEnabled() ? Location.EMPTY_SET : Location.SET_CLASS,\n+          List.of()),\n@@ -215,8 +186,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0\n-                            && PreviewFeatures.isEnabled())\n-                            ? Location.SET_CLASS_INNER_CLASS : Location.EMPTY_SET;\n-                }\n-            }),\n+            List.of()),\n@@ -230,7 +194,1 @@\n-         new Function<ClassFileFormatVersion, Set<Location>>() {\n-             @Override\n-             public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                     Location.SET_MODULE:\n-                     Location.EMPTY_SET;}\n-         }),\n+         List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -244,7 +202,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                           Location.SET_MODULE_REQUIRES:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -257,1 +209,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, null),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, List.of()),\n@@ -265,7 +217,1 @@\n-                 new Function<ClassFileFormatVersion, Set<Location>>() {\n-                     @Override\n-                     public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                         return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                             Location.SET_MODULE_REQUIRES:\n-                             Location.EMPTY_SET;}\n-                 }),\n+                 List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -278,1 +224,1 @@\n-    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, null),\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, List.of()),\n@@ -286,7 +232,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -299,1 +239,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, null),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, List.of()),\n@@ -303,1 +243,1 @@\n-     <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n+     * <code>{@value \"0x%04x\" Modifier#VARARGS}<\/code>.\n@@ -307,7 +247,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                        Location.SET_METHOD:\n-                        Location.EMPTY_SET;}\n-            }),\n+            List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -320,1 +254,1 @@\n-    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, null),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, List.of()),\n@@ -328,7 +262,1 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                          Location.SET_CLASS:\n-                          Location.SET_CLASS_INNER_CLASS;}\n-              }),\n+              List.of(Map.entry(RELEASE_0, Location.SET_CLASS))),\n@@ -343,7 +271,1 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n-                         Location.SET_CLASS_METHOD:\n-                         Location.SET_CLASS_METHOD_INNER_CLASS;}\n-             }),\n+             List.of(Map.entry(RELEASE_0, Location.SET_CLASS_METHOD))),\n@@ -362,8 +284,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n-                           cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n-                       Location.SET_METHOD:\n-                       Location.EMPTY_SET;}\n-           }),\n+           List.of(Map.entry(RELEASE_16, Location.SET_METHOD),\n+                   Map.entry(RELEASE_1, Location.EMPTY_SET))),\n@@ -381,8 +297,1 @@\n-            new Function<ClassFileFormatVersion, Set<Location>>() {\n-                @Override\n-                public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                    return (cffv.compareTo(ClassFileFormatVersion.latest()) >= 0\n-                            && PreviewFeatures.isEnabled())\n-                            ? Location.SET_FIELD : Location.EMPTY_SET;\n-                }\n-            }),\n+                List.of()),\n@@ -398,15 +307,3 @@\n-              new Function<ClassFileFormatVersion, Set<Location>>() {\n-                  @Override\n-                  public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                      if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n-                          return Location.SET_SYNTHETIC_9;\n-                      else {\n-                          return\n-                              switch(cffv) {\n-                              case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n-                              case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n-                              default        -> Location.EMPTY_SET;\n-                              };\n-                      }\n-                  }\n-              }),\n+              List.of(Map.entry(RELEASE_8, Location.SET_SYNTHETIC_8),\n+                      Map.entry(RELEASE_7, Location.SET_SYNTHETIC_5),\n+                      Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -420,7 +317,1 @@\n-               new Function<ClassFileFormatVersion, Set<Location>>() {\n-                   @Override\n-                   public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                       return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                           Location.SET_CLASS_INNER_CLASS:\n-                           Location.EMPTY_SET;}\n-               }),\n+               List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -434,7 +325,1 @@\n-         new Function<ClassFileFormatVersion, Set<Location>>() {\n-             @Override\n-             public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                 return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n-                     Location.SET_CLASS_FIELD_INNER_CLASS:\n-                     Location.EMPTY_SET;}\n-         }),\n+         List.of(Map.entry(RELEASE_4, Location.EMPTY_SET))),\n@@ -447,12 +332,2 @@\n-             new Function<ClassFileFormatVersion, Set<Location>>() {\n-                 @Override\n-                 public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                     if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n-                         return Location.SET_MANDATED_9;\n-                     } else {\n-                         return (cffv == ClassFileFormatVersion.RELEASE_8) ?\n-                             Location.SET_METHOD_PARAM:\n-                             Location.EMPTY_SET;\n-                     }\n-                 }\n-             }),\n+             List.of(Map.entry(RELEASE_8, Location.SET_METHOD_PARAM),\n+                     Map.entry(RELEASE_7, Location.EMPTY_SET))),\n@@ -465,7 +340,1 @@\n-           new Function<ClassFileFormatVersion, Set<Location>>() {\n-               @Override\n-               public Set<Location> apply(ClassFileFormatVersion cffv) {\n-                   return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n-                       Location.SET_CLASS:\n-                       Location.EMPTY_SET;}\n-           })\n+           List.of(Map.entry(RELEASE_8, Location.EMPTY_SET))),\n@@ -480,2 +349,1 @@\n-    \/\/ Intentionally using Set rather than EnumSet since EnumSet is\n-    \/\/ mutable.\n+    \/\/ immutable\n@@ -483,2 +351,2 @@\n-    \/\/ Lambda to implement locations(ClassFileFormatVersion cffv)\n-    private final Function<ClassFileFormatVersion, Set<Location>> cffvToLocations;\n+    \/\/ historical locations up to a given version; immutable\n+    private final List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations;\n@@ -489,1 +357,1 @@\n-                       Function<ClassFileFormatVersion, Set<Location>> cffvToLocations) {\n+                       List<Map.Entry<ClassFileFormatVersion, Set<Location>>> historicalLocations) {\n@@ -493,1 +361,1 @@\n-        this.cffvToLocations = cffvToLocations;\n+        this.historicalLocations = Location.ensureHistoryOrdered(historicalLocations);\n@@ -497,1 +365,2 @@\n-     * {@return the corresponding integer mask for the access flag}\n+     * {@return the corresponding mask for the access flag}  The mask has\n+     * exactly one bit set and is in the range of {@code char}.\n@@ -504,1 +373,1 @@\n-     * {@return whether or not the flag has a directly corresponding\n+     * {@return whether or not this flag has a directly corresponding\n@@ -512,2 +381,5 @@\n-     * {@return kinds of constructs the flag can be applied to in the\n-     * latest class file format version}\n+     * {@return locations this flag can be applied to in the current class file\n+     * format version}\n+     * <p>\n+     * This method returns an empty set if this flag is not defined in\n+     * the current class file format version.\n@@ -520,2 +392,6 @@\n-     * {@return kinds of constructs the flag can be applied to in the\n-     * given class file format version}\n+     * {@return locations this flag can be applied to in the given class file\n+     * format version}\n+     * <p>\n+     * This method returns an empty set if this flag is not defined in\n+     * the given {@code cffv}.\n+     *\n@@ -526,6 +402,1 @@\n-        Objects.requireNonNull(cffv);\n-        if (cffvToLocations == null) {\n-            return locations;\n-        } else {\n-            return cffvToLocations.apply(cffv);\n-        }\n+        return Location.findInHistory(locations, historicalLocations, cffv);\n@@ -544,12 +415,5 @@\n-        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n-        for (var accessFlag : LocationToFlags.locationToFlags.get(location)) {\n-            int accessMask = accessFlag.mask();\n-            if ((mask & accessMask) != 0) {\n-                result.add(accessFlag);\n-                mask = mask & ~accessMask;\n-                if (mask == 0) {\n-                    break;      \/\/ no more mask bits\n-                }\n-            }\n-        }\n-        if (mask != 0) {\n+        var definition = findDefinition(location);\n+        int flagsMask = location.flagsMask();\n+        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n+        int unmatchedMask = mask & (~parsingMask);\n+        if (unmatchedMask != 0) {\n@@ -557,2 +421,2 @@\n-                                               Integer.toHexString(mask) +\n-                                               \" for location \" + location);\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location);\n@@ -560,1 +424,1 @@\n-        return Collections.unmodifiableSet(result);\n+        return new AccessFlagSet(definition, mask);\n@@ -577,15 +441,5 @@\n-        Set<AccessFlag> result = java.util.EnumSet.noneOf(AccessFlag.class);\n-        for (var accessFlag : AccessFlag.values()) {\n-            int accessMask = accessFlag.mask();\n-            if ((mask & accessMask) != 0) {\n-                var locations = accessFlag.locations(cffv);\n-                if (locations.contains(location)) {\n-                    result.add(accessFlag);\n-                    mask = mask & ~accessMask;\n-                    if (mask == 0) {\n-                        break;      \/\/ no more mask bits\n-                    }\n-                }\n-            }\n-        }\n-        if (mask != 0) {\n+        var definition = findDefinition(location);\n+        int flagsMask = location.flagsMask(cffv);\n+        int parsingMask = location == Location.METHOD ? flagsMask | ACC_STRICT : flagsMask; \/\/ flagMask lacks strictfp\n+        int unmatchedMask = mask & (~parsingMask);\n+        if (unmatchedMask != 0) {\n@@ -593,3 +447,2 @@\n-                                               Integer.toHexString(mask) +\n-                                               \" for location \" + location +\n-                                               \" for class file format version \" + cffv);\n+                    Integer.toHexString(unmatchedMask) +\n+                    \" for location \" + location);\n@@ -597,1 +450,1 @@\n-        return Collections.unmodifiableSet(result);\n+        return new AccessFlagSet(definition, mask);\n@@ -600,5 +453,4 @@\n-\n-     * A location within a class file where flags can be applied.\n-     *\n-     * Note that since these locations represent class file structures\n-     * rather than language structures many language structures, such\n+     * A location within a {@code class} file where flags can be applied.\n+     * <p>\n+     * Note that since these locations represent {@code class} file structures\n+     * rather than language structures, many language structures, such\n@@ -612,1 +464,6 @@\n-         * @jvms 4.1 The ClassFile Structure\n+         *\n+         * @see Class#accessFlags()\n+         * @see ClassModel#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.1 The {@code ClassFile} Structure\n@@ -614,1 +471,11 @@\n-        CLASS,\n+        CLASS(ACC_PUBLIC | ACC_FINAL | (PreviewFeatures.isEnabled() ? ACC_IDENTITY : ACC_SUPER) |\n+              ACC_INTERFACE | ACC_ABSTRACT |\n+              ACC_SYNTHETIC | ACC_ANNOTATION |\n+              ACC_ENUM | ACC_MODULE,\n+              List.of(Map.entry(RELEASE_8, \/\/ no module\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT |\n+                                ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM),\n+                      Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                                ACC_PUBLIC | ACC_FINAL | ACC_SUPER |\n+                                ACC_INTERFACE | ACC_ABSTRACT))),\n@@ -618,0 +485,4 @@\n+         *\n+         * @see Field#accessFlags()\n+         * @see FieldModel#flags()\n+         * @see Modifier#fieldModifiers()\n@@ -620,1 +491,7 @@\n-        FIELD,\n+        FIELD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+              ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+              ACC_TRANSIENT | ACC_SYNTHETIC | ACC_ENUM | (PreviewFeatures.isEnabled() ? ACC_STRICT : 0),\n+              List.of(Map.entry(RELEASE_4, \/\/ no synthetic, enum\n+                                ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                ACC_STATIC | ACC_FINAL | ACC_VOLATILE |\n+                                ACC_TRANSIENT))),\n@@ -624,0 +501,5 @@\n+         *\n+         * @see Executable#accessFlags()\n+         * @see MethodModel#flags()\n+         * @see Modifier#methodModifiers()\n+         * @see Modifier#constructorModifiers()\n@@ -626,1 +508,17 @@\n-        METHOD,\n+        METHOD(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+               ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+               ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+               ACC_ABSTRACT | ACC_SYNTHETIC,\n+               List.of(Map.entry(RELEASE_16, \/\/ had strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_BRIDGE | ACC_VARARGS | ACC_NATIVE |\n+                                 ACC_ABSTRACT | ACC_STRICT | ACC_SYNTHETIC),\n+                       Map.entry(RELEASE_4, \/\/ no bridge, varargs, synthetic\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT | ACC_STRICT),\n+                       Map.entry(RELEASE_1, \/\/ no strict\n+                                 ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                                 ACC_STATIC | ACC_FINAL | ACC_SYNCHRONIZED |\n+                                 ACC_NATIVE | ACC_ABSTRACT))),\n@@ -630,1 +528,6 @@\n-         * @jvms 4.7.6 The InnerClasses Attribute\n+         *\n+         * @see Class#accessFlags()\n+         * @see InnerClassInfo#flags()\n+         * @see Modifier#classModifiers()\n+         * @see Modifier#interfaceModifiers()\n+         * @jvms 4.7.6 The {@code InnerClasses} Attribute\n@@ -632,1 +535,8 @@\n-        INNER_CLASS,\n+        INNER_CLASS(ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED | (PreviewFeatures.isEnabled() ? ACC_IDENTITY : 0) |\n+                    ACC_STATIC | ACC_FINAL | ACC_INTERFACE | ACC_ABSTRACT |\n+                    ACC_SYNTHETIC | ACC_ANNOTATION | ACC_ENUM,\n+                    List.of(Map.entry(RELEASE_4, \/\/ no synthetic, annotation, enum\n+                            ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED |\n+                            ACC_STATIC | ACC_FINAL | ACC_INTERFACE |\n+                            ACC_ABSTRACT),\n+                            Map.entry(RELEASE_0, 0))), \/\/ did not exist\n@@ -636,1 +546,5 @@\n-         * @jvms 4.7.24 The MethodParameters Attribute\n+         *\n+         * @see Parameter#accessFlags()\n+         * @see MethodParameterInfo#flags()\n+         * @see Modifier#parameterModifiers()\n+         * @jvms 4.7.24 The {@code MethodParameters} Attribute\n@@ -638,1 +552,2 @@\n-        METHOD_PARAMETER,\n+        METHOD_PARAMETER(ACC_FINAL | ACC_SYNTHETIC | ACC_MANDATED,\n+                         List.of(Map.entry(RELEASE_7, 0))),  \/\/ did not exist\n@@ -641,2 +556,5 @@\n-         * Module location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module location.\n+         *\n+         * @see ModuleDescriptor#accessFlags()\n+         * @see ModuleAttribute#moduleFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -644,1 +562,2 @@\n-        MODULE,\n+        MODULE(ACC_OPEN | ACC_SYNTHETIC | ACC_MANDATED,\n+               List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -647,2 +566,5 @@\n-         * Module requires location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module requires location.\n+         *\n+         * @see ModuleDescriptor.Requires#accessFlags()\n+         * @see ModuleRequireInfo#requiresFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -650,1 +572,2 @@\n-        MODULE_REQUIRES,\n+        MODULE_REQUIRES(ACC_TRANSITIVE | ACC_STATIC_PHASE | ACC_SYNTHETIC | ACC_MANDATED,\n+                        List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -653,2 +576,5 @@\n-         * Module exports location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module exports location.\n+         *\n+         * @see ModuleDescriptor.Exports#accessFlags()\n+         * @see ModuleExportInfo#exportsFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -656,1 +582,2 @@\n-        MODULE_EXPORTS,\n+        MODULE_EXPORTS(ACC_SYNTHETIC | ACC_MANDATED,\n+                       List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n@@ -659,2 +586,5 @@\n-         * Module opens location\n-         * @jvms 4.7.25 The Module Attribute\n+         * Module opens location.\n+         *\n+         * @see ModuleDescriptor.Opens#accessFlags()\n+         * @see ModuleOpenInfo#opensFlags()\n+         * @jvms 4.7.25 The {@code Module} Attribute\n@@ -662,1 +592,3 @@\n-        MODULE_OPENS;\n+        MODULE_OPENS(ACC_SYNTHETIC | ACC_MANDATED,\n+                     List.of(Map.entry(RELEASE_8, 0))),  \/\/ did not exist\n+        ;\n@@ -689,2 +621,0 @@\n-        private static final Set<Location> SET_PUBLIC_1 =\n-            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n@@ -695,1 +625,1 @@\n-        private static final Set<Location> SET_SYNTHETIC_7 =\n+        private static final Set<Location> SET_SYNTHETIC_5 =\n@@ -702,1 +632,1 @@\n-              \/\/ Added as an access flag in 7\n+              \/\/ Added as an access flag in 5.0\n@@ -714,0 +644,94 @@\n+\n+        private final int flagsMask;\n+        private final List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks;\n+\n+        Location(int flagsMask,\n+                 List<Map.Entry<ClassFileFormatVersion, Integer>> historicalFlagsMasks) {\n+            this.flagsMask = flagsMask;\n+            this.historicalFlagsMasks = ensureHistoryOrdered(historicalFlagsMasks);\n+        }\n+\n+        \/\/ Ensures the historical versions are from newest to oldest and do not include the latest\n+        \/\/ These 2 utilities reside in Location because Location must be initialized before AccessFlag\n+        private static <T> List<Map.Entry<ClassFileFormatVersion, T>> ensureHistoryOrdered(\n+                List<Map.Entry<ClassFileFormatVersion, T>> history) {\n+            ClassFileFormatVersion lastVersion = ClassFileFormatVersion.latest();\n+            for (var e : history) {\n+                var historyVersion = e.getKey();\n+                if (lastVersion.compareTo(historyVersion) <= 0) {\n+                    throw new IllegalArgumentException(\"Versions out of order\");\n+                }\n+                lastVersion = historyVersion;\n+            }\n+            return history;\n+        }\n+\n+        private static <T> T findInHistory(T candidate, List<Map.Entry<ClassFileFormatVersion, T>> history,\n+                                           ClassFileFormatVersion cffv) {\n+            Objects.requireNonNull(cffv);\n+            for (var e : history) {\n+                if (e.getKey().compareTo(cffv) < 0) {\n+                    \/\/ last version found was valid\n+                    return candidate;\n+                }\n+                candidate = e.getValue();\n+            }\n+            return candidate;\n+        }\n+\n+        \/**\n+         * {@return the union of masks of all access flags defined for\n+         * this location in the current class file format version}\n+         * <p>\n+         * This method returns {@code 0} if this location does not exist in\n+         * the current class file format version.\n+         *\n+         * @since 25\n+         *\/\n+        public int flagsMask() {\n+            return flagsMask;\n+        }\n+\n+        \/**\n+         * {@return the union of masks of all access flags defined for\n+         * this location in the given class file format version}\n+         * <p>\n+         * This method returns {@code 0} if this location does not exist in\n+         * the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public int flagsMask(ClassFileFormatVersion cffv) {\n+            return findInHistory(flagsMask, historicalFlagsMasks, cffv);\n+        }\n+\n+        \/**\n+         * {@return the set of access flags defined for this location in the\n+         * current class file format version}  The set is immutable.\n+         * <p>\n+         * This method returns an empty set if this location does not exist\n+         * in the current class file format version.\n+         *\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags() {\n+            return new AccessFlagSet(findDefinition(this), flagsMask());\n+        }\n+\n+        \/**\n+         * {@return the set of access flags defined for this location in the\n+         * given class file format version}  The set is immutable.\n+         * <p>\n+         * This method returns an empty set if this location does not exist\n+         * in the given {@code cffv}.\n+         *\n+         * @param cffv the class file format version\n+         * @throws NullPointerException if {@code cffv} is {@code null}\n+         * @since 25\n+         *\/\n+        public Set<AccessFlag> flags(ClassFileFormatVersion cffv) {\n+            \/\/ implicit null check cffv\n+            return new AccessFlagSet(findDefinition(this), flagsMask(cffv));\n+        }\n@@ -716,35 +740,127 @@\n-    private static class LocationToFlags {\n-        private static Map<Location, Set<AccessFlag>> locationToFlags =\n-            Map.ofEntries(entry(Location.CLASS,\n-                                Set.of(PUBLIC, FINAL, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER),\n-                                       INTERFACE, ABSTRACT,\n-                                       SYNTHETIC, ANNOTATION,\n-                                       ENUM, AccessFlag.MODULE)),\n-                          entry(Location.FIELD,\n-                                PreviewFeatures.isEnabled() ?\n-                                        \/\/ STRICT_INIT should be included only if preview is enabled\n-                                        Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                            STATIC, FINAL, VOLATILE,\n-                                            TRANSIENT, SYNTHETIC, ENUM, STRICT_INIT) :\n-                                        Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                                STATIC, FINAL, VOLATILE,\n-                                                TRANSIENT, SYNTHETIC, ENUM)),\n-                          entry(Location.METHOD,\n-                                Set.of(PUBLIC, PRIVATE, PROTECTED,\n-                                       STATIC, FINAL, SYNCHRONIZED,\n-                                       BRIDGE, VARARGS, NATIVE,\n-                                       ABSTRACT, STRICT, SYNTHETIC)),\n-                          entry(Location.INNER_CLASS,\n-                                          Set.of(PUBLIC, PRIVATE, PROTECTED, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER),\n-                                                  STATIC, FINAL, INTERFACE, ABSTRACT,\n-                                                  SYNTHETIC, ANNOTATION, ENUM)),\n-                          entry(Location.METHOD_PARAMETER,\n-                                Set.of(FINAL, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE,\n-                                Set.of(OPEN, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_REQUIRES,\n-                                Set.of(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_EXPORTS,\n-                                Set.of(SYNTHETIC, MANDATED)),\n-                          entry(Location.MODULE_OPENS,\n-                                Set.of(SYNTHETIC, MANDATED)));\n+    private static AccessFlag[] createDefinition(AccessFlag... known) {\n+        var ret = new AccessFlag[Character.SIZE];\n+        for (var flag : known) {\n+            var mask = flag.mask;\n+            int pos = Integer.numberOfTrailingZeros(mask);\n+            assert ret[pos] == null : ret[pos] + \" \" + flag;\n+            ret[pos] = flag;\n+        }\n+        return ret;\n+    }\n+\n+    private static AccessFlag[] findDefinition(Location location) {\n+        return switch (location) {\n+            case CLASS -> CLASS_FLAGS;\n+            case FIELD -> FIELD_FLAGS;\n+            case METHOD -> METHOD_FLAGS;\n+            case INNER_CLASS -> INNER_CLASS_FLAGS;\n+            case METHOD_PARAMETER -> METHOD_PARAMETER_FLAGS;\n+            case MODULE -> MODULE_FLAGS;\n+            case MODULE_REQUIRES -> MODULE_REQUIRES_FLAGS;\n+            case MODULE_EXPORTS -> MODULE_EXPORTS_FLAGS;\n+            case MODULE_OPENS -> MODULE_OPENS_FLAGS;\n+        };\n+    }\n+\n+    private static final @Stable AccessFlag[] \/\/ Can use stable array and lazy init in the future\n+            CLASS_FLAGS = createDefinition(PUBLIC, FINAL, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER), INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM, MODULE),\n+              FIELD_FLAGS = PreviewFeatures.isEnabled() ? \/\/ Using Valhalla\n+              createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, VOLATILE, TRANSIENT, SYNTHETIC, ENUM, STRICT_INIT) :\n+              createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, VOLATILE, TRANSIENT, SYNTHETIC, ENUM),\n+            METHOD_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, STATIC, FINAL, SYNCHRONIZED, BRIDGE, VARARGS, NATIVE, ABSTRACT, STRICT, SYNTHETIC),\n+            INNER_CLASS_FLAGS = createDefinition(PUBLIC, PRIVATE, PROTECTED, (PreviewFeatures.isEnabled() ? IDENTITY : SUPER), STATIC, FINAL, INTERFACE, ABSTRACT, SYNTHETIC, ANNOTATION, ENUM),\n+            METHOD_PARAMETER_FLAGS = createDefinition(FINAL, SYNTHETIC, MANDATED),\n+            MODULE_FLAGS = createDefinition(OPEN, SYNTHETIC, MANDATED),\n+            MODULE_REQUIRES_FLAGS = createDefinition(TRANSITIVE, STATIC_PHASE, SYNTHETIC, MANDATED),\n+            MODULE_EXPORTS_FLAGS = createDefinition(SYNTHETIC, MANDATED),\n+            MODULE_OPENS_FLAGS = createDefinition(SYNTHETIC, MANDATED);\n+\n+    private static int undefinedMask(AccessFlag[] definition, int mask) {\n+        assert definition.length == Character.SIZE;\n+        int definedMask = 0;\n+        for (int i = 0; i < Character.SIZE; i++) {\n+            if (definition[i] != null) {\n+                definedMask |= 1 << i;\n+            }\n+        }\n+        return mask & ~definedMask;\n+    }\n+\n+    private static final class AccessFlagSet extends AbstractSet<AccessFlag> {\n+        private final @Stable AccessFlag[] definition;\n+        private final int mask;\n+\n+        \/\/ all mutating methods throw UnsupportedOperationException\n+        @Override public boolean add(AccessFlag e) { throw uoe(); }\n+        @Override public boolean addAll(Collection<? extends AccessFlag> c) { throw uoe(); }\n+        @Override public void    clear() { throw uoe(); }\n+        @Override public boolean remove(Object o) { throw uoe(); }\n+        @Override public boolean removeAll(Collection<?> c) { throw uoe(); }\n+        @Override public boolean removeIf(Predicate<? super AccessFlag> filter) { throw uoe(); }\n+        @Override public boolean retainAll(Collection<?> c) { throw uoe(); }\n+        private static UnsupportedOperationException uoe() { return new UnsupportedOperationException(); }\n+\n+        private AccessFlagSet(AccessFlag[] definition, int mask) {\n+            assert undefinedMask(definition, mask) == 0 : mask;\n+            this.definition = definition;\n+            this.mask = mask;\n+        }\n+\n+        @Override\n+        public Iterator<AccessFlag> iterator() {\n+            return new AccessFlagIterator(definition, mask);\n+        }\n+\n+        @Override\n+        public void forEach(Consumer<? super AccessFlag> action) {\n+            Objects.requireNonNull(action); \/\/ in case of empty\n+            for (int i = 0; i < Character.SIZE; i++) {\n+                if ((mask & (1 << i)) != 0) {\n+                    action.accept(definition[i]);\n+                }\n+            }\n+        }\n+\n+        private static final class AccessFlagIterator implements Iterator<AccessFlag> {\n+            private final @Stable AccessFlag[] definition;\n+            private int remainingMask;\n+\n+            private AccessFlagIterator(AccessFlag[] definition, int remainingMask) {\n+                this.definition = definition;\n+                this.remainingMask = remainingMask;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return remainingMask != 0;\n+            }\n+\n+            @Override\n+            public AccessFlag next() {\n+                int flagBit = Integer.lowestOneBit(remainingMask);\n+                if (flagBit == 0) {\n+                    throw new NoSuchElementException();\n+                }\n+                remainingMask &= ~flagBit;\n+                return definition[Integer.numberOfTrailingZeros(flagBit)];\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return Integer.bitCount(mask);\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+            if (Objects.requireNonNull(o) instanceof AccessFlag flag) {\n+                int bit = flag.mask;\n+                return (bit & mask) != 0 && definition[Integer.numberOfTrailingZeros(bit)] == flag;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return mask == 0;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":420,"deletions":304,"binary":false,"changes":724,"status":"modified"},{"patch":"@@ -484,0 +484,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -497,0 +499,2 @@\n+     * @see AccessFlag.Location#CLASS\n+     * @see AccessFlag.Location#INNER_CLASS\n@@ -510,0 +514,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -523,0 +528,1 @@\n+     * @see AccessFlag.Location#METHOD\n@@ -536,0 +542,1 @@\n+     * @see AccessFlag.Location#FIELD\n@@ -549,0 +556,1 @@\n+     * @see AccessFlag.Location#METHOD_PARAMETER\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Modifier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1471,1 +1471,1 @@\n-        return ((int) (seconds ^ (seconds >>> 32))) + (51 * nanos);\n+        return Long.hashCode(seconds) + (51 * nanos);\n","filename":"src\/java.base\/share\/classes\/java\/time\/Duration.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1374,1 +1374,1 @@\n-        return ((int) (seconds ^ (seconds >>> 32))) + 51 * nanos;\n+        return Long.hashCode(seconds) + 51 * nanos;\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2144,4 +2144,1 @@\n-        int yearValue = year;\n-        int monthValue = month;\n-        int dayValue = day;\n-        return (yearValue & 0xFFFFF800) ^ ((yearValue << 11) + (monthValue << 6) + (dayValue));\n+        return (year & 0xFFFFF800) ^ ((year << 11) + (month << 6) + day);\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDate.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -425,1 +425,1 @@\n-        return getChronology().hashCode() ^ ((int) (epDay ^ (epDay >>> 32)));\n+        return getChronology().hashCode() ^ Long.hashCode(epDay);\n","filename":"src\/java.base\/share\/classes\/java\/time\/chrono\/ChronoLocalDateImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-     *          supplying function is {@code null}\n+     *         supplying function is {@code null} or produces a {@code null} result\n","filename":"src\/java.base\/share\/classes\/java\/util\/Optional.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,5 +234,0 @@\n-    \/**\n-     * Updates module m to open all packages in the given sets.\n-     *\/\n-    void addOpensToAllUnnamed(Module m, Set<String> concealedPkgs, Set<String> exportedPkgs);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    static final int DEFAULT_CLASS_FLAGS = ClassFile.ACC_PUBLIC;\n+    static final int DEFAULT_CLASS_FLAGS = ClassFile.ACC_PUBLIC | ClassFile.ACC_SUPER;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,2 @@\n+        @JEP(number = 502, title = \"Stable Values\", status = \"Preview\")\n+        STABLE_VALUES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import jdk.internal.misc.CDS;\n@@ -340,0 +341,34 @@\n+    @SuppressWarnings(\"unchecked\")\n+    public void prepareForAOTCache() {\n+        \/\/ We are running the AOT assembly phase. The JVM has a single Java thread, so\n+        \/\/ we don't have any concurrent threads that may modify the map while we are\n+        \/\/ iterating its keys.\n+        \/\/\n+        \/\/ Also, the java.lang.ref.Reference$ReferenceHandler thread is not running,\n+        \/\/ so even if the GC has put some of the keys on the pending ReferencePendingList,\n+        \/\/ none of the keys would have been added to the stale queue yet.\n+        assert CDS.isSingleThreadVM();\n+\n+        for (ReferenceKey<K> key : map.keySet()) {\n+            Object referent = key.get();\n+            if (referent == null) {\n+                \/\/ We don't need this key anymore. Add to stale queue\n+                ((Reference)key).enqueue();\n+            } else {\n+                \/\/ Make sure the referent cannot be collected. Otherwise, when\n+                \/\/ the referent is collected, the GC may push the key onto\n+                \/\/ Universe::reference_pending_list() at an unpredictable time,\n+                \/\/ making it difficult to correctly serialize the key's\n+                \/\/ state into the CDS archive.\n+                \/\/\n+                \/\/ See aotReferenceObjSupport.cpp for more info.\n+                CDS.keepAlive(referent);\n+            }\n+            Reference.reachabilityFence(referent);\n+        }\n+\n+        \/\/ Remove all keys enqueued above\n+        removeStaleReferences();\n+    }\n+\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -276,0 +276,1 @@\n+        jdk.incubator.vector,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,12 @@\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.Signature;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ModuleEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.ClassFileFormatVersion;\n@@ -32,5 +44,3 @@\n-import java.lang.classfile.*;\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.constantpool.*;\n-import java.lang.classfile.attribute.*;\n-import static java.lang.classfile.ClassFile.*;\n+\n+import static java.lang.classfile.ClassFile.ACC_MANDATED;\n+import static java.lang.classfile.ClassFile.ACC_SYNTHETIC;\n@@ -69,2 +79,2 @@\n-    public void write(List<Attribute<?>> attrs) {\n-        write(attrs, null);\n+    public void write(List<Attribute<?>> attrs, ClassFileFormatVersion cffv) {\n+        write(attrs, null, cffv);\n@@ -73,1 +83,1 @@\n-    public void write(List<Attribute<?>> attrs, CodeAttribute lr) {\n+    public void write(List<Attribute<?>> attrs, CodeAttribute lr, ClassFileFormatVersion cffv) {\n@@ -76,1 +86,1 @@\n-                write(attr, lr);\n+                write(attr, lr, cffv);\n@@ -83,1 +93,1 @@\n-    public void write(Attribute<?> a, CodeAttribute lr) {\n+    public void write(Attribute<?> a, CodeAttribute lr, ClassFileFormatVersion cffv) {\n@@ -215,1 +225,1 @@\n-                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS)) {\n+                        for (var flag : maskToAccessFlagsReportUnknown(access_flags, AccessFlag.Location.INNER_CLASS, cffv)) {\n@@ -500,1 +510,1 @@\n-                        write(componentInfo.attributes());\n+                        write(componentInfo.attributes(), cffv);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,14 +28,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.net.URI;\n-import java.text.DateFormat;\n-import java.util.Collection;\n-import java.util.Date;\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.reflect.Modifier;\n-import java.util.ArrayList;\n-import java.util.LinkedHashSet;\n-\n@@ -43,0 +29,1 @@\n+\n@@ -45,4 +32,2 @@\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.ClassSignature;\n-import static java.lang.classfile.ClassFile.*;\n-import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassSignature;\n@@ -57,0 +42,18 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantValueEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.reflect.ClassFileFormatVersion;\n+import java.lang.reflect.Modifier;\n+import java.net.URI;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.EnumSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static java.lang.classfile.ClassFile.*;\n@@ -117,0 +120,10 @@\n+    protected ClassFileFormatVersion cffv() {\n+        var major = classModel.majorVersion();\n+        if (major < JAVA_1_VERSION || major > ClassFile.latestMajorVersion())\n+            return null;\n+        if (major >= JAVA_12_VERSION && classModel.minorVersion() != 0) {\n+            return null;\n+        }\n+        return ClassFileFormatVersion.fromMajor(major);\n+    }\n+\n@@ -254,1 +267,1 @@\n-            attrWriter.write(classModel.attributes());\n+            attrWriter.write(classModel.attributes(), cffv());\n@@ -271,1 +284,1 @@\n-    private static final ClassFile VERIFIER = ClassFile.of(ClassFile.ClassHierarchyResolverOption.of(\n+    private static final ClassFile VERIFIER = ClassFile.of(ClassHierarchyResolverOption.of(\n@@ -274,1 +287,1 @@\n-                public ClassHierarchyResolver.ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n+                public ClassHierarchyInfo getClassInfo(ClassDesc classDesc) {\n@@ -424,1 +437,1 @@\n-        writeModifiers(flagsReportUnknown(flags).stream().filter(fl -> fl.sourceModifier())\n+        writeModifiers(flagsReportUnknown(flags, cffv()).stream().filter(fl -> fl.sourceModifier())\n@@ -453,1 +466,1 @@\n-                    flagsReportUnknown(flags).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    flagsReportUnknown(flags, cffv()).stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n@@ -457,1 +470,1 @@\n-            attrWriter.write(f.attributes());\n+            attrWriter.write(f.attributes(), cffv());\n@@ -485,1 +498,1 @@\n-        for (var f : flagsReportUnknown(m.flags()))\n+        for (var f : flagsReportUnknown(m.flags(), cffv()))\n@@ -568,1 +581,1 @@\n-            for (var f : flagsReportUnknown(m.flags())) {\n+            for (var f : flagsReportUnknown(m.flags(), cffv())) {\n@@ -578,1 +591,1 @@\n-            attrWriter.write(m.attributes());\n+            attrWriter.write(m.attributes(), cffv());\n@@ -791,1 +804,1 @@\n-        var flagSet = flagsReportUnknown(flags);\n+        var flagSet = flagsReportUnknown(flags, cffv());\n@@ -804,1 +817,1 @@\n-        Set<AccessFlag> flagSet = flagsReportUnknown(flags);\n+        Set<AccessFlag> flagSet = flagsReportUnknown(flags, cffv());\n@@ -816,1 +829,1 @@\n-    private static Set<String> getModifiers(Set<java.lang.reflect.AccessFlag> flags) {\n+    private static Set<String> getModifiers(Set<AccessFlag> flags) {\n@@ -824,1 +837,1 @@\n-        return getFlags(flags.flagsMask(), flagsReportUnknown(flags));\n+        return getFlags(flags.flagsMask(), flagsReportUnknown(flags, cffv()));\n@@ -827,1 +840,1 @@\n-    private static Set<String> getFlags(int mask, Set<java.lang.reflect.AccessFlag> flags) {\n+    private static Set<String> getFlags(int mask, Set<AccessFlag> flags) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":46,"deletions":33,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -81,0 +81,5 @@\n+compiler\/c2\/TestVerifyConstraintCasts.java 8355574 generic-all\n+\n+compiler\/c2\/irTests\/TestFloat16ScalarOperations.java 8355708 linux-aarch64\n+compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java 8355708 linux-aarch64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -472,1 +472,2 @@\n- -runtime\/cds\/appcds\/LotsOfClasses.java \\\n+ -runtime\/cds\/appcds\/LotsOfJRTClasses.java \\\n+ -runtime\/cds\/appcds\/LotsOfSyntheticClasses.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1388,0 +1388,40 @@\n+    public static final String UMIN_VB = VECTOR_PREFIX + \"UMIN_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VB, \"UMinV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMIN_VS = VECTOR_PREFIX + \"UMIN_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VS, \"UMinV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMIN_VI = VECTOR_PREFIX + \"UMIN_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VI, \"UMinV\", TYPE_INT);\n+    }\n+\n+    public static final String UMIN_VL = VECTOR_PREFIX + \"UMIN_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMIN_VL, \"UMinV\", TYPE_LONG);\n+    }\n+\n+    public static final String UMAX_VB = VECTOR_PREFIX + \"UMAX_VB\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VB, \"UMaxV\", TYPE_BYTE);\n+    }\n+\n+    public static final String UMAX_VS = VECTOR_PREFIX + \"UMAX_VS\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VS, \"UMaxV\", TYPE_SHORT);\n+    }\n+\n+    public static final String UMAX_VI = VECTOR_PREFIX + \"UMAX_VI\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VI, \"UMaxV\", TYPE_INT);\n+    }\n+\n+    public static final String UMAX_VL = VECTOR_PREFIX + \"UMAX_VL\" + POSTFIX;\n+    static {\n+        vectorNode(UMAX_VL, \"UMaxV\", TYPE_LONG);\n+    }\n+\n@@ -1525,0 +1565,5 @@\n+    public static final String OPAQUE_TEMPLATE_ASSERTION_PREDICATE = PREFIX + \"OPAQUE_TEMPLATE_ASSERTION_PREDICATE\" + POSTFIX;\n+    static {\n+        duringLoopOpts(OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"OpaqueTemplateAssertionPredicate\");\n+    }\n+\n@@ -1631,1 +1676,1 @@\n-        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop Limit Check\");\n+        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop_Limit_Check\");\n@@ -1636,1 +1681,6 @@\n-        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled Loop\");\n+        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled_Loop\");\n+    }\n+\n+    public static final String AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE = PREFIX + \"AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE\" + POSTFIX;\n+    static {\n+        parsePredicateNodes(AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"Auto_Vectorization_Check\");\n@@ -2186,0 +2236,20 @@\n+    public static final String RISCV_VAND_NOTI_VX = PREFIX + \"RISCV_VAND_NOTI_VX\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTI_VX, \"vand_notI_vx\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTL_VX = PREFIX + \"RISCV_VAND_NOTL_VX\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTL_VX, \"vand_notL_vx\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTI_VX_MASKED = PREFIX + \"RISCV_VAND_NOTI_VX_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTI_VX_MASKED, \"vand_notI_vx_masked\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTL_VX_MASKED = PREFIX + \"RISCV_VAND_NOTL_VX_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTL_VX_MASKED, \"vand_notL_vx_masked\");\n+    }\n+\n@@ -2886,0 +2956,10 @@\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_LOOP_OPTS}\n+     * up to and including {@link CompilePhase#AFTER_LOOP_OPTS}.\n+     *\/\n+    private static void duringLoopOpts(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.AFTER_LOOP_OPTS, regex,\n+                                                                          CompilePhase.BEFORE_LOOP_OPTS,\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n+    }\n+\n@@ -2892,1 +2972,1 @@\n-        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \"[ ]*!jvms:\" + END;\n+        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \" \" + END;\n@@ -2895,1 +2975,1 @@\n-                                                                          CompilePhase.PHASEIDEALLOOP_ITERATIONS));\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":84,"deletions":4,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -192,0 +192,3 @@\n+java\/awt\/datatransfer\/ClipboardPerformanceTest.java 8029022 windows-all\n+java\/awt\/datatransfer\/HTMLTransferConsoleOutputTest.java 8237254 macosx-all\n+java\/awt\/datatransfer\/ImageTransferCrashTest.java 8237253 macosx-all\n@@ -749,1 +752,0 @@\n-java\/util\/logging\/LoggingDeadlock5.java       8354424 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,0 +171,15 @@\n+\n+        for (var location : AccessFlag.Location.values()) {\n+            try {\n+                location.flags(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flags(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+            try {\n+                location.flagsMask(null);\n+                throw new RuntimeException(\"Did not get NPE on \" + location + \".flagsMask(null)\");\n+            } catch (NullPointerException npe ) {\n+                ; \/\/ Expected\n+            }\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/BasicAccessFlagTest.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import static java.lang.reflect.AccessFlag.*;\n+\n@@ -59,1 +61,1 @@\n-@ExpectedClassFlags(\"[PUBLIC, FINAL, SUPER]\")\n+@ExpectedClassFlags({PUBLIC, FINAL, SUPER})\n@@ -91,2 +93,4 @@\n-            String actual = clazz.accessFlags().toString();\n-            if (!expected.value().equals(actual)) {\n+            Set<AccessFlag> base = EnumSet.noneOf(AccessFlag.class);\n+            Collections.addAll(base, expected.value());\n+            Set<AccessFlag> actual = clazz.accessFlags();\n+            if (!base.equals(actual)) {\n@@ -94,1 +98,1 @@\n-                                           \" expected \" + expected.value() +\n+                                           \" expected \" + base +\n@@ -113,1 +117,1 @@\n-        var expected = Set.of(AccessFlag.PUBLIC,\n+        var expected = Set.of(PUBLIC,\n@@ -142,2 +146,2 @@\n-            if (flags.contains(AccessFlag.PUBLIC))\n-                accessLevel = AccessFlag.PUBLIC;\n+            if (flags.contains(PUBLIC))\n+                accessLevel = PUBLIC;\n@@ -160,1 +164,1 @@\n-                                Set.of(AccessFlag.PUBLIC,\n+                                Set.of(PUBLIC,\n@@ -176,1 +180,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, INTERFACE, ABSTRACT})\n@@ -178,1 +182,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, INTERFACE, ABSTRACT})\n@@ -180,1 +184,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, STATIC, INTERFACE, ABSTRACT})\n@@ -182,1 +186,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -185,1 +189,1 @@\n-    @ExpectedClassFlags(\"[FINAL]\")\n+    @ExpectedClassFlags({FINAL})\n@@ -188,1 +192,1 @@\n-    @ExpectedClassFlags(\"[ABSTRACT]\")\n+    @ExpectedClassFlags({ABSTRACT})\n@@ -191,1 +195,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT, ANNOTATION]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT, ANNOTATION})\n@@ -194,1 +198,1 @@\n-    @ExpectedClassFlags(\"[PUBLIC, STATIC, FINAL, ENUM]\")\n+    @ExpectedClassFlags({PUBLIC, STATIC, FINAL, ENUM})\n@@ -201,1 +205,1 @@\n-    @ExpectedClassFlags(\"[PROTECTED, STATIC, ABSTRACT, ENUM]\")\n+    @ExpectedClassFlags({PROTECTED, STATIC, ABSTRACT, ENUM})\n@@ -210,1 +214,1 @@\n-    @ExpectedClassFlags(\"[PRIVATE, ABSTRACT]\")\n+    @ExpectedClassFlags({PRIVATE, ABSTRACT})\n@@ -213,1 +217,1 @@\n-    @ExpectedClassFlags(\"[STATIC, INTERFACE, ABSTRACT]\")\n+    @ExpectedClassFlags({STATIC, INTERFACE, ABSTRACT})\n@@ -218,1 +222,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT, ANNOTATION]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT, ANNOTATION})\n@@ -220,1 +224,1 @@\n-    String value();\n+    AccessFlag[] value();\n@@ -223,1 +227,1 @@\n-@ExpectedClassFlags(\"[INTERFACE, ABSTRACT]\")\n+@ExpectedClassFlags({INTERFACE, ABSTRACT})\n@@ -227,1 +231,1 @@\n-@ExpectedClassFlags(\"[FINAL, SUPER, ENUM]\")\n+@ExpectedClassFlags({FINAL, SUPER, ENUM})\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/ClassAccessFlagTest.java","additions":28,"deletions":24,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @summary Tests of AccessFlag.locations(ClassFileFormatVersion)\n+ * @summary Tests of AccessFlag.locations(ClassFileFormatVersion) and\n+ *          accessors on AccessFlag.Location\n@@ -82,0 +83,2 @@\n+        testFlagVersionConsistency();\n+        testLocationMaskFlagConsistency();\n@@ -248,1 +251,1 @@\n-            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_6) <= 0) {\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) < 0) {\n@@ -253,1 +256,2 @@\n-                        case RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n+                        case RELEASE_5, RELEASE_6,\n+                             RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n@@ -292,0 +296,43 @@\n+    private static void testFlagVersionConsistency() {\n+        for (var flag : AccessFlag.values()) {\n+            for (var location : AccessFlag.Location.values()) {\n+                if (location.flags().contains(flag) != flag.locations().contains(location)) {\n+                    throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                            \"flag %s and location %s are inconsistent for the latest version\", flag, location));\n+                }\n+            }\n+        }\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            for (var flag : AccessFlag.values()) {\n+                for (var location : AccessFlag.Location.values()) {\n+                    if (location.flags(cffv).contains(flag) != flag.locations(cffv).contains(location)) {\n+                        throw new RuntimeException(String.format(\"AccessFlag and Location inconsistency:\" +\n+                                \"flag %s and location %s are inconsistent for class file version %s\", flag, location, cffv));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void testLocationMaskFlagConsistency() {\n+        for (var location : AccessFlag.Location.values()) {\n+            if (!flagsAndMaskMatch(location.flags(), location.flagsMask())) {\n+                throw new RuntimeException(String.format(\"Flags and mask mismatch for %s\", location));\n+            }\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                if (!flagsAndMaskMatch(location.flags(cffv), location.flagsMask(cffv))) {\n+                    throw new RuntimeException(String.format(\"Flags and mask mismatch for %s in %s\", location, cffv));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static boolean flagsAndMaskMatch(Set<AccessFlag> flags, int mask) {\n+        for (var flag : flags) {\n+            int bit = flag.mask();\n+            if (((mask & bit) == 0))\n+                return false;\n+            mask &= ~bit;\n+        }\n+        return mask == 0;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,2 @@\n- * @test 8333748\n+ * @test\n+ * @bug 8333748 8349536\n","filename":"test\/langtools\/tools\/javap\/UndefinedAccessFlagTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.ref.Reference;\n@@ -28,0 +29,3 @@\n+import java.lang.reflect.InaccessibleObjectException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n@@ -573,0 +577,47 @@\n+  \/\/ Infrastructure for waitForReferenceProcessing()\n+  private static volatile Method waitForReferenceProcessingMethod = null;\n+\n+  private static Method getWaitForReferenceProcessingMethod() {\n+    Method wfrp = waitForReferenceProcessingMethod;\n+    if (wfrp == null) {\n+      try {\n+        wfrp = Reference.class.getDeclaredMethod(\"waitForReferenceProcessing\");\n+        wfrp.setAccessible(true);\n+        assert wfrp.getReturnType().equals(boolean.class);\n+        Class<?>[] ev = wfrp.getExceptionTypes();\n+        assert ev.length == 1;\n+        assert ev[0] == InterruptedException.class;\n+        waitForReferenceProcessingMethod = wfrp;\n+      } catch (InaccessibleObjectException e) {\n+        throw new RuntimeException(\"Need to add @modules java.base\/java.lang.ref:open to test?\", e);\n+      } catch (NoSuchMethodException e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+    return wfrp;\n+  }\n+\n+  \/**\n+   * Wait for reference processing, via Reference.waitForReferenceProcessing().\n+   * Callers of this method will need the\n+   * @modules java.base\/java.lang.ref:open\n+   * jtreg tag.\n+   *\n+   * This method should usually be called after a call to WhiteBox.fullGC().\n+   *\/\n+  public boolean waitForReferenceProcessing() throws InterruptedException {\n+    try {\n+      Method wfrp = getWaitForReferenceProcessingMethod();\n+      return (Boolean) wfrp.invoke(null);\n+    } catch (IllegalAccessException e) {\n+      throw new RuntimeException(\"Shouldn't happen, we call setAccessible()\", e);\n+    } catch (InvocationTargetException e) {\n+      Throwable cause = e.getCause();\n+      if (cause instanceof InterruptedException) {\n+        throw (InterruptedException) cause;\n+      } else {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"}]}